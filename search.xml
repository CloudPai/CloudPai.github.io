<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之三]]></title>
    <url>%2F2018%2F03%2F10%2F2018-03-10%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略3.2 判断对象是否存活3.2.1 引用计数算法 (Reference Counting) 非主流 3.2.2 可达性分析算法 (GC Roots Analysis) 主流用这个判断 在主流的商用程序语言中 (Java 和 C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，下图对象 object5, object6, object7 虽然有互相判断，但它们到 GC Roots 是不可达的，所以它们将会判定为是可回收对象。 在 Java 语言里，可作为 GC Roots 对象的包括如下几种： a. 虚拟机栈 (栈桢中的本地变量表) 中的引用的对象 b. 方法区中的类静态属性引用的对象 c. 方法区中的常量引用的对象 d. 本地方法栈中 JNI 的引用的对象 3.2.3 引用在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用：就是指在程序代码之中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。 3.2.4 finalize() 方法最终判定对象是否存活 即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑” 阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 标记的前提是对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链。1). 第一次标记并进行一次筛选。 筛选的条件是此对象是否有必要执行 finalize() 方法。 当对象没有覆盖 finalize 方法，或者 finzlize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”，对象被回收。 2). 第二次标记 如果这个对象被判定为有必要执行 finalize（）方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的 “执行” 是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象 finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。 Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模标记，如果对象要在 finalize（）中成功拯救自己—- 只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出 “即将回收” 的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。不过大家尽量避免使用这个方法流程图如下： 注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，因此第二段代码的自救行动失败了。 并且建议大家尽量避免使用它 GC 日志说明： GC 打印时间: [垃圾回收类型回收时间: [收集器名称: 年轻代回收前占用大小 -&gt;年轻代回收后占用大小 (年轻代当前容量), 年轻代局部 GC 时 JVM 暂停处理的时间] 堆空间 GC 前占用的空间 -&gt; 堆空间 GC 后占用的空间(堆空间当前容量),GC 过程中 JVM 暂停处理的时间]。 垃圾回收类型：分为 GC 和 Full GC. GC 一般为堆空间某个区发生了垃圾回收， Full GC 基本都是整个堆空间及持久代发生了垃圾回收，通常优化的目标之一是尽量减少 GC 和 Full GC 的频率。 收集器名称：一般都为收集器的简称或别名，通过收集器名称基本都能判断出那个区发生了 GC。 DefNew：年轻代（新生代）发生了 GC （若为 DefNew 可知当前 JVM 年轻代使用的串行收集器） ParNew：年轻代（新生代）发生了 GC （若为 ParNew 可知当前 JVM 年轻代使用了并行收集器） Tenured：老年代发生了 GC Perm：持久代发生了 GC 3.2.5回收方法区 Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价表” 一般比较低。 方法区中的垃圾回收主要是：废弃常量及无用类。判断常量是否废弃与判断堆中对象十分相似。例如，若常量池中存在字符串 “abc”，而系统中并没有任何 String 对象的值为“abc” 的，也就是没有任何对象引用它，那么它就可以被回收了。无用类的判定稍微复杂点，需要满足： 1). 该类的所有对象实例已经被回收，也就是 Java 堆中不存在该类的任何实例； 2). 加载该类的 ClassLoader 已经被回收； 3). 该类的类对象 Class 没有在任何地方被引用，无法使用反射来访问该类的方法。 当方法区中的类满足以上条件时，就可以对无用类进行回收了，这里说的仅仅是 “可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了各种配置，这里不多讲。 在大量使用反射、动态代理、CGLIB 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保存永久代不会溢出。 3.3 垃圾收集算法（本书重点中的重点）3.3.1 标记 - 清除算法 (Mark-Sweep) 最基础的收集算法。其它算法都是基于这种思路并对其不足进行改进而得到的。 标记 - 清除算法将垃圾回收分为两个阶段： ①. 标记阶段：首先标记出所有需要回收的对象。 如何标记，在上面的 “判断对象是否存活” 里有讲过 ②. 清除阶段：标记完成后，统一回收被标记的对象缺点： ①. 效率问题：标记清除过程效率都不高。 ②. 空间问题：标记清除之后会产生大量的不连续的内存碎片 (空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。） 3.3.2 复制算法 (Copying)为了解决 mark-sweep 算法的效率问题 算法思想： 1). 将现有的内存空间分为两块，每次只使用其中一块. 2). 当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。 3). 再把已使用过的内存空间一次清理掉。 优点： 1). 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 2). 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 2.3 缺点： 1). 内存减少为原来的一半，太浪费了。 2). 对象存活率较高的时候就要执行较多的复制操作，效率变低。 3). 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。2.4. 演进 并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 EdenSpace 和两块较小的 SurvivorSpace JavaHeap 内存回收模型（当前商业虚拟机大多使用此算法回收新生代） jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 3.3.3 标记 - 整理算法 (Mark-Compact) 由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 算法思想 1). 标记阶段：首先标记出所有需要回收的对象。与 “标记 - 清除” 一样 2). 让存活的对象向内存的一段移动。 3). 直接清理掉边界以外的内存。 由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记 - 清理算法或者标记整理算法。 3.3.4 代收集算法 (Generational Collecting) 当前的商业虚拟机的垃圾收集都采用，把 Java 堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。 3.4 HotSpot的算法实现3.4.1 枚举根节点可达性分析在执行 GC 的时候会停顿一下，如果引用关系不断变换的时候很难进行准确的可达性分析。目前虚拟机主要采用的是准确性 GC，虚拟机应该有办法知道哪些地方存着对象引用，在 HotSpot 的实现中，用一组叫做 OopMap 的数据结构来实现这个目的，在类加载完成后记录下对象内的数据类型与偏移量，在 JIT 编译 过程中记录下栈和寄存器中哪些位置是引⽤。 3.4.2 安全点导致 OopMap 变化的指令非常多，我们只在特定的地点做记录，我们把这些点叫做安全点，也就是说让所以线程（不包括 JNI 调用的线程）跑到最近的安全点再停顿下来，所以安全点不能让 GC 等待时间过长，也不能太频繁。这里我们分为两种方式 抢占式中断，在 GC 的时候停下所以线程，再让没有到安全点的跑到安全点，目前几乎没有虚拟机采用这种方式进行 GC 主动式中断，当 GC 需要中断线程的时候，在安全点上设置中断标 志，线程执⾏时主动轮询中断标志，发现标志为真时则主动中断挂 起线程。轮训标志的地方和安全点重合。 3.4.3 安全区域指线程在某⼀段代码⽚段中，引⽤关系不会发⽣变化，在这个区域中的任意点开始 GC 都是安全的。GC 的时候不用考虑处于安全区域的，当线程出安全区域的时候要检查是否 GC 完成了，在线程处于 blocked 或 sleep 状态⽆法跑到安全点时，采⽤安全区域可以避免 GC ⻓时间等待。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 3.5 垃圾收集器 如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。 GC实现目标: 准确、高效、低停顿、空闲内存规整. ————————–新生代收集器———————— 3.5.1 Serial 收集器Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在 JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。 特性：这个收集器是一个单线程的收集器，但它的 “单线程” 的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Stop The World 应用场景：Serial 收集器是虚拟机运行在 Client 模式下的默认新生代收集器。 优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 3.5.2 ParNew 收集器 特性：ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。 应用场景：ParNew 收集器是许多运行在 Server 模式下的虚拟机中首选的新生代收集器。 很重要的原因是：除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS 收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。 Serial 收集器 VS ParNew 收集器：ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。然而，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的有效利用还是很有好处的。 3.5.3 Parallel Scavenge 收集器 1. 特性： Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 应用场景：停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 对比分析： Parallel Scavenge 收集器 VS CMS 等收集器：Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为 “吞吐量优先” 收集器。 Parallel Scavenge 收集器 VS ParNew 收集器：Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别是它具有自适应调节策略。 GC 自适应的调节策略：Parallel Scavenge 收集器有一个参数 -XX:+UseAdaptiveSizePolicy。当这个参数打开之后，就不需要手工指定新生代的大小、Eden 与 Survivor 区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。 ————————- 老年代收集器—————————- 3.5.4 Serial Old 收集器 特性：Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记－整理算法。 应用场景： Client 模式Serial Old 收集器的主要意义也是在于给 Client 模式下的虚拟机使用。 Server 模式如果在 Server 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 3.5.5 Parallel Old 收集器 特性：Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记－整理” 算法。 应用场景：在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作）。由于老年代 Serial Old 收集器在服务端应用性能上的 “拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。直到 Parallel Old 收集器出现后，“吞吐量优先” 收集器终于有了比较名副其实的应用组合。 3.5.6 CMS(Concurrent Mark Sweep) 收集器 1. 特性： CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。 CMS 收集器是基于 “标记—清除” 算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤： 初始标记（CMS initial mark）初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要 “Stop The World”。 并发标记（CMS concurrent mark）并发标记阶段就是进行 GC Roots Tracing 的过程。 重新标记（CMS remark）重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要 “Stop The World”。 并发清除（CMS concurrent sweep）并发清除阶段会清除对象。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。 优点：CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。 缺点： CMS 收集器对 CPU 资源非常敏感其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU 数量 + 3）/ 4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大。 CMS 收集器无法处理浮动垃圾CMS 收集器无法处理浮动垃圾，可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为 “浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS 收集器会产生大量空间碎片CMS 是一款基于 “标记—清除” 算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。—————————新生代和老年代均适用——————— 3.5.7 G1 收集器 特性：G1（Garbage-First）是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。 并行与并发G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。 分代收集与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合与 CMS 的 “标记—清理” 算法不同，G1 从整体来看是基于 “标记—整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。 可预测的停顿这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。 在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。 G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 执行过程：G1 收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking）初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 3.5.8、GC 相关参数总结JVM 小工具在 ${JAVA_HOME}/bin / 目录下 Sun/Oracle 给我们提供了一些处理应用程序性能问题、定位故障的工具, 包含 bin 描述 功能 jps 打印 Hotspot VM 进程 VMID、JVM 参数、main()函数参数、主类名 / Jar 路径 jstat 查看 Hotspot VM 运行时信息 类加载、内存、GC[可分代查看]、JIT 编译 jinfo 查看和修改虚拟机各项配置 -flag name=value jmap heapdump: 生成 VM 堆转储快照、查询 finalize 执行队列、Java 堆和永久代详细信息 jmap -dump:live,format=b,file=heap.bin [VMID] jstack 查看 VM 当前时刻的线程快照: 当前 VM 内每一条线程正在执行的方法堆栈集合 Thread.getAllStackTraces()提供了类似的功能 javap 查看经 javac 之后产生的 JVM 字节码代码 自动解析.class文件, 避免了去理解 class 文件格式以及手动解析 class 文件内容 jcmd 一个多功能工具, 可以用来导出堆, 查看 Java 进程、导出线程信息、 执行 GC、查看性能相关数据等 几乎集合了 jps、jstat、jinfo、jmap、jstack 所有功能 jconsole 基于 JMX 的可视化监视、管理工具 可以查看内存、线程、类、CPU 信息, 以及对 JMX MBean 进行管理 jvisualvm JDK 中最强大运行监视和故障处理工具 可以监控内存泄露、跟踪垃圾回收、执行时内存分析、CPU 分析、线程分析… VM 常用参数整理 参数 描述 -Xms 最小堆大小 -Xmx 最大堆大小 -Xmn 新生代大小 -XX:PermSize 永久代大小 -XX:MaxPermSize 永久代最大大小 -XX:+PrintGC 输出 GC 日志 -verbose:gc - -XX:+PrintGCDetails 输出 GC 的详细日志 -XX:+PrintGCTimeStamps 输出 GC 时间戳 (以基准时间的形式) -XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息 -Xloggc:/path/gc.log 日志文件的输出路径 -XX:+PrintGCApplicationStoppedTime 打印由 GC 产生的停顿时间 垃圾收集器参数总结 参数 描述 -XX:+UseSerialGC Jvm 运行在 Client 模式下的默认值，打开此开关后，使用 Serial + Serial Old 的收集器组合进行内存回收 -XX:+UseParNewGC 打开此开关后，使用 ParNew + Serial Old 的收集器进行垃圾回收 -XX:+UseConcMarkSweepGC 使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收，Serial Old 作为 CMS 出现 “Concurrent Mode Failure” 失败后的后备收集器使用。 -XX:+UseParallelGC Jvm 运行在 Server 模式下的默认值，打开此开关后，使用 Parallel Scavenge + Serial Old 的收集器组合进行回收 -XX:+UseParallelOldGC 使用 Parallel Scavenge + Parallel Old 的收集器组合进行回收 -XX:SurvivorRatio 新生代中 Eden 区域与 Survivor 区域的容量比值，默认为 8，代表 Eden:Subrvivor = 8:1 -XX:PretenureSizeThreshold 直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 -XX:MaxTenuringThreshold 晋升到老年代的对象年龄，每次 Minor GC 之后，年龄就加 1，当超过这个参数的值时进入老年代 -XX:UseAdaptiveSizePolicy 动态调整 java 堆中各个区域的大小以及进入老年代的年龄 -XX:+HandlePromotionFailure 是否允许新生代收集担保，进行一次 minor gc 后, 另一块 Survivor 空间不足时，将直接会在老年代中保留 -XX:ParallelGCThreads 设置并行 GC 进行内存回收的线程数 -XX:GCTimeRatio GC 时间占总时间的比列，默认值为 99，即允许 1% 的 GC 时间，仅在使用 Parallel Scavenge 收集器时有效 -XX:MaxGCPauseMillis 设置 GC 的最大停顿时间，在 Parallel Scavenge 收集器下有效 -XX:CMSInitiatingOccupancyFraction 设置 CMS 收集器在老年代空间被使用多少后出发垃圾收集，默认值为 68%，仅在 CMS 收集器时有效，-XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSCompactAtFullCollection 由于 CMS 收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在 CMS 收集器时有效 -XX:+CMSFullGCBeforeCompaction 设置 CMS 收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与 UseCMSCompactAtFullCollection 参数一起使用 -XX:+UseFastAccessorMethods 原始类型优化 -XX:+DisableExplicitGC 是否关闭手动 System.gc -XX:+CMSParallelRemarkEnabled 降低标记停顿 -XX:LargePageSizeInBytes 内存页的大小不可设置过大，会影响 Perm 的大小，-XX:LargePageSizeInBytes=128m Client、Server 模式默认 GC 服务端 or 客户端 新生代 GC 方式 老年代和持久代 GC 方式 Client Serial 串行 GC Serial Old 串行 GC Server Parallel Scavenge 并行回收 GC Parallel Old 并行 GC Sun/oracle JDK GC 组合方式 参数 新生代 GC 方式 老年代和持久代 GC 方式 -XX:+UseSerialGC Serial 串行 GC Serial Old 串行 GC -XX:+UseParallelGC Parallel Scavenge 并行回收 GC Serial Old 并行 GC -XX:+UseConcMarkSweepGC ParNew 并行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时，采用 Serial Old 串行 GC -XX:+UseParNewGC ParNew 并行 GC Serial Old 串行 GC -XX:+UseParallelOldGC Parallel Scavenge 并行回收 GC Parallel Old 并行 GC -XX:+UseConcMarkSweepGC -XX:+UseParNewGC Serial 串行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时采用 Serial Old 串行 GC 常用的收集器组合 服务器 31 新生代 GC 策略 老年老代 GC 策略 说明 组合 1 Serial Serial Old Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。 组合 2 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。 组合 3 ParNew CMS 使用-XX:+UseParNewGC选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用 - XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用 ParNew GC 策略。 组合 4 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。 组合 5 Parallel Scavenge Serial Old Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 组合 6 Parallel Scavenge Parallel Old Parallel Old 是 Serial Old 的并行版本 组合 7 G1GC G1GC -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启；-XX:MaxGCPauseMillis =50 #暂停时间目标；-XX:GCPauseIntervalMillis =200 #暂停间隔目标；-XX:+G1YoungGenSize=512m #年轻代大小；-XX:SurvivorRatio=6 #幸存区比例 1. 与串行回收器相关的参数 -XX:+UseSerialGC: 在新生代和老年代使用串行回收器。 -XX:+SuivivorRatio: 设置 eden 区大小和 survivor 区大小的比例。 -XX:+PretenureSizeThreshold: 设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。 -XX:MaxTenuringThreshold: 设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。 2. 与并行 GC 相关的参数 -XX:+UseParNewGC: 在新生代使用并行收集器。 -XX:+UseParallelOldGC: 老年代使用并行回收收集器。 -XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。 -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。 -XX:GCTimeRatio: 设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 -XX:+UseAdaptiveSizePolicy: 打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 3. 与 CMS 回收器相关的参数 -XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS + 串行收集器。 -XX:+ParallelCMSThreads: 设定 CMS 的线程数量。 -XX:+CMSInitiatingOccupancyFraction: 设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。 -XX:+UseFullGCsBeforeCompaction: 设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 -XX:+CMSClassUnloadingEnabled: 允许对类元数据进行回收。 -XX:+CMSParallelRemarkEndable: 启用并行重标记。 -XX:CMSInitatingPermOccupancyFraction: 当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是 - XX:+CMSClassUnloadingEnabled 激活了)。 -XX:UseCMSInitatingOccupancyOnly: 表示只在到达阈值的时候，才进行 CMS 回收。 -XX:+CMSIncrementalMode: 使用增量模式，比较适合单 CPU。 4. 与 G1 回收器相关的参数 -XX:+UseG1GC：使用 G1 回收器。 -XX:+UnlockExperimentalVMOptions: 允许使用实验性参数。 -XX:+MaxGCPauseMills: 设置最大垃圾收集停顿时间。 -XX:+GCPauseIntervalMills: 设置停顿间隔时间。 5. 其他参数 -XX:+DisableExplicitGC: 禁用显示 GC。 3.6 内存分配与回收策略（重点） Java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题： 1). 给对象分配内存; 2). 回收分配给对象的内存。关于回收内存这一点请参考如下文章 内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为 “对象游离”。 Jvm 怎么判断对象可以回收了？ 1). 对象没有引用，被判定为 “死亡”（并不是这个对象被赋值为 null 之后就一定被标记为可回收） 2). 作用域发生未捕获异常 3). 程序在作用域正常执行完毕 4). 程序执行了 System.exit() 5). 程序发生意外终止（被杀进程等） 对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 分配前请先了解下新年代和老年代： 3.6.1 对象优先在 Eden 分配 前面的文章介绍过 Hotspot 虚拟机新生代内存布局及算法： a. 将新生代内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。b. 每次使用 Enden 和其中一块 Survivor。c. 当回收时，将 Eden 和使用中的 Sruvivor 中还存的对象一次性复制到另一块 Survivor；d. 然后清理掉 Eden 和使用过的 Survivor 空间；e. 后面就使用 Eden 和另一块 Survivior 空间，重复步骤 3。 默认 Eden：Survivor=8：1，即每次可以使用 90% 的空间，只有一块 Survivor 空间被浪费。 大多数情况下，对象在 Eden 区中分配；当 Eden 区没有足够空间进行分配时，JVM 将会发起一次 MinorGC(新生代 GC)。MinorGC 时，如果发现存活的对象无法全部放入 Servivor 空间，只好通过分配机制提前转入熬年老代中。 3.6.2 大对象直接进入老年代 所谓的大对象是指：需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。 大对象对虚拟机的内存分配来说就是一个坏消息，比遇到一个大对象更加坏的消息就是：遇到一群 “朝生夕灭” 的 “短命大对象”。 经常出现大对象容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。 所以我们应该避免创建大对象； “-XX:PretenureSizeThreshold”： 可以设置这个阀值，大于这个参数值的对象直接在年老代中分配。 默认为 0(无效)，且只对 Serail 和 ParNew 两款收集器有效。 如果需要使用该参数，可以考虑 ParNew+CMS 组合 长期存活的对象将进入年老代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.3 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.4 动态对象年龄判定JVM 为了更好适应不同程序，不是永远要求等到 MaxTenuringThreshold 参数设置的年龄。 如果在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，大于或等于该年龄的对象就可以直接进入年老代。 3.6.5 空间分配担保 当 Survivor 空间不够用时，需要依赖其他内存 (年老代) 进行分配担保(Hanle Promotion) 分配担保流程如下： a. 在发生 Minor GC 之前，JVM 首先检查年老代最大可用的连续空间是否大于新生所有对象的空间。 b. 如果大于，那么可以确保 Minor GC 是安全的。 c. 如果不大于，则 JVM 查看 HandlePromotionFailure 值是否允许担保失败。 d. 如果允许，将尝试进行一次 Minor GC，但这是有风险对的； e. 如果小于或 HandlePromotionFailure 值不允许冒险，那这时，要改为进行一次 Full GC； 尝试 Minor GC 的风险 – 担保失败： 因为尝试 Minor GC 前，无法知道存货的对象大小，所以使用历次晋升到年老代对象的平均大小作为经验值。 加入尝试的 Minor GC 最终存活的对象远远高于经验值的话，会导致担保失败 (Handle Promotion Failure)。 失败后只有重新发起一次 Full GC，这绕了一个大圈，代价较高。 但一般还是要开启 HandlePromotionFailure，避免 Full GC 过于频繁，而且担保失败概率还是比较低的。 JDK1.6 之后，JVM 代码中已经不再使用 HandlePromotionFailure 参数了… 规则变为： 只要年老代最大可用的连续空间大于新生所有对象的空间或历次晋升到年老代对象的平均大小，就会进行 MinorGC，否则进行 Full GC。 即年老代最大可用的连续空间小于新生所有对象空间时，不在检查 HandlePromotionFailure，而是直接检查历次晋升熬年老代对象的平均大小。 参考：http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/https://www.jianshu.com/p/50d5c88b272dhttp://blog.csdn.net/simba_cheng/article/details/78223010]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM参数调优]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09%2F</url>
    <content type="text"><![CDATA[常见配置汇总堆设置-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值.如:为3,表示年轻代与年老代比值为1:3,年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:3,表示Eden:Survivor=3:2,一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数.并行收集线程数.-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式.适用于单CPU情况.-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数. 参考：http://blog.csdn.net/xiajian2010/article/details/17376157]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理数据可视化]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[根据现有数据集进行数据表查询集构建： galleryproduction 左外联结 production: 1234SELECT scratch_api_production.id,scratch_api_galleryproduction.production_id,scratch_api_production.nameFROM scratch_api_galleryproduction LEFT JOIN scratch_api_productionON scratch_api_production.id=scratch_api_galleryproduction.production_id production 左外联结 user: 1234SELECT scratch_api_production.author_id,scratch_api_user.baseuser_ptr_id,scratch_api_user.sex,scratch_api_user.gradeFROM scratch_api_production LEFT JOIN scratch_api_user ON scratch_api_production.author_id=scratch_api_user.baseuser_ptr_id 再构建三联表： galleryproduction左外联结production左外联结user 三表联结查询模版： 123select username,psw,gname,tel from (t1 left join t2 on t1.t1_id=t2.t1_id) left join t3 on t1.t1_id=t3.t1_id 我根据业务流程实现的sql查询： 查询某专题活动中的所有信息 1234SELECT *FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 然后使用阿里云的DataV进行数据可视化: 需要对接接口： 查询点赞数最多作品排行： 12345SELECT scratch_api_production.like,scratch_api_production.name FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' AND sex='男'ORDER BY scratch_api_production.like DESC 查询结果集中的男女人数 123456789SELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='男'UNIONSELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='女' 查询某专题活动学校参与度排名 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询某专题活动中的参与性别 1234SELECT scratch_api_user.sexFROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' 查询年级占比 123456SELECT scratch_api_user.grade ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.grade is not NULLGROUP BY scratch_api_user.gradeorder by count(*) desc 查询学校占比 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询作品提交时间 12345SELECT DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") as '日期',count(*) as '当日投票数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1GROUP BY DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") 把地址转换成经纬度不要方，利用高德地图经纬度快速查询工具可以轻松地把任何地址转换成经纬度，可具体到门牌号喔，工具地址： 控制台 | 高德开放平台 | 高德地图API 义乌市首届Scratch编程周实时数据状态网址(动态页面):http://datav.aliyun.com/share/07ef37b235d9763bd364f344912d1a05大数据可视化说明:大数据屏幕：1920*1080（可修改）最高实时更新频率：1min/次正常显示的预览效果参考（静态截图）：http://p4lmrb1gp.bkt.clouddn.com/15205615855957.jpg本机上如果不是上述参考效果请检查自己的浏览器如下:推荐电脑上预览：首选谷歌 Chrome 浏览器版本56以上，其他浏览器则需更新至最新版并开启极速（chrome内核）模式，不要使用IE浏览器，否则无法正常显示。不推荐手机上预览：无法按默认长宽比例展示 预览效果：]]></content>
      <tags>
        <tag>数据可视化</tag>
        <tag>DataV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之二]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-05-2%2F</url>
    <content type="text"><![CDATA[第二章 Java内存区域与内存溢出异常&amp;实战第二章结构： Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。参考：https://www.jianshu.com/p/989c90f339b9 2.2 运行时数据区域具体见下图： 2.2.1 程序计数器（Program Counter Register） 概述：该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有：因为 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。2.无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法（本地方法，一个调用非Java代码的接口），这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。（个人理解：参考C++理解是：当线程中调用native方法的时候，当前线程应当会被阻塞，重新启动一个新的线程，那么计数器为空则不会影响新线程的计数器，相互独立。当前线程应当会被阻塞，直到另外一个线程执行结束。当然参数也会被保留） 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 我们经常将 Java 内存分为堆内存（Heap）和栈内存（Stack），这种分法中所指的栈就是 Java 虚拟机栈，或者说是虚拟机栈中 局部变量表 部分。 概述：描述 Java 方法执行的内存模型，每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆是所有线程共享的一块内存区域，由虚拟机启动时创建，堆得唯一目的就是存储对象的实例。几乎所有的对象实例都在改内存区域分配，但是随着JIT编译器（即时编译）的发展及逃逸分析技术（分析指针的动态范围）的发展，栈上分配、标量替换导致堆分配不那么“绝对”了。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开。 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 内存：Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。 相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对 常量池的回收 和 类型的卸载。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。Class 文件中除了有类的（版本、字段、方法、接口）等描述信息外，还有一项信息就是常量池。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2.3 HotSpot 虚拟机对象探秘 这一部分内容将以 HotSpot 虚拟机和常用的内存区域 Java 堆为例，阐述对象分配、布局和访问的全过程。 2.3.1 对象的创建 概述：Java 是一门面向对象的编程语言，在 Java 程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个 new 关键字而已，而在虚拟机中对象的创建则分为以下几个步骤。 虚拟机遇到New指令 首先检查指令的参数能否在常量池中定位到一个类的符号引用 检查这个符号引用对应的类是否已被加载、解析、初始化过 没有加载，则需要先加载 为新生对象分配内存区域（指针碰撞&amp;空闲列表） 线程安全（方案1：对分配内存空间的动作同步；方案2：本地线程分配缓冲 TLAB） 对对象进行必要的设置 调用init方法 类加载概述：虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存概述：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。 分配方式：1.指针碰撞（Bump the Pointer）：假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。2.空闲列表（Free List）：如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。 同步控制概述：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。 方案一：对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。 初始化概述：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。作用：保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。 对象头（Object Header）概述：接下来，虚拟机要为对象头数据进行设置。（e.g. 对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄） init概述：在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，&lt;init&gt; 方法还没有被执行，所有的字段还为零值。 一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，将对象按照我们的意愿进行初始化，这样一个真正的对象才算完全产生。 2.3.2对象的内存布局 在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域。 对象头（存放对象自身的运行时数据&amp;类型指针） 实例数据 对齐填充 2.3.2.1 对象头（Header） HotSpot 虚拟机的对象头包括两部分信息，存储自身的运行时数据的（Mark Word） 和 类型指针。 第一部分：Mark Word 概述：用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。 内存：对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 HotSpot 虚拟机对象头 Mark Word 表如下 第二部分：类型指针 概述：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 Reminder并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。(见2.2.3节) 数组对象：如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。 2.3.2.2 实例数据（Instance Data） 概述：这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 存储顺序：这部分的存储顺序会受到虚拟机 分配策略参数（FieldsAllocationStyle） 和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles =&gt; ints =&gt; shorts/chars =&gt; bytes/booleans =&gt; oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 2.3.2.3 对齐填充（Padding） 概述：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 原理：由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 2.3.3 对象的访问定位 概述：建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以 对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有两种。 句柄访问：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。 直接指针：Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示。 比较：1.句柄访问：使用句柄访问的最大好处就是 reference 中存储的是 稳定的 句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。2.指针访问：使用直接访问最大的好处就是 速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 Sun HotSpot 使用的是第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 2.4 实战：OutOfMemoryError 异常 在 Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemory（OOM）异常的可能。 目的：1. 通过代码验证 Java 虚拟机规范中描述的各个运行时区域的存储内容。2. 遇到实际的内存溢出异常时，能根据异常的信息快速判断哪个区域的内存溢出。3. 了解什么样的代码可能会导致这些区域内存溢出，并了解如何处理。 VM Args 设置 Eclipse IDE：Debug Configurations =&gt; Java Application =&gt; YoungGenGC =&gt; Arguments 中的 VM arguments 中进行书写（书写参数以 - 开头，以空格分隔）。 控制台：直接跟在 Java 命令之后书写。 本人运行在 Mac 系统下，使用 IDEA 进行配置，步骤如下所示👇。 1\. 打开 Run Configurations（⌃ + ⌥ + R 选择 0 ）或者（⌘ + ⇧ + A 输入 run 选择 run…）。 2\. 点击并打开 VM options。 3\. 写入虚拟机启动参数。 4.Apply 并 Run。 2.4.1 - Java 堆溢出 概述：Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 测试环境： 12345-verbose:gc-Xms20M // 最小 GC 启动-Xmx20M // 最大 GC 启动-XX:+PrintGCDetails // 打印设置-XX:SurvivorRatio=8 // 存活对象比率 测试代码：HeapOOM 123456789101112131415import java.util.*;public class Main &#123; private static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 运行结果： 1java.lang.OutOfMemoryError: Java heap space 分析：Java 堆内存的 OOM 异常是时机应用中常见的内存溢出异常情况。当出现 Java 堆内存溢出时，异常堆栈信息 java.lang.OutOfMemoryError 会跟着进一步提示 Java heap space。 解决方式 堆转储快照：要解决这个区域的异常，一般的手段是先通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。 内存泄露：进一步通过工具查看泄露对象到 CG Roots 的引用链，于是就能找到内存泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄露代码的位置。 内存溢出：如果不存在泄露，换句话说，就是内存中的对象确实都必须还活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对象看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗。 2.4.2 - 虚拟机栈和本地方法栈溢出 概述：由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoos 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 -Xss 参数设定。关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常。 异常类型 发生条件 StackOverflowError 线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。 OutOfMemoryError 无法申请到足够的内存时抛出该异常。 这里把异常分为两种情况，看似更加严谨，但却存在一些相互重叠的地方：方栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事的两种描述而已。 2.4.2.1 - StackOverflowError 测试环境：在此测试中，将测试范围限制于单线程中操作。1. 使用 -Xss 参数减少栈内存容量，结果抛出 SOF 异常，异常出现时输出的堆栈深度相应缩小。2. 定义了大量的本地变量，增大此方法栈中本地变量表长度。结果抛出 SOF 异常时输出的堆栈深度相应缩小。 JavaVMStackSOF: 1234567891011121314151617181920212223242526//JavaVMStackSOF//VM Args: -Xss160k // 栈内存容量public class Main &#123; public static class JavaVMStackSOF&#123; private int stackLength = 1; public void stackLeak() &#123; stackLength++; stackLeak(); &#125; &#125; public static void main(String[] args) throws Throwable &#123; JavaVMStackSOF oom = new JavaVMStackSOF(); try &#123; oom.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println("Stack length: " + oom.stackLength); throw e; &#125; &#125;&#125; 运行结果 123Exception in thread &quot;main&quot; Stack length: 771java.lang.StackOverflowError at Main$JavaVMStackSOF.stackLeak(Main.java:8) 分析：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者确切地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 理解：操作系统分配给每个进程的内存是有限的，虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存 -Xms（最大堆容量） -MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略不计。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈瓜分了。每个线程分配到的栈容量越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。 探索：出现 SOF 异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的）达到 1000 - 2000 完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果建立过多线程导致内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过 减少最大堆 和 减少栈容量 来换更多的线程。 2.4.2.2 - OutOfMemoryError 测试环境注意：下面这块代码运行有风险，书上说在windows上会造成系统假死，我在mac上的IDEA上运行，也死机了，测了两次，都导致了系统假死。 JavaVMStackOOM 12345678910111213141516171819202122232425262728293031323334public class Main &#123; //VM Args: -Xss2M // 栈内存容量 //测试代码：创建线程导致内存溢出异常 private void dontStop() &#123; while (true) &#123; &#125; &#125; // 循环开启线程 public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; Main oom = new Main(); oom.stackLeakByThread(); &#125;&#125; 运行结果（参考别人的结果） 1Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread 这是mac死机时用手机照的(；′⌒`)cpu已爆表 2.4.3 - 方法区和运行时常量池溢出 概述：由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。 脑补：String.intern() 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。在 JDK1.6 以及之前的版本中，由于常量池分配在永久代内，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小名，从而间接限制其中常量池的容量。 2.4.3.1 - OutOfMemoryError 测试环境 12-XX:PermSize=10M // 方法区最小值-XX:MaxPermSize=10M // 方法区最大值 测试代码RuntimeConstantPoolOOM 12345678910111213package com.company.bupt;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); long i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 在JDK1.6上运行结果如下： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at com.company.bupt.Main.main(Main.java:10) 分析：从运行结果中可以看到，运行时常量池溢出，在 OutOfMemoryError 后面跟随的提示信息是 PermGen space，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分。 在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为JVM实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。 在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。 在JDK8之前的HotSpot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域。永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过‑XX:MaxPermSize 设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误(OOM)。 参考：Java永久代去哪儿了 http://www.infoq.com/cn/articles/Java-PERMGEN-Removed 总结：java jdk1.7中的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域，如果想了解更多可以参考：http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.htmlhttp://blog.csdn.net/zhyhang/article/details/17246223/ 在JDK1.7上测试 模拟了一下常量池的oom，突然发现设置的参数-XX:PermSize=10M -XX:MaxPermSize=10M不管用了，同时发现内存一直在上升，当上升到一个极值就会趋于平稳，然后再过一段时间会报：Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded这个异常是当GC的时间超过总运行时间的98%才会报的，是为了防止GC占用的时间过长。 运行结果 2.4.3.2 - String 常量池测试 使用 JDK1.7 运行这段程序就不会得到相同的结果，while 循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响。 测试代码RuntimeConstantPoolOOM1 12345678910111213package com.company.bupt;public class Main &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); &#125;&#125; 分析： JDK1.6：会得到两个 false，而在 JDK1.7 中运行，会得到一个 true 和一个 false。产生差异的原因是：是 JDK1.6 中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由 StringBuilder 创建的字符串实例在 Java 堆上，所以必然不是同一个引用，将返回 false JDK1.7：intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此 intern() 返回的引用和由 StringBuilder 创建的那个字符串实例是同一个。对 str2 比较返回 false 是因为 java 这个字符串在执行 StringBuilder.toString() 之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而 计算机软件 这个字符串是首次出现的，因此返回 true。 JVM启动的时候已经写到常量池里了，类似的还有’main’、’int’、’float’。参考：https://www.jianshu.com/p/b98851899f37 JDK1.7上测试结果: 12345678String str1 = new StringBuilder("jc").append( "vc" ).toString();//JVM不会自动加载jcvc，所以这个jcvc是首次出现的，返回true System.out.println(str1.intern()==str1); String str2=new StringBuilder("mai").append( "n" ).toString(); //main已经被自动加载了，不是首次出现，所以返回false System.out.println(str2.intern()==str2); String str3=new StringBuilder("in").append( "t" ).toString(); //flase System.out.println(str3.intern()==str3); String str4=new StringBuilder("flo").append( "at" ).toString(); //flase System.out.println(str4.intern()==str4); JDK1.6上测试上述代码则全返回是false 2.4.3.3 - 方法区溢出 方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本思路就是运行时产生大量的类去填满方法区，直到溢出。另外的，直接使用 Java SE API 也可以动态产生类（如反射时的 GeneratedConstorAccessor 和动态代理等）。 但在本次试验使用CGLIB直接操作字节码运行时，生成大量的动态类。 值得注意的是，当前主流的很多框架 如：Spring,Hibernate对类进行增强时，都会使用到类似CGLIB这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载如内存。 注意：项目必须引入asm-6.0.jar和cglib-3.2.6.jar，需要手动寻找引入 测试代码JavaMethodAreaOOM： 1234567891011121314151617181920212223242526272829303132333435package com.company.bupt;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 测试方法区内存溢出 * 方法区保存的是Class的相关信息，如类名，字段描述符等等，在这里使用cglib来创建大量的类信息来使方法区内存溢出 * * 异常信息为：java.lang.OutOfMemoryError: PermGen space * VM args:-XX:PermSize=10m -XX:MaxPermSize=10m * @author Tim * */public class Main &#123; public static void main(String[] args) &#123; while(true)&#123; Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125; static class OOMObject&#123; &#125;&#125; 以下是我的实测情况： 下列是在JDK1.6上测试得到的： 下列是在JDK1.7上测试得到的： 2.4.3.4 - 总结 方法区溢出是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量的 Class 的应用中，需要特别注意类的回收情况。这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 2.4.4 - 本机直接内存溢出 概述：DirectMemory 容量可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（-Xmx指定）一样，下面的测试代码越过了 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）。因为，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 unfase.allocateMemory()。 测试代码DirectMemoryOOM 12345678910111213141516171819202122package com.company.bupt;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M * @author zzm */public class Main &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 运行结果参考： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryErrorat sun.misc.Unsafe.allocateMemory(Native Method)at org.fenixsoft.oom.DMOOM.main(DMOOM.java:20) 以下是JDK1.6上实测：程序并没有报错 分析：由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看到明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，那就可以考虑检查一下是不是这方面的原因。 参考:https://www.jianshu.com/p/989c90f339b9]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之一]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-06%2F</url>
    <content type="text"><![CDATA[全书核心分布： 第一章 走近JAVA1.6 实战：自己编译JDK(已成功编译) 疑问： 将JDK源码进行编译是做了点什么？是将JDK中的.java文件编译成.class文件吗？ JDK中包含开发工具包和JVM，作者编译完JDK以后，用的还是原来包中的JVM吗？ 我们平常使用的JDK，例如JDK1.7中，里面的文件是以.java形式存在的还是以.class形式存在的，或者是以.java形式存在，要用的时候再用JVM去编译的?答： JDK是c/c++写的, 编译就是把JDK编译成可以运行的状态, 可运行的意思是指可以编译运行.java文件. 而一般情况下官方下载的JDK都是已经帮你编译好而已. 作者可以用自己编译的, 也可以用官方编译好的. 这个要看书中的说明了 JDK是c/c++写的, 里面和其他c++程序没什么区别, windows下面是一堆dll和一堆exe. 你说的.java文件是JDK的功能之一, 帮你编译java文件成class, JVM是运行class文件的容器 一 环境： 操作系统：CentOS6.8计划编译的jdk: openjdk7现成的jdk: java version “1.6.0_25”(Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode))jdk6下载链接如果你当前的系统版本不是这个，没关系，只要下载上述版本安装rpm（默认安装到/usr/java路径下）(不必配置环境变量)即可 二 编译前准备工作如下123456yum install -y mercurialyum install -y ant ant-nodepsyum install -y libX11* libX*yum install -y libXi-devel libXtst-devel libXt-devel freetype* yum install -y alsa-lib-devel cups-develyum install -y gcc gcc-c++ 三 下载计划编译的openjdk7(jdk源码网站：http://hg.openjdk.java.net/jdk7u/ ， 你值得收藏) 1234hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-devcd jdk7u-devchmod 755 get_source.sh ./get_source.sh 四 编译4.1准备好编译环境相关参数解释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export LANG=C#Bootstrap JDK的安装路径，必须设置export ALT_BOOTDIR=/export/servers/jdk1.6.0_25/#允许自动下载依赖export ALLOW_DOWNLOADS=true#并行编译的线数，设置和cpu的数量一致即可export HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2#比较本次build出来的映像与先前版本的差异，这对我们来说没有意义，export SKIP_COMPARE_IMAGES=true#使用预编译头文件，不加这个编译会更慢一些export USE_PRECOMPILED_HEADER=true#指定要编译的内容export BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=falseexport BUILD_JAXWS=falseexport BUILD_CORBA=false#要编译的版本#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueexport DEBUG_NAME=debug#可以避开javaws和浏览器Java插件之类的部分buildBUILD_DEPLOY=false#设置成false就不会build出包装包，因为包装包里有些奇怪的依赖#但是即使不build出它也已经能得到完整的JDK映像，所以还是别build它好了BUILD_INSTALL=false#编译结果存放的路径export ALT_OUTPUTDIR=/root/temp/jdk7u WARNINGS_ARE_ERRORS=#卸载环境变量，避免诡异的事情发生unset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS#make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 好了，我们将上面一系列的环境变量，创建环境文件VAR来统一管理吧vi VAR 12345678910111213141516171819202122232425262728293031323334353637383940export LANG=Cexport ALT_BOOTDIR=/usr/java/jdk1.6.0_25export ALLOW_DOWNLOADS=trueexport HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2export SKIP_COMPARE_IMAGES=trueexport USE_PRECOMPILED_HEADER=trueexport BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=trueexport BUILD_JAXWS=trueexport BUILD_CORBA=true#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueBUILD_DEPLOY=falseBUILD_INSTALL=falseexport ALT_OUTPUTDIR=/home/cloudpai/app/jdk7u #export CORBA_DIST=$ALT_OUTPUTDIR/corba/dist#export JAXP_DIST=$ALT_OUTPUTDIR/jaxp/dist#export JAXWS_DIST=$ALT_OUTPUTDIR/jaxws/distunset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS 使之生效. VAR 4.2检测设置是否全部正确make sanity当看到如下输出时则表示成功 123456789101112131415161718192021Build Machine Information: build machine = workstation.centos.vbirdBuild Directory Structure: CWD = /root/temp/jdk7u-dev TOPDIR = . LANGTOOLS_TOPDIR = ./langtools JAXP_TOPDIR = ./jaxp JAXWS_TOPDIR = ./jaxws CORBA_TOPDIR = ./corba HOTSPOT_TOPDIR = ./hotspot JDK_TOPDIR = ./jdk ……Sanity check passed. 4.3真正开始编译make (命令等同于make all) 成功的标志 12345678910111213#-- Build times ----------Target all_product_buildStart 2018-03-06 21:03:26End 2018-03-06 21:20:0900:02:02 corba00:05:08 hotspot00:00:16 jaxp00:00:19 jaxws00:08:34 jdk00:00:23 langtools00:16:43 TOTAL-------------------------make[1]: Leaving directory `/home/cloudpai/Downloads/jdk7u-dev' 4.4测试自己编译出来的jdk吧正确编译后，可以执行如下命令验证 1234[cloudpai@hadoop000 bin]$ /home/cloudpai/app/jdk7u/j2sdk-image/bin/java -versionopenjdk version "1.7.0-internal"OpenJDK Runtime Environment (build 1.7.0-internal-cloudpai_2018_03_06_21_03-b00)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) OK，到些就大功告成了。 五 可能出现的错误/usr/bin/ld: cannot find -lX11 collect2: ld returned 1 exit status解决办法yum install -y libX11* /bin/sh: line 0: cd: /NOT-SET/re/jdk/1.7.0/promoted/latest/binaries/linux-amd64: No such file or directory make[4]: *** [/root/temp/jdk7u/tmp/java/components_imported] Error 1解决办法VAR文件确认执行过了，正确的姿势. VAR 参考博客：http://blog.csdn.net/hl_java/article/details/76691321 由1.6.4得我们得到了自己的虚拟机1.7.0-internal-cloudpai_2018_03_06_21_03-b00 现在我们要将JVM运行起来： 在大多数时候，如果我们并不关心JDK中HotSpot虚拟机以外的内容，只想单独编译 HotSpot虚拟机的话（例如调试虚拟机时，每次改动程序都执行整个OpenJDK的Makefile，速 度肯定受不了），那么使用hotspot/make目录下的Makefile进行替换即可，其他参数设置与前 面是一致的，这时候虚拟机的输出结果存放在build/hotspot/outputdir/bsd_amd64_compiler2目录(在不同机器上，最后一个目录名称会有所差别，bsd表示Mac OS系统（内核为 FreeBSD），amd64表示是64位JDK（32位是x86），compiler2表示是Server VM（Client VM表 示是compiler1）。) 中，进入后可以见到以下几个目录。 在路径：/home/cloudpai/app/jdk7u/hotspot/outputdir/linux_amd64_compiler2 12345678910[cloudpai@hadoop000 linux_amd64_compiler2]$ lltotal 48drwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 debugdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 fastdebugdrwxrwxr-x. 7 cloudpai cloudpai 4096 Mar 6 21:06 generateddrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 jvmgdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 optimizeddrwxrwxr-x. 3 cloudpai cloudpai 20480 Mar 6 21:11 productdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 profiled-rw-rw-r--. 1 cloudpai cloudpai 1778 Mar 6 21:06 shared_dirs.lst 这些目录对应了不同的优化级别，优化级别越高，性能自然就越好，但是输出代码与源 码的差距就越大，难于调试，具体哪个目录有内容，取决于make命令后面的参数。 在编译结束之后、运行虚拟机之前，还要手工编辑目录下的env.sh文件，这个文件由编 译脚本自动产生，用于设置虚拟机的环境变量，里面已经发布了“JAVA_HOME、 CLASSPATH、HOTSPOT_BUILD_USER”3个环境变量， 还要在在product下边（看网上都是在jvmg下边，可我的jvmg下边没有gamma，不知道什么情况）的env.sh下加入： 123456export JAVA_HOME=/usr/java/jdk1.6.0_25export PATH=$JAVA_HOME/bin:$PATHLD_LIBRARY_PATH=.:$&#123;JAVA_HOME&#125;/jre/lib/amd64/native_threads:$&#123;JAVA_HOME&#125;/jre/lib/amd64:export LD_LIBRARY_PATH 然后执行以下命令启动虚拟机（这时的启动器名为gamma），输出版本号。 12source ./env.sh ./gamma -version 最后运行虚拟机成功！！ 12345[cloudpai@hadoop000 product]$ ./gamma -versionUsing java runtime at: /usr/java/jdk1.6.0_25/jrejava version &quot;1.6.0_25&quot;Java(TM) SE Runtime Environment (build 1.6.0_25-b06)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) 1.6.5 JVM 在IDE工具中进行源码调试注意这里是源码调试，是对1.6.4中计划编译的jdk源码进行操作: openjdk7（centos上的存储路径是/home/cloudpai/Downloads/jdk7u-dev） centos下安装NetBeans集成开发环境 官网下载地址：http://download.netbeans.org/netbeans/7.0.1/final/bundles/netbeans-7.0.1-ml-cpp-linux.sh 以netbeans-7.0.1-ml-cpp-linux.sh为例 首先，到NetBeans网站（http://netbeans.org/）上下载最新版的NetBeans（网上说7.0.1版本没问题，我就直接用这个版本了），下载时选择支持 C/C++开发的那个版本。 注意：不要在本地远程用SecureCRT输入命令啊，要在Linux下用终端输入命令： 1sh netbeans-7.0.1-ml-cpp-linux.sh 这样就会在centos中弹出安装界面： 配置好安装路径和IDE使用的java环境（注意与编译时的环境一致） 安装好以后，桌面上就有了NetBeans： 后续操作可以参考这个博客：使用Netbeans开发调试OpenJDK中的HotSpothttp://blog.csdn.net/pange1991/article/details/51580969 CentOS下安装NetBeans集成开发环境http://www.itboth.com/d/QriYZj/centos-java-windows-linux-netbeans]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java1.8 帮助文档]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05-1%2F</url>
    <content type="text"><![CDATA[java 1.6 帮助文档中文链接：http://download.csdn.net/detail/qw599186875/9608735英文Java1.8 帮助文档英文中文 – 谷歌版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-google/下载链接：http://download.csdn.net/detail/qw599186875/9802192]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站架构技能图谱（Java版）]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05%2F</url>
    <content type="text"><![CDATA[每天都要有进步！]]></content>
      <tags>
        <tag>java</tag>
        <tag>图谱</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[workflow工作流]]></title>
    <url>%2F2018%2F03%2F04%2F2018-03-04%2F</url>
    <content type="text"><![CDATA[工作流脚本测试：测试成功~晚安~~]]></content>
      <tags>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scratch编程探究]]></title>
    <url>%2F2018%2F03%2F02%2F2018-03-02%2F</url>
    <content type="text"><![CDATA[转载自：儿童使用Scratch编程时，与程序员在工作中的编程有什么区别？ - Milo Yip的回答 - 知乎https://www.zhihu.com/question/42012520/answer/310430799]]></content>
      <tags>
        <tag>scratch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018拜年祭单品]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01-1%2F</url>
    <content type="text"><![CDATA[2018拜年祭单品传送门： 1.【逆浪千秋】av20204904 2.【如果我的一生只需要做一件事 — Bilibili Zeitgeist 2017】av20203478 3.【梦想小剧场-遗失的宝物】av20203610 4.【口袋竞技场ー冰与铁之歌】av20203938 5.【相遇day by day】av20203945 6.【上海一夜】av20204014 7.【神鬼恋曲】av20204051 8.【UP主的奇妙冒险之勇者传说】av20204517 9.【我的破烂之掀起波澜】av20204332 10.【palette】av20204403 11.【广告高手】av20204701 12.【滑稽君大冒险】av20204534 13.【journey】av20204614 14.【全靠我勤劳的手】av20204705 15.【演奏区的偷心计划】av20204824 16.【乒乓帝国】av20205319 17.【鬼畜大战之真相黎明】av20205316 18.【如何翻拍一个CG短片】av20205314 19.【坦克大战】av20205375 20.【星空花火】av20203411 彩蛋【举头三尺有神明】av16201808]]></content>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blogs 上的标签tag参数]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01%2F</url>
    <content type="text"><![CDATA[12345678910---title: Mac终端翻墙tags: Linux&amp;Unixcategories: Linux&amp;Unixcomments: trueabbrlink: 745a6d7date: 2016-11-24 18:26:33updated: 2016-11-24 18:26:33copyright: true---]]></content>
      <tags>
        <tag>mac</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要进行的改进]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[TODO： 测试git的备份功能 学习 Alfred workflow实现打开重启任意应用 脚本实现清理浏览器缓存]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28-1%2F</url>
    <content type="text"><![CDATA[创建的仓库：默认master克隆的仓库：默认origin（源） git add 开始跟踪一个新文件git status显示git状态 git commit提交更新 git diff：比较工作区和缓存区的不同。git diff --cached：比较缓存区和仓库的不同。 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 git push [remote-name] [branch-name] 如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：git push origin master git log显示从最近到最远的提交日志。包含每个提交的SHA1校验和、作者的名字和邮箱、提交时间以及提交说明等。gitk使用图形化工具查阅提交历史 git commit --amend修改最后一次提交 git reset HEAD &lt;file&gt;...取消已经暂存的文件 Git 分支git branch创建一个新的分支 git commit -a -m &#39;made other changes&#39; 提交分支git mergetool调用一个可视化的合并工具并引导你解决所有冲突 git学习链接]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac使用]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28%2F</url>
    <content type="text"><![CDATA[Mac系统如何显示隐藏文件？以”.”开头的隐藏文件如何在MAC系统下显示？ 答：Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 显示 隐藏文件 1234567#显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool trueosascript -e 'tell application "Finder" to quit'#不显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool falseosascript -e 'tell application "Finder" to quit']]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog通过git备份与恢复的最优操作]]></title>
    <url>%2F2018%2F02%2F28%2Fblog%E9%80%9A%E8%BF%87git%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%9A%84%E6%9C%80%E4%BC%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引言：Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。特别简洁。 关于搭建的流程 创建仓库，http://CrazyMilk.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库； 在本地http://CrazyMilk.github.io 仓库新建一个文件后，进入文件中。在该文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 关于日常的改动流程 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的http://CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 其实只要把hexo和需要每个插件都写入到package.json中（平常安装时加–save参数会自动写入），那么git clone下来之后，只要一句npm install就能装好hexo和所有的依赖，开箱即用 ^_^ 迁移源码库一开始用了该方法，后来意识到备份到github分支的博客源码也是public的，后来改为备份到开源中国git私有库了 参考1：GitHub Pages + Hexo搭建博客参考2：使用hexo，如果换了电脑怎么更新博客？ - CrazyMilk的回答 - 知乎]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客样式改进杂记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8D%9A%E5%AE%A2%E6%A0%B7%E5%BC%8F%E6%94%B9%E8%BF%9B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[评论区样式修改：文件位置：themes/next/source/css/_common/components/comments.styl 修改内容： 1234.comments &#123; background white; opacity:0.8;&#125; 移动端不加载背景图一点优化，移动端不加载背景图。在_layout.swig底部L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});标签前，加上移动端浏览器内核判断语句，当为PC端浏览器时，加载背景js 123456789101112131415161718192021222324252627&lt;!--移动端判断，是否引入背景--&gt;&lt;script&gt;var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123;//移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase() &#125; if(browser.versions.mobile || browser.versions.ios || browser.versions.android || browser.versions.iPhone || browser.versions.iPad)&#123; &#125;else&#123; document.write("&lt;script type=\'text/javascript\' src=\'/js/src/particle.js\'&gt;&lt;\/script&gt;"); &#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🎵记录点滴生活]]></title>
    <url>%2F2018%2F02%2F24%2F%F0%9F%8E%B5%E8%AE%B0%E5%BD%95%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[记录点滴生活《BINGBIAN病变》歌曲不错，曲调有些忧伤 [00:00.21]罗之豪 - BINGBIAN病变 [00:01.87]词：Cubi/Fi9 [00:02.76]曲：Jurrivh [00:03.72]混音：Fi9 [00:19.36][02:01.33][03:09.30]有天我睡醒看到我的身边没有你 [00:23.52][02:05.53][03:13.50]在我的右边是你曾经喜欢的玩具 [00:27.75][02:09.76][03:17.66]可当我站起身来在房间里寻找你 [00:32.04][02:14.00][03:21.93]留下的只有带着你味道的一封信 [00:36.50][02:18.48][03:26.35]就在昨天还一起看我们的照片 [00:40.47][02:22.48][03:30.46]可现在让我感觉像烂剧里的主演 [00:44.74][02:26.71][03:34.69]为什么这种事情会发生在我身边 [00:48.97][02:31.00][03:38.92]是不是老天没能看到对你的疯癫 [00:54.46]还想着 创造你的宇宙 [00:56.53]但现在 已经被我清空 [00:58.57]你让我 整个人都冰冻 [01:00.68]还怎么 再次为你心动 [01:02.88]Wake me 不是你的意愿 [01:04.97]离开我 开始新的起点 [01:07.12]可能我 还会对你贪恋 [01:09.30]谁让你 曾经让我疯癫 [01:11.18]疯癫 那也是过去的画面 [01:14.54]看往后的几天 [01:16.72]我猜你也不会出现 [01:18.78]我回想这几年 [01:20.93]就像是要命的病变 [01:23.16]你可能听不见 [01:25.16]来自我对你的挂念 [01:27.53]可能有点累 [01:28.85]觉得对不对这是第几次在为你宿醉 [01:31.98]没了我肩膀 [01:33.08]你在谁身旁买的礼物变成了灰 [01:35.99]曾经我多想 [01:37.25]把你变漂亮看着别人羡慕你的模样 [01:40.50]没关系有小熊陪着你看月亮 [01:44.40]我已经看到跟你断电的过程 [01:46.96]但我假装看不见 [01:48.76]是不是要我变得像个厉鬼 [01:50.96]才能进入你的世界 [01:52.95]为什么不说再见 [01:54.31]我猜你应该是不小心的忘记 [01:57.04]都无所谓也有点累 [01:59.09]也可以开始新的记忆 [02:35.19]我不能够停止啊 [02:37.43]这些年我对你的疯癫 [02:39.49]戴上那条围巾吧 [02:41.59]在每个寒风刺骨的冬天 [02:43.92]每次送你回家你抱着我 [02:45.63]不经意间又触碰到你的手 [02:48.10]你穿裙子眨眼睛 望着我 [02:50.52]让我每次心动的瞬间 [02:52.49]那条十字路口 [02:54.39]始终有你身上的气味 [02:57.00]车水马龙过后的路灯下的身影 [03:00.10]又会是谁 [03:00.83]他想说我真的 [03:02.01]喜欢你但是每次欲言又闭嘴 [03:05.57]那时荒唐的男孩 [03:07.64]又浑浊了几岁 var ap = new APlayer({ element: document.getElementById("aplayer1"), narrow: false, autoplay: false, showlrc: 2, music: { title: "BINGBIAN病变", author: "Cubi / Fi9江澈", url: "http://p4lmrb1gp.bkt.clouddn.com/Cubi,Aydo$,BRGang%20-%20BINGBIAN%E7%97%85%E5%8F%98.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/BINGBIAN%E7%97%85%E5%8F%98.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的blog自动发布脚本]]></title>
    <url>%2F2018%2F02%2F23%2Fmac%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[遇到的坑： -bash: ./install.sh: /bin/bash: bad interpreter: Operation not permitted出现这个问题的主要原因是：-rwxrwxrwx@ 文件的属性最后带个@，这个@代表的是更多的一些属性，具体含义不太清楚，但有它就是执行不了解决：可以用这个命令来去除这个属性：xattr -d com.apple.quarantine ./*后来进入目录发现目录下面的文件还是带有@属性，我们到根目录加一个-r就好了：xattr -d -r com.apple.quarantine ./* 我的blog自动发布脚本:blog_publish.sh 123456789#!/bin/bashsay "blogs updating"cd /Users/pailiu/Library/Mobile\ Documents/iCloud~com~coderforart~iOS~MWeb/Documents/mweb_documents_library/Bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo dsay "blogs published"rm -rf /Users/pailiu/Library/Caches/Google/Chrome/Profile\ 1/*open -a "/Applications/Google Chrome.app" 'http://cloudpai.site/'# hexo server]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客插入音频、视频]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为了避免后期外链失效，可以将视频、音频图片等资源传至七牛云等cdn服务器上，从中获取外链。 常用排版：居中： 1&lt;center&gt; &lt;/center&gt; 插入图片：有尺寸要求时： 1&lt;img src="http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg" width="80%" height="80%"&gt; 无尺寸要求时快速插入（md格式）： 1![](http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg) 插入音乐网易云音乐外链获取：见官网修改博客音乐播放器歌曲路径：/Blog/themes/hexo-theme-next-master/layout/_macro/sidebar.swig qq音乐外链获取： http://www.qqmusic.cc/插入音频播放器代码： 1&lt;audio src="http://mp3.qqmusic.cc/yq/211758246.mp3" controls="controls"&gt;&lt;/audio&gt; hexo-tag-aplayer：博客中插入自定义音乐 安装成功后，在 Markdown 文档中添加比如添加如下代码使用hexo-tag-aplayer 参数12345678title ：音乐标题author：音乐作者url：音乐文件网址picture_url：可选，音乐图片网址narrow：可选，窄款式autoplay：可选，自动播放音乐，不支持移动浏览器width:xxx：可选，前缀width:，播放器宽度（默认值：100％）lrc:xxx：可选，前缀lrc:，LRC文件url 示例: 1&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125; [ti:春意红包 (Vocaloid Ver.)] [ar:乐正绫/心华/洛天依] [al:春意红包] [by:] [offset:0] [00:00.29]春意红包 (Vocaloid Ver.) - 乐正绫/心华/洛天依 [00:00.89]词：泠鸢YOUSA [00:01.05]曲：Wing翼 [00:01.18]编曲：Wing翼 [00:01.95]小麦面包饺 喜色上眉梢 [00:05.78]点柳翠 画春晓 [00:08.85] [00:10.08]找旧样铜板穿一串吉兆 [00:14.20]把春意装满红包 [00:17.86] [00:37.11]廊下的小阿妹摇头晃脑 [00:41.25]望着瓦上的碎嘴家雀 [00:44.76] [00:45.56]问它们春日的鸟儿 何时才能到 [00:49.81] [00:50.35]穿街搜巷沿路找 [00:53.26] [00:53.76]看邻家的老人摘下毡帽 [00:57.88]虽是脱去冬衣还尚早 [01:01.89]宰鸡鸭 起炉灶 揭开自家陈酿 [01:07.91]偷偷尝一瓢 [01:09.81] [01:13.01]大鬼叫 小鬼叫 邪祟吓得跌倒 [01:16.73]该用什么清扫 锣鼓鞭炮 [01:20.58] [01:21.30]小孩儿 快来瞧 别再人堆胡闹 [01:24.85] [01:25.43]只有听话乖巧 来年才能长高 [01:29.08] [01:30.21]和纸浆 采朱砂 攒一摞春联叠好 [01:34.25]剪金花 染红料 [01:36.24]再糊一个四方小包 [01:37.98] [01:38.56]对花调 抄童谣 写一串吉祥安好 [01:42.51]扶正了封面 画上春来到 [01:46.14]一片翠色葱葱明快又跳跃 [01:50.13]几瓣海棠山茶花儿相映笑 [01:54.29]再蘸浓墨潦草添只燕子闹 [01:58.48]红绳绕 来封一个大红包 [02:02.83] [02:19.34]找一张晒烫的板凳歇脚 [02:22.80] [02:23.58]看你眼下又布满操劳 [02:27.59]编织橙黄蓝绿把烦恼全部忘掉 [02:32.00] [02:32.65]抬手捧一把红枣 [02:34.70] [02:35.97]骗怕生的小妹点灯睡觉 [02:40.05]会有鬼祟在夜晚来到 [02:43.55] [02:44.13]她慌张 我偷笑 连说不怕不怕 [02:50.16]让我去赶跑 [02:52.62] [02:55.34]左搭肩 右帮腔 [02:57.19]挤兑迟来的大忙人 [02:59.59]礼物未到 人怎能到 [03:03.02] [03:03.62]表嫂吵 大舅闹 连天地喳喳叫 [03:07.03] [03:07.71]我装作听不到 盘坐把碗沿敲 [03:11.35] [03:12.37]踩高跷 抓花包 撩一挂红衣鞭炮 [03:16.52]打年糕 串辣椒 [03:18.59]抹花我的胭脂粉膏 [03:20.67]侃八卦 讲小道 等杯中茶酒减少 [03:24.79]将手上红包 塞进你棉袄 [03:28.05] [03:28.60]你送吉祥如意 幸福快来到 [03:32.57]我送百年顺遂 不怕被火烧 [03:36.57]再求来年生辰 添一分美貌 [03:40.74]拱手摇 同鞠一躬对眼笑 [03:44.55] [03:47.29]小麦面包饺 喜色上眉梢 [03:51.29]点柳翠 画春晓 [03:55.45]找旧样铜板穿一串吉兆 [03:59.58]把春意赠与明朝 [04:03.12] [04:04.16]左搭肩 右帮腔 热闹话不见少 [04:08.24]你来蒸 我来挑 塞满嘴的玉米包 [04:12.41]干柴烧 火焰高 烦心事已寥寥 [04:16.05] [04:16.66]眯眼瞧 把红包塞进你棉袄 [04:20.59]一片翠色葱葱 明快又跳跃 [04:24.66]几瓣海棠山茶 花儿相映笑 [04:28.80]封着吉祥如意 幸福快来到 [04:32.97]红绳绕 拆开春意大红包 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 2, music: { title: "春意红包", author: "三无MarBlue,祖娅纳惜,泠鸢yousa", url: "http://p4lmrb1gp.bkt.clouddn.com/%E4%B8%89%E6%97%A0MarBlue,%E7%A5%96%E5%A8%85%E7%BA%B3%E6%83%9C,%E6%B3%A0%E9%B8%A2yousa%20-%20%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 播放列表123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; "narrow": false, // Optional, narrow style "autoplay": true, // Optional, autoplay song(s), not supported by mobile browsers "mode": "random", // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` "showlrc": 3, // Optional, show lrc, can be 1, 2, 3 "mutex": true, // Optional, pause other players when this player playing "theme": "#e6d0b2", // Optional, theme color, default: #b7daff "preload": "metadata", // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' "listmaxheight": "513px", // Optional, max height of play list "music": [ &#123; "title": "CoCo", "author": "Jeff Williams", "url": "caffeine.mp3", "pic": "caffeine.jpeg", "lrc": "caffeine.txt" &#125;, &#123; "title": "アイロニ", "author": "鹿乃", "url": "irony.mp3", "pic": "irony.jpg" &#125; ]&#125;&#123;% endaplayerlist %&#125; 插入视频：video 标签： 123&lt;video src="http://lxqncdn.miaopai.com/stream/BvmaXK2X49guVi4ehlOjjQ__.mp4" width="100%" height="100%" controls="controls"&gt;Your browser does not support the video tag.&lt;/video&gt; embed标签： 1&lt;embed src="http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA==/v.swf" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" allowFullScreen="true" mode="transparent" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; iframe标签： 1&lt;iframe height=498 width=510 src="http://player.youku.com/embed/XMTY1MTI3NjMyNA==" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
