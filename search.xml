<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM参数调优]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09%2F</url>
    <content type="text"><![CDATA[常见配置汇总堆设置-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值.如:为3,表示年轻代与年老代比值为1:3,年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:3,表示Eden:Survivor=3:2,一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数.并行收集线程数.-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式.适用于单CPU情况.-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数. 参考：http://blog.csdn.net/xiajian2010/article/details/17376157]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理数据可视化]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[根据现有数据集进行数据表查询集构建： galleryproduction 左外联结 production: 1234SELECT scratch_api_production.id,scratch_api_galleryproduction.production_id,scratch_api_production.nameFROM scratch_api_galleryproduction LEFT JOIN scratch_api_productionON scratch_api_production.id=scratch_api_galleryproduction.production_id production 左外联结 user: 1234SELECT scratch_api_production.author_id,scratch_api_user.baseuser_ptr_id,scratch_api_user.sex,scratch_api_user.gradeFROM scratch_api_production LEFT JOIN scratch_api_user ON scratch_api_production.author_id=scratch_api_user.baseuser_ptr_id 再构建三联表： galleryproduction左外联结production左外联结user 三表联结查询模版： 123select username,psw,gname,tel from (t1 left join t2 on t1.t1_id=t2.t1_id) left join t3 on t1.t1_id=t3.t1_id 我根据业务流程实现的sql查询： 查询某专题活动中的所有信息 1234SELECT *FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 然后使用阿里云的DataV进行数据可视化: 需要对接接口： 查询点赞数最多作品排行： 12345SELECT scratch_api_production.like,scratch_api_production.name FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' AND sex='男'ORDER BY scratch_api_production.like DESC 查询结果集中的男女人数 123456789SELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='男'UNIONSELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='女' 查询某专题活动学校参与度排名 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询某专题活动中的参与性别 1234SELECT scratch_api_user.sexFROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' 查询年级占比 123456SELECT scratch_api_user.grade ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.grade is not NULLGROUP BY scratch_api_user.gradeorder by count(*) desc 查询学校占比 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询作品提交时间 12345SELECT DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") as '日期',count(*) as '当日投票数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1GROUP BY DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") 把地址转换成经纬度不要方，利用高德地图经纬度快速查询工具可以轻松地把任何地址转换成经纬度，可具体到门牌号喔，工具地址： 控制台 | 高德开放平台 | 高德地图API 义乌市首届Scratch编程周实时数据状态网址(动态页面):http://datav.aliyun.com/share/07ef37b235d9763bd364f344912d1a05大数据可视化说明:大数据屏幕：1920*1080（可修改）最高实时更新频率：1min/次正常显示的预览效果参考（静态截图）：http://p4lmrb1gp.bkt.clouddn.com/15205615855957.jpg本机上如果不是上述参考效果请检查自己的浏览器如下:推荐电脑上预览：首选谷歌 Chrome 浏览器版本56以上，其他浏览器则需更新至最新版并开启极速（chrome内核）模式，不要使用IE浏览器，否则无法正常显示。不推荐手机上预览：无法按默认长宽比例展示 预览效果：]]></content>
      <tags>
        <tag>数据可视化</tag>
        <tag>DataV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之二]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-05-2%2F</url>
    <content type="text"><![CDATA[第二章 Java内存区域与内存溢出异常&amp;实战第二章结构： Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。参考：https://www.jianshu.com/p/989c90f339b9 2.2 运行时数据区域具体见下图： 2.2.1 程序计数器（Program Counter Register） 概述：该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有：因为 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。2.无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法（本地方法，一个调用非Java代码的接口），这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。（个人理解：参考C++理解是：当线程中调用native方法的时候，当前线程应当会被阻塞，重新启动一个新的线程，那么计数器为空则不会影响新线程的计数器，相互独立。当前线程应当会被阻塞，直到另外一个线程执行结束。当然参数也会被保留） 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 我们经常将 Java 内存分为堆内存（Heap）和栈内存（Stack），这种分法中所指的栈就是 Java 虚拟机栈，或者说是虚拟机栈中 局部变量表 部分。 概述：描述 Java 方法执行的内存模型，每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆是所有线程共享的一块内存区域，由虚拟机启动时创建，堆得唯一目的就是存储对象的实例。几乎所有的对象实例都在改内存区域分配，但是随着JIT编译器（即时编译）的发展及逃逸分析技术（分析指针的动态范围）的发展，栈上分配、标量替换导致堆分配不那么“绝对”了。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开。 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 内存：Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。 相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对 常量池的回收 和 类型的卸载。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。Class 文件中除了有类的（版本、字段、方法、接口）等描述信息外，还有一项信息就是常量池。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2.3 HotSpot 虚拟机对象探秘 这一部分内容将以 HotSpot 虚拟机和常用的内存区域 Java 堆为例，阐述对象分配、布局和访问的全过程。 2.3.1 对象的创建 概述：Java 是一门面向对象的编程语言，在 Java 程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个 new 关键字而已，而在虚拟机中对象的创建则分为以下几个步骤。 虚拟机遇到New指令 首先检查指令的参数能否在常量池中定位到一个类的符号引用 检查这个符号引用对应的类是否已被加载、解析、初始化过 没有加载，则需要先加载 为新生对象分配内存区域（指针碰撞&amp;空闲列表） 线程安全（方案1：对分配内存空间的动作同步；方案2：本地线程分配缓冲 TLAB） 对对象进行必要的设置 调用init方法 类加载概述：虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存概述：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。 分配方式：1.指针碰撞（Bump the Pointer）：假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。2.空闲列表（Free List）：如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。 同步控制概述：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。 方案一：对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。 初始化概述：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。作用：保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。 对象头（Object Header）概述：接下来，虚拟机要为对象头数据进行设置。（e.g. 对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄） init概述：在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，&lt;init&gt; 方法还没有被执行，所有的字段还为零值。 一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，将对象按照我们的意愿进行初始化，这样一个真正的对象才算完全产生。 2.3.2对象的内存布局 在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域。 对象头（存放对象自身的运行时数据&amp;类型指针） 实例数据 对齐填充 2.3.2.1 对象头（Header） HotSpot 虚拟机的对象头包括两部分信息，存储自身的运行时数据的（Mark Word） 和 类型指针。 第一部分：Mark Word 概述：用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。 内存：对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 HotSpot 虚拟机对象头 Mark Word 表如下 第二部分：类型指针 概述：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 Reminder并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。(见2.2.3节) 数组对象：如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。 2.3.2.2 实例数据（Instance Data） 概述：这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 存储顺序：这部分的存储顺序会受到虚拟机 分配策略参数（FieldsAllocationStyle） 和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles =&gt; ints =&gt; shorts/chars =&gt; bytes/booleans =&gt; oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 2.3.2.3 对齐填充（Padding） 概述：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 原理：由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 2.3.3 对象的访问定位 概述：建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以 对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有两种。 句柄访问：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。 直接指针：Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示。 比较：1.句柄访问：使用句柄访问的最大好处就是 reference 中存储的是 稳定的 句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。2.指针访问：使用直接访问最大的好处就是 速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 Sun HotSpot 使用的是第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 2.4 实战：OutOfMemoryError 异常 在 Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemory（OOM）异常的可能。 目的：1. 通过代码验证 Java 虚拟机规范中描述的各个运行时区域的存储内容。2. 遇到实际的内存溢出异常时，能根据异常的信息快速判断哪个区域的内存溢出。3. 了解什么样的代码可能会导致这些区域内存溢出，并了解如何处理。 VM Args 设置 Eclipse IDE：Debug Configurations =&gt; Java Application =&gt; YoungGenGC =&gt; Arguments 中的 VM arguments 中进行书写（书写参数以 - 开头，以空格分隔）。 控制台：直接跟在 Java 命令之后书写。 本人运行在 Mac 系统下，使用 IDEA 进行配置，步骤如下所示👇。 1\. 打开 Run Configurations（⌃ + ⌥ + R 选择 0 ）或者（⌘ + ⇧ + A 输入 run 选择 run…）。 2\. 点击并打开 VM options。 3\. 写入虚拟机启动参数。 4.Apply 并 Run。 2.4.1 - Java 堆溢出 概述：Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 测试环境： 12345-verbose:gc-Xms20M // 最小 GC 启动-Xmx20M // 最大 GC 启动-XX:+PrintGCDetails // 打印设置-XX:SurvivorRatio=8 // 存活对象比率 测试代码：HeapOOM 123456789101112131415import java.util.*;public class Main &#123; private static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 运行结果： 1java.lang.OutOfMemoryError: Java heap space 分析：Java 堆内存的 OOM 异常是时机应用中常见的内存溢出异常情况。当出现 Java 堆内存溢出时，异常堆栈信息 java.lang.OutOfMemoryError 会跟着进一步提示 Java heap space。 解决方式 堆转储快照：要解决这个区域的异常，一般的手段是先通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。 内存泄露：进一步通过工具查看泄露对象到 CG Roots 的引用链，于是就能找到内存泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄露代码的位置。 内存溢出：如果不存在泄露，换句话说，就是内存中的对象确实都必须还活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对象看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗。 2.4.2 - 虚拟机栈和本地方法栈溢出 概述：由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoos 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 -Xss 参数设定。关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常。 异常类型 发生条件 StackOverflowError 线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。 OutOfMemoryError 无法申请到足够的内存时抛出该异常。 这里把异常分为两种情况，看似更加严谨，但却存在一些相互重叠的地方：方栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事的两种描述而已。 2.4.2.1 - StackOverflowError 测试环境：在此测试中，将测试范围限制于单线程中操作。1. 使用 -Xss 参数减少栈内存容量，结果抛出 SOF 异常，异常出现时输出的堆栈深度相应缩小。2. 定义了大量的本地变量，增大此方法栈中本地变量表长度。结果抛出 SOF 异常时输出的堆栈深度相应缩小。 JavaVMStackSOF: 1234567891011121314151617181920212223242526//JavaVMStackSOF//VM Args: -Xss160k // 栈内存容量public class Main &#123; public static class JavaVMStackSOF&#123; private int stackLength = 1; public void stackLeak() &#123; stackLength++; stackLeak(); &#125; &#125; public static void main(String[] args) throws Throwable &#123; JavaVMStackSOF oom = new JavaVMStackSOF(); try &#123; oom.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println("Stack length: " + oom.stackLength); throw e; &#125; &#125;&#125; 运行结果 123Exception in thread &quot;main&quot; Stack length: 771java.lang.StackOverflowError at Main$JavaVMStackSOF.stackLeak(Main.java:8) 分析：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者确切地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 理解：操作系统分配给每个进程的内存是有限的，虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存 -Xms（最大堆容量） -MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略不计。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈瓜分了。每个线程分配到的栈容量越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。 探索：出现 SOF 异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的）达到 1000 - 2000 完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果建立过多线程导致内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过 减少最大堆 和 减少栈容量 来换更多的线程。 2.4.2.2 - OutOfMemoryError 测试环境注意：下面这块代码运行有风险，书上说在windows上会造成系统假死，我在mac上的IDEA上运行，也死机了，测了两次，都导致了系统假死。 JavaVMStackOOM 12345678910111213141516171819202122232425262728293031323334public class Main &#123; //VM Args: -Xss2M // 栈内存容量 //测试代码：创建线程导致内存溢出异常 private void dontStop() &#123; while (true) &#123; &#125; &#125; // 循环开启线程 public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; Main oom = new Main(); oom.stackLeakByThread(); &#125;&#125; 运行结果（参考别人的结果） 1Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread 这是mac死机时用手机照的(；′⌒`)cpu已爆表 2.4.3 - 方法区和运行时常量池溢出 概述：由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。 脑补：String.intern() 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。在 JDK1.6 以及之前的版本中，由于常量池分配在永久代内，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小名，从而间接限制其中常量池的容量。 2.4.3.1 - OutOfMemoryError 测试环境 12-XX:PermSize=10M // 方法区最小值-XX:MaxPermSize=10M // 方法区最大值 测试代码RuntimeConstantPoolOOM 12345678910111213package com.company.bupt;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); long i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 在JDK1.6上运行结果如下： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at com.company.bupt.Main.main(Main.java:10) 分析：从运行结果中可以看到，运行时常量池溢出，在 OutOfMemoryError 后面跟随的提示信息是 PermGen space，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分。 在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为JVM实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。 在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。 在JDK8之前的HotSpot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域。永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过‑XX:MaxPermSize 设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误(OOM)。 参考：Java永久代去哪儿了 http://www.infoq.com/cn/articles/Java-PERMGEN-Removed 总结：java jdk1.7中的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域，如果想了解更多可以参考：http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.htmlhttp://blog.csdn.net/zhyhang/article/details/17246223/ 在JDK1.7上测试 模拟了一下常量池的oom，突然发现设置的参数-XX:PermSize=10M -XX:MaxPermSize=10M不管用了，同时发现内存一直在上升，当上升到一个极值就会趋于平稳，然后再过一段时间会报：Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded这个异常是当GC的时间超过总运行时间的98%才会报的，是为了防止GC占用的时间过长。 运行结果 2.4.3.2 - String 常量池测试 使用 JDK1.7 运行这段程序就不会得到相同的结果，while 循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响。 测试代码RuntimeConstantPoolOOM1 12345678910111213package com.company.bupt;public class Main &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); &#125;&#125; 分析： JDK1.6：会得到两个 false，而在 JDK1.7 中运行，会得到一个 true 和一个 false。产生差异的原因是：是 JDK1.6 中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由 StringBuilder 创建的字符串实例在 Java 堆上，所以必然不是同一个引用，将返回 false JDK1.7：intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此 intern() 返回的引用和由 StringBuilder 创建的那个字符串实例是同一个。对 str2 比较返回 false 是因为 java 这个字符串在执行 StringBuilder.toString() 之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而 计算机软件 这个字符串是首次出现的，因此返回 true。 JVM启动的时候已经写到常量池里了，类似的还有’main’、’int’、’float’。参考：https://www.jianshu.com/p/b98851899f37 JDK1.7上测试结果: 12345678String str1 = new StringBuilder("jc").append( "vc" ).toString();//JVM不会自动加载jcvc，所以这个jcvc是首次出现的，返回true System.out.println(str1.intern()==str1); String str2=new StringBuilder("mai").append( "n" ).toString(); //main已经被自动加载了，不是首次出现，所以返回false System.out.println(str2.intern()==str2); String str3=new StringBuilder("in").append( "t" ).toString(); //flase System.out.println(str3.intern()==str3); String str4=new StringBuilder("flo").append( "at" ).toString(); //flase System.out.println(str4.intern()==str4); JDK1.6上测试上述代码则全返回是false 2.4.3.3 - 方法区溢出 方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本思路就是运行时产生大量的类去填满方法区，直到溢出。另外的，直接使用 Java SE API 也可以动态产生类（如反射时的 GeneratedConstorAccessor 和动态代理等）。 但在本次试验使用CGLIB直接操作字节码运行时，生成大量的动态类。 值得注意的是，当前主流的很多框架 如：Spring,Hibernate对类进行增强时，都会使用到类似CGLIB这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载如内存。 注意：项目必须引入asm-6.0.jar和cglib-3.2.6.jar，需要手动寻找引入 测试代码JavaMethodAreaOOM： 1234567891011121314151617181920212223242526272829303132333435package com.company.bupt;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 测试方法区内存溢出 * 方法区保存的是Class的相关信息，如类名，字段描述符等等，在这里使用cglib来创建大量的类信息来使方法区内存溢出 * * 异常信息为：java.lang.OutOfMemoryError: PermGen space * VM args:-XX:PermSize=10m -XX:MaxPermSize=10m * @author Tim * */public class Main &#123; public static void main(String[] args) &#123; while(true)&#123; Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125; static class OOMObject&#123; &#125;&#125; 以下是我的实测情况： 下列是在JDK1.6上测试得到的： 下列是在JDK1.7上测试得到的： 2.4.3.4 - 总结 方法区溢出是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量的 Class 的应用中，需要特别注意类的回收情况。这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 2.4.4 - 本机直接内存溢出 概述：DirectMemory 容量可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（-Xmx指定）一样，下面的测试代码越过了 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）。因为，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 unfase.allocateMemory()。 测试代码DirectMemoryOOM 12345678910111213141516171819202122package com.company.bupt;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M * @author zzm */public class Main &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 运行结果参考： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryErrorat sun.misc.Unsafe.allocateMemory(Native Method)at org.fenixsoft.oom.DMOOM.main(DMOOM.java:20) 以下是JDK1.6上实测：程序并没有报错 分析：由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看到明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，那就可以考虑检查一下是不是这方面的原因。 参考:https://www.jianshu.com/p/989c90f339b9]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之一]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-06%2F</url>
    <content type="text"><![CDATA[全书核心分布： 第一章 走近JAVA1.6 实战：自己编译JDK(已成功编译) 疑问： 将JDK源码进行编译是做了点什么？是将JDK中的.java文件编译成.class文件吗？ JDK中包含开发工具包和JVM，作者编译完JDK以后，用的还是原来包中的JVM吗？ 我们平常使用的JDK，例如JDK1.7中，里面的文件是以.java形式存在的还是以.class形式存在的，或者是以.java形式存在，要用的时候再用JVM去编译的?答： JDK是c/c++写的, 编译就是把JDK编译成可以运行的状态, 可运行的意思是指可以编译运行.java文件. 而一般情况下官方下载的JDK都是已经帮你编译好而已. 作者可以用自己编译的, 也可以用官方编译好的. 这个要看书中的说明了 JDK是c/c++写的, 里面和其他c++程序没什么区别, windows下面是一堆dll和一堆exe. 你说的.java文件是JDK的功能之一, 帮你编译java文件成class, JVM是运行class文件的容器 一 环境： 操作系统：CentOS6.8计划编译的jdk: openjdk7现成的jdk: java version “1.6.0_25”(Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode))jdk6下载链接如果你当前的系统版本不是这个，没关系，只要下载上述版本安装rpm（默认安装到/usr/java路径下）(不必配置环境变量)即可 二 编译前准备工作如下123456yum install -y mercurialyum install -y ant ant-nodepsyum install -y libX11* libX*yum install -y libXi-devel libXtst-devel libXt-devel freetype* yum install -y alsa-lib-devel cups-develyum install -y gcc gcc-c++ 三 下载计划编译的openjdk7(jdk源码网站：http://hg.openjdk.java.net/jdk7u/ ， 你值得收藏) 1234hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-devcd jdk7u-devchmod 755 get_source.sh ./get_source.sh 四 编译4.1准备好编译环境相关参数解释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export LANG=C#Bootstrap JDK的安装路径，必须设置export ALT_BOOTDIR=/export/servers/jdk1.6.0_25/#允许自动下载依赖export ALLOW_DOWNLOADS=true#并行编译的线数，设置和cpu的数量一致即可export HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2#比较本次build出来的映像与先前版本的差异，这对我们来说没有意义，export SKIP_COMPARE_IMAGES=true#使用预编译头文件，不加这个编译会更慢一些export USE_PRECOMPILED_HEADER=true#指定要编译的内容export BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=falseexport BUILD_JAXWS=falseexport BUILD_CORBA=false#要编译的版本#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueexport DEBUG_NAME=debug#可以避开javaws和浏览器Java插件之类的部分buildBUILD_DEPLOY=false#设置成false就不会build出包装包，因为包装包里有些奇怪的依赖#但是即使不build出它也已经能得到完整的JDK映像，所以还是别build它好了BUILD_INSTALL=false#编译结果存放的路径export ALT_OUTPUTDIR=/root/temp/jdk7u WARNINGS_ARE_ERRORS=#卸载环境变量，避免诡异的事情发生unset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS#make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 好了，我们将上面一系列的环境变量，创建环境文件VAR来统一管理吧vi VAR 12345678910111213141516171819202122232425262728293031323334353637383940export LANG=Cexport ALT_BOOTDIR=/usr/java/jdk1.6.0_25export ALLOW_DOWNLOADS=trueexport HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2export SKIP_COMPARE_IMAGES=trueexport USE_PRECOMPILED_HEADER=trueexport BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=trueexport BUILD_JAXWS=trueexport BUILD_CORBA=true#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueBUILD_DEPLOY=falseBUILD_INSTALL=falseexport ALT_OUTPUTDIR=/home/cloudpai/app/jdk7u #export CORBA_DIST=$ALT_OUTPUTDIR/corba/dist#export JAXP_DIST=$ALT_OUTPUTDIR/jaxp/dist#export JAXWS_DIST=$ALT_OUTPUTDIR/jaxws/distunset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS 使之生效. VAR 4.2检测设置是否全部正确make sanity当看到如下输出时则表示成功 123456789101112131415161718192021Build Machine Information: build machine = workstation.centos.vbirdBuild Directory Structure: CWD = /root/temp/jdk7u-dev TOPDIR = . LANGTOOLS_TOPDIR = ./langtools JAXP_TOPDIR = ./jaxp JAXWS_TOPDIR = ./jaxws CORBA_TOPDIR = ./corba HOTSPOT_TOPDIR = ./hotspot JDK_TOPDIR = ./jdk ……Sanity check passed. 4.3真正开始编译make (命令等同于make all) 成功的标志 12345678910111213#-- Build times ----------Target all_product_buildStart 2018-03-06 21:03:26End 2018-03-06 21:20:0900:02:02 corba00:05:08 hotspot00:00:16 jaxp00:00:19 jaxws00:08:34 jdk00:00:23 langtools00:16:43 TOTAL-------------------------make[1]: Leaving directory `/home/cloudpai/Downloads/jdk7u-dev' 4.4测试自己编译出来的jdk吧正确编译后，可以执行如下命令验证 1234[cloudpai@hadoop000 bin]$ /home/cloudpai/app/jdk7u/j2sdk-image/bin/java -versionopenjdk version "1.7.0-internal"OpenJDK Runtime Environment (build 1.7.0-internal-cloudpai_2018_03_06_21_03-b00)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) OK，到些就大功告成了。 五 可能出现的错误/usr/bin/ld: cannot find -lX11 collect2: ld returned 1 exit status解决办法yum install -y libX11* /bin/sh: line 0: cd: /NOT-SET/re/jdk/1.7.0/promoted/latest/binaries/linux-amd64: No such file or directory make[4]: *** [/root/temp/jdk7u/tmp/java/components_imported] Error 1解决办法VAR文件确认执行过了，正确的姿势. VAR 参考博客：http://blog.csdn.net/hl_java/article/details/76691321 由1.6.4得我们得到了自己的虚拟机1.7.0-internal-cloudpai_2018_03_06_21_03-b00 现在我们要将JVM运行起来： 在大多数时候，如果我们并不关心JDK中HotSpot虚拟机以外的内容，只想单独编译 HotSpot虚拟机的话（例如调试虚拟机时，每次改动程序都执行整个OpenJDK的Makefile，速 度肯定受不了），那么使用hotspot/make目录下的Makefile进行替换即可，其他参数设置与前 面是一致的，这时候虚拟机的输出结果存放在build/hotspot/outputdir/bsd_amd64_compiler2目录(在不同机器上，最后一个目录名称会有所差别，bsd表示Mac OS系统（内核为 FreeBSD），amd64表示是64位JDK（32位是x86），compiler2表示是Server VM（Client VM表 示是compiler1）。) 中，进入后可以见到以下几个目录。 在路径：/home/cloudpai/app/jdk7u/hotspot/outputdir/linux_amd64_compiler2 12345678910[cloudpai@hadoop000 linux_amd64_compiler2]$ lltotal 48drwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 debugdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 fastdebugdrwxrwxr-x. 7 cloudpai cloudpai 4096 Mar 6 21:06 generateddrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 jvmgdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 optimizeddrwxrwxr-x. 3 cloudpai cloudpai 20480 Mar 6 21:11 productdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 profiled-rw-rw-r--. 1 cloudpai cloudpai 1778 Mar 6 21:06 shared_dirs.lst 这些目录对应了不同的优化级别，优化级别越高，性能自然就越好，但是输出代码与源 码的差距就越大，难于调试，具体哪个目录有内容，取决于make命令后面的参数。 在编译结束之后、运行虚拟机之前，还要手工编辑目录下的env.sh文件，这个文件由编 译脚本自动产生，用于设置虚拟机的环境变量，里面已经发布了“JAVA_HOME、 CLASSPATH、HOTSPOT_BUILD_USER”3个环境变量， 还要在在product下边（看网上都是在jvmg下边，可我的jvmg下边没有gamma，不知道什么情况）的env.sh下加入： 123456export JAVA_HOME=/usr/java/jdk1.6.0_25export PATH=$JAVA_HOME/bin:$PATHLD_LIBRARY_PATH=.:$&#123;JAVA_HOME&#125;/jre/lib/amd64/native_threads:$&#123;JAVA_HOME&#125;/jre/lib/amd64:export LD_LIBRARY_PATH 然后执行以下命令启动虚拟机（这时的启动器名为gamma），输出版本号。 12source ./env.sh ./gamma -version 最后运行虚拟机成功！！ 12345[cloudpai@hadoop000 product]$ ./gamma -versionUsing java runtime at: /usr/java/jdk1.6.0_25/jrejava version &quot;1.6.0_25&quot;Java(TM) SE Runtime Environment (build 1.6.0_25-b06)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) 1.6.5 JVM 在IDE工具中进行源码调试注意这里是源码调试，是对1.6.4中计划编译的jdk源码进行操作: openjdk7（centos上的存储路径是/home/cloudpai/Downloads/jdk7u-dev） centos下安装NetBeans集成开发环境 官网下载地址：http://download.netbeans.org/netbeans/7.0.1/final/bundles/netbeans-7.0.1-ml-cpp-linux.sh 以netbeans-7.0.1-ml-cpp-linux.sh为例 首先，到NetBeans网站（http://netbeans.org/）上下载最新版的NetBeans（网上说7.0.1版本没问题，我就直接用这个版本了），下载时选择支持 C/C++开发的那个版本。 注意：不要在本地远程用SecureCRT输入命令啊，要在Linux下用终端输入命令： 1sh netbeans-7.0.1-ml-cpp-linux.sh 这样就会在centos中弹出安装界面： 配置好安装路径和IDE使用的java环境（注意与编译时的环境一致） 安装好以后，桌面上就有了NetBeans： 后续操作可以参考这个博客：使用Netbeans开发调试OpenJDK中的HotSpothttp://blog.csdn.net/pange1991/article/details/51580969 CentOS下安装NetBeans集成开发环境http://www.itboth.com/d/QriYZj/centos-java-windows-linux-netbeans]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java1.8 帮助文档]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05-1%2F</url>
    <content type="text"><![CDATA[java 1.6 帮助文档中文链接：http://download.csdn.net/detail/qw599186875/9608735英文Java1.8 帮助文档英文中文 – 谷歌版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-google/下载链接：http://download.csdn.net/detail/qw599186875/9802192]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站架构技能图谱（Java版）]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05%2F</url>
    <content type="text"><![CDATA[每天都要有进步！]]></content>
      <tags>
        <tag>java</tag>
        <tag>图谱</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[workflow工作流]]></title>
    <url>%2F2018%2F03%2F04%2F2018-03-04%2F</url>
    <content type="text"><![CDATA[工作流脚本测试：测试成功~晚安~~]]></content>
      <tags>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scratch编程探究]]></title>
    <url>%2F2018%2F03%2F02%2F2018-03-02%2F</url>
    <content type="text"><![CDATA[转载自：儿童使用Scratch编程时，与程序员在工作中的编程有什么区别？ - Milo Yip的回答 - 知乎https://www.zhihu.com/question/42012520/answer/310430799]]></content>
      <tags>
        <tag>scratch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018拜年祭单品]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01-1%2F</url>
    <content type="text"><![CDATA[2018拜年祭单品传送门： 1.【逆浪千秋】av20204904 2.【如果我的一生只需要做一件事 — Bilibili Zeitgeist 2017】av20203478 3.【梦想小剧场-遗失的宝物】av20203610 4.【口袋竞技场ー冰与铁之歌】av20203938 5.【相遇day by day】av20203945 6.【上海一夜】av20204014 7.【神鬼恋曲】av20204051 8.【UP主的奇妙冒险之勇者传说】av20204517 9.【我的破烂之掀起波澜】av20204332 10.【palette】av20204403 11.【广告高手】av20204701 12.【滑稽君大冒险】av20204534 13.【journey】av20204614 14.【全靠我勤劳的手】av20204705 15.【演奏区的偷心计划】av20204824 16.【乒乓帝国】av20205319 17.【鬼畜大战之真相黎明】av20205316 18.【如何翻拍一个CG短片】av20205314 19.【坦克大战】av20205375 20.【星空花火】av20203411 彩蛋【举头三尺有神明】av16201808]]></content>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blogs 上的标签tag参数]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01%2F</url>
    <content type="text"><![CDATA[12345678910---title: Mac终端翻墙tags: Linux&amp;Unixcategories: Linux&amp;Unixcomments: trueabbrlink: 745a6d7date: 2016-11-24 18:26:33updated: 2016-11-24 18:26:33copyright: true---]]></content>
      <tags>
        <tag>mac</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要进行的改进]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[TODO： 测试git的备份功能 学习 Alfred workflow实现打开重启任意应用 脚本实现清理浏览器缓存]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog通过git备份与恢复的最优操作]]></title>
    <url>%2F2018%2F02%2F28%2Fblog%E9%80%9A%E8%BF%87git%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%9A%84%E6%9C%80%E4%BC%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引言：Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。特别简洁。 关于搭建的流程 创建仓库，http://CrazyMilk.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库； 在本地http://CrazyMilk.github.io 仓库新建一个文件后，进入文件中。在该文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 关于日常的改动流程 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的http://CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 其实只要把hexo和需要每个插件都写入到package.json中（平常安装时加–save参数会自动写入），那么git clone下来之后，只要一句npm install就能装好hexo和所有的依赖，开箱即用 ^_^ 迁移源码库一开始用了该方法，后来意识到备份到github分支的博客源码也是public的，后来改为备份到开源中国git私有库了 参考1：GitHub Pages + Hexo搭建博客参考2：使用hexo，如果换了电脑怎么更新博客？ - CrazyMilk的回答 - 知乎]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac使用]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28%2F</url>
    <content type="text"><![CDATA[Mac系统如何显示隐藏文件？以”.”开头的隐藏文件如何在MAC系统下显示？ 答：Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 显示 隐藏文件 1234567#显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool trueosascript -e 'tell application "Finder" to quit'#不显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool falseosascript -e 'tell application "Finder" to quit']]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28-1%2F</url>
    <content type="text"><![CDATA[创建的仓库：默认master克隆的仓库：默认origin（源） git add 开始跟踪一个新文件git status显示git状态 git commit提交更新 git diff：比较工作区和缓存区的不同。git diff --cached：比较缓存区和仓库的不同。 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 git push [remote-name] [branch-name] 如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：git push origin master git log显示从最近到最远的提交日志。包含每个提交的SHA1校验和、作者的名字和邮箱、提交时间以及提交说明等。gitk使用图形化工具查阅提交历史 git commit --amend修改最后一次提交 git reset HEAD &lt;file&gt;...取消已经暂存的文件 Git 分支git branch创建一个新的分支 git commit -a -m &#39;made other changes&#39; 提交分支git mergetool调用一个可视化的合并工具并引导你解决所有冲突 git学习链接]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客样式改进杂记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8D%9A%E5%AE%A2%E6%A0%B7%E5%BC%8F%E6%94%B9%E8%BF%9B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[评论区样式修改：文件位置：themes/next/source/css/_common/components/comments.styl 修改内容： 1234.comments &#123; background white; opacity:0.8;&#125; 移动端不加载背景图一点优化，移动端不加载背景图。在_layout.swig底部L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});标签前，加上移动端浏览器内核判断语句，当为PC端浏览器时，加载背景js 123456789101112131415161718192021222324252627&lt;!--移动端判断，是否引入背景--&gt;&lt;script&gt;var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123;//移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase() &#125; if(browser.versions.mobile || browser.versions.ios || browser.versions.android || browser.versions.iPhone || browser.versions.iPad)&#123; &#125;else&#123; document.write("&lt;script type=\'text/javascript\' src=\'/js/src/particle.js\'&gt;&lt;\/script&gt;"); &#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🎵记录点滴生活]]></title>
    <url>%2F2018%2F02%2F24%2F%F0%9F%8E%B5%E8%AE%B0%E5%BD%95%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[记录点滴生活《BINGBIAN病变》歌曲不错，曲调有些忧伤 [00:00.21]罗之豪 - BINGBIAN病变 [00:01.87]词：Cubi/Fi9 [00:02.76]曲：Jurrivh [00:03.72]混音：Fi9 [00:19.36][02:01.33][03:09.30]有天我睡醒看到我的身边没有你 [00:23.52][02:05.53][03:13.50]在我的右边是你曾经喜欢的玩具 [00:27.75][02:09.76][03:17.66]可当我站起身来在房间里寻找你 [00:32.04][02:14.00][03:21.93]留下的只有带着你味道的一封信 [00:36.50][02:18.48][03:26.35]就在昨天还一起看我们的照片 [00:40.47][02:22.48][03:30.46]可现在让我感觉像烂剧里的主演 [00:44.74][02:26.71][03:34.69]为什么这种事情会发生在我身边 [00:48.97][02:31.00][03:38.92]是不是老天没能看到对你的疯癫 [00:54.46]还想着 创造你的宇宙 [00:56.53]但现在 已经被我清空 [00:58.57]你让我 整个人都冰冻 [01:00.68]还怎么 再次为你心动 [01:02.88]Wake me 不是你的意愿 [01:04.97]离开我 开始新的起点 [01:07.12]可能我 还会对你贪恋 [01:09.30]谁让你 曾经让我疯癫 [01:11.18]疯癫 那也是过去的画面 [01:14.54]看往后的几天 [01:16.72]我猜你也不会出现 [01:18.78]我回想这几年 [01:20.93]就像是要命的病变 [01:23.16]你可能听不见 [01:25.16]来自我对你的挂念 [01:27.53]可能有点累 [01:28.85]觉得对不对这是第几次在为你宿醉 [01:31.98]没了我肩膀 [01:33.08]你在谁身旁买的礼物变成了灰 [01:35.99]曾经我多想 [01:37.25]把你变漂亮看着别人羡慕你的模样 [01:40.50]没关系有小熊陪着你看月亮 [01:44.40]我已经看到跟你断电的过程 [01:46.96]但我假装看不见 [01:48.76]是不是要我变得像个厉鬼 [01:50.96]才能进入你的世界 [01:52.95]为什么不说再见 [01:54.31]我猜你应该是不小心的忘记 [01:57.04]都无所谓也有点累 [01:59.09]也可以开始新的记忆 [02:35.19]我不能够停止啊 [02:37.43]这些年我对你的疯癫 [02:39.49]戴上那条围巾吧 [02:41.59]在每个寒风刺骨的冬天 [02:43.92]每次送你回家你抱着我 [02:45.63]不经意间又触碰到你的手 [02:48.10]你穿裙子眨眼睛 望着我 [02:50.52]让我每次心动的瞬间 [02:52.49]那条十字路口 [02:54.39]始终有你身上的气味 [02:57.00]车水马龙过后的路灯下的身影 [03:00.10]又会是谁 [03:00.83]他想说我真的 [03:02.01]喜欢你但是每次欲言又闭嘴 [03:05.57]那时荒唐的男孩 [03:07.64]又浑浊了几岁 var ap = new APlayer({ element: document.getElementById("aplayer1"), narrow: false, autoplay: false, showlrc: 2, music: { title: "BINGBIAN病变", author: "Cubi / Fi9江澈", url: "http://p4lmrb1gp.bkt.clouddn.com/Cubi,Aydo$,BRGang%20-%20BINGBIAN%E7%97%85%E5%8F%98.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/BINGBIAN%E7%97%85%E5%8F%98.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的blog自动发布脚本]]></title>
    <url>%2F2018%2F02%2F23%2Fmac%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[遇到的坑： -bash: ./install.sh: /bin/bash: bad interpreter: Operation not permitted出现这个问题的主要原因是：-rwxrwxrwx@ 文件的属性最后带个@，这个@代表的是更多的一些属性，具体含义不太清楚，但有它就是执行不了解决：可以用这个命令来去除这个属性：xattr -d com.apple.quarantine ./*后来进入目录发现目录下面的文件还是带有@属性，我们到根目录加一个-r就好了：xattr -d -r com.apple.quarantine ./* 我的blog自动发布脚本:blog_publish.sh 123456789#!/bin/bashsay "blogs updating"cd /Users/pailiu/Library/Mobile\ Documents/iCloud~com~coderforart~iOS~MWeb/Documents/mweb_documents_library/Bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo dsay "blogs published"rm -rf /Users/pailiu/Library/Caches/Google/Chrome/Profile\ 1/*open -a "/Applications/Google Chrome.app" 'http://cloudpai.site/'# hexo server]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客插入音频、视频]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为了避免后期外链失效，可以将视频、音频图片等资源传至七牛云等cdn服务器上，从中获取外链。 常用排版：居中： 1&lt;center&gt; &lt;/center&gt; 插入图片：有尺寸要求时： 1&lt;img src="http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg" width="80%" height="80%"&gt; 无尺寸要求时快速插入（md格式）： 1![](http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg) 插入音乐网易云音乐外链获取：见官网修改博客音乐播放器歌曲路径：/Blog/themes/hexo-theme-next-master/layout/_macro/sidebar.swig qq音乐外链获取： http://www.qqmusic.cc/插入音频播放器代码： 1&lt;audio src="http://mp3.qqmusic.cc/yq/211758246.mp3" controls="controls"&gt;&lt;/audio&gt; hexo-tag-aplayer：博客中插入自定义音乐 安装成功后，在 Markdown 文档中添加比如添加如下代码使用hexo-tag-aplayer 参数12345678title ：音乐标题author：音乐作者url：音乐文件网址picture_url：可选，音乐图片网址narrow：可选，窄款式autoplay：可选，自动播放音乐，不支持移动浏览器width:xxx：可选，前缀width:，播放器宽度（默认值：100％）lrc:xxx：可选，前缀lrc:，LRC文件url 示例: 1&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125; [ti:春意红包 (Vocaloid Ver.)] [ar:乐正绫/心华/洛天依] [al:春意红包] [by:] [offset:0] [00:00.29]春意红包 (Vocaloid Ver.) - 乐正绫/心华/洛天依 [00:00.89]词：泠鸢YOUSA [00:01.05]曲：Wing翼 [00:01.18]编曲：Wing翼 [00:01.95]小麦面包饺 喜色上眉梢 [00:05.78]点柳翠 画春晓 [00:08.85] [00:10.08]找旧样铜板穿一串吉兆 [00:14.20]把春意装满红包 [00:17.86] [00:37.11]廊下的小阿妹摇头晃脑 [00:41.25]望着瓦上的碎嘴家雀 [00:44.76] [00:45.56]问它们春日的鸟儿 何时才能到 [00:49.81] [00:50.35]穿街搜巷沿路找 [00:53.26] [00:53.76]看邻家的老人摘下毡帽 [00:57.88]虽是脱去冬衣还尚早 [01:01.89]宰鸡鸭 起炉灶 揭开自家陈酿 [01:07.91]偷偷尝一瓢 [01:09.81] [01:13.01]大鬼叫 小鬼叫 邪祟吓得跌倒 [01:16.73]该用什么清扫 锣鼓鞭炮 [01:20.58] [01:21.30]小孩儿 快来瞧 别再人堆胡闹 [01:24.85] [01:25.43]只有听话乖巧 来年才能长高 [01:29.08] [01:30.21]和纸浆 采朱砂 攒一摞春联叠好 [01:34.25]剪金花 染红料 [01:36.24]再糊一个四方小包 [01:37.98] [01:38.56]对花调 抄童谣 写一串吉祥安好 [01:42.51]扶正了封面 画上春来到 [01:46.14]一片翠色葱葱明快又跳跃 [01:50.13]几瓣海棠山茶花儿相映笑 [01:54.29]再蘸浓墨潦草添只燕子闹 [01:58.48]红绳绕 来封一个大红包 [02:02.83] [02:19.34]找一张晒烫的板凳歇脚 [02:22.80] [02:23.58]看你眼下又布满操劳 [02:27.59]编织橙黄蓝绿把烦恼全部忘掉 [02:32.00] [02:32.65]抬手捧一把红枣 [02:34.70] [02:35.97]骗怕生的小妹点灯睡觉 [02:40.05]会有鬼祟在夜晚来到 [02:43.55] [02:44.13]她慌张 我偷笑 连说不怕不怕 [02:50.16]让我去赶跑 [02:52.62] [02:55.34]左搭肩 右帮腔 [02:57.19]挤兑迟来的大忙人 [02:59.59]礼物未到 人怎能到 [03:03.02] [03:03.62]表嫂吵 大舅闹 连天地喳喳叫 [03:07.03] [03:07.71]我装作听不到 盘坐把碗沿敲 [03:11.35] [03:12.37]踩高跷 抓花包 撩一挂红衣鞭炮 [03:16.52]打年糕 串辣椒 [03:18.59]抹花我的胭脂粉膏 [03:20.67]侃八卦 讲小道 等杯中茶酒减少 [03:24.79]将手上红包 塞进你棉袄 [03:28.05] [03:28.60]你送吉祥如意 幸福快来到 [03:32.57]我送百年顺遂 不怕被火烧 [03:36.57]再求来年生辰 添一分美貌 [03:40.74]拱手摇 同鞠一躬对眼笑 [03:44.55] [03:47.29]小麦面包饺 喜色上眉梢 [03:51.29]点柳翠 画春晓 [03:55.45]找旧样铜板穿一串吉兆 [03:59.58]把春意赠与明朝 [04:03.12] [04:04.16]左搭肩 右帮腔 热闹话不见少 [04:08.24]你来蒸 我来挑 塞满嘴的玉米包 [04:12.41]干柴烧 火焰高 烦心事已寥寥 [04:16.05] [04:16.66]眯眼瞧 把红包塞进你棉袄 [04:20.59]一片翠色葱葱 明快又跳跃 [04:24.66]几瓣海棠山茶 花儿相映笑 [04:28.80]封着吉祥如意 幸福快来到 [04:32.97]红绳绕 拆开春意大红包 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 2, music: { title: "春意红包", author: "三无MarBlue,祖娅纳惜,泠鸢yousa", url: "http://p4lmrb1gp.bkt.clouddn.com/%E4%B8%89%E6%97%A0MarBlue,%E7%A5%96%E5%A8%85%E7%BA%B3%E6%83%9C,%E6%B3%A0%E9%B8%A2yousa%20-%20%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 播放列表123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; "narrow": false, // Optional, narrow style "autoplay": true, // Optional, autoplay song(s), not supported by mobile browsers "mode": "random", // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` "showlrc": 3, // Optional, show lrc, can be 1, 2, 3 "mutex": true, // Optional, pause other players when this player playing "theme": "#e6d0b2", // Optional, theme color, default: #b7daff "preload": "metadata", // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' "listmaxheight": "513px", // Optional, max height of play list "music": [ &#123; "title": "CoCo", "author": "Jeff Williams", "url": "caffeine.mp3", "pic": "caffeine.jpeg", "lrc": "caffeine.txt" &#125;, &#123; "title": "アイロニ", "author": "鹿乃", "url": "irony.mp3", "pic": "irony.jpg" &#125; ]&#125;&#123;% endaplayerlist %&#125; 插入视频：video 标签： 123&lt;video src="http://lxqncdn.miaopai.com/stream/BvmaXK2X49guVi4ehlOjjQ__.mp4" width="100%" height="100%" controls="controls"&gt;Your browser does not support the video tag.&lt;/video&gt; embed标签： 1&lt;embed src="http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA==/v.swf" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" allowFullScreen="true" mode="transparent" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; iframe标签： 1&lt;iframe height=498 width=510 src="http://player.youku.com/embed/XMTY1MTI3NjMyNA==" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
