<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 远程调用（RPC）]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-6%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Java</tag>
        <tag>PRC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 序列化]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-5%2F</url>
    <content type="text"><![CDATA[序列化与反序列化序列化 (Serialization) 是将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是 XML 等格式。而字节的或 XML 编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。 Java 对象的序列化与反序列化在 Java 中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用该对象。但是，我们创建出来的这些 Java 对象都是存在于 JVM 的堆内存中的。只有 JVM 处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。 但是在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java 的对象序列化可以帮助我们实现该功能。 对象序列化机制（object serialization）是 Java 语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在 JVM 中的活动对象和字节数组（流）之间进行转换。 在 Java 中，对象的序列化与反序列化被广泛应用到 RMI(远程方法调用) 及网络传输中。 相关接口及类Java 为了方便开发人员将 Java 对象进行序列化及反序列化提供了一套方便的 API 来支持。其中包括以下接口和类： java.io.Serializable java.io.Externalizable ObjectOutput ObjectInput ObjectOutputStream ObjectInputStream Serializable 接口类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。 (该接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？) 当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出NotSerializableException。 如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成java.io.Serializable接口。 下面是一个实现了java.io.Serializable接口的类 1234567891011121314151617181920212223242526272829303132333435package com.hollischaung.serialization.SerializableDemos;import java.io.Serializable;/** * Created by hollis on 16/2/17. * 实现Serializable接口 */public class User1 implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 通过下面的代码进行序列化及反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hollischaung.serialization.SerializableDemos; import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils; import java.io.*;/** * Created by hollis on 16/2/17. * SerializableDemo1 结合SerializableDemo2说明 一个类要想被序列化必须实现Serializable接口 */public class SerializableDemo1 &#123; public static void main(String[] args) &#123; //Initializes The Object User1 user = new User1(); user.setName("hollis"); user.setAge(23); System.out.println(user); //Write Obj to File ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream("tempFile")); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(oos); &#125; //Read Obj from File File file = new File("tempFile"); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); User1 newUser = (User1) ois.readObject(); System.out.println(newUser); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(ois); try &#123; FileUtils.forceDelete(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; //OutPut://User&#123;name='hollis', age=23&#125;//User&#123;name='hollis', age=23&#125; 更多关于 Serializable 的使用，请参考代码实例 Externalizable 接口除了 Serializable 之外，java 中还提供了另一个序列化接口Externalizable 为了了解 Externalizable 接口和 Serializable 接口的区别，先来看代码，我们把上面的代码改成使用 Externalizable 的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hollischaung.serialization.ExternalizableDemos; import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput; /** * Created by hollis on 16/2/17. * 实现Externalizable接口 */public class User1 implements Externalizable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void writeExternal(ObjectOutput out) throws IOException &#123; &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 12345678910111213141516171819202122232425262728package com.hollischaung.serialization.ExternalizableDemos; import java.io.*; /** * Created by hollis on 16/2/17. */public class ExternalizableDemo1 &#123; //为了便于理解和节省篇幅，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记 //IOException直接抛出 public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //Write Obj to file ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile")); User1 user = new User1(); user.setName("hollis"); user.setAge(23); oos.writeObject(user); //Read Obj from file File file = new File("tempFile"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); User1 newInstance = (User1) ois.readObject(); //output System.out.println(newInstance); &#125;&#125;//OutPut://User&#123;name='null', age=0&#125; 通过上面的实例可以发现，对 User1 类进行序列化及反序列化之后得到的对象的所有属性的值都变成了默认值。也就是说，之前的那个对象的状态并没有被持久化下来。这就是 Externalizable 接口和 Serializable 接口的区别： Externalizable 继承了 Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用 Externalizable 接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。还有一点值得注意：在使用 Externalizable 进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现 Externalizable 接口的类必须要提供一个 public 的无参的构造器。 按照要求修改之后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hollischaung.serialization.ExternalizableDemos; import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput; /** * Created by hollis on 16/2/17. * 实现Externalizable接口,并实现writeExternal和readExternal方法 */public class User2 implements Externalizable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(name); out.writeInt(age); &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; name = (String) in.readObject(); age = in.readInt(); &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 12345678910111213141516171819202122232425262728package com.hollischaung.serialization.ExternalizableDemos; import java.io.*; /** * Created by hollis on 16/2/17. */public class ExternalizableDemo2 &#123; //为了便于理解和节省篇幅，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记 //IOException直接抛出 public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //Write Obj to file ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile")); User2 user = new User2(); user.setName("hollis"); user.setAge(23); oos.writeObject(user); //Read Obj from file File file = new File("tempFile"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); User2 newInstance = (User2) ois.readObject(); //output System.out.println(newInstance); &#125;&#125;//OutPut://User&#123;name='hollis', age=23&#125; 这次，就可以把之前的对象状态持久化下来了。 如果 User 类中没有无参数的构造函数，在运行时会抛出异常：java.io.InvalidClassException 更多 Externalizable 接口使用实例请参考代码实例 ObjectOutput 和 ObjectInput 接口ObjectInput 接口 扩展自 DataInput 接口以包含对象的读操作。 DataInput 接口用于从二进制流中读取字节，并根据所有 Java 基本类型数据进行重构。同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具。 对于此接口中的所有数据读取例程来说，如果在读取所需字节数之前已经到达文件末尾 (end of file)，则将抛出 EOFException（IOException 的一种）。如果因为到达文件末尾以外的其他原因无法读取字节，则将抛出 IOException 而不是 EOFException。尤其是，在输入流已关闭的情况下，将抛出 IOException。 ObjectOutput扩展 DataOutput 接口以包含对象的写入操作。 DataOutput 接口用于将数据从任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流。同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具。 对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException。 ObjectOutputStream 类和 ObjectInputStream 类通过前面的代码片段中我们也能知道，我们一般使用 ObjectOutputStream 的writeObject方法把一个对象进行持久化。再使用 ObjectInputStream 的readObject从持久化存储中把对象读取出来。 更多关于 ObjectInputStream 和 ObjectOutputStream 的相关知识欢迎阅读我的另外两篇博文：深入分析 Java 的序列化与反序列化、单例与序列化的那些事儿 Transient 关键字Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。关于 Transient 关键字的拓展知识欢迎阅读深入分析 Java 的序列化与反序列化 序列化 ID虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID) 序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。 参考资料维基百科 理解 Java 对象序列化 Java 序列化的高级认识 参考：Java对象的序列化与反序列化 - ImportNewhttp://www.importnew.com/17964.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO面试]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-4%2F</url>
    <content type="text"><![CDATA[1. 什么是比特 (Bit), 什么是字节 (Byte), 什么是字符 (Char), 它们长度是多少, 各有什么区别 答案 Bit 最小的二进制单位 ，是计算机的操作部分 取值 0 或者 1Byte 是计算机操作数据的最小单位由 8 位 bit 组成 取值（-128-127）Char 是用户的可读写的最小单位，在 Java里面由 16 位 bit 组成 取值（0-65535） Bit 是最小单位 计算机 只能认识 0 或者 1 8 个字节 是给计算机看的字符 是看到的东西 一个字符 = 二个字节 2. 什么是流, 按照传输的单位, 分成哪两种流, 并且他们的父类叫什么流是指数据的传输 答案 字节流，字符流字节流：InputStream OutputStream字符流：Reader Writer 3. 流按照传输的方向可以分为哪两种, 分别举例说明 答案 输入输出相对于程序输入流 InputStream，输出流 OutputStream 4. 按照实现功能分为哪两种, 分别举例说明 答案 节点流，处理流节点流：OutputStream处理流： OutputStreamWriter 5.BufferedReader 属于哪种流, 它主要是用来做什么的, 它里面有那些经典的方法 答案 属于处理流中的缓冲流，可以将读取的内容存在内存里面，有 readLine（）方法 6. 什么是节点流, 什么是处理流, 它们各有什么用处, 处理流的创建有什么特征 答案 节点流 直接与数据源相连，用于输入或者输出处理流：在节点流的基础上对之进行加工，进行一些功能的扩展处理流的构造器必须要 传入节点流的子类 7. 如果我要对字节流进行大量的从硬盘读取, 要用那个流, 为什么 答案 BufferedInputStream 使用缓冲流能够减少对硬盘的损伤 8. 如果我要打印出不同类型的数据到数据源, 那么最适合的流是那个流, 为什么 答案 Printwriter 可以打印各种数据类型 9. 怎么样把我们控制台的输出改成输出到一个文件里面, 这个技术叫什么 答案 SetOut（printWriter,printStream）重定向 11. 怎么样把输出字节流转换成输出字符流, 说出它的步骤 答案 使用 转换处理流 OutputStreamWriter 可以将字节流转为字符流New OutputStreamWriter（new FileOutputStream（File file））; 12. 把包括基本类型在内的数据和字符串按顺序输出到数据源，或者按照顺序从数据源读入，一般用哪两个流 答案 DataInputStream DataOutputStream 13. 把一个对象写入数据源或者从一个数据源读出来, 用哪两个流 答案 ObjectInputStream ObjectOutputStream 14. 什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作 答案 对象序列化，将对象以二进制的形式保存在硬盘上反序列化；将二进制的文件转化为对象读取实现 serializable 接口 不想让字段放在硬盘上就加 transient 15. 如果在对象序列化的时候不想给一个字段的数据保存在硬盘上面, 采用那个关键字? 答案 transient 关键字 16. 在实现序列化接口是时候一般要生成一个 serialVersionUID 字段, 它叫做什么, 一般有什么用 答案 是版本号，要保持版本号的一致 来进行序列化 为了防止序列化出错 17.InputStream 里的 read() 返回的是什么, read(byte[] data) 是什么意思, 返回的是什么值 答案 返回的是所读取的字节的 int 型（范围 0-255）read（byte [ ] data）将读取的字节储存在这个数组返回的就是传入数组参数个数 Read 字节读取字节 字符读取字符 18.OutputStream 里面的 write() 是什么意思, write(byte b[], int off, int len) 这个方法里面的三个参数分别是什么意思 答案 write 将指定字节传入数据源Byte b[ ] 是 byte 数组b[off] 是传入的第一个字符b[off+len-1] 是传入的最后的一个字符len 是实际长度 19. 流一般需要不需要关闭, 如果关闭的话在用什么方法, 一般要在那个代码块里面关闭比较好，处理流是怎么关闭的，如果有多个流互相调用传入是怎么关闭的？ 答案 流一旦打开就必须关闭，使用 close 方法放入 finally 语句块中（finally 语句一定会执行）调用的处理流就关闭处理流多个流互相调用只关闭最外层的流 20.Java 中的所有的流可以分为几大类, 它们的名字是什么, 各代表什么 答案 分为:字节输入流 InputStream字节输出流 OutputStream字符输入流 Reader字符输出流 Writer所有流都是这四个流的子类 说下常用的 io 流 Icon InputStream,OutputStream,FileInputStream,FileOutputStream,BufferedInputStream,BufferedOutputStreamReader,WriterBufferedReader,BufferedWriter 21 写一段代码读取一个序列化的对象一般使用哪种 Stream？ Icon A、InputStream B、FileReader C、DataInputStream D、ObjectStream 22 io 流怎样读取文件的？ Icon 使用 File 对象获取文件路径，通过字符流 Reader 加入文件，使用字符缓存流 BufferedReader 处理 Reader，再定义一个字符串，循环遍历出文件。代码如下：File file = new File(“d:/spring.txt”);try {Reader reader = new FileReader(file);BufferedReader buffered = new BufferedReader(reader);String data = null;while((data = buffered.readLine())!=null){System.out.println(data);}} catch (FileNotFoundException e) {e.printStackTrace();} catch (IOException e) {e.printStackTrace();} 23 说说你对 io 流的理解 Icon Io 流主要是用来处理输入输出问题，常用的 io 流有 InputStream，OutputStream，Reader，Writer 等 24 JAVA 的 IO 流和 readLine 方法 Icon Java 的 io 流用来处理输入输出问题，readLine 是 BufferedReader 里的一个方法，用来读取一行。 25 用什么把对象动态的写入磁盘中，写入要实现什么接口。 Icon ObjectInputStream，需要实现 Serializable 接口 26 FileInputStream 创建详情，就是怎样的创建不报错，它列出了几种形式! Icon FileInputStream 是 InputStream 的子类，通过接口定义，子类实现创建 FileInputStream, 27 用 io 流中的技术，指定一个文件夹的目录，获取此目录下的所有子文件夹路径28 请问你在什么情况下会在你得 java 代码中使用可序列化？ 如何实现 java 序列化？ Icon 把一个对象写入数据源或者从一个数据源读出来，使用可序列化，需要实现 Serializable 接口28 PrintStream、BufferedWriter、PrintWriter 的比较?PrintStream 类的输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成 PrintStream 后进行输出。它还提供其他两项功能。与其他输出流不同，PrintStream 永远不会抛出 IOException；而是，异常情况仅设置可通过 checkError 方法测试的内部标志。另外，为了自动刷新，可以创建一个 PrintStreamBufferedWriter: 将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过 write() 方法可以将获取到的字符输出，然后通过 newLine() 进行换行操作。BufferedWriter 中的字符流必须通过调用 flush 方法才能将其刷出去。并且 BufferedWriter 只能对字符流进行操作。如果要对字节流操作，则使用 BufferedInputStream。 PrintWriter 的 println 方法自动添加换行，不会抛异常，若关心异常，需要调用 checkError 方法看是否有异常发生，PrintWriter 构造方法可指定参数，实现自动刷新缓存（autoflush）； 1. 读写原始数据，一般采用什么流？（AC ）A InputStreamB DataInputStreamC OutputStreamD BufferedInputStream2. 为了提高读写性能，可以采用什么流？（ DF）A InputStreamB DataInputStreamC BufferedReaderD BufferedInputStreamE OutputStreamF BufferedOutputStream3. 对各种基本数据类型和 String 类型的读写，采用什么流？（ AD）A DataInputStreamB BufferedReaderC PrintWriterD DataOutputStreamE ObjectInputStreamF ObjectOutputStream4. 能指定字符编码的 I/O 流类型是：（BH ）A ReaderB InputStreamReaderC BufferedReaderD WriterE PrintWriterF ObjectInputStreamG ObjectOutputStreamH OutputStreamWriter5. File 类型中定义了什么方法来判断一个文件是否存在？（ D）A createNewFileB renameToC deleteD exists6. File 类型中定义了什么方法来创建一级目录？（ CD）A createNewFileB existsC mkdirsD mkdir File 类的 mkdir 方法根据抽象路径创建目录；File 类的 mkdirs 方法根据抽象路径创建目录，包括创建必需但不存在的父目录 7. 对文本文件操作用什么 I/O 流？（AD ）A FileReaderB FileInputStreamC RandomAccessFileD FileWriter8. 在 unix 服务器 www.openlab.com.cn 上提供了基于 TCP 的时间服务应用，该应用使用 port 为 13。创建连接到此服务器的语句是：（A ）A Socket s = new Socket(“www.openlab.com.cn”, 13);B Socket s = new Socket(“www.openlab.com.cn:13”);C Socket s = accept(“www.openlab.com.cn”, 13);9. 创建一个 TCP 客户程序的顺序是：（DACBE ）A 获得 I/O 流B 关闭 I/O 流C 对 I/O 流进行读写操作D 建立 socketE 关闭 socket10. 创建一个 TCP 服务程序的顺序是：（BCADEGF ）A 创建一个服务线程处理新的连接B 创建一个服务器 socketC 从服务器 socket 接受客户连接请求D 在服务线程中，从 socket 中获得 I/O 流E 对 I/O 流进行读写操作，完成与客户的交互F 关闭 socketG 关闭 I/O 流11. Java UDP 编程主要用到的两个类型是：（ BD）A UDPSocketB DatagramSocketC UDPPacketD DatagramPacket12. TCP/IP 是一种：（ B）A 标准B 协议C 语言D 算法 参考：java IO流面试总结 - CSDN博客https://blog.csdn.net/baidu_37107022/article/details/76890019]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO总结]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-3%2F</url>
    <content type="text"><![CDATA[字符流： Reader： 用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。 |—BufferedReader ：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 |—LineNumberReader ：跟踪行号的缓冲字符输入流。此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号。 |—InputStreamReader ：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 |—FileReader： ：用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。 |—CharArrayReade |—StringReader Writer： 写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。 |—BufferedWriter： ：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 |—OutputStreamWriter ：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 |—FileWriter： ：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。 |—PrintWrite |—CharArrayWriter |—StringWriter 字 节 流： InputStream： 是表示字节输入流的所有类的超类。 |— FileInputStream： ：从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。 |— FilterInputStream： ：包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。 |— BufferedInputStream ：该类实现缓冲的输入流。 |— Stream ： |— ObjectInputStream ： |— PipedInputStream OutputStream：此抽象类是表示输出字节流的所有类的超类。 |— FileOutputStream ：文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。 |— FilterOutputStream ：此类是过滤输出流的所有类的超类。 |— BufferedOutputStream ：该类实现缓冲的输出流。 |— PrintStream ： |— DataOutputStream ： |— ObjectOutputStream ： |— PipedOutputStream： 规律总结 IO 流中的对象：其实很简单，就是读取和写入。但是因为功能的不同，流的体系中提供 N 多的对象。那么开始时，到底该用哪个对象更为合适呢？这就需要明确流的操作规律。 1 ，明确源和目的。 数据源：就是需要读取，可以使用两个体系：InputStream、Reader； 数据汇：就是需要写入，可以使用两个体系：OutputStream、Writer； 2 ，操作的数据是否是纯文本数据？ 如果是：数据源：Reader 数据汇：Writer 如果不是：数据源：InputStream 数据汇：OutputStream 3 ，虽然确定了一个体系，但是该体系中有太多的对象，到底用哪个呢？明确操作的数据设备。 数据源对应的设备：硬盘 (File)，内存 (数组)，键盘 (System.in) 数据汇对应的设备：硬盘 (File)，内存 (数组)，控制台 (System.out)。 4 ，需要在基本操作上附加其他功能吗？比如缓冲。 如果需要就进行装饰。 根据规律实例化演示需求：读取键盘录入，将数据存储到一个文件中。规律分析1，明确体系： 源：InputStream ，Reader 目的：OutputStream ，Writer 2，明确数据： 源：是纯文本吗？是 Reader 目的；是纯文本吗？是 Writer 3，明确设备： 源：键盘，System.in 目的：硬盘，FileWriter InputStream in = System.in; FileWriter fw = new FileWriter(“a.txt”); 4，需要额外功能吗？ 需要，因为源明确的体系是 Reader。可是源的设备是 System.in。所以为了方便于操作文本数据，将源转成字符流。需要转换流。 1234InputStreamReader InputStreamReader isr = new InputStreamReader(System.in);FileWriter fw = new FileWriter(“a.txt”);BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));BufferedWriter bufw = new BufferedWriter(new FileWriter(“a.txt”)); 代码实现1234567891011121314151617181920212223242526272829303132333435/** * 通过键盘录入文字输出到文件 */public static void test3() &#123; BufferedWriter bufferedWriter = null; BufferedReader bufferedReader = null; try &#123; bufferedWriter = new BufferedWriter( new OutputStreamWriter( new FileOutputStream( "E:\\kejiang\\IdeaProjects\\JavaProjectTest\\src\\io\\SystemOut.txt"),"UTF-8")); bufferedReader = new BufferedReader(new InputStreamReader(System.in)); String s = ""; while ((s = bufferedReader.readLine()) != null) &#123; if ("over".equals(s)) &#123; break; &#125; bufferedWriter.write(s.toUpperCase()); bufferedWriter.newLine(); bufferedWriter.flush(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bufferedWriter.close(); bufferedReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行效果 控制台 123456这是通过键盘录入的数据测试一下overProcess finished with exit code 0 输出的文件 参考：Java IO流之规律总结 - CSDN博客https://blog.csdn.net/linglongxin24/article/details/52840580]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO学习笔记]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-1%2F</url>
    <content type="text"><![CDATA[Java IO 学习笔记（一）：File 类在整个 IO 包里，唯一表示与文件本身有关的类就是 File 类。使用 File 类可以进行创建或删除文件等常用操作。要想使用 File 类。则首先要观察 File 类的构造方法，此类的常用构造方法如下所示： public File(String pathname) 实例化 File 类的时候，必须设置好路径 实例操作一：创建一个新文件在 D 盘创建一个 test.txt 文件 12345678910111213import java.io.File;import java.io.IOException;public class Test1 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator+"test.txt");//为增加可移植性，建议使用File.separator try &#123; f.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实例操作二：删除一个指定文件删除刚刚创建的 test.txt 文件 12345678910import java.io.File;public class Test2 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator+"test.txt"); if(f.exists())&#123;//判断文件存不存在，如不存在就不用删除了 f.delete(); &#125; &#125;&#125; 实例操作三：综合创建，删除文件的操作给定一个路径，如果此文件存在，则删除，如果不存在，则创建 1234567891011121314151617import java.io.File;import java.io.IOException;public class Test3 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator+"test.txt"); if(f.exists())&#123; f.delete(); &#125;else&#123; try &#123; f.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 实例操作五：列出指定目录的全部文件如果现在给出了一个目录，则可以直接列出目录中的内容。但是列出的方法在 File 类中存在两个： 以字符串数组的形式返回：public String[] list() 以 File 数组的形式返回：public File[] listFiles() 操作一：使用 list() 列出全部内容 1234567891011import java.io.File;public class Test5 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator); String[] str=f.list(); for(String s:str)&#123; System.out.println(s); &#125; &#125;&#125; 以上列出了全部的名字，包括文件夹得名字和文件的名字。 操作二：使用 listFiles() 列出 1234567891011import java.io.File;public class Test6 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator); File[] files=f.listFiles(); for(File file:files)&#123; System.out.println(file); &#125; &#125;&#125; 以上列出了完全路径。 实例操作六：判断一个给定的路径是否为目录给定路径，判断是否是目录 123456789101112import java.io.File;public class Test7 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator); if(f.isDirectory())&#123; System.out.println(f.getPath()+"是目录"); &#125;else&#123; System.out.println(f.getPath()+"不是目录"); &#125; &#125;&#125; 实例操作七：列出指定目录的全部内容如果给定了一个目录，则要求把此目录中的全部文件都列出来，包括子文件夹下的文件 12345678910111213141516171819202122import java.io.File;public class Test8 &#123; public static void main(String[] args) &#123; File f = new File("d:" + File.separator); print(f); &#125; public static void print(File f) &#123; if (f != null) &#123; if (f.isDirectory()) &#123; File[] files = f.listFiles(); if (files != null) &#123; for (File file : files) &#123; print(file); &#125; &#125; &#125; else &#123; System.out.println(f); &#125; &#125; &#125;&#125; 总结： File 类是在 java.io 包中唯一与文件本身有关的 可以使用 File 类创建、删除等常见的文件操作 在使用 File 类指定路径的时候一定要注意操作系统间的差异，尽量使用 separator 进行分割 Java IO学习笔记（二）：RandomAccessFile类之前的 File 类只是针对文件本身进行操作的，而如果相对文件内容进行操作，则可以使用 RandomAccessFile 类，此类属于随机读取类，可以随机的读取一个文件中指定位置的数据。 因为在文件中，所有得内容都是按照字节存放的，都有固定的保存位置。 构造函数： public RandomAccessFile(File file,String mode)throws FileNotFoundException 实例化此类的时候需要传递 File 类。告诉程序应该操作的是哪个文件，之后有个模式，文件的打开模式，常用的两种模式： r：读 w：写 rw：读写，如果使用此模式，如果文件不存在，则会自动创建 先写信息： 12345678910111213141516171819import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;public class Test9 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); RandomAccessFile raf=new RandomAccessFile(f,"rw");//读写模式，如果该路径不存在会自动创建 String name1="jim"; int age1 =20; String name2="Tom"; int age2=30; raf.writeBytes(name1); raf.writeInt(age1); raf.writeBytes(name2); raf.writeInt(age2); raf.close(); &#125;&#125; 然后读文件： 1234567891011121314151617181920212223242526import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;public class Test10 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); RandomAccessFile raf=new RandomAccessFile(f,"r");//以读模式打开 raf.skipBytes(7);//跳过第一个人的信息 byte[] bs=new byte[3]; for(int i=0;i&lt;bs.length;i++)&#123; bs[i]=raf.readByte(); &#125; String name2=new String(bs); int age2=raf.readInt(); System.out.println(name2+" "+age2); raf.seek(0);//指针回到文件开头，读取第二个人的信息 for(int i=0;i&lt;bs.length;i++)&#123; bs[i]=raf.readByte(); &#125; String name1=new String(bs); int age1=raf.readInt(); System.out.println(name1+" "+age1); &#125;&#125; 另外：可能有的同学输入的是中文，那么使用 getBytes() 转换，会占 3 个字节（取决你的本地编码，如果用 Eclipse 可设置成 UTF-8），咦？java 里面中文不是占两个字节吗？怎么会变成 3 个字节呢？其实这不是一个概念，java 默认字符编码的是 unicode，确实占两个字节，但是在 String 换转 byte[] 时用的 getBytes() 默认用的编码进行转换，那么就会占 3 个字节，unicode 和 UTF-8 不是一个概念，仔细观察的话会发现 getBytes() 方法有另外的重载 getBytes(“……”)，例如通过 getBytes(“gbk”)，这是转化的中文就会变成两字节了。 Java IO学习笔记（三）：字节流与字符流先来看一下流的概念： 在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。 程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。 字节流与字符流在 java.io 包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用 OutputStream 完成，输入使的是 InputStream，在字符流中输出主要是使用 Writer 类完成，输入流主要使用 Reader 类完成。（这四个都是抽象类） 操作流程在 Java 中 IO 操作也是有相应步骤的，以文件操作为例，主要的操作流程如下： 使用 File 类打开一个文件 通过字节流或字符流的子类，指定输出的位置 进行读 / 写操作 关闭输入 / 输出 IO 操作属于资源操作，一定要记得关闭 字节流字节流主要是操作 byte 类型数据，以 byte 数组为准，主要操作类就是 OutputStream、InputStream 字节输出流：OutputStream OutputStream 是整个 IO 包中字节输出流的最大父类，此类的定义如下： public abstract class OutputStream extends Object implements Closeable,Flushable 从以上的定义可以发现，此类是一个抽象类，如果想要使用此类的话，则首先必须通过子类实例化对象，那么如果现在要操作的是一个文件，则可以使用：FileOutputStream 类。通过向上转型之后，可以为 OutputStream 实例化 Closeable 表示可以关闭的操作，因为程序运行到最后肯定要关闭 Flushable：表示刷新，清空内存中的数据 FileOutputStream 类的构造方法如下： public FileOutputStream(File file)throws FileNotFoundException 写数据： 123456789101112131415import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建 String str="Hello World"; byte[] b=str.getBytes(); out.write(b);//因为是字节流，所以要转化成字节数组进行输出 out.close(); &#125;&#125; 也可以一个字节一个字节进行输出，如下： 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建 String str="Hello World"; byte[] b=str.getBytes(); for(int i=0;i&lt;b.length;i++)&#123; out.write(b[i]); &#125; out.close(); &#125;&#125; 以上输出只会进行覆盖，如果要追加的话，请看 FileOutputStream 类的另一个构造方法： public FileOutputStream(File file,boolean append)throws FileNotFoundException 在构造方法中，如果将 append 的值设置为 true，则表示在文件的末尾追加内容。 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); OutputStream out=new FileOutputStream(f,true);//追加内容 String str="\r\nHello World"; byte[] b=str.getBytes(); for(int i=0;i&lt;b.length;i++)&#123; out.write(b[i]); &#125; out.close(); &#125;&#125; 文件中换行为：\r\n 字节输入流：InputStream既然程序可以向文件中写入内容，则就可以通过 InputStream 从文件中把内容读取进来，首先来看 InputStream 类的定义： public abstract class InputStream extends Object implements Closeable 与 OutputStream 类一样，InputStream 本身也是一个抽象类，必须依靠其子类，如果现在是从文件中读取，就用 FileInputStream 来实现。 观察 FileInputStream 类的构造方法： public FileInputStream(File file)throws FileNotFoundException 读文件： 123456789101112131415import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test12 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); InputStream in=new FileInputStream(f); byte[] b=new byte[1024]; int len=in.read(b); in.close(); System.out.println(new String(b,0,len)); &#125;&#125; 但以上方法是有问题的，用不用开辟这么大的一个字节数组，明显是浪费嘛，我们可以根据文件的大小来定义字节数组的大小，File 类中的方法：public long length() 123456789101112131415import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test13 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); InputStream in=new FileInputStream(f); byte[] b=new byte[(int) f.length()]; in.read(b); in.close(); System.out.println(new String(b)); &#125;&#125; 我们换种方式，一个字节一个字节读入~ 1234567891011121314151617import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test14 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); InputStream in=new FileInputStream(f); byte[] b=new byte[(int) f.length()]; for(int i=0;i&lt;b.length;i++)&#123; b[i]=(byte) in.read(); &#125; in.close(); System.out.println(new String(b)); &#125;&#125; 但以上情况只适合知道输入文件的大小，不知道的话用如下方法： 1234567891011121314151617181920import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test15 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); InputStream in=new FileInputStream(f); byte[] b=new byte[1024]; int temp=0; int len=0; while((temp=in.read())!=-1)&#123;//-1为文件读完的标志 b[len]=(byte) temp; len++; &#125; in.close(); System.out.println(new String(b,0,len)); &#125;&#125; 字符流在程序中一个字符等于两个字节，那么 java 提供了 Reader、Writer 两个专门操作字符流的类。 字符输出流：WriterWriter 本身是一个字符流的输出类，此类的定义如下： public abstract class Writer extends Object implements Appendable，Closeable，Flushable 此类本身也是一个抽象类，如果要使用此类，则肯定要使用其子类，此时如果是向文件中写入内容，所以应该使用 FileWriter 的子类。 FileWriter 类的构造方法定义如下： public FileWriter(File file)throws IOException 字符流的操作比字节流操作好在一点，就是可以直接输出字符串了，不用再像之前那样进行转换操作了。 写文件： 1234567891011121314import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Test16 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Writer out=new FileWriter(f); String str="Hello World"; out.write(str); out.close(); &#125;&#125; 在默认情况下再次输出会覆盖，追加的方法也是在构造函数上加上追加标记 1234567891011121314import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Test17 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Writer out=new FileWriter(f,true);//追加 String str="\r\nHello World"; out.write(str); out.close(); &#125;&#125; 字符输入流：ReaderReader 是使用字符的方式从文件中取出数据，Reader 类的定义如下： public abstract class Reader extends Objects implements Readable，Closeable Reader 本身也是抽象类，如果现在要从文件中读取内容，则可以直接使用 FileReader 子类。 FileReader 的构造方法定义如下： public FileReader(File file)throws FileNotFoundException 以字符数组的形式读取出数据： 123456789101112131415import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class Test18 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Reader input=new FileReader(f); char[] c=new char[1024]; int len=input.read(c); input.close(); System.out.println(new String(c,0,len)); &#125;&#125; 也可以用循环方式，判断是否读到底： 1234567891011121314151617181920import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class Test19 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Reader input=new FileReader(f); char[] c=new char[1024]; int temp=0; int len=0; while((temp=input.read())!=-1)&#123; c[len]=(char) temp; len++; &#125; input.close(); System.out.println(new String(c,0,len)); &#125;&#125; 字节流与字符流的区别字节流和字符流使用是非常相似的，那么除了操作代码的不同之外，还有哪些不同呢？ 字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的 字节流在操作文件时，即使不关闭资源（close 方法），文件也能输出，但是如果字符流不使用 close 方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用 flush 方法强制进行刷新缓冲区，这时才能在不 close 的情况下输出内容 那开发中究竟用字节流好还是用字符流好呢？ 在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。 如果要 java 程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）。 Java IO学习笔记（四）：字节-字符转换流OutputStreamWriter 和 InputStreamReader在整个 IO 包中，实际上就是分为字节流和字符流，但是除了这两个流之外，还存在了一组字节流 - 字符流的转换类。 OutputStreamWriter：是 Writer 的子类，将输出的字符流变为字节流，即：将一个字符流的输出对象变成字节流的输出对象。 InputStreamReader: 是 Reader 的子类，将输入的字节流变为字符流，即：将一个字节流的输入对象变成字符流的输入对象。 一般在操作输入输出内容就需要使用字节或字符流，但是有些时候需要将字符流变成字节流的形式，或者将字节流变为字符流的形式，所以，就需要另外一组转换流的操作类。 看一下 OutputStreamWriter 的构造方法： public OutputStreamWriter(OutputStream out) 例如，将字节的文件输出流，以字符的形式输出 1234567891011121314import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;public class Test20 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Writer out=new OutputStreamWriter(new FileOutputStream(f)); out.write("Hello World!!!"); out.close(); &#125;&#125; 读得时候也可以用字符流形式读取字节流的对象 12345678910111213141516import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.Reader;public class Test21 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Reader input=new InputStreamReader(new FileInputStream(f)); char[] c=new char[1024]; int len=input.read(c); input.close(); System.out.println(new String(c,0,len)); &#125;&#125; 以上操作只是以文件操作为例，OutputStreamWriter 中接受的类型是 OutputStream，只要是字节输出流都可以以使用字符的形式操作，InputStreamReader 一样。 FileWriter 和 FileReader 的说明从 JDK 文档中可以知道 FileOutputStream 是 OutputStream 的直接子类。FileInputStream 也是 InputStream 的直接子类，但是在字符流文件的两个操作类却有一些特殊，FileWriter 并不直接是 Writer 的子类，而是 OutputStreamWriter 的子类，而 FileReader 也不直接是 Reader 的子类，而是 InputStreamReader 的子类，那么从这两个类的继承关系就可以清楚的发现，不管是使用字节流还是字符流实际上最终都是以字节的形式操作输入输出流的。也就是说，传输或者从文件中读取数据的时候，文件里真正保存的数据永远是字节。 Java IO学习笔记（五）：内存操作流ByteArrayInputStream 和 ByteArrayOutputStream之前所讲解的程序中，输出和输入都是从文件中来得，当然，也可以将输出的位置设置在内存之上，此时就要使用 ByteArrayInputStream、ByteArrayOutputStream 来完成输入输出功能了 ByteArrayInputStream 的主要功能将内容输入到内存之中 ByteArrayOutputStream 的主要功能是将内存中的数据输出 此时应该把内存作为操作点 ByteArrayInputStream 类的定义： public class ByteArrayInputStream extends InputStream 构造方法： public ByteArrayInputStream(byte[] buf) 接受一个 byte 数组，实际上内存的输入就是在构造方法上将数据传入到内存中。 ByteArrayOutputStream：输出就是从内存中写出数据 public void write(int b) 以下是以内存操作流完成的一个大小写字母转换的程序： 1234567891011121314151617181920import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class Test22 &#123; public static void main(String[] args) throws IOException &#123; String str="HELLO WORlD!!!"; InputStream input=new ByteArrayInputStream(str.getBytes()); OutputStream output=new ByteArrayOutputStream(); int temp=0; while((temp=input.read())!=-1)&#123; output.write(Character.toLowerCase(temp)); &#125; input.close(); output.close(); System.out.println(output.toString()); &#125;&#125; Java IO学习笔记（六）：管道流管道流（线程通信流）管道流的主要作用是可以进行两个线程间的通讯，分为管道输出流 (PipedOutputStream)、管道输入流（PipedInputStream），如果想要进行管道输出，则必须要把输出流连在输入流之上，在 PipedOutputStream 类上有如下的一个方法用于连接管道： public void connect(PipedInputStream snk)throws IOException 例子：线程之间用管道流进行通讯 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;class Send implements Runnable&#123; private PipedOutputStream pos;//管道输出流 public Send()&#123; pos=new PipedOutputStream(); &#125; @Override public void run() &#123; String str="Hello World!"; try &#123; pos.write(str.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; pos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public PipedOutputStream getPos() &#123; return pos; &#125;&#125;class Receive implements Runnable&#123; private PipedInputStream pis;//管道输入流 public Receive()&#123; pis=new PipedInputStream(); &#125; @Override public void run() &#123; byte[] b=new byte[1024]; int len=0; try &#123; len=pis.read(b); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; pis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(b,0,len)); &#125; public PipedInputStream getPis() &#123; return pis; &#125;&#125;public class Test23 &#123; public static void main(String[] args) &#123; Send send=new Send(); Receive receive=new Receive(); try &#123; send.getPos().connect(receive.getPis());//连接管道 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; new Thread(send).start();//启动线程 new Thread(receive).start();//启动线程 &#125;&#125; Java IO学习笔记（七）：打印流在整个 IO 包中，打印流是输出信息最方便的类，主要包含字节打印流（PrintStream）和字符打印流（PrintWrite）。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等。 看一下 PrintStream 的构造方法： public PrintStream(OutputStream out) 在 PrintStream 中定义的构造方法中可以清楚的发现有一个构造方法可以直接接收 OutputStream 类的实例，这是因为与 OutputStream 相比起来，PrintStream 可以更加方便的输出数据，这就好比将 OutputStream 类重新包装了一下，使之输出更加方便。 使用 PrintStream 输出信息： 1234567891011121314import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class Test24 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); PrintStream output=new PrintStream(new FileOutputStream(f)); output.println("Hello World!"); output.print("1+1="+2); output.close(); &#125;&#125; 也就是说此时，实际上是将 FileOutputStream 类的功能包装了一下，这样的设计在 java 中称为装饰设计。 但如果仅仅是上面的那些功能也未免太寒碜了吧，好吧，看绝招，大家学过 C 吧~： 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class Test25 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); PrintStream output=new PrintStream(new FileOutputStream(f)); String name="Jim"; int age=20; float score=90.5f; char sex='M'; output.printf("姓名：%s 年龄：%d 成绩：%f 性别：%c", name,age,score,sex); output.close(); &#125;&#125; 哈哈，竟然有 printf！~ 而且你要是觉得 %s %d %f %c 太麻烦，可以全用 %s 代替，比 C 的 printf 还好用 Java IO学习笔记（八）：System类对IO的支持System 类的常量System 表示系统类，此类也对 IO 给予了一定的支持。 public static final PrintStream out 对应系统标准输出，一般是显示器 public static final PrintStream err 错误信息输出 public static final InputStream in 对应着标准输入，一般是键盘 又是由于历史遗留问题 全局变量没有大写~ System.out使用 System.out 输出的时候就是将输出的位置定义在了显示器之中。 FileOutputStream 是定位在文件里，而 System.out 是定位在屏幕上。 使用 OutputStream 完成屏幕上输出（PrintStream 是 OutputStream 的子类） 12345678910 import java.io.IOException; import java.io.OutputStream; public class Test26 &#123; public static void main(String[] args) throws IOException &#123; OutputStream out=System.out; out.write("Hello World!".getBytes()); out.close(); &#125;&#125; 这其实就是多态的一种表现 System.errSystem.err 表示的错误的标准输出，如果程序中出现了错误的话，则直接使用 System.err 进行打印输出即可。 12345678910public class Test27 &#123; public static void main(String[] args) &#123; String str="Hello World"; try&#123; int a=Integer.parseInt(str); &#125;catch(Exception e)&#123; System.err.println(e); &#125; &#125;&#125; 但是有些人会问这跟 System.out 输出的结果完全一样的嘛，有什么区别啊？ System.out 与 System.err 的区别 System.out 和 System.err 都是 PrintStream 的实例化对象，而且通过实例代码可以发现，两者都可以输出错误信息，但是一般来讲 System.out 是将信息显示给用户看，是正常的信息显示，而 System.err 的信息正好相反是不希望用户看到，会直接在后台打印，是专门显示错误的 一般来讲，如果要想输出错误信息的时候最好不要使用 System.out 而是直接使用 System.err，这一点只能从其概念上划分。 System.inSystem.in 实际上是一个键盘的输入流，其本身是 InputStream 类型的对象。那么，此时就可以利用此方式完成从键盘读取数据的功能。 InputStream 对应的是输入流，输入流的话肯定可以从指定位置上读取，之前使用的是 FileInputStream 是从文件中读取的 1234567891011import java.io.IOException;import java.io.InputStream;public class Test28 &#123; public static void main(String[] args) throws IOException &#123; InputStream in=System.in; byte[] b=new byte[1024]; int len=in.read(b); System.out.println(new String(b,0,len)); &#125;&#125; 如果不使用 byte 数组指定长度呢： 1234567891011121314151617import java.io.IOException;import java.io.InputStream;public class Test29 &#123; public static void main(String[] args) throws IOException &#123; InputStream in=System.in; StringBuilder buf=new StringBuilder(); int temp=0; while((temp=in.read())!=-1)&#123; char c=(char) temp; if(c=='\n')break; buf.append(c); &#125; in.close(); System.out.println(buf.toString()); &#125;&#125; 但以上代码还是有很大问题的，输入中文的话~，所以最好的方法还是一次性把数据都放在内存了，再一次性全部拿出来，要实现这个功能的话，要用到 BufferedReader 类，下回介绍~ 输入输出重定向System.out、System.err、System.in 都有重定向功能，分别是 setOut、setErr、setIn 方法 System.out 重定向 123456789101112import java.io.File;import java.io.FileNotFoundException;import java.io.PrintStream;public class Test30 &#123; public static void main(String[] args) throws FileNotFoundException &#123; File f = new File("d:" + File.separator+"test.txt"); System.setOut(new PrintStream(f)); String str="This is a test!"; System.out.println(str); &#125;&#125; System.err 重定向 1234567891011import java.io.ByteArrayOutputStream;import java.io.PrintStream;public class Test31 &#123; public static void main(String[] args) &#123; ByteArrayOutputStream out=new ByteArrayOutputStream(); System.setErr(new PrintStream(out)); System.err.println("Test---------------"); System.out.println(out.toString()); &#125;&#125; 一般不建议修改 err 的重定向，因为这些信息都不太希望用户看到 System.in 重定向 12345678910111213141516import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test32 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); System.setIn(new FileInputStream(f)); InputStream in=System.in; byte[] b=new byte[1024]; int len=in.read(b); in.close(); System.out.println(new String(b,0,len)); &#125;&#125; 一般，使用最多的还是 System.out 的重定向~ Java IO学习笔记（九）：BufferedReader和Scanner如果想要接收任意长度的数据，而且避免乱码产生，就可以使用 BufferedReader 类 public class BufferedReader extends Reader 因为输入的数据有可能出现中文，所以，此处使用字符流完成。BufferedReader 是从缓冲区之中读取内容，所有的输入的字节数据都将放在缓冲区之中。 System.in 本身表示的是 InputStream（字节流），现在要求接收的是一个字符流，需要将字节流变成字符流才可以，所以要用 InputStreamReader 1234567891011import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Test33 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader reader=new BufferedReader(new InputStreamReader(System.in)); String str=reader.readLine(); System.out.println(str); &#125;&#125; 在 JDK1.5 之后 Java 提供了专门的输入数据类，此类可以完成 BufferedReader 类的功能，也可以方便的对输入数据进行验证，此类存放在 java.util 包中 使用 Scanner 接收键盘的输入数据： 123456789import java.util.Scanner;public class Test34 &#123; public static void main(String[] args) &#123; Scanner s=new Scanner(System.in); String str=s.next(); System.out.println(str); &#125;&#125; 比直接使用 BufferedReader 更加方便，但是这个程序是有问题的，如果输入的字符串中存在空格，那么就会截止，如果我们要接收空格的下，将分隔符变成 “\n”。 12345678910import java.util.Scanner;public class Test34 &#123; public static void main(String[] args) &#123; Scanner s=new Scanner(System.in); s.useDelimiter("\n");//使用分隔符 String str=s.next(); System.out.println(str); &#125;&#125; 参考：java IO - 标签 - 一直在等 - 博客园http://www.cnblogs.com/lich/tag/java%20IO/]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 生成速度过慢]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-2%2F</url>
    <content type="text"><![CDATA[参考：Speed Up the Rendering Process of hexo 3 | HaHackhttp://www.hahack.com/codes/hexo-3-speed-up/hexo3中hexo g生成速度过慢 | SHANG Bloghttps://blog.xinshangshangxin.com/2015/06/29/hexo3%E4%B8%ADhexo-g%E7%94%9F%E6%88%90%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx实战]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31%2F</url>
    <content type="text"><![CDATA[使用理由 123456配置文件简单支持Rewrite重写规则内置健康检查功能节省带宽稳定性高支持热部署 平滑重启 1kill -HUP \`/usr/local/nginx/logs/nginx.pid\` 当Nginx接收到hup信号时，它会尝试先解析配置文件，如果 成功就应用新的配置谁的，之后，Nginx运行新的工作进程并从容关闭旧的工作进程 ，通知工作进程 关闭监听大套接字，但是继续为新的客户提供服务 ，所有客户端的服务完成后旧的工作进程 被关闭。如果 新的配置文件应用失败，Nginx继续使用旧的配置进行工作。 Nginx支持以下几种信号 TERM, INT 快速关闭; QUIT 从容关闭； HUP 平滑重启，重新加载配置文件； USR1 重新的打开日志文件，在切割日志时用途较大； USR2 平滑升级可执行程序 ； WINCH 从容关闭工作进程。 nginx配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#使用的用户和组user www www;#指定工作衍生进程数（一般等于CUP的总或总的两倍，例如两个 四核CUP，则总核数为8）worker_processes 8;#指定错误日志存放的路径，错误日志记录级别可选项为：【debug | info | notice | warn | error | crit 】error_log /data1/logs/nginx_error.log crit;#指定PID存放的路径pid /usr/local/nginx/nginx.pid;#指定文件描述符数量 worker_rlimit_nofile 51200;events &#123; #使用的网络I/O模型，Linux系统推荐采用epoll模型，FreeBSD系统采用kqueue模型use epoll;#允许的连接数worker_connections 51200;&#125;http &#123;include mime types;default_type application/octet-stream;#设置使用的字符集，如果 一个网站 有多种字符集，请不要随便设置，就让程序 员在html代码中通过meta标签设置#charset gb2312;server_names_hash_bucket_size 128;client_header_buffer_size 32k;large_client_header_buffers 4 32k;#设置客户端能够上传文件的大小client_max_body_size 8m;sendfile on;tcp_nopush on;keepalive_timeout 60;tcp_nodelay on;fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fasgcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;#开启gzip压缩gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_http_version 1.1;gzip_comp_level 2;gzip_types text/plain application/x-javascript text/css application/xml;gzip_vary on;#limit_zone crawler $binary_remote_addr 10m;server &#123;#监听的IP和端口 listen 80;#主机名称 server_name www.yourdomain.com yourdomain.com;#默认首页文件，顺序从左到右，如果 找不到index.html文件，则查找 index.htm文件作为首页文件index index.html index.htm index.php;root /data0/htdocs;#limit_conn crawler 20;location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$&#123; expires 30d;&#125; location ~ .*\.(js|css)?$&#123; expires 1h;&#125;log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos; $status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;$http_user_agent&quot; $http_x_forwarded_for&apos;;access_log /data1/logs/access.log access;&#125;&#125; 虚拟主机 虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成一台台 “虚拟” 的主机，每台虚拟主机都可以是一个独立的网站，可以具有独立的域名，具有完整的 Internet 服务器功能（www、FTP、Email 等），同一台主机上的虚拟主机之间是完全独立的。从网站访问者来看，每一台虚拟主机和一台独立的主机完全一样。 利用虚拟主机，不用为每个要运行的网站 提供一台单独的 Nginx 服务 器或单独运行一级 nginx 进程 。虚拟主机提供了在同一台服务器、同一级 Nginx 进程 上运行多个网站 的功能。 跟 apache 一样，Nginx 也可以配置多种类型的虚拟主机; 一是基于 ip 的虚拟主机，二是基于域名的虚拟主机，三是基于端口的虚拟主机。 一段 server{……} 就是一个虚拟该机，如果要配置多个虚拟主机，建立多段 server{} 配置即可，非常方便，监听的 IP 商品也可以不写 IP 地址，只写端口，把它配置成 “listen 80”，则表示监听 该服务器所有 IP 的 80 端口，可通过 server_name 区分不同的虚拟主机。 反向代理后客户端 IP 问题 由于在客户端和 web 服务器之间增加了蹭层，因此 web 服务器无法直接拿到客户端的 IP, 通过 $remote_addr 变量拿到的是反向代理服务器的 ip 地址，但是，反射代理服务器在转发请求的 HTTP 头信息中，可以增加 X-Forwarded-For 信息，用以记录原有的客户端 IP 地址和原来客户端请求的服务器地址 日志切割 12345#!/bin/bashlogs_path = &quot;/data1/logs/&quot;mkdir -p $&#123;logs_path&#125;$(date -d &quot;yesterday&quot; + &quot;%Y&quot;)/$(date -d &quot;yesterday&quot; + &quot;%m&quot;)/mv $&#123;logs_path&#125;access.log $&#123;logs_path&#125;$(date -d &quot;yesterday&quot; + &quot;%Y&quot;)/$(date -d &quot;yesterday&quot; + &quot;%m&quot;)/access_$(date -d &quot;yesterday&quot; + &quot;%Y%m%d&quot;).logkill -USR1 `cat /usr/local/nginx/nginx.pid` 配置 crontab 每天凌晨 00：00 定时执行这个脚本：crontab -e Nginx 的压缩输出配置 gizp(GNU-ZIP) 是一种压缩技术。经过 gzip 压缩后页面的大小可以变为原来的 30% 甚至更小。这样，用户浏览页面时候会快很多。gzip 的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，浏览器端解压并解析。大多数浏览器都支持解析 gzip 过的页面。配置在 http{} 段中： 1234567gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_http_version 1.1;gzip_comp_level 2;gzip_types text/palin application/x-javascript text/css application/xml;gzip_vary on; 自动目录配置 前提：当前目录下不存在 index 指令设置的默认首页文件。 1234567location / &#123; autoindex on;&#125;相关指令#设定索引时文件大小的单位【B、KB、GB】autoindex_exact_xize [on|off]#开户本地时间来显示 文件时间的功能。默认为关(GMT时间) Nginx 的浏览器本地缓存设置 (Browser Cacging) 浏览器缓存是为了加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示 文档，这样就可以加速页面的浏览。缓存 的方式节约了网络的资源，提高网络的效率。 fastcgi FastCG 是语言无关的、可伸缩架构的 CGI 开放扩展，其主要行为是将 CGI 解释器进程保持在内存中并因此获得较高的性能，众所周知，CGI 解释器的反复加载是 CGI 性能低下的主要原因，如果 CGI 解释器保持在内存中并接受 FastCGI 进程 管理器调度，则可以提供良好的性能，伸缩性、Fail-Over 特性等。 fastcgi 原理和优点 mysql 管理 shell 脚本 vi /data0/mysql/3306/mysql 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/shmysql_port=3306mysql_usermysql_password=&quot;123456&quot;function_start_mysql() &#123; printf &quot;starting mysql...\n&quot; /bin/sh/usr/local/mysql/bin/mysqld_safe --defaults-file=/data0/mysql/$&#123;mysql_port&#125;/my.cnf 2&gt;&amp;1&gt;/dev/null &amp;&#125;function_stop_mysql() &#123; printf &quot;stoping mysql...\n&quot; /usr/local/mysql/bin/mysqladmin -u $&#123;mysql_username&#125; -p $&#123;mysql_password&#125; -S /tmp/mysql.sock shutdown&#125;function_restart_mysql()&#123; printf &quot;restarting mysql...\n&quot; function_stop_mysql sleep 5 function_start_mysql&#125;function_kill_mysql()&#123; kill -9 $(ps -ef | grep &apos;bin/mysqld_safe&apos; | grep $&#123;mysql_port&#125; | awk &apos;&#123;printf $2&#125;&apos;) kill -9 $(ps -ef | grep &apos;libexec/mysqld&apos; | grep $&#123;mysql_port&#125; | awk &apos;&#123;printf $2&#125;&apos;)&#125;if [ &quot;$1&quot; = &quot;start&quot;]; then function_start_mysqlelif [ &quot;$1&quot; = &quot;stop&quot; ]; then function_stop_mysqlelif [&quot;$1&quot; = &quot;restart&quot; ]; then function_restart_mysqlelif [ &quot;$1&quot; = &quot;kill&quot; ]; then function_kill_mysqlelse printf &quot;Usage:/data0/mysql/$&#123;mysql_prot&#125;/mysql &#123;start|stop|restart|kill&#125;\n&quot;fi chmod +x /data0/mysql/3306/mysql 启动 mysql: /data0/mysql/3306/mysql start /usr/local/mysql/bin/mysql -u -root -p -S /tmp/mysql.sock 创建一个具有 root 权限的用户和密码 12GRANT ALL PRIVILEGES ON *.* TO &apos;admin&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;GRANT ALL PRIVILEGES ON *.* TO &apos;admin&apos;@&apos;127.0.01&apos; IDENTIFIED BY &apos;123456&apos;; 为什么使用负载 均衡 随着网站 访问量的快速增长，单台服务器已经无法承担大量用户的并发访问，必须采用多台服务器协同工作，以提高计算机系统的处理能力和计算强度，满足当前业务量的需求。而如何 在完成同样功能的多个网络设备之间实现合理的业务量分配，使之不会出现一台设备过忙，而其它设备却没有充分使用的情况。要解决这一问题，可以采用负载 均衡的方法 负载均衡 负载均衡是由多台服务器以对称的方式组成 一个服务器集合，每台服务器具有等价的地位，都可以单独对提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部送来请求均匀分配到对称的某一台服务器上，而接收到请求的服务器独立 地回应客户的请求。均衡负载 能够平均分配 客户请求到服务器阵列，藉此快速获取重要数据，解决大量并发访问服务问题。这种集群技术可以用最少 的投资获得接近于大型主机的性能 。 反向代理 反向代理是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 负载均衡实现方式 用户手动选择 DNS 轮询方式（可靠性低，负载分配 不均衡） upstream 中的 ip_hash 会使相同的用户访问后端同一个服务器但是会影响负载均衡 如果后端有时候要从 Nginx 负载均衡（已使用 ip_hash）中摘除一段时间，你必须将其标记为 “down”，而不是直接从配置文件中删掉或注释掉该后端服务器信息 1234567upstream bakcend&#123; ip_hash; server backend1.example.com; server backend2.example.com; server bakcend3.example.com down; server backend4.example.com;&#125; rewrite 规则的用处 通过 Rewrite 规则，可以实现规范的 URL，根据变量来做 URL 转向及选择配置。例如，一些使用 MVC 框架的程序只有一个入口，可以通过 Rewrite 来实现 ，一些动态 URL 地址需要伪装成静态 HTML，全球搜索引擎攫取，也需要 Rwrite 来处理，一些由于目录结构、域名变化的旧 URL 需要跳转到新的 URL 上，也可以通过 Rwrite 来处理 if 中的条件 rewrite 该指令根据表达试来重定向 URI, 或者修改字符串，指令根据配置文件中的顺序来执行。重写表达式只对相对路径有效，如果你想配对主机名，需要使用 if 语句： 1234if ($host ~* www\.(.*)) &#123; set $host_without_www $1; rewrite ^(.*)$ http://$host_without_www$1 permanent;&#125; 如果字符串以http://开头，将会采用 301 或 302 跳转进行 URL 重定向。 rewrite 指命的 flag last 和 break 标记的实现功能类似 ，但二者之间有细微的差别，使用 alias 指令时必须用 last 标记，使用 proxy_pass 指令时要使用 break 标记，lat 标记在本条 rewrite 规则执行完毕后，终止匹配，不再匹配后面的规则。一般在根 location 中（即 location / {}) 或直接在 server 标签中编写 rewrite 规则，推荐使用 last 标记，在非根 location 中 （例如 location /cms/ {}）, 则使用 break 标记。 如果被替换的 URI 中含有参数（妈类似 / app/test.php?id=5 之类的 URI），默认情况下参数 会被自动加到替换串上，可以在末尾加上? 来解决这个问题。如rewrite ^/users/(.*)$ /show?user=$1? last; 对花括号来说，它们既能用在重定向的正规表达式里，也能用在配置文件里分割代码块，为了避免冲突，正则表达式里如果 带花括号，应该用双引号或单引号包围如：/photos/123456 =&gt; /path/to/photos/12/1234/123456.png rewrite &quot;/photos/([0-9]{2})([0-9]{2})([0-9]{2})&quot; /path/to/photos/$1/$1$2/$1$2$3.png; Nginx 的 Rwrite 规则编写实例 123456789if (!-e $request_filename) &#123; rewrite ^/(.*)$ /index.php last;&#125;多目录转成参数 abc.domain.com/sort/2 =&gt; abc.domain.com/index.php?act=sort&amp;name=abc&amp;id=2;if ($host ~* (.*)\.domain\.com) &#123; set $sub_name $1; rewrite ^/sort\/(\d)\/?$ /index.php?act=sort&amp;name=$sub_name&amp;id=$1 last;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647目录对换/123456/xxxx =&gt; /xxxx?id=1234565:rewrite ^/(\d+)/(.+)/ /$2?id=$1 last;如果 客户端 使用IE浏览器，则重定向到/nginx-ie目录下if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /nginx-ie/$1 break;&#125;禁止访问多个目录:location ~ ^/(cron|templates)/ &#123; deny all; break;&#125;禁止访问以/data/开头的文件:location ~ ^/data &#123; deny all;&#125;设置某些类型文件的浏览器缓存时间：location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d;&#125;location ~ .*\.(js|css)$ &#123; expires 1h;&#125;将多级目录下的文件转换成一个文件/job-123-456-789.html 指向/job/123/456/789.htmlrewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/$1/$2/jobshow_$3.html last;禁止访问以.sh、.flv、.mp4为文件后缀的URL地址：location ~ .*\.(sh|flv|mp4)?$ &#123; return 403;&#125;适用于Zend Framework重写规则:if ($request_uri ~* &quot;^/pay(.*)&quot;) &#123; set $var_pay_public &apos;1&apos;;&#125;if ($request_uri ~* &quot;.&quot;\.(js|ico|gif|jpg|png|css)$&quot;) &#123; set $var_pay_public &apos;0&apos;;&#125;if ($request_pay_public ~ &apos;1&apos;) &#123; rewirte ^(.*)$ /pay/index.php last;&#125; 12345678910111213141516171819202122232425Bo-blog开源PHP博客系统伪静态重写规则if (! -x $request_filename) &#123; rewrite ^/post/([0-9]+)/?([0-9+])/?([0-9]?/?$) /read.php/entryid=$1&amp;page=$2&amp;part=$3 lastrewrite ^/page/([0-9]+)/([0-9]+)?/?$ /index.php?mode=$1&amp;page=$2 last;rewrite ^/started/([0-9]+)/?([0-9]+)?/?$ /star.php?mode=$1&amp;page=$2 last;rewrite ^/category/([^/]+)/?([0-9]+)?/?([0-9]+)?/?$ /index.php?go=category_$1&amp;mode=$2&amp;page=$3 lastrewrite ^/archiver/([0-9]+)/([0-9]+)/?([0-9]+)?/?([0-9]+)?/?$ /index.php?go=archive&amp;cm=$1&amp;cy=$2&amp;mode=$3&amp;page=$4 last;rewrite ^/date/([0-9]+)/([0-9]+)/([0-9]+)/?([0-9]+)?([0-9]+)?/?([0-9]+)?/?$ /index.php?go=showday_$1-$2-$3&amp;mode=$4&amp;page=$5 last;rewrite ^/user/([0-9]+)/?$ /view.php?go=user_$1 last;rewrite ^/tags/([^/]+)/?([0-9]+)?/?([0-9]+)?/?$ /tag.php?tag=$1&amp;mode=$2&amp;page=$3 last;rewrite ^/compnent/id/([0-9]+)/?$ /page.php?pageid=$1 last;rewrite ^/component/([^/]+)/?$ /page.php?pagealias=$1 last;rewrite ^/read\.php/([0-9]+)/([0-9]+)\.htm$ http://$host/post/$1/ permanent;rewrite ^/post/([0-9]+)\_([0-9]+)\.htm$ http://$host/post/$1/$2/ permanent;rewrite ^/post/([0-9]+)\_([0-9]+)\_([0-9])\.htm$ http://$host/post/$1/$2/$3/ permanent;rewrite ^/index\_([0-9]+)\_([0-9]+)\.htm$ http://$host/page/$1/$2/ permanent;rewrite ^/star\_([0-9]+)\_([0-9]+)\.htm$ http://$host/starred/$1/$2/ permanent;rewrite ^/category\_([0-9]+)\.htm$ http://$host/category/$1/ permanent;rewrite ^/category\_([0-9]+)\_([0-9]+)\.htm$ http://$host/category/$1/$2/$3/ permanent;rewrite ^archive\_([0-9]+)\_([0-9]+)\.htm$ http://$host/archiver/$1/$2/ permanent;rewrite ^/archive\_([0-9]+)\_([0-9]+)\_([0-9]+)\_([0-9]+)\.htm$ http://$host/archiver/$1/$2/$3/$4/ permanent;rewrite ^/showday\_([0-9]+)\_([0-9]+)\_([0-9]+)\.htm$ http://$host/date/$1/$2/$3/ permanent;rewrite ^/showday\_([0-9]+)\_([0-9]+)\_([0-9]+)\_([0-9]+)\_([0-9])\.htm http://$host/date/$1/$2/$3/$4/$5 permanent;&#125;rewrite ^/([a-zA-Z0-9_-]+)/?([0-9]+)?/?$ /read.php?biogalias=$1&amp;page=$2&amp;part=$3 last; 根据 referer 信息防盗链 123456location ~* \.(gif|jpg|jpeg|png|swf|flv)$ &#123; valid_referers none blocked www.youdomain.com *.youdomain.com; if ($invalid_referer) &#123; rewrite ^/(.*) http://www.yourdomain.com/blocked.html; &#125;&#125; Nginx 与 Apache 的 Rewrite 规则 Apache: 1RewriteRule ^/(mianshi|xianjing)/$ /z1/index.php?name=$1 [L] Apache 的 RewriteRule 指令换成 Nginx 的 rewrite 指令，Apache 的 [L] 标记换成 Nginx 的 last 标记，中间的内容不变。 Nginx 与 apache 的各种区别 nginx 模块 要编写一个 Nginx 模块，你要熟悉 Nginx 的配置文件。Nginx 配置文件主要分成 4 部分：main（全局配置）、server（虚拟主机配置）、upstream（主要为反向代理、负载均衡相关配置）和 location（目录匹配配置), 每部分包含若干个指令。main 部分的指令将影响其他所有部分; server 部分的指令主要用于指定虚拟主机域名、IP 端口; upstream 的指令用于设置反向代理及后端服务器的负载均衡; location 部分用于匹配网页位置（例如，根目录 “/“、”/images”, 等等）。location 部分会继承 server 部分的指令，而 server 会继承 main 部分的指令: upstream 既不会继承指令也不会影响其他 部分。它有自己的特殊指令，不需要在其他地方应用。 Nginx 的模块不能够像 Apache 那样动态添加，所有的模块要预先编译进 Nginx 二进制可执行文件中。 Nginx 模块的三种角色 Handlers（处理模块） 用于处理 HTTP 请求并输出内容 Filters（过滤模块） 用于过滤 Handler 输出的内容 Load-balancers （负载均衡模块）当有多于一台的后端服务器供选择时，选择一台后端服务器并将 HTTP 请求转发到该服务器。 Nginx 模块的处理流程 客户端改善 HTTP 请求到 Nginx 服务器 -&gt;Nginx 基于配置文件中的位置选择一个合适的处理模块 -&gt; 负载均衡模块选择一台后端服务器（反向代理情况下）-&gt; 处理模块进行处理并把输出缓冲放到第一个过滤模块上 -&gt; 第一个过滤模块处理后输出 给第二个过滤模块 -&gt; 第 n 个过滤模块 -&gt; 最后把处理结果发送给客户端 。 实战参考：实战nginx笔记 - 简书https://www.jianshu.com/p/dff2c0497840nginx - 标签 - 黄棣-dee - 博客园http://www.cnblogs.com/dee0912/tag/nginx/Nginx日常笔记 – 萌马笔记 – 因为记性差，所以记笔记http://git.malu.me/Nginx%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 面试 总结]]></title>
    <url>%2F2018%2F03%2F30%2F2018-03-30%2F</url>
    <content type="text"><![CDATA[Nginx的并发能力在同类型网页服务器中的表现，相对而言是比较好的，因此受到了很多企业的青睐，我国使用Nginx网站的知名用户包括腾讯、淘宝、百度、京东、新浪、网易等等。Nginx是网页服务器运维人员必备技能之一，下面为大家整理了一些比较常见的Nginx相关面试题，仅供参考： 1、请解释一下什么是Nginx?Nginx 是一个 web 服务器和反向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议。 2、请列举Nginx的一些特性。Nginx服务器的特性包括： 反向代理 / L7 负载均衡器 嵌入式 Perl 解释器 动态二进制升级 可用于重新编写 URL，具有非常好的 PCRE 支持 3、请列举Nginx和Apache 之间的不同点。 4、请解释Nginx如何处理HTTP请求。Nginx使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。 5、在Nginx中，如何使用未定义的服务器名称来阻止处理请求?只需将请求删除的服务器就可以定义为： 123456789Server &#123;listen 80;server_name “ “ ;return 444;&#125; 这里，服务器名被保留为一个空字符串，它将在没有 “主机” 头字段的情况下匹配请求，而一个特殊的Nginx的非标准代码444被返回，从而终止连接。 6、 使用 “反向代理服务器” 的优点是什么?反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。 7、请列举Nginx服务器的最佳用途。Nginx服务器的最佳用法是在网络上部署动态HTTP内容，使用SCGI、WSGI应用程序服务器、用于脚本的FastCGI处理程序。它还可以作为负载均衡器。 8、请解释Nginx服务器上的Master和Worker进程分别是什么?Master进程：读取及评估配置和维持 Worker进程：处理请求 9、请解释你如何通过不同于80 的端口开启 Nginx?为了通过一个不同的端口开启Nginx，你必须进入/etc/Nginx/sites-enabled/，如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放置在你想要的端口： 1Like server &#123; listen 81; &#125; 10、请解释是否有可能将Nginx的错误替换为502错误、503?502 = 错误网关 503 = 服务器超载 有可能，但是您可以确保fastcgi_intercept_errors被设置为ON，并使用错误页面指令。 123456Location / &#123;fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors on;error_page 502 =503/error_page.html;#…&#125; 11、在Nginx中，解释如何在URL中保留双斜线?要在URL中保留双斜线，就必须使用merge_slashes_off; 语法:merge_slashes [on/off] 默认值: merge_slashes on 环境: http，server 12、请解释ngx_http_upstream_module的作用是什么?ngx_http_upstream_module用于定义可通过fastcgi传递、proxy传递、uwsgi传递、memcached传递和 scgi 传递指令来引用的服务器组。 13、请解释什么是C10K问题?C10K问题是指无法同时处理大量客户端 (10,000) 的网络套接字。 14、请陈述stub_status和sub_filter指令的作用是什么?Stub_status指令：该指令用于了解Nginx当前状态的当前状态，如当前的活动连接，接受和处理当前读 / 写 / 等待连接的总数 Sub_filter指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据 15、解释Nginx是否支持将请求压缩到上游?您可以使用Nginx模块gunzip将请求压缩到上游。gunzip模块是一个过滤器，它可以对不支持 “gzip” 编码方法的客户机或服务器使用 “内容编码: gzip” 来解压缩响应。 16、解释如何在Nginx中获得当前的时间?要获得 Nginx 的当前时间，必须使用SSI模块、$date_gmt和$date_local的变量。 Proxy_set_header THE-TIME $date_gmt; 17、用Nginx服务器解释-s的目的是什么?用于运行Nginx -s参数的可执行文件。 18、解释如何在Nginx服务器上添加模块?在编译过程中，必须选择Nginx模块，因为Nginx不支持模块的运行时间选择。 什么是 Nginx？ Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器 Nginx 是一款轻量级的 Web 服务器 / 反向代理服务器及电子邮件（IMAP/POP3）代理服务器 目前使用的最多的 web 服务器或者代理服务器，像淘宝、新浪、网易、迅雷等都在使用为什么要用 Nginx？ 优点： 跨平台、配置简单 非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发 内存消耗小：开启 10 个 nginx 才占 150M 内存 成本低廉：开源 内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。 节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存 稳定性高：宕机的概率非常小 master/worker 结构：一个 master 进程，生成一个或者多个 worker 进程 接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力 一边接收 web 服务器的返回数据，一边发送给浏览器客户端 网络依赖性比较低，只要 ping 通就可以负载均衡 可以有多台 nginx 服务器 事件驱动：通信机制采用 epoll 模型为什么 Nginx 性能这么高？ 得益于它的事件处理机制： 异步非阻塞事件处理机制：运用了 epoll 模型，提供了一个队列，排队解决为什么不使用多线程？ 因为线程创建和上下文的切换非常消耗资源，线程占用内存大，上下文切换占用 cpu 也很高，采用 epoll 模型避免了这个缺点Nginx 是如何处理一个请求的呢？ 首先，nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面 先初始化好这个监控的 socket(创建 socket，设置 addrreuse 等选项，绑定到指定的 ip 地址端口，再 listen) 然后再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程) 出多个子进程出来 然后子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与 nginx 进行三次握手，与 nginx 建立好一个连接后 此时，某一个子进程会 accept 成功，得到这个建立好的连接的 socket，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体 接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了正向代理 一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器) 然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理 正向代理总结就一句话：代理端代理的是客户端反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求，发给内部网络上的服务器 并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器 反向代理总结就一句话：代理端代理的是服务端动态资源、静态资源分离 动态资源、静态资源分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后 我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路 动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离为什么要做动、静分离？ 在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js 等等文件） 这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗 当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决 动、静分离将网站静态资源（HTML，JavaScript，CSS，img 等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问 这里我们将静态资源放到 nginx 中，动态资源转发到 tomcat 服务器中负载均衡 负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中 负载均衡主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器大并发压力 首先列出一些面试题目包括 nginx 和 redis 的。 1.、nginx 框架是怎样的 2. nginx 负载均衡的算法怎么实现的，懵逼，说没看过 。 nginx 的 upstream 目前支持 4 种方式的分配1)、轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。2)、weight 指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。2)、ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。3)、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。4)、url_hash（第三方） nginx 内置策略包含加权轮询和 ip hash 加权轮询算法分为先深搜索和先广搜索，那么 nginx 采用的是先深搜索算法，即将首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器； 3. redis 主从是怎么选取的 4、redis 插槽的分配 5、redis 复制的过程 6、redis 主节点宕机了怎么办，还有没有同步的数据怎么办 ….. 反正一大堆 redis 的问题 7、重入锁是怎么计数的 8、如何解决惊群现象？ 惊群是多个子进程在同一时刻监听同一个端口引起的； Nginx 解决方法：同一个时刻只能有唯一一个 worker 子进程监听 web 端口，此时新连接事件只能唤醒唯一正在监听端口的 worker 子进程。 采用锁，互斥量实现！！ 一、Nginx 优秀模块 模块设计： 高度模块化设计，除了少量核心代码，其他一切接模块。官方 Nginx 共有五大类型模块：核心模块、配置模块、事件模块、HTTP 模块、mail 模块。 要注意的是：nginx 的模块是静态的，添加和删除模块都要对 nginx 进行重新编译，这一点与 Apache 的动态模块完全不同。 二、事件驱动框架： nginx 事件驱动框架（书本 p254）：所谓事件驱动架构，简单来说，就是由一些事件发生源来产生事件，由一个或多个事件收集器（epolld 等）来收集、分发事件，然后许多事件处理器会注册自己感兴趣的事件，同时会 “消费” 这些事件。nginx 不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。 传统 web 服务器（如 Apache）的，所谓事件局限在 TCP 连接建立、关闭上，其他读写都不在是事件驱动，这时会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu 等资源。并且把一个进程或线程作为事件消费者。 传统 web 服务器与 Nginx 间重要差别： 前者每个事件消费者独占一个进程资源，后者只是被事件分发者进程短期调用而已。 三、请求的多阶段异步处理请求的多阶段异步处理只能基于事件驱动框架实现，就是把一个请求的处理过程按照事件的触发方式分为多个阶段，每个阶段都可以有事件收集、分发器（epoll 等）来触发。比如一个 http 请求可以分为七个阶段 四、一个 master 进程（管理），多个 work（工作）进程。 master 对 work 进程采用信号进行控制 五、平台无关的代码实现： 在核心代码都使用了与操作系统无关的代码实现，在与操作系统相关的系统调用上则分别针对各个操作系统都有独立实现，这最终造就了 Nginx 的可移植性。 六、内存池的设计 为了减少避免出现内存碎片、减少向操作系统申请内存的次数、降低各个模块的开发复杂度，Nginx 采用了简单的内存池（统一申请，统一释放）。比如为每个 http 请求分配一个内存池，请求结束时销毁整个内存池。 1、什么是 Nginx？ Nginx 是一个高性能的 HTTP 和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡。 多进程异步非阻塞事件处理机制：运用了 epoll 模型 2、为什么要用 Nginx？ 优点： 跨平台、配置简单 非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发 内存消耗小：开启 10 个 nginx 才占 150M 内存，Nginx 采取了分阶段资源分配技术 nginx 处理静态文件好, 耗费内存少 内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。 节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存 稳定性高：宕机的概率非常小 master/worker 结构：一个 master 进程，生成一个或者多个 worker 进程 接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力 一边接收 web 服务器的返回数据，一边发送给浏览器客户端 网络依赖性比较低，只要 ping 通就可以负载均衡 可以有多台 nginx 服务器 事件驱动：通信机制采用 epoll 模型 3、为什么 Nginx 性能这么高？ 得益于它的事件处理机制： 异步非阻塞事件处理机制：运用了 epoll 模型，提供了一个队列，排队解决 4、为什么不使用多线程？ Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。 Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。 5、Nginx 是如何处理一个请求的呢？ 首先，nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面 先初始化好这个监控的 socket，再进行 listen 然后再 fork 出多个子进程出来, 子进程会竞争 accept 新的连接。 此时，客户端就可以向 nginx 发起连接了。当客户端与 nginx 进行三次握手，与 nginx 建立好一个连接后 此时，某一个子进程会 accept 成功，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体 接着，根据事件调用相应的事件处理模块，如 http 模块与客户端进行数据的交换。 最后，nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了 6、正向代理 一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理 正向代理总结就一句话：代理端代理的是客户端 7、反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求，发给内部网络上的服务器 并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器 反向代理总结就一句话：代理端代理的是服务端 8、动态资源、静态资源分离 动态资源、静态资源分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路 动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离 9、为什么要做动、静分离？ 在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js 等等文件） 这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗 当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决 动、静分离将网站静态资源（HTML，JavaScript，CSS，img 等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问 这里我们将静态资源放到 nginx 中，动态资源转发到 tomcat 服务器中 10、负载均衡 负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中 负载均衡主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器大并发压力 参考：Nginx面试中最常见的18道题https://segmentfault.com/a/1190000010677483Nginx常见面试题 - Gibbons的个人空间https://my.oschina.net/gibbons/blog/900493nginx面试要点–持续更新中 - CSDN博客https://blog.csdn.net/watson2016/article/details/77938678]]></content>
      <tags>
        <tag>面试</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx理论]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-3%2F</url>
    <content type="text"><![CDATA[1 反向代理1.1 概念反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 举个例子，比如我想访问 http://www.test.com/readme，但www.test.com上并不存在 readme 页面，于是他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。这里所提到的 www.test.com 这个域名对应的服务器就设置了反向代理功能。 结论就是，反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间 (name-space) 中的内容发送普通请求，接着反向代理服务器将判断向何处 (原始服务器) 转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 正向代理，既然有反向代理，就肯定有正向代理。什么叫正向代理呢？ 正向代理（Forward Proxy）通常都被简称为代理，就是在用户无法正常访问外部资源，比方说受到 GFW 的影响无法访问 twitter 的时候，我们可以通过代理的方式，让用户绕过防火墙，从而连接到目标网络或者服务。 正向代理的工作原理就像一个跳板，比如：我访问不了 google.com，但是我能访问一个代理服务器 A，A 能访问 google.com，于是我先连上代理服务器 A，告诉他我需要 google.com 的内容，A 就去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。 结论就是，正向代理是一个位于客户端和原始服务器 (origin server) 之间的服务器。为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 反向代理 VS 正向代理： 1.2 工作流程 用户通过域名发出访问 Web 服务器的请求，该域名被 DNS 服务器解析为反向代理服务器的 IP 地址； 反向代理服务器接受用户的请求； 反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户； 如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中。 1.3 优点 保护了真实的 web 服务器，保证了 web 服务器的资源安全 通常的代理服务器，只用于代理内部网络对 Internet 外部网络的连接请求，客户机必须指定代理服务器，并将本来要直接发送到 Web 服务器上的 http 请求发送到代理服务器中。不支持外部网络对内部网络的连接请求，因为内部网络对外部网络是不可见的。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个 Web 服务器，外部网络就可以简单把它当作一个标准的 Web 服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者 CGI 程序，都保存在内部的 Web 服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了 Web 服务器的安全性。 节约了有限的 IP 地址资源 企业内所有的网站共享一个在 internet 中注册的 IP 地址，这些服务器分配私有地址，采用虚拟主机的方式对外提供服务。 减少 WEB 服务器压力，提高响应速度 反向代理就是通常所说的 web 服务器加速，它是一种通过在繁忙的 web 服务器和外部网络之间增加一个高速的 web 缓冲服务器来降低实际的 web 服务器的负载的一种技术。反向代理是针对 web 服务器提高加速功能，作为代理缓存，它并不是针对浏览器用户，而针对一台或多台特定的 web 服务器，它可以代理外部网络对内部网络的访问请求。 反向代理服务器会强制将外部网络对要代理的服务器的访问经过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存到本地，以便日后再收到同样的信息请求时，它会把本地缓存里的内容直接发给用户，以减少后端 web 服务器的压力，提高响应速度。因此 Nginx 还具有缓存功能。 其他优点 （1）请求的统一控制，包括设置权限、过滤规则等； （2）区分动态和静态可缓存内容； （3）实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问； （4）解决 Ajax 跨域问题； （5）作为真实服务器的缓冲，解决瞬间负载量大的问题； 2 Nginx 模块Nginx 有五大优点：模块化、事件驱动、异步、非阻塞、多进程单线程。由内核和模块组成的，其中内核完成的工作比较简单，仅仅通过查找配置文件将客户端请求映射到一个 location block，然后又将这个 location block 中所配置的每个指令将会启动不同的模块去完成相应的工作。 2.1 模块划分Nginx 的模块从结构上分为核心模块、基础模块和第三方模块： 核心模块：HTTP 模块、EVENT 模块和 MAIL 模块 基础模块：HTTP Access 模块、HTTP FastCGI 模块、HTTP Proxy 模块和 HTTP Rewrite 模块， 第三方模块：HTTP Upstream Request Hash 模块、Notice 模块和 HTTP Access Key 模块。 Nginx 的模块从功能上分为如下四类： Core(核心模块)：构建 nginx 基础服务、管理其他模块。 Handlers（处理器模块）：此类模块直接处理请求，并进行输出内容和修改 headers 信息等操作。 Filters （过滤器模块）：此类模块主要对其他处理器模块输出的内容进行修改操作，最后由 Nginx 输出。 Proxies （代理类模块）：此类模块是 Nginx 的 HTTP Upstream 之类的模块，这些模块主要与后端一些服务比如 FastCGI 等进行交互，实现服务代理和负载均衡等功能。 Nginx 的核心模块主要负责建立 nginx 服务模型、管理网络层和应用层协议、以及启动针对特定应用的一系列候选模块。其他模块负责分配给 web 服务器的实际工作： (1) 当 Nginx 发送文件或者转发请求到其他服务器，由 Handlers(处理模块) 或 Proxies（代理类模块）提供服务； (2) 当需要 Nginx 把输出压缩或者在服务端加一些东西，由 Filters(过滤模块) 提供服务。 2.2 模块处理 当服务器启动，每个handlers(处理模块)都有机会映射到配置文件中定义的特定位置（location）；如果有多个 handlers(处理模块) 映射到特定位置时，只有一个会 “赢”（说明配置文件有冲突项，应该避免发生）。 处理模块以三种形式返回： OK ERROR 或者放弃处理这个请求而让默认处理模块来处理（主要是用来处理一些静态文件，事实上如果是位置正确而真实的静态文件，默认的处理模块会抢先处理）。 如果handlers(处理模块)把请求反向代理到后端的服务器，就变成另外一类的模块：load-balancers（负载均衡模块）。负载均衡模块的配置中有一组后端服务器，当一个 HTTP 请求过来时，它决定哪台服务器应当获得这个请求。 Nginx 的负载均衡模块采用两种方法： 轮转法，它处理请求就像纸牌游戏一样从头到尾分发； IP 哈希法，在众多请求的情况下，它确保来自同一个 IP 的请求会分发到相同的后端服务器。 如果handlers(处理模块)没有产生错误，filters（过滤模块）将被调用。多个 filters（过滤模块）能映射到每个位置，所以（比如）每个请求都可以被压缩成块。它们的执行顺序在编译时决定。 filters（过滤模块）是经典的“接力链表（CHAIN OF RESPONSIBILITY）”模型：一个 filters（过滤模块）被调用，完成其工作，然后调用下一个 filters（过滤模块），直到最后一个 filters（过滤模块）。 过滤模块链的特别之处在于： 每个 filters（过滤模块）不会等上一个 filters（过滤模块）全部完成； 它能把前一个过滤模块的输出作为其处理内容；有点像 Unix 中的流水线； 过滤模块能以buffer（缓冲区）为单位进行操作，这些buffer一般都是一页（4K）大小，当然你也可以在nginx.conf文件中进行配置。这意味着，比如，模块可以压缩来自后端服务器的响应，然后像流一样的到达客户端，直到整个响应发送完成。 总之，过滤模块链以流水线的方式高效率地向客户端发送响应信息。 所以总结下上面的内容，一个典型的 HTTP 处理周期是这样的： 客户端发送 HTTP 请求 –&gt; Nginx 基于配置文件中的位置选择一个合适的处理模块 -&gt; (如果有) 负载均衡模块选择一台后端服务器 –&gt; 处理模块进行处理并把输出缓冲放到第一个过滤模块上 –&gt; 第一个过滤模块处理后输出给第二个过滤模块 –&gt; 然后第二个过滤模块又到第三个 –&gt; 依此类推 –&gt; 最后把响应发给客户端。 下图展示了 Nginx 模块处理流程： Nginx 本身做的工作实际很少，当它接到一个 HTTP 请求时，它仅仅是通过查找配置文件将此次请求映射到一个 location block，而此 location 中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做 Nginx 真正的劳动工作者。通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。 3 Nginx 请求处理Nginx 在启动时会以 daemon 形式在后台运行，采用多进程 + 异步非阻塞 IO 事件模型来处理各种连接请求。多进程模型包括一个 master 进程，多个 worker 进程，一般 worker 进程个数是根据服务器 CPU 核数来决定的。master 进程负责管理 Nginx 本身和其他 worker 进程。如下图： 从上图中可以很明显地看到，4 个 worker 进程的父进程都是 master 进程，表明 worker 进程都是从父进程 fork 出来的，并且父进程的 ppid 为 1，表示其为 daemon 进程。 需要说明的是，在 nginx 多进程中，每个 worker 都是平等的，因此每个进程处理外部请求的机会权重都是一致的。 Master 进程的作用是？ 读取并验证配置文件 nginx.conf；管理 worker 进程； Worker 进程的作用是？ 每一个 Worker 进程都维护一个线程（避免线程切换），处理连接和请求；注意 Worker 进程的个数由配置文件决定，一般和 CPU 个数相关（有利于进程切换），配置几个就有几个 Worker 进程。 Nginx 如何做到热部署？ 所谓热部署，就是配置文件 nginx.conf 修改后，不需要 stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载 / nginx -t 检查配置 / nginx -s stop） 通过上文我们已经知道 worker 进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象： 方案一： 修改配置文件 nginx.conf 后，主进程 master 负责推送给 woker 进程更新配置信息，woker 进程收到信息后，更新进程内部的线程信息。 方案二： 修改配置文件 nginx.conf 后，重新生成新的 worker 进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的 worker 进程，至于老的 worker 进程，等把那些以前的请求处理完毕后，kill 掉即可。 Nginx 采用的就是方案二来达到热部署的！ Nginx 如何做到高并发下的高效处理？ 上文已经提及 Nginx 的 worker 进程个数与 CPU 绑定、worker 进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。 作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步 / 同步、阻塞 / 非阻塞… 要同时处理那么多的请求，要知道，有的请求需要发生 IO，可能需要很长时间，如果等着它，就会拖慢 worker 的处理速度。 Nginx 采用了 Linux 的 epoll 模型，epoll 模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果 OK，那么放入 epoll 队列中，这个过程是异步的。worker 只需要从 epoll 队列循环处理即可。 Nginx 挂了怎么办？ Nginx 既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。 答案是：Keepalived+Nginx 实现高可用。 Keepalived 是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和 Nginx 配合来实现 Web 服务的高可用。（其实，Keepalived 不仅仅可以和 Nginx 配合，还可以和很多其他服务配合） Keepalived+Nginx 实现高可用的思路： 第一：请求不要直接打到 Nginx 上，应该先通过 Keepalived（这就是所谓虚拟 IP，VIP） 第二：Keepalived 应该能监控 Nginx 的生命状态（提供一个用户自定义的脚本，定期检查 Nginx 进程状态，进行权重变化,，从而实现 Nginx 故障切换） Nginx 架构及工作流程图： Nginx 真正处理请求业务的是 Worker 之下的线程。_worker进程中有一个ngx_worker_process_cycle()函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理_，直到整个 Nginx 服务被停止。 worker 进程中，ngx_worker_process_cycle() 函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下： 操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。 接收和处理这些事件，如是接收到数据，则产生更高层的 request 对象。 处理 request 的 header 和 body。 产生响应，并发送回客户端。 完成 request 的处理。 重新初始化定时器及其他事件。 3.1 多进程处理模型下面来介绍一个请求进来，多进程模型的处理方式： 首先，master 进程一开始就会根据我们的配置，来建立需要listen的网络socket fd，然后 fork 出多个 worker 进程。 其次，根据进程的特性，新建立的 worker 进程，也会和 master 进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。 然后，这个时候有多个 worker 进程都在监听同样设置的 socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的“惊群现象”。为了保证只会有一个进程成功注册到 listenfd 的读事件，_nginx中实现了一个“accept_mutex”类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件_。其他进程全部 accept 失败。 最后，监听成功的 worker 进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个 request 请求，只需要 worker 进程就可以完成。 进程模型的处理方式带来的一些好处就是：进程之间是独立的，也就是一个 worker 进程出现异常退出，其他 worker 进程是不会受到影响的；此外，独立进程也会避免一些不需要的锁操作，这样会提高处理效率，并且开发调试也更容易。 如前文所述，多进程模型+异步非阻塞模型才是胜出的方案。单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题；并且还因此避免的多线程的上下文切换导致的性能损失。 worker 进程会竞争监听客户端的连接请求：这种方式可能会带来一个问题，就是可能所有的请求都被一个worker进程给竞争获取了，导致其他进程都比较空闲，而某一个进程会处于忙碌的状态，这种状态可能还会导致无法及时响应连接而丢弃discard掉本有能力处理的请求。这种不公平的现象，是需要避免的，尤其是在高可靠 web 服务器环境下。 针对这种现象，Nginx 采用了一个是否打开 accept_mutex 选项的值，_ngx_accept_disabled标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件_。 ngx_accept_disabled 值：nginx 单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个 ngx_accept_disabled。 当 ngx_accept_disabled 大于 0 时，不会去尝试获取 accept_mutex 锁，并且将 ngx_accept_disabled 减 1，于是，每次执行到此处时，都会去减 1，直到小于 0。不去获取 accept_mutex 锁，就是等于让出获取连接的机会，很显然可以看出，_当空闲连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大_。不去 accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx 就控制了多进程间连接的平衡了。 3.2 一个简单的 HTTP 请求从 Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段： 初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。 处理请求头。 处理请求体。 如果有的话，调用与此请求（URL 或者 Location）关联的 handler。 依次调用各 phase handler 进行处理。 在建立连接过程中，_对于nginx监听到的每个客户端连接，都会将它的读事件的handler设置为ngx_http_init_request函数，这个函数就是请求处理的入口_。在处理请求时，主要就是要解析 http 请求，比如：uri，请求行等，然后再根据请求生成响应。下面看一下 nginx 处理的具体过程： 在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。所以 phase handlers 也就好理解了，就是包含若干个处理阶段的一些 handler。 在每一个阶段，包含有若干个 handler，再处理到某个阶段的时候，依次调用该阶段的 handler 对 HTTP Request 进行处理。 通常情况下，一个 phase handler 对这个 request 进行处理，并产生一些输出。通常 phase handler 是与定义在配置文件中的某个 location 相关联的。 一个 phase handler 通常执行以下几项任务： 获取 location 配置。 产生适当的响应。 发送 response header。 发送 response body。 当 Nginx 读取到一个 HTTP Request 的 header 的时候，Nginx 首先查找与这个请求关联的虚拟主机的配置。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase handlers）： NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段 NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段 NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段 NGX_HTTP_REWRITE_PHASE: Location 请求地址重写阶段 NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段 NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段 NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段 NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段 NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段 NGX_HTTP_CONTENT_PHASE: 内容产生阶段 NGX_HTTP_LOG_PHASE: 日志模块处理阶段 在内容产生阶段，为了给一个 request 产生正确的响应，Nginx 必须把这个 request 交给一个合适的 content handler 去处理。如果这个 request 对应的 location 在配置文件中被明确指定了一个 content handler，那么 Nginx 就可以通过对 location 的匹配，直接找到这个对应的 handler，并把这个 request 交给这个 content handler 去处理。这样的配置指令包括像，perl，flv，proxy_pass，mp4 等。 如果一个 request 对应的 location 并没有直接有配置的 content handler，那么 Nginx 依次尝试： 如果一个 location 里面有配置 random_index on，那么随机选择一个文件，发送给客户端。 如果一个 location 里面有配置 index 指令，那么发送 index 指令指明的文件，给客户端。 如果一个 location 里面有配置 autoindex on，那么就发送请求地址对应的服务端路径下的文件列表给客户端。 如果这个 request 对应的 location 上有设置 gzip_static on，那么就查找是否有对应的. gz 文件存在，有的话，就发送这个给客户端（客户端支持 gzip 的情况下）。 请求的 URI 如果对应一个静态文件，static module 就发送静态文件的内容到客户端。 内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理。filter 模块也是与 location 相关的。所有的 filter 模块都被组织成一条链。输出会依次穿越所有的 filter，直到有一个 filter 模块的返回值表明已经处理完成。 这里列举几个常见的 filter 模块，例如： server-side includes。 XSLT filtering。 图像缩放之类的。 gzip 压缩。 在所有的 filter 中，有几个 filter 模块需要关注一下。按照调用的顺序依次说明如下： copy: 将一些需要复制的 buf(文件或者内存) 重新复制一份然后交给剩余的 body filter 处理。 postpone: 这个 filter 是负责 subrequest 的，也就是子请求的。 write: 写输出到客户端，实际上是写到连接对应的 socket 上。 3.3 请求完整处理过程根据以上请求步骤所述，请求完整的处理过程如下图所示： 3.4 keepalive 长连接当然，在 nginx 中，对于 http1.0 与 http1.1 也是支持长连接的。 什么是长连接呢？我们知道，http 请求是基于 TCP 协议之上的，那么，当客户端在发起请求前，需要先与服务端建立 TCP 连接，而每一次的 TCP 连接是需要三次握手来确定的，如果客户端与服务端之间网络差一点，这三次交互消费的时间会比较多，而且三次交互也会带来网络流量。当然，当连接断开后，也会有四次的交互，当然对用户体验来说就不重要了。而 http 请求是请求应答式的，如果我们能知道每个请求头与响应体的长度，那么我们是可以在一个连接上面执行多个请求的，这就是所谓的长连接，但前提条件是我们先得确定请求头与响应体的长度。 对于请求来说，如果当前请求需要有 body，如 POST 请求，那么 nginx 就需要客户端在请求头中指定 content-length 来表明 body 的大小，否则返回 400 错误。也就是说，请求体的长度是确定的，那么响应体的长度呢？先来看看 http 协议中关于响应 body 长度的确定： 对于 http1.0 协议来说，如果响应头中有 content-length 头，则以 content-length 的长度就可以知道 body 的长度了，客户端在接收 body 时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有 content-length 头，则客户端会一直接收数据，直到服务端主动断开连接，才表示 body 接收完了。 而对于 http1.1 协议来说，如果响应头中的 Transfer-encoding 为 chunked 传输，则表示 body 是流式输出，body 会被分成多个块，每块的开始会标识出当前块的长度，此时，body 不需要通过长度来指定。如果是非 chunked 传输，而且有 content-length，则按照 content-length 来接收数据。否则，如果是非 chunked，并且没有 content-length，则客户端接收数据，直到服务端主动断开连接。 从上面，我们可以看到，除了 http1.0 不带 content-length 以及 http1.1 非 chunked 不带 content-length 外，body 的长度是可知的。此时，当服务端在输出完 body 之后，会可以考虑使用长连接。能否使用长连接，也是有条件限制的。如果客户端的请求头中的 connection 为 close，则表示客户端需要关掉长连接，如果为 keep-alive，则客户端需要打开长连接，如果客户端的请求中没有 connection 这个头，那么根据协议，如果是 http1.0，则默认为 close，如果是 http1.1，则默认为 keep-alive。如果结果为 keepalive，那么，nginx 在输出完响应体后，会设置当前连接的 keepalive 属性，然后等待客户端下一次请求。 当然，nginx 不可能一直等待下去，如果客户端一直不发数据过来，岂不是一直占用这个连接？所以当 nginx 设置了 keepalive 等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项 keepalive_timeout 来配置的，如果配置为 0，则表示关掉 keepalive，此时，http 版本无论是 1.1 还是 1.0，客户端的 connection 不管是 close 还是 keepalive，都会强制为 close。 如果服务端最后的决定是 keepalive 打开，那么在响应的 http 头里面，也会包含有 connection 头域，其值是”Keep-Alive”，否则就是”Close”。如果 connection 值为 close，那么在 nginx 响应完数据后，会主动关掉连接。所以，对于请求量比较大的 nginx 来说，关掉 keepalive 最后会产生比较多的 time-wait 状态的 socket。一般来说，当客户端的一次访问，需要多次访问同一个 server 时，打开 keepalive 的优势非常大，比如图片服务器，通常一个网页会包含很多个图片。打开 keepalive 也会大量减少 time-wait 的数量。 参考 WEB 请求处理二：Nginx 请求反向代理 Nginx 开发从入门到精通 深入浅出 Nginx 原理参考：理解Nginx工作原理 - 简书https://www.jianshu.com/p/6215e5d24553Nginx工作原理和优化、漏洞。 - CSDN博客https://blog.csdn.net/hguisu/article/details/8930668]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-2%2F</url>
    <content type="text"><![CDATA[使用 ^\#\#\#(注意正则表达式结尾是一个空格)正则表达式进行替换查找博客中的三级标题，]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP面试总结]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-1%2F</url>
    <content type="text"><![CDATA[下面是我整理下来的 JSP 知识点: 图上的知识点都可以在我其他的文章内找到相应内容。 JSP 常见面试题jsp 静态包含和动态包含的区别 jsp 静态包含和动态包含的区别 在讲解 request 对象的时候，我们曾经使用过 request.getRequestDispatcher(String url).include(request,response) 来对页头和页尾面进行包含 inclue 指令也是做这样的事情，我们来试验一下吧！ 这是页头 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是页头 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 这是页尾 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页尾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;我是页尾&lt;/body&gt;&lt;/html&gt; 在 1.jsp 中把页头和页尾包含进来 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;包含页头和页尾进来&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%@include file=&quot;head.jsp&quot; %&gt;&lt;%@include file=&quot;foot.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 访问 1.jsp include 指令是静态包含。静态包含的意思就是：把文件的代码内容都包含进来，再编译！，看一下 jsp 的源代码就知道了！ 上面已经提及到了，include 指令是静态包含，include 行为是动态包含。其实 include 行为就是封装了 request.getRequestDispatcher(String url).include(request,response) include 行为语法是这个样子的 12&lt;jsp:include page=&quot;&quot;/&gt; 我们先来使用一下把，在 1.jsp 页面中也将页头和页尾包含进来。 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;包含页头和页尾进来&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:include page=&quot;head.jsp&quot;/&gt; &lt;jsp:include page=&quot;foot.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 访问 1.jsp 页面看一下效果： 使用 jsp 行为来包含文件，jsp 源文件是这样子的： jsp 行为包含文件就是先编译被包含的页面，再将页面的结果写入到包含的页面中（1.jsp) 当然了，现在有静态包含和动态包含，使用哪一个更好呢？答案是：动态包含。 动态包含可以向被包含的页面传递参数（用处不大），并且是分别处理包含页面的（将被包含页面编译后得出的结果再写进包含页面）【如果有相同名称的参数，使用静态包含就会报错！】！ 模拟一下场景吧，现在我的头页面有个名为 s 的字符串变量 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% String s = &quot;zhongfucheng&quot;; %&gt; 我是页头呀 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 我的页尾也有个名为 s 的字符串变量 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页尾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% String s = &quot;zhongfucheng&quot;;%&gt;我是页尾呀&lt;/body&gt;&lt;/html&gt; 现在我使用静态包含看看会发生什么，出现异常了。 出现异常的原因很简单，就是同一个文件中有两个相同的变量 s 使用动态包含就可以避免这种情况 总结 &lt;%@include file=&quot;xxx.jsp&quot;%&gt;为 jsp 中的编译指令，其文件的包含是发生在 jsp 向 servlet 转换的时期，而&lt;jsp:include page=&quot;xxx.jsp&quot;&gt;是 jsp 中的动作指令，其文件的包含是发生在编译时期，也就是将 java 文件编译为 class 文件的时期 使用静态包含只会产生一个 class 文件，而使用动态包含会产生多个 class 文件 使用静态包含，包含页面和被包含页面的 request 对象为同一对象，因为静态包含只是将被包含的页面的内容复制到包含的页面中去；而动态包含包含页面和被包含页面不是同一个页面，被包含的页面的 request 对象可以取到的参数范围要相对大些，不仅可以取到传递到包含页面的参数，同样也能取得在包含页面向下传递的参数 jsp 有哪些内置对象? 作用分别是什么? jsp 有哪些内置对象? 作用分别是什么? 九个内置对象： pageContext page config request response session application exception out 其中，request、response、session、application、config 这五个对象和 Servlet 的 API 是一样的。这 5 个对象我就不解释了。 在 JSP 中，尤其重要的是 pageContext 对象。 pageContext 是内置对象中最重要的一个对象，它代表着 JSP 页面编译后的内容（也就是 JSP 页面的运行环境）！ pageContext 对象 既然它代表了 JSP 页面编译后的内容，理所当然的：它封装了对其他 8 大内置对象的引用！，也就是说，通过 pageContext 可以获取到其他的 8 个内置对象！ 123456789101112131415161718192021222324&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;获取八大内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(pageContext.getSession()); System.out.println(pageContext.getRequest()); System.out.println(pageContext.getResponse()); System.out.println(pageContext.getException()); System.out.println(pageContext.getPage()); System.out.println(pageContext.getServletConfig()); System.out.println(pageContext.getServletContext()); System.out.println(pageContext.getOut());%&gt;&lt;/body&gt;&lt;/html&gt; 看下效果： pageContext 作为域对象 类似于 request，session，ServletContext 作为域对象而言都有以下三个方法： setAttribute(String name,Objcet o) getAttribute(String name) removeAttribute(String name) 当然了，pageContext 也不例外，pageContext 也有这三个方法！ pageContext 本质上代表的是当前 JSP 页面编译后的内容，作为域对象而言，它就代表着当前 JSP 页面（也就是 page）！也就是说：pageContext 域对象只在 page 范围内有效，超出了 page 范围就无效了！ 首先来看看在 page 范围内能不能使用 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用page域对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;zhongfucheng&quot;);%&gt;&lt;% String value = (String) pageContext.getAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 我们现在来试验一下是不是超出了 page 范围就无效了！ 在 2.jsp 中 request 域对象设置属性 123456789101112131415161718&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request域对象设置属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //这是request域对象保存的内容 request.setAttribute(&quot;name&quot;,&quot;zhongfucheng&quot;);%&gt;&lt;%--跳转到1.jsp中--%&gt;&lt;jsp:forward page=&quot;1.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 企图在 1.jsp 中 pageContext 取出 request 存进去的属性 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在page域对象获取属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //企图获取request域对象存进的属性 String value = (String) pageContext.getAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： pageContext 本质上代表着编译后 JSP 的内容，pageContext 还可以封装了访问其他域的方法！ 上面的 pageContext 默认是 page 范围的，但 pageContext 对象重载了 set、get、removeAttribute 这三个方法 getAttribute(String name,int scope) setAttribute(String name,Object value,int scope) removeAttribute(String name,int scope) 多了一个设置域范围的一个参数，如果不指定默认就是 page。当然了，pageContext 把 request、session、application、page 这几个域对象封装着了静态变量供我们使用。 PageContext.APPLICATION_SCOPE PageContext.SESSION_SCOPE PageContext.REQUEST_SCOPE PageContext.PAGE_SCOPE 刚才我们没有使用重载方法的时候，使用 pageContext 是无法获取到 request 域对象设置的属性的。现在我们使用重载后的方法看一下能不能获取得到！ 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在page域对象获取request域对象的属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //使用重载的方法获取request域对象的属性 String value = (String) pageContext.getAttribute(&quot;name&quot;,pageContext.REQUEST_SCOPE); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果： pageContexst 还有这么一个方法： findAttribute(String name) 该方法会查找各个域的属性，从小到大开始寻找！也就是 page—&gt;request-&gt;session-&gt;application。 我们用此方法看能不能查找出 request 域对象的属性吧！ 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用findAttribute&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //使用findAttribute查找2.jsp中request域对象的属性 String value = (String) pageContext.findAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： out 对象： out 对象用于向浏览器输出数据，与之对应的是 Servlet 的 PrintWriter 对象。然而这个 out 对象的类型并不是 PrintWriter，是 JspWriter 我们可以简单理解为：JspWriter 就是带缓存的 PrintWrieter。 out 对象的原理如下： 只有向 out 对象中写入了内容，且满足如下任何一个条件时，out 对象才去调用 ServletResponse.getWriter 方法，并通过该方法返回的 PrintWriter 对象将 out 对象的缓冲区中的内容真正写入到 Servlet 引擎提供的缓冲区中： 设置 page 指令的 buffer 属性关闭了 out 对象的缓存功能 out 对象的缓冲区已满 整个 JSP 页面结束 一般我们在 JSP 页面输出都是用表达式（&lt;%=%&gt;)，所以 out 对象用得并不是很多！ page 对象 内置对象 page 是 HttpJasPage 对象，其实 page 对象代表的就是当前 JSP 页面，是当前 JSP 编译后的 Servlet 类的对象。也就是说：page 对象相当于普通 java 类的 this exception 对象 内置对象 exception 是 java.lang.Exception 类的对象，exception 封装了 JSP 页面抛出的异常信息。exception 经常被用来处理错误页面 前面我们已经讲过了怎么设置错误页面了，下面我们就来简单使用一下 exception 对象吧 1.jsp 页面 1234&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; errorPage=&quot;error.jsp&quot; %&gt;&lt;%--模拟空指针异常的错误--%&gt;&lt;% String sss = null; sss.length();%&gt; error.jsp 页面 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isErrorPage=&quot;true&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% out.println(&quot;程序抛出了异常：&quot; + exception);%&gt;&lt;/body&gt;&lt;/html&gt; 效果： 总结 request 用户端请求，此请求会包含来自 GET/POST 请求的参数 response 网页传回用户端的回应 pageContext 网页的属性是在这里管理，代表的编译后 JSP 内容 session 与请求有关的会话期 application servlet 正在执行的内容 out 用来传送回应的输出 config servlet 的构架部件 page JSP 网页本身 exception 针对错误网页，未捕捉的例外 jsp 和 servlet 的区别、共同点、各自应用的范围？ jsp 和 servlet 的区别、共同点、各自应用的范围？ JSP 是 Servlet 技术的扩展，本质上就是 Servlet 的简易方式。JSP 编译后是 “类 servlet”。 Servlet 和 JSP 最主要的不同点在于：Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为. jsp 的文件。 JSP 侧重于视图，Servlet 主要用于控制逻辑。 属性作用域范围 属性作用域范围 page【只在一个页面中保存属性，跳转页面无效】 requet【只在一次请求中保存属性，服务器跳转有效，浏览器跳转无效】 session【在一个会话范围中保存属性，无论何种跳转均有效，关闭浏览器后无效】 application【在整个服务器中保存，所有用户都可以使用】 应用场景： request：如果客户向服务器发请求，产生的数据，用户看完就没用了，像这样的数据就存在 request 域, 像新闻数据，属于用户看完就没用的 session：如果客户向服务器发请求，产生的数据，用户用完了等一会儿还有用，像这样的数据就存在 session 域中，像购物数据，用户需要看到自己购物信息，并且等一会儿，还要用这个购物数据结帐 servletContext：如果客户向服务器发请求，产生的数据，用户用完了，还要给其它用户用，像这样的数据就存在 servletContext 域中，像聊天数据 写出 5 种 JSTL 常用标签 写出 5 种 JSTL 常用标签 12&lt;c:if&gt;，&lt;c:item&gt;，&lt;c:foreach&gt;，&lt;c:out&gt;，&lt;c:set&gt; 写一个自定义标签要继承什么类 写一个自定义标签要继承什么类 我们可以有两种方式来实现自定义标签： 传统方式，实现 Tag 接口 (老方法) 简单方式，继承 SimpleTagSupport 类 SimpleTagSupport 类的执行顺序 (原理)： ①WEB 容器调用标签处理器对象的 setJspContext 方法，将代表 JSP 页面的 pageContext 对象传递给标签处理器对象 ②WEB 容器调用标签处理器对象的 setParent 方法，将父标签处理器对象传递给这个标签处理器对象。【注意，只有在标签存在父标签的情况下，WEB 容器才会调用这个方法】 ③如果调用标签时设置了属性，容器将调用每个属性对应的 setter 方法把属性值传递给标签处理器对象。如果标签的属性值是 EL 表达式或脚本表达式，则 WEB 容器首先计算表达式的值，然后把值传递给标签处理器对象。 ④如果简单标签有标签体，容器将调用 setJspBody 方法把代表标签体的 JspFragment 对象传递进来 ⑤执行标签时：容器调用标签处理器的 doTag() 方法，开发人员在方法体内通过操作 JspFragment 对象，就可以实现是否执行、迭代、修改标签体的目的。 总结SimpleTagSupport，一般调用 doTag 方法或者实现 SimpleTag 接口 JSP 是如何被执行的？执行效率比 SERVLET 低吗？ JSP 是如何被执行的？执行效率比 SERVLET 低吗？ 当客户端向一个 jsp 页面发送请求时，Web Container 将 jsp 转化成 servlet 的源代码（只在第一次请求时），然后编译转化后的 servlet 并加载到内存中执行，执行的结果 response 到客户端 jsp 只在第一次执行的时候会转化成 servlet，以后每次执行，web 容器都是直接执行编译后的 servlet，所以 jsp 和 servlet 只是在第一次执行的时候不一样，jsp 慢一点，以后的执行都是相同的 如何避免 jsp 页面自动生成 session 对象？为什么要这么做？ 如何避免 jsp 页面自动生成 session 对象？为什么要这么做？ 可以使用页面指令显式关掉，代码如下： &lt;%@ page session=&quot;false&quot; %&gt; jsp 的缺点？ jsp 的缺点？ 1）不好调试 2）与其他脚本语言的交互 (可读性差) 说出 Servlet 和 CGI 的区别？ 说出 Servlet 和 CGI 的区别？ Servlet 处于服务器进程中，只会有一个 servlet 实例，每个请求都会产生一个新的线程，而且 servlet 实例一般不会销毁 CGI：来一个请求就创建一个进程，用完就销毁，效率低于 servlet 简述 JSP 的设计模式。 简述 JSP 的设计模式。 在 Web 开发模式中，有两个主要的开发结构，称为模式一（Mode I）和模式二（Mode II） 首先我们来理清一些概念吧： DAO(Data Access Object)：主要对数据的操作，增加、修改、删除等原子性操作。 Web 层：界面 + 控制器，也就是说 JSP【界面】+Servlet【控制器】 Service 业务层：将多个原子性的 DAO 操作进行组合，组合成一个完整的业务逻辑 控制层：主要使用 Servlet 进行控制 数据访问层：使用 DAO、Hibernate、JDBC 技术实现对数据的增删改查 JavaBean 用于封装数据，处理部分核心逻辑，每一层中都用到！ 模式一指的就是在开发中将显示层、控制层、数据层的操作统一交给 JSP 或者 JavaBean 来进行处理！ 模式一有两种情况： 完全使用 JSP 做开发: 优点： 开发速度贼快，只要写 JSP 就行了，JavaBean 和 Servlet 都不用设计！ 小幅度修改代码方便，直接修改 JSP 页面交给 WEB 容器就行了，不像 Servlet 还要编译成. class 文件再交给服务器！【当然了，在 ide 下开发这个也不算是事】 缺点： 程序的可读性差、复用性低、代码复杂！什么 jsp 代码、html 代码都往上面写，这肯定很难阅读，很难重用！ 使用 JSP+JavaBean 做开发: 优点： 程序的可读性较高，大部分的代码都写在 JavaBean 上，不会和 HTML 代码混合在一起，可读性还行的。 可重复利用高，核心的代码都由 JavaBean 开发了，JavaBean 的设计就是用来重用、封装，大大减少编写重复代码的工作！ 缺点： 没有流程控制，程序中的 JSP 页面都需要检查请求的参数是否正确，异常发生时的处理。显示操作和业务逻辑代码工作会紧密耦合在一起的！日后维护会困难 Mode II 中所有的开发都是以 Servlet 为主体展开的，由 Servlet 接收所有的客户端请求，然后根据请求调用相对应的 JavaBean，并所有的显示结果交给 JSP 完成！，也就是俗称的 MVC 设计模式！ MVC 设计模式： 显示层（View）：主要负责接受 Servlet 传递的内容，调用 JavaBean，将内容显示给用户 控制层（Controller）：主要负责所有用户的请求参数，判断请求参数是否合法，根据请求的类型调用 JavaBean，将最终的处理结果交给显示层显示！ 模型层（Mode）：模型层包括了业务层，DAO 层。 总结 （1）ModelI，JSP+JavaBean 设计模式。 （2）ModelII，MVC 设计模式。 参考：Servlet+JSP - 文集 - 简书https://www.jianshu.com/nb/21926044]]></content>
      <tags>
        <tag>面试</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP 学习]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29%2F</url>
    <content type="text"><![CDATA[JSP 第一篇【JSP 介绍、工作原理、生命周期、语法、指令、行为】什么是 JSPJSP 全名为 Java Server Pages，java 服务器页面。JSP 是一种基于文本的程序，其特点就是 HTML 和 Java 代码共同存在！ 为什么需要 JSPJSP 是为了简化 Servlet 的工作出现的替代品，Servlet 输出 HTML 非常困难，JSP 就是替代 Servlet 输出 HTML 的。 简单使用一下 JSP 在 idea 下生成一个 JSP，我们来看一下 JSP 长什么样子 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;简单使用JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 看起来就像一个 HTML 页面，前面也说了：JSP 的特点就是 HTML 和 Java 代码共同存在 我们向浏览器输出一句 HelloWorld，至于 &lt;%%&gt; 这个东西，我先不解释！ 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;简单使用JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% String s = &quot;HelloWorld&quot;; out.println(s);%&gt;&lt;/body&gt;&lt;/html&gt; JSP 的工作原理 在 Tomcat 博客中我提到过：Tomcat 访问任何的资源都是在访问 Servlet！，当然了，JSP 也不例外！JSP 本身就是一种 Servlet。为什么我说 JSP 本身就是一种 Servlet 呢？其实 JSP 在第一次被访问的时候会被编译为 HttpJspPage 类（该类是 HttpServlet 的一个子类） 刚才我简单使用了一下 JSP，它被编译成了这么一个 Servlet: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;import java.util.Date;public final class _1_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent &#123; private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory(); private static java.util.List&lt;String&gt; _jspx_dependants; private javax.el.ExpressionFactory _el_expressionfactory; private org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.List&lt;String&gt; getDependants() &#123; return _jspx_dependants; &#125; public void _jspInit() &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); &#125; public void _jspDestroy() &#123; &#125; public void _jspService(final HttpServletRequest request, final HttpServletResponse response) throws java.io.IOException, ServletException &#123; final PageContext pageContext; HttpSession session = null; final ServletContext application; final ServletConfig config; JspWriter out = null; final Object page = this; JspWriter _jspx_out = null; PageContext _jspx_page_context = null; try &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(&quot;\r\n&quot;); out.write(&quot;\r\n&quot;); out.write(&quot;&lt;html&gt;\r\n&quot;); out.write(&quot;&lt;head&gt;\r\n&quot;); out.write(&quot; &lt;title&gt;简单使用JSP&lt;/title&gt;\r\n&quot;); out.write(&quot;&lt;/head&gt;\r\n&quot;); out.write(&quot;&lt;body&gt;\r\n&quot;); String s = &quot;HelloWorda&quot;; out.println(s); out.write(&quot;\r\n&quot;); out.write(&quot;&lt;/body&gt;\r\n&quot;); out.write(&quot;&lt;/html&gt;\r\n&quot;); &#125; catch (Throwable t) &#123; if (!(t instanceof SkipPageException))&#123; out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125; if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); &#125; &#125; finally &#123; _jspxFactory.releasePageContext(_jspx_page_context); &#125; &#125;&#125; 编译过程是这样子的：浏览器第一次请求 1.jsp 时，Tomcat 会将 1.jsp 转化成 1_jsp.java 这么一个类，并将该文件编译成 class 文件。编译完毕后再运行 class 文件来响应浏览器的请求。 以后访问 1.jsp 就不再重新编译 jsp 文件了，直接调用 class 文件来响应浏览器。当然了，如果 Tomcat 检测到 JSP 页面改动了的话，会重新编译的。 既然 JSP 是一个 Servlet，那 JSP 页面中的 HTML 排版标签是怎么样被发送到浏览器的？我们来看下上面 1_jsp.java 的源码就知道了。原来就是用 write() 出去的罢了。说到底，JSP 就是封装了 Servlet 的 java 程序罢了。 12345678out.write(&quot;\r\n&quot;);out.write(&quot;\r\n&quot;);out.write(&quot;&lt;html&gt;\r\n&quot;);out.write(&quot;&lt;head&gt;\r\n&quot;);out.write(&quot; &lt;title&gt;简单使用JSP&lt;/title&gt;\r\n&quot;);out.write(&quot;&lt;/head&gt;\r\n&quot;);out.write(&quot;&lt;body&gt;\r\n&quot;); 有人可能也会问：JSP 页面的代码服务器是怎么执行的？再看回 1_jsp.java 文件，java 代码就直接在类中的 service() 中。 123String s = &quot;HelloWorda&quot;;out.println(s); JSP 比 Servlet 更方便更简单的一个重要原因就是：内置了 9 个对象！内置对象有：out、session、response、request、config、page、application、pageContext、exception，这几个内置对象不在这里讲。现在先知道一下即可！ JSP 生命周期JSP 也是 Servlet，运行时只有一个实例，JSP 初始化和销毁时也会调用 Servlet 的 init() 和 destroy() 方法。另外，JSP 还有自己初始化和销毁的方法 12345678public void _jspInit() &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());&#125;public void _jspDestroy() &#123;&#125; JSP 的语法JSP 代码可以分为两部分： 模板数据：就是 HTML 代码 元素：JSP 页面中的 java 代码、JSP 指令、JSP 标签 JSP 脚本 JSP 的脚本就是 JSP 页面中的 java 代码，也叫做 scriptlet。JSP 的脚本必须使用 &lt;%%&gt; 括起来，不然会被当成是模板数据的！ JSP 脚本有三种方式： &lt;%%&gt;【定义局部变量，编写语句】 &lt;%!%&gt;【定义类或方法，但是没人这样用！】 &lt;%=%&gt;（也称之为表达式输出）【输出各种类型的变量，int、double、String、Object 等】 如果过多地使用 &lt;%%&gt; 会导致代码混乱，JSP 还提供了一种 scriptlet 标签，使用此标签和 &lt;%%&gt; 有相同的功能，只不过它更美观了一些 1234567&lt;jsp:scriptlet&gt; String s = &quot;HelloWorld&quot;; out.println(s);&lt;/jsp:scriptlet&gt; JSP 注释123456789&lt;%--这是JSP注释--%&gt;&lt;%--%&gt;//这是java的当行注释///*这是java的多行注释*//**/ JSP 指令JSP 指令用来声明 JSP 页面的相关属性，例如编码方式、文档类型等等 JSP 指令的语法： 12&lt;%@指令 属性名=&quot;值&quot; %&gt; page 指令 我在 idea 生成的 JSP 页面就有 page 指令了。 12&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; page 指令常见属性： language=”java” extends=”package.class” import=”{package.class | package.*}, …” session=”true | false” buffer=”none | 8kb | sizekb” autoFlush=”true | false” isThreadSafe=”true | false” info=”text” errorPage=”relative_url” isErrorPage=”true | false” contentType=”mimeType ;charset=characterSet” | “text/html ; charset=ISO-8859-1” pageEncoding=”characterSet | ISO-8859-1” isELIgnored=”true | false” 一般地，在 eclipse 或 idea 这些高级开发工具上开发，我们只需要在 page 指令中指定 contentType=”text/html;charset=UTF-8”，就不会出现中文乱码问题！ 当然了 contentType 不仅仅可以指定以 text/html 的方式显示，还可以使用其他的形式显示出来。在 conf/web.xml 文件中可以查询出来 比如，我以 doc 形式显示 jsp 的数据 1234567891011&lt;%@ page contentType=&quot;application/msword;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;简单使用JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1111&lt;/body&gt;&lt;/html&gt; 效果是这样子的： 我们上网的时候，如果我们操作不当，或者服务器出错了，页面都是会出现友好提示的！这个也能通过 page 指令来实现跳转到友好提示页面上！ page 指令 errorPage = 和 isErrorPage 这两个属性，下面我们来看一下怎么使用！ 1.jsp 出现了错误，通过 page 指令的 errorPage 属性跳转到 error.jsp 页面上 1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; errorPage=&quot;error.jsp&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;该页面出错了！&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--模拟页面出错了！！！--%&gt; &lt;% int result = 2 / 0; %&gt; 你好呀&lt;/body&gt;&lt;/html&gt; error.jsp 页面要通过 page 指令的 isErrorPage 属性设置页面就是错误页面 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isErrorPage=&quot;true&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;友好提示页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 服务器正忙着呢！ &lt;/body&gt;&lt;/html&gt; 下面是效果： 当然了，细心的朋友可以发现地址栏是没有变化的，所以属于是服务器跳转。以上的做法是单个页面设置的，如果我会有很多错误（JSP 多的情况下，错误就会多），单个设置太麻烦了！ 我们可以在 web.xml 文件中全局设置错误页，只要发生了 404 错误或者空指针异常的错误都会跳转到 error.jsp 页面上 12345678910&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.NullPointerException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; 随便输个资源进行，会发生发 404 错误的，跳转到错误页面。下面是效果： include 指令 在讲解 request 对象的时候，我们曾经使用过 request.getRequestDispatcher(String url).include(request,response) 来对页头和页尾面进行包含 inclue 指令也是做这样的事情，我们来试验一下吧！ 这是页头 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是页头 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 这是页尾 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页尾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;我是页尾&lt;/body&gt;&lt;/html&gt; 在 1.jsp 中把页头和页尾包含进来 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;包含页头和页尾进来&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%@include file=&quot;head.jsp&quot; %&gt;&lt;%@include file=&quot;foot.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 访问 1.jsp include 指令是静态包含。静态包含的意思就是：把文件的代码内容都包含进来，再编译！，看一下 jsp 的源代码就知道了！ jsp 还提供另一种包含文件的方式：JSP 行为 — 动态包含。jsp 行为在下面会讲到！ taglib 指令 JSP 支持标签技术，要使用标签技术就先得声明标签库和标签前缀。taglib 指令就是用来指明 JSP 页面内使用标签库技术。 这里就不详细说明了，等到学习 JSP 标签的时候再使用吧！现在记住有这个指令即可。 JSP 行为 JSP 行为（JSP Actions）是一组 JSP 内置的标签，只书写少量的标记代码就能够使用 JSP 提供丰富的功能，JSP 行为是对常用的 JSP 功能的抽象和封装。 为什么我不把它直接称为 JSP 标签呢？我把这些 JSP 内置的标签称之为 JSP 行为，能够和 JSTL 标签区分开来。当然了，你也可以把它称之为 JSP 标签，你不要搞混就行了。我个人喜欢把这些 JSP 内置标签称之为 JSP 行为。 include 行为 上面已经提及到了，include 指令是静态包含，include 行为是动态包含。其实 include 行为就是封装了 request.getRequestDispatcher(String url).include(request,response) include 行为语法是这个样子的 12&lt;jsp:include page=&quot;&quot;/&gt; 我们先来使用一下把，在 1.jsp 页面中也将页头和页尾包含进来。 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;包含页头和页尾进来&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:include page=&quot;head.jsp&quot;/&gt; &lt;jsp:include page=&quot;foot.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 访问 1.jsp 页面看一下效果： 使用 jsp 行为来包含文件，jsp 源文件是这样子的： jsp 行为包含文件就是先编译被包含的页面，再将页面的结果写入到包含的页面中（1.jsp) 当然了，现在有静态包含和动态包含，使用哪一个更好呢？答案是：动态包含。 动态包含可以向被包含的页面传递参数（用处不大），并且是分别处理包含页面的（将被包含页面编译后得出的结果再写进包含页面）【如果有相同名称的参数，使用静态包含就会报错！】！ 模拟一下场景吧，现在我的头页面有个名为 s 的字符串变量 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% String s = &quot;zhongfucheng&quot;; %&gt; 我是页头呀 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 我的页尾也有个名为 s 的字符串变量 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页尾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% String s = &quot;zhongfucheng&quot;;%&gt;我是页尾呀&lt;/body&gt;&lt;/html&gt; 现在我使用静态包含看看会发生什么，出现异常了。 出现异常的原因很简单，就是同一个文件中有两个相同的变量 s 使用动态包含就可以避免这种情况 param 行为 当使用 forward 行为 在讲解 request 对象的时候，我们使用 request.getRequestDispatcher(String url).forward(request,response) 进行跳转。其实 forward 行为就是对其封装！ 我们来看一下 forward 的语法： 1&lt;jsp:forward page=&quot;&quot;/&gt; 好的，我们来使用一下吧。访问 1.jsp 页面就跳转到 head.jsp 页面中 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;访问1.jsp就跳转到head.jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;jsp:forward page=&quot;head.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 看一下效果 如果我要传递参数，就要在 forward 行为嵌套 param 行为 在跳转到 head.jsp 时传入参数 username 值为 zhongfucheng 123&lt;jsp:forward page=&quot;head.jsp&quot;&gt; &lt;jsp:param /&gt;&lt;/jsp:forward&gt; 在 head.jsp 页面中获取到传递过来的参数 1234567&lt;% String ss = request.getParameter(&quot;username&quot;);%&gt;获取到的参数是：&lt;%=ss%&gt; 效果如下图所示 directive 行为 directive 的中文意思就是指令。该行为就是替代指令 %@% 的语法的 我们来试一下能不能用的 123&lt;jsp:directive.include file=&quot;head.jsp&quot;&gt;&lt;/jsp:directive.include&gt;&lt;jsp:directive.include file=&quot;foot.jsp&quot;&gt;&lt;/jsp:directive.include&gt; 看下效果，正常可以包含页面： 使用该指令可以让 JSP 页面更加美观！ 使用 scriptlet 行为&lt;jsp:scriptlet&gt;替代 &lt;%%&gt; 是同样一个道理 javaBean 行为 JSP 还提供了操作 javaBean 对象的行为，在这里就不详细说明了，后面会讲到的！现在记住 JSP 提供了 javaBean 行为来操作简单类即可！ &lt;jsp:useBean id=&quot;&quot;/&gt; &lt;jsp:setProperty /&gt; &lt;jsp:getProperty /&gt; JSP 第二篇【内置对象的介绍、4 种属性范围、应用场景】什么是 JSP 内置对象 JSP 引擎在调用 JSP 对应的 jspServlet 时，会传递或创建 9 个与 web 开发相关的对象供 jspServlet 使用。JSP 技术的设计者为便于开发人员在编写 JSP 页面时获得这些 web 对象的引用，特意定义了 9 个相应的变量，开发人员在 JSP 页面中通过这些变量就可以快速获得这 9 大对象的引用 细心的朋友会发现，我们没有在 JSP 页面上定义过 out 对象，却可以直接使用！其实 out 对象就是 JSP 内置对象之一。 九个内置对象： pageContext page config request response session application exception out out 对象out 对象的 API int getBufferSize()【得到缓存大小】 int getRemaining()【得到未使用缓存的大小】 boolean isAutoFlush() void println() void flush() void close() void clearBuffer() void clear() out 对象用于向浏览器输出数据，与之对应的是 Servlet 的 PrintWriter 对象。然而这个 out 对象的类型并不是 PrintWriter，是 JspWriter 我们可以简单理解为：JspWriter 就是带缓存的 PrintWrieter。 out 对象的原理如下： 只有向 out 对象中写入了内容，且满足如下任何一个条件时，out 对象才去调用 ServletResponse.getWriter 方法，并通过该方法返回的 PrintWriter 对象将 out 对象的缓冲区中的内容真正写入到 Servlet 引擎提供的缓冲区中： 设置 page 指令的 buffer 属性关闭了 out 对象的缓存功能 out 对象的缓冲区已满 整个 JSP 页面结束 一般我们在 JSP 页面输出都是用表达式（&lt;%=%&gt;)，所以 out 对象用得并不是很多！ request 内置对象 request 其实就是 HttpServletRequest，在 Servlet 讲解的时候已经详细说明了，没什么好说的 response 内置对象 response 其实就是 HttpServletResponse，在 Servlet 讲解的时候已经详细说明了，没什么好说的 config 内置对象 config 其实就是 ServletConfig，在 Servlet 讲解的时候已经详细说明了，没什么好说的 session 内置对象 session 其实就是 HttpSession。，在 Servlet 讲解的时候已经详细说明了，没什么好说的 注意：在 page 指令配置如下信息，session 将不可使用 12&lt;%@page session=&quot;false&quot; %&gt; application 内置对象 application 其实就是 ServletContext 对象，在 Servlet 讲解的时候已经详细说明了，没什么好说的 page 内置对象 page 是 HttpJasPage 对象，其实 page 对象代表的就是当前 JSP 页面，是当前 JSP 编译后的 Servlet 类的对象。也就是说：page 对象相当于普通 java 类的 this exception 内置对象 exception 是 java.lang.Exception 类的对象，exception 封装了 JSP 页面抛出的异常信息。exception 经常被用来处理错误页面 前面我们已经讲过了怎么设置错误页面了，下面我们就来简单使用一下 exception 对象吧 1.jsp 页面 1234&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; errorPage=&quot;error.jsp&quot; %&gt;&lt;%--模拟空指针异常的错误--%&gt;&lt;% String sss = null; sss.length();%&gt; 12* error.jsp页面 1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isErrorPage=&quot;true&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% out.println(&quot;程序抛出了异常：&quot; + exception);%&gt;&lt;/body&gt;&lt;/html&gt; 效果： pageContextpageContext是内置对象中最重要的一个对象，它代表着JSP页面编译后的内容（也就是JSP页面的运行环境）！ pageContext获取8个内置对象 既然它代表了JSP页面编译后的内容，理所当然的：它封装了对其他8大内置对象的引用！，也就是说，通过pageContext可以获取到其他的8个内置对象！ 1234567891011121314151617181920212223&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;获取八大内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(pageContext.getSession()); System.out.println(pageContext.getRequest()); System.out.println(pageContext.getResponse()); System.out.println(pageContext.getException()); System.out.println(pageContext.getPage()); System.out.println(pageContext.getServletConfig()); System.out.println(pageContext.getServletContext()); System.out.println(pageContext.getOut());%&gt;&lt;/body&gt;&lt;/html&gt; pageContext作为域对象 类似于request，session，ServletContext作为域对象而言都有以下三个方法： setAttribute(String name,Objcet o) getAttribute(String name) removeAttribute(String name) 当然了，pageContext也不例外，pageContext也有这三个方法！ pageContext本质上代表的是当前JSP页面编译后的内容，作为域对象而言，它就代表着当前JSP页面（也就是page）！也就是说：pageContext域对象只在page范围内有效，超出了page范围就无效了！ 首先来看看在page范围内能不能使用 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用page域对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;zhongfucheng&quot;);%&gt;&lt;% String value = (String) pageContext.getAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 我们现在来试验一下是不是超出了page范围就无效了！ 在2.jsp中request域对象设置属性 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request域对象设置属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //这是request域对象保存的内容 request.setAttribute(&quot;name&quot;,&quot;zhongfucheng&quot;);%&gt;&lt;%--跳转到1.jsp中--%&gt;&lt;jsp:forward page=&quot;1.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 企图在1.jsp中pageContext取出request存进去的属性 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在page域对象获取属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //企图获取request域对象存进的属性 String value = (String) pageContext.getAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： pageContext本质上代表着编译后JSP的内容，pageContext还可以封装了访问其他域的方法！ 上面的pageContext默认是page范围的，但pageContext对象重载了set、get、removeAttribute这三个方法 getAttribute(String name,int scope) setAttribute(String name,Object value,int scope) removeAttribute(String name,int scope) 多了一个设置域范围的一个参数，如果不指定默认就是page。当然了，pageContext把request、session、application、page这几个域对象封装着了静态变量供我们使用。 PageContext.APPLICATION_SCOPE PageContext.SESSION_SCOPE PageContext.REQUEST_SCOPE PageContext.PAGE_SCOPE 刚才我们没有使用重载方法的时候，使用pageContext是无法获取到request域对象设置的属性的。现在我们使用重载后的方法看一下能不能获取得到！ 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在page域对象获取request域对象的属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //使用重载的方法获取request域对象的属性 String value = (String) pageContext.getAttribute(&quot;name&quot;,pageContext.REQUEST_SCOPE); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果： pageContexst还有这么一个方法： findAttribute(String name) 该方法会查找各个域的属性，从小到大开始寻找！也就是page—&gt;request-&gt;session-&gt;application。这个是EL表达式的原理！，EL表达式后面会讲到！ 我们用此方法看能不能查找出request域对象的属性吧！ 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用findAttribute&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //使用findAttribute查找2.jsp中request域对象的属性 String value = (String) pageContext.findAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 引入和跳转PageContext类中定义了一个forward方法和两个include方法来分别简化和替代RequestDispatcher.forward方法和include方法。 pageContext.forward(String url) pageContext.include(String url) 4种属性范围到目前为止，我们已经学了4种属性范围了。 1. page【只在一个页面中保存属性，跳转页面无效】2. requet【只在一次请求中保存属性，服务器跳转有效，浏览器跳转无效】3. session【在一个会话范围中保存属性，无论何种跳转均有效，关闭浏览器后无效】4. application【在整个服务器中保存，所有用户都可以使用】 4个内置对象都支持以下的方法： 1. setAttribute(String name, Object o )2. getAttribute(String name)3. removeAttribute(String name) 应用场景1. request：如果客户向服务器发请求，产生的数据，用户看完就没用了，像这样的数据就存在request域,像新闻数据，属于用户看完就没用的2. session：如果客户向服务器发请求，产生的数据，用户用完了等一会儿还有用，像这样的数据就存在session域中，像购物数据，用户需要看到自己购物信息，并且等一会儿，还要用这个购物数据结帐3. servletContext：如果客户向服务器发请求，产生的数据，用户用完了，还要给其它用户用，像这样的数据就存在servletContext域中，像聊天数据 JSP 第三篇【JavaBean 的介绍、JSP 的行为 –JavaBean】什么是 javaBean JavaBean 就是一个普通的 java 类，也称之为简单 java 对象 –POJO（Plain Ordinary Java Object），是 Java 程序设计中一种设计模式，是一种基于 Java 平台的软件组件思想 JavaBean 遵循着特定的写法，通常有以下的规则： 有无参的构造函数 成员属性私有化 封装的属性如果需要被外所操作，必须编写 public 类型的 setter、getter 方法 上面的文字看起来好像很高大上，javaBean 其实非常简单，下面的代码就是按照特定写法、规则编写的一个 JavaBean 对象 12345678910111213141516171819202122232425public class Person &#123; private String username ; private int age; public Person() &#123; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 为什么需要使用 Javabean 使用 javaBean 的好处就是：封装，重用, 可读！ 下面引用知乎一段回答： JaveBean 你可以理解为一辆货车，在你的 java 端和 web 页面进行数据传递的载体，你当然可以每个变量单独传递，或者使用集合传递，但是 javabean 可以使你的数据更有可读性，方便开发时明确变量的意义，也使其他阅读你代码的人能直接你的意图 如果把 bean 类与数据库联合使用，一张表使用 bean 类，可以使你的代码更加简洁高效，易于理解，现在大多数框架都会使用这种机制。 JSP 行为 –JavaBean JSP 技术提供了三个关于 JavaBean 组件的动作元素，即 JSP 行为（标签），它们分别为： &lt;jsp:useBean&gt;【在 JSP 页面中查找 javaBean 对象或者实例化 javaBean 对象】 &lt;jsp:setProperty&gt;【设置 javaBean 的属性】 &lt;jsp:getProperty&gt;【获取 javaBean 的属性】 jsp:useBean &lt;jsp:useBean&gt;标签用于在指定的域范围内查找指定名称的 JavaBean 对象： 存在则直接返回该 JavaBean 对象的引用。 不存在则实例化一个新的 JavaBean 对象并将它以指定的名称存储到指定的域范围中。 语法： 12&lt;jsp:useBean id=&quot;实例化对象的名称&quot; class=&quot;类的全名&quot; scope=&quot;保存范围&quot;/&gt; 如果 JSP 不支持&lt;jsp:useBean&gt;这个行为，我们要使用 Person 类是这样使用的 123456789101112131415161718192021&lt;%--这里需要导入Person类--%&gt;&lt;%@ page import=&quot;domain.Person&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //new出对象 Person person = new Person(); person.setName(&quot;zhongfucheng&quot;); System.out.println(person.getName());%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 我们使用&lt;jsp:useBean&gt;就显得非常简洁，不用导包，不用 new 出对象 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;&lt;% person.setName(&quot;zhongfucheng&quot;); System.out.println(person.getName());%&gt;&lt;/body&gt;&lt;/html&gt; 也可以实现同样的效果： 有人可能会想，凭什么写一个&lt;jsp:useBean&gt;这样的代码就可以创建出一个对象出来。 现在我把 JavaBean 中无参的构造函数改成有参的，我们看看会出现什么情况，出现异常了！ 1234public Person(int age) &#123; this.age = age; &#125; &lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;内部原理是这样子的： 通过上面的代码我们也知道了为什么要有一个无参的构造函数！内部在 new 对象的时候是没有传递参数进去的！ jsp:setProperty 语法： 12&lt;jsp:setProerty &gt; 在语法上可分为 4 种模式 当我们没有学习到&lt;jsp:setProperty&gt;时，我们获取表单的信息，然后导入到 javaBean 对象中是这样的一种情况： 这是表单的页面代码： 123456&lt;form action=&quot;/zhongfucheng/1.jsp&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt; 年龄：&lt;input type=&quot;text &quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 这是处理表单提交过来数据的 jsp 的代码 12345678910&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;&lt;% int age = Integer.parseInt(request.getParameter(&quot;age&quot;)); person.setAge(age); System.out.println(person.getAge());%&gt; 这是可以完成的，但是相对来说，比较麻烦！ 我们来使用 12345678&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;&lt;%--指定属性名称为age--%&gt;&lt;jsp:setProperty /&gt;&lt;% System.out.println(person.getAge());%&gt; 也可以完成，并且代码更少，功能更强大！ 代码更少可以直观看出来，为什么我说它功能更加强大呢？表单提交过来的数据都是字符串，在我们没有用！但是 我们再来使用一下自动匹配来感受它的强大之处吧 123456789&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;&lt;%--property的值设置为*就代表自动匹配--%&gt;&lt;jsp:setProperty /&gt;&lt;% System.out.println(person.getAge()); System.out.println(person.getName());%&gt; 我们再来看一下效果： 看到这里，有人可能会觉得好神奇：只要设置 property 的值就可以将表单传递过来的数据封装到 JavaBean 对象中了！这究竟是这样做到的？？？ 细心的朋友会发现，JavaBean 的属性名称和表单的 name 属性设置的名称是一模一样的！ 123456private String username ;private int age;用户名：&lt;input type=&quot;text&quot; &gt;年龄：&lt;input type=&quot;text &quot; &gt; 如果我设置不一样还能不能用？我们试试：表单 name 属性的 username 改成是 user 12用户名：&lt;input type=&quot;text&quot; &gt; 我们再来看看还能不能把表单的数据完整地封装 JavaBean 对象中 我们可以发现：要想能够把表单带过来的数据成功封装到 JavaBean 对象上，名字要一致！也就是说：JavaBean 属性名要和表单的 name 的名称一致 至于原理，它是通过反射来做的, 调用了内省的方法！，我们看编译后的 JSP 就明白了。 jsp:getProperty 语法： 该 jsp 行为十分简单，我们来使用一下就知道了。 1234&lt;%--使用&lt;jsp:getProperty&gt;输出--%&gt;&lt;jsp:getProperty /&gt;&lt;jsp:getProperty /&gt; 效果： 原理如下 JSP 第四篇【EL 表达式介绍、获取各类数据、11 个内置对象、执行运算、回显数据、自定义函数、fn 方法库】什么是 EL 表达式？表达式语言（Expression Language，EL）,EL 表达式是用 “${}” 括起来的脚本，用来更方便的读取对象！ EL 表达式主要用来读取数据，进行内容的显示！ 为什么要使用 EL 表达式？ 为什么要使用 EL 表达式，我们先来看一下没有 EL 表达式是怎么样读取对象数据的吧！ 在 1.jsp 中设置了 Session 属性 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;向session设置一个属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //向session设置一个属性 session.setAttribute(&quot;name&quot;, &quot;aaa&quot;); System.out.println(&quot;向session设置了一个属性&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; 在 2.jsp 中获取 Session 设置的属性 1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% String value = (String) session.getAttribute(&quot;name&quot;); out.write(value);%&gt;&lt;/body&gt;&lt;/html&gt; 上面看起来，也没有多复杂呀，那我们试试 EL 表达式的！ 在 2.jsp 中读取 Session 设置的属性 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;name&#125;&lt;/body&gt;&lt;/html&gt; 只用了简简单单的几个字母就能输出 Session 设置的属性了！并且输出在浏览器上！ 使用 EL 表达式可以方便地读取对象中的属性、提交的参数、JavaBean、甚至集合！ EL 表达式的作用 首先来看一下 EL 表达式的语法吧： 12$&#123;标识符&#125; EL 表达式如果找不到相应的对象属性，返回的的空白字符串 “”，而不是 null，这是 EL 表达式最大的特点！ 获取各类数据获取域对象的数据 上面在例子中，我们已经体验到了获取 Session 域对象的数据是多么地方便！其实 EL 表达式可以让我们获取各个域范围的数据 在 1.jsp 中设置 ServeltContext 属性（也就是 application） 123456&lt;% //向ServletContext设置一个属性 application.setAttribute(&quot;name&quot;, &quot;aaa&quot;); System.out.println(&quot;向application设置了一个属性&quot;);%&gt; 在 2.jsp 中获取 application 的属性 12345&lt;% $&#123;name&#125;%&gt; 和 Session 一样，也能获取得到！ 之前我们来讲 ServletContext 对象的时候讲过一个方法 findAttribute(String name),EL 表达式语句在执行的时候会调用该方法，用标识符作为关键字分别从 page、request、session、application 四个域中查找相应的对象。这也解释了为什么 EL 表达式可以仅仅通过标识符就能够获取到存进域对象的数据！ findAttribute() 的查找顺序：从小到大，也就是 page-&gt;request-&gt;session-&gt;application 获取 JavaBean 的属性 以前在 JSP 页面获取 JavaBean 的数据是这样子的： 1.jsp 页面 Session 存进一个 Person 对象，设置 age 的属性为 22 123&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;session&quot;/&gt;&lt;jsp:setProperty /&gt; 在 2.jsp 中取出 Session 的属性 1234567&lt;% Person person = (Person) session.getAttribute(&quot;person&quot;); System.out.println(person.getAge());%&gt; 现在我使用了 EL 表达式读取数据又会非常方便了 123//等同于person.getAge()$&#123;person.age&#125; 上面的代码 等同于调用对象的 getter 方法，内部是通过反射机制完成的！ 获取集合的数据 集合操作在开发中被广泛地采用，在 EL 表达式中也很好地支持了集合的操作！可以非常方便地读取 Collection 和 Map 集合的内容 为了更好地看出 EL 表达式的强大之处，我们也来对比一下使用 EL 表达式和不使用 EL 表达式的区别 下面不使用 EL 表达式输出集合的元素 在 1.jsp 页面中设置 session 的属性，session 属性的值是 List 集合，List 集合装载的又是 Person 对象 123456789101112131415&lt;% List&lt;Person&gt; list = new ArrayList(); Person person1 = new Person(); person1.setUsername(&quot;zhongfucheng&quot;); Person person2 = new Person(); person2.setUsername(&quot;ouzicheng&quot;); list.add(person1); list.add(person2); session.setAttribute(&quot;list&quot;,list);%&gt; 在 2.jsp 中获取到 session 的属性，并输出到页面上 123456789&lt;% List&lt;Person&gt; list = (List) session.getAttribute(&quot;list&quot;); out.write(list.get(0).getUsername()+&quot;&lt;br&gt;&quot;); out.write(list.get(1).getUsername());%&gt; 使用 EL 表达式又是怎么样的效果呢？我们来看看！ 12345&lt;%--取出list集合的第1个元素（下标从0开始），获取username属性--%&gt;$&#123;list[0].username&#125;&lt;br&gt;&lt;%--取出list集合的第2个元素，获取username属性--%&gt;$&#123;list[1].username&#125; 我们再来使用一下 Map 集合 在 1.jsp 中 session 属性存储了 Map 集合，Map 集合的关键字是字符串，值是 Person 对象 12345678910111213141516&lt;% Map&lt;String, Person&gt; map = new HashMap&lt;&gt;(); Person person1 = new Person(); person1.setUsername(&quot;zhongfucheng1&quot;); Person person2 = new Person(); person2.setUsername(&quot;ouzicheng1&quot;); map.put(&quot;aa&quot;,person1); map.put(&quot;bb&quot;,person2); session.setAttribute(&quot;map&quot;,map);%&gt; 看起来好像取出数据的时候是会有点复杂，但是有了 EL 表达式也是非常轻松的！ 1234$&#123;map.aa.username&#125;&lt;br&gt;$&#123;map.bb.username&#125; 效果： 如果 Map 集合存储的关键字是一个数字，就不能使用 “.” 号运算符了，如下所示 对于这种情况，我们可以使用 “[]” 的形式读取 Map 集合的数据 1234$&#123;map[&quot;1&quot;].username&#125;&lt;br&gt;$&#123;map[&quot;2&quot;].username&#125; EL 表达式配合 JSTL 标签可以很方便的迭代集合，后面讲到 JSTL 标签的时候会用到! 这里就不详细说明了。 EL 运算符 EL 表达式支持简单的运算符：加减乘除取摸，逻辑运算符。empty 运算符（判断是否为 null)，三目运算符 empty 运算符可以判断对象是否为 null，用作于流程控制！ 三目运算符简化了 if 和 else 语句，简化代码书写 123456&lt;% List&lt;Person&gt; list = null;%&gt;$&#123;list==null?&quot;list集合为空&quot;:&quot;list集合不为空&quot;&#125; EL 表达式 11 个内置对象EL 表达式主要是来对内容的显示，为了显示的方便，EL 表达式提供了 11 个内置对象。 pageContext 对应于 JSP 页面中的 pageContext 对象（注意：取的是 pageContext 对象） pageScope 代表 page 域中用于保存属性的 Map 对象 requestScope 代表 request 域中用于保存属性的 Map 对象 sessionScope 代表 session 域中用于保存属性的 Map 对象 applicationScope 代表 application 域中用于保存属性的 Map 对象 param 表示一个保存了所有请求参数的 Map 对象 paramValues 表示一个保存了所有请求参数的 Map 对象，它对于某个请求参数，返回的是一个 string[] header 表示一个保存了所有 http 请求头字段的 Map 对象 headerValues 同上，返回 string[] 数组。 cookie 表示一个保存了所有 cookie 的 Map 对象 initParam 表示一个保存了所有 web 应用初始化参数的 map 对象 下面测试各个内置对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%--pageContext内置对象--%&gt;&lt;% pageContext.setAttribute(&quot;pageContext1&quot;, &quot;pageContext&quot;);%&gt;pageContext内置对象：$&#123;pageContext.getAttribute(&quot;pageContext1&quot;)&#125;&lt;br&gt;&lt;%--pageScope内置对象--%&gt;&lt;% pageContext.setAttribute(&quot;pageScope1&quot;,&quot;pageScope&quot;);%&gt;pageScope内置对象:$&#123;pageScope.pageScope1&#125;&lt;br&gt;&lt;%--requestScope内置对象--%&gt;&lt;% request.setAttribute(&quot;request1&quot;,&quot;reqeust&quot;);%&gt;requestScope内置对象:$&#123;requestScope.request1&#125;&lt;br&gt;&lt;%--sessionScope内置对象--%&gt;&lt;% session.setAttribute(&quot;session1&quot;, &quot;session&quot;);%&gt;sessionScope内置对象：$&#123;sessionScope.session1&#125;&lt;br&gt;&lt;%--applicationScope内置对象--%&gt;&lt;% application.setAttribute(&quot;application1&quot;,&quot;application&quot;);%&gt;applicationScopt内置对象：$&#123;applicationScope.application1&#125;&lt;br&gt;&lt;%--header内置对象--%&gt;header内置对象：$&#123;header.Host&#125;&lt;br&gt;&lt;%--headerValues内置对象,取出第一个Cookie--%&gt;headerValues内置对象：$&#123;headerValues.Cookie[0]&#125;&lt;br&gt;&lt;%--Cookie内置对象--%&gt;&lt;% Cookie cookie = new Cookie(&quot;Cookie1&quot;, &quot;cookie&quot;);%&gt;Cookie内置对象：$&#123;cookie.JSESSIONID.value&#125;&lt;br&gt;&lt;%--initParam内置对象，需要为该Context配置参数才能看出效果【jsp配置的无效！亲测】--%&gt;initParam内置对象:$&#123;initParam.name&#125;&lt;br&gt; 注意事项： 测试 headerValues 时，如果头里面有 “-” ，例 Accept-Encoding，则要 headerValues[“Accept-Encoding”] 测试 cookie 时，例${cookie.key}取的是 cookie 对象，如访问 cookie 的名称和值，须${cookie.key.name}或${cookie.key.value} 测试 initParam 时，初始化参数要的 web.xml 中的配置 Context 的，仅仅是 jsp 的参数是获取不到的 上面已经测过了 9 个内置对象了，至于 param 和 parmaValues 内置对象一般都是别的页面带数据过来的（表单、地址栏）！ 表单页面 12345678910&lt;form action=&quot;/zhongfucheng/1.jsp&quot; method=&quot;post&quot;&gt;用户名：&lt;input type=&quot;text&quot; &gt;&lt;br&gt;年龄：&lt;input type=&quot;text &quot; &gt;&lt;br&gt;爱好：&lt;input type=&quot;checkbox&quot; &gt;足球&lt;input type=&quot;checkbox&quot; &gt;篮球&lt;input type=&quot;checkbox&quot; &gt;兵乓球&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 处理表单页面： 123456789101112131415$&#123;param.username&#125;&lt;br&gt;$&#123;param.age&#125;&lt;br&gt;//没有学习jstl之前就一个一个写吧。$&#123;paramValues.hobbies[0]&#125;&lt;br&gt;$&#123;paramValues.hobbies[1]&#125;&lt;br&gt;$&#123;paramValues.hobbies[2]&#125;&lt;br&gt; 当然了，使用地址栏方式提交数据给处理页面也是用 param 内置对象去获取数据的！ EL 表达式回显数据EL 表达式最大的特点就是：如果获取到的数据为 null，输出空白字符串 “”！这个特点可以让我们数据回显 在 1.jsp 中模拟场景 123456789101112&lt;%--模拟数据回显场景--%&gt;&lt;% User user = new User(); user.setGender(&quot;male&quot;); //数据回显 request.setAttribute(&quot;user&quot;,user);%&gt;&lt;input type=&quot;radio&quot; $&#123;user.gender==&apos;male&apos;?&apos;checked&apos;:&apos;&apos; &#125;&gt;男&lt;input type=&quot;radio&quot; $&#123;user.gender==&apos;female&apos;?&apos;checked&apos;:&apos;&apos; &#125;&gt;女 EL 自定义函数EL 自定义函数用于扩展 EL 表达式的功能，可以让 EL 表达式完成普通 Java 程序代码所能完成的功能 开发 HTML 转义的 EL 函数 我们有时候想在 JSP 页面中输出 JSP 代码，但是 JSP 引擎会自动把 HTML 代码解析，输出给浏览器。此时我们就要对 HTML 代码转义。 步骤： 编写一个包含静态方法的类（EL 表达式只能调用静态方法），该方法很常用，Tomcat 都有此方法，可在 \ webapps\examples\WEB-INF\classes\util 中找到 123456789101112131415161718192021222324252627282930public static String filter(String message) &#123; if (message == null) return (null); char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuilder result = new StringBuilder(content.length + 50); for (int i = 0; i &lt; content.length; i++) &#123; switch (content[i]) &#123; case &apos;&lt;&apos;: result.append(&quot;&amp;lt;&quot;); break; case &apos;&gt;&apos;: result.append(&quot;&amp;gt;&quot;); break; case &apos;&amp;&apos;: result.append(&quot;&amp;amp;&quot;); break; case &apos;&quot;&apos;: result.append(&quot;&amp;quot;&quot;); break; default: result.append(content[i]); &#125; &#125; return (result.toString());&#125; 在 WEB/INF 下创建 tld（taglib description）文件，在 tld 文件中描述自定义函数 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot; version=&quot;2.1&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;myshortname&lt;/short-name&gt; &lt;uri&gt;/zhongfucheng&lt;/uri&gt; &lt;!--函数的描述--&gt; &lt;function&gt; &lt;!--函数的名字--&gt; &lt;name&gt;filter&lt;/name&gt; &lt;!--函数位置--&gt; &lt;function-class&gt;utils.HTMLFilter&lt;/function-class&gt; &lt;!--函数的方法声明--&gt; &lt;function-signature&gt;java.lang.String filter(java.lang.String)&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 在 JSP 页面中导入和使用自定义函数，EL 自定义的函数一般前缀为 “fn”，uri 是 “/WEB-INF/tld 文件名称” 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@taglib prefix=&quot;fn&quot; uri=&quot;/WEB-INF/zhongfucheng.tld&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;//完成了HTML转义的功能$&#123;fn:filter(&quot;&lt;a href=&apos;#&apos;&gt;点我&lt;/a&gt;&quot;)&#125;&lt;/body&gt;&lt;/html&gt; 效果： [图片上传中…(image-1fc61b-1517900786708-3)] EL 函数库（fn 方法库） 由于在 JSP 页面中显示数据时，经常需要对显示的字符串进行处理，SUN 公司针对于一些常见处理定义了一套 EL 函数库供开发者使用。 其实 EL 函数库就是 fn 方法库，是 JSTL 标签库中的一个库，也有人称之为 fn 标签库，但是该库长得不像是标签，所以称之为 fn 方法库 既然作为 JSTL 标签库中的一个库，要使用 fn 方法库就需要导入 JSTL 标签！要想使用 JSTL 标签库就要导入 jstl.jar 和 standard.jar 包！ 所以，要对 fn 方法库做测试，首先导入开发包（jstl.jar、standard.jar) 在 JSP 页面中指明使用标签库 12&lt;%@taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt; fn 方法库全都是跟字符串有关的（可以把它想成是 String 的方法） fn:toLowerCase fn:toUpperCase fn:trim fn:length fn:split fn:join 【接收字符数组，拼接字符串】 fn:indexOf fn:contains fn:startsWith fn:replace fn:substring fn:substringAfter fn:endsWith fn:escapeXml【忽略 XML 标记字符】 fn:substringBefore 测试代码： 1234567891011121314151617181920212223242526272829303132contains:$&#123;fn:contains(&quot;zhongfucheng&quot;,zhong )&#125;&lt;br&gt;containsIgnoreCase:$&#123;fn:containsIgnoreCase(&quot;zhongfucheng&quot;,ZHONG )&#125;&lt;br&gt;endsWith:$&#123;fn:endsWith(&quot;zhongfucheng&quot;,&quot;eng&quot; )&#125;&lt;br&gt;escapeXml:$&#123;fn:escapeXml(&quot;&lt;zhongfucheng&gt;你是谁呀&lt;/zhongfucheng&gt;&quot;)&#125;&lt;br&gt;indexOf:$&#123;fn:indexOf(&quot;zhongfucheng&quot;,&quot;g&quot; )&#125;&lt;br&gt;length:$&#123;fn:length(&quot;zhongfucheng&quot;)&#125;&lt;br&gt;replace:$&#123;fn:replace(&quot;zhongfucheng&quot;,&quot;zhong&quot; ,&quot;ou&quot; )&#125;&lt;br&gt;split:$&#123;fn:split(&quot;zhong,fu,cheng&quot;,&quot;,&quot; )&#125;&lt;br&gt;startsWith:$&#123;fn:startsWith(&quot;zhongfucheng&quot;,&quot;zho&quot; )&#125;&lt;br&gt;substring:$&#123;fn:substring(&quot;zhongfucheng&quot;,&quot;2&quot; , fn:length(&quot;zhongfucheng&quot;))&#125;&lt;br&gt;substringAfter:$&#123;fn:substringAfter(&quot;zhongfucheng&quot;,&quot;zhong&quot; )&#125;&lt;br&gt;substringBefore:$&#123;fn:substringBefore(&quot;zhongfucheng&quot;,&quot;fu&quot; )&#125;&lt;br&gt;toLowerCase:$&#123;fn:toLowerCase(&quot;zhonGFUcheng&quot;)&#125;&lt;br&gt;toUpperCase:$&#123;fn:toUpperCase(&quot;zhongFUcheng&quot;)&#125;&lt;br&gt;trim:$&#123;fn:trim(&quot; zhong fucheng &quot;)&#125;&lt;br&gt;&lt;%--将分割成的字符数组用&quot;.&quot;拼接成一个字符串--%&gt;join:$&#123;fn:join(fn:split(&quot;zhong,fu,cheng&quot;,&quot;,&quot; ),&quot;.&quot; )&#125;&lt;br&gt; 使用 fn 方法库数据回显 12345678910111213&lt;% User user = new User(); String likes[] = &#123;&quot;sing&quot;&#125;; user.setLikes(likes); //数据回显 request.setAttribute(&quot;user&quot;,user);%&gt;&lt;%--java的字符数组以&quot;,&quot;号分割开，首先拼接成一个字符串，再判读该字符串有没有包含关键字，如果有就checked--%&gt;&lt;input type=&quot;checkbox&quot;$&#123; fn:contains(fn:join(user.likes,&quot;,&quot;),&quot;sing&quot;)?&apos;checked&apos;:&apos;&apos; &#125;&gt;唱歌&lt;input type=&quot;checkbox&quot;$&#123; fn:contains(fn:join(user.likes,&quot;,&quot;),&quot;dance&quot;)?&apos;checked&apos;:&apos;&apos; &#125;&gt;跳舞 JSP 第五篇【JSTL 的介绍、core 标签库、fn 方法库、fmt 标签库】什么是 JSTLJSTL 全称为 JSP Standard Tag Library 即 JSP 标准标签库。 JSTL 作为最基本的标签库，提供了一系列的 JSP 标签，实现了基本的功能：集合的遍历、数据的输出、字符串的处理、数据的格式化等等！ 为什么要使用 JSTL EL 表达式不够完美，需要 JSTL 的支持！在 JSP 中，我们前面已经用到了 EL 表达式，体会到了 EL 表达式的强大功能：使用 EL 表达式可以很方便地引用一些 JavaBean 以及其属性，不会抛出 NullPointerException 之类的错误！但是，EL 表达式非常有限，它不能遍历集合，做逻辑的控制。这时，就需要 JSTL 的支持了！ Scriptlet 的可读性，维护性，重用性都十分差！JSTL 与 HTML 代码十分类似，遵循着 XML 标签语法，使用 JSTL 让 JSP 页面显得整洁，可读性非常好，重用性非常高，可以完成复杂的功能！ 在 JSP 中不推荐使用 scriptlet 输出，推荐使用 JSP 标签。 使用 JSTL 标签库步骤： 导入 jstl.jar 和 standard.jar 开发包 在 JSP 页面中用 tablib 指令引入需要用到的 JSTL 标签 core 标签库 core 标签库是 JSTL 的核心标签库，实现了最基本的功能：流程控制、迭代输出等操作！ core 标签库的前缀一般是 c c:out 简单使用一下 123456789&lt;% session.setAttribute(&quot;name&quot;, &quot;zhongfucheng&quot;);%&gt;//&lt;c:out/&gt;标签支持标签体，default属性上的数据可以写在标签体中//&lt;c:out value=&quot;$&#123;name&#125;&quot; escapeXml=&quot;true&quot;&gt;您要的数据找不着&lt;/c:out&gt;&lt;c:out value=&quot;$&#123;name&#125;&quot; default=&quot;您要的数据找不着&quot; escapeXml=&quot;true&quot;/&gt; 我们发现上面的代码实现的效果和 EL 表达式是一样的，它出色的地方就多了两个属性, default 和 escapeXml 属性。如果我们用到这两个属性，我们就使用该标签，如果没有用到这两个属性就用 EL 表达式就可以了。 c:set 该标签有 5 个属性，用起来有稍微有些复杂了！现在要记住的就是：var 属性操作的是 Integer、Double、Float、String 等类型的数据，target 属性操作的是 JavaBean 或 Map 对象的数据，scope 代表的是 Web 域，value 是值，property 是对象的属性！ 使用 var 属性 既然 var 属性只能操作 Integer、Double、String 等类型，那么存在 var 属性就一定没有 property 属性（property 代表的是对象的成员属性，Integer、String 这些类型哪来的成员变量呀） 下面的代码流程是这样的：创建了一个 name 的变量，设置的值为 zhongfucheng，范围是 page 1234&lt;c:set var=&quot;name&quot; value=&quot;fucheng&quot; scope=&quot;page&quot;/&gt;$&#123;name&#125; 效果： 当然了，set 标签也支持标签体，value 的值可以写在标签体里边 1234&lt;c:set var=&quot;name&quot; scope=&quot;page&quot;&gt; zhongfucheng&lt;/c:set&gt; 使用 var 属性和 scope 属性实现计数器 123456789&lt;%--由于下面变量需要做加法运算，所以要定义出来，不然服务器是不知道我的变量是Integer类型的--%&gt;&lt;% Integer sessionCount = 0; Integer applicationCount = 0;%&gt;&lt;c:set var=&quot;sessionCount&quot; value=&quot;$&#123;sessionCount+1&#125;&quot; scope=&quot;session&quot;/&gt;&lt;c:set var=&quot;applicationCount&quot; value=&quot;$&#123;applicationCount+1&#125;&quot; scope=&quot;application&quot;/&gt; 效果： 使用 target 属性 使用 target 属性与之配对的是 property 属性，target 属性只能操作 JavaBean 或 Map 对象，property 就是对应的成员变量或 key 了。。 既然 target 属性操作的是 JavaBean 或 Map 对象，那么一定是通过 EL 表达式来获取到对象了。taget 属性如果获取不到数据会抛出异常！使用 target 属性就一定没有 scope 属性（scope 属性代表的是保存范围，target 的值都是获取来的，难道你还能改变人家的范围？） 12345678&lt;%--创建出JavaBean对象，设置为session范围的属性--%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;session&quot;/&gt;&lt;%--获取到person对象，设置age属性的值为32--%&gt;&lt;c:set target=&quot;$&#123;person&#125;&quot; property=&quot;age&quot; value=&quot;32&quot;/&gt;$&#123;person.age&#125; 效果： c:removeremove 标签就相当简单了，只有 var 和 scope 属性，代表的是删除域范围的属性 下面简单来测试一下吧： 12345678910111213&lt;%--创建出JavaBean对象，设置为session范围的属性--%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;session&quot;/&gt;&lt;%--获取到person对象，设置age属性的值为32--%&gt;&lt;c:set target=&quot;$&#123;person&#125;&quot; property=&quot;age&quot; value=&quot;32&quot;/&gt;$&#123;person.age&#125;&lt;br&gt;&lt;%--删除session属性--%&gt;&lt;c:remove var=&quot;person&quot; scope=&quot;session&quot;&gt;&lt;/c:remove&gt;$&#123;person.age==null?&quot;存在session的person对象被删除了！&quot;:&quot;我还在呢！&quot;&#125; 效果： c:catch该标签主要用来处理程序中产生的异常。 catch 标签也十分简单，只有一个 var 属性，var 属性封装了异常的信息！ 123456789101112&lt;%--创建出JavaBean对象，设置为session范围的属性--%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;session&quot;/&gt;&lt;c:catch var=&quot;message&quot;&gt; &lt;%--target属性只能是EL表达式，现在我是字符串，获取不到对象，肯定会抛出异常的！--%&gt; &lt;c:set target=&quot;person&quot; property=&quot;age&quot; value=&quot;32&quot;/&gt;&lt;/c:catch&gt;$&#123;message&#125; 效果： c:if JSTL 提供了 if 标签完成分支语句的实现，test 属性是不可或缺的。 var 和 scope 属性我看来好像没什么用的（保存执行结果有什么用？） 根据传递过来的参数的不同显示不同的页面！ 1234567891011121314&lt;%--如果带过来的名字是zhongfucheng，那么可以登陆--%&gt;&lt;c:if test=&quot;$&#123;param.name==&apos;zhongfucheng&apos;&#125;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;&lt;/c:if&gt;&lt;%--如果带过来的名字是ouzicheng，那么就是注册--%&gt;&lt;c:if test=&quot;$&#123;param.name==&apos;ouzicheng&apos;&#125;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/c:if&gt; 注意地址栏的参数！ c:chooseif 标签没有 else 的功能，如果需要类似于 java 中的 if else 流程就需要使用 choose 标签。 choose 标签需要联合 when 和 otherwise 标签一起使用！ 123456789101112&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;param.name==&apos;zhongfucheng&apos;&#125;&quot;&gt; 你好啊，zhongfucheng &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.name==&apos;ouzicheng&apos;&#125;&quot;&gt; 你好啊，ouzicheng &lt;/c:when&gt; &lt;c:otherwise&gt; 你是谁啊？别随便过来！ &lt;/c:otherwise&gt;&lt;/c:choose&gt; 效果： c:forEach forEach 为循环标签，相当于 Java 中的 while 和 for 之前我们在使用 EL 表达式获取到集合的数据，遍历集合都是用 scriptlet 代码循环，现在我们学了 forEach 标签就可以舍弃 scriptlet 代码了。 向 Session 中设置属性，属性的类型是 List 集合 123456789&lt;% List list = new ArrayList&lt;&gt;(); list.add(&quot;zhongfucheng&quot;); list.add(&quot;ouzicheng&quot;); list.add(&quot;xiaoming&quot;); session.setAttribute(&quot;list&quot;, list);%&gt; 遍历 session 属性中的 List 集合, items：即将要迭代的集合。var：当前迭代到的元素 1234&lt;c:forEach var=&quot;list&quot; items=&quot;$&#123;list&#125;&quot; &gt; $&#123;list&#125;&lt;br&gt;&lt;/c:forEach&gt; 效果： 遍历 Map 对象有稍微地不一样，我们来看一下，var 属性保存的不是每个迭代的对象，而是 Map.Entry。 123456789101112131415&lt;% Map map = new HashMap(); map.put(&quot;1&quot;, &quot;zhongfucheng&quot;); map.put(&quot;2&quot;, &quot;xiaohong&quot;); map.put(&quot;3&quot;, &quot;xiaoming&quot;); session.setAttribute(&quot;map&quot;,map);%&gt;&lt;c:forEach var=&quot;me&quot; items=&quot;$&#123;map&#125;&quot; &gt; $&#123;me.key&#125; $&#123;me.value&#125;&lt;br&gt;&lt;/c:forEach&gt; begin 默认从 0 开始、end 默认为集合的最后一个元素、step 默认为 1 varStatus 代表着当前对象被迭代的信息，它有以下的属性。 index【返回当前是第几个对象，从 0 开始计数】 count【已经遍历多少个对象了，从 1 开始计数】 first【是否是第一个】 last【是否是最后一个】 current【当前被迭代的对象】 begin【开始的位置】 end【最后的位置】 step【步长】 123456&lt;c:forEach var=&quot;list&quot; items=&quot;$&#123;list&#125;&quot; varStatus=&quot;varStatus&quot; &gt; $&#123;list&#125;您的下标是:$&#123;varStatus.index&#125;&lt;br&gt;&lt;/c:forEach&gt; 效果： c:forTokens该标签类似于 String 类的 split() 和 for 循环的一种集合 它与 forEach 标签非常相似，都有 begin、end、step、items、var、varStatus 属性，不同的是 forTokens 标签的 items 属性里面是字符串，这个字符串会被 delims 属性的内容分割成多个字符串！ 1234&lt;c:forTokens items=&quot;zhongfucheng,ouzicheng,xiaoming,xiaohong&quot; var=&quot;name&quot; delims=&quot;,&quot; &gt; $&#123;name&#125;&lt;/c:forTokens&gt; 效果图： c:importimport 标签类似于 JSP 行为&lt;jsp:include/&gt;和 JSP 指令&lt;%include&gt; import 标签的属性： url【指定要包含的路径，Internet 所有的 url 都可以】 context【访问同一个 web 容器的其他资源，以 “/“ 开头】 var【保存导入的文件的内容，以 String 类型存储】 socpe【保存的范围，默认是 page】 charEncoding【字符编码】 varReader【保存导入文件的内容，以 Reader 类型存储】 当然了，import 标签功能更加更大！强大在哪里呢？import 标签可以引入 Internet 网页上的内容，也就是说，csdn 也可以引入进来！ 我们来用一下把！ 12&lt;c:import url=&quot;http://www.csdn.net&quot; charEncoding=&quot;UTF-8&quot; /&gt; 我们一看，是没有样式的： 打印 csdn 的源代码： 12345&lt;c:import url=&quot;http://www.csdn.net&quot; charEncoding=&quot;UTF-8&quot; var=&quot;net&quot;/&gt;CSDN的源码是：&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;c:out value=&quot;$&#123;net&#125;&quot; escapeXml=&quot;true&quot;&gt;&lt;/c:out&gt; 效果： c:param 在 JSP 页面进行 URL 的相关操作时，经常要在 URL 地址后面附加一些参数。 c:urlurl 标签十分实用！在浏览器禁用 Cookie 的时候，我们之前学 Servlet 时解决办法是：response.encodeURL()。url 标签也可以实现这样的功能，再配合 param 标签使用，就十分实用了！ 我们配合 param 标签来使用一下吧！ 1234567&lt;c:url value=&quot;2.jsp&quot; var=&quot;url&quot;&gt; &lt;c:param 中国！&quot;&gt; &lt;/c:param&gt;&lt;/c:url&gt;&lt;a href=&quot;$&#123;url&#125;&quot;&gt;我经过了URL地址重写！&lt;/a&gt; 效果： c:redirectredirect 标签用于实现 Redirect 功能，当然了，此标签也能够配合 param 标签使用！ 简单使用一下，重定向到 2.jsp，带了一个参数： 12345&lt;c:redirect url=&quot;2.jsp&quot; &gt; &lt;c:param &gt; &lt;/c:param&gt;&lt;/c:redirect&gt; 在 2.jsp 中获取到参数 fmt 标签库fmt 标签库也叫做国际化标签库。这里就不详细说明了，等我讲到 Web 国际化的时候才讲吧！ fn 方法库fn 方法库也叫做 EL 函数库、fn 标签库。这个在讲解 EL 表达式的时候有详细的说明，可转移到我 EL 表达式的博文中！ JSP第六篇【自定义标签之传统标签】为什么要使用自定义标签？JSTL 标签库只提供了简单的输出等功能，没有实现任何的 HTML 代码封装，并且某些复杂类型转换，或者逻辑处理的时候，JSTL 标签库完成不了，需要自定义标签! 编写自定义标签的步骤： 编写一个实现 Tag 接口的 Java 类【标签处理器类】 在 WEB-INF 目录下创建 tld(Tag Library Descriptor) 文件，在 tld 文件中对标签处理类（实现 Tag 接口的 Java 类）进行描述 快速入门 目标：使用标签输出客户机的 IP 地址！ 按照步骤来：首先编写一个实现 Tag 接口的 Java 类 123456789101112131415161718192021222324252627282930313233public class showIp implements Tag &#123; @Override public void setPageContext(PageContext pageContext) &#123; &#125; @Override public void setParent(Tag tag) &#123; &#125; @Override public Tag getParent() &#123; return null; &#125; @Override public int doStartTag() throws JspException &#123; return 0; &#125; @Override public int doEndTag() throws JspException &#123; return 0; &#125; @Override public void release() &#123; &#125;&#125; 既然要获取到客户机的 IP 地址，那么 request 对象是必不可少的。现在问题来了，在 Tag 重写的方法好像不能直接获取到 request 对象啊。 经过我一番仔细的观察，发现了下面这个方法： 1234@Overridepublic void setPageContext(PageContext pageContext) &#123;&#125; 既然能获取到 pageContext 对象，那么其他 8 大内置对象还不是随随便便？于是乎，我就定义一个成员变量 pageContext，在 setPageContext() 方法中传递过来的 pageContext 赋值给我定义的成员变量即可！ 1234567private PageContext pageContext = null;@Overridepublic void setPageContext(PageContext pageContext) &#123; this.pageContext = pageContext;&#125; 好的，看回我们的需求：使用标签输出客户机的 IP 地址。在上面剩余 5 个方法中，最有可能就是在 doStartTag() 方法中编写代码！ 12345678910111213141516171819202122@Overridepublic int doStartTag() throws JspException &#123; //获取到request对象 HttpServletRequest httpServletRequest = (HttpServletRequest) pageContext.getRequest(); //获取到客户机的ip地址 String ip = httpServletRequest.getRemoteAddr(); //获取输出到浏览器的对象 JspWriter jspWriter = pageContext.getOut(); //下面的异常只能捕获，因为子类的异常不能比父类多 try &#123; jspWriter.write(ip); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return 0;&#125; 接着，编写tld文件，描述实现 Tag 接口的 Java 类【标签处理类】。 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot; version=&quot;2.1&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;zhongfucheng&lt;/short-name&gt; &lt;uri&gt;/zhongfucheng&lt;/uri&gt; &lt;!-- Invoke &apos;Generate&apos; action to add tags or functions --&gt; &lt;tag&gt; &lt;name&gt;viewIp&lt;/name&gt; &lt;tag-class&gt;tag.showIp&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 下面我们来测试一下看能不能用 标签处理类详细说明看完上面的程序，大部分人都是懵逼的。因为还不知道它具体是怎么用的，调用顺序是什么。 首先我们来看一下 Tag 接口的源码！ 12345678910111213141516171819public interface Tag extends JspTag &#123; int SKIP_BODY = 0; int EVAL_BODY_INCLUDE = 1; int SKIP_PAGE = 5; int EVAL_PAGE = 6; void setPageContext(PageContext var1); void setParent(Tag var1); Tag getParent(); int doStartTag() throws JspException; int doEndTag() throws JspException; void release();&#125; 上面程序的执行流程： JSP 引擎遇到自定义标签，首先创建标签处理器类的实例对象。 JSP 引擎实例化完标签处理器类后，调用 setPageContext() 方法，将 pageContext 对象传递给标签处理器类，使得标签处理器类可以通过 pageContext 对象与 JSP 页面进行通信！ setPageContext() 方法执行完后，调用 setParent() 方法，将当前标签的父标签传递给当前处理器类，如果当前标签没有父标签，则传入 null 当 WEB 容器执行到自定义标签的开始标记时，调用 doStartTag() 方法。 当 WEB 容器执行到自定义标签的结束标记时，调用 doEndTag() 方法。 一般来说，当 WEB 容器执行完自定义标签后，标签处理器类会驻留在内存中，直至停止 WEB 应用时，WEB 容器才会调用 release() 方法 我们现在已经清楚了方法的执行顺序了，可 Tag 接口的源码还有 4 个变量阿，它们是用来做什么的呢？我们在编写 JSP 页面时，经常需要在页面中引入一些逻辑，例如： 控制 JSP 页面某一部分（标签体）是否执行 控制整个 JSP 页面是否执行 控制 JSP 页面内容重复执行 修改 JSP 页面内容输出 再看回 4 个变量的名字，我们可以发现，这 4 个变量就是用来做逻辑判断的！ 我们来测试一下吧，在 doEndTag() 方法中，返回的是 SKIP_PAGE 变量，看下会怎么样！ 12345@Overridepublic int doEndTag() throws JspException &#123; return SKIP_PAGE;&#125; 我们再来看一看效果： 好像是没什么区别！我们再查看一下源代码，发现执行完标签后，后面的代码全都没有执行！ doStartTag() 方法使用的是 SKIP_BODY 和 EVAL_BODY_INCLUDE 这两个变量，判断是否执行标签体的内容。 doEndTag() 方法使用的是 SKIP_PAGE 和 EVAL_PAGE 这两个变量，判断是否执行剩下页面的内容 控制 JSP 页面内容重复执行和修改 JSP 页面内容输出后面会有！ tld 文件详细说明 首先我们来看一下 tld 文件当前用到的内容吧！ 12345678910&lt;tlib-version&gt;1.0&lt;/tlib-version&gt;&lt;short-name&gt;myshortname&lt;/short-name&gt;&lt;uri&gt;http://mycompany.com&lt;/uri&gt;&lt;tag&gt; &lt;name&gt;&lt;/name&gt; &lt;tag-class&gt;&lt;/tag-class&gt; &lt;body-content&gt;&lt;/body-content&gt;&lt;/tag&gt; 我们一个一个来看： shortname 推荐使用 prefix uri 就是引入这个标签库使用的 uri name 为标签名 tagclass 为实现类 bodycontent 为标签体的限制，它有 4 个值： EMPTY【不允许有标签体】，JSP【允许有 JSP 代码】 ，scriptless【不允许有脚本代码（也就是 &lt;%%&gt;），允许有 EL 表达式，文本，JSP 行为】 ， tagdepentend【标签体内的 JSP 代码不会被解析，直接输出文本】 TagSupport 类大部分时候我们都不需要实现 Tag 接口来编写自定义标签，TagSupport 是 Tag 的一个模板类，实现了 pageContext，parent 的 getter、setter 方法以及一些其他的功能。我们要做的就是重写 doStartTag() 和 doEndTag() 方法 下面我们就来简单使用一下吧： 继承 TagSupport 类，重写 doStartTag() 方法，比直接实现 Tag 接口简洁很多！ 12345678910111213141516171819202122public class Demo1 extends TagSupport &#123; @Override public int doStartTag() throws JspException &#123; //获取到request对象 HttpServletRequest httpServletRequest = (HttpServletRequest) pageContext.getRequest(); String method = httpServletRequest.getMethod(); JspWriter jspWriter = pageContext.getOut(); try &#123; jspWriter.write(method); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return 0; &#125;&#125; 在 tld 文件中描述一把： 123456&lt;tag&gt; &lt;name&gt;showMethod&lt;/name&gt; &lt;tag-class&gt;tag.Demo1&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt;&lt;/tag&gt; 效果： 带属性的标签上面我们编写的自定义标签都没有附带属性的，我们在使用 core 标签库的时候，标签一般都带有属性。 其实 JSTL 标签库的原理就是自定义标签，把自定义标签搞明白了，对 JSTL 标签库的使用就有更好的理解了！ 想要自定义标签带有属性也非常简单，只要在标签处理器类上加一个成员变量和 setter、getter()，再在 tld 文件中描述下该属性即可！它的原理是这样的：当标签使用到属性的时候，引擎就会调用它的 setter() 方法 下面我想要完成的功能是：使用标签的人，传入一个字符串格式就可以显示想要的格式日期 编写标签处理器类，增加一个成员变量以及对应的 setter、getter 方法 123456789101112131415161718192021222324252627282930public class Demo1 extends TagSupport &#123; //创建成员对象，对应的setter、getter方法 private String format = null; @Override public int doStartTag() throws JspException &#123; //创建日期格式化对象 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format); //格式化日期并向浏览器输出 try &#123; pageContext.getOut().write(simpleDateFormat.format(new Date())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return 0; &#125; public String getFormat() &#123; return format; &#125; public void setFormat(String format) &#123; this.format = format; &#125;&#125; 在 tld 文件中描述标签和属性，name 代表的是属性的名字，required 代表的是是否为必须，rtexprvalue 代表能否使用 EL 表达式 1234567891011&lt;tag&gt; &lt;name&gt;formatDate&lt;/name&gt; &lt;tag-class&gt;tag.Demo1&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;format&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt;&lt;/tag&gt; 我们来看一下效果： 标签的继承关系 在深入讲解之前，我们先来看一下各种 Tag 接口、类之间的关系，这样学习下去才不会晕！ IterationTag 说明 我们已经使用过了 Tag 接口和 TagSupport 类了。接下来我们看一下 IterationTag 是什么玩意。 123456public interface IterationTag extends Tag &#123; int EVAL_BODY_AGAIN = 2; int doAfterBody() throws JspException;&#125; 从关系图我们也可以看出，IterationTag 接口实现了 Tag 接口，InterationTag 接口和 Tag 接口最主要的区别就是多了个 doAfterBody() 方法和 EVAL_BODY_AGAIN 变量 理解起来也很简单：当 doAfterBody() 返回的是 EVAL_BODY_AGAIN 变量，那么标签体的内容就一直循环！当然了，TagSupport 也实现了 Iteration 接口，也就是说 TagSupport 类也能完成 Iteration 接口的事情！ 我们来使用一下吧： 123456789101112131415161718192021222324public class Demo1 extends TagSupport &#123; @Override public int doStartTag() throws JspException &#123; try &#123; pageContext.getOut().write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //执行标签体 return EVAL_BODY_INCLUDE; &#125; @Override public int doAfterBody() throws JspException &#123; //标签体不断循环，直到doAfterBody()返回的是SKIP_BODY return EVAL_BODY_AGAIN; &#125;&#125; tld 文件中描述，既然标签体有内容，就不能用 empty 了！ 123456&lt;tag&gt; &lt;name&gt;foreverEval&lt;/name&gt; &lt;tag-class&gt;tag.Demo1&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt;&lt;/tag&gt; 注意看横向的滑轮，已经死循环输出了： doAfterBody() 中只要返回的是 SKPI_BODY 就退出循环，执行 doEndTag() 方法 1234567891011121314151617181920212223242526272829//定义一个变量，规定标签体循环的次数int x = 0;@Overridepublic int doStartTag() throws JspException &#123; try &#123; pageContext.getOut().write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //执行标签体 return EVAL_BODY_INCLUDE;&#125;@Overridepublic int doAfterBody() throws JspException &#123; x++; if (x &gt;= 10) &#123; return SKIP_BODY; &#125; //标签体不断循环，直到doAfterBody()返回的是SKIP_BODY return EVAL_BODY_AGAIN;&#125; 现在我们已经能控制循环的次数了！ BodyTag 说明前面我们已经使用到了带标签体的自定义标签了，前面的都是只能直接输出而得不到标签体的内容，既然得不到标签体的内容，就更别说修改标签体了！ 此时，我们就需要 BodyTag 接口的支持了！它专门用来处理带标签体的标签，下面我们来看一下 BodyTag 的源码！ 1234567891011public interface BodyTag extends IterationTag &#123; /** @deprecated */ int EVAL_BODY_TAG = 2; int EVAL_BODY_BUFFERED = 2; void setBodyContent(BodyContent var1); void doInitBody() throws JspException;&#125; BodyTag 多了 EVAL_BODY_BUFFERED 变量【一个已经标识过时了】，多了 setBodyContent 和 doInitBody() 两个方法 其实使用 BodyTag 十分简单 如果 doStartTag() 方法返回的是 EVAL_BODY_BUFFERED，把标签体的内容缓存起来 接着调用 setBodyContent() 方法和 doInitBody() 方法，封装标签体的内容到 BodyContent 对象中 接着调用 doEndTag() 方法 对于标签体的内容，我们可以通过 getBodyContenet() 来获取！ 再看回上面的关系图，BodyTag 实现了 IterationTag 和 Tag 接口，如果直接实现 BodyTag 接口做开发，要实现的方法就太多了。一般我们使用继承 BodyTag 的 BodyTagSupport 来做开发 BodyTagSupport 说明 首先来看一下源代码吧： 123456789101112131415161718192021222324252627282930313233343536373839public class BodyTagSupport extends TagSupport implements BodyTag &#123; protected BodyContent bodyContent; public BodyTagSupport() &#123; &#125; public int doStartTag() throws JspException &#123; return 2; &#125; public int doEndTag() throws JspException &#123; return super.doEndTag(); &#125; public void setBodyContent(BodyContent b) &#123; this.bodyContent = b; &#125; public void doInitBody() throws JspException &#123; &#125; public int doAfterBody() throws JspException &#123; return 0; &#125; public void release() &#123; this.bodyContent = null; super.release(); &#125; public BodyContent getBodyContent() &#123; return this.bodyContent; &#125; public JspWriter getPreviousOut() &#123; return this.bodyContent.getEnclosingWriter(); &#125;&#125; 可以发现:BodyTagSupport 主要扩充了以下的内容: 把 BodyContent 直接定义为成员变量，在获取标签体内容的时候就不需要通过 getBodyContent() 获取了 提供获取 JspWriter 的方法，不需要从 pageConext 中获取了 以上的两个扩充都简化了我们的代码书写！ 123456protected BodyContent bodyContent;public JspWriter getPreviousOut() &#123; return this.bodyContent.getEnclosingWriter();&#125; 从 BodyTag 接口中，我就说到了：标签体的内容封装到了 BodyContent 类中，那么 BodyContent 类究竟是什么？我们来看一下源码： 12345678910111213141516171819202122232425262728293031public abstract class BodyContent extends JspWriter &#123; private JspWriter enclosingWriter; protected BodyContent(JspWriter e) &#123; super(-2, false); this.enclosingWriter = e; &#125; public void flush() throws IOException &#123; throw new IOException(&quot;Illegal to flush within a custom tag&quot;); &#125; public void clearBody() &#123; try &#123; this.clear(); &#125; catch (IOException var2) &#123; throw new Error(&quot;internal error!;&quot;); &#125; &#125; public abstract Reader getReader(); public abstract String getString(); public abstract void writeOut(Writer var1) throws IOException; public JspWriter getEnclosingWriter() &#123; return this.enclosingWriter; &#125;&#125; 原来 BodyContent 继承着 JspWriter，它与 JspWriter 最大的区别是：BodyContent 类的任何写入的内容并不自动地向页面输出！ 我们一般使用 BodyContent 都使用两个方法： 123456//将数据转变成Reader对象public abstract Reader getReader();//将数据转变成String对象public abstract String getString(); 再从关系图我们可以看初，BodyTagSupport 继承了 TagSupport 类实现了 BodyTag 接口，可以说：BodyTagSupport 有着前面讲的接口和类的所有功能！。 下面我们来使用下 BodyTagSupport 将标签体的内容转成是小写的： 标签处理器类 1234567891011121314151617181920212223242526272829public class Demo1 extends BodyTagSupport &#123; @Override public int doStartTag() throws JspException &#123; //想要获取到标签体的内容，就要返回EVAL_BODY_BUFFERED变量 return EVAL_BODY_BUFFERED; &#125; @Override public int doEndTag() throws JspException &#123; //获取到标签体的内容 String value = bodyContent.getString(); //将标签体的内容转成小写并输出 try &#123; this.getPreviousOut().write(value.toLowerCase()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.doEndTag(); &#125;&#125; tld 文件： 123456&lt;tag&gt; &lt;name&gt;BodyContentToLowerCase&lt;/name&gt; &lt;tag-class&gt;tag.Demo1&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt;&lt;/tag&gt; 效果： 参考：Servlet+JSP - 文集 - 简书https://www.jianshu.com/nb/21926044]]></content>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat bio nio apr 模式性能测试]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-3%2F</url>
    <content type="text"><![CDATA[11.11 活动当天，服务器负载过大，导致部分页面出现了不可访问的状态、那后来主管就要求调优了，下面是 tomcat bio、nio、apr 模式以及后来自己测试的一些性能结果。 原理方面的资料都是从网上找的，并且把多个地方的整理到了一起，觉得很有意义。（后面对 tomcat 默认页面测试的数据是自己测出来的），tomcat 的三种模式如果用对了场合，性能绝对有大幅度的提升。当然调优也并不只在这一个方面，还有内存（堆内存、非堆内存、新生代内存）以及线程（最大线程、请求队列、备用线程、压缩、以及禁用 dns 轮询）等方面。 那在做 tomcat bio nio apr 模式之前，先来了解下 java 的一些特性吧。 Java BIO、NIO、AIO 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 IO 时，Java 自己处理 IO 读写）。 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步 IO 时，Java 将 IO 读写委托给 OS 处理，需要将数据缓冲区地址和大小传给 OS(银行卡和密码)，OS 需要支持异步 IO 操作 API）。 阻塞 ： ATM 排队取款，你只能等待（使用阻塞 IO 时，Java 调用会一直阻塞到读写完成才返回）。 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞 IO 时，如果不能读写 Java 调用会马上返回，当 IO 事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。 Java 对 BIO、NIO、AIO 的支持： Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。 Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理 BIO、NIO、AIO 适用场景分析: BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。 NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。 AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。 好，下面来看看 tomcat 的 bio、nio、apr 模式 biobio(blocking I/O)，顾名思义，即阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作 (即 java.io 包及其子包)。Tomcat 在默认情况下，就是以 bio 模式运行的。遗憾的是，就一般而言，bio 模式是三种运行模式中性能最低的一种。我们可以通过 Tomcat Manager 来查看服务器的当前状态。 nio是 Java SE 1.4 及后续版本提供的一种新的 I/O 操作方式 (即 java.nio 包及其子包)。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API，因此 nio 也被看成是 non-blocking I/O 的缩写。它拥有比传统 I/O 操作(bio) 更好的并发运行性能。 apr(Apache Portable Runtime/Apache 可移植运行库)，是 Apache HTTP 服务器的支持库。你可以简单地理解为，Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高 Tomcat 对静态文件的处理性能。 Tomcat apr 也是在 Tomcat 上运行高并发应用的首选模式。 在这之前，我们先把 tomcat 管理界面配置起来，以便等下能更方便的观察我们的 bio、nio、apr 模式 添加 manager/status 用户 123vim /usr/local/apache-tomcat-7.0.47/conf/tomcat-users.xml&lt;role role/&gt; &lt;user user/&gt; 配置完重启，通过 ip:port/manager/status 就可以看 tomcat 状态了，里面有服务器的信息及 tomcat 信息。 bio server.xml 配置 （重启生效） 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; nio server.xml 配置 （重启生效） 123&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; apr server.xml 配置 （重启生效） 123&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 当然，apr 模式还需要安装 apr 、 apr-utils 、tomcat-native 包 123456789101112131415apr 安装tar zxf apr-1.5.2.tar.gz -C /usr/local/src/cd /usr/local/src/apr-1.5.2/./configure --prefix=/usr/local/apr &amp;&amp; make &amp;&amp; make installapr-utils 安装tar zxf apr-util-1.5.4.tar.gz -C /usr/local/src/cd /usr/local/src/apr-util-1.5.4/./configure --with-apr=/usr/local/apr/ --prefix=/usr/local/apr-utils &amp;&amp; make &amp;&amp; make install tomcat-native安装cd /usr/local/apache-tomcat-7.0.65/bin/tar zxf tomcat-native.tar.gz cd tomcat-native-1.1.33-src/jni/native./configure --with-apr=/usr/local/apr --with-java-home=/usr/local/java/ &amp;&amp; make &amp;&amp; make install 安装完后记得在 /etc/profile 的 JAVA 变量后面多加一条 APR 的环境变量 设置环境变量 123456JAVA_HOME=/usr/local/javaJAVA_BIN=$JAVA_HOME/binPATH=$PATH:$JAVA_BINCLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME JAVA_BIN PATH CLASSPATHexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/lib source /etc/profile 那下面来看看 apr 的页面 到这里大致的配置就结束了，建议在做实验之前，先了解清楚 java 的 bio 、nio 、aio 特性，在 web 服务器上阻塞 IO(BIO)与 NIO 一个比较重要的不同是，客户系统使用 BIO 的时候往往会为每一个 web 请求引入多线程，每个 web 请求一个单独的线程，所以并发量一旦上去了，线程数就上去了，CPU 就忙着线程切换，所以 BIO 不合适高吞吐量、高可伸缩的 web 服务器；而 NIO 则是使用单线程 (单个 CPU) 或者只使用少量的多线程 (多 CPU) 来接受 Socket，而由线程池来处理堵塞在 pipe 或者队列里的请求. 这样的话，只要 OS 可以接受 TCP 的连接，web 服务器就可以处理该请求。大大提高了 web 服务器的可伸缩性。 下面是我自己的一些性能测试表格，通过 jmeter 压测软件（jmeter 软件使用自行百度）在本地测试的（为了数据的有效以及准确性，我没测试 10 分钟，也就是进行一次测试，都会重启 linux 主机及重新打开 jmeter 软件。），当然你也可以选择通过 云主机、自己机房的服务器以及虚拟机等测试，测试当中会涉及到很多点，例如（磁盘 io、带宽、内存、cpu、以及内核配置中的 tcp 各种状态，甚至是各种打开文件限制，都会影响到我们的测试结果） 可以看到，随着线程的不断增多，bio 模式性能越来越差，就算是在本地，错误率和响应时间都在明显的增加、而吞吐量、样本数和每秒传输速率都在下降（当然，如果是生产环境，我们肯定通过 nginx web 软件进行反向代理，提供多个 tomcat 节点来提供更稳定的服务。） 而 bio 和 apr 模式基本上没有变化太多，都保持在一个稳定的状态。 而后来当我进行一些 service 后端程序的测试时，发现 tomcat 性能并没有大幅度的提升，甚至会有下降的趋势。（该接口不是在同网段测试，而是跨越路由器，在网络传输中会有损耗方面，性能跟本地测试也会有所差异） 总结：个人觉得在 tomcat bio、nio、apr 模式中，每种都会有各自适用的场合，也不能说哪个好那个不好，就像 tomcat 内存方面的配置，如果内存设置的过大，gc 垃圾回收机制就会变慢；如果内存设置的过小，tomcat 又会出现内存溢出的情况，所以设置在一个合适的范围很重要，不仅不会出错，并且 gc 回收频繁使性能达到一个最优的结果。当然，这也需要根据不同的场合进行不同的测试才能产生最优的结果！ 参考：tomcat bio nio apr 模式性能测试与个人看法 - CSDN博客https://blog.csdn.net/wanglei_storage/article/details/50225779]]></content>
      <tags>
        <tag>Java</tag>
        <tag>tomcat</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中BIO,NIO,AIO的理解]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-2%2F</url>
    <content type="text"><![CDATA[Java 中 BIO,NIO,AIO 的理解 在高性能的 IO 体系设计中，有几个名词概念常常会使我们感到迷惑不解。具体如下： 1 什么是同步？2 什么是异步？3 什么是阻塞？4 什么是非阻塞？5 什么是同步阻塞？6 什么是同步非阻塞？7 什么是异步阻塞？ 8 什么是异步非阻塞？ 先来举个实例生活中的例子： 如果你想吃一份宫保鸡丁盖饭： 同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！ 同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ 异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。 在弄清楚上面的几个问题之前，我们首先得明白什么是同步，异步，阻塞，非阻塞，只有这几个单个概念理解清楚了，然后在组合理解起来，就相对比较容易了。 1, 同步和异步是针对应用程序和内核的交互而言的。 2, 阻塞和非阻塞是针对于进程在访问数据的时候，根据 strong textIO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。 由上描述基本可以总结一句简短的话，同步和异步是目的，阻塞和非阻塞是实现方式。 1. 同步：指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪。自己上街买衣服，自己亲自干这件事，别的事干不了。2. 异步：异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知（异步的特点就是通知） 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步 IO 时，Java 将 IO 读写委托给 OS 处理，需要将数据缓冲区地址和大小传给 OS）3. 阻塞：所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读, 或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止 去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。）4. 非阻塞：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待， 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。 一个 IO 操作其实分成了两个步骤：发起 IO 请求和实际的 IO 操作。 同步 IO 和异步 IO 的区别就在于第二个步骤是否阻塞，如果实际的 IO 读写阻塞请求进程，那么就是同步 IO。阻塞 IO 和非阻塞 IO 的区别在于第一步，发起 IO 请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞 IO，如果不阻塞，那么就是非阻塞 IO。 同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪，而异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。所以, IO 操作可以分为 3 类：同步阻塞（即早期的 BIO 操作）、同步非阻塞（NIO）、异步非阻塞（AIO）。 同步阻塞 (BIO)：在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。JAVA 传统的 IO 模型属于此种方式。同步非阻塞 (NIO)：在此种方式下，用户进程发起一个 IO 操作以后便可返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO。异步非阻塞 (AIO)： 此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序。 同步阻塞 IO（JAVA BIO）： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 同步非阻塞 IO(Java NIO)：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。用户进程也需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问。 异步阻塞 IO（Java NIO）： 此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄（如果从 UNP 的角度看，select 属于同步操作。因为 select 之后，进程还需要读写数据），从而提高系统的并发性！ （Java AIO(NIO.2)）异步非阻塞 IO: 在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 读取或者写入操作已经由内核完成了。 BIO、NIO、AIO 适用场景分析: BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。 NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。 AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。 参考：Java中BIO,NIO,AIO的理解 - CSDN博客https://blog.csdn.net/itismelzp/article/details/50886009]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-1%2F</url>
    <content type="text"><![CDATA[Servlet第一篇【介绍Servlet、HTTP协议、WEB目录结构、编写入门Servlet程序、Servlet生命周期】什么是 Serlvet？Servlet 其实就是一个遵循 Servlet 开发的 java 类。Serlvet 是由服务器调用的，运行在服务器端。 为什么要用到 Serlvet？我们编写 java 程序想要在网上实现 聊天、发帖、这样一些的交互功能，普通的 java 技术是非常难完成的。sun 公司就提供了 Serlvet 这种技术供我们使用。 HTTP 协议什么是 HTPP 协议 超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。它是 TCP/IP 协议的一个应用层协议 简单来说，HTTP 协议就是客户端和服务器交互的一种通迅的格式。 例子: 在浏览器点击一个链接，浏览器就为我打开这个链接的网页。 原理：当在浏览器中点击这个链接的时候，浏览器会向服务器发送一段文本，告诉服务器请求打开的是哪一个网页。服务器收到请求后，就返回一段文本给浏览器，浏览器会将该文本解析，然后显示出来。这段文本就是遵循 HTTP 协议规范的。 HTTP1.0 和 HTTP1.1 的区别HTTP1.0 协议中，客户端与 web 服务器建立连接后，只能获得一个 web 资源【短连接，获取资源后就断开连接】 HTTP1.1 协议，允许客户端与 web 服务器建立连接后，在一个连接上获取多个 web 资源【保持连接】 HTTP 请求浏览器向服务器请求某个 web 资源时，称之为浏览器向服务器发送了一个 http 请求。 一个完整 http 请求应该包含三个部分： 请求行【描述客户端的请求方式、请求的资源名称，以及使用的 HTTP 协议版本号】 多个消息头【描述客户端请求哪台主机，以及客户端的一些环境信息等】 一个空行 请求行请求行：GET /java.html HTTP/1.1 请求行中的 GET 称之为请求方式，请求方式有：POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT。 常用的有：POST,GET 一般来说，当我们点击超链接，通过地址栏访问都是 get 请求方式。通过表单提交的数据一般是 post 方式。 可以简单理解 GET 方式用来查询数据,POST 方式用来提交数据，get 的提交速度比 post 快 GET 方式：在 URL 地址后附带的参数是有限制的，其数据容量通常不能超过 1K。 POST 方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。 请求头 Accept: text/html,image/* 【浏览器告诉服务器，它支持的数据类型】 Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它支持哪种字符集】 Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的压缩格式】 Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】 Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】 If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】 Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的 — 反盗链】 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】 Cookie【浏览器告诉服务器，带来的 Cookie 是什么】 Connection: close/Keep-Alive 【浏览器告诉服务器，请求完后是断开链接还是保持链接】 Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】 HTTP 响应一个 HTTP 响应代表着服务器向浏览器回送数据 一个完整的 HTTP 响应应该包含四个部分: 一个状态行【用于描述服务器对请求的处理结果。】 多个消息头【用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据】 一个空行 实体内容【服务器向客户端回送的数据】 状态行格式： HTTP 版本号 状态码 原因叙述 状态行：HTTP/1.1 200 OK 状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为 5 类 响应头 Location: http://www.it315.org/index.jsp 【服务器告诉浏览器要跳转到哪个页面】 Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】 Content-Encoding: gzip 【服务器告诉浏览器数据压缩的格式】 Content-Length: 80 【服务器告诉浏览器回送数据的长度】 Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】 Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，回送数据的类型】 Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】 Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要定时刷新】 Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器以下载方式打开数据】 Transfer-Encoding: chunked 【服务器告诉浏览器数据以分块方式回送】 Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要保存 Cookie】 Expires: -1【服务器告诉浏览器不要设置缓存】 Cache-Control: no-cache 【服务器告诉浏览器不要设置缓存】 Pragma: no-cache 【服务器告诉浏览器不要设置缓存】 Connection: close/Keep-Alive 【服务器告诉浏览器连接方式】 Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】 Servlet 的作用Servlet 带给我们最大的作用就是能够处理浏览器带来 HTTP 请求，并返回一个响应给浏览器，从而实现浏览器和服务器的交互。 JAVAWEB 目录结构 以上图说明： bbs 目录代表一个 web 应用 bbs 目录下的 html,jsp 文件可以直接被浏览器访问 WEB-INF 目录下的资源是不能直接被浏览器访问的 web.xml 文件是 web 程序的主要配置文件 所有的 classes 文件都放在 classes 目录下 jar 文件放在 lib 目录下 实现 Servlet 接口编写 Servlet 程序程序我都是由 idea 下写，首先要在 idea 上配置 Tomcat，在我别的博文中有教程！ 编写 Servlet 程序的步骤 创建一个自定义类，实现 Serlvet 接口 我们发现有 5 个方法需要重写，有 init【初始化】，destroy【销毁】,service【服务】,ServletConfig【Servlet 配置】,getServletInfo【Serlvet 信息】。 在此一看，发现 service() 方法是最有可能是写逻辑代码的地方。 首先写一个 hellword 入门先 调用 ServletResponse 对象的方法向浏览器输出 HelloWorld 配置 xml 文件，光写了 Servlet 是不行的，Tomcat 还要知道浏览器怎么访问这个 Servlet。 访问自己写的 Serlvet 程序 Serlvet 生命周期 下面我们看看 Servlet 的生命周期 第一次访问 Servlet，我们发现 init() 和 service() 都被调用了 第二次访问 Servlet，service() 被调用了 第三次访问 Servlet，还是 service() 被调用了 当我们关闭 Tomcat 服务器的时候，destroy() 被调用了！ Servlet 生命周期可分为 5 个步骤 加载 Servlet。当 Tomcat 第一次访问 Servlet 的时候，Tomcat 会负责创建 Servlet 的实例 初始化。当 Servlet 被实例化后，Tomcat 会调用 init() 方法初始化这个对象 处理服务。当浏览器访问 Servlet 的时候，Servlet 会调用 service() 方法处理请求 销毁。当 Tomcat 关闭时或者检测到 Servlet 要从 Tomcat 删除的时候会自动调用 destroy() 方法，让该实例释放掉所占的资源。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁 卸载。当 Servlet 调用完 destroy() 方法后，等待垃圾回收。如果有需要再次使用这个 Servlet，会重新调用 init() 方法进行初始化操作。 简单总结：只要访问 Servlet，service() 就会被调用。init() 只有第一次访问 Servlet 的时候才会被调用。destroy() 只有在 Tomcat 关闭的时候才会被调用。 继承 HttpServlet 编写 Servlet 程序在上面我们实现 Servlet 接口，要实现 5 个方法。这样太麻烦了！而 HttpServlet 类已经实现了 Servlet 接口的所有方法，编写 Servlet 时，只需要继承 HttpServlet，重写你需要的方法即可，并且它在原有 Servlet 接口上添加了一些与 HTTP 协议处理方法，它比 Servlet 接口的功能更为强大。 一般我们开发的时候，都是重写 doGet() 和 doPost() 方法的。对于 idea 而言，创建 Servlet 的时候已经帮你重写好了 Servlet 第二篇【Servlet 调用图、Servlet 细节、ServletConfig、ServletContext】Servlet 的调用图前面我们已经学过了 Servlet 的生命周期了，我们根据 Servlet 的生命周期画出 Servlet 的调用图加深理解 Servlet 的细节一个已经注册的 Servlet 可以被多次映射同一个 Servlet 可以被映射到多个 URL 上。 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/ouzicheng&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 无论我访问的是 http://localhost:8080/Demo1 还是 http://localhost:8080/ouzicheng。我访问的都是 Demo1。 Servlet 映射的 URL 可以使用通配符通配符有两种格式： *. 扩展名 正斜杠（/）开头并以 “/*” 结尾。 匹配所有 匹配扩展名为. jsp 的 如果. 扩展名和正斜杠（/）开头并以 “/” 结尾两种通配符同时出现，匹配的是哪一个呢？ 看谁的匹配度高，谁就被选择 *.扩展名的优先级最低 Servlet 映射的 URL 可以使用通配符和 Servlet 可以被映射到多个 URL 上的作用： 隐藏网站是用什么编程语言写的【.php,.net,.asp 实际上访问的都是同一个资源】 用特定的后缀声明版权【公司缩写】 123456789101112131415161718192021 &lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;*.net&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;*.asp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;*.php&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet 是单例的为什么 Servlet 是单例的浏览器多次对 Servlet 的请求，一般情况下，服务器只创建一个 Servlet 对象，也就是说，Servlet 对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。 每次访问请求对象和响应对象都是新的对于每次访问请求，Servlet 引擎都会创建一个新的 HttpServletRequest 请求对象和一个新的 HttpServletResponse 响应对象，然后将这两个对象作为参数传递给它调用的 Servlet 的 service() 方法，service 方法再根据请求方式分别调用 doXXX 方法。 线程安全问题当多个用户访问 Servlet 的时候，服务器会为每个用户创建一个线程。当多个用户并发访问 Servlet 共享资源的时候就会出现线程安全问题。 原则： 如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制 synchronized (对象){} 如果一个变量不需要共享，则直接在 doGet() 或者 doPost() 定义. 这样不会存在线程安全问题 load-on-startup如果在 作用： 为 web 应用写一个 InitServlet，这个 servlet 配置为启动时装载，为整个 web 应用创建必要的数据库表和数据 完成一些定时的任务【定时写日志，定时备份数据】 在 web 访问任何资源都是在访问 Servlet当你启动 Tomcat，你在网址上输入 http://localhost:8080。为什么会出现 Tomcat 小猫的页面？ 这是由缺省 Servlet 为你服务的！ 我们先看一下 web.xml 文件中的配置,web.xml 文件配置了一个缺省 Servlet 12345678910111213141516171819&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 什么叫做缺省 Servlet？凡是在 web.xml 文件中找不到匹配的，它们的访问请求都将交给缺省 Servlet 处理，也就是说，缺省 Servlet 用于处理所有其他 Servlet 都不处理的访问请求 既然我说了在 web 访问任何资源都是在访问 Servlet，那么我访问静态资源【本地图片，本地 HTML 文件】也是在访问这个缺省 Servlet【DefaultServlet】 证实一下：当我没有手工配置缺省 Servlet 的时候，访问本地图片是可以访问得到的 现在我自己配置一个缺省 Servlet,Demo1 就是我手工配置的缺省 Servlet，覆盖掉 web.xml 配置的缺省 Servlet 12345678910&lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 下面我继续访问一下刚才的图片，此时输出的是 Demo1 这个 Servlet 写上的内容了 总结：无论在 web 中访问什么资源【包括 JSP】，都是在访问 Servlet。没有手工配置缺省 Servlet 的时候，你访问静态图片，静态网页，缺省 Servlet 会在你 web 站点中寻找该图片或网页，如果有就返回给浏览器，没有就报 404 错误 ServletConfig 对象ServletConfig 对象有什么用？ 通过此对象可以读取 web.xml 中配置的初始化参数。 现在问题来了，为什么我们要把参数信息放到 web.xml 文件中呢？我们可以直接在程序中都可以定义参数信息，搞到 web.xml 文件中又有什么好处呢？ 好处就是：能够让你的程序更加灵活【更换需求，更改配置文件 web.xml 即可，程序代码不用改】 获取 web.xml 文件配置的参数信息 为 Demo1 这个 Servlet 配置一个参数，参数名是 name，值是 zhongfucheng 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;zhongfucheng&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在 Servlet 中获取 ServletConfig 对象，通过 ServletConfig 对象获取在 web.xml 文件配置的参数 ServletContext 对象什么是 ServletContext 对象？当 Tomcat 启动的时候，就会创建一个 ServletContext 对象。它代表着当前 web 站点 ServletContext 有什么用？ ServletContext 既然代表着当前 web 站点，那么所有 Servlet 都共享着一个 ServletContext 对象，所以 Servlet 之间可以通过 ServletContext 实现通讯。 ServletConfig 获取的是配置的是单个 Servlet 的参数信息，ServletContext 可以获取的是配置整个 web 站点的参数信息 利用 ServletContext 读取 web 站点的资源文件 实现 Servlet 的转发【用 ServletContext 转发不多，主要用 request 转发】 Servlet 之间实现通讯ServletContext 对象可以被称之为域对象 到这里可能有一个疑问，域对象是什么呢？其实域对象可以简单理解成一个容器【类似于 Map 集合】 实现 Servlet 之间通讯就要用到 ServletContext 的 setAttribute(String name,Object obj) 方法，第一个参数是关键字，第二个参数是你要存储的对象 这是 Demo2 的代码 12345678//获取到ServletContext对象ServletContext servletContext = this.getServletContext();String value = &quot;zhongfucheng&quot;;//MyName作为关键字，value作为值存进域对象【类型于Map集合】servletContext.setAttribute(&quot;MyName&quot;, value); 这是 Demo3 的代码 12345678//获取ServletContext对象ServletContext servletContext = this.getServletContext();//通过关键字获取存储在域对象的值String value = (String) servletContext.getAttribute(&quot;MyName&quot;);System.out.println(value); 访问 Demo3 可以获取 Demo2 存储的信息，从而实现多个 Servlet 之间通讯 获取 web 站点配置的信息如果我想要让所有的 Servlet 都能够获取到连接数据库的信息，不可能在 web.xml 文件中每个 Servlet 中都配置一下，这样代码量太大了！并且会显得非常啰嗦冗余。 web.xml 文件支持对整个站点进行配置参数信息【所有 Servlet 都可以取到该参数信息】 12345&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;zhongfucheng&lt;/param-value&gt;&lt;/context-param&gt; Demo4 代码 1234567//获取到ServletContext对象ServletContext servletContext = this.getServletContext();//通过名称获取值String value = servletContext.getInitParameter(&quot;name&quot;);System.out.println(value); 试一下 Demo3 是否能拿到，相同的代码 1234567//获取到ServletContext对象ServletContext servletContext = this.getServletContext();//通过名称获取值String value = servletContext.getInitParameter(&quot;name&quot;);System.out.println(value); 读取资源文件第一种方式： 现在我要通过 Servlet111 读取 1.png 图片 按我们以前的方式，代码应该是这样的。 123FileInputStream fileInputStream = new FileInputStream(&quot;1.png&quot;);System.out.println(fileInputStream); 当我们访问的时候，却出错了！说找不到 1.png 文件 这是为什么呢？我们以前读取文件的时候，如果程序和文件在同一包名，可以直接通过文件名称获取得到的！，原因很简单，以前我们写的程序都是通过 JVM 来运行的，而现在，我们是通过 Tomcat 来运行的 根据 web 的目录规范，Servlet 编译后的 class 文件是存放在 WEB-INF\classes 文件夹中的 看到这里，我们知道了要进入 classes 目录中读取文件，所以我们将代码改成以下方式 123FileInputStream fileInputStream = new FileInputStream(&quot;D:\\zhongfucheng\\web\\WEB-INF\\classes\\zhongfucheng\\web\\1.png&quot;);System.out.println(fileInputStream); 再去读取时，就发现可以获取到文件了。 但是现在问题又来了，我读取文件的时候都要写上绝对路径，这样太不灵活了。试想一下，如果我将该读取文件的模块移到其他的 web 站点上，我的代码就又要修改了【因为 web 站点的名字不一样】。 我们通过 ServletContext 读取就可以避免修改代码的情况，因为 ServletContext 对象是根据当前 web 站点而生成的 代码如下所示： 123456//获取到ServletContext对象ServletContext servletContext = this.getServletContext();//调用ServletContext方法获取到读取文件的流InputStream inputStream = servletContext.getResourceAsStream(&quot;/WEB-INF/classes/zhongfucheng/web/1.png&quot;); 第二种方式： 如果我的文件放在 web 目录下，那么就简单得多了！, 直接通过文件名称就能获取 代码如下所示 123456//获取到ServletContext对象ServletContext servletContext = this.getServletContext();//调用ServletContext方法获取到读取文件的流InputStream inputStream = servletContext.getResourceAsStream(&quot;2.png&quot;); 第三种方式： 通过类装载器读取资源文件。 我的文件放在了 src 目录下【也叫做类目录】 代码如下所示 123456//获取到类装载器ClassLoader classLoader = Servlet111.class.getClassLoader();//通过类装载器获取到读取文件流InputStream inputStream = classLoader.getResourceAsStream(&quot;3.png&quot;); 我的文件放在了 src 目录下的包下 代码如下，添加包名路径即可。 123456//获取到类装载器ClassLoader classLoader = Servlet111.class.getClassLoader();//通过类装载器获取到读取文件流InputStream inputStream = classLoader.getResourceAsStream(&quot;/zhongfucheng/web/1.png&quot;); 原则：如果文件太大，就不能用类装载器的方式去读取，会导致内存溢出 Servlet 第四篇【request 对象常用方法、应用】什么是 HttpServletRequest HttpServletRequest 对象代表客户端的请求，当客户端通过 HTTP 协议访问服务器时，HTTP 请求头中的所有信息都封装在这个对象中，开发人员通过这个对象的方法，可以获得客户这些信息。 简单来说，要得到浏览器信息，就找 HttpServletRequest 对象 HttpServletRequest 常用方法获得客户机【浏览器】信息 getRequestURL 方法返回客户端发出请求时的完整 URL。 getRequestURI 方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo 方法返回请求 URL 中的额外路径信息。额外路径信息是请求 URL 中的位于 Servlet 的路径之后和查询参数之前的内容，它以 “/” 开头。 getRemoteAddr 方法返回发出请求的客户机的 IP 地址 getRemoteHost 方法返回发出请求的客户机的完整主机名 getRemotePort 方法返回客户机所使用的网络端口号 getLocalAddr 方法返回 WEB 服务器的 IP 地址。 getLocalName 方法返回 WEB 服务器的主机名 获得客户机请求头 getHeader 方法 getHeaders 方法 getHeaderNames 方法 获得客户机请求参数 (客户端提交的数据) getParameter 方法 getParameterValues（String name）方法 getParameterNames 方法 getParameterMap 方法 HttpServletRequest 应用防盗链什么是防盗链呢？比如：我现在有海贼王最新的资源，想要看海贼王的要在我的网页上看。现在别的网站的人看到我有海贼王的资源，想要把我的资源粘贴在他自己的网站上。这样我独家的资源就被一个 CTRL+C 和 CTRL+V 抢走了？而反盗链就是不能被他们 CRTL+C 和 CRTL+V 下面我模拟一下场景。现在我首页先有一个超链接，指向着海贼王最新资源 当我点进去，就能看到海贼王最新资源了 其他的人可以通过复制粘贴我的地址，放到它们的网页上 这样我就划不来啦【我的广告你来没看呢！】。想要看我的资源，就必须经过我的首页点进去看。 想要实现这样的效果，就要获取 Referer 这个消息头，判断 Referer 是不是从我的首页来的。如果不是从我的首页来的，跳转回我的首页。 123456789101112131415//获取到网页是从哪里来的String referer = request.getHeader(&quot;Referer&quot;);//如果不是从我的首页来或者从地址栏直接访问的，if ( referer == null || !referer.contains(&quot;localhost:8080/zhongfucheng/index.jsp&quot;) ) &#123; //回到首页去 response.sendRedirect(&quot;/zhongfucheng/index.jsp&quot;); return;&#125;//能执行下面的语句，说明是从我的首页点击进来的，那没问题，照常显示response.setContentType(&quot;text/html;charset=UTF-8&quot;);response.getWriter().write(&quot;路飞做了XXXXxxxxxxxxxxxxxxxx&quot;); 首先按正常预想的，别人从首页点击我的资源，访问我海贼王最新的资源 \ 能够成功访问到资源 如果我在浏览器直接输入地址【此时 Referer 是为 null 的】，我们来看看 跳回到首页上，不能访问到海贼王资源 再试试，如果别人粘贴了我的资源 url，在它的网页上挂了一个网址呢。 在别人网页上点击的时候 又跳回到了我的首页了。 表单提交数据【通过 post 方式提交数据】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;form action=&quot;/zhongfucheng/Servlet111&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; &gt;男 &lt;input type=&quot;radio&quot; &gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; &gt;游泳 &lt;input type=&quot;checkbox&quot; &gt;跑步 &lt;input type=&quot;checkbox&quot; &gt;飞翔 &lt;/td&gt; &lt;/tr&gt; &lt;input type=&quot;hidden&quot; &gt; &lt;tr&gt; &lt;td&gt;你的来自于哪里&lt;/td&gt; &lt;td&gt; &lt;select &gt; &lt;option value=&quot;广州&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;详细说明:&lt;/td&gt; &lt;td&gt; &lt;textarea cols=&quot;30&quot; rows=&quot;2&quot; &gt;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 在 Servlet111 中获取到提交的数据，代码如下 1234567891011121314151617181920//设置request字符编码的格式request.setCharacterEncoding(&quot;UTF-8&quot;);//通过html的name属性，获取到值String username = request.getParameter(&quot;username&quot;);String password = request.getParameter(&quot;password&quot;);String gender = request.getParameter(&quot;gender&quot;);//复选框和下拉框有多个值，获取到多个值String[] hobbies = request.getParameterValues(&quot;hobbies&quot;);String[] address = request.getParameterValues(&quot;address&quot;);//获取到文本域的值String description = request.getParameter(&quot;textarea&quot;);//得到隐藏域的值String hiddenValue = request.getParameter(&quot;aaa&quot;);....各种System.out.println()....... 向表单输入数据 Servlet111 得到表单带过来的数据，最后的一个数据是隐藏域带过来的。 超链接方式提交数据常见的 get 方式提交数据有：使用超链接，sendRedirect() 格式如下： 12sendRedirect(&quot;servlet的地址?参数名=&quot;+参数值 &amp;&quot;参数名=&quot;+参数值); 我们来使用一下，通过超链接将数据带给浏览器 12&lt;a href=&quot;/zhongfucheng/Servlet111?user&gt;使用超链接将数据带给浏览器&lt;/a&gt; 在 Servlet111 接收数据 1234//接收以username为参数名带过来的值String username = request.getParameter(&quot;username&quot;);System.out.println(username); 注意看浏览器左下角 服务器成功接收到浏览器发送过来的数据 并且，传输数据明文的出现在浏览器的地址栏上 sendRedirect() 和超链接类似，在这里就不赘述了 解决中文乱码问题细心的朋友会发现，我在获取表单数据的时候，有这句代码request.setCharacterEncoding(&quot;UTF-8&quot;);，如果没有这句代码，会发生什么事呢？我们看看。 再重新填写数据 在服务器查看提交过来的数据，所有的中文数据都乱码了 来这里我们来分析一下乱码的原因，在前面的博客中我已经介绍了，Tomcat 服务器默认编码是 ISO 8859-1，而浏览器使用的是 UTF-8 编码。浏览器的中文数据提交给服务器，Tomcat 以 ISO 8859-1 编码对中文编码，当我在 Servlet 读取数据的时候，拿到的当然是乱码。而我设置 request 的编码为 UTF-8，乱码就解决了。 接下来使用 get 方式传递中文数据，把表单的方式改成 get 即可 当我们访问的时候，又出现乱码了！ 于是我按照上面的方式，把 request 对象设置编码为 UTF-8 试试 123request.setCharacterEncoding(&quot;UTF-8&quot;);String name = request.getParameter(&quot;name&quot;); 结果还是乱码。这是为什么呢？我明明已经把编码设置成 UTF-8 了，按照 post 方式，乱码问题已经解决了！。我们来看看 get 和 post 方式的区别在哪？为什么 post 方式设置了 request 编码就可以解决乱码问题，而 get 方式不能呢。 首先我们来看一下 post 方法是怎么进行参数传递的。当我们点击提交按钮的时候，数据封装进了 Form Data 中，http 请求中把实体主体带过去了【传输的数据称之为实体主体】，既然 request 对象封装了 http 请求，所以 request 对象可以解析到发送过来的数据，于是只要把编码设置成 UTF-8 就可以解决乱码问题了。 而 get 方式不同，它的数据是从消息行带过去的，没有封装到 request 对象里面，所以使用 request 设置编码是无效的。 要解决 get 方式乱码问题也不难，我们既然知道 Tomcat 默认的编码是 ISO 8859-1，那么 get 方式由消息体带过去给浏览器的时候肯定是用 ISO 8859-1 编码了。 123456789//此时得到的数据已经是被ISO 8859-1编码后的字符串了，这个是乱码String name = request.getParameter(&quot;username&quot;);//乱码通过反向查ISO 8859-1得到原始的数据byte[] bytes = name.getBytes(&quot;ISO8859-1&quot;);//通过原始的数据，设置正确的码表，构建字符串String value = new String(bytes, &quot;UTF-8&quot;); 上面的代码有些难理解，我画张图说明一下： 经过我们手工转换，再来访问一下 好的，成功解决掉乱码问题了。 除了手工转换，get 方式还可以改 Tomcat 服务器的配置来解决乱码，但是不推荐使用，这样不灵活。“ 我们都知道 Tomcat 默认的编码是 ISO 8859-1, 如果在 Tomcat 服务器的配置下改成是 UTF-8 的编码，那么就解决服务器在解析数据的时候造成乱码问题了 在 8080 端口的 Connector 上加入URIEncoding=&quot;utf-8&quot;，设置 Tomcat 的访问该端口时的编码为 utf-8，从而解决乱码，这种改法是固定使用 UTF-8 编码的 1234&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot;/&gt; 设置了编码后，没有做任何手工转换，成功拿到数据 、 当然也有另一种改服务器编码的方式。设置 Tomcat 的访问该端口时的编码为页面的编码，这种改法是随着页面的编码而变 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot; /&gt; 设置编码为 UTF-8 123request.setCharacterEncoding(&quot;UTF-8&quot;);String name = request.getParameter(&quot;name&quot;); 再次访问 手写超链接如果附带中文参数问题，要 URL 重写，在 JSP 博客中会讲到 总结： post 方式直接改 request 对象的编码 get 方式需要手工转换编码 get 方式也可以修改 Tomcat 服务器的编码，不推荐，因为会太依赖服务器了！ 提交数据能用 post 就用 post 实现转发之前讲过使用 response 的 sendRedirect() 可以实现重定向，做到的功能是页面跳转，使用 request 的 getRequestDispatcher.forward(request,response) 实现转发，做到的功能也是页面跳转，他们有什么区别呢？现在我先来说下转发 代码如下所示 123456//获取到requestDispatcher对象，跳转到index.jspRequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/index.jsp&quot;);//调用requestDispatcher对象的forward()实现转发,传入request和response方法requestDispatcher.forward(request, response); 访问 Servlet111 上面已经说了，可以通过 sendRedirect() 重定向可以在资源尾部添加参数提交数据给服务器。那么转发能不能提交数据给服务器呢？ 答案明显是可以的，并且使用这种方法非常频繁 在讲 ServletContext 的时候，曾经说过 Servlet 之间可以通过 ServletContext 实现通讯，ServletContext 也能称之为域对象。而 request 也可以称之为域对象，只不过 ServletContext 的域是整个 web 应用，而 request 的域仅仅代表一次 http 请求 下面我们来使用 request 实现 Servlet 之间的通讯，Servlet111 代码 123456789//以username为关键字存zhongfucheng值request.setAttribute(&quot;username&quot;, &quot;zhongfucheng&quot;);//获取到requestDispatcher对象RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/Servlet222&quot;);//调用requestDispatcher对象的forward()实现转发,传入request和response方法requestDispatcher.forward(request, response); Servlet222 代码 123456//获取到存进request对象的值String userName = (String) request.getAttribute(&quot;username&quot;);//在浏览器输出该值response.getWriter().write(&quot;i am :&quot;+userName); 访问 Servlet111 看下效果 如上图所示，Servlet222 成功拿到了 request 对象在 Servlet111 存进的数据。 现在问题又来了，我们可以使用 ServletContext 和 request 实现 Servlet 之间的通讯，那么我们用哪一种呢？一般的原则：可以使用 request 就尽可能使用 request。因为 ServletContext 代表着整个 web 应用，使用 ServletContext 会消耗大量的资源，而 request 对象会随着请求的结束而结束，资源会被回收。使用 request 域进行 Servlet 之间的通讯在开发中是非常频繁的。 转发的时序图 请求转发的细节 如果在调用 forward 方法之前，在 Servlet 程序中写入的部分内容已经被真正地传送到了客户端，forward 方法将抛出 IllegalStateException 异常。 也就是说：不要在转发之前写数据给浏览器 我们来试试是不是真的会出现异常。 123456789OutputStream outputStream = response.getOutputStream();outputStream.write(&quot;--------------------------------------------&quot;.getBytes());//关闭流，确保让数据到浏览器中outputStream.close();//跳转request.getRequestDispatcher(&quot;/Foot&quot;).forward(request, response); 访问的时候，看到浏览器可以输出数据，Tomcat 后台抛出了异常 如果在调用 forward 方法之前向 Servlet 引擎的缓冲区中写入了内容，只要写入到缓冲区中的内容还没有被真正输出到客户端，forward 方法就可以被正常执行，原来写入到输出缓冲区中的内容将被清空，但是，已写入到 HttpServletResponse 对象中的响应头字段信息保持有效。 转发和重定向的区别实际发生位置不同，地址栏不同 转发是发生在服务器的 转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问 Servlet111 的时候，即使跳转到了 Servlet222 的页面，浏览器的地址还是 Servlet111 的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的 http 请求，一次转发中 request 和 response 对象都是同一个。这也解释了，为什么可以使用 request 作为域对象进行 Servlet 之间的通讯。 重定向是发生在浏览器的 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。曾经介绍过：实现重定向的原理是由 response 的状态码和 Location 头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个 http 请求，request 域对象是无效的，因为它不是同一个 request 对象 用法不同很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则：给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 request.getRequestDispatcher(“/ 资源名 URI”).forward(request,response) 转发时 “/“ 代表的是本应用程序的根目录【zhongfucheng】 response.send(“/web 应用 / 资源名 URI”); 重定向时 “/“ 代表的是 webapps 目录 能够去往的 URL 的范围不一样 转发是服务器跳转只能去往当前 web 应用的资源 重定向是服务器跳转，可以去往任何的资源 传递数据的类型不同 转发的 request 对象可以传递各种类型的数据，包括对象 重定向只能传递字符串 跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 转发和重定向使用哪一个？根据上面说明了转发和重定向的区别也可以很容易概括出来。转发是带着转发前的请求的参数的。重定向是新的请求。 典型的应用场景： 转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变 重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了 RequestDispatcher 再说明RequestDispatcher 对象调用 forward() 可以实现转发上面已经说过了。RequestDispatcher 还有另外一个方法 include()，该方法可以实现包含，有什么用呢？ 我们在写网页的时候，一般网页的头部和尾部是不需要改变的。如果我们多个地方使用 Servlet 输出网头和网尾的话，需要把代码重新写一遍。而使用 RequestDispatcher 的 include() 方法就可以实现包含网头和网尾的效果了。 我们来操作吧！现在我有网头和网尾的 Servlet 使用 Servlet111 将网头和网尾包含 123456request.getRequestDispatcher(&quot;/Head&quot;).include(request, response);response.getWriter().write(&quot;--------------------------------------------&quot;);request.getRequestDispatcher(&quot;/Foot&quot;).include(request, response); 访问一下 Servlet111, 成功把网头和网尾包含了 Servlet 第五篇【介绍会话技术、Cookie 的 API、详解、应用】什么是会话技术 基本概念: 指用户开一个浏览器，访问一个网站, 只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话. 为什么我们要使用会话技术？会话跟踪技术可以解决我们很多很多问题。 在论坛登陆的时候，很多时候会有一个小框框问你是否要自动登陆，当你下次登陆的时候就不用输入密码了 根据我以前浏览过的商品，猜我喜欢什么商品 Cookie会话跟踪技术有 Cookie 和 Session，Cookie 技术是先出现的。我们先讲 Cookie 技术吧。 什么是 Cookie Cookie 是由 W3C 组织提出，最早由 netscape 社区发展的一种机制 网页之间的交互是通过 HTTP 协议传输数据的，而 Http 协议是无状态的协议。无状态的协议是什么意思呢？一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接。 服务器无法确认用户的信息，于是乎，W3C 就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是 Cookie Cookie 的流程：浏览器访问服务器，如果服务器需要记录该用户的状态，就使用 response 向浏览器发送一个 Cookie，浏览器会把 Cookie 保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址连同 Cookie 一同交给服务器。 Cookie API Cookie 类用于创建一个 Cookie 对象 response 接口中定义了一个 addCookie 方法，它用于在其响应头中增加一个相应的 Set-Cookie 头字段 request 接口中定义了一个 getCookies 方法，它用于获取客户端提交的 Cookie 常用的 Cookie 方法： public Cookie(String name,String value) setValue 与 getValue 方法 setMaxAge 与 getMaxAge 方法 setPath 与 getPath 方法 setDomain 与 getDomain 方法 getName 方法 简单使用 Cookie 创建 Cookie 对象，发送 Cookie 给浏览器、 1234567891011//设置response的编码response.setContentType(&quot;text/html;charset=UTF-8&quot;);//创建Cookie对象，指定名称和值Cookie cookie = new Cookie(&quot;username&quot;, &quot;zhongfucheng&quot;);//向浏览器给一个Cookieresponse.addCookie(cookie);response.getWriter().write(&quot;我已经向浏览器发送了一个Cookie&quot;); 浏览器本身没有任何 Cookie 访问 Servlet1，再回到文件夹中，还是没有发现 Cookie，这是为什么呢？我明明向浏览器发送了一个 Cookie 的。 原来发送 Cookie 给浏览器是需要设置 Cookie 的时间的。在给浏览器之前，设置一下 Cookie 的时间 123//设置Cookie的时间cookie.setMaxAge(1000); 再次访问，已经发现文件夹中多了个 Cookie 的文本了 Cookie 细节Cookie 不可跨域名性 很多人在初学的时候可能有一个疑问：在访问 Servlet 的时候浏览器是不是把所有的 Cookie 都带过去给服务器，会不会修改了别的网站的 Cookie 答案是否定的。Cookie 具有不可跨域名性。浏览器判断一个网站是否能操作另一个网站的 Cookie 的依据是域名。所以一般来说，当我访问 baidu 的时候，浏览器只会把 baidu 颁发的 Cookie 带过去，而不会带上 google 的 Cookie。 Cookie 保存中文 上面我们的例子保存的是英文字符，下面我们来看下保存中文字符会怎么样。 12345678910response.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter printWriter = response.getWriter();String name = &quot;中国&quot;;Cookie cookie = new Cookie(&quot;country&quot;, name);cookie.setMaxAge(2000);response.addCookie(cookie);printWriter.write(&quot;我颁发了一个Cookie，值保存的是中文数据&quot;); 访问 Servlet1，好吧。出异常了！ 中文属于 Unicode 字符，英文数据 ASCII 字符，中文占 4 个字符或者 3 个字符，英文占 2 个字符。 解决：Cookie 使用 Unicode 字符时需要对 Unicode 字符进行编码。 123//对Unicode字符进行编码Cookie cookie = new Cookie(&quot;country&quot;, URLEncoder.encode(name, &quot;UTF-8&quot;)); 再次访问 Servlet1，已经把 Cookie 成功颁发给浏览器了 我们发现 Cookie 保存在硬盘的中文数据是经过编码的，那么我们在取出 Cookie 的时候要对中文数据进行解码 12345678910Cookie[] cookies = request.getCookies();for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; String name = cookies[i].getName(); //经过URLEncoding就要URLDecoding String value = URLDecoder.decode(cookies[i].getValue(), &quot;UTF-8&quot;); printWriter.write(name + &quot;------&quot; + value);&#125; 取出存进 Cookie 的值 Cookie 的有效期Cookie 的有效期是通过 setMaxAge() 来设置的。 如果 MaxAge 为正数，浏览器会把 Cookie 写到硬盘中，只要还在 MaxAge 秒之前，登陆网站时该 Cookie 就有效【不论关闭了浏览器还是电脑】 如果 MaxAge 为负数，Cookie 是临时性的，仅在本浏览器内有效，关闭浏览器 Cookie 就失效了，Cookie 不会写到硬盘中。Cookie 默认值就是 - 1。这也就为什么在我第一个例子中，如果我没设置 Cookie 的有效期，在硬盘中就找不到对应的文件。 如果 MaxAge 为 0，则表示删除该 Cookie。Cookie 机制没有提供删除 Cookie 对应的方法，把 MaxAge 设置为 0 等同于删除 Cookie Cookie 的修改和删除 上面我们已经知道了 Cookie 机制没有提供删除 Cookie 的方法。其实细心点我们可以发现，Cookie 机制也没有提供修改 Cookie 的方法。那么我们怎么修改 Cookie 的值呢？ Cookie 存储的方式类似于 Map 集合，如下图所示 Cookie 的名称相同，通过 response 添加到浏览器中，会覆盖原来的 Cookie。 以 country 为名保存的是 %E4%B8%AD%E5%9B%BD，下面我再以 country 为名，把值改变一下。 12345String name = &quot;看完博客就点赞&quot;;//对Unicode字符进行编码Cookie cookie = new Cookie(&quot;country&quot;, URLEncoder.encode(name, &quot;UTF-8&quot;)); 再次查看 Cookie 的时候，值已经改变了，但是文件还是那一份 现在我要删除该 Cookie，把 MaxAge 设置为 0，并添加到浏览器中即可 1234567891011String name = &quot;看完博客就点赞&quot;;//对Unicode字符进行编码Cookie cookie = new Cookie(&quot;country&quot;, URLEncoder.encode(name, &quot;UTF-8&quot;));//一定不要忘记添加到浏览器中cookie.setMaxAge(0);response.addCookie(cookie);printWriter.write(&quot;我删除了该Cookie&quot;); 访问 Servlet，在硬盘已经找不到 Cookie 的文件了！ 注意：删除，修改 Cookie 时，新建的 Cookie 除了 value、maxAge 之外的所有属性都要与原 Cookie 相同。否则浏览器将视为不同的 Cookie，不予覆盖，导致删除修改失败！ 我们来试验一下把。 123456789String name = &quot;看完博客就点赞&quot;;//对Unicode字符进行编码Cookie cookie = new Cookie(&quot;country&quot;, URLEncoder.encode(name, &quot;UTF-8&quot;));//一定不要忘记添加到浏览器中cookie.setMaxAge(10000);response.addCookie(cookie); 上面新建了一个 Cookie，我修改下 Cookie 的其他属性，再删除，看能否把 Cookie 删除掉 12345678//一定不要忘记添加到浏览器中cookie.setPath(&quot;/ouzicheng&quot;);cookie.setMaxAge(0);response.addCookie(cookie);printWriter.write(&quot;删除一个Cookie&quot;); 结果 Cookie 还在硬盘中 Cookie 的域名Cookie 的 domain 属性决定运行访问 Cookie 的域名。domain 的值规定为 “. 域名” Cookie 的隐私安全机制决定 Cookie 是不可跨域名的。也就是说 www.baidu.com 和 www.google.com 之间的 Cookie 是互不交接的。即使是同一级域名，不同二级域名也不能交接，也就是说：www.goole.com 和 www.image.goole.com 的 Cookie 也不能访问 我在本地上配置了 3 个虚拟主机，localhost,www.zhongfucheng.com,www.image.zhongfucheng.com【如果不知道怎么配置，在我 Tomcat 的博客有】 我用 www.zhongfucheng.com 域名发送了一个 Cookie 给浏览器 123456Cookie cookie = new Cookie(&quot;name&quot;, &quot;zhongfucheng&quot;);cookie.setMaxAge(1000);response.addCookie(cookie);printWriter.write(&quot;使用www.zhongfucheng.com域名添加了一个Cookie&quot;); 首先，证明了 Cookie 不可跨名性，localhost 域名拿不到 www.zhongfucheng.com 颁发给浏览器的 Cookie 再使用 www.image.zhongfucheng.com 域名访问, 证明即使一级域名相同，二级域名不同，也不能获取到 Cookie 当然，使用 www.zhongfucheng.com 当然能获取到 Cookie，Cookie 通过请求头带给服务器 现在我希望一级域名相同的网页 Cookie 之间可以相互访问。也就是说 www.image.zhongfucheng.com 可以获取到 www.zhongfucheng.com 的 Cookie 就需要使用到 domain 方法。 1234567Cookie cookie = new Cookie(&quot;name&quot;, &quot;ouzicheng&quot;);cookie.setMaxAge(1000);cookie.setDomain(&quot;.zhongfucheng.com&quot;);response.addCookie(cookie);printWriter.write(&quot;使用www.zhongfucheng.com域名添加了一个Cookie,只要一级是zhongfucheng.com即可访问&quot;); 使用 www.zhongfucheng.com 发布一个 Cookie 使用 www.image.zhongfucheng.com 域名访问一下。发现可以获取到 Cookie 了 Cookie 的路径Cookie 的 path 属性决定允许访问 Cookie 的路径 一般地，Cookie 发布出来，整个网页的资源都可以使用。现在我只想 Servlet1 可以获取到 Cookie，其他的资源不能获取。 使用 Servlet2 颁发一个 Cookie 给浏览器, 设置路径为 “/Servlet1”。 1234567Cookie cookie = new Cookie(&quot;username&quot;, &quot;java&quot;);cookie.setPath(&quot;/Servlet1&quot;);cookie.setMaxAge(1000);response.addCookie(cookie);printWriter.write(&quot;该Cookie只有Servlet1获取得到&quot;); 使用 Servlet3 访问服务器，看看浏览器是否把 Cookie 带上。显然，浏览器访问 Servlet3 并没有把 Cookie 带上。 使用 Servlet1 访问服务器，看看浏览器是否把 Cookie 带上。答案是肯定的！ Cookie 的安全属性 HTTP 协议不仅仅是无状态的，而且是不安全的！如果不希望 Cookie 在非安全协议中传输，可以设置 Cookie 的 secure 属性为 true，浏览器只会在 HTTPS 和 SSL 等安全协议中传输该 Cookie。 当然了，设置 secure 属性不会将 Cookie 的内容加密。如果想要保证安全，最好使用 md5 算法加密【后面有】。 Cookie 的应用显示用户上次访问的时间 其实就是每次登陆的时候，取到 Cookie 保存的值，再更新下 Cookie 的值。 访问 Serlvet 有两种情况 第一次访问 已经访问过了 全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);response.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter printWriter = response.getWriter();//获取网页上所有的CookieCookie[] cookies = request.getCookies();//判断Cookie的值是否为空String cookieValue = null;for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; //获取到以time为名的Cookie if (cookies[i].getName().equals(&quot;time&quot;)) &#123; printWriter.write(&quot;您上次登陆的时间是：&quot;); cookieValue = cookies[i].getValue(); printWriter.write(cookieValue); cookies[i].setValue(simpleDateFormat.format(new Date())); response.addCookie(cookies[i]); //既然已经找到了就可以break循环了 break; &#125;&#125;//如果Cookie的值是空的，那么就是第一次访问if (cookieValue == null) &#123; //创建一个Cookie对象，日期为当前时间 Cookie cookie = new Cookie(&quot;time&quot;, simpleDateFormat.format(new Date())); //设置Cookie的生命期 cookie.setMaxAge(20000); //response对象回送Cookie给浏览器 response.addCookie(cookie); printWriter.write(&quot;您是第一次登陆啊！&quot;);&#125; 按照正常的逻辑来写，程序流程应该是这样子的。先创建 Cookie 对象，回送 Cookie 给浏览器。再遍历 Cookie，更新 Cookie 的值。 但是，按照上面的逻辑是做不到的！因为每次访问 Servlet 的时候都会覆盖原来的 Cookie，取到 Cookie 的值永远都是当前时间，而不是上次保存的时间。 我们换一个逻辑写：先检查（遍历）所有 Cookie 有没有我要的，如果得不到我想要的 Cookie，Cookie 的值是 null，那么就是第一次登陆，于是就有了上面的代码了。 我们来看下效果吧！当我第一次登陆的时候 Cookie 保存在硬盘中。 再次访问 Servlet。明显地，取到的就是 Cookie 的值 显示上次浏览过商品 我就以书籍为例子了！首先设计 Book 对象 123456789101112131415private String id ;private String name ;private String author;public Book() &#123;&#125;public Book(String id, String name, String author) &#123; this.id = id; this.name = name; this.author = author;&#125;...各种set、get方法 设计一个简单的数据库存储数据。就用 LinkedHashMap 集合【根据商品的 id 找书籍所以用 Map，删改较多所以用 Linked】 12345678910111213141516private static LinkedHashMap&lt;String, Book&gt; linkedHashMap = new LinkedHashMap();//简化开发复杂度，book的id和商品的id相同static &#123; linkedHashMap.put(&quot;1&quot;, new Book(&quot;1&quot;, &quot;javaweb&quot;, &quot;zhong&quot;)); linkedHashMap.put(&quot;2&quot;, new Book(&quot;2&quot;, &quot;java&quot;, &quot;fu&quot;)); linkedHashMap.put(&quot;3&quot;, new Book(&quot;3&quot;, &quot;oracle&quot;, &quot;cheng&quot;)); linkedHashMap.put(&quot;4&quot;, new Book(&quot;4&quot;, &quot;mysql&quot;, &quot;ou&quot;)); linkedHashMap.put(&quot;5&quot;, new Book(&quot;5&quot;, &quot;ajax&quot;, &quot;zi&quot;));&#125;//获取到所有书籍public static LinkedHashMap getAll() &#123; return linkedHashMap;&#125; 显示网页上所有的书籍【首页】 123456789101112printWriter.write(&quot;网页上所有的书籍：&quot;+&quot;&lt;br/&gt;&quot;);//拿到数据库所有的书LinkedHashMap&lt;String, Book&gt; linkedHashMap = DB.getAll();Set&lt;Map.Entry&lt;String, Book&gt;&gt; entry = linkedHashMap.entrySet();//显示所有的书到网页上for (Map.Entry&lt;String, Book&gt; stringBookEntry : entry) &#123; Book book = stringBookEntry.getValue(); printWriter.write(book.getId() +&quot; &quot;+ book.getName()+&quot;&lt;br/&gt;&quot;);&#125; 接着，我们要做的就是给显示的书籍挂上一个超链接，当用户点击想看的书籍时，就跳转到该书籍的详细信息页面 超链接应该把书的 id 传递过去，不然处理页面是不知道用户想看的是哪一本书的！ 1234567//显示所有的书到网页上for (Map.Entry&lt;String, Book&gt; stringBookEntry : entry) &#123; Book book = stringBookEntry.getValue(); printWriter.write(&quot;&lt;a href=&apos;/ouzicheng/Servlet2?id=&quot; + book.getId() + &quot;&apos;&apos;target=_blank&apos; +&quot; + book.getName() + &quot;&lt;/a&gt;&quot;); printWriter.write(&quot;&lt;br/&gt;&quot;);&#125; 接收 id，找到用户想要看哪一本书，输出该书的详细信息 12345678910String id = request.getParameter(&quot;id&quot;);//由于book的id和商品的id是一致的。获取到用户点击的书Book book = (Book) DB.getAll().get(id);//输出书的详细信息printWriter.write(&quot;书的编号是：&quot; + book.getId()+&quot;&lt;br/&gt;&quot;);printWriter.write(&quot;书的名称是：&quot; + book.getName()+&quot;&lt;br/&gt;&quot;);printWriter.write(&quot;书的作者是：&quot; + book.getAuthor()+&quot;&lt;br/&gt;&quot;); 点击想要的书籍。 得到书籍的详细信息 既然用户点击了书籍，那么服务器就应该颁发 Cookie 给浏览器，记住用户点击了该书籍 现在问题来了，Cookie 的值应该是什么呢？试想一下，待会还要把浏览过的书籍显示出来，所以用书籍的 id 是最好不过的。想到了用书籍的 id 作为 Cookie 的值，我们还要定义一些规则！ 我们可能有非常多的书籍，不可能把用户浏览过的书籍都显示出来。所以我们定义只能显示 3 本浏览过的书籍 书籍的 id 都是数字，如果不做任何修改，存到 Cookie 里边可能就是 231，345，123 此类的数字，这样取出某一个 id 的时候就十分费劲并且后面还要判断该书是否存在 Cookie 里边了，所以我们要把存储到 Cookie 的书籍 id 分割起来。所以我们定义”_“作为分隔符 按上面的应用，我们的逻辑应该是：先遍历下 Cookie，看下有没有我们想要的 Cookie。如果找到想要的 Cookie，那就取出 Cookie 的值 12345678String bookHistory = null;Cookie[] cookies = request.getCookies();for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; if (cookies[i].getName().equals(&quot;bookHistory&quot;)) &#123; bookHistory = cookies[i].getValue(); &#125;&#125; 取出了 Cookie 的值也分几种情况 Cookie 的值为 null【直接把传入进来的 id 当做是 Cookie 的值】 Cookie 的值长度有 3 个了【把排在最后的 id 去掉，把传进来的 id 排在最前边】 Cookie 的值已经包含有传递进来的 id 了【把已经包含的 id 先去掉，再把 id 排在最前面】 Cookie 的值就只有 1 个或 2 个，直接把 id 排在最前边 123456789101112131415161718192021222324if (bookHistory == null) &#123; return id;&#125;//如果Cookie的值不是null的，那么就分解Cookie的得到之前的id。String[] strings = bookHistory.split(&quot;\\_&quot;);//为了增删容易并且还要判断id是否存在于该字符串内-----我们使用LinkedList集合装载分解出来的idList list = Arrays.asList(strings);LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();linkedList.addAll(list);if (linkedList.contains(id)) &#123; linkedList.remove(id); linkedList.addFirst(id);&#125;else &#123; if (linkedList.size() &gt;= 3) &#123; linkedList.removeLast(); linkedList.addFirst(id); &#125; else &#123; linkedList.addFirst(id); &#125;&#125; 这么折腾完了，我们的 Cookie 值就在 LinkedList 集合里边了。接下来，我们要做的就是把集合中的值取出来，拼接成一个字符串 12345678910StringBuffer stringBuffer = new StringBuffer();//遍历LinkedList集合，添加个下划线“_”for (String s : linkedList) &#123; stringBuffer.append(s + &quot;_&quot;);&#125;//最后一个元素后面就不需要下划线了return stringBuffer.deleteCharAt(stringBuffer.length() - 1).toString(); 好的，我们现在已经完成了 Cookie 值了。接下来设置 Cookie 的生命周期，回送给浏览器即可 12345String bookHistory = makeHistory(request, id);Cookie cookie = new Cookie(&quot;bookHistory&quot;, bookHistory);cookie.setMaxAge(30000);response.addCookie(cookie); 既然我们已经把 Cookie 回送给浏览器了。那么接下来我们就在首页上获取 Cookie 的值，显示用户浏览过什么商品就行了！ 123456789101112131415161718192021222324252627282930printWriter.write(&quot;您曾经浏览过的商品：&quot;);printWriter.write(&quot;&lt;br/&gt;&quot;);//显示用户浏览过的商品Cookie[] cookies = request.getCookies();for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; if (cookies[i].getName().equals(&quot;bookHistory&quot;)) &#123; //获取到的bookHistory是2_3_1之类的 String bookHistory = cookies[i].getValue(); //拆解成每一个id值 String[] ids = bookHistory.split(&quot;\\_&quot;); //得到每一个id值 for (String id : ids) &#123; //通过id找到每一本书 Book book = linkedHashMap.get(id); printWriter.write(book.getName()); printWriter.write(&quot;&lt;br/&gt;&quot;); &#125; break; &#125;&#125; 好的，我们来试验一下吧！！，第一次访问首页，并没有浏览过的商品 当我点击 javaweb 书籍再访问首页的时候 再点击 ajax 然后访问首页 再点击 javaweb 然后访问首页 点击 oracle 然后访问首页 好的，经过测试，该程序应该没有什么问题了！ Servlet 第六篇【Session 介绍、API、生命周期、应用、与 Cookie 区别】什么是 Session Session 是另一种记录浏览器状态的机制。不同的是 Cookie 保存在浏览器中，Session 保存在服务器中。用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器，这就是 Session 如果说 Cookie 是检查用户身上的”通行证 “来确认用户的身份，那么 Session 就是通过检查服务器上的” 客户明细表“来确认用户的身份的。Session 相当于在服务器中建立了一份“客户明细表”。 为什么要使用 Session 技术？Session 比 Cookie 使用方便，Session 可以解决 Cookie 解决不了的事情【Session 可以存储对象，Cookie 只能存储字符串。】。 Session API long getCreationTime();【获取 Session 被创建时间】 String getId();【获取 Session 的 id】 long getLastAccessedTime();【返回 Session 最后活跃的时间】 ServletContext getServletContext();【获取 ServletContext 对象】 void setMaxInactiveInterval(int var1);【设置 Session 超时时间】 int getMaxInactiveInterval();【获取 Session 超时时间】 Object getAttribute(String var1);【获取 Session 属性】 Enumeration void setAttribute(String var1, Object var2);【设置 Session 属性】 void removeAttribute(String var1);【移除 Session 属性】 void invalidate();【销毁该 Session】 boolean isNew();【该 Session 是否为新的】 Session 作为域对象从上面的 API 看出，Session 有着 request 和 ServletContext 类似的方法。其实 Session 也是一个域对象。Session 作为一种记录浏览器状态的机制，只要 Session 对象没有被销毁，Servlet 之间就可以通过 Session 对象实现通讯 我们来试试吧，在 Servlet4 中设置 Session 属性 123456//得到Session对象HttpSession httpSession = request.getSession();//设置Session属性httpSession.setAttribute(&quot;name&quot;, &quot;看完博客就要点赞！！&quot;); 在 Servlet5 中获取到 Session 存进去的属性 12345//获取到从Servlet4的Session存进去的值HttpSession httpSession = request.getSession();String value = (String) httpSession.getAttribute(&quot;name&quot;);System.out.println(value); 访问 Servlet4，再访问 Servlet5 一般来讲，当我们要存进的是用户级别的数据就用 Session，那什么是用户级别呢？只要浏览器不关闭，希望数据还在，就使用 Session 来保存。 Session 的生命周期和有效期 Session 在用户第一次访问服务器 Servlet，jsp 等动态资源就会被自动创建，Session 对象保存在内存里，这也就为什么上面的例子可以直接使用 request 对象获取得到 Session 对象。 如果访问 HTML,IMAGE 等静态资源 Session 不会被创建。 Session 生成后，只要用户继续访问，服务器就会更新 Session 的最后访问时间，无论是否对 Session 进行读写，服务器都会认为 Session 活跃了一次。 由于会有越来越多的用户访问服务器，因此 Session 也会越来越多。为了防止内存溢出，服务器会把长时间没有活跃的 Session 从内存中删除，这个时间也就是 Session 的超时时间。 Session 的超时时间默认是 30 分钟，有三种方式可以对 Session 的超时时间进行修改 第一种方式：在 tomcat/conf/web.xml 文件中设置，时间值为 20 分钟，所有的 WEB 应用都有效 1234&lt;session-config&gt; &lt;session-timeout&gt;20&lt;/session-timeout&gt;&lt;/session-config&gt; 第二种方式：在单个的 web.xml 文件中设置，对单个 web 应用有效，如果有冲突，以自己的 web 应用为准。 1234&lt;session-config&gt; &lt;session-timeout&gt;20&lt;/session-timeout&gt;&lt;/session-config&gt; 第三种方式：通过 setMaxInactiveInterval() 方法设置 12345//设置Session最长超时时间为60秒，这里的单位是秒httpSession.setMaxInactiveInterval(60);System.out.println(httpSession.getMaxInactiveInterval()); Session 的有效期与 Cookie 的是不同的 使用 Session 完成简单的购物功能 我们还是以书籍为例，所以可以 copy“显示浏览过的商品 “例子部分的代码。 1234567891011121314151617181920response.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter printWriter = response.getWriter();printWriter.write(&quot;网页上所有的书籍：&quot; + &quot;&lt;br/&gt;&quot;);//拿到数据库所有的书LinkedHashMap&lt;String, Book&gt; linkedHashMap = DB.getAll();Set&lt;Map.Entry&lt;String, Book&gt;&gt; entry = linkedHashMap.entrySet();//显示所有的书到网页上for (Map.Entry&lt;String, Book&gt; stringBookEntry : entry) &#123; Book book = stringBookEntry.getValue(); String url = &quot;/ouzicheng/Servlet6?id=&quot; + book.getId(); printWriter.write(book.getName()); printWriter.write(&quot;&lt;a href=&apos;&quot; + url + &quot;&apos;&gt;购买&lt;/a&gt;&quot;); printWriter.write(&quot;&lt;br/&gt;&quot;);&#125; 在购物车页面上，获取到用户想买的书籍【用户可能不单想买一本书，于是乎，就用一个 List 容器装载书籍】，有了：先遍历 Cookie，再判断是否是第一次访问 Servlet 的逻辑思路，我们就可以先获取到 Session 的属性，如果 Session 的属性为 null，那么就是还没有该属性 123456789101112131415161718192021//得到用户想买书籍的idString id = request.getParameter(&quot;id&quot;);//根据书籍的id找到用户想买的书Book book = (Book) DB.getAll().get(id);//获取到Session对象HttpSession httpSession = request.getSession();//由于用户可能想买多本书的，所以我们用一个容器装着书籍List list = (List) httpSession.getAttribute(&quot;list&quot;);if (list == null) &#123; list = new ArrayList(); //设置Session属性 httpSession.setAttribute(&quot;list&quot;,list);&#125;//把书籍加入到list集合中list.add(book); 按我们正常的逻辑思路：先创建一个 ArrayList 对象，把书加到 list 集合中，然后设置 Session 的属性。这样是行不通的。每次 Servlet 被访问的时候都会创建一个 ArrayList 集合，书籍会被分发到不同的 ArrayList 中去。所以下面的代码是不行的！ 123456789101112131415//得到用户想买书籍的idString id = request.getParameter(&quot;id&quot;);//根据书籍的id找到用户想买的书Book book = (Book) DB.getAll().get(id);//获取到Session对象HttpSession httpSession = request.getSession();//创建List集合List list = new ArrayList();list.add(book);httpSession.setAttribute(&quot;list&quot;, list); 既然用户已经购买了书籍，那么也应该给提供页面显示用户购买过哪些书籍 123456789101112131415161718192021222324//得到用户想买书籍的idString id = request.getParameter(&quot;id&quot;);//根据书籍的id找到用户想买的书Book book = (Book) DB.getAll().get(id);//获取到Session对象HttpSession httpSession = request.getSession();//由于用户可能想买多本书的，所以我们用一个容器装着书籍List list = (List) httpSession.getAttribute(&quot;list&quot;);if (list == null) &#123; list = new ArrayList(); //设置Session属性 httpSession.setAttribute(&quot;list&quot;,list);&#125;//把书籍加入到list集合中list.add(book);String url = &quot;/ouzicheng/Servlet7&quot;;response.sendRedirect(url); 列出用户购买过的书籍 12345678910111213141516//要得到用户购买过哪些书籍，得到Session的属性遍历即可HttpSession httpSession = request.getSession();List&lt;Book&gt; list = (List) httpSession.getAttribute(&quot;list&quot;);if (list == null || list.size() == 0) &#123; printWriter.write(&quot;对不起，你还没有买过任何商品&quot;);&#125; else &#123; printWriter.write(&quot;您购买过以下商品：&quot;); printWriter.write(&quot;&lt;br/&gt;&quot;); for (Book book : list) &#123; printWriter.write(book.getName()); printWriter.write(&quot;&lt;br/&gt;&quot;); &#125;&#125; 效果如下 Session 的实现原理 用现象说明问题，我在 Servlet4 中的代码设置了 Session 的属性 123456//得到Session对象HttpSession httpSession = request.getSession();//设置Session属性httpSession.setAttribute(&quot;name&quot;, &quot;看完博客就要点赞！！&quot;); 接着在 Servlet7 把 Session 的属性取出来 1234String value = (String) request.getSession().getAttribute(&quot;name&quot;);printWriter.write(value); 自然地，我们能取到在 Servlet4 中 Session 设置的属性 接着，我在浏览器中新建一个会话，再次访问 Servlet7 发现报了空指针异常的错误 现在问题来了：服务器是如何实现一个 session 为一个用户浏览器服务的？换个说法：为什么服务器能够为不同的用户浏览器提供不同 session？ HTTP 协议是无状态的，Session 不能依据 HTTP 连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为 JESSIONID 的 Cookie，它的值是 Session 的 id 值。其实 Session 依据 Cookie 来识别是否是同一个用户。 简单来说：Session 之所以可以识别不同的用户，依靠的就是 Cookie 该 Cookie 是服务器自动颁发给浏览器的，不用我们手工创建的。该 Cookie 的 maxAge 值默认是 - 1，也就是说仅当前浏览器使用，不将该 Cookie 存在硬盘中 我们来捋一捋思路流程：当我们访问 Servlet4 的时候，服务器就会创建一个 Session 对象，执行我们的程序代码，并自动颁发个 Cookie 给用户浏览器 当我们用同一个浏览器访问 Servlet7 的时候，浏览器会把 Cookie 的值通过 http 协议带过去给服务器，服务器就知道用哪一 Session。 而当我们使用新会话的浏览器访问 Servlet7 的时候，该新浏览器并没有 Cookie，服务器无法辨认使用哪一个 Session，所以就获取不到值 浏览器禁用了 Cookie，Session 还能用吗？上面说了 Session 是依靠 Cookie 来识别用户浏览器的。如果我的用户浏览器禁用了 Cookie 了呢？绝大多数的手机浏览器都不支持 Cookie，那我的 Session 怎么办？ 好的，我们来看看情况是怎么样的。用户浏览器访问 Servlet4 的时候，服务器向用户浏览器颁发了一个 Cookie 但是呢，当用户浏览器访问 Servlet7 的时候，由于我们禁用了 Cookie，所以用户浏览器并没有把 Cookie 带过去给服务器。 一看，Session 好像不能用了。但是 Java Web 提供了解决方法：URL 地址重写 HttpServletResponse 类提供了两个 URL 地址重写的方法： encodeURL(String url) encodeRedirectURL(String url) 需要值得注意的是：这两个方法会自动判断该浏览器是否支持 Cookie，如果支持 Cookie，重写后的 URL 地址就不会带有 jsessionid 了【当然了，即使浏览器支持 Cookie，第一次输出 URL 地址的时候还是会出现 jsessionid（因为没有任何 Cookie 可带）】 下面我们就以上面 “购物” 的例子来做试验吧！首先我们来看看禁用掉 Cookie 对原来的小例子有什么影响。 访问 Servlet1，随便点击一本书籍购买 无论点击多少次，都会直接提示我们有买过任何商品 原因也非常简单，没有 Cookie 传递给服务器，服务器每次创建的时候都是新的 Session，导致最后获取到的 List 集合一定是空的。 不同 Servlet 获取到的 Session 的 id 号都是不同的。 下面我们就对 URL 进行重写，看看能不能恢复没有禁掉 Cookie 之前的效果。 原则：把 Session 的属性带过去【传递给】另外一个 Servlet，都要 URL 地址重写 在跳转到显示购买过商品的 Servlet 的时候，URL 地址重写。 1234String url = &quot;/ouzicheng/Servlet7&quot;;response.sendRedirect(response.encodeURL(url)); 再次访问 Servlet1，当我点击 javaweb 的时候，已经能够成功出现我买过的商品了。并且 Session 的 id 通过 URL 地址重写，使用的是同一个 Session URL 地址重写的原理：将 Session 的 id 信息重写到 URL 地址中。服务器解析重写后 URL，获取 Session 的 id。这样一来，即使浏览器禁用掉了 Cookie，但 Session 的 id 通过服务器端传递，还是可以使用 Session 来记录用户的状态。 Session 禁用 Cookie Java Web 规范支持通过配置禁用 Cookie 禁用自己项目的 Cookie 在 META-INF 文件夹下的 context.xml 文件中修改（没有则创建） 12345&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;Context path=&quot;/ouzicheng&quot; cookies=&quot;false&quot;&gt;&lt;/Context&gt; 禁用全部 web 应用的 Cookie 在 conf/context.xml 中修改 注意：该配置只是让服务器不能自动维护名为 jsessionid 的 Cookie，并不能阻止 Cookie 的读写。 Session 案例使用 Session 完成用户简单登陆 先创建 User 类 12345678910111213private String username = null;private String password = null;public User() &#123;&#125;public User(String username, String password) &#123; this.username = username; this.password = password;&#125;....各种set、get方法 使用简单的集合模拟一个数据库 1234567891011121314151617181920212223private static List&lt;User&gt; list = new ArrayList&lt;&gt;();//装载些数据进数据库static &#123; list.add(new User(&quot;aaa&quot;,&quot;111&quot;)); list.add(new User(&quot;bbb&quot;,&quot;222&quot;)); list.add(new User(&quot;ccc&quot;,&quot;333&quot;));&#125;//通过用户名和密码查找用户public static User find(String username, String password) &#123; for (User user : list) &#123; if (user.getUsername().equals(username) &amp;&amp; user.getPassword().equals(password)) &#123; return user; &#125; &#125; return null;&#125; 表单提交的工作我就在 jsp 写了，如果在 Servlet 写太麻烦了！ 1234567&lt;form action=&quot;/ouzicheng/LoginServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 获取到表单提交的数据，查找数据库是否有相对应的用户名和密码。如果没有就提示用户名或密码出错了，如果有就跳转到另外一个页面 123456789101112131415161718String username = request.getParameter(&quot;username&quot;);String password = request.getParameter(&quot;password&quot;);User user = UserDB.find(username, password);//如果找不到，就是用户名或密码出错了。if (user == null) &#123; response.getWriter().write(&quot;you can&apos;t login&quot;); return;&#125;//标记着该用户已经登陆了！HttpSession httpSession = request.getSession();httpSession.setAttribute(&quot;user&quot;, user);//跳转到其他页面，告诉用户成功登陆了。response.sendRedirect(response.encodeURL(&quot;index.jsp&quot;)); 我们来试试下数据库没有的用户名和密码，提示我不能登陆。 试试数据库存在的用户名和密码 利用 Session 防止表单重复提交 重复提交的危害： 在投票的网页上不停地提交，实现了刷票的效果。 注册多个用户，不断发帖子，扰乱正常发帖秩序。 首先我们来看一下常见的重复提交。 在处理表单的 Servlet 中刷新。 后退再提交 网络延迟，多次点击提交按钮 下面的 gif 是后退再提交，在处理提交请求的 Servlet 中刷新 下面的 gif 是网络延迟，多次点击提交按钮 对于网络延迟造成的多次提交数据给服务器，其实是客户端的问题。于是，我们可以使用 javaScript 来防止这种情况 要做的事情也非常简单：当用户第一次点击提交按钮时，把数据提交给服务器。当用户再次点击提交按钮时，就不把数据提交给服务器了。 监听用户提交事件。只能让用户提交一次表单！ 12345678910111213141516171819202122232425262728293031323334&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;表单提交&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //定义一个全局标识量：是否已经提交过表单数据 var isCommitted = false; function doSubmit() &#123; //false表示的是没有提交过，于是就可以让表单提交给Servlet if(isCommitted==false) &#123; isCommitted = true; return true; &#125;else &#123; return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/ouzicheng/Servlet7&quot; onsubmit=&quot;return doSubmit()&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 好的，我们来试一下是不是真的可以解决网络延迟所造成的多次提交表单数据，注意鼠标，我已经点击过很多次的了！ 由于网络延迟造成的多次提交数据给服务器，我们还可以使用 javaScript 代码这样解决：当我点击过一次提交按钮时，我就把提交的按钮隐藏起来。不能让用户点击了！ 想要让按钮隐藏起来，也很简单。只要获取到按钮的节点，就可以控制按钮的隐藏或显示了！ 12345678910&lt;script type=&quot;text/javascript&quot;&gt; function doSubmit() &#123; var button = document.getElementById(&quot;button&quot;); button.disabled = disabled; return true; &#125;&lt;/script&gt; 我们再来看一下效果 在处理表单的 Servlet 中刷新和后退再提交这两种方式不能只靠客户端来限制了。也就是说 javaScript 代码无法阻止这两种情况的发生。 于是乎，我们就想得用其他办法来阻止表单数据重复提交了。我们现在学了 Session，Session 可以用来标识一个用户是否登陆了。Session 的原理也说了：不同的用户浏览器会拥有不同的 Session。而 request 和 ServletContext 为什么就不行呢？request 的域对象只能是一次 http 请求，提交表单数据的时候 request 域对象的数据取不出来。ServletContext 代表整个 web 应用，如果有几个用户浏览器同时访问，ServletContext 域对象的数据会被多次覆盖掉，也就是说域对象的数据就毫无意义了。 可能到这里，我们会想到：在提交数据的时候，存进 Session 域对象的数据，在处理提交数据的 Servlet 中判断 Session 域对象数据????。究竟判断 Session 什么？判断 Session 域对象的数据不为 null？没用呀，既然已经提交过来了，那肯定不为 null。 此时，我们就想到了，在表单中还有一个隐藏域，可以通过隐藏域把数据交给服务器。 判断 Session 域对象的数据和 jsp 隐藏域提交的数据是否对应。 判断隐藏域的数据是否为空【如果为空，就是直接访问表单处理页面的 Servlet】 判断 Session 的数据是否为空【servlet 判断完是否重复提交，最好能立马移除 Session 的数据，不然还没有移除的时候，客户端那边儿的请求又来了，就又能匹配了，产生了重复提交。如果 Session 域对象数据为空，证明已经提交过数据了！】 我们向 Session 域对象的存入数据究竟是什么呢？简单的一个数字？好像也行啊。因为只要 Session 域对象的数据和 jsp 隐藏域带过去的数据对得上号就行了呀，反正在 Servlet 上判断完是否重复提交，会立马把 Session 的数据移除掉的。更专业的做法是：向 Session 域对象存入的数据是一个随机数【Token– 令牌】。 生成一个独一无二的随机数 123456789101112131415161718192021222324252627282930313233343536373839404142/** 产生随机数就应该用一个对象来生成，这样可以避免随机数的重复。* 所以设计成单例* */public class TokenProcessor &#123; private TokenProcessor() &#123; &#125; private final static TokenProcessor TOKEN_PROCESSOR = new TokenProcessor(); public static TokenProcessor getInstance() &#123; return TOKEN_PROCESSOR; &#125; public static String makeToken() &#123; //这个随机生成出来的Token的长度是不确定的 String token = String.valueOf(System.currentTimeMillis() + new Random().nextInt(99999999)); try &#123; //我们想要随机数的长度一致，就要获取到数据指纹 MessageDigest messageDigest = MessageDigest.getInstance(&quot;md5&quot;); byte[] md5 = messageDigest.digest(token.getBytes()); //如果我们直接 return new String(md5)出去，得到的随机数会乱码。 //因为随机数是任意的01010101010，在转换成字符串的时候，会查gb2312的码表，gb2312码表不一定支持该二进制数据，得到的就是乱码 //于是乎经过base64编码成了明文的数据 BASE64Encoder base64Encoder = new BASE64Encoder(); return base64Encoder.encode(md5); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 创建 Token 随机数，并跳转到 jsp 页面 12345678910//生出随机数TokenProcessor tokenProcessor = TokenProcessor.getInstance();String token = tokenProcessor.makeToken();//将随机数存进Session中request.getSession().setAttribute(&quot;token&quot;, token);//跳转到显示页面request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response); jsp 隐藏域获取到 Session 的值 12345678910&lt;form action=&quot;/ouzicheng/Servlet7&quot; &gt; 用户名：&lt;input type=&quot;text&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;button&quot;&gt; &lt;%--使用EL表达式取出session中的Token--%&gt; &lt;input type=&quot;hidden&quot; $&#123;token&#125;&quot; &gt;&lt;/form&gt; 在处理表单提交页面中判断：jsp 隐藏域是否有值带过来，Session 中的值是否为空，Session 中的值和 jsp 隐藏域带过来的值是否相等 123456789101112131415String serverValue = (String) request.getSession().getAttribute(&quot;token&quot;);String clientValue = request.getParameter(&quot;token&quot;);if (serverValue != null &amp;&amp; clientValue != null &amp;&amp; serverValue.equals(clientValue)) &#123; System.out.println(&quot;处理请求&quot;); //清除Session域对象数据 request.getSession().removeAttribute(&quot;token&quot;);&#125;else &#123; System.out.println(&quot;请不要重复提交数据！&quot;);&#125; 下面我们再来看一下, 已经可以解决表单重复提交的问题了！ 实现原理是非常简单的： 在 session 域中存储一个 token 然后前台页面的隐藏域获取得到这个 token 在第一次访问的时候，我们就判断 seesion 有没有值，如果有就比对。对比正确后我们就处理请求，接着就把 session 存储的数据给删除了 等到再次访问的时候，我们 session 就没有值了，就不受理前台的请求了！ 一次性校验码 一次性校验码其实就是为了防止暴力猜测密码 在讲 response 对象的时候，我们使用 response 对象输出过验证码，但是没有去验证！ 验证的原理也非常简单：生成验证码后，把验证码的数据存进 Session 域对象中，判断用户输入验证码是否和 Session 域对象的数据一致。 生成验证码图片，并将验证码存进 Session 域中 123456789101112131415161718192021222324252627282930313233//在内存中生成图片BufferedImage bufferedImage = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB);//获取到这张图片Graphics2D graphics2D = (Graphics2D) bufferedImage.getGraphics();//设置背景色为白色graphics2D.setColor(Color.white);graphics2D.fillRect(0, 0, 80, 20);//设置图片的字体和颜色graphics2D.setFont(new Font(null, Font.BOLD, 20));graphics2D.setColor(Color.BLUE);//生成随机数String randomNum = makeNum();//往这张图片上写数据,横坐标是0，纵坐标是20graphics2D.drawString(randomNum, 0, 20);//将随机数存进Session域中request.getSession().setAttribute(&quot;randomNum&quot;, randomNum);//控制浏览器不缓存该图片response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);//通知浏览器以图片的方式打开response.setHeader(&quot;Content-type&quot;, &quot;image/jpeg&quot;);//把图片写给浏览器ImageIO.write(bufferedImage, &quot;jpg&quot;, response.getOutputStream()); 生成随机数的方法： 1234567891011121314151617181920private String makeNum() &#123; Random random = new Random(); //生成0-6位的随机数 int num = random.nextInt(999999); //验证码的数位全都要6位数，于是将该随机数转换成字符串，不够位数就添加 String randomNum = String.valueOf(num); //使用StringBuffer来拼凑字符串 StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; 6 - randomNum.length(); i++) &#123; stringBuffer.append(&quot;0&quot;); &#125; return stringBuffer.append(randomNum).toString();&#125; jsp 显示页面 1234567891011&lt;form action=&quot;/ouzicheng/Login2Servlet&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br&gt; 验证码：&lt;input type=&quot;text&quot; &gt; &lt;img src=&quot;/ouzicheng/ImageServlet&quot; &gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 处理提交表单数据的 Servlet，判断用户带过来验证码的数据是否和 Session 的数据相同。 1234567891011121314//获取用户输入验证码的数据String client_randomNum = request.getParameter(&quot;randomNum&quot;);//获取Session中的数据String session_randomNum = (String) request.getSession().getAttribute(&quot;randomNum&quot;);//判断他俩数据是否相等，用户是否有输入验证码，Session中是否为空if (client_randomNum == null || session_randomNum == null || !client_randomNum.equals(session_randomNum)) &#123; System.out.println(&quot;验证码错误了！！！&quot;); return ;&#125;//下面就是验证用户名和密码................... 显示页面是这样子的 我们来看一下效果！ 对于校验码实现思路是这样子的： 使用 awt 语法来描写一张验证码，生成随机数保存在 seesion 域中，我们让验证码不能缓存起来【做到验证码都不一样】 页面直接访问 Servlet 来获取我们的验证码，于是我们验证码的值就会改变【同时 session 的值也会被改变】 当用户验证的时候，就是 session 内的值的验证了。 Session 和 Cookie 的区别 从存储方式上比较 Cookie 只能存储字符串，如果要存储非 ASCII 字符串还要对其编码。 Session 可以存储任何类型的数据，可以把 Session 看成是一个容器 从隐私安全上比较 Cookie 存储在浏览器中，对客户端是可见的。信息容易泄露出去。如果使用 Cookie，最好将 Cookie 加密 Session 存储在服务器上，对客户端是透明的。不存在敏感信息泄露问题。 从有效期上比较 Cookie 保存在硬盘中，只需要设置 maxAge 属性为比较大的正整数，即使关闭浏览器，Cookie 还是存在的 Session 的保存在服务器中，设置 maxInactiveInterval 属性值来确定 Session 的有效期。并且 Session 依赖于名为 JSESSIONID 的 Cookie，该 Cookie 默认的 maxAge 属性为 - 1。如果关闭了浏览器，该 Session 虽然没有从服务器中消亡，但也就失效了。 从对服务器的负担比较 Session 是保存在服务器的，每个用户都会产生一个 Session，如果是并发访问的用户非常多，是不能使用 Session 的，Session 会消耗大量的内存。 Cookie 是保存在客户端的。不占用服务器的资源。像 baidu、Sina 这样的大型网站，一般都是使用 Cookie 来进行会话跟踪。 从浏览器的支持上比较 如果浏览器禁用了 Cookie，那么 Cookie 是无用的了！ 如果浏览器禁用了 Cookie，Session 可以通过 URL 地址重写来进行会话跟踪。 从跨域名上比较 Cookie 可以设置 domain 属性来实现跨域名 Session 只在当前的域名内有效，不可夸域名 Cookie 和 Session 共同使用 如果仅仅使用 Cookie 或仅仅使用 Session 可能达不到理想的效果。这时应该尝试一下同时使用 Session 和 Cookie 那么，什么时候才需要同时使用 Cookie 和 Session 呢？ 在上一篇博客中，我们使用了 Session 来进行简单的购物，功能也的确实现了。现在有一个问题：我在购物的途中，不小心关闭了浏览器。当我再返回进去浏览器的时候，发现我购买过的商品记录都没了！！为什么会没了呢？原因也非常简单：服务器为 Session 自动维护的 Cookie 的 maxAge 属性默认是 - 1 的，当浏览器关闭掉了，该 Cookie 就自动消亡了。当用户再次访问的时候，已经不是原来的 Cookie 了。 我们现在想的是：即使我不小心关闭了浏览器了，我重新进去网站，我还能找到我的购买记录。 要实现该功能也十分简单，问题其实就在：服务器为 Session 自动维护的 Cookie 的 maxAge 属性是 - 1，Cookie 没有保存在硬盘中。我现在要做的就是：把 Cookie 保存在硬盘中，即使我关闭了浏览器，浏览器再次访问页面的时候，可以带上 Cookie，从而服务器识别出 Session。 第一种方式：只需要在处理购买页面上创建 Cookie，Cookie 的值是 Session 的 id 返回给浏览器即可 12345Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,session.getId());cookie.setMaxAge(30*60);cookie.setPath(&quot;/ouzicheng/&quot;);response.addCookie(cookie); 第二种方式： 在 server.xml 文件中配置，将每个用户的 Session 在服务器关闭的时候序列化到硬盘或数据库上保存。但此方法不常用，知道即可！ 下面看一下效果 参考：Servlet+JSP - 文集 - 简书https://www.jianshu.com/nb/21926044]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat+Servlet面试总结]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28%2F</url>
    <content type="text"><![CDATA[Servlet 知识点: 图上的知识点都可以在我其他的文章内找到相应内容。 Tomcat 常见面试题Tomcat 的缺省端口是多少，怎么修改 Tomcat 的缺省端口是多少，怎么修改 找到 Tomcat 目录下的 conf 文件夹 进入 conf 文件夹里面找到 server.xml 文件 打开 server.xml 文件 在 server.xml 文件里面找到下列信息 12345&lt;Service &gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 把 port=”8080″改成 port=”8888″，并且保存 启动 Tomcat，并且在 IE 浏览器里面的地址栏输入 http://127.0.0.1:8888/ 到 tomcat 主目录下的 conf/server.xml 文件中修改, 把 8080 端口改成是 8088 或者是其他的 Tomcat 有哪几种 Connector 运行模式 (优化)？ tomcat 有哪几种 Connector 运行模式 (优化)？ bio(blocking I/O) nio(non-blocking I/O) apr(Apache Portable Runtime/Apache 可移植运行库) 相关解释: bio: 传统的 Java I/O 操作，同步且阻塞 IO。 nio: JDK1.4 开始支持，同步阻塞或同步非阻塞 IO aio(nio.2): JDK7 开始支持，异步非阻塞 IO apr: Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高 Tomcat 对静态文件的处理性能 下面是配置 Tomcat 运行模式改成是 NIO 模式，并配置连接池相关参数来进行优化: 1234567891011121314151617181920&lt;!--&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;--&gt;&lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;&lt;!-- minProcessors最小空闲连接线程数--&gt;&lt;!-- maxProcessors最大连接线程数--&gt;&lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;&lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443 maxThreads=“500” minSpareThreads=“100” maxSpareThreads=“200” acceptCount=&quot;200&quot; enableLookups=&quot;false&quot; /&gt; apr 模式启动起来是比较复杂的，详情可参考:http://blog.csdn.net/wanglei_storage/article/details/50225779 对于 bio,nio,nio.2 的理解可参考:http://blog.csdn.net/itismelzp/article/details/50886009 Tomcat 有几种部署方式 直接把 Web 项目放在 webapps 下，Tomcat 会自动将其部署 在 server.xml 文件上配置&lt;Context&gt;节点，设置相关的属性即可 通过 Catalina 来进行配置: 进入到 conf\Catalina\localhost 文件下，创建一个 xml 文件，该文件的名字就是站点的名字。编写 XML 的方式来进行设置。 部署方式第二点： 在其他盘符下创建一个 web 站点目录，并创建 WEB-INF 目录和一个 html 文件。 找到 Tomcat 目录下 / conf/server.xml 文件 在 server.xml 中的节点下添加如下代码。path 表示的是访问时输入的 web 项目名，docBase 表示的是站点目录的绝对路径 12&lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt; 访问配置好的 web 站点 部署方式第三点： 进入到 conf\Catalina\localhost 文件下，创建一个 xml 文件，该文件的名字就是站点的名字。 xml 文件的代码如下，docBase 是你 web 站点的绝对路径 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Context docBase=&quot;D:\web1&quot; reloadable=&quot;true&quot;&gt; &lt;/Context&gt; 访问 web 站点下的 html 资源 Servlet 面试题Servlet 生命周期 Servlet 生命周期? 第一次访问 Servlet，我们发现 init() 和 service() 都被调用了 第二次访问 Servlet，service() 被调用了 第三次访问 Servlet，还是 service() 被调用了 当我们关闭 Tomcat 服务器的时候，destroy() 被调用了！ Servlet 生命周期可分为 5 个步骤 加载 Servlet。当 Tomcat 第一次访问 Servlet 的时候，Tomcat 会负责创建 Servlet 的实例 初始化。当 Servlet 被实例化后，Tomcat 会调用 init() 方法初始化这个对象 处理服务。当浏览器访问 Servlet 的时候，Servlet 会调用 service() 方法处理请求 销毁。当 Tomcat 关闭时或者检测到 Servlet 要从 Tomcat 删除的时候会自动调用 destroy() 方法，让该实例释放掉所占的资源。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁 卸载。当 Servlet 调用完 destroy() 方法后，等待垃圾回收。如果有需要再次使用这个 Servlet，会重新调用 init() 方法进行初始化操作。 简单总结：只要访问 Servlet，service() 就会被调用。init() 只有第一次访问 Servlet 的时候才会被调用。destroy() 只有在 Tomcat 关闭的时候才会被调用。 get 方式和 post 方式有何区别 get 方式和 post 方式有何区别 数据携带上: GET 方式：在 URL 地址后附带的参数是有限制的，其数据容量通常不能超过 1K。 POST 方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。 请求参数的位置上: GET 方式：请求参数放在 URL 地址后面，以? 的方式来进行拼接 POST 方式: 请求参数放在 HTTP 请求包中 用途上: GET 方式一般用来获取数据 POST 方式一般用来提交数据 原因: 首先是因为 GET 方式携带的数据量比较小，无法带过去很大的数量 POST 方式提交的参数后台更加容易解析 (使用 POST 方式提交的中文数据，后台也更加容易解决) GET 方式比 POST 方式要快GET 方式比 POST 方式要快，详情可看:https://www.cnblogs.com/strayling/p/3580048.html Servlet 相关 API doGet 与 doPost 方法的两个参数是什么 HttpServletRequest：封装了与请求相关的信息 HttpServletResponse：封装了与响应相关的信息 获取页面的元素的值有几种方式，分别说一下 request.getParameter() 返回客户端的请求参数的值 request.getParameterNames() 返回所有可用属性名的枚举 request.getParameterValues() 返回包含参数的所有值的数组 request.getAttribute() 和 request.getParameter() 区别 用途上: request.getAttribute()， 一般用于获取 request 域对象的数据 (在跳转之前把数据使用 setAttribute 来放到 request 对象上) request.getParameter()， 一般用于获取客户端提交的参数 存储数据上: request.getAttribute() 可以获取 Objcet 对象 request.getParameter() 只能获取字符串 (这也是为什么它一般用于获取客户端提交的参数) forward 和 redirect 的区别 forward 和 redirect 的区别 实际发生位置不同，地址栏不同 转发是发生在服务器的 转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问 Servlet111 的时候，即使跳转到了 Servlet222 的页面，浏览器的地址还是 Servlet111 的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的 http 请求，一次转发中 request 和 response 对象都是同一个。这也解释了，为什么可以使用 request 作为域对象进行 Servlet 之间的通讯。 重定向是发生在浏览器的 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。曾经介绍过：实现重定向的原理是由 response 的状态码和 Location 头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个 http 请求，request 域对象是无效的，因为它不是同一个 request 对象 用法不同: 很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 request.getRequestDispatcher(“/ 资源名 URI”).forward(request,response) 转发时”/” 代表的是本应用程序的根目录【zhongfucheng】 response.send(“/web 应用 / 资源名 URI”); 重定向时”/” 代表的是 webapps 目录 能够去往的 URL 的范围不一样: 转发是服务器跳转只能去往当前 web 应用的资源 重定向是服务器跳转，可以去往任何的资源 传递数据的类型不同 转发的 request 对象可以传递各种类型的数据，包括对象 重定向只能传递字符串 跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 那么转发 (forward) 和重定向 (redirect) 使用哪一个？ 根据上面说明了转发和重定向的区别也可以很容易概括出来。转发是带着转发前的请求的参数的。重定向是新的请求。 典型的应用场景： 转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变 重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了 tomcat 容器是如何创建 servlet 类实例？用到了什么原理？ tomcat 容器是如何创建 servlet 类实例？用到了什么原理 当容器启动时，会读取在 webapps 目录下所有的 web 应用中的 web.xml 文件，然后对 xml 文件进行解析，并读取 servlet 注册信息。然后，将每个应用中注册的 servlet 类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化） 在 servlet 注册时加上 1 如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。 什么是 cookie？Session 和 cookie 有什么区别？ 什么是 cookie？ Cookie 是由 W3C 组织提出，最早由 netscape 社区发展的一种机制 网页之间的交互是通过 HTTP 协议传输数据的，而 Http 协议是无状态的协议。无状态的协议是什么意思呢？一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接。 服务器无法确认用户的信息，于是乎，W3C 就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是 Cookie Session 和 cookie 有什么区别？ 从存储方式上比较 Cookie 只能存储字符串，如果要存储非 ASCII 字符串还要对其编码。 Session 可以存储任何类型的数据，可以把 Session 看成是一个容器 从隐私安全上比较 Cookie 存储在浏览器中，对客户端是可见的。信息容易泄露出去。如果使用 Cookie，最好将 Cookie 加密 Session 存储在服务器上，对客户端是透明的。不存在敏感信息泄露问题。 从有效期上比较 Cookie 保存在硬盘中，只需要设置 maxAge 属性为比较大的正整数，即使关闭浏览器，Cookie 还是存在的 Session 的保存在服务器中，设置 maxInactiveInterval 属性值来确定 Session 的有效期。并且 Session 依赖于名为 JSESSIONID 的 Cookie，该 Cookie 默认的 maxAge 属性为 - 1。如果关闭了浏览器，该 Session 虽然没有从服务器中消亡，但也就失效了。 从对服务器的负担比较 Session 是保存在服务器的，每个用户都会产生一个 Session，如果是并发访问的用户非常多，是不能使用 Session 的，Session 会消耗大量的内存。 Cookie 是保存在客户端的。不占用服务器的资源。像 baidu、Sina 这样的大型网站，一般都是使用 Cookie 来进行会话跟踪。 从浏览器的支持上比较 如果浏览器禁用了 Cookie，那么 Cookie 是无用的了！ 如果浏览器禁用了 Cookie，Session 可以通过 URL 地址重写来进行会话跟踪。 从跨域名上比较 Cookie 可以设置 domain 属性来实现跨域名 Session 只在当前的域名内有效，不可夸域名 Servlet 安全性问题由于 Servlet 是单例的，当多个用户访问 Servlet 的时候，服务器会为每个用户创建一个线程。当多个用户并发访问 Servlet 共享资源的时候就会出现线程安全问题。 原则： 如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制 synchronized (对象){} 如果一个变量不需要共享，则直接在 doGet() 或者 doPost() 定义. 这样不会存在线程安全问题 1)解释什么是Jasper? Jasper是Tomcat的JSP引擎 它解析JSP文件，将它们编译成JAVA代码作为servlet 在运行时，Jasper允许自动检测JSP文件的更改并重新编译它们 2)请说明select * from tab的输出结果是什么? 显示数据库中的默认表 3)请解释如何配置Tomcat来使用IIS和NTLM ? 必须遵循isapi_redirector.dll的标准指令 配置IIS使用“集成windows验证” 确保在服务器.xml中您已经禁用了tomcat身份验证 &lt;Connector port = “8009” enableLooksup = “false” redirect port = “8443” protocol = “AJP/1.3” tomcatAuthentication = “false” /&gt; 4)请解释一下什么时候可以使用“.”，什么时候可以使用“[]”? 如果正在运行bean属性，请使用“.”操作符，如果正在执行映射值或数组索引，则首选使用“[]”运算符。虽然两个运算符可以互换。 5)请解释Tomcat的默认端口是什么? Tomcat的默认端口是8080。在本地机器上初始化Tomcat之后，您可以验证Tomcat是否正在运行URL:http://localhost:8080 6)请解释Tomcat中使用的连接器是什么? 在Tomcat中，使用了两种类型的连接器： HTTP连接器:它有许多可以更改的属性，以确定它的工作方式和访问功能，如重定向和代理转发 AJP连接器:它以与HTTP连接器相同的方式工作，但是他们使用的是HTTP的AJP协议。AJP连接器通常通过插件技术mod_jk在Tomcat中实现 7)请阐述Catalina的配置文件有哪些? Catalina包含的配置文件有： ·policy ·properties ·properties ·xml ·xml ·Tomcat-users.xml ·xml 8)请解释将Tomcat作为一个Windows 服务运行会带来哪些好处? 运行Tomcat作为windows服务带来了以下的好处： 自动启动:对于需要在维护后远程重新启动系统的环境来说，这是至关重要的 启动无活动用户登录的服务器:Tomcat通常在刀片服务器上运行，这些服务器甚至可能没有一个活动监视器，Windows服务可以在没有活动用户的情况下启动 安全性:在Windows服务下的Tomcat可以让您在一个特殊的系统帐户下运行它，这个账户可以从其他用户帐户中得到保护 9)解释何时在Tomcat使用SSL ? 当你将Tomcat作为独立的web服务器运行时，需使用Tomcat来处理连接 10)解释如何使用WAR文件部署web应用程序? 在Tomcat的web应用程序目录下，jsp、servlet和它们的支持文件被放置在适当的子目录中。你可以将web应用程序目录下的所有文件压缩到一个压缩文件中，以.war文件扩展名结束。你可以通过在webapps目录中放置WAR文件来执行web应用程序。当一个web服务器开始执行时，它会将WAR文件的内容提取到适当的webapps子目录中。 11)解释什么是Tomcat Valve? Tomcat Valve——Tomcat 4引入的新技术，它允许您将Java类的实例链接到一个特定的Catalina容器。 12)说明Tomcat配置了多少个Valve? Tomcat配置了四种类型的Valve： ·访问日志 ·远程地址过滤 ·远程主机过滤器 ·客户请求记录器 13)解释servlet如何完成生命周期? 在Tomcat上运行的典型servlet生命周期如下： ·Tomcat通过它的其中一个连接器接收来自客户端的请求 ·进程请求Tomcat将此请求映射为适当的 ·一旦请求被定向到适当的servlet，Tomcat就会验证servlet类是否已经加载。如果不是Tomcat将servlet包装成Java字节码，这是由JVM执行的，并形成servlet的实例 ·Tomcat通过调用它的init来启动servlet，它包含能够筛选Tomcat配置文件并相应地采取行动的代码，并声明它可能需要的任何资源 ·一旦servlet启动，Tomcat就可以调用servlet的服务方法来进行请求 ·在servlet的生命周期中，Tomcat和servlet可以通过使用侦听器类来进行协调或通信，从而跟踪各种状态变化的servlet ·删除servlet，Tomcat调用servlet销毁方法 14)请说明NAT协议的目的是什么? NAT协议的目的是将私有IP地址从公共IP地址隐藏起来，并给组织提供一定的安全性。 15)请解释一下MAC代表什么? MAC意味着中访问控制- 16)请解释什么是Tomcat Coyote ? Tom coyote是基于HTTP / 1.1规范的HTTP连接器，通过监听TCP / IP端口并将请求发送回请求客户端，向Tomcat引擎接收和传输web请求。 参考：Tomcat+Servlet面试题都在这里 - 简书https://www.jianshu.com/p/fdee4e0c2a1dhttp://server.it168.com/a2017/0901/3168/000003168567.shtml]]></content>
      <tags>
        <tag>servlet</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat学习]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-4%2F</url>
    <content type="text"><![CDATA[什么是 TomcatTomcat 简单的说就是一个运行 JAVA 的网络服务器，底层是 Socket 的一个程序，它也是 JSP 和 Serlvet 的一个容器。 为什么我们需要用到 Tomcat如果你学过 html，css，你会知道你写的页面只能自己访问，别人不能远程访问你写的页面，Tomcat 就是提供能够让别人访问自己写的页面的一个程序 配置 Tomcat运行 Tomcat 需要 JDK 的支持【Tomcat 会通过 JAVA_HOME 找到所需要的 JDK】。 新建 JAVA_HOME 环境变量【路径是 JDK 的主目录】 进入 Tomcat 目录下的 bin 中启动 startup.bat，以下是成功启动 Tomcat 的页面。 在浏览器地址栏输入 http://localhost:8080, 如果能够出现 Tomcat 页面，说明配置成功了！ 注意：如果在使用 Tomcat 时出现了Error deploying web application directory web222, 很大原因就是 jdk 和 tomcat 的版本不匹配。目前，jdk8 不能匹配 tomcat7.0，所以要降低 jdk 版本【换成 JDK7】 当然也有可能不是一帆风顺能够直接启动 Tomcat，不能正常启动 Tomcat 会有以下情况 JAVA_HOME 配置错误 端口被占用了 第一种方法：在 cmd 输入 netstat -anb 查看谁占用了该端口【Tomcat 默认的是 8080】, 在进程中关闭它 第二种方法：主动改变 tomcat 的端口, 到 tomcat 主目录下的 conf/server.xml 文件中修改, 把 8080 端口改成是 8088 或者是其他的‘ 相关术语介绍 tomcat 结构目录 目录的简单介绍 bin：启动和关闭 tomcat 的 bat 文件 conf：配置文件 server.xml该文件用于配置 server 相关的信息，比如 tomcat 启动的端口号，配置主机 (Host) web.xml文件配置与 web 应用（web 应用相当于一个 web 站点） tomcat-user.xml配置用户名密码和相关权限. lib：该目录放置运行 tomcat 运行需要的 jar 包 logs：存放日志，当我们需要查看日志的时候，可以查询信息 webapps：放置我们的 web 应用 work 工作目录：该目录用于存放 jsp 被访问后生成对应的 server 文件和. class 文件 webapps 目录的详细说明在 webapps 中建立了 web1 目录，下面放置我们的 html 文件，jsp 文件，图片等等，则 web1 就被当做 web 应用管理起来【tomcat6.0 以后的版本才支持】 例子：在 webapps 下创建一个 web 站点，在 web 站点下创建一个 html 文件，访问 html 文件 web 站点的目录是有规范的 为什么要这样设置 web 站点目录呢？ 需求：我有多个 html 文件，想把其中的一个 html 文件作为我 web 站点的首页。 如果没有 WEB-INF 目录下的 web.xml 文件支持，是无法解决我的需求的 这个规范是约定熟成的。 下面将 web 站点下的 helloword2.xml 文件作为站点的首页 新建一个 WEB-INF 目录 在 WEB-INF 目录下创建一个 web.xml web.xml 我们不可能会写，所以可以在 webapps 目录下其他的站点中抄一份过来【复制 ROOT/WEB-INF/web.xml 的文件到自己的站点中】 在 web.xml 中添加以下代码 1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;helloword2.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 访问 web 站点【helloword2.html 已经是 web 站点的首页了，所以不需要指定资源访问了】 配置虚拟目录为什么需要配置虚拟目录？ 如果把所有 web 站点的目录都放在 webapps 下，可能导致磁盘空间不够用，也不利于对 web 站点目录的管理【如果存在非常多的 web 站点目录】 把 web 站点的目录分散到其他磁盘管理就需要配置虚拟目录【默认情况下，只有 webapps 下的目录才能被 Tomcat 自动管理成一个 web 站点】 把 web 应用所在目录交给 web 服务器管理，这个过程称之为虚拟目录的映射 配置虚拟目录方法一： 在其他盘符下创建一个 web 站点目录，并创建 WEB-INF 目录和一个 html 文件。 找到 Tomcat 目录下 / conf/server.xml 文件 在 server.xml 中的 12&lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt; 访问配置好的 web 站点 配置虚拟目录方法二： 进入到 conf\Catalina\localhost 文件下，创建一个 xml 文件，该文件的名字就是站点的名字。 xml 文件的代码如下，docBase 是你 web 站点的绝对路径 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Context docBase=&quot;D:\web1&quot; reloadable=&quot;true&quot;&gt; &lt;/Context&gt; 访问 web 站点下的 html 资源 配置临时域名访问 Tomcat 服务器有好几种方式 使用 localhost 域名访问【localhost 代表本机】 使用 ip 地址 127.0.0.1 访问【该 ip 地址也是本机】 使用机器名称访问【只限用于本机上或者局域网】 使用本机 IP 地址访问【在 cmd 中输入 ipconfig 可以查询到本机 IP 地址】 还可以为机器配置临时域名 配置临时域名步骤 打开到 C:\Windows\System32\drivers\etc 下，找到 hosts 文件 在 hosts 文件下配置临时域名 设置虚拟主机什么是虚拟主机？多个不同域名的网站共存于一个 Tomcat 中 为什么需要用到虚拟主机？例子：我现在开发了 4 个网站，有 4 个域名。如果我不配置虚拟主机，一个 Tomcat 服务器运行一个网站，我就需要 4 台电脑才能把 4 个网站运行起来。 配置虚拟主机的步骤 在 tomcat 的 server.xml 文件中添加主机名 1234&lt;Host D:\web1&quot;&gt; &lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt;&lt;/Host&gt; 访问虚拟主机下的 web 站点 Tomcat 体系结构 浏览器访问 WEB 资源的流程图 练习在浏览器输入 http//:zhongfucheng 直接显示到页面 分析： 需要配置虚拟主机 把 8080 端口改成 80 设置 web 站点首页 映射虚拟目录为 / Servlet+JSP - 文集 - 简书https://www.jianshu.com/nb/21926044 参考：专栏：How Tomcat Works笔记 - CSDN博客https://blog.csdn.net/column/details/howtomcatworks.html?&amp;page=2How Tomcat Works读书笔记 - 简书https://www.jianshu.com/p/b21520f4ed69]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - Servlet 完全教程]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-3%2F</url>
    <content type="text"><![CDATA[Servlet是一种允许响应请求的 Java 类。虽然Servlet可以响应任何类型的请求，但它们通常被用来响应网络请求。一个Servlet必须部署在 Java servlet 容器中，它才能成为可用的。虽然许多开发者利用Servlet框架如 Java Server Pages (JSP) 和 Java Server Faces (JSF)，但实际上这两种技术通过 servlet 容器在幕后将页面编译为 Java servlet。也就是说，Java servlet 技术的基本知识对任何 Java web 开发都很有用。 在本教程中，我们将涵盖以下主题，从而获得 Java servlet 技术的整体认识。 目录 编写第一个Servlet Servlet的生命周期方法 使用 @WebServlet 注解开发Servlet 打包并部署Servlet到 Tomcat 服务器 在Servlet响应中写入动态内容 Servlet接受参数处理并响应 监听Servlet容器事件 给Servlet传入初始化参数 给指定的请求增加Servlet过滤器 用Servlet下载二进制文件 用 RequestDispatcher.forward() 将请求内部转发到另一个Servlet 用 HttpServletResponse.sendRedirect() 将请求重定向到另一个Servlet 用Servlet读写 cookie 让我们开始一步一步学习Servlet。 编写第一个 Servlet下面是一个非常简单的Servlet，实际上你需要写的代码代码非常少 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.bill.servlets;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyFirstServlet extends HttpServlet &#123; private static final long serialVersionUID = -1915463532411657451L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); try &#123; // Write some content out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;MyFirstServlet&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h2&gt;Servlet MyFirstServlet at &quot; + request.getContextPath() + &quot;&lt;/h2&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125; finally &#123; out.close(); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //Do some other work &#125; @Override public String getServletInfo() &#123; return &quot;MyFirstServlet&quot;; &#125;&#125; 用一个 web.xml 文件将上面的MyFirstServlet注册在 web 容器中。 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/Javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/MyFirstServlet&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bill.servlets.MyFirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/MyFirstServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 你可能想知道上面MyFirstServlet的完成了哪些重要的事情。 MyFirstServlet继承自HttpServlet。这是强制性的，因为所有的Servlet必须继承javax.servlet.GenericServlet或javax.servlet.http. HttpServlet。 重写了 doGet() 和 doPos() 方法。这些方法定义在HttpServlet类中。每当 GET 或 POST 请求到来时，它被映射到其各自对应的方法（例如，如果您发送一个 HTTP GET 请求，然后 servlet 的 doGet() 方法被调用。 还有一些你可以重写的其他方法，被用来控制应用程序，比如 getServletInfo()。 HttpServletRequest和HttpServletResponse是 doxxx() 方的默认参数类型。我们将在以后的章节中更多地了解这两种类型对应的对象。 这就是了解一个简单Servlet需要知道的的全部内容。 Servlet 的生命周期方法在应用程序中，每当加载并使用Servlet时会发生一系列事件，如初始化和销毁。这些被称为Servlet的生命周期事件（或方法）。让我们多了解一些关于它们的故事。 init()，service()，和 destroy() 是三个在Servlet的生命周期中至关重要的方法。它们由每个Servlet实现，并在特定时间被调用。 1）在Servlet生命周期的初始阶段，web 容器通过调用 init() 方法初始化Servlet实例，同时传入一个实现javax.servlet.ServletConfig接口的对象。这个配置对象允许Servlet访问在 web.xml 文件中定义的键值对值初始化参数。这只在Servlet实例的生命周期中调用一次。init 方法定义如下所示： 123public void init() throws ServletException &#123; //custom initialization code&#125; 2）在初始化之后，Servlet实例可以为客户请求提供服务。web 容器调用Servlet的 service() 方法处理每个请求。service 方法判断请求的种类或者将请求转发到哪个方法里处理更加合适。Servlet的开发人员必须为这些方法提供一个实现。如果Servlet未实现这个方法，那么请求将调用父类的方法处理，通常会给请求者导致返回一个错误。 几乎没有必要重写此方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123;String method = req.getMethod();if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn&apos;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125;&#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp);&#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp);&#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp);&#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp);&#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp);&#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);&#125;&#125; 3）最后，web 容器调用 destroy() 方法终止Servlet的服务。如果希望在Servlet不可用之前关闭或销毁某些文件系统或网络资源，则应该调用此方法。destory() 方法和 init() 方法一样在Servlet整个生命周期中只被调用一次。 123public void destroy() &#123; //&#125; 通常情况下，你不需要重写Servlet的这些方法。 使用 @WebServlet 注解开发 servlet如果你不是很喜欢 xml 配置，而特别喜欢注释， Servlets API 也有这样的功能。您可以使用 @WebServlet ，如下的例子，那么你不需要在 web.xml 中做任何事情。在运行时会自动将Servlet注册到容器，并像往常一样处理它。 1234567891011121314151617181920212223242526272829package com.bill.servlets;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;MyFirstServlet&quot;, urlPatterns = &#123;&quot;/MyFirstServlet&quot;&#125;)public class MyFirstServlet extends HttpServlet &#123; private static final long serialVersionUID = -1915463532411657451L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //Do some work &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //Do some other work &#125;&#125; 打包并部署 servlet 到 Tomcat 服务器如果您使用的是任何 IDE（如 Eclipse），那么打包和部署应用程序非常简单。右键单击项目 &gt; Run As &gt; Run As Server。如果尚未完成，就配置服务器，然后就完成了。如果您不使用任何 IDE，那么您需要做一些额外的工作，例如从命令提示符编译应用程序，使用 Ant 创建 WAR 文件等，但我确信现在每个人都使用一些 IDE 进行开发，所以我不会在这里浪费更多的时间。当您在 Tomcat 中部署完我们写的第一个Servlet，然后在浏览器地址栏输入 http://localhost:8080/servletexamples/MyFirstServlet，回车，你将得到下面的响应。 在 Servlet 响应中写入动态内容Servlet之所以非常用用的原因是它允许给网页内容动态的加入一些内容。内容可以从服务器本身、数据库、另一个 web 站点或许多其他可访问的 web 资源。Servlet不是静态的网页，他们是动态的，这是它们最关键的地方。 让我们以Servlet为例，它负责向用户显示当前日期和时间，以及他的名字和一些自定义消息，代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.bill.servlets;import java.io.IOException;import java.io.PrintWriter;import java.util.Date;import java.util.HashMap;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;CalendarServlet&quot;, urlPatterns = &#123;&quot;/CalendarServlet&quot;&#125;)public class CalendarServlet extends HttpServlet &#123; private static final long serialVersionUID = -1915463532411657451L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Map&lt;String,String&gt; data = getData(); response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); try &#123; // Write some content out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;CalendarServlet&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h2&gt;Hello &quot; + data.get(&quot;username&quot;) + &quot;, &quot; + data.get(&quot;message&quot;) + &quot;&lt;/h2&gt;&quot;); out.println(&quot;&lt;h2&gt;The time right now is : &quot; + new Date() + &quot;&lt;/h2&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125; finally &#123; out.close(); &#125; &#125; //This method will access some external system as database to get user name, and his personalized message private Map&lt;String, String&gt; getData() &#123; Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); data.put(&quot;username&quot;, &quot;Guest&quot;); data.put(&quot;message&quot;, &quot;Welcome to my world !!&quot;); return data; &#125;&#125; 当你在 Tomcat 中运行上面的Servlet，然后在浏览器中请求 http://localhost:8080/servletexamples/CalendarServlet，你将得到下面的响应 Servlet 接受参数处理并响应Servlet可以很容易地创建 web 应用程序，给用户的请求返回响应。它们能够提供 HTTP 响应，并在同一代码体中处理业务逻辑。用于处理业务逻辑的能力使Servlet比标准的 HTML 代码更强大。 在实际应用程序中，HTML Web 表单包含发送给Servlet的参数。然后 servlet 以某种方式处理这些参数，并给客户端返回一个响应。在一个 HttpServlet 对象的情况下，客户端是一个 web 浏览器，响应是一个网页。表单的 action 属性标签指定了谁来处理表单中所包含的参数。 调用HttpServletRequest对象的 getparameter() 方法获取请求参数，通过 id 获得你想得到的参数。 12String value1 = req.getParameter(&quot;param1&quot;);String value1 = req.getParameter(&quot;param2&quot;); 一旦获得这些值，就可以根据需要进行处理。然后为客户机返回响应，正如我们在以上章节中讨论的那样，用HttpServletResponse类型的对象给客户端返回响应。 一个基本的请求 - 处理 - 响应的流程如下： 123456789101112131415161718192021222324252627282930313233@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); boolean success = validateUser(username, password); try &#123; // Write some content out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;LoginServlet&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); if(success) &#123; out.println(&quot;&lt;h2&gt;Welcome Friend&lt;/h2&gt;&quot;); &#125;else&#123; out.println(&quot;&lt;h2&gt;Validate your self again.&lt;/h2&gt;&quot;); &#125; out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125; finally &#123; out.close(); &#125;&#125; 你需要从HttpServletResponse对象获得PrintWriter对象，给客户端返回内容。任何写入它的内容将被写入OutputStream，然后数据将被发送回客户端。 监听 Servlet 容器事件有时候知道在容器中发生的某些事件是非常有用的。这个概念在许多不同的情况下都是有用的，但大多数情况下，它可能被用于在启动时初始化，关闭时清理。一个Servlet可以在容器注册Listener，以监听它何时启动或关闭。因此，通过侦听此类事件，Servlet有机会在发生某些事件时执行某些操作。 要创建一个基于容器的事件的监听器，你必须实现一个ServletContextListener接口的类。需要实现 contextInitialized() 和 contextDestroyed() 方法。这两种方法都接受一个ServletContextEvent作为参数，并分别在每次Servlet容器初始化或关闭时被自动调用。 用给容器注册监听器，可以使用以下技术之一： 利用 @WebListener 注解。 在 web.xml 中注册监听器。 使用ServletContext的 addListener() 方法。 请注意，ServletContextListener不是 Servlet API 中的唯一监听器。还有更多，比如 javax.servlet.servletrequestlistener javax.servlet.servletrequestattrbitelistener javax.servlet.servletcontextlistener javax.servlet.servletcontextattributelistener javax.servlet.httpsessionlistener javax.servlet.httpsessionattributelistener 根据你希望监听到的事件实现你自己的监听器类，如HttpSessionListener将监听每当户创建一个新的用户Session或者销毁时的事件。 给 Servlet 传入初始化参数今天大多数应用程序需要设置一些在应用程序 / 控制器启动时传给它们配置参数。Servlet也可以在它们被第一请求的时候接受初始化参数。 显然，你可以在Servlet本身硬编码的配置，但改变任何他们需要重新编译一次整个应用程序，没有人会喜欢这样做。 1234567891011121314&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bill.servlets.SimpleServlet&lt;/servlet-class&gt; &lt;!-- Servlet init param --&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;value&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt;&lt;/web-app&gt; 一旦设置，该参数通过调用 getServletConfig().getInitializationParameter() 和传递的参数的名称来得到并使用，如下面的代码行所示： 1String value = getServletConfig().getInitParameter(&quot;name&quot;); 给指定的请求增加 Servlet 过滤器Web 过滤器对于在访问给定 URL 求之前调用某些功能，它非常有用。相比通过一个固定的 URL 请求一个Servlet，过滤器匹配一个模式的 URL，在这些 URL 对应的Servlet调用之前被调用。这在许多情况下非常有用，如日志记录、身份验证或其他服务。 过滤器必须实现javax.servlet.Filter接口。方法包含 init ()，destroy()，和 dofilter() 方法。init () 和 destroy() 方法由容器调用。dofilter() 方法被用来定义过滤器类所要完成的任务。如果你想要过滤器链，或者对应一个 URL 有多个过滤器，在 web.xml 配置文件中按顺序配置即可。 在 web.xml 配置文件中配置一个过滤器，使用 XML 的 和 &lt; filter-mapping &gt; 元素以及与它们相关的子元素标签。 12345678&lt;filter&gt; &lt;filter-name&gt;LoggingFilter&lt;/filter-name&gt; &lt;filter-class&gt;LoggingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;LogingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 如果你想使用注释来配置特定的Servlet过滤器，你可以使用 @WebFilter 注释。 用 Servlet 下载二进制文件下载文件是几乎所有 web 应用程序的基本任务。要下载文件，Servlet必须提供与下载文件匹配的相同类型的响应，它还必须在响应标头中指出要包含附件，如下所示。 123String mimeType = context.getMimeType( fileToDownload );response.setContentType( mimeType != null ? mimeType : &quot;text/plain&quot; );response.setHeader( &quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + fileToDownload + &quot;\&quot;&quot; ); 你可以通过给ServletContext的 getResourceAsStream() 方法传一个路径，获得一个你需要下载 (被存在服务器的文件系统中) 的文件的引用。这将返回一个InputStream对象可以用来读取文件内容。然后创建一个字节缓冲区，用于读取文件时从文件中获取数据块。最后真正的任务是读取文件内容并将它们复制到输出流中。这是通过使用一个 while 循环，这将不断读取InputStream直到文件结束。使用循环将数据块读入并写入输出流。在这之后，ServletOutputStream 对象 flush 方法被调用，来清除内容和释放资源。 让我们看示例代码 1234567891011121314151617181920212223private void downloadFile(HttpServletRequest request, HttpServletResponse response, String fileToDownload) throws IOException &#123; final int BYTES = 1024; int length = 0; ServletOutputStream outStream = response.getOutputStream(); ServletContext context = getServletConfig().getServletContext(); String mimeType = context.getMimeType( fileToDownload ); response.setContentType( mimeType != null ? mimeType : &quot;text/plain&quot; ); response.setHeader( &quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + fileToDownload + &quot;\&quot;&quot; ); InputStream in = context.getResourceAsStream(&quot;/&quot; + fileToDownload); byte[] bbuf = new byte[BYTES]; while ((in != null) &amp;&amp; ((length = in.read(bbuf)) != -1)) &#123; outStream.write(bbuf, 0, length); &#125; outStream.flush(); outStream.close(); &#125; 用 RequestDispatcher.forward() 将请求内部转发到另一个 servlet有时，你的应用程序需要一个Servlet完成部分任务，然后让其他 servlet 完成剩下的任务。此外，请求应该在不将客户机重定向到另一个 URL 的情况下进行传递，即浏览器中的 URL 不应更改。 调用ServletContext对象 getRequestDispatcher () 方法获得RequestDispatcher对象，这个对象可以被用来内部转发。getRequestDispatcher () 调用方法时，传递一个字符串包含要把请求的Servlet的名字。通过将HttpServletRequest和HttpServletResponse传给RequestDispatcher的对象，然后调用 forword() 方法。然后内部转发到另一个Servlet 12RequestDispatcher rd = servletContext.getRequestDispatcher(&quot;/NextServlet&quot;);rd.forward(request, response); 用 HttpServletResponse.sendRedirect() 将请求转发到另一个 servlet尽管有时正如我们在上一节中看到的您不愿意通知用户，Servlet重定向已经发生，但在某些场景中，我们实际上希望用户知道。当访问应用程序中的特定 URL 时，您希望重定向浏览器到另一个 URL。 要做到这一点，你需要调用 HttpServletResponse 对象的 sendRedirect() 方法。这个简单的重定向不会把 HttpReuest 的对象在 servlet 链条中传递。 用 Servlet 读写 Cookie许多应用程序希望将用户浏览历史的当前状态存储在客户机中，以便当用户再次返回应用程序时，他从离开的位置开始。通常，对于这个要求，使用cookie。您可以将cookie视为存储在客户机上的键值对数据。当从浏览器中发出请求时，浏览器可以读取或写入这些值。 简单地实例化一个新的Javax.servlet.http.Cookie类创建一个cookie对象。一旦实例化了cookie，就可以设置属性，这将有助于配置cookie。在下面例子中，cookie的 setMaxAge() 和 setHttpOnly() 方法被调用，设置cookie的有效期并防止客户端脚本访问。 由于 Servlet 3.0 API, 将cookie标记为 HTTP。这使得cookie可以防止客户端脚本攻击，使cookie更加安全。 1234Cookie cookie = new Cookie(&quot;sessionId&quot;,&quot;123456789&quot;);cookie.setHttpOnly(true);cookie.setMaxAge(-30);response.addCookie(cookie); 这里的response对象是传给 doXXX() 方法中的参数。 要从服务端获得cookie信息，请使用以下代码： 123456Cookie[] cookies = request.getCookies();for(Cookie cookie : cookies)&#123; //cookie.getName(); //cookie.getValue()&#125; 这就是本教程关于Servlet的所有技术。欢迎评论 / 反馈。 Happy Learning !! 参考：Java - Servlet完全教程 - 简书https://www.jianshu.com/p/e0471ce1b106]]></content>
      <tags>
        <tag>Java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程总结]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-2%2F</url>
    <content type="text"><![CDATA[本文主要是自己在网络编程方面的学习总结，先主要介绍计算机网络方面的相关内容，包括计算机网络基础，OSI 参考模型，TCP/IP 协议簇，常见的网络协议等等，在此基础上，介绍 Java 中的网络编程。 123456789101112一、概述二、计算机网络 1.网络协议 2.网络体系结构三、OSI参考模型四、TCP/IP参考模型五、常见网络协议 1.TCP协议 2.UDP协议 3.HTTP协议六、计网常见问题七、Java网络编程 一、概述计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来，实现资源共享和数据传输的系统。网络编程就就是编写程序使联网的两个 (或多个) 设备 (例如计算机) 之间进行数据传输。Java 语言对网络编程提供了良好的支持，通过其提供的接口我们可以很方便地进行网络编程。下面先对网络编程的一些基础知识进行介绍，最后给出使用 Java 语言进行网络编程的实例。 二、计算机网络计算机网络 20 世纪 60 年代出现，经历了 20 世纪 70 年代、80 年代和 90 年代的发展，进入 21 世纪后，计算机网络已经成为信息社会的基础设施，深入到人类社会的方方面面，与人们的工作、学习和生活息息相关。 网络协议 如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间能够进行相互通信是因为它们都共同遵守一定的规则，即网络协议。 网络体系结构 计算机网络是个复杂的系统，按照人们解决复杂问题的方法，把计算机网络实现的功能分到不同的层次上，层与层之间用接口连接。通信的双方具有相同的层次，层次实现的功能由协议数据单元 (PDU) 来描述。不同系统中的同一层构成对等层，对等层之间通过对等层协议进行通信，理解彼此定义好的规则和约定。 计算机网络体系结构是计算机网络层次和协议的集合，网络体系结构对计算机网络实现的功能，以及网络协议、层次、接口和服务进行了描述，但并不涉及具体的实现。接口是同一节点内相邻层之间交换信息的连接处，也叫服务访问点 (SAP)。 三、OSI 参考模型前面我们介绍了计算机网络的体系结构，因为计算机网络是个复杂的系统，所以把计算机网络实现的功能分到不同的层次上，而计算机网络体系结构是计算机网络层次和协议的集合。那么，计算机网络如何进行分层呢？下面先介绍的是 OSI 参考模型。 简介 世界上第一个网络体系结构由 IBM 公司提出（1974 年，SNA），以后其他公司也相继提出自己的网络体系结构如：Digital 公司的 DNA，美国国防部的 TCP/IP 等，多种网络体系结构并存，其结果是若采用 IBM 的结构，只能选用 IBM 的产品，只能与同种结构的网络互联。 为了促进计算机网络的发展，国际标准化组织 ISO 于 1977 年成立了一个委员会，在现有网络的基础上，提出了不基于具体机型、操作系统或公司的网络体系结构，称为开放系统互连参考模型，即 OSI/RM (Open System Interconnection Reference Model)。OSI 模型把网络通信的工作分为 7 层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 OSI 模型层次功能 物理层 物理层处于 OSI 的最底层，是整个开放系统的基础。物理层涉及通信信道上传输的原始比特流 (bits)，它的功能主要是为数据端设备提供传送数据的通路以及传输数据。 数据链路层 数据链路层的主要任务是实现计算机网络中相邻节点之间的可靠传输，把原始的、有差错的物理传输线路加上数据链路协议以后，构成逻辑上可靠的数据链路。需要完成的功能有链路管理、成帧、差错控制以及流量控制等。其中成帧是对物理层的原始比特流进行界定，数据链路层也能够对帧的丢失进行处理。 网络层 网络层涉及源主机节点到目的主机节点之间可靠的网络传输，它需要完成的功能主要包括路由选择、网络寻址、流量控制、拥塞控制、网络互连等。 传输层 传输层起着承上启下的作用，涉及源端节点到目的端节点之间可靠的信息传输。传输层需要解决跨越网络连接的建立和释放，对底层不可靠的网络，建立连接时需要三次握手，释放连接时需要四次挥手。 会话层和表示层 会话层的主要功能是负责应用程序之间建立、维持和中断会话，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工 3 种不同的通信方式，使系统和服务之间有序地进行通信。 表示层关心所传输数据信息的格式定义，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。 应用层 应用层为 OSI 的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。 四、TCP/IP 参考模型OSI 参考模型的初衷是提供全世界范围的计算机网络都要遵循的统一标准，但是由于存在模型和协议自身的缺陷，迟迟没有成熟的产品推出。TCP/IP 协议在实践中不断完善和发展取得成功，作为网络的基础，Internet 的语言，可以说没有 TCP/IP 协议就没有互联网的今天。 简介 TCP/IP，即 Transmission Control Protocol/Internet Protocol 的简写，中译名为传输控制协议 / 因特网互联协议，是 Internet 最基本的协议、Internet 国际互联网络的基础。 TCP/IP 协议是一个开放的网络协议簇，它的名字主要取自最重要的网络层 IP 协议和传输层 TCP 协议。TCP/IP 协议定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。TCP/IP 参考模型采用 4 层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求，这 4 个层次分别是：网络接口层、互联网层 (IP 层)、传输层 (TCP 层)、应用层。 TCP/IP 模型层次功能 网络接口层 TCP/IP 协议对网络接口层没有给出具体的描述，网络接口层对应着物理层和数据链路层。 互联网层 (IP 层) 互联网层是整个 TCP/IP 协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。互联网层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，互联网层还需要完成拥塞控制的功能。 传输层 (TCP 层) TCP 层负责在应用进程之间建立端到端的连接和可靠通信，它只存在与端节点中。TCP 层涉及两个协议，TCP 和 UDP。其中，TCP 协议提供面向连接的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等。UDP 协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中。 应用层 应用层为 Internet 中的各种网络应用提供服务。 五、常见网络协议上面主要介绍了 OSI 参考模型和 TCP/IP 模型的相关内容，从下面这张图可以看出 TCP/IP 协议簇中不同的层次中有着很多不同的网络协议，下面主要介绍传输层的 TCP、UDP 协议和应用层的 HTTP 协议。 TCP 协议 简介 TCP（Transmission Control Protocol ，传输控制协议）是面向连接的传输层协议。TCP 层是位于 IP 层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换。TCP 协议采用字节流传输数据。 TCP 报文段格式 TCP 报文段包括协议首部和数据两部分，协议首部的固定部分有 20 个字节，首部的固定部分后面是选项部分。 下面是报文段首部各个字段的含义。 源端口号以及目的端口号，各占 2 个字节，端口是传输层和应用层的服务接口，用于寻找发送端和接收端的进程，一般来讲，通过端口号和 IP 地址，可以唯一确定一个 TCP 连接，在网络编程中，通常被称为一个 socket 接口。 序号，占 4 字节，用来标识从 TCP 发送端向 TCP 接收端发送的数据字节流。 确认序号，占 4 字节，包含发送确认的一端所期望收到的下一个序号，因此，确认序号应该是上次已经成功收到数据字节序号加 1. 数据偏移，占 4 位，用于指出 TCP 首部长度，若不存在选项，则这个值为 20 字节，数据偏移的最大值为 60 字节。 保留字段占 6 位，暂时可忽略，值全为 0 标志位URG（紧急） : 为 1 时表明紧急指针字段有效ACK（确认）：为 1 时表明确认号字段有效PSH（推送）：为 1 时接收方应尽快将这个报文段交给应用层RST（复位）：为 1 时表明 TCP 连接出现故障必须重建连接SYN（同步）：在连接建立时用来同步序号FIN （终止）： 为 1 时表明发送端数据发送完毕要求释放连接 接收窗口占 2 个字节，用于流量控制和拥塞控制，表示当前接收缓冲区的大小。在计算机网络中，通常是用接收方的接收能力的大小来控制发送方的数据发送量。TCP 连接的一端根据缓冲区大小确定自己的接收窗口值，告诉对方，使对方可以确定发送数据的字节数。 校验和占 2 个字节，范围包括首部和数据两部分。 选项是可选的，默认情况是不选。 三次握手与四次挥手 TCP 是面向连接的协议，因此每个 TCP 连接都有 3 个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为 “三次握手”。 TCP 三次握手过程如下： 第一次握手客户机发送连接请求报文段到服务器，并进入 SYN_SENT 状态，等待服务器确认。（SYN = 1,seq=x） 第二次握手服务器收到连接请求报文，如果同意建立连接，向客户机发回确认报文段，并为该 TCP 连接分配 TCP 缓存和变量。(SYN=1,ACK=1,seq=y,ack=x+1)。 第三次握手客户机收到服务器的确认报文段后，向服务器给出确认报文段，并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。(ACK=1,seq=x+1,ack=y+1)。 TCP 四次挥手过程如下： 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP 客户端发送一个 FIN，用来关闭客户到服务器的数据传送。 服务器收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。 服务器关闭客户端的连接，发送一个 FIN 给客户端。 客户端发回 ACK 报文确认，并将确认序号设置为收到序号加 1。 UDP 协议 简介 UDP，用户数据报协议，英文全称是 User Datagram Protocol，它是 TCP/IP 协议簇中无连接的运输层协议。 UDP 协议格式 从图中可以看到，UDP 协议十分简单，它由两部分组成：首部和数据。其中，首部仅有 8 个字节，包括源端口和目的端口，长度（UDP 用于数据报的长度）、校验和。 HTTP 协议 简介 HTTP，超文本传输协议，英文全称是 Hypertext Transfer Protocol，它是互联网上应用最为广泛的一种网络协议。HTTP 是一种应用层协议，它是基于 TCP 协议之上的请求 / 响应式的协议，即一个客户端与服务器建立连接后，向服务器发送一个请求；服务器接到请求后，给予相应的响应信息。HTTP 协议默认的端口号为 80. 现在使用的 HTTP 协议是 HTTP/1.1 版本，1997 年之前采用的是 HTTP1.0 版本。HTTP 连接在 1.0 版本中采用非持续连接工作方式，1.1 版本采用的是持续连接工作方式，持续连接是指服务器在发送响应后仍然在一段时间内保持这条由 TCP 运输层协议建立起来的连接，使客户机和服务器可以继续在这条连接上传输 HTTP 报文。 是否采用持续连接工作方式，1.0 中默认是关闭的，需要在 HTTP 头加入 “Connection:Keep-Alive”，才能启用 Keep-Alive。HTTP1.1 中默认启用 Keep-Alive，如果加入 “Connection:close”，才关闭。目前大部分浏览器都是用 HTTP1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep- Alive 连接就看服务器设置情况。 HTTP 报文 HTTP 协议是基于 TCP 协议之上的请求 / 响应式协议，下面主要介绍 HTTP 报文的格式，HTTP 报文主要有请求报文和响应报文两种。首先看请求报文的格式： HTTP 请求报文由请求行、首部行和实体主体组成，由浏览器发送给服务器。上面这张图中 SP 表示空格，cr lf 表示回车和换行。 上面这张图是 HTTP 响应报文，它由状态行、首部行和实体主体组成。下面两张图是在谷歌浏览器内访问服务器查看的 HTTP 请求和响应。 HTTP 请求方法和响应状态码 在上面的 HTTP 请求报文例子中，我们可以看到请求方法是 GET，这表示请求读取由 URL 所标志的信息，除了 GET，还有其它几种常用的方法。 在 HTTP 响应报文的例子中，我们可以看到状态码是 200，表示响应成功。下表是其它状态码，总共 5 大类，33 种。 HTTPS 和 HTTP 的区别 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。它是一个 URI scheme（抽象标识符体系），句法类同 http: 体系。用于安全的 HTTP 数据传输。https:URL 表明它使用了 HTTP，但 HTTPS 存在不同于 HTTP 的默认端口及一个加密 / 身份验证层（在 HTTP 与 TCP 之间）。 超文本传输协议 HTTP 协议被用于在 Web 浏览器和网站服务器之间传递信息。HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此 HTTP 协议不适合传输一些敏感信息，比如信用卡号、密码等。 为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS。为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS 和 HTTP 的区别主要为以下四点：1、https 协议需要到 ca 申请证书，一般免费证书很少，需要交费。2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 六、常见问题到这里，关于计算机网络部分的总结内容就结束了，下面是几个常见的问题，汇总在这里。 OSI 参考模型的分为哪几层，每层的功能？OSI，开放系统互连参考模型，它的 7 个层次自顶到下依次为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。各层的功能见文章开始。 TCP 协议和 UDP 协议的区别？TCP 协议是传输控制协议，UDP 协议是用户数据报协议，两者都是传输层的协议，主要区别在于前者是可靠的，面向连接的协议，后者是不可靠的，无连接的协议。其它的区别还有，TCP 协议传输速度慢，UDP 常用于一次性传输比较少量数据的网络应用。 TCP 三次握手为什么不能是两次?主要是防止两次握手情况下已经失效的连接请求报文段突然又传送到服务端而产生错误。例如，客户机 A 向服务器 B 发送 TCP 连接请求，第一个连接请求报文在网络的某个节点长时间滞留，A 超时后认为报文丢失，于是再重传一次连接请求，B 收到后建立连接。数据传输完毕后双方断开连接，而这时之前滞留的连接请求到达了服务端 B，而 B 认为 A 又发来连接请求。如果两次握手建立连接，A 并无连接请求，造成 B 的资源浪费。 HTTP 请求的 GET 方法和 POST 方法的区别？GET 和 POST 是 HTTP 请求的两种方法，主要区别在于 GET 方法是请求读取由 URL 所标志的信息，POST 是给服务器添加信息。点击查看更多 在浏览器中输入网址到显示出页面的整个过程？(1) 输出包含域名的网址 (2) 浏览器向 DNS 请求解析域名对应的 IP 地址 (3) 域名系统 DNS 解析出域名对应的 IP 地址 (4) 浏览器与该服务器建立 TCP 连接 (5) 浏览器发送 HTTP 请求 (6) 服务器通过 HTTP 响应把页面文件发送给浏览器 (7) TCP 连接释放 (8) 浏览器解释文件，并显示 七、Java 网络编程Java 的网络编程主要涉及到的内容是 Socket 编程，那么什么是 Socket 呢？简单地说，Socket，套接字，就是两台主机之间逻辑连接的端点。TPC/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协议，主要解决如何包装数据。Socket，本质上就是一组接口，是对 TCP/IP 协议的封装和应用 (程序员层面上)。 整体流程 Socket 编程主要涉及到客户端和服务器端两个方面，首先是在服务器端创建一个服务器套接字 (ServerSocket)，并把它附加到一个端口上，服务器从这个端口监听连接。端口号的范围是 0 到 65536，但是 0 到 1024 是为特权服务保留的端口号，我们可以选择任意一个当前没有被其他进程使用的端口。 客户端请求与服务器进行连接的时候，根据服务器的域名或者 IP 地址，加上端口号，打开一个套接字。当服务器接受连接后，服务器和客户端之间的通信就像输入输出流一样进行操作。 实例一 下面是一个客户端和服务器端进行数据交互的简单例子，客户端输入正方形的边长，服务器端接收到后计算面积并返回给客户端，通过这个例子可以初步对 Socket 编程有个把握。 服务器端 1234567891011121314151617181920212223242526272829303132public class SocketServer &#123; public static void main(String[] args) throws IOException &#123; // 端口号 int port = 7000; // 在端口上创建一个服务器套接字 ServerSocket serverSocket = new ServerSocket(port); // 监听来自客户端的连接 Socket socket = serverSocket.accept(); DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); do &#123; double length = dis.readDouble(); System.out.println(&quot;服务器端收到的边长数据为：&quot; + length); double result = length * length; dos.writeDouble(result); dos.flush(); &#125; while (dis.readInt() != 0); socket.close(); serverSocket.close(); &#125;&#125; 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SocketClient &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; int port = 7000; String host = &quot;localhost&quot;; // 创建一个套接字并将其连接到指定端口号 Socket socket = new Socket(host, port); DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); Scanner sc = new Scanner(System.in); boolean flag = false; while (!flag) &#123; System.out.println(&quot;请输入正方形的边长:&quot;); double length = sc.nextDouble(); dos.writeDouble(length); dos.flush(); double area = dis.readDouble(); System.out.println(&quot;服务器返回的计算面积为:&quot; + area); while (true) &#123; System.out.println(&quot;继续计算？(Y/N)&quot;); String str = sc.next(); if (str.equalsIgnoreCase(&quot;N&quot;)) &#123; dos.writeInt(0); dos.flush(); flag = true; break; &#125; else if (str.equalsIgnoreCase(&quot;Y&quot;)) &#123; dos.writeInt(1); dos.flush(); break; &#125; &#125; &#125; socket.close(); &#125;&#125; 实例二 可以看到上面的服务器端程序和客户端程序是一对一的关系，为了能让一个服务器端程序能同时为多个客户提供服务，可以使用多线程机制，每个客户端的请求都由一个独立的线程进行处理。下面是改写后的服务器端程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class SocketServerM &#123; public static void main(String[] args) throws IOException &#123; int port = 7000; int clientNo = 1; ServerSocket serverSocket = new ServerSocket(port); // 创建线程池 ExecutorService exec = Executors.newCachedThreadPool(); try &#123; while (true) &#123; Socket socket = serverSocket.accept(); exec.execute(new SingleServer(socket, clientNo)); clientNo++; &#125; &#125; finally &#123; serverSocket.close(); &#125; &#125;&#125;class SingleServer implements Runnable &#123; private Socket socket; private int clientNo; public SingleServer(Socket socket, int clientNo) &#123; this.socket = socket; this.clientNo = clientNo; &#125; @Override public void run() &#123; try &#123; DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); do &#123; double length = dis.readDouble(); System.out.println(&quot;从客户端&quot; + clientNo + &quot;接收到的边长数据为：&quot; + length); double result = length * length; dos.writeDouble(result); dos.flush(); &#125; while (dis.readInt() != 0); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;与客户端&quot; + clientNo + &quot;通信结束&quot;); try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面改进后的服务器端代码可以支持不断地并发响应网络中的客户请求。关键的地方在于多线程机制的运用，同时利用线程池可以改善服务器程序的性能。 参考：Java - 网络编程完全总结 - 简书https://www.jianshu.com/p/ae5e1cee5b04]]></content>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现Tomcat]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-1%2F</url>
    <content type="text"><![CDATA[跟我一起动手实现 Tomcat（一）: 实现静态 Web 服务器前言1最近笔者读了《深入剖析tomcat》这本书（原作：《how tomcat works》）,发现该书简单易读，每个章节循序渐进的讲解了tomcat的原理，在接下来的章节中，tomcat都是基于上一章新增功能并完善，到最后形成一个简易版tomcat的完成品。所以有兴趣的同学请按顺序阅读，本文为记录第一章的知识点以及源码实现（造轮子）。 如何实现HTTP 协议就是咱们 web 服务器与浏览器交互的协议，具体的知识点以及背景本文就不再累述。那么举一个简单的例子就好： 在浏览器输入 http://www.baidu.com 按下回车键。 浏览器大概发送了以下的 http 请求到百度的服务器中： 123GET /index.html HTTP/1.1Host: www.baidu.com... 百度 web 服务器在接收到我们的请求的时候，找到对应的服务器资源并相应： 1234567891011HTTP/1.1 200 OK... &lt;html&gt; &lt;head&gt; &lt;title&gt;百度一下你就知道&lt;/title&gt; &lt;/head&gt; &lt;body&gt; .... &lt;/body&gt;&lt;/html&gt; 那么其实通过上面的例子我们可以发现，静态 (这里指的是 html / 图片 / css 等)web 服务器的实现也是比较简单的： 代码实现1在这里使用java socket api 实现简单的静态web服务器。 新建一个 main 方法，核心伪代码如下： 1//开启socket server 8080端口监听. ServerSocket server = new ServerSocket(8080, 1, InetAddress.getByName(&quot;127.0.0.1&quot;));try (Socket accept = serverSocket.accept(); InputStream inputStream = accept.getInputStream(); OutputStream outputStream = accept.getOutputStream()) &#123; //解析用户的请求 Request request = new Request(); request.setRequestStream(inputStream); request.parseRequest(); //生成响应对象并响应静态资源 Response resp = new Response(outputStream, request); resp.accessStaticResources();&#125; catch (IOException e) &#123; LOGGER.warn(&quot;catch from user request.&quot;,e);&#125;//关闭服务器serverSocket.close(); Request 对象 1主要功能：将用户请求（socket的inputStream流）解析为字符串，提取请求中的URI 解析字符串代码如下： 1StringBuilder requestStr = new StringBuilder();int i;//new 一个 byte缓冲数组byte[] buffer = ArrayUtil.generatorCache();try &#123; i = inputStream.read(buffer);&#125; catch (IOException e) &#123; e.printStackTrace(); i = -1;&#125;//将读取到的byte转为Stringfor (int j = 0; j &lt; i; j++) &#123; requestStr.append((char) buffer[j]);&#125;//解析请求的字符串，提取请求的URIthis.parseURI(requestStr.toString()); 那么请求的信息被我们解析成字符串了，我们怎么知道他想请求什么静态资源呢？ 那我们把解析字符串打印一下: 1System.out.println(requestStr.toString()); GET /index.html HTTP/1.1Host: 127.0.0.1:8080Connection: keep-aliveCache-Control: max-age=0User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36Upgrade-Insecure-Requests: 1Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9 可以很明显的看到，加粗的地方就是我们要提取的 URI，那么怎么提取呢？细心的我们发现了，/index.html 这段字符串前后都有一个空格！行，那我们可以直接用 String 的 indexOf 方法解析，参考代码如下： 1// 获取/index.html 前面的那个空格索引int oneSpace = requestStr.indexOf(&quot; &quot;);//获取/index.html 后面的那个空格索引int twoSpace = requestStr.indexOf(&quot; &quot;, oneSpace + 1);//截取获得用户请求URIuri = requestStr.substring(oneSpace + 1, twoSpace); Response 对象 1上面Request对象已经把用户想请求的资源解析出来了，那么Response的功能就是找到这个文件，使用Socket的outputStream把文件作为字节流输出给浏览器，就可以将我们的HTML显示给用户啦~ 那么这个项目我们的静态文件放在那里呢？来看看我们的项目结构： 1-main -java java代码 -resources -webroot 存放我们静态资源的文件夹 因为是只使用 MAVEN 构建项目，我们也没使用 Spring 等框架，如何定位到 webroot 这个文件夹呢？参考了网上的代码： 1String WEB_PROJECT_ROOT = HttpServer.class.getClassLoader().getResource(&quot;webroot&quot;).getFile().substring(1); 前面的疑惑都解决了，接下来我们就直接把对应的文件找到给写回去就完事了~伪码如下： 1//根据请求URI找到用户对应请求的资源文件File staticResource = new File(HttpServer.WEB_PROJECT_ROOT + request.getUri());//资源存在if (staticResource.exists() &amp;&amp; staticResource.isFile()) &#123; outputStream.write(this.responseToByte(200,&quot;OK&quot;)); write(staticResource);//资源不存在，使用默认的404返回&#125; else &#123; staticResource = new File(HttpServer.WEB_PROJECT_ROOT + &quot;/404.html&quot;); outputStream.write(this.responseToByte(404,&quot;file not found&quot;)); write(staticResource);&#125; 其中，responseToByte() 这个方法只负责将响应行输出： 1HTTP/1.1 200 OK 资源不存在时咱们就输出： 1HTTP/1.1 404 file not found write() 方法也很简单，将传入的 file 对象转成流并使用 socket 的 outputStream 输出 1try (FileInputStream fis = new FileInputStream(file)) &#123; byte[] cache = new byte[1024]; int read; while ((read = fis.read(cache, 0, 1024)) != -1) &#123; outputStream.write(cache, 0, read); &#125;&#125; 看看效果运行 main 方法，打开我们的浏览器输出 127.0.0.1/index.html 按下回车，可以看到结果如图： 试试随便输入一个不存在的资源：按下 F12 看看 Http 请求和响应分别是怎样的： 1请求：GET /abc.html HTTP/1.1Host: 127.0.0.1:8080其他请求头忽略...响应：HTTP/1.1 404 file not found&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;404 not found!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;请求页面不存在！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 到这里，咱们的 Tomcat 1.0 web 服务器就已经开发完成啦（滑稽脸），已经可以实现简单的 html 和 css、图片等资源的访问等功能，下一章咱们来实现以下简单的 Servlet 容器功能开发： PS：本章源码已上传 github SimpleTomcat 跟我一起动手实现 Tomcat（二）: 实现简单的 Servlet 容器前言1章节循序渐进的讲解了tomcat的原理，在接下来的章节中，tomcat都是基于上一章新增功能并完善，到最后形成一个简易版tomcat的完成品。所以有兴趣的同学请按顺序阅读，本文为记录第二章的知识点以及源码实现（造轮子）。 内容回顾跟我一起动手实现 Tomcat（一）: 实现静态 Web 服务器上一章我们实现了简单的静态资源 web 服务器，能够读取到用户自定义的 HTML/css/js / 图片并显示到浏览器以及 404 页面的展示等。 本章内容本章会实现简单的 Servlet 容器，能够根据用户请求 URI 调用对应的 Servlet 的 service() 方法并执行，init()/destory() 方法和 HttpServletRequest/HttpServletResponse 里面的大部分方法本章仍未实现，会在下面的几章逐步完善。 开始之前 javax.servlet.Servlet 1咱们web开发的同学都知道，刚学习web开发的时候都是先实现这个Servlet接口去自定义自己的Servlet类的，那么在这里简单的回顾一下Servlet这个接口。 项目加个依赖： 1&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt; Servlet 接口方法一览（具体方法干嘛的大家应该都懂了，就不介绍了）： 1public interface Servlet &#123; public void init(ServletConfig config) throws ServletException; public ServletConfig getServletConfig(); public void service(ServletRequest req, ServletResponse res)throws ServletException, IOException; public String getServletInfo();public void destroy();&#125; 如何实现 在这里基于上一章的代码，只要用户输入 127.0.0.1:8080/servlet/{servletName}，我们就将这个 URI 提取出具体的 servlet 名字，使用 java.net 包下的 URLClassLoader 将这个 Servlet 类加载并实例化，然后调用它的 service() 方法，一次 Servlet 调用就这样完成啦，是不是很简单呢，来让我们看看代码怎么去实现！！！ 代码实现1. 实现相应的接口 我们先把上个章节的 Request、Response 分别实现 ServletRequest、ServletResponse 接口（这是 Servlet 规范），具体实现的方法咱们什么都不做，等以后再完善。 1public class Request implements ServletRequest &#123; ...省略N个方法&#125;public class Response implements ServletResponse &#123; /*Response只实现这个方法，把我们socket的outputStream封装成一个PrintWriter*/ @Override public PrintWriter getWriter() throws IOException &#123; PrintWriter writer = new PrintWriter(outputStream,true); return writer; &#125;&#125; 2. 不同资源使用不同的执行器 我们的 tomcat 准备要支持 servlet 调用了，那么 servlet 和普通静态资源不一样，那么我们在代码层面应该将他们隔离开来，以方便日后的扩展，在这里我们实现以下两个执行器： 1- ServletProcess 专门执行Servlet的执行器 - StaticResourceProcess 执行静态资源的执行器 那么我们看看我们现在一个请求的执行流程： 好吧其实大家可以看到，跟以前变化也不是很大，只是多了个 if 判断，然后把相应的执行过程丢到执行器里面去执行而已~ 那我们来看看对应的实现： HttpServer 大家应该还记得 HttpServer 吧，是我们启动程序的主入口以及 ServerSocket 监听实现。它的改动不大，只是加了个 if 判断： 1public static void main(String[] args) &#123; ServerSocket serverSocket = new ServerSocket(8080, 1, InetAddress.getByName(&quot;127.0.0.1&quot;)); .... //解析用户的请求 Request request = new Request(); request.setRequestStream(inputStream); request.parseRequest(); //生成相应的响应 Response response = new Response(outputStream, request); //根据URI调用不同的处理器处理请求 if (request.getUri().startsWith(&quot;/servlet/&quot;)) &#123; new ServletProcess().process(request, response); &#125; else &#123; new StaticResourceProcess().process(request, response); &#125; ...&#125; StaticResourceProcess StaticResourceProcess 也没干啥，只是调用了上个章节读取静态资源的方法 1public class StaticResourceProcess &#123; public void process(Request request, Response response) throws IOException &#123; response.accessStaticResources(); &#125;&#125; ServletProcess ServletProcess 持有了一个 URLClassLoader 静态变量，专门用来加载 Servlet： 1private static final URLClassLoader URL_CLASS_LOADER;static &#123; /*定位到我们的webroot/servlet/文件夹*/ URL servletClassPath = new File(HttpServer.WEB_ROOT, &quot;servlet&quot;).toURI().toURL(); //初始化classloader URL_CLASS_LOADER = new URLClassLoader(new URL[]&#123;servletClassPath&#125;);&#125; 现在我们知道以 / servlet / 开头的 URI 请求是需要调用 Servlet 资源的，那么我们怎么提取 Servlet 的名字并初始化呢？先来看看一个 URI： 1/servlet/TestServlet 好像也不是很难提取，直接用 String 的 lastIndexOf 和 substring 方法就可以搞定啦： 1uri = uri.substring(uri.lastIndexOf(&quot;/&quot;) + 1); 前面的难题也都解决了，那么我们看看 process 是怎么执行的： 1public void process(Request request, Response response) throws IOException &#123; //就是上面的那个字符串截取方法 String servletName = this.parseServletName(request.getUri()); //使用URLClassLoader加载这个Servlet并实例化 Class servletClass = = URL_CLASS_LOADER.loadClass(servletName); Servlet servlet = (Servlet) servletClass.newInstance(); response.getWriter().println(new String(response.responseToByte(HttpStatusEnum.OK))); //调用servlet的service方法 servlet.service(request,response);&#125; 大家可能不太理解倒数第二行的代码，它就是调用了 Response.PrintWriter(我们刚才上面用 socket 的 outputStream 封装的) 对象向浏览器输出了一个响应头（不这么做傲娇的 chrome 会认为这个响应是无效的，servlet 回显的内容就看不到了 ServletProcess 大致调用流程： 3. 准备一个自定义 Servlet 我们 Servlet 容器也算开发完成了，我们搞一个 servlet 做做实验吧~ 1public class TestServlet implements Servlet &#123; public void init(ServletConfig config) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(&quot;Start invoke TestServlet ... &quot;); res.getWriter().println(&quot;Hello Servlet!&quot;); &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123; &#125;&#125; 它只是在控制台输出一个记录以及向浏览器回显一句话（是不是觉得不能处理参数很无聊，下面几章我们就会实现它），把这个类编译成 class 文件，丢到我们 resource/webroot/servlet 文件夹下，打开浏览器走一波： 搞定！不对… 其实上面的设计是有很严重的缺陷的 加强 Request、Response 安全性 缺陷在哪里 细心的哥们肯定发现了：我们在 ServletProcess 调用用户自定义的 servlet 的时候，是直接将 Request/Response 作为参数传入用户的 service 方法中 (因为我们的 reuqest、response 实现了 ServletRequest、ServletResponse 接口)，那么如果我们的这个 tomcat 拿去发布给其他人使用的时候，阅读过我们的 tomcat 源码的人的 servlet 就可以这样写: 1public class TestServlet &#123; public void service(HttpServletRequest request,HttpServletResponse response)&#123; ((Request)request).parseRequest(&quot;&quot;); ((Response)response).accessStaticResources(); &#125;&#125; 上面那两个方法我们设计时是提供我们 process 或者其他时候使用的 (所以方法不能设置为 private)，并不是提供给用户调用的，这就破坏了封装性了！！ 解决方案 有看过或者阅读过 Tomcat 源码的时候，发现 Tomcat 已经用了一种设计模式去解决这个缺陷了，就是外观设计模式 (门面设计模式)，具体设计模式大家可以去搜索了解一下，在这里我们也引用这种设计模式处理这个缺陷，UML 类图关系如下：代码也很简单都是调用内部 request 对象的相应方法： 1public class RequestFacade implements ServletRequest&#123; private Request request; @Override public Object getAttribute(String name) &#123; return request.getAttribute(name); &#125; 其他实现的方法也类似...&#125; 在 ServletProcess 方法调用 servlet 时我们用 Facade 类包装一下： 1...Servlet servlet = (Servlet) servletClass.newInstance();servlet.service(new RequestFacade(request), new ResponseFacade(response));... 就此大功告成！ 1使用者顶多只能将ServletRequest/ServletResponse向下转型为RequestFacade/ResponseFacade 但是我们没提供getReuqest()/getResponse()方法，所以它能调用的方法还是相应ServletRequest、ServletResponse接口定义的方法，这样我们内部的方法就不会被用户调用到啦~ 到这里，咱们的 Tomcat 2.0 web 服务器就已经开发完成啦（滑稽脸），已经可以实现简单的自定义 Servlet 调用，但是很多功能仍未完善： 1- 每一次请求就new一次Servlet，Servlet应该在初始化项目时就应该初始化，是单例的。 - 并未遵循Servlet规范实现相应的生命周期，例如init()/destory()方法我们均未调用。 - ServletRequest/ServletResponse接口的方法我们仍未实现 - 其他未实现的功能 在下一个章节我们会实现 Request 解析 Parameter、HTTPHeader、Cookie 等参数并重构架构模式： 跟我一起动手实现 Tomcat（三）: 解析 Request 请求参数、请求头、cookie PS：本章源码已上传 github SimpleTomcat 跟我一起动手实现 Tomcat（三）: 解析 Request 请求参数、请求头、cookie前言1最近笔者读了《深入剖析tomcat》这本书（原作：《how tomcat works》）,发现该书简单易读，每个章节循序渐进的讲解了tomcat的原理，在接下来的章节中，tomcat都是基于上一章新增功能并完善，到最后形成一个简易版tomcat的完成品。所以有兴趣的同学请按顺序阅读，本文为记录第三章的知识点以及源码实现（造轮子）。 内容回顾跟我一起动手实现 Tomcat（二）: 实现简单的 Servlet 容器上一章我们实现了一个简单的 Servlet 容器，能够调用并执行用户自定义实现 Servlet 接口的类。 本章内容 模块模仿 tomcat，实现 Connector(连接器)、Bootstrap(启动器) 和核心模块。 能够执行继承 HttpServlet 类的自定义 Servlet(上一章是实现了 Servlet 接口) 能够解析用户请求参数 (Parameters)/Cookie / 请求头 (Header) 开始之前 简单介绍 Connector(连接器) 对 Tomcat 比较熟悉的朋友对这个词应该不陌生，后面的篇幅会继续比较详细介绍，在这里不熟悉的朋友可以理解为：连接器只是负责接收请求，然后将请求丢给 Container(容器) 去执行相应的请求。 javax.servlet.http.HttpServlet 类 上一章我们自定义的 Servlet 是实现了 Servlet 接口，实例化 Servlet 的时候我们是将解析的 Request/Response(分别实现了 ServletRequest/ServletResponse 接口) 传入对应的 service() 方法中完成执行。那我们来回顾一下刚学 Servlet 开发的时候，大部分教程都按顺序讲解实现 Servlet 接口、继承 GenericServlet 类、继承 HttpServlet 类这三种方式去写自己的 Servlet，那么后面推荐的仍然是最后一种，重写其中的 doGet()/doPost() 方法即可，那么我们来看看上一章我们的 tomcat 能不能支持继承 HttpServlet 类的 Servlet 呢： 1//HttpServlet源代码片段public abstract class HttpServlet extends GenericServlet &#123; ... public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException&#123; HttpServletRequest request; HttpServletResponse response; //如果传进来的request/response对象不是Http类型的则抛异常 if (!(req instanceof HttpServletRequest &amp;&amp; res instanceof HttpServletResponse)) &#123; throw new ServletException(&quot;non-HTTP request or response&quot;); &#125; request = (HttpServletRequest) req; response = (HttpServletResponse) res; service(request, response); &#125; ...&#125; 如上所示源码，再来看看我们上一章的 ServletProcess 调用 Servlet 源码: 1servlet.service(new RequestFacade(request), new ResponseFacade(response)); 很明显上一章的 request/response 在 HttpServlet 时会抛出异常，所以本章我们会将 Request/Response 以及它们的外观类都实现 HttpServletRequest/HttpServletResponse 接口。 代码实现在代码实现前我们看看整体模块以及流程执行图（看不清可以点击放大）： 1. Bootstrap 模块 启动模块目前我们没有多大工作，只是启动 HttpConnector： 1public final class Bootstrap &#123; public static void main(String[] args)&#123; new HttpConnector().start(); &#125;&#125; 2. HttpConnector 模块 (连接器) 1连接器模块和下面的核心模块的前身其实就是上一章的HttpServer类，我们把它按功能拆分成了 等待和建立连接(HttpConnector)/处理连接(HttpProcess)2个模块。 连接器功能是等待请求并将请求丢给相应执行器去执行： 1public class HttpConnector implements Runnable &#123; public void start()&#123; new Thread(this).start(); &#125; @Override public void run() &#123; ServerSocket serverSocket = new ServerSocket(8080, 1, InetAddress.getByName(&quot;127.0.0.1&quot;)); while (true) &#123; Socket accept = serverSocket.accept(); HttpProcess process = new HttpProcess(this); process.process(accept); &#125; serverSocket.close(); &#125;&#125; 3. 核心模块 (执行器) 1上面也有说到，执行器也是上一章HttpServer类的前身，只不过这章我们修改了解析请求信息的方式。 主要代码 1public class HttpProcess &#123; private HttpRequest request; private HttpResponse response; public void process(Socket socket) &#123; InputStream input = socket.getInputStream(); OutputStream output = socket.getOutputStream(); //初始化request以及response request = new HttpRequest(input); response = new HttpResponse(output, request); //解析request请求行和请求头 this.parseRequestLine(input); this.parseHeaders(input); //调用对应的处理器处理 if (request.getRequestURI().startsWith(SERVLET_URI_START_WITH)) &#123; new ServletProcess().process(request, response); &#125; else &#123; new StaticResourceProcess().process(request, response); &#125; &#125;&#125; 看了上面的实现可能很多人对有些对象有点陌生，下面一一介绍： 11\. HttpRequest/HttpResponse变量就是上一章的Request/Response对象，因为实现了 HttpServletReuqest/HttpServletResponse也就顺便改了个名，将会在下面介绍； 2\. 每一个请求都对应了一个HttpProcess对象，所以这里request/response是成员变量； 3\. 解析请求行和解析请求头的方法也在下面介绍。 parseRequestLine、parseHeaders 方法 让我们先看看一个原始的 HTTP 请求字符串，看看如何去解析请求行和请求头： 1GET /index.html?utm_source=aaa HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: keep-alive\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\r\nAccept: text/html\r\nAccept-Encoding: gzip, deflate, sdch, br\r\nAccept-Language: zh-CN,zh;q=0.8\r\nCookie: BAIDUID=462A9AC35EE6158AA7DFCD27AF:FG=1; BIDUPSID=462A9AC35EE6158AA7DF027AF; PSTM=1506310304; BD_CK_SAM=1; PSINO=7; BD_HOME=1; H_PS_PSSID=1459_24885_21115_25436; BD_UPN=12314353; sug=3; sugstore=0; ORIGIN=2; bdime=0\r\n 大家可以发现，其实我们使用 socket 读取 HTTP 请求时候，发现每一行都会有’\r\n’这个回车换行符，只不过在我们浏览器按 F12 时被浏览器自动解析成了换行而已，我们分析上面的这个请求信息得出以下规律： 每一行结尾字符都是\r\n- 请求行（第一行）的HTTP请求方法、URI、请求协议中间都有个空格- 第二行开始（请求头）key和value的内容都是以’:’和一个’ ‘字符隔开- Cookie的键值对是以’=’分割，以’;’和’ ‘区分前后键值对 接下来我们分别去解析以下 ISO-8859-1 编码情况下上面字符对应的值，并建立一个常量类： 1public class HttpConstant &#123; /* 回车 \r */ public static final byte CARRIAGE_RETURN = 13; /* 换行 \n */ public static final byte LINE_FEED = 10; /* 空格 */ public static final byte SPACE = 32; /* 冒号 : */ public static final byte COLON = 58;&#125; 1.parseRequestLine 方法 根据上面的思路，我们就可以轻松地解析请求行的数据： 1StringBuilder temp = new StringBuilder();int cache;while ((cache = requestStream.read()) != -1) &#123; //读取到第一个\r\n时则说明读取请求行完毕 if (HttpConstant.CARRIAGE_RETURN == cache &amp;&amp; HttpConstant.LINE_FEED == requestStream.read()) &#123; break; &#125; temp.append((char)cache);&#125;String[] requestLineArray = temp.toString().split(&quot; &quot;); 最后分割空格使用数组装着请求行（如果你有更好的方案也可以在评论区说一说哈）接下来判断 URI 有没有使用 “?” 传递参数，如果有就截取并丢到 HttpRequest 的 QueryString 变量中，最后截取 URI 即可。 1String uri = requestLineArray[1];int question = uri.indexOf(&quot;?&quot;);if (question &gt;= 0) &#123; request.setQueryString(uri.substring(question+1,uri.length())); uri = uri.substring(0,question);&#125; 1判断是不是从?传递jsessionid过来，如果是就赋值到request对象中 1String match = &quot;;jsessionid=&quot;;int semicolon = uri.indexOf(match);if (semicolon &gt;= 0) &#123; String rest = uri.substring(semicolon + match.length()); int semicolon2 = rest.indexOf(&apos;;&apos;); if (semicolon2 &gt;= 0) &#123; request.setRequestedSessionId(rest.substring(0, semicolon2)); rest = rest.substring(semicolon2); &#125; else &#123; request.setRequestedSessionId(rest); rest = &quot;&quot;; &#125; request.setRequestedSessionURL(true); uri = uri.substring(0, semicolon) + rest;&#125; else &#123; request.setRequestedSessionId(null); request.setRequestedSessionURL(false);&#125; 这里调用了一个校验 URI 合法性的方法, 如果 URI 不合法 (例如包含’.//‘之类跳转目录的危险字符)则抛异常，否则就将上面解析到的内容丢到 request 中去。 1String normalizedUri = this.normalize(uri);if (normalizedUri == null) &#123; throw new ServletException(&quot;Invalid URI: &quot; + uri + &quot;&apos;&quot;);&#125;request.setRequestURI(normalizedUri);request.setMethod(requestLineArray[0]);request.setProtocol(requestLineArray[2]); 就这样，请求行的信息就被我们读取完毕，那我们再来看看读取请求头的代码： parseHeaders 方法 这里有个坑：Socket 的 read()方法读取完毕时最后一个字节不是 - 1，而是阻塞等待 Socket 客户端发送 - 1 过来结束读取，但是我们的 Socket 客户端是浏览器，浏览器不会发送 - 1 以表示结束发送，所以我们结合 InputStream#available()方法 (返回实际还可以读取的字节数) 来判断是否读取完毕即可。 1public void parseHeader() &#123; StringBuilder sb = new StringBuilder(); int cache; while (input.available() &gt; 0 &amp;&amp; (cache = input.read()) &gt; -1) &#123; sb.append((char)cache); &#125; ....看下文&#125; 读取完毕效果如图：如果是 POST 请求，那么表单参数会在空行后面： 也很有规律，请求头都用 \ r\n 隔开，并且如果是 POST 请求提交表单，那么表单参数会在一个空行后面 (两个 \ r\n) 1//使用\r\n分割请求头Queue&lt;String&gt; headers = Stream.of(sb.toString().split(&quot;\r\n&quot;)).collect(toCollection(LinkedList::new));while (!headers.isEmpty()) &#123; //获取一个请求头 String headerString = headers.poll(); //读取到空行则说明请求头已读取完毕 if (StringUtil.isBlank(headerString)) &#123; break; &#125; //分割请求头的key和value String[] headerKeyValue = headerString.split(&quot;: &quot;); request.addHeader(headerKeyValue[0], headerKeyValue[1]);&#125;//如果在读取到空行后还有数据，说明是POST请求的表单参数if(!headers.isEmpty())&#123; request.setPostParams(headers.poll());&#125; 大致流程： 最后我们对一些特殊的请求头信息设置到 Request 对象中 (cookie、content-type、content-length); 1String contentLength = request.getHeader(&quot;content-length&quot;);if(contentLength!=null)&#123; request.setContentLength(Integer.parseInt(contentLength));&#125;request.setContentType(request.getHeader(&quot;content-type&quot;));Cookie[] cookies = parseCookieHeader( request.getHeader(&quot;cookie&quot;));Stream.of(cookies).forEach(cookie -&gt; request.addCookie(cookie));//如果sessionid不是从cookie中获取的，则优先使用cookie中的sessionidif (!request.isRequestedSessionIdFromCookie()) &#123; Stream.of(cookies) .filter(cookie -&gt; &quot;jsessionid&quot;.equals(cookie.getName())) .findFirst(). ifPresent(cookie -&gt; &#123; //设置cookie的值 request.setRequestedSessionId(cookie.getValue()); request.setRequestedSessionCookie(true); request.setRequestedSessionURL(false); &#125;);&#125; 读取 cookie 的方法也很简单： 1private Cookie[] parseCookieHeader(String cookieListString) &#123; return Stream.of(cookieListString.split(&quot;; &quot;)) .map(cookieStr -&gt; &#123; String[] cookieArray = cookieStr.split(&quot;=&quot;); return new Cookie(cookieArray[0], cookieArray[1]); &#125;).toArray(Cookie[]::new);&#125; 不熟悉 JDK8 语法的小伙伴们可能看不太懂干了什么，没关系来张图解释一下上面那段代码内容： 到这里，HttpProcess 处理请求的逻辑就搞定啦，(是不是觉得代码有点多)，细心的客官们一定发现了，request 怎么可以设置那么多属性呢？上一章的 request 好像没有那么多功能吧？是的，我们这一章也对 request/response 做了手脚，请看下文分析： HttpRequest(上一章的 Request 对象) 没错，在文章的开头我们已经说了要把 Request 升级一下，那么怎么升级呢？也就是实现 HttpServletRequest 接口啦： 1public class HttpRequest implements HttpServletRequest &#123; private String contentType; private int contentLength; private InputStream input; private String method; private String protocol; private String queryString; private String postParams; private String requestURI; private boolean requestedSessionCookie; private String requestedSessionId; private boolean requestedSessionURL; protected ArrayList&lt;Cookie&gt; cookies = new ArrayList&lt;&gt;(); protected HashMap&lt;String, ArrayList&lt;String&gt;&gt; headers = new HashMap&lt;&gt;(); protected ParameterMap parameters; ...&#125; 哈哈没有看错，多了一堆参数，但是细心的客官们应该可以看到，这些参数都是非常眼熟，而且上面已经对大部分参数设值过了，眼生的可能就是下面的那个 ParameterMap，那么等下我们慢慢分析：(那些 get、set 方法就不分析了) 请求头 (header) 操作： 1public void addHeader(String name, String value) &#123; name = name.toLowerCase(); //如果key对应的value不存在则new一个ArrayList ArrayList&lt;String&gt; values = headers.computeIfAbsent(name, k -&gt; new ArrayList&lt;&gt;()); values.add(value);&#125;public ArrayList getHeaders(String name) &#123; name = name.toLowerCase(); return headers.get(name);&#125;public String getHeader(String name) &#123; name = name.toLowerCase(); ArrayList&lt;String&gt; values = headers.get(name); if (values != null) &#123; return values.get(0); &#125; else &#123; return null; &#125;&#125; public ArrayList getHeaderNames() &#123; return new ArrayList(headers.keySet());&#125; 大家可以看到请求头是是个 Map，key 是请求头的名字，value 则是请求头的内容数组 (一个请求头可以有多个内容)，所以也就是对这个 Map 做操作而已~ Cookie 操作： 1public Cookie[] getCookies() &#123; return cookies.toArray(new Cookie[cookies.size()]);&#125;public void addCookie(Cookie cookie) &#123; cookies.add(cookie);&#125; 好像也没什么好说的，对 List \ 做常规操作。 Parameters 操作：这是我们最常用的一个操作啦，那么 ParameterMap 是个什么东西呢，我们先来看看： 1public final class ParameterMap extends HashMap&lt;String,String[]&gt; &#123; private boolean locked = false; public boolean isLocked() &#123; return locked; &#125; public void setLocked(boolean locked) &#123; this.locked = locked; &#125; public String[] put(String key, String[] value) &#123; if (locked) &#123; throw new IllegalStateException(&quot;error&quot;); &#125; return (super.put(key, value)); &#125; ...&#125; 好吧其实它就是在 HashMap 基础上加了一个 locked 对象 (如果已经解析参数完毕了则将这个对象设置为 true 禁止更改),key 是参数名，value 是参数值数组 (可有多个) 例如：127.0.0.1:8080/servlet/QueryServlet?name=geoffrey&amp;name=yip 那么我们来看看对 parameter 这个 map 的操作有： 1public String getParameter(String name) &#123; parseParameters(); String[] values = parameters.get(name); return Optional.ofNullable(values).map(arr -&gt; arr[0]).orElse(null);&#125;public Map getParameterMap() &#123; parseParameters(); return this.parameters;&#125;public ArrayList&lt;String&gt; getParameterNames() &#123; parseParameters(); return new ArrayList&lt;&gt;(parameters.keySet());&#125; public String[] getParameterValues(String name) &#123; parseParameters(); return parameters.get(name);&#125; 代码都很简单，但是这个 parseParameters() 是什么呢，对，它是去解析请求的参数了 (懒加载)，因为我们不知道用户使用 Servlet 会不会用到请求参数这个功能，而且解析它的开销比解析其他数据大，所以我们会在用户真正使用参数的时候才会去解析，提高整体的响应速度，大概的代码如下： 1protected void parseParameters() &#123; if (parsed) &#123; //已经解析过则停止解析 return; &#125; ParameterMap results = parameters; if (results == null) &#123; results = new ParameterMap(); &#125; results.setLocked(false); String encoding = getCharacterEncoding(); if (encoding == null) &#123; encoding = StringUtil.ISO_8859_1; &#125; // 解析URI携带的请求参数 String queryString = getQueryString(); this.parseParameters(results, queryString, encoding); // 初始化Content-Type的值 String contentType = getContentType(); if (contentType == null) &#123; contentType = &quot;&quot;; &#125; int semicolon = contentType.indexOf(&apos;;&apos;); if (semicolon &gt;= 0) &#123; contentType = contentType.substring(0, semicolon).trim(); &#125; else &#123; contentType = contentType.trim(); &#125; //解析POST请求的表单参数 if (HTTPMethodEnum.POST.name().equals(getMethod()) &amp;&amp; getContentLength() &gt; 0 &amp;&amp; &quot;application/x-www-form-urlencoded&quot;.equals(contentType)) &#123; this.parseParameters(results, getPostParams(), encoding); &#125; //解析完毕就锁定 results.setLocked(true); parsed = true; parameters = results;&#125;/** * 解析请求参数 * @param map Request对象中的参数map * @param params 解析前的参数 * @param encoding 编码 */public void parseParameters(ParameterMap map, String params, String encoding) &#123; String[] paramArray = params.split(&quot;&amp;&quot;); Stream.of(paramArray).forEach(param -&gt; &#123; String[] splitParam = param.split(&quot;=&quot;); String name = splitParam[0]; String value = splitParam[1]; //此处是将key和value使用URLDecode解码并添加进map中 putMapEntry(map, urlDecode(name, encoding), urlDecode(value, encoding)); &#125;);&#125; 大概内容就是根据之前 HttpProcess 解析请求行的 queryString 参数以及如果是 POST 请求的表单数据放入 ParameterMap 中，并且锁定 Map。 HttpResponse(上一章的 Response 对象) HttpResponse 对象也跟随者实现了 HttpServletResponse 接口，但是本章没有实现具体的内容，所以此处略过。 1public class HttpResponse implements HttpServletResponse &#123; ...&#125; ServletProcess ServletProcess 具体只需要将 request 和 response 的外观类跟着升级实现对应的接口即可： 1public void process(HttpRequest request, HttpResponse response) throws IOException &#123; ... servlet.service(new HttpRequestFacade(request), new HttpResponseFacade(response)); ...&#125;public class HttpRequestFacade implements HttpServletRequest &#123; private HttpRequest request; ...&#125;public class HttpResponseFacade implements HttpServletResponse &#123; private HttpResponse response; ...&#125; 实验我们先编写一个 Servlet： 1/** * 测试注册Servlet */public class RegisterServlet extends HttpServlet &#123; @Override public void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; //打印表单参数 String name = req.getParameter(&quot;name&quot;); String password = req.getParameter(&quot;password&quot;); if (StringUtil.isBlank(name) || StringUtil.isBlank(password)) &#123; try &#123; resp.getWriter().println(&quot;账号/密码不能为空！&quot;); &#125; finally &#123; return; &#125; &#125; //打印请求行 System.out.println(&quot;Parse user register method:&quot; + req.getMethod()); //打印Cookie System.out.println(&quot;Parse user register cookies:&quot;); Optional.ofNullable(req.getCookies()) .ifPresent(cookies -&gt; Stream.of(cookies) .forEach(cookie -&gt;System.out.println(cookie.getName() + &quot;:&quot; + cookie.getValue() ))); //打印请求头 System.out.println(&quot;Parse http headers:&quot;); Enumeration&lt;String&gt; headerNames = req.getHeaderNames(); while (headerNames.hasMoreElements()) &#123; String headerName = headerNames.nextElement(); System.out.println(headerName + &quot;:&quot; + req.getHeader(headerName)); &#125; System.out.println(&quot;Parse User register name :&quot; + name); System.out.println(&quot;Parse User register password :&quot; + password); try &#123; resp.getWriter().println(&quot;注册成功！&quot;); &#125; finally &#123; return; &#125; &#125; @Override public void doPost(HttpServletRequest req, HttpServletResponse resp) &#123; this.doGet(req, resp); &#125;&#125; 编写一个 HTML： 1&lt;html&gt; &lt;head&gt; &lt;title&gt;注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;/servlet/RegisterServlet&quot;&gt; 账号：&lt;input type=&quot;text&quot; &gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 打开浏览器测试: 控制台输出： 到这里，咱们的 Tomcat 3.0 web 服务器就已经开发完成啦（滑稽脸），已经可以实现简单的自定义 Servlet 调用，以及请求行 / 请求头 / 请求参数 / cookie 等信息的解析，待完善的地方还有很多： 1- HTTPProcess一次性只能处理一个请求，其他请求只能堵塞，不具备服务器使用性。 - 每一次请求就new一次Servlet，Servlet应该在初始化项目时就应该初始化，是单例的。 - 并未遵循Servlet规范实现相应的生命周期，例如init()/destory()方法我们均未调用。 - HttpServletRequest/HttpServletResponse接口的大部分方法我们仍未实现 - 架构/包结构和tomcat相差太多 - 其他未实现的功能 在下一章节我们会把我们的连接器实现 Catalina 的 Connector 接口，并且使得我们可以同时处理多个请求，最终我们的连接器实现的功能以及结构和 Tomcat4 版本的默认连接器基本一致。 PS：本章源码已上传 github： SimpleTomcat 原文：Geoffrey.Yip🌴 的个人主页 - 专栏 - 掘金https://juejin.im/user/5915598ba0bb9f005fd2feb1/posts]]></content>
      <tags>
        <tag>待阅</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas处理数据,Echarts可视化]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27%2F</url>
    <content type="text"><![CDATA[先连接在线数据库： 1234567891011import pymysqlimport pandas as pdimport jsonconn = pymysql.connect( host = '', user = '',#一般默认用户名 passwd = '',#本地数据库登录密码 db = 'scratchDB',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码) 根据现有数据集进行数据表查询集构建： galleryproduction 左外联结 production: 对应pandas的操作： 123sql1 = 'SELECT scratch_api_production.id,scratch_api_galleryproduction.production_id,scratch_api_production.name FROM scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_production.id=scratch_api_galleryproduction.production_id;'df1 = pd.read_sql(sql1,conn)df1 production 左外联结 user: 123sql1 = 'SELECT scratch_api_production.author_id,scratch_api_user.baseuser_ptr_id,scratch_api_user.sex,scratch_api_user.grade FROM scratch_api_production LEFT JOIN scratch_api_user ON scratch_api_production.author_id=scratch_api_user.baseuser_ptr_id;'df1 = pd.read_sql(sql1,conn)df1 再构建三联表： galleryproduction左外联结production左外联结user 三表联结查询模版： 123sql1 = 'SELECT * FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id;'df1 = pd.read_sql(sql1,conn)df1 我根据业务流程实现的sql查询： 查询某专题活动中的所有信息123sql1 = "SELECT * FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id WHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1;"df1 = pd.read_sql(sql1,conn)df1 然后使用python，将上面的表集合按照要求保存到本地的json数据库中，使用echarts接口对接，进行数据可视化 需要对接接口： 查询点赞数最多作品排行：1234sql1 = "SELECT scratch_api_production.like,scratch_api_production.name FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id WHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' AND sex='男' ORDER BY scratch_api_production.like DESC;"df1 = pd.read_sql(sql1,conn)#df1df1.to_json('/Users/pailiu/Downloads/查询点赞数最多作品排行.json',orient='table') 看到展示的结果符合要求，可以保存为json文件： json格式化后的效果如下： 在echarts中选择合适的图表进行展示： http://echarts.baidu.com/examples/editor.html?c=bar-y-category&amp;theme=light 页面中的参数如下： 12345678910111213141516171819202122232425262728293031323334app.title = &apos;作品点赞排行榜 - 条形图&apos;;option = &#123; title: &#123; text: &apos;作品点赞排行榜&apos;, subtext: &apos;数据来自maibao&apos; &#125;, tooltip: &#123; trigger: &apos;axis&apos;, axisPointer: &#123; type: &apos;shadow&apos; &#125; &#125;, grid: &#123; left: &apos;3%&apos;, right: &apos;4%&apos;, bottom: &apos;3%&apos;, containLabel: true &#125;, xAxis: &#123; type: &apos;value&apos;, boundaryGap: [0, 0.01] &#125;, yAxis: &#123; type: &apos;category&apos;, data: [&apos;巴西&apos;,&apos;印尼&apos;,&apos;美国&apos;,&apos;印度&apos;,&apos;中国&apos;] &#125;, series: [ &#123; type: &apos;bar&apos;, data: [19325, 23438, 31000, 121594, 134141] &#125; ]&#125;; 接下来进行接口对接：点击下载，将html文件下载下来，在本地服务器中测试运行效果是否一致： 退出循环尽管 ES5 提供了 forEach 方法，但是 forEach 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。但是对于 jQuery 的 each 函数，如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。https://github.com/mqyqingfeng/Blog/issues/40 12345678$.each( [0, 1, 2, 3, 4, 5], function(i, n)&#123; if (i &gt; 2) return false; console.log( "Item #" + i + ": " + n );&#125;);// Item #0: 0// Item #1: 1// Item #2: 2 最终js写法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;script type="text/javascript"&gt; function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('container')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; title: &#123; text: '作品点赞排行榜', subtext: '数据来自maibao' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['发布排行'] &#125;, xAxis: &#123; data: [] &#125;, yAxis: &#123;&#123;# splitLine: &#123; show: false &#125;,//去除网格线#&#125; name: '' &#125;, series: [&#123; barWidth: "30px", name: '发布排行', type: 'bar', itemStyle: &#123; normal: &#123; label: &#123; show: true, position: 'top', textStyle: &#123; color: '#333' &#125; &#125; &#125; &#125;, data: [] &#125;] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（实际用来盛放X轴坐标值） var nums = []; //销量数组（实际用来盛放Y坐标值） $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/查询点赞数最多作品排行.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 var i = 0; $.each(result.data, function (index, item) &#123; if (index &gt;= 5) return false; // names.push(item.name); //挨个取出类别并填入类别数组 nums.push(item.like); //挨个取出销量并填入销量数组 &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 xAxis: &#123; data: names &#125;, series: [&#123; // 根据名字对应到相应的系列 name: '发布排行', //显示在上部的标题 data: nums &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;; loadOneColumn();&lt;/script&gt; 最终效果： 查询某次活动结果集中的男女人数1234#查询结果集中的男女人数sql1 = "SELECT sex , COUNT(sex) AS 'nums' FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id WHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='男' UNION SELECT sex as 性别, COUNT(sex) AS '人数' FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id WHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='女';"df1 = pd.read_sql(sql1,conn)df1.to_json('/Users/pailiu/Downloads/查询结果集中的男女人数.json',orient='table') 在echarts中选择合适的图表： 图中代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;script type="text/javascript"&gt;function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('gender')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; color: ['#ff7d27', '#47b73d', '#fcc36e', '#57a2fd', "#228b22"],//饼图颜色 title: &#123; text: '参赛男女比例', subtext: 'from麦宝', x:'center' &#125;, tooltip: &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, legend: &#123; orient: 'vertical', x: 'left', data: [] &#125;, toolbox: &#123; show: true, feature: &#123; mark: &#123; show: true &#125;,&#123;# dataView: &#123; show: true, readOnly: false &#125;,#&#125; magicType: &#123; show: true, type: ['pie', 'funnel'], option: &#123; funnel: &#123; x: '25%', width: '50%', funnelAlign: 'left', max: 1548 &#125; &#125; &#125;,&#123;# restore: &#123; show: true &#125;,#&#125;&#123;# saveAsImage: &#123; show: true &#125;#&#125; &#125; &#125;, series: [&#123; name: '发布排行', type: 'pie', radius: '55%', center: ['50%', '60%'], data: [] &#125;] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（用于存放饼图的类别） var brower = []; $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/查询结果集中的男女人数.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 $.each(result.data, function (index, item) &#123; names.push(item.department); //挨个取出类别并填入类别数组 brower.push(&#123; name: item.sex, value: item.nums &#125;); &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 legend: &#123; data: names &#125;, series: [&#123; data: brower &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;;loadOneColumn();&lt;/script&gt; 查询某专题活动学校参与度排名123456# 查询某专题活动学校参与度排名sql3 = "SELECT scratch_api_user.school_id ,COUNT(*) as nums FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id WHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULL GROUP BY scratch_api_user.school_id order by count(*) desc ;"df3 = pd.read_sql(sql3,conn)df3# df3.to_json('../static/BigDataAnalysis/查询某专题活动学校参与度排名.json',orient='table')# df3.to_json('/Users/pailiu/Downloads/查询某专题活动学校参与度排名.json',orient='table') 对应的js代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;script type="text/javascript"&gt; function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('school_rank')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; title: &#123; text: '学校参与排行榜', subtext: '数据来自maibao' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['发布排行'] &#125;, xAxis: &#123; data: [] &#125;, yAxis: &#123;&#123;# splitLine: &#123; show: false &#125;,//去除网格线#&#125; name: '' &#125;, series: [&#123; barWidth: "30px", name: '发布排行', type: 'bar', itemStyle: &#123; normal: &#123; label: &#123; show: true, position: 'top', textStyle: &#123; color: '#333' &#125; &#125; &#125; &#125;, data: [] &#125;] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（实际用来盛放X轴坐标值） var nums = []; //销量数组（实际用来盛放Y坐标值） $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/查询某专题活动学校参与度排名.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 var i = 0; $.each(result.data, function (index, item) &#123; if (index &gt;= 5) return false; // names.push(item.school_id); //挨个取出类别并填入类别数组 nums.push(item.nums); //挨个取出销量并填入销量数组 &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 xAxis: &#123; data: names &#125;, series: [&#123; // 根据名字对应到相应的系列 name: '发布排行', //显示在上部的标题 data: nums &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;; loadOneColumn(); &lt;/script&gt; 效果展示： 查询年级占比123456# 查询查询年级占比sql4 = "SELECT scratch_api_user.grade ,COUNT(*) as nums FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id WHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.grade is not NULL GROUP BY scratch_api_user.grade order by count(*) desc;"df4 = pd.read_sql(sql4,conn)df4# df4.to_json('../static/BigDataAnalysis/查询查询年级占比.json',orient='table')# df4.to_json('/Users/pailiu/Downloads/查询查询年级占比.json',orient='table') js如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;script type="text/javascript"&gt;function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('grade_rank')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; tooltip: &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)" &#125;, legend: &#123; orient: 'vertical', x: 'left', data:['直接访问','邮件营销','联盟广告','视频广告','搜索引擎'] &#125;, series: [ &#123; name:'访问来源', type:'pie', radius: ['50%', '70%'], avoidLabelOverlap: false, label: &#123; normal: &#123; show: false, position: 'center' &#125;, emphasis: &#123; show: true, textStyle: &#123; fontSize: '30', fontWeight: 'bold' &#125; &#125; &#125;, labelLine: &#123; normal: &#123; show: false &#125; &#125;, data:[ ] &#125; ] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（用于存放饼图的类别） var brower = []; $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/查询查询年级占比.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 $.each(result.data, function (index, item) &#123; names.push(item.grade); //挨个取出类别并填入类别数组 brower.push(&#123; name: item.grade, value: item.nums &#125;); &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 legend: &#123; data: names &#125;, series: [&#123; data: brower &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;;loadOneColumn();&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;script type="text/javascript"&gt;function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('grade_rank')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; tooltip: &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)" &#125;, legend: &#123; orient: 'vertical', x: 'left', data: names &#125;, series: [ &#123; name:'年级占比', type:'pie', radius: ['40%', '55%'], label: &#123; normal: &#123; formatter: '&#123;a|&#123;a&#125;&#125;&#123;abg|&#125;\n&#123;hr|&#125;\n &#123;b|&#123;b&#125;：&#125;&#123;c&#125; &#123;per|&#123;d&#125;%&#125; ', backgroundColor: '#eee', borderColor: '#aaa', borderWidth: 1, borderRadius: 4, // shadowBlur:3, // shadowOffsetX: 2, // shadowOffsetY: 2, // shadowColor: '#999', // padding: [0, 7], rich: &#123; a: &#123; color: '#999', lineHeight: 22, align: 'center' &#125;, // abg: &#123; // backgroundColor: '#333', // width: '100%', // align: 'right', // height: 22, // borderRadius: [4, 4, 0, 0] // &#125;, hr: &#123; borderColor: '#aaa', width: '100%', borderWidth: 0.5, height: 0 &#125;, b: &#123; fontSize: 16, lineHeight: 33 &#125;, per: &#123; color: '#eee', backgroundColor: '#334455', padding: [2, 4], borderRadius: 2 &#125; &#125; &#125; &#125;, data:[ ] &#125; ] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（用于存放饼图的类别） var brower = []; $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/查询查询年级占比.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 $.each(result.data, function (index, item) &#123; names.push(item.grade); //挨个取出类别并填入类别数组 brower.push(&#123; name: item.grade, value: item.nums &#125;); &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 legend: &#123; data: names &#125;, series: [&#123; data: brower &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;;loadOneColumn();&lt;/script&gt; 查询学校占比123456# 查询学校占比sql5 = "SELECT scratch_api_user.school_id ,COUNT(*) as nums FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id WHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULL GROUP BY scratch_api_user.school_id order by count(*) desc;"df5 = pd.read_sql(sql5,conn)df5# df4.to_json('../static/BigDataAnalysis/查询学校占比.json',orient='table')# df4.to_json('/Users/pailiu/Downloads/查询学校占比.json',orient='table') js如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;script type="text/javascript"&gt;function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('school_proportion')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; tooltip: &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)" &#125;, legend: &#123; orient: 'vertical', x: 'left', data: names &#125;, series: [ &#123; name:'学校占比', type:'pie', radius: ['40%', '55%'], label: &#123; normal: &#123; formatter: '&#123;a|&#123;a&#125;&#125;&#123;abg|&#125;\n&#123;hr|&#125;\n &#123;b|&#123;b&#125;：&#125;&#123;c&#125; &#123;per|&#123;d&#125;%&#125; ', backgroundColor: '#eee', borderColor: '#aaa', borderWidth: 1, borderRadius: 4, // shadowBlur:3, // shadowOffsetX: 2, // shadowOffsetY: 2, // shadowColor: '#999', // padding: [0, 7], rich: &#123; a: &#123; color: '#999', lineHeight: 22, align: 'center' &#125;, // abg: &#123; // backgroundColor: '#333', // width: '100%', // align: 'right', // height: 22, // borderRadius: [4, 4, 0, 0] // &#125;, hr: &#123; borderColor: '#aaa', width: '100%', borderWidth: 0.5, height: 0 &#125;, b: &#123; fontSize: 16, lineHeight: 33 &#125;, per: &#123; color: '#eee', backgroundColor: '#334455', padding: [2, 4], borderRadius: 2 &#125; &#125; &#125; &#125;, data:[ ] &#125; ] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（用于存放饼图的类别） var brower = []; $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/查询学校占比.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 $.each(result.data, function (index, item) &#123; names.push(item.school_id); //挨个取出类别并填入类别数组 brower.push(&#123; name: item.school_id, value: item.nums &#125;); &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 legend: &#123; data: names &#125;, series: [&#123; data: brower &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;;loadOneColumn();&lt;/script&gt; 查询作品提交时间 Python拼接SQL时单引号，双引号问题:在单引号双引号前加”\”进行转义 123456# 查询作品提交时间sql6 = "SELECT DATE_FORMAT(scratch_api_production.update_time,\"%Y/%m/%e\") as 'date',count(*) as 'nums' FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id) LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_id WHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 GROUP BY DATE_FORMAT(scratch_api_production.update_time,\"%Y/%m/%e\");"df6 = pd.read_sql(sql6,conn)df6# df6.to_json('../static/BigDataAnalysis/查询作品提交时间.json',orient='table')# df6.to_json('/Users/pailiu/Downloads/查询作品提交时间.json',orient='table') js如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 &lt;script type="text/javascript"&gt; function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('date_line')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; tooltip: &#123; trigger: 'axis', axisPointer: &#123; type: 'cross', crossStyle: &#123; color: '#999' &#125; &#125; &#125;, toolbox: &#123; feature: &#123;&#123;# dataView: &#123;show: true, readOnly: false&#125;,#&#125; magicType: &#123;show: true, type: ['line', 'bar']&#125;, restore: &#123;show: true&#125;,&#123;# saveAsImage: &#123;show: true&#125;#&#125; &#125; &#125;, legend: &#123; data:['投稿量'] &#125;, xAxis: [ &#123; type: 'category', data: names, axisPointer: &#123; type: 'shadow' &#125; &#125; ], yAxis: [ &#123; type: 'value', name: '投稿量', min: 0, max: 40, interval: 5, axisLabel: &#123; formatter: '&#123;value&#125; ' &#125; &#125; ], series: [ &#123; name:'投稿趋势', type:'line', // yAxisIndex: 1, data: nums &#125; ] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（实际用来盛放X轴坐标值） var nums = []; //销量数组（实际用来盛放Y坐标值） $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/查询作品提交时间.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 var i = 0; $.each(result.data, function (index, item) &#123;&#123;# if (index &gt;= 5) return false; //#&#125; names.push(item.date); //挨个取出类别并填入类别数组 nums.push(item.nums); //挨个取出销量并填入销量数组 &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 xAxis: &#123; data: names &#125;, series: [&#123; // 根据名字对应到相应的系列 name: '单日投稿量', //显示在上部的标题 data: nums &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;; loadOneColumn(); &lt;/script&gt; 把地址转换成经纬度不要方，利用高德地图经纬度快速查询工具可以轻松地把任何地址转换成经纬度，可具体到门牌号喔，工具地址：控制台 | 高德开放平台 | 高德地图API 这里使用了百度的地图扩展： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script type="text/javascript"&gt;var dom = document.getElementById("map");var myChart = echarts.init(dom);var app = &#123;&#125;;option = null;app.title = '热力图与百度地图扩展';$.get('&#123;% static "BigDataAnalysis/hangzhou-tracks.json" %&#125;', function (data) &#123; var points = [].concat.apply([], data.map(function (track) &#123; return track.map(function (seg) &#123; return seg.coord.concat([1]); &#125;); &#125;)); myChart.setOption(option = &#123; animation: false, bmap: &#123; center: [120.13066322374, 30.240018034923], zoom: 14, roam: true &#125;, visualMap: &#123; show: false, top: 'top', min: 0, max: 5, seriesIndex: 0, calculable: true, inRange: &#123; color: ['blue', 'blue', 'green', 'yellow', 'red'] &#125; &#125;, series: [&#123; type: 'heatmap', coordinateSystem: 'bmap', data: points, pointSize: 5, blurSize: 6 &#125;] &#125;); if (!app.inNode) &#123; // 添加百度地图插件 var bmap = myChart.getModel().getComponent('bmap').getBMap(); bmap.addControl(new BMap.MapTypeControl()); &#125;&#125;);;if (option &amp;&amp; typeof option === "object") &#123; myChart.setOption(option, true);&#125;&lt;/script&gt; 这里使用了数据集：http://p4lmrb1gp.bkt.clouddn.com/hangzhou-tracks.json json格式如下： 展现效果如下： http://gallery.echartsjs.com/editor.html?c=effectScatter-bmap http://echarts.baidu.com/examples/editor.html?c=effectScatter-bmap js如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258&lt;script type="text/javascript"&gt; var dom = document.getElementById("map_point"); var myChart = echarts.init(dom); var app = &#123;&#125;; option = null; var data = [ &#123;name: '稠城一校', value: 716&#125;, &#123;name: '义乌市廿三里第一小学', value: 571&#125;, &#123;name: '义乌市吴店小学', value: 442&#125;, &#123;name: '义乌市绣湖小学', value: 358&#125;, &#123;name: '义亭小学', value: 341&#125;, &#123;name: '义乌市江湾小学', value: 307&#125;, &#123;name: '义乌市赤岸小学', value: 284&#125;, &#123;name: '义乌市廿三里第二小学', value: 260&#125;, &#123;name: '义乌市上溪小学', value: 256&#125;, &#123;name: '义乌市东河小学', value: 225&#125;, &#123;name: '上溪小学', value: 225&#125;, &#123;name: '杭州市文海实验学校', value: 187&#125;, &#123;name: '义乌市大陈小学', value: 181&#125;, &#123;name: '义乌市徐江小学', value: 130&#125;, &#123;name: '义乌市倍磊小学', value: 123&#125;, &#123;name: '义乌市香山小学教育集团胜利校区', value: 87&#125;, &#123;name: '麦宝教育', value: 71&#125;, &#123;name: 'BUPT', value: 40&#125;, &#123;name: '义乌市苏溪镇西山下小学', value: 33&#125;, &#123;name: '柯桥区漓渚镇中心小学', value: 33&#125;, &#123;name: '义乌市保联小学', value: 32&#125;, &#123;name: '北京邮电大学', value: 23&#125;, &#123;name: '杭州市育海外国语学校', value: 15&#125;, &#123;name: '义乌市大陈镇大陈小学', value: 7&#125;, &#123;name: '义乌市上溪镇吴店小学', value: 3&#125;, &#123;name: '义乌市苏溪镇第三小学', value: 1&#125; ]; var geoCoordMap = &#123; '稠城一校':[120.079845,29.306292], '义乌市廿三里第一小学':[120.174312,29.32387], '义乌市吴店小学':[119.911287,29.258073], '义乌市绣湖小学':[120.070803,29.307213], '义亭小学':[119.963402,29.240663], '义乌市江湾小学':[120.027102,29.262128], '义乌市赤岸小学':[120.038164,29.144239], '义乌市廿三里第二小学':[120.173303,29.3393], '义乌市上溪小学':[119.931584,29.27996], '义乌市东河小学':[119.991707,29.309221], '上溪小学':[119.931561,29.279982], '杭州市文海实验学校':[120.380516,30.3059], '义乌市大陈小学':[120.0984,29.466781], '义乌市徐江小学':[120.054342,29.253904], '义乌市倍磊小学':[119.982153,29.167134], '义乌市香山小学教育集团胜利校区':[120.066606,29.303548], '麦宝教育':[120.035696,29.310189], 'BUPT':[116.356244,39.960464], '义乌市苏溪镇西山下小学':[120.165749,29.394101], '柯桥区漓渚镇中心小学':[120.469319,29.95452], '义乌市保联小学':[120.078764,29.297556], '北京邮电大学':[116.358103,39.961554], '杭州市育海外国语学校':[119.997496,30.229866], '义乌市大陈镇大陈小学':[120.0984,29.466781], '义乌市上溪镇吴店小学':[119.911287,29.258073], '义乌市苏溪镇第三小学':[120.136356,29.432928] &#125;; var convertData = function (data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var geoCoord = geoCoordMap[data[i].name]; if (geoCoord) &#123; res.push(&#123; name: data[i].name, value: geoCoord.concat(data[i].value) &#125;); &#125; &#125; return res; &#125;; option = &#123; title: &#123; text: '参与学校热力分布图', subtext: 'from 麦宝', &#123;# sublink: 'http://www.pm25.in',#&#125; left: 'center' &#125;, tooltip : &#123; trigger: 'item', show:true, formatter: '&#123;b&#125;(经纬度,人数):&#123;c&#125;人' &#125;, bmap: &#123; center: [120.07, 29.30], zoom: 12, roam: true, mapStyle: &#123; styleJson: [&#123; 'featureType': 'water', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'land', 'elementType': 'all', 'stylers': &#123; 'color': '#f3f3f3' &#125; &#125;, &#123; 'featureType': 'railway', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'highway', 'elementType': 'all', 'stylers': &#123; 'color': '#fdfdfd' &#125; &#125;, &#123; 'featureType': 'highway', 'elementType': 'labels', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'geometry', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'geometry.fill', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'poi', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'green', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'subway', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'manmade', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'local', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'labels', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'boundary', 'elementType': 'all', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'building', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'label', 'elementType': 'labels.text.fill', 'stylers': &#123; 'color': '#999999' &#125; &#125;] &#125; &#125;, series : [ &#123; name: '参与人数', type: 'scatter', coordinateSystem: 'bmap', data: convertData(data), symbolSize: function (val) &#123; return val[2] / 20; &#125;, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: false &#125;, emphasis: &#123; show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: 'purple' &#125; &#125; &#125;, &#123; name: 'Top 3', type: 'effectScatter', coordinateSystem: 'bmap', data: convertData(data.sort(function (a, b) &#123; return b.value - a.value; &#125;).slice(0, 3)), symbolSize: function (val) &#123; return val[2] / 20; &#125;, showEffectOn: 'render', rippleEffect: &#123; brushType: 'stroke' &#125;, hoverAnimation: true, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: 'red', shadowBlur: 10, shadowColor: '#333' &#125; &#125;, zlevel: 1 &#125; ] &#125;; if (option &amp;&amp; typeof option === "object") &#123; myChart.setOption(option, true); &#125; &lt;/script&gt; 效果如下： 义乌市首届Scratch编程周实时数据状态网址(动态页面):http://datav.aliyun.com/share/07ef37b235d9763bd364f344912d1a05大数据可视化说明:大数据屏幕：1920*1080（可修改）最高实时更新频率：1min/次正常显示的预览效果参考（静态截图）：http://p4lmrb1gp.bkt.clouddn.com/15205615855957.jpg本机上如果不是上述参考效果请检查自己的浏览器如下:推荐电脑上预览：首选谷歌 Chrome 浏览器版本56以上，其他浏览器则需更新至最新版并开启极速（chrome内核）模式，不要使用IE浏览器，否则无法正常显示。不推荐手机上预览：无法按默认长宽比例展示]]></content>
      <tags>
        <tag>数据可视化</tag>
        <tag>pandas</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[韩顺平细说Servlet笔记]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-2%2F</url>
    <content type="text"><![CDATA[CS 结构与 BS 结构基本概述B/S 结构即浏览器和服务器结构。它是随着 Internet 技术的兴起，对 C/S 结构的一种变化或者改进的结构。在这种结构下，用户工作界面是通过 WWW 浏览器来实现，极少部分事务逻辑在前端 (Browser) 实现，但是主要事务逻辑在服务器端 (Server) 实现，形成所谓三层 3-tier 结构。 C/S 结构，即大家熟知的客户机和服务器结构。它是软件系统体系结构，通过它可以充分利用两端硬件环境的优势，将任务合理分配到 Client 端和 Server 端来实现，降低了系统的通讯开销。 PS：像腾讯就是以 C/S 结构起家的，其旗下的 QQ 这一软件就是典型的 C/S 结构应用，像 Facebook 就是以 B/S 为结构的。B/S 结构的好处就是方便，跨平台性好，真正的实现了一次开发，处处运行。C/S 结构以其稳定安全著称，降低了通讯代价，但是实现起来麻烦，需要开发服务器和客户端两套系统并且在不同的平台移植起来非常麻烦。所以现在大多是以 C/S 模式来开发。 C/S 系统结构 B/S 系统结构 实例： 1234567891011121314151617181920212223/** 模拟的简单Web服务器*/import java.io.*;import java.net.*;public class Servlet1&#123; public static void main(String[] args) throws Exception&#123; // 创建ServerSocket ServerSocket ss = new ServerSocket(9999); Socket s = ss.accept(); System.out.println("9999"); OutputStream os = s.getOutputStream(); BufferedReader br = new BufferedReader(new FileReader("c:\\hello.html")); String buf = ""; while((buf = br.readLine()) != null)&#123; os.write(buf.getBytes()); &#125; br.close(); os.close(); s.close(); &#125;&#125; Tomcat 容器入门介绍Tomcat 环境配置PS：JDK 的安装这里就不讲了，找到安装包直接下一步下一步就行了。 1、配置 JDK在 Windows10 下，找到环境变量 在环境变量中添加 JDK 主目录 格式为：JAVA_HOME= 指向你的 jdk 的主目录（并不是 bin 文件目录） 在环境变量中添加路径 格式为：path = %JAVA_HOME%\bin; 在环境变量中添加 classpath 格式为：classpath: .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 至此，JDK 就配置完了。 PS：如果在不配置 JAVAHOME 的前提下可以用如下方法启动 tomcat 在 startup.bat 的第 25 行中添加 set JAVA_HOME=JKD 路径 2、启动 tomcat到 tomcat 主目录下的 bin/startup.bat 点击启动 3、验证是否安装成功在浏览器中输入 http://127.0.0.1:8080(8080 是默认端口，如果该端口被占用需要到主目录 / conf/server.xml 中改端口号) 出现这个界面，就表示 tomcat 已经配置成功了。 Tomcat 配置异常及其解决1、JAVA_HOME 配置错误，或者没有配置这时候，可以按照上面的步骤在来一次，在命令行中输入 java -version，如果显示 就表示成功了。 2、如果你的机器已经占有了 8080 端口，则无法启动解决方法 (1) 你可以 8080 先关闭 netstat –an netstat –anb 来查看谁占用该 8080 (2) 主动改变 tomcat 的端口. 到 conf/server.xml 文件中修改 3、 能够正常启动，但是会导航到另外一个页面去修改工具 -&gt; 管理加载项，把默认的导航给禁用即可 4、浏览器显示 404 Not Found在访问 tomcat 时候，一定要保证 tomcat 服务器是启动，不然就会出现这种错误。 Tomcat 的目录结构文件 bin: 启动和关闭 tomcat 的 bat 文件 conf: 配置文件 –&gt;server.xml : 该文件用于配置和 server 相关的信息, 比如 tomcat 启动端口后, 配置 Host, 配置 Context 即 web 应用 –&gt;web.xml : 该文件配置与 web 应用 (web 应用就相当于是一个 web 站点) –&gt;tomcat-users.xml: 该文件用户配置 tomcat 的用户密码 和 权限 lib 目录: 该目录放置运行 tomcat 运行需要的 jar 包 logs 目录：存放日志, 当我们需要去查看日志的时候，很有用!, 当我们启动 tomcat 错误时候，可以查询信息. webapps 目录: 该目录下，放置我们的 web 应用 (web 站点), 比如: 建立 web1 目录 下面放置我们的 html 文件 jsp 文件.. 图片… 则 web1 就被当做一个 web 应用管理起来 (☞ 特别说明 tomcat 6.0 以后支持 tomcat 5 版本 还有别的设置) work: 工作目录: 该目录用于存放 jsp 被访问后 生成的对应的 server 文件 和. class 文件 如何访问一个 web 应用的某个文件 PS：想要访问一个 WEB 应用中的某个文件可以采用 url(Uniform Resource Locator) 统一资源定位符来访问，其格式如上。 Tomcat 应用部署目录结构规范 Tomcat 管理虚拟目录需求：当希望将 web 应用部署到非 webapps 目录下时，怎么解决这问题。 PS：可以通过虚拟目录配置技术解决。 配置步骤1、找到 server.xml 文件 2、编辑 host 节点，添加 Context path 例如：要访问该 web 应用根目录下的 hello.html 文件 实际访问时输入的地址：http://localhost:8088 / 应用名 / hello.html 3、重启、重新部署生效 context 的几个属性的说明path: 应用名称 docbase: web 应用所在的绝对路径 reloadable: 如果设为 ture ，表示 tomcat 会自动更新 web 应用，但是这个开销大，建议在开发过程中，可以设为 true, 但是真的发布了，则应当设为 false upackWAR: 如果设为 ture ，则自动解压，否则不自动解压. PS：war 包的打包和 Tomcat 怎么部署 war 包可以使用搜索引擎找到。 配置域名实现的步骤如下: (1) 在 C:\WINDOWS\system32\drivers\etc 下的 host 文件 添加 127.0.0.1 www.myweb.com (2) 在 tomcat 的 server.xml 文件添加主机名 12345&lt;Host d:\web3”&gt;&lt;Context path=&quot;/&quot; docBase=&quot;d:\web3&quot; /&gt;&lt;/Host&gt; (3) 在 d:\web3 加入了一个 /WEB-INF/web.xml 把 hello2.html 设为首页面，如果连端口都不希望带，则可以把 tomcat 的启动端口设为 80 即可. (4) 重启生效 Tomcat 框架机制 Tomcat 配置默认主机在 tomcat/conf/server.xml 文件 如： Servlet 入门基本概述Servlet（Server Applet），全称 Java Servlet，未有中文译文。是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。 Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。 PS：学习 Servlet 是学习 JSP 的基础，故很重要。 Servlet 在网络中的位置 Servlet 的生命周期 1、WEB 服务器 (Tomcat) 首先会找到该 Servlet 并装载该 Servlet 2、WEB 服务器 (Tomcat) 会创建该 Servlet 的实例 3、WEB 服务器 (Tomcat) 会调用实例对象的 init()方法 4、WEB 服务器 (Tomcat) 创建一个封装 HTTP 请求消息的 HttpServletRequest 对象和一个代表 HTTP 响应消息的 HttpServletResponse 对象，然后调用 service()方法并将请求对象和响应对象作为参数传递进去。(实现是通过多线程技术) 5、WEB 服务器在某种情况，停止对该 Servlet 支持，Servlet 引擎将卸载该 Servlet，在卸载之前会调用 Servlet 的 destroy() 方法进行销毁 手工开发 Servlet 的方式1、在 Tomcat 主目录的 webapps 文件夹下建立一个 web 应用 web1 2、在 web1 下建立文件夹 WEB-INF，在该文件夹中建立 web.xml [web.xml 可以从 ROOT/WEB-INF/web.xml 拷贝] 3、在 WEB-INF 目录下建立 classes 目录 (Servlet 在该目录下开发)，建立 lib 目录 4、在 classes 目录下开发 Servlet 5、在 web.xml 中配置 web.xml 6、编译 Servlet 文件 (编译时需要将 servlet-api.jar 包加入环境变量 classpath 中，该 jar 包在 Tomcat 主目录的 lib 文件夹下) 7、运行 Tomcat 8、访问 Servlet 开发 Servlet 的三种方法1、实现 Servlet 接口12345678910111213141516171819202122232425262728293031323334353637/** 使用实现Servlet接口的方式开发一个Servlet 要求：显示当前时间*/package com.pc;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class Servlet2 implements Servlet&#123; // 该方法用于初始化Servlet，就是把该Servlet装载入内存，该方法只会被调用一次 public void init(ServletConfig config)&#123; &#125; // 得到ServletConfig对象 public ServletConfig getServletConfig()&#123; return null; &#125; // 该方法是服务方法，业务逻辑代码写在这 // 该方法每次都会被调用 public void service(ServletRequest req, ServletResponse res) throws ServletException, java.io.IOException&#123; // 在控制台输出 System.out.println(&quot;hello world：&quot; + new java.util.Date().toString()); // 在浏览器返回 res.getWriter().println(&quot;hello world：&quot; + new java.util.Date().toLocaleString()); &#125; // 该方法得到Servlet配置信息 public java.lang.String getServletInfo()&#123; return null; &#125; // 销毁该Servlet，从内存中清除，该方法只会被调用一次 public void destroy()&#123; &#125;&#125; PS：不仅要写 Servlet 文件，还要在 web.xml 中添加配置信息，配置信息格式如下： 1234567891011121314&lt;!-- servlet部署到web.xml文件，该部署配置可以从examples下拷贝 --&gt;&lt;servlet&gt; &lt;!--servlet-name 该名字可以自定义，但是默认就使用servlet的名字 --&gt; &lt;servlet-name&gt;Servlet2&lt;/servlet-name&gt; &lt;!--servlet-class要指明该servlet放在那个包下的 --&gt; &lt;servlet-class&gt;com.pc.Servlet2&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射 --&gt;&lt;servlet-mapping&gt; &lt;!-- 这个servlet-name要和上面的servlet-name名字一样，这样才能匹配的上 --&gt; &lt;servlet-name&gt;Servlet2&lt;/servlet-name&gt; &lt;!-- url-pattern 这是访问该servlet的资源部分 默认命名规范：就是该servlet的名字--&gt; &lt;url-pattern&gt;/Servlet2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; PS： 1、在 classes 文件夹下编译 (当然 Servlet 文件也应该在这里) javac -encoding UTF-8 -d . Servlet 文件名. java 2、不重启更新 web 应用 首先，在 Tomcat 主目录的 conf 文件夹中找到 tomcat-users.xml 文件，打开它，并在标签中添加如下语句 1234&lt;tomcat-users&gt; &lt;role role/&gt; &lt;user user/&gt;&lt;/tomcat-users&gt; 然后，在 localhost:8080 主界面点击，进入 manager 界面，找到该应用，点击 reload 按钮即可。 2、继承 GenericServlet 类12345678910111213141516/** 使用继承GenericServlet的方式开发一个Servlet*/package com.pc;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class Servlet3 extends GenericServlet&#123; // 该方法是服务方法，业务逻辑代码写在这 // 该方法每次都会被调用 public void service(ServletRequest req,ServletResponse res) throws ServletException,IOException&#123; res.getWriter().println(&quot;hellow,world, GenericServle.&quot;); &#125;&#125; PS：不仅要写 Servlet 文件，还要在 web.xml 中添加配置信息，配置信息格式如下： 12345678&lt;servlet&gt; &lt;servlet-name&gt;Servlet3&lt;/servlet-name&gt; &lt;servlet-class&gt;com.pc.Servlet3&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Servlet3&lt;/servlet-name&gt; &lt;url-pattern&gt;/Servlet3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、继承 HttpServlet 类123456789101112131415161718192021222324/** 使用继承HttpServlet的方式开发一个Servlet 要求：显示当前时间*/package com.pc;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class Servlet4 extends HttpServlet&#123; // 在HttpServlet中，设计者分别提供了对Post提交和Get提交的处理，默认是get提交 // doGet().doPost()底层也是调用service方法 // 处理Get请求 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException&#123; resp.getWriter().println(&quot;doGet()&quot;); &#125; // 处理Post请求 protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; resp.getWriter().println(&quot;doPost()&quot;); &#125;&#125; PS：不仅要写 Servlet 文件，还要在 web.xml 中添加配置信息，配置信息格式如下： 12345678&lt;servlet&gt; &lt;servlet-name&gt;Servlet4&lt;/servlet-name&gt; &lt;servlet-class&gt;com.pc.Servlet4&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Servlet4&lt;/servlet-name&gt; &lt;url-pattern&gt;/Servlet4&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用 MyEclipse 集成开发环境 IDE 来开发 Web 应用PS：具体的配置步骤可以参考搜索引擎。 MyEclipse 的开发目录结构 Servlet 细节问题1、一个已经注册的 Servlet 可以被多次映射1234567891011121314151617181920 &lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;!-- servlet的注册名 --&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;!-- servlet类的全路径(包名+类名) --&gt; &lt;servlet-class&gt;com.web1.servlet.MyServlet1&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;!-- 对一个已经注册的servlet的映射 --&gt; &lt;servlet-mapping&gt; &lt;!-- servelt的注册名 --&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;!-- servlet的访问路径 --&gt; &lt;url-pattern&gt;/MyServlet1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;url-pattern&gt;/abc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2、当映射一个 Servlet 时，可以多层映射1&lt;url-pattern&gt;/servlet/index.html&lt;/url-pattern&gt; 3、在 Servlet 使用通配符映射到 URL有两种格式: 第一种格式 . 扩展名 比如 .do *.ss 第二种格式 以 / 开头 同时以 / 结尾 比如 / /news/* 通配符案例： Servlet1 映射到 /abc/* Servlet2 映射到 /* Servlet3 映射到 /abc Servlet4 映射到 *.do 问题： 1、当请求 URL 为 “/abc/a.html”，“/abc/” 和 “/” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet1。 2、当请求 URL 为 “/abc” 时，“/abc/*”和 “/abc” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet3。 3、当请求 URL 为 “/abc/a.do” 时，“/abc/” 和 “.do” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet1。 4、当请求 URL 为 “/a.do” 时，“/” 和 “.do” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet2。 5、当请求 URL 为 “/xxx/yyy/a.do” 时，“/” 和 “.do” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet2。 在匹配的时候，要参考的标准: 1、看谁的匹配度高，谁就被选择 2、*.do 的优先级最低 4、servlet 中的配置当需要在网站启动时，初始化一些资源时可以配置 123&lt;servlet&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; PS：在 servlet 中如此配置就行，中间的数是整数，越小优先级越高。 配置好了之后，在网站启动时就会调用该 Servlet 的 init() 方法，所以可以在该方法中进行需要的初始化步骤，比如定时刷新，建立内存表之类的等等。 ServletConfig 对象该对象主要用于读取 servlet 的配置信息. 案例: 123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletConfigTest&lt;/servlet-name&gt; &lt;servlet-class&gt;com.web1.servlet.ServletConfigTest&lt;/servlet-class&gt; &lt;!-- 这里可以给servlet配置信息,这里配置的信息，只能被该servlet 读取 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; 如何使用：在 Servlet 使用如下语句 1String encoding = this.getServletConfig().getInitParameter(&quot;encoding&quot;); 补充说明: 这种配置参数的方式，只能被某个 Servlet 独立使用. 如希望让所有的 Servlet 都去读取某个参数, 这样配置: 12345&lt;!-- 如果这里配置参数，可被所有servlet读取 --&gt;&lt;context-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt;&lt;/context-param&gt; 读取所有的参数，可以使用如下方法： 123456Enumeration&lt;String&gt; names=this.getServletConfig().getInitParameterNames();while(names.hasMoreElements())&#123; String name=names.nextElement(); System.out.println(name); System.out.println(this.getServletConfig().getInitParameter(name));&#125; 注意事项：1、Servlet 类是单例模式的，所以要注意线程同步情况。 2、Servlet 的 service() 方法，在每次响应时都会调用一次。 3、Servlet 的 init() 初始化方法，destroy() 销毁方法只会被调用一次。 4、Servlet 的 service() 方法，会根据客户端的请求方法来决定调用对应的 doXXX() 方法。 5、不要重写构造方法，因为所继承的 HttpServlet 及其父类都已经对构造方法进行了某些初始化，当不了解这些系统自带的初始化，然后盲目使用构造方法，可能导致 Servlet 无法创建实例。 6、不要重写 service 方法 (在继承 HttpServlet 的情况下)，因为其内部有判别客户端请求方法的逻辑和一些其他逻辑。 7、必须重写 doPost() 或者是 doGet() 方法中的一个。 8、当想用一种逻辑去处理 Get 和 Post 请求，可以采用委托机制，在 doPost 方法内加入 this.doGet(request, response); 或者在 doGet 方法中加入 this.doPost(request, response); 9、继承 HttpServlet 开发 Servlet 是最常用的方法。 10、get 提交和 post 提交的区别 10.1、从安全的角度看，get &lt; post，因为 get 会把提交的信息显示到地址栏。 10.2、从提交内容大小看， get &lt; post， get 一般不要大于 2k，post 理论无限制，但是在实际开发中，建议不要大于 64k 10.3、从速度看，get &gt; post，因为 get 仅仅只是获取数据而已 11、Servlet 的映射的后缀名不一定代表它就真的是那格式的文件。 HTTP 协议入门——1.1 版本基本概述超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。 HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示 (如文本先于图形) 等。 HTTP 是客户端浏览器或其他程序与 Web 服务器之间的应用层通信协议。在 Internet 上的 Web 服务器上存放的都是超文本信息，客户机需要通过 HTTP 协议传输所要访问的超文本信息。HTTP 包含命令和传输信息，不仅可用于 Web 访问，也可以用于其他因特网 / 内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。 长连接和短连接的区别解释 1 所谓长连接指建立 SOCKET 连接后不管是否使用都保持连接，但安全性较差，所谓短连接指建立 SOCKET 连接后发送后接收完数据后马上断开连接，一般银行都使用短连接 解释 2 长连接就是指在基于 tcp 的通讯中，一直保持连接，不管当前是否发送或者接收数据。而短连接就是只有在有数据传输的时候才进行连接，客户－服务器通信 / 传输数据完毕就关闭连接。 解释 3 长连接和短连接这个概念好像只有移动的 CMPP 协议中提到了，其他的地方没有看到过。通信方式各网元之间共有两种连接方式：长连接和短连接。所谓长连接，指在一个 TCP 连接上可以连续发送多个数据包，在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接。短连接是指通信双方有数据交互时，就建立一个 TCP 连接，数据发送完成后，则断开此 TCP 连接，即每次 TCP 连接只完成一对 CMPP 消息的发送。现阶段，要求 ISMG 之间必须采用长连接的通信方式，建议 SP 与 ISMG 之间采用长连接的通信方式。 解释 4 短连接：比如 http 的，只是连接、请求、关闭，过程时间较短, 服务器若是一段时间内没有收到请求即可关闭连接。长连接：有些服务需要长时间连接到服务器，比如 CMPP，一般需要自己做在线维持。 参考文章：http://blog.csdn.net/shine0181/article/details/7799754 HTTP 请求部分基本结构GET /q547550831?viewmode=contents HTTP/1.1 [请求行] Host: blog.csdn.net [消息头] 消息名: 内容 Connection: keep-alive Cache-Control: max-age=0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,_/_;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36 Referer: http://blog.csdn.net/q547550831?viewmode=contents Accept-Encoding: gzip, deflate, sdch Accept-Language: zh-CN,zh;q=0.8 PS：这是我博客主页的请求头，但是这并不代表每个网页的请求头都是这一样的。 请求方式请求方式有： POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT,CONNECT 等 参考文档：http://tools.jb51.net/table/http_request_method 常用的有：POST 和 GET 请求消息头Host: blog.csdn.net [主机名] Connection: keep-alive [连接状态: 保持连接] Cache-Control: max-age=0 [指定请求和响应遵循的缓存机制: 查看是否有修改并选择更新否] Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,_/_;q=0.8 [可接受的格式] User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36 [浏览器内核] Referer: http://blog.csdn.net/q547550831?viewmode=contents [从哪个网页跳转到这个网页来的，可以用来防盗链] Accept-Encoding: gzip, deflate, sdch [可接收的压缩格式] Accept-Language: zh-CN,zh;q=0.8 [浏览器支持的语言] PS：请求是指浏览器发出向服务器发出，所以这些信息都是浏览器的信息。请求头远远不止这几种，可以参考该文档：http://tools.jb51.net/table/http_header 案例：防止盗链 12345678910111213141516171819202122232425262728293031package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet6 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;a href=&apos;http://127.0.0.1:8080/servlet1/Servlet5&apos;&gt;连接到Servlet5&lt;/a&gt;&quot;); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet5 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 通过request对象来获取http请求信息 // 取出Host String host = request.getHeader(&quot;Host&quot;); out.println(&quot;host=&quot; + host); // 限制用户 // 获取用户浏览器的Referer // referer可以防止盗链，通过判断链接来至哪里 String referer = request.getHeader(&quot;Referer&quot;); if(referer == null || !referer.startsWith(&quot;http://127.0.0.1:8080/servlet1&quot;))&#123; out.println(&quot;非法盗链&quot;); &#125; else &#123; out.println(&quot;referer=&quot; + referer); &#125; out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 一般开发人员习惯把doGet()和doPost()合二为一 this.doGet(request, response); &#125; public void init() throws ServletException &#123; // Put your code here &#125;&#125; PS：该案例中只能允许 http://127.0.0.1:8080/servlet1 开头的网址进行访问 Servlet5 HTTP 响应部分基本结构HTTP/1.1 200 OK [状态行] Server: openresty [消息名] 消息名: 内容 Date: Fri, 01 Jan 2016 08:11:04 GMT Content-Type: text/html; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive Vary: Accept-Encoding Cache-Control: private Set-Cookie: uuid=5cad65d6-7a99-4b15-a6e6-5c50e584ca77; expires=Sat, 02-Jan-2016 08:13:49 GMT; path=/ Set-Cookie: ViewMode=contents; path=/ Content-Encoding: gzip ————– 这是一个空行 消息体 响应状态码响应状态码分别为 1,2,3,4,5 开头的三位数字 响应状态码 含义 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 PS：常见的有 200(成功)，303(重定向)，400(Not Found)，500(服务器内部错误) 可以参考该文档：http://tools.jb51.net/table/http_status_code 响应消息头Server: openresty [服务器名称] Date: Fri, 01 Jan 2016 08:11:04 GMT [原始服务器消息发出的时间] Content-Type: text/html; charset=utf-8 [返回内容的 MIME 类型] Transfer-Encoding: chunked [文件传输编码] Connection: keep-alive [连接状态: 保持连接] Vary: Accept-Encoding [告诉下游代理是使用缓存响应还是从原始服务器请求] Cache-Control: private [告诉所有的缓存机制是否可以缓存及哪种类型] Set-Cookie: uuid=**; expires=Sat, 02-Jan-2016 08:13:49 GMT; path=/ [设置 Http Cookie] Set-Cookie: ViewMode=contents; path=/ [设置 Http Cookie] Content-Encoding: gzip [web 服务器支持的返回内容压缩编码类型] PS：可以参考该文档 http://tools.jb51.net/table/http_header 缓存机制浏览器默认情况下，会缓存所访问的页面，这样会出现一个问题：如果用户习惯把光标停留在地址栏，然后回车来取页面，就会默认调用 cache 中取数据。 案例 1、有些网站要求及时性很高，因此要求不缓存页面。 // 指定该页面不缓存 Ie response.setDateHeader(“Expires”, -1);【针对 IE 浏览器设置不缓存】 // 为了保证兼容性. response.setHeader(“Cache-Control”, “no-cache”);【针对火狐浏览器等】 response.setHeader(“Pragma”, “no-cache”);【其他浏览器】 案例 2、有些网站要求网页缓存一定时间, 比如缓存一个小时 response.setDateHeader(“Expires”, System.currentTimeMillis()+3600*1000); // 后面一个参数表示设置的缓存保持时间，-1 表示永远不缓存 Content-Type 消息头Content-Type，内容类型，一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件 PS：其作用就是告诉浏览器，该服务器返回的网页中消息体是什么格式的，该以什么编码格式来读取这个网页。 因为该类型很多，故给出参考文档，以备后用：http://tools.jb51.net/table/http_content_type 案例 1：定时刷新 Refresh 的使用 response.setHeader(“Refresh”, “5;url=/servletPro/Servlet2”); // 5 秒后刷新并跳转到 url 后的链接。通过这个可以实现页面定时刷新。 案例 2：文件下载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.pc;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet7 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); // 演示下载文件 response.setHeader("Content-Disposition", "attachment; file); // 打开文件 // 1.获取到要下载文件的全路径 String path = this.getServletContext().getRealPath("/EVO_120G.jpg"); // 测试 System.out.println("path=" + path); // 2.创建文件输入流 FileInputStream fis = new FileInputStream(new File(path)); // 做一个缓冲字符数组 byte buff[] = new byte[1024]; int length = 0; // 3.指向response的输出流 OutputStream os = response.getOutputStream(); // 4.循环读出 // length表示每次实际读入的字节数 while((length = fis.read(buff)) != -1)&#123; os.write(buff, 0, length); &#125; // 关闭 os.close(); fis.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; HttpServletResponse 说明基本概述HttpServletResponse 是用于将 Servlet 处理好的内容发送给浏览器的类，服务器通过对 HttpServletResponse 对象中的内容进行截取、拼接就能获得一个完整的 HTTP 响应信息。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html 常用方法public void addHeader(String name,String value) // 添加一个消息头到 HttpServletResponse 对象中去。 public void setHeader(String name,String value) // 重设一个消息头，其与 addHeader 的区别是，add 是添加 (重复也行)，set 表示的是，如果有该消息头就覆盖它，没有就创建它 public void setStatus(int sc) // 设置响应消息的状态码，具体可以参照我的另一篇博客 HTTP 协议入门 public void sendRedirect(String location) throws java.io.IOException // 这个方法在与 request 的 getRequestDispatch() 比较时，会探讨 public ServletOutputStream getOutputStream() throws java.io.IOException // 得到一个二进制输出流，可以回送任意格式数据数据 public java.io.PrintWriter getWriter() throws java.io.IOException // 得到一个字符输出流，可以回送字符数据 getWriter() 和 getOutputStream() 的区别getWriter() 用于向客户机回送字符数据 getOutputStream() 返回的对象，可以回送字符数据，也可以回送字节数据 (二进制数据) OutputStream os=response.getOutputStream(); os.write(“hello,world”.getBytes()); PS：通过该方法也能用 getOutputStream() 回送字符数据 如何选择如果是回送字符数据，则使用 PrintWriter 对象 , 效率高 如果是回送字节数据 (binary date) , 则只能使用 OutputStream 注意事项PrintWriter,OutputStream 这两个流不能同时使用 比如： OutputStream os=response.getOutputStream(); os.write(“hello,world”.getBytes()); PrintWriter out=response.getWriter(); out.println(“abc”); 会报错: java.lang.IllegalStateException: getOutputStream() has already been called for this response 不能同时使用 PrintWriter 和 OutputStream 的原因 结论：Web 服务器在完成一次 service 之后会自动关闭流，并销毁当前的 request 和 response 对象，故无法同时使用两个流。 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.pc;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet7 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); // 演示下载文件 response.setHeader("Content-Disposition", "attachment; file); // 打开文件 // 1.获取到要下载文件的全路径 String path = this.getServletContext().getRealPath("/EVO_120G.jpg"); // 测试 System.out.println("path=" + path); // 2.创建文件输入流 FileInputStream fis = new FileInputStream(new File(path)); // 做一个缓冲字符数组 byte buff[] = new byte[1024]; int length = 0; // 3.指向response的输出流 OutputStream os = response.getOutputStream(); // 4.循环读出 // length表示每次实际读入的字节数 while((length = fis.read(buff)) != -1)&#123; os.write(buff, 0, length); &#125; // 关闭 os.close(); fis.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; Servlet 中文乱码处理发生中文乱码的原因 发生中文乱码的各种情况1、表单 form(1)post在服务器端设置成浏览器端的编码方式。 解决方法: request.setCharacterEncoding(“utf-8”); //gbk gb2312 big5 (2)get写一个工具类: 12345678910111213package com.pc.utils;public class MyTools &#123; public static String getNewString(String str) &#123; String newString=&quot;&quot;; try &#123; // 把iso-8859-1 转换成 utf-8 newString=new String(str.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return newString; &#125;&#125; 2、超链接&lt;a href=”http://www.sohu.com?name = 函数后”&gt; 测试 PS：该方法和 get 处理方法一样 3、sendRedirect() 发生乱码response.sendRedirect(“servlet 地址? username = 张三”); PS：重定向默认是 get 方法，所以处理方法参照 get。 重定向产生乱码的原因： 重定向的原理是 Web 服务器告知浏览器，要浏览器访问另一个地址，这样 HttpServletResponse 和 HttpServletRequest 对象都是不同的了，所以需要到跳转的地址再次设置才行。 4、返回浏览器显示乱码在服务端是中文，在 response 的时候，也要考虑浏览器显示是否正确, 一般通过使用： response.setContentType(“text/html;charset=utf-8”); 5、下载提示框中文乱码下载文件的时候，可能提示框是中文乱码 String temp=java.net.URLEncoder.encode(“演员. mp3”,”utf-8”); response.setHeader(“Content-Disposition”,”attachment; filename=”+temp); PS：应当尽量使用 post 方式提交，因为 post 方式提交处理该问题简单，而 get 方式就有点麻烦了。 HttpServletRequest 说明基本概述该对象是有 Web 服务器创建的，每一次请求都会创建一次。其作用是将 HTTP 请求封装成一个类，供 Servlet 处理。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html 常用方法getRequestURL 方法返回客户端发出请求时的完整 URL。 getRequestURI 方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分 (参数名 + 值)。 该函数可以获取请求部分的数据 比如 http://localhost/web名?username=abc&amp;pwd=123 request.getQueryString(); 就会得到 username=abc&amp;pwd=123 getRemoteAddr 方法返回发出请求的客户机的 IP 地址 getRemoteHost 方法返回发出请求的客户机的完整主机名 getRemotePort 方法返回客户机所使用的网络端口号 客户机的端口号是随机选择的，web 服务器的端口号是一定的 getLocalPort 方法返回 web 服务器所使用的网络端口号 getLocalAddr 方法返回 WEB 服务器的 IP 地址。 getLocalName 方法返回 WEB 服务器的主机名 getMothod 方法返回浏览器的提交方式 &lt;h3 data-line=)URL(统一资源定位符) 和 URI(统一资源标识符) 的区别 案例： URL=http://localhost:8080/web1/Servlet7 完整的请求 Uri=/web1/Servlet7 web 应用的名称 + 资源的名称 获取用户提交的内容 (通过表单)案例： 123456789101112131415161718192021222324252627282930package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInfoForm extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); out.println("&lt;form action='/servletPro3/RegisterCl' method='post'&gt;&lt;br/&gt;"); out.println("&lt;input type='hidden' value='abc' ); out.println("用户名:&lt;input type='text' ); out.println("密 码:&lt;input type='password' ); out.println("性 别:&lt;input type='radio' ); out.println("你的爱好:&lt;input type='checkbox' name='hobby' value='音乐'&gt;音乐 &lt;input type='checkbox' name='hobby' value='体育'&gt;体育 &lt;input type='checkbox' name='hobby' value=\"旅游\"&gt;旅游&lt;br/&gt;"); out.println("所在城市:&lt;select ); out.println("你的介绍:&lt;textarea cols='20' rows='10' ); out.println("提交照片:&lt;input type='file' ); //什么时候使用hidden传输数据 1.不希望用户看到该数据 2\. 不希望影响界面，同时使用该数据 out.println("&lt;input type='submit' value='提交信息'/&gt;"); out.println("&lt;/form&gt;"); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 接受信息的 Servlet: 12345678910111213141516171819202122232425262728293031323334353637383940package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class RegisterCl extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); String u=request.getParameter("username"); String p=request.getParameter("pwd"); String sex=request.getParameter("sex"); //如果接受复选框的内容，则使用getparameterValues String [] hobbies=request.getParameterValues("hobby"); String city=request.getParameter("city"); String intro=request.getParameter("intro"); String hidden1=request.getParameter("hidden1"); out.println("用户名="+u+"&lt;br/&gt;"); out.println("密 码="+p+"&lt;br/&gt;"); out.println("性 别="+sex+"&lt;br/&gt;"); if(hobbies!=null)&#123; for(int i=0;i&lt;hobbies.length;i++)&#123; out.println("爱好:"+hobbies[i]); &#125; &#125;else&#123; out.println("无爱好"); &#125; out.println("&lt;br/&gt;所在城市:"+city); out.println("&lt;br/&gt;个人介绍:"+intro); out.println("&lt;br/&gt;隐藏数据:"+hidden1); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; Servlet 传递数据方式基本概述Servlet 传递数据的方式有很多，这里提供五种方式： 1、静态变量 2、HttpServletResponse 的 sendRedirect() 方法 3、HttpServletRequest 的 getRequestDispatch() 方法 4、HttpServletRequest 的 getSession() 方法 5、HttpServletRequest 的 setAttribute() 方法 静态变量通过建立一个数据类来进行传递。 案例： public class MyData{ public static String data; // 通过使用该类来实现数据传递 } HttpServletResponse 的 sendRedirect() 方法sendRedirect() 方法是让浏览器重定向到另一个链接。其内部原理是设置状态码为 303，并设置相应的 Location 响应头。 基本语法： response.sendRedirect(“/Web 应用名 / 资源名? u+password); response.sendRedirect(“servlet 的地址? 参数名 = 参数值 &amp; 参数名 = 参数值…”); 参照值是 String , 参数名应当使用 字母组合 在接受数据的 Servlet 中： String 参数 = request.getParameter(“参数名”); 基本原理图 PS：使用重定向不能使用 PrintWrite，ServletOutputStream 这样的流。因为重定向已经将消息返回给浏览器，其数据流也就没必要使用了。 HttpServletRequest 的 getRequestDispatch() 方法getRequestDispatch() 方法是使 WEB 服务器从当前 Servlet 转发到当前应用下的另一个 Servlet。 基本语法： request.getRequestDispatcher(资源地址).forward(request,response); 资源地址：不需要项目名。因为它只能在 WEB 服务器内部转发。 基本原理图 PS：getRequestDispatcher() 请求转发可以一直转发下去，只要最终会处理并给服务器相应内容就行了。而且请求转发不会改变浏览器的 URL，sendRedirect() 会改变 URL。 注意事项： 1、使用 forward 不能转发到该 WEB 应用外的 URL2、因为 forward 发生在文本服务器内，所以 Servlet1、Servlet2 等等，只要一直转发，使用的都是相同的 request 和 response HttpServletRequest 的 getSession() 方法getSession() 方法会获取一个会话，这个内容会在另一篇博客会话技术中详细说明。 基本语法： 1、放入 session：request.getSession.setAttribute(“loginUser”,username); 2、取出 session：request.getSession.getAttribute(“loginUser”); PS：该方法可以传递对象 案例： 放入： User user= new User(); user.setName(“zs”); user.setPassWord(“123”); request.getSession.setAttribute(“userObj”,userObj); 取出： User user=(User)request.getSession.getAttribute(“userObj”); HttpServletRequest 的 setAttribute() 方法setAttribute() 方法可以设置一个键值对，该键值对在该 request 的有效期内都可以使用。相应的还有 removeAttribute() 注销键值对的方法。该方法经常和 getRequestDispatch() 一起使用。 基本语法： setAttribute(name, value); PS：request 的 Attribute 在一次请求中有效。一次请求：没有将响应消息返回给浏览器就视为一次请求。 比较 sendRedirect() 和 forward(request,response)1、sendRedirect() 重定向，forward() 转发 2、实际发生的位置不一样 sendRedirect 发生在浏览器 forward 发生在 web 服务器 3、使用用法不一样 request.getRequestDispatcher(“/ 资源 URI”).forward(request,response) response.sendRedirect(“/web 应用 / 资源 URI”); 4、能够去 URL 范围不一样 sendRedirect 可以去任意 URL forward 只能去当前的 WEB 应用的资源 Cookie 入门基本概述Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie 也可以叫做浏览器缓存。 因为 HTTP 是无状态的协议，它不能保存用户状态，这时候往往会用到 Cookie 技术来对用户进行标识并进行一些特定的处理。服务器可以利用 Cookies 包含信息的任意性来筛选并经常性维护这些信息，以判断在 HTTP 传输中的状态。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html Cookie 原理图 案例： 123456789101112131415161718192021222324252627282930313233343536package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：设置Cookie */public class Servlet8 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); PrintWriter out = response.getWriter(); // 创建Cookie (api) Cookie cookie = new Cookie("Switch", "123456"); // 设置cookie的生命周期 cookie.setMaxAge(3600); // 把cookie信息会写给浏览器 response.addCookie(cookie); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * * @author Switch * 功能：获取Cookie * */public class Servlet9 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 获取客户端发过来的所有cookie Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; // 测试 // System.out.println(cookies.length); for(Cookie c : cookies)&#123; out.println(c.getName() + &quot; &quot; + c.getValue()); &#125; &#125; out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：测试Cookie同名会发生什么情况 */public class Servlet10 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 创建Cookie (api) Cookie cookie1 = new Cookie(&quot;Switch2&quot;, &quot;123456&quot;); // 设置cookie的生命周期 cookie1.setMaxAge(3600); // 把cookie信息会写给浏览器 response.addCookie(cookie1); // 同名会后面的会覆盖前面的Cookie Cookie cookie2 = new Cookie(&quot;Switch2&quot;, &quot;654321&quot;); // 设置cookie的生命周期 cookie2.setMaxAge(3600); // 把cookie信息会写给浏览器 response.addCookie(cookie2); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 小结： 1、cookie 是在服务器创建的 2、cookie 是保存在浏览器缓存文件中的 3、cookie 的生命周期是可设置的 cookie.setMaxAge(time); // time 是以秒为单位的 如果不设置 setMaxAge 则当浏览器关闭时，该 cookie 就消亡。 4、cookie 可以被多个浏览器共享 5、cookie 是 (名 — 值) 对应关系 name 和 value 都是 String 型的 如果设置 Cookie，name 相同，则后设置会覆盖前设置 6、一个 web 应用中可以保存多个 cookie，并且会保存在浏览器缓存文件夹的同一个文件中 7、cookie 存放方式是以明文的方式，所以为了安全，要进行加密。 MD5 加密算法123456789101112131415161718192021222324252627282930313233package com.pc;import java.security.*;import java.security.spec.*;/** * @author Switch * 功能：MD5加密 */class MD5_test &#123; public final static String MD5(String s) &#123; char hexDigits[] = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; &#125;; try &#123; byte[] strTemp = s.getBytes(); MessageDigest mdTemp = MessageDigest.getInstance(&quot;MD5&quot;); mdTemp.update(strTemp); byte[] md = mdTemp.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; return null; &#125; &#125; public static void main(String[] args) &#123; System.out.print(MD5_test.MD5(&quot;Switch&quot;)); &#125;&#125; PS：MD5 是一种单向加密方式，其加密是不可逆转的，但是也可能存在破解方法，不过要一定的时间，所以建议采用 MD5 64 位加密或者是 128 位加密，该提供的方法只是 32 位加密方式。 使用 Cookie 保存用户重要信息时，比如密码、银行账号时，必须要进行加密传输存储。 案例：保存上次登录的时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.text.SimpleDateFormat;import java.util.Date;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet11 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 用Cookie记录上次登录时间 boolean b = false; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; // 获取name String name = cookie.getName(); if (&quot;lasttime&quot;.equals(name)) &#123; // 显示时间 out.println(&quot;上次登录时间是：&quot; + cookie.getValue()); updateDate(response); b = true; break; &#125; &#125; &#125; if (!b) &#123; out.println(&quot;这是您第一次登录&quot;); updateDate(response); &#125; out.flush(); out.close(); &#125; private void updateDate(HttpServletResponse response) &#123; // 更新时间 SimpleDateFormat simpleDateFormat = new SimpleDateFormat( &quot;yyyy-MM-dd HH:mm:ss&quot;); String nowDate = simpleDateFormat.format(new Date()); Cookie c = new Cookie(&quot;lasttime&quot;, nowDate); // 7天有效期 c.setMaxAge(3600 * 24 * 7); response.addCookie(c); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; cookie 生命周期cookie 默认的生命周期是会话级别的，也就是说浏览器一关闭 cookie 立即失效。可以通过 setMaxAge(time) 的方法设置生命周期。 time 解释 正数 设置多少秒后失效 0 删除该cooki 负数 设置该cookie为会话级别 案例： 1234567891011//先得到该cookieCookie cookies[]=request.getCookies();for(Cookie cookie: cookies)&#123; if(cookie.getName().equals(&quot;id&quot;))&#123; System.out.println(&quot;id&quot;); //删除 cookie.setMaxAge(0); //一定带上这句话，否则不能删除 response.addCookie(cookie); &#125;&#125; PS：如果该 web 应用只有一个 cookie ，则删除该 cookie 后，在浏览器的临时文件夹下没有该 cookie 文件，如果该 web 应用有多个 cookie, 则删除一个 cookie 后，文件还在，只是该 cookie 没有。 cookie 细节1、一个浏览器最多能够存放 300 个 cookie，每个 web 站点，最多只能占用 20 个 cookie，而且一个 cookie 大小最大不能超过 4k。 2、cookie 存放中文，有可能会出现乱码的情况，这时可以采用如下方法解决 存放: String val=java.net.URLEncoder.encode(“张三”,”utf-8”); Cookie cookie=new Cookie(“name”,val); 取出: String val=java.net.URLDecoder.decode(cookie.getValue(), “utf-8”); out.println(“name =”+val); Servlet 详解基本概述Session 在计算机中，尤其是在网络应用中，称为 “会话控制”。在计算机专业术语中，Session 是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间。具体到 Web 中的 Session 指的就是用户在浏览某个网站时，从进入网站到关闭这个网站所经过的这段时间，也就是用户浏览这个网站所花费的时间。因此从上述的定义中可以看到，Session 实际上是一个特定的时间概念。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html Session 工作原理图 Tomcat 默认是 30 分钟。 Tomcat 主目录的 conf 文件夹中的 web.xml 文件可以进行设置全局默认会话生命周期时间。 3 种设置 session 生命周期的方法1、tomcat/conf/web.xml如上图所示，将数字进行更改则行，单位为分钟。 2、在 web 应用下的 web.xml直接在中加入如图所示代码则行。 3、通过 request.getSession().setMaxInactiveInterval(time)time 是以秒为单位的。time 为正数表示用户未操作多少秒后会话失效，0 为立即失效，负数代表永不失效。 PS：session 的生命周期的时间是指用户未操作时间，也就是说当用户未操作多少秒后失效。而 cookie 的生命周期的时间指得是累积的时间，也就说无论用户访问否，只要累积过去了多少秒后就失效了。 案例： 12345678910111213141516171819202122232425262728293031323334353637383940package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.net.URLDecoder;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class Servlet12 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); PrintWriter out = response.getWriter(); // 访问session [当发现没用session时，就会自动创建session] HttpSession session = request.getSession(); // 给该session放入属性，可以加入对象 String val = URLEncoder.encode("张三", "utf-8"); session.setAttribute("name", val); session.setAttribute("age", 20); // session的生命周期(默认30min,可以修改) // time指的是等待时间，如果超过这个时间，则会自动释放该会话 // session.setMaxInactiveInterval(time); out.println("创建session并放入属性"); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.net.URLDecoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class Servlet13 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 获取Session HttpSession session = request.getSession(); // 获取属性 String name = (String) session.getAttribute(&quot;name&quot;); Integer age = (Integer) session.getAttribute(&quot;age&quot;); // 删除name属性 //session.removeAttribute(&quot;name&quot;); if (name != null &amp;&amp; age != null) &#123; out.println(URLDecoder.decode(name, &quot;utf-8&quot;) + &quot; &quot; + age); &#125; out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 小结1、session 存在于服务器的内存中 2、一个用户浏览器, 独享一个 session 域对象 3、session 中的属性的默认生命周期是 30min ，你可以通过 web.xml 来修改 4、session 中可以存放多个属性 5、session 可以存放对象 6、如果 request.getSession().setAttribute(“name”,val) , 如果名字重复，则会替换该属性. 7、生命周期设置优先级顺序为 setMaxInactiveInterval &gt; web 应用下的 web.xml 设置 &gt; tomcat/conf/web.xml 下的设置 8、1,2 两种方法之所以不能是秒级的一个关键原因是因为太耗费资源，3 能是秒级的原因是因为它是对单个 Session 进行监控。 9、session 生命周期时间指得是用户未操作时间，当用户访问后，有从新计时，可以采取如下几种方式使 session 或者其中属性失效。 1、重启、reload 应用、关机，session 会完全失效。 2、通过 request.getSession().invalidate() 让 session 中所有属性失效。 3、通过 request.getSession().removeAttribute() 让 session 中某一属性失效、 Session 工作原理更深入的理解 PS：JSESSIONID 是 Session 自动生成的用于唯一表示 Session 对象的一个 ID 号，通过该 ID 号服务器可以对每一个浏览器进行标识。 JSESSION 控制 session 销毁时间当关闭浏览器之后，因为 session 默认返回的 Cookie 是会话级别的，所以即使服务器那端 session 并没有失效，再打开浏览器也无法使用之前的会话了。不过可以通过重设 JSESSIONID 这个 Cookie 来实现有效期持续到 session 生命周期完。 案例： 1234567891011public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); HttpSession session = request.getSession(); session.setAttribute(&quot;name&quot;, &quot;张三&quot;); out.println(&quot;创一个session并放入姓名属性&quot;); //把该session id保存cookie，在id时，一定要按照规范命名，这里区分大小写 Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId()); cookie.setMaxAge(60*30); response.addCookie(cookie);&#125; 1234567 public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); HttpSession httpSession = request.getSession(); String name = (String) httpSession.getAttribute(&quot;name&quot;); out.println(&quot;name = &quot;+name);&#125; Cookie 禁用后使用 Session 的方法cookie 禁用后可以使用 URL 重写的方法，来实现 Session。 基本语法：response.encodeRedirectURL(java.lang.String url) 用于对 sendRedirect 方法后的 url 地址进行重写 response.encodeURL(java.lang.String url) 用于对表单 action 和超链接的 url 地址进行重写 encodeURL (String url) 方法的实现机制为：先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url，再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。 cookie 与 session 的比较1、存在的位置cookie：存在客户端的临时文件夹 session：存在服务器内存中，一个 session 域对象为一个用户浏览器服务 2、安全性cookie：是以明文的方式放在客户端的，安全性弱，可以通过（MD5）加密再存放。 session：是存放在服务器内存中，所有安全性好 3、网络传输cookie：属性值会传递信息给服务器 session：属性值不会给客户端 4、生命周期cookie 的生命周期：是累计时间，即如果我们给 cookie 设置 setMaxAge（30），则 30 秒后失效。 session 的生命周期：是间隔时间，如我们设置 session 20min，指在 20min 内，如果没有访问 session，则 session 失效（session 失效是指无法读取 session 属性）， 在以下情况 session 也会失效 （1）关闭 tomcat （2）reload web 应用 （3）时间到 （4） 调用 invalidate 方法 5、作用范围cookie：能够被多个浏览器共享 session：只能一个浏览器使用 6、使用原则session：因为 session 会占用服务器的内存，因此不要向 session 中存放过多过大的对象，会影响性能。 cookie：不要将太多数据放置在 cookie 中，这样会使用大量带宽。 过滤器 Filter基本概述Java 中的 Filter 并不是一个标准的 Servlet ，它不能处理用户请求，也不能对客户端生成响应。 主要用于对 HttpServletRequest 进行预处理，也可以对 HttpServletResponse 进行后处理，是个典型的处理链。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html 参考博客：http://blog.csdn.net/sd0902/article/details/8395641 开发过滤器的步骤1、创建继承 HttpServlet 同时实现 Filter 接口 默认 filter 不生效，需要配置. 123456789&lt;!-- 配置的一个filter --&gt; &lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.pc.filter.MyFilter&lt;/filter-class&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; /*表示对该WEB的所有网页都过滤 &lt;/filter-mapping&gt; 2、在 filter 的方法中添加业务逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243package com.pc.filter;import java.io.*;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.pc.domain.User;public class MyFilter1 extends HttpServlet implements Filter &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)hrows ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125; public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) throws IOException, ServletException &#123; System.out.print(&quot;myfilter1...&quot;); //获取sessionHttpServletRequest httpServletRequest=(HttpServletRequest)request; //看看请求的资源是什么 String uri=httpServletRequest.getRequestURI(); if(uri.startsWith(&quot;/UsersManager3/imgs&quot;)||uri.startsWith(&quot;/UsersManager3/Login&quot;))&#123; // 该过滤器放行，进入下一个过滤器 chain.doFilter(request, response); &#125;else&#123; HttpSession session=httpServletRequest.getSession(); User user=(User) session.getAttribute(&quot;loginuser&quot;); if(user!=null)&#123; //该用户合法,放行 chain.doFilter(request, response); &#125;else&#123; request.setAttribute(&quot;err&quot;, &quot;请好好登陆&quot;); httpServletRequest.getRequestDispatcher(&quot;/LoginServlet&quot;) .forward(request, response); &#125; &#125; &#125; public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 过滤器链过滤器链的概念很容易理解，就是在配置过滤器时，多个过滤器加载进内存中时，当使用过滤器之后调用 chain.doFilter(request, response);WEB 服务器会按配置顺序决定下一个调用的过滤器是什么。这就可以视为过滤器链。 简易购物车就是一个简单的购物车，还可以扩展。 实现原理： 用户在 ShowBook 页面购书，BuyBookCl 进行业务逻辑处理之后，显示在 ShowMyCart 上。Book 是图书信息类，DB 是一个内存图书数据库，用来存放初始化图书信息。 使用技术： 1、JAVASE 中的 ArrayList,HashMap,LinkedHashMap 2、Session 技术 3、Servlet 技术 4、单例 123456789101112131415161718192021222324252627282930313233343536373839404142package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.util.ArrayList;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：显示图书 */ public class ShowBook extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;h1&gt;欢迎购买&lt;/h1&gt;&quot;); // 取出DB ArrayList&lt;Book&gt; db = DB.getBooks(); for(Book book : db)&#123; out.println(book.getName() + &quot;&lt;a href=&apos;/MyCart/BuyBookCl?id=&quot;+ book.getId() + &quot;&amp;); &#125; out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedHashMap;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：处理购书信息 */public class BuyBookCl extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); // 接收用户购书信息 String bookname = request.getParameter(&quot;name&quot;); String id = request.getParameter(&quot;id&quot;); String price = request.getParameter(&quot;price&quot;); // 从会话获取总价 Float totalprice = (Float) request.getSession().getAttribute(&quot;totalprice&quot;); // 将总价加入会话中 if(totalprice == null)&#123; request.getSession().setAttribute(&quot;totalprice&quot;, Float.parseFloat(price)); &#125; else &#123; request.getSession().setAttribute(&quot;totalprice&quot;, totalprice + Float.parseFloat(price)); &#125; // 从session中取出mybooks HashMap&lt;String, Book&gt; books = (HashMap&lt;String, Book&gt;) request.getSession().getAttribute(&quot;mybooks&quot;); // 如果是第一次购物 books == 空 if(books == null)&#123; // 创建集合对象 books = new LinkedHashMap&lt;String, Book&gt;(); // 创建book对象 Book book = new Book(); book.setId(id); book.setName(bookname); // 设置图书数量为1 book.setNum(1); books.put(id, book); // 将bookd加入session request.getSession().setAttribute(&quot;mybooks&quot;, books); &#125; else &#123; // 检测集合中是否有该书 if(books.containsKey(id))&#123; // 表示数已被购买过 // 从集合中取出图书 Book book = books.get(id); // 数量+1 book.setNum(book.getNum() + 1); &#125; else &#123; // 该图书未被购买过 Book book = new Book(); book.setId(id); book.setName(bookname); book.setNum(1); books.put(id, book); &#125; &#125; // 转发到显示购物车界面 request.getRequestDispatcher(&quot;/ShowMyCart&quot;).forward(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：显示购物车 */public class ShowMyCart extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 从session中取出购买的书 HashMap&lt;String, Book&gt; books = (HashMap&lt;String, Book&gt;) request.getSession().getAttribute(&quot;mybooks&quot;); // 测试 // System.out.println(books); out.println(&quot;您的购物车有以下书籍：&lt;br/&gt;&quot;); Iterator iterator = books.keySet().iterator(); while(iterator.hasNext())&#123; Book book = books.get(iterator.next()); out.println(&quot;书名为：&quot; + book.getName() + &quot; 数量为：&quot; + book.getNum()); out.println(&quot;&lt;br/&gt;&quot;); &#125; out.println(&quot;总价为：&quot; + request.getSession().getAttribute(&quot;totalprice&quot;)); out.println(&quot;&lt;br/&gt;&quot;); out.println(&quot;&lt;a href=&apos;/MyCart/ShowBook&apos;&gt;返回购物大厅&lt;/a&gt;&quot;); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.pc;/** * @author Switch * 功能：存储图书信息 * id------id号 * name----书名 * num-----数量 * price---价格 */public class Book &#123; private String id; private String name; private int num; private float price; // 设置器与获取器 public String getId() &#123; return id; &#125; public float getPrice() &#123; return price; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.pc;import java.io.Serializable;import java.util.ArrayList;/** * * @author Switch * 功能：模拟内存数据库,单例实现 * */public final class DB implements Serializable&#123; private static ArrayList&lt;Book&gt; books = null; private DB()&#123; &#125; // 静态代码块初始化图书信息 static&#123; books = new ArrayList&lt;Book&gt;(); Book book1 = new Book(); book1.setId(&quot;1&quot;); book1.setName(&quot;Think in Java&quot;); book1.setPrice(99); books.add(book1); Book book2 = new Book(); book2.setId(&quot;2&quot;); book2.setName(&quot;Javascript权威指南&quot;); book2.setPrice(139); books.add(book2); Book book3 = new Book(); book3.setId(&quot;3&quot;); book3.setName(&quot;Head First Servlet &amp; JSP&quot;); book3.setPrice(129); books.add(book3); Book book4 = new Book(); book4.setId(&quot;4&quot;); book4.setName(&quot;设计模式之禅&quot;); book4.setPrice(89); books.add(book4); Book book5 = new Book(); book5.setId(&quot;5&quot;); book5.setName(&quot;Java核心技术&quot;); book5.setPrice(139); books.add(book5); &#125; // 返回图书集合 public static ArrayList&lt;Book&gt; getBooks() &#123; return books; &#125;&#125; ServletContext基本概述servletContext 接口是 Servlet 中最大的一个接口，呈现了 web 应用的 Servlet 视图。ServletContext 实例是通过 getServletContext() 方法获得的，由于 HttpServlet 继承 GenericServlet 的关系，GenericServlet 类和 HttpServlet 类同时具有该方法。 每个应用都会有一个 ServletContext 对象与之关联, 当容器分布在在多个虚拟机上时，web 应用在所分布的每个虚拟机上都拥有一个 ServletContext 实例. 缺省情况下，ServletContext 不是分布式的，并且只存在于一个虚拟机上。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html ServletContext 原理图 PS：一个 WEB 服务器上所有的 Servlet 共享一个 ServletComtext。 小结1、ServletContext 是在服务器 2、ServletContext 是被所有客户端共享 3、ServletContext 是当 web 应用启动的时候，自动创建 4、ServletContext 当 web 应用关闭 / tomcat 关闭 / 对 web 应用 reload 会造成 servletContext 销毁 5、ServletContext 与 Session、Request 一样都能存入属性、取出属性，但是其作用域和生命周期是不同的 1、ServletContext 作用域是整个 WEB 应用，生命周期是从服务器启动到关闭 2、Session 作用域是对应的会话，生命周期是从会话创建到会话销毁 3、Request 作用域是一次响应，生命周期是一次响应 (服务器将 HTTP 响应发给浏览器) 6、ServletContext 能够通过以下几种方式使用1、获取 this.getServletConfig().getServletContext(); this.getServletContext(); // 两种效果一样，推荐下面这种 2、添加属性 this.getServletContext().setAttribute(String,Object); 3、取出属性 this.getServletContext().getAttribute(属性名); 4、移除属性 // 注意：同Session、Request 一样，移除属性只能一个一个移除 this.getServletContext().removeAttribute(属性名); ServletContext 应用1、获取 WEB 应用的初始化参数12345&lt;!-- 如果希望所有的servlet都可以访问该配置. --&gt;&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;scott&lt;/param-value&gt;&lt;/context-param&gt; 如何获取 1String val= this.getServletContext().getInitParameter(&quot;name&quot;); 2、使用 ServletContext 实现跳转1234567891011//目前我们跳转到下一个页面//1 response.sendRedirect(&quot;/web应用名/资源名&quot;);//2 request.getRequestDispatcher(&quot;/资源名&quot;).forward(request, response);/** 区别1\. getRequestDispatcher 一个跳转发生在web服务器 sendRedirect发生在浏览器 * 2\. 如果request.setAttribute(&quot;name&quot;,&quot;Switch&quot;) 希望下一个页面可以使用属性值，则使用 getRequestDispatcher* 3\. 如果session.setAttribute(&quot;name2&quot;,&quot;Switch2&quot;), 希望下一个页面可以使用属性值，则两个方法均可使用,但是建议使用 getRequestDispatcher* 4\. 如果我们希望跳转到本web应用外的一个url,应使用sendRedirect *///3.这种方法和2一样this.getServletContext().getRequestDispatcher(&quot;/资源url&quot;).forward(request, response); 3、读取文件，和获取文件全路径123456789101112//首先读取到文件InputStream inputStream=this.getServletContext().getResourceAsStream(&quot;dbinfo.properties&quot;);//创建PropertiesProperties pp=new Properties();pp.load(inputStream);out.println(&quot;));//如果文件放在src目录下，应该使用类加载器来读取//InputStream is=Servlet5.class.getClassLoader().getResourceAsStream(&quot;dbinfo.properties&quot;);//获取文件全路径//读取到一个文件的全路径String path=this.getServletContext().getRealPath(&quot;/imgs/Sunset.jpg&quot;);out.println(&quot;paht = &quot;+path); 用户管理系统基本概述该系统是一个简单的用户管理系统，目前实现的功能不是很多，但是可以扩展。其结构采用的是 MVC 模式。 MVC 模型示意图 系统框架图 开发目录结构图 注意事项：数据库采用的是 Oracle 数据库，用户名，密码之类的在上图的 dbinfo.properties 文件下更改，使用其他数据库也是在该文件下更改驱动名称。 SQL1234567891011121314151617181920212223242526272829303132333435363738394041424344create table users( id number primary key, --id username varchar2(32) not null, --用户名 email varchar2(64) not null, --电子邮箱 grade number default 1, --等级 1-&gt;5 1为普通用户，5为管理员 passwd varchar2(32) not null --密码);--插入测试数据insert into users values(1,&apos;zhangsan&apos;,&apos;zhangsan@switch.com&apos;,1,&apos;123456&apos;);insert into users values(2,&apos;lisi&apos;,&apos;lisi@switch.com&apos;,1,&apos;123456&apos;);insert into users values(3,&apos;wangwu&apos;,&apos;wangwu@switch.com&apos;,1,&apos;123456&apos;);insert into users values(4,&apos;zhaoliu&apos;,&apos;zhaoliu@switch.com&apos;,1,&apos;123456&apos;);insert into users values(5,&apos;switch&apos;,&apos;switch@switch.com&apos;,5,&apos;switch&apos;);insert into users values(6,&apos;AAA&apos;,&apos;AAA@switch.com&apos;,1,&apos;123456&apos;);insert into users values(7,&apos;BBB&apos;,&apos;BBB@switch.com&apos;,1,&apos;123456&apos;);insert into users values(8,&apos;CCC&apos;,&apos;CCC@switch.com&apos;,1,&apos;123456&apos;);insert into users values(9,&apos;DDD&apos;,&apos;DDD@switch.com&apos;,1,&apos;123456&apos;);insert into users values(10,&apos;EEE&apos;,&apos;EEE@switch.com&apos;,1,&apos;123456&apos;);insert into users values(11,&apos;FFF&apos;,&apos;FFF@switch.com&apos;,1,&apos;123456&apos;);insert into users values(12,&apos;GGG&apos;,&apos;GGG@switch.com&apos;,1,&apos;123456&apos;);insert into users values(13,&apos;HHH&apos;,&apos;HHH@switch.com&apos;,1,&apos;123456&apos;);insert into users values(14,&apos;AAA&apos;,&apos;AAA@switch.com&apos;,1,&apos;123456&apos;);insert into users values(15,&apos;BBB&apos;,&apos;BBB@switch.com&apos;,1,&apos;123456&apos;);insert into users values(16,&apos;CCC&apos;,&apos;CCC@switch.com&apos;,1,&apos;123456&apos;);insert into users values(17,&apos;DDD&apos;,&apos;DDD@switch.com&apos;,1,&apos;123456&apos;);insert into users values(18,&apos;EEE&apos;,&apos;EEE@switch.com&apos;,1,&apos;123456&apos;);insert into users values(19,&apos;FFF&apos;,&apos;FFF@switch.com&apos;,1,&apos;123456&apos;);insert into users values(20,&apos;GGG&apos;,&apos;GGG@switch.com&apos;,1,&apos;123456&apos;);insert into users values(21,&apos;HHH&apos;,&apos;HHH@switch.com&apos;,1,&apos;123456&apos;);insert into users values(22,&apos;HHH&apos;,&apos;HHH@switch.com&apos;,1,&apos;123456&apos;);--分页语句select * from (select u.*,rownum rn from (select * from users order by id) u where rownum &lt;= 6) where rn &gt;=4;--序列自增长create sequence users_seqstart with 100increment by 1minvalue 100nomaxvaluenocyclenocache; 源代码：http://download.csdn.net/detail/q547550831/9391557 导入 MyEclipse 就能用了。 原文：Servlet学习笔记https://www.kancloud.cn/digest/switch-servlet/120123]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet 工作原理解析]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-1%2F</url>
    <content type="text"><![CDATA[Servlet 工作原理解析从 Servlet 容器说起要介绍 Servlet 必须要先把 Servlet 容器说清楚，Servlet 与 Servlet 容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。既然接口是连接 Servlet 与 Servlet 容器的关键，那我们就从它们的接口说起。 前面说了 Servlet 容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展，我们这里还是以大家最为熟悉 Tomcat 为例来介绍 Servlet 容器如何管理 Servlet。Tomcat 本身也很复杂，我们只从 Servlet 与 Servlet 容器的接口部分开始介绍，关于 Tomcat 的详细介绍可以参考我的另外一篇文章《 Tomcat 系统架构与模式设计分析》。 Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式。 图 1 . Tomcat 容器模型 从上图可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程，在 Tomcat 的配置文件中可以很容易发现这一点，如下： 清单 1 Context 配置参数12&lt;Context path="/projectOne " docBase="D:\projects\projectOne"reloadable="true" /&gt; 下面详细介绍一下 Tomcat 解析 Context 容器的过程，包括如何构建 Servlet 的过程。 Servlet 容器的启动过程Tomcat7 也开始支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。 清单 2 . 给 Tomcat 增加一个 Web 工程1234567Tomcat tomcat = getTomcatInstance(); File appDir = new File(getBuildDirectory(), "webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/examples/servlets/servlet/HelloWorldExample"); assertTrue(res.toString().indexOf("&lt;h1&gt;Hello World!&lt;/h1&gt;") &gt; 0); 清单 2的代码是创建一个 Tomcat 实例并新增一个 Web 应用，然后启动 Tomcat 并调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。 Tomcat 的 addWebapp 方法的代码如下： 清单 3 .Tomcat.addWebapp1234567891011121314151617181920public Context addWebapp(Host host, String url, String path) &#123; silence(url); Context ctx = new StandardContext(); ctx.setPath( url ); ctx.setDocBase(path); if (defaultRealm == null) &#123; initSimpleAuth(); &#125; ctx.setRealm(defaultRealm); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); if (host == null) &#123; getHost().addChild(ctx); &#125; else &#123; host.addChild(ctx); &#125; return ctx; &#125; 前面已经介绍了一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径，这个两个参数与清单 1 中的两个参数是一致的。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作，后面将会详细介绍。最后将这个 Context 容器加到父容器 Host 中。 接下去将会调用 Tomcat 的 start 方法启动 Tomcat，如果你清楚 Tomcat 的系统架构，你会容易理解 Tomcat 的启动逻辑，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理着容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener），关于这个设计模式可以参考《 Tomcat 的系统架构与设计模式，第二部分：设计模式》。Tomcat 启动的时序图可以用图 2 表示。 图 2. Tomcat 主要类的启动时序图 上图描述了 Tomcat 启动过程中，主要类之间的时序关系，下面我们将会重点关注添加 examples 应用所对应的 StandardContext 容器的启动过程。 当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用清单 3 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。 ContextConfig 的 init 方法将会主要完成以下工作： 创建用于解析 xml 配置文件的 contextDigester 对象 读取默认 context.xml 配置文件，如果存在解析它 读取默认 Host 配置文件，如果存在解析它 读取默认 Context 自身的配置文件，如果存在解析它 设置 Context 的 DocBase ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分： 创建读取资源文件的对象 创建 ClassLoader 对象 设置应用的工作目录 启动相关的辅助类如：logger、realm、resources 等 修改启动状态，通知感兴趣的观察者（Web 应用的配置） 子容器的初始化 获取 ServletContext 并设置必要的参数 初始化 “load on startup” 的 Servlet Web 应用的初始化工作Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。 Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(“catalina.base”)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。如果当前应用支持 Servlet3.0，解析还将完成额外 9 项工作，这个额外的 9 项工作主要是为 Servlet3.0 新增的特性，包括 jar 包中的 META-INF/web-fragment.xml 的解析以及对 annotations 的支持。 接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。下面是解析 Servlet 的代码片段： 清单 4. 创建 Wrapper 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748for (ServletDef servlet : servlets.values()) &#123; Wrapper wrapper = context.createWrapper(); String jspFile = servlet.getJspFile(); if (jspFile != null) &#123; wrapper.setJspFile(jspFile); &#125; if (servlet.getLoadOnStartup() != null) &#123; wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); &#125; if (servlet.getEnabled() != null) &#123; wrapper.setEnabled(servlet.getEnabled().booleanValue()); &#125; wrapper.setName(servlet.getServletName()); Map&lt;String,String&gt; params = servlet.getParameterMap(); for (Entry&lt;String, String&gt; entry : params.entrySet()) &#123; wrapper.addInitParameter(entry.getKey(), entry.getValue()); &#125; wrapper.setRunAs(servlet.getRunAs()); Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) &#123; wrapper.addSecurityReference( roleRef.getName(), roleRef.getLink()); &#125; wrapper.setServletClass(servlet.getServletClass()); MultipartDef multipartdef = servlet.getMultipartDef(); if (multipartdef != null) &#123; if (multipartdef.getMaxFileSize() != null &amp;&amp; multipartdef.getMaxRequestSize()!= null &amp;&amp; multipartdef.getFileSizeThreshold() != null) &#123; wrapper.setMultipartConfigElement(new MultipartConfigElement( multipartdef.getLocation(), Long.parseLong(multipartdef.getMaxFileSize()), Long.parseLong(multipartdef.getMaxRequestSize()), Integer.parseInt( multipartdef.getFileSizeThreshold()))); &#125; else &#123; wrapper.setMultipartConfigElement(new MultipartConfigElement( multipartdef.getLocation())); &#125; &#125; if (servlet.getAsyncSupported() != null) &#123; wrapper.setAsyncSupported( servlet.getAsyncSupported().booleanValue()); &#125; context.addChild(wrapper); &#125; 这段代码清楚的描述了如何将 Servlet 包装成 Context 容器中的 StandardWrapper，这里有个疑问，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象。这里 StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。 除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。 创建 Servlet 实例前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。 创建 Servlet 对象如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。 创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。 创建 Servlet 对象的相关类结构图如下： 图 3. 创建 Servlet 对象的相关类结构 初始化 Servlet初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。 如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。 这样 Servlet 对象就初始化完成了，事实上 Servlet 从被 web.xml 中解析到完成初始化，这个过程非常复杂，中间有很多过程，包括各种容器状态的转化引起的监听事件的触发、各种访问权限的控制和一些不可预料的错误发生的判断行为等等。我们这里只抓了一些关键环节进行阐述，试图让大家有个总体脉络。 下面是这个过程的一个完整的时序图，其中也省略了一些细节。 图 4. 初始化 Servlet 的时序图 Servlet 体系结构我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。 图 5.Servlet 顶层类关联图 从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的 “握手型的交互式” 运行模式。所谓 “握手型的交互式” 就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。 ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？ 下图是 ServletConfig 和 ServletContext 在 Tomcat 容器中的类关系图。 图 6. ServletConfig 在容器中的类关联图 上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类。所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。 同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。 通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。 Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？ 图 7.Request 相关类结构图 上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示： 图 8.Request 和 Response 的转变过程 Servlet 如何工作我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。 当用户从浏览器向服务器发起一个请求，通常会包含如下信息：http://hostname: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？ Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。 图 9.Request 的 Mapper 类关系图 可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 : 清单 5. MapperListener.init12345678910111213public void init() &#123; findDefaultHost(); Engine engine = (Engine) connector.getService().getContainer(); engine.addContainerListener(this); Container[] conHosts = engine.findChildren(); for (Container conHost : conHosts) &#123; Host host = (Host) conHost; if (!LifecycleState.NEW.equals(host.getState())) &#123; host.addLifecycleListener(this); registerHost(host); &#125; &#125; &#125; 这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。 图 10.Request 在容器中的路由图 上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。 接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。 Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。 当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。 Session 与 Cookie前面我们已经说明了 Servlet 如何被调用，我们基于 Servlet 来构建应用程序，那么我们能从 Servlet 获得哪些数据信息呢？ Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 init 方法时设置的 ServletConfig，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。根据前面的介绍 ServletConfig 的实际对象是 StandardWrapperFacade，到底能获得哪些容器信息可以看看这类提供了哪些接口。还有一部分数据是由 ServletRequest 类提供，它的实际对象是 RequestFacade，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。所以要掌握 Servlet 的工作方式必须要很清楚 HTTP 协议，如果你还不清楚赶紧去找一些参考资料。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。 Session 与 Cookie 不管是对 Java Web 的熟练使用者还是初学者来说都是一个令人头疼的东西。Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。 不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作： 基于 URL Path Parameter，默认就支持 基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的 基于 SSL，默认不支持，只有 connector.getAttribute(“SSLEnabled”) 为 TRUE 时才支持 第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中 “Servlet；” 后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。 请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。 如果是第三种情况的话将会根据 javax.servlet.request.ssl_session 属性值设置 Session ID。 有了 Session ID 服务器端就可以创建 HttpSession 对象了，第一次触发是通过 request. getSession() 方法，如果当前的 Session ID 还没有对应的 HttpSession 对象那么就创建一个新的，并将这个对象加到 org.apache.catalina. Manager 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 HttpSession 对象存在，用户就可以根据 Session ID 来获取到这个对象，也就达到了状态的保持。 图 11.Session 相关类图 上从图中可以看出从 request.getSession 中获取的 HttpSession 对象实际上是 StandardSession 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图： 图 12.Session 工作的时序图 还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的 session-config 配置项来指定。 Servlet 中的 Listener整个 Tomcat 服务器中 Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示： 图 13.Servlet 中的 Listener 它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 ServletContextListener 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。 总结本文涉及到内容有点多，要把每个细节都说清楚，似乎不可能，本文试着从 Servlet 容器的启动到 Servlet 的初始化，以及 Servlet 的体系结构等这些环节中找出一些重点来讲述，目的是能读者有一个总体的完整的结构图，同时也详细分析了其中的一些难点问题，希望对大家有所帮助。 原文：Java Servlet完全教程 - ImportNewhttp://www.importnew.com/14621.html 参考：Java Servlet完全教程 - ImportNewhttp://www.importnew.com/14621.htmlServlet 工作原理解析https://www.ibm.com/developerworks/cn/java/j-lo-servlet/Servlet3.1规范（最终版）中文版下载 - 开涛的博客—公众号：kaitao-1234567，一如既往的干货分享 - ITeye博客http://jinnianshilongnian.iteye.com/blog/1912455前言 · Servlet学习笔记 · 看云https://www.kancloud.cn/digest/switch-servlet/120123Servlet教程_w3cschoolhttps://www.w3cschool.cn/servlet/]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda 大数据分析+json返回给echarts图表]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26%2F</url>
    <content type="text"><![CDATA[anaconda安装环境：pymysql 在jupyterlab中引入该包并建立数据库连接： 12345678910111213#!/usr/bin/python3 import pymysql # 打开数据库连接conn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码) 首先，我们要创建一个游标cursor = conn.cursor()什么是游标呢？ 游标就相当于一个缓冲区，存放暂时的结果（这是我的理解） 就像去超市买买买，你可能要推一个手推车，这里的手推车就像游标，推着手推车去对应的货架完成挑选操作，而手推车最终会在出超市时候清空 12345678910111213import pymysqlconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)cursor = conn.cursor()#创建一个游标cursor.execute('SELECT * FROM `f_vote`;')data = cursor.fetchone()#取一条数据print(data) 当我们将fetchone改成fetchall时候，就是取出所有信息了 下面是带异常检测的连接： 123456789101112131415161718import pymysqltry: conn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码 ) cursor = conn.cursor() cursor.execute('SELECT * FROM `f_vote`;') data = cursor.fetchall()#取一条数据 print(data) conn.close()except MySQLdb.Error as e: print('Error:%s' % e) 导入表中所有数据并查看前五行 12345678910111213import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)sql = 'SELECT * FROM `f_vote`;'df = pd.read_sql(sql,conn)df.head() 结果： 查找id=3的记录： 12345678910111213141516import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)#sql = 'SELECT * FROM `f_vote`;'#df = pd.read_sql(sql,conn)#df.head()sql1 = 'SELECT * FROM `f_vote` WHERE `id` = 3;'df1 = pd.read_sql(sql1,conn)df1 结果： 查找vote_num大于6000的数据，注意这里默认按照id排序的： 12345678910111213141516171819import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)#sql = 'SELECT * FROM `f_vote`;'#df = pd.read_sql(sql,conn)#df.head()#sql1 = 'SELECT * FROM `f_vote` WHERE `id` = 3;'#df1 = pd.read_sql(sql1,conn)#df1sql2 = 'SELECT * FROM `f_vote` WHERE `vote_num` &gt; 6000;'df2 = pd.read_sql(sql2,conn)df2 结果： 加上ORDER BY goods_prices之后，就是按照价格升序排列： 1234567891011121314151617181920import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)#sql = 'SELECT * FROM `f_vote`;'#df = pd.read_sql(sql,conn)#df.head()#sql1 = 'SELECT * FROM `f_vote` WHERE `id` = 3;'#df1 = pd.read_sql(sql1,conn)#df1sql2 = 'SELECT * FROM `f_vote` WHERE `vote_num` &gt; 6000 ORDER BY `vote_num`;'#sql2 = 'SELECT * FROM `f_vote` WHERE `vote_num` &gt; 6000 ORDER BY `vote_num`DESC;'df2 = pd.read_sql(sql2,conn)df2 结果： 将数据库文件导出成csv 12345678910111213141516171819import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)#sql = 'SELECT * FROM `f_vote`;'#df = pd.read_sql(sql,conn)#df.head()#sql1 = 'SELECT * FROM `f_vote` WHERE `id` = 3;'#df1 = pd.read_sql(sql1,conn)#df1sql2 = 'SELECT * FROM `f_vote` WHERE `vote_num` &gt; 6000 ORDER BY `vote_num`DESC;'df2 = pd.read_sql(sql2,conn)df2.to_csv('/Users/pailiu/Downloads/goods_info.csv', encoding = 'utf-8', index = False) 最后养成好习惯，断开与数据库的连接：conn.close() pandas.DataFrame.to_json按行转json 官网demo： 123456789101112131415161718192021222324252627282930313233df = pd.DataFrame([['a', 'b'], ['c', 'd']], index=['row 1', 'row 2'], columns=['col 1', 'col 2'])###########split###########df.to_json(orient='split')&gt;'&#123;"columns":["col 1","col 2"], "index":["row 1","row 2"], "data":[["a","b"],["c","d"]]&#125;'###########index###########df.to_json(orient='index')&gt;'&#123;"row 1":&#123;"col 1":"a","col 2":"b"&#125;,"row 2":&#123;"col 1":"c","col 2":"d"&#125;&#125;'###########records###########df.to_json(orient='index')&gt;'[&#123;"col 1":"a","col 2":"b"&#125;,&#123;"col 1":"c","col 2":"d"&#125;]'###########table###########df.to_json(orient='table')&gt;'&#123;"schema": &#123;"fields": [&#123;"name": "index", "type": "string"&#125;, &#123;"name": "col 1", "type": "string"&#125;, &#123;"name": "col 2", "type": "string"&#125;], "primaryKey": "index", "pandas_version": "0.20.0"&#125;, "data": [&#123;"index": "row 1", "col 1": "a", "col 2": "b"&#125;, &#123;"index": "row 2", "col 1": "c", "col 2": "d"&#125;]&#125;' 主要参考官网API：https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_json.html 下面是示例： split： index records table pandas_views.py文件内容如下： 123456789101112131415161718import MySQLdbimport pandas as pdimport pandas as pdconn = MySQLdb.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)sql1 = 'SELECT * FROM `bigdata1`;'df1 = pd.read_sql(sql1,conn)df1.to_json('../static/BigDataAnalysis/test.json',orient='table')conn.close() jupterLab： 1234567891011121314import pymysqlimport pandas as pdimport jsonconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)sql1 = 'SELECT * FROM `bigdata1`;'df1 = pd.read_sql(sql1,conn)df1.to_json('/Users/pailiu/Downloads/1234.json',orient='table') BigDataOnlineJson.html如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&#123;% extends "Scratch/index.html" %&#125;&#123;% load render_table from django_tables2 %&#125;&#123;% load favorite_extra %&#125;&#123;% load staticfiles %&#125;&#123;% block css %&#125; &lt;link href=&#123;% static "Scratch/css/productlist.css" %&#125; rel='stylesheet' type='text/css'/&gt; &lt;link href=&#123;% static "Scratch/css/gallerylist.css" %&#125; rel='stylesheet' type='text/css'/&gt;&#123;% endblock %&#125;&#123;% block mainbody %&#125; &lt;body style="height: 100%; margin: 0"&gt; &lt;div id="container" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts-gl/echarts-gl.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts-stat/ecStat.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/dataTool.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/china.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/world.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=ZUONbpqGBsYGXNIYHicvbAbM"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/bmap.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/simplex.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('container')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; title: &#123; text: '异步数据加载示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['发布排行'] &#125;, xAxis: &#123; data: [] &#125;, yAxis: &#123; splitLine: &#123; show: false &#125;,//去除网格线 name: '' &#125;, series: [&#123; barWidth: "30px", name: '发布排行', type: 'bar', itemStyle: &#123; normal: &#123; label: &#123; show: true, position: 'top', textStyle: &#123; color: '#333' &#125; &#125; &#125; &#125;, data: [] &#125;] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（实际用来盛放X轴坐标值） var nums = []; //销量数组（实际用来盛放Y坐标值） $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/test.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 $.each(result.data, function (index, item) &#123; names.push(item.department); //挨个取出类别并填入类别数组 nums.push(item.num); //挨个取出销量并填入销量数组 &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 xAxis: &#123; data: names &#125;, series: [&#123; // 根据名字对应到相应的系列 name: '发布排行', //显示在上部的标题 data: nums &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;;loadOneColumn(); &lt;/script&gt; &lt;/body&gt;&#123;% endblock %&#125; 最终效果展示: 参考：Python操作Mysql数据库入门——查看和增加记录 - 天善智能：专注于商业智能BI和数据分析、大数据领域的垂直社区平台https://ask.hellobi.com/blog/wangdawei/9367Python操作Mysql数据库入门——数据导入pandas（数据分析准备） - 天善智能：专注于商业智能BI和数据分析、大数据领域的垂直社区平台https://ask.hellobi.com/blog/wangdawei/9441Python3 MySQL 数据库连接 | 菜鸟教程http://www.runoob.com/python3/python3-mysql.html]]></content>
      <tags>
        <tag>python</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache commons BeanUtils学习]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25-4%2F</url>
    <content type="text"><![CDATA[BeanUtils 简要描述beanutils，顾名思义，是 java bean 的一个工具类，可以帮助我们方便的读取 (get) 和设置(set)bean 属性值、动态定义和访问 bean 属性； 细心的话，会发现其实 JDK 已经提供了一个 java.beans 包，同样可以实现以上功能，只不过使用起来比较麻烦，所以诞生了 apache commons beanutils； 看源码就知道，其实 apache commons beanutils 就是基于 jdk 的 java.beans 包实现的。 Java Bean在介绍 apache commons beanutils 之前，很有必要先了解下 javabean。 apache commons beanutils 就是基于 JavaBeans 的设计命名规范来实现的，如下是一个简单的 javabean 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* * File Name: Employee.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.pojo;import java.util.Date;/** * * @author PiChen * @version 2017年5月29日 */public class Employee&#123; private String firstName; private String lastName; private Date hireDate; private boolean isManager;/** * @return the firstName */ public String getFirstName() &#123; return firstName; &#125; /** * @param firstName the firstName to set */ public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; /** * @return the lastName */ public String getLastName() &#123; return lastName; &#125; /** * @param lastName the lastName to set */ public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; /** * @return the hireDate */ public Date getHireDate() &#123; return hireDate; &#125; /** * @param hireDate the hireDate to set */ public void setHireDate(Date hireDate) &#123; this.hireDate = hireDate; &#125; /** * @return the isManager */ public boolean isManager() &#123; return isManager; &#125; /** * @param isManager the isManager to set */ public void setManager(boolean isManager) &#123; this.isManager = isManager; &#125; /** * @return the fullName */ public String getFullName() &#123; return firstName + " " + lastName; &#125;&#125; javabean 一般有以下几个特性：1、类必须是 public 访问权限，且需要有一个 public 的无参构造方法，之所以这样主要是方便利用 Java 的反射动态创建对象实例： 12Class beanClass = Class.forName(className);Object beanInstance = beanClass.newInstance(); 2、由于 javabean 的构造方法是无参的，所以我们的 bean 的行为配置（即设置 bean 的属性值，方法对应行为，属性对应数据）不能在构造方法完成，取而代之的是通过一系列的 set 方法来设置属性值，通过 setter 方法，我们可以改变 javabean 呈现出来的行为和内部数据，这里的 setter 方法会按一定的约定来命名，如 setHireDate、setName。。。 3、读取和设置 bean 属性值的命名约定，即 getter 方法和 setter 方法, 不过这里需要特别注意 boolean 类型的约定，如下示例： 123456789101112private String firstName;private String lastName;private Date hireDate;private boolean isManager;public String getFirstName();public void setFirstName(String firstName);public String getLastName();public void setLastName(String lastName);public Date getHireDate();public void setHireDate(Date hireDate);public boolean isManager();public void setManager(boolean manager); 4、并不是必须为每个属性提供 setter 和 getter 方法，我们可以只定义一个属性的 getter 方法而不定义 setter 方法，这样的属性一般是只读属性； 访问基本数据类型的 Bean 属性简述： 这类属性指的是 Integer, Double, Float, boolean 等,,,, 注意这里还包括 String，其实像 HashMap，ArrayList, 等属性都可以设置，只不过 Map 里面的键值对、List 索引处的值无法通过这两个 API 访问，需要使用专门的 API 来处理，接下来将会介绍； 访问 API： PropertyUtils.getSimpleProperty(Object, String) PropertyUtils.setSimpleProperty(Object, String, Object) 调用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * File Name: Main.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.Employee;/** * * @author PiChen * @version 2017年5月29日 */public class BasicPropertyAccess&#123; /** * * * @param args * @throws NoSuchMethodException * @throws InvocationTargetException * @throws IllegalAccessException */ public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Employee employee = new Employee(); String firstName = (String) PropertyUtils.getSimpleProperty(employee, "firstName"); String lastName = (String) PropertyUtils.getSimpleProperty(employee, "lastName"); firstName = firstName == null ? "Pi" : ""; lastName = lastName == null ? "Chen" : ""; PropertyUtils.setSimpleProperty(employee, "firstName", firstName); PropertyUtils.setSimpleProperty(employee, "lastName", lastName); System.out.println(employee.getFullName()); &#125;&#125; 访问索引类型的 Bean 属性简述： 可索引的属性，如 ArrayList, 数组等，可以通过下标索引来访问 Bean 属性的值, 同理可设置 value； 访问 API PropertyUtils.getIndexedProperty(Object, String) PropertyUtils.getIndexedProperty(Object, String, int) PropertyUtils.setIndexedProperty(Object, String, Object) PropertyUtils.setIndexedProperty(Object, String, int, Object) 调用示例 Bean： 12345678910111213141516171819202122232425262728293031323334353637383940package apache.commons.beanutils.example.pojo;import java.util.List;public class IndexedBean &#123; private List&lt;Employee&gt; employeeList; private Integer[] intArr; /** * @return the employeeList */ public List&lt;Employee&gt; getEmployeeList() &#123; return employeeList; &#125; /** * @param employeeList the employeeList to set */ public void setEmployeeList(List&lt;Employee&gt; employeeList) &#123; this.employeeList = employeeList; &#125; /** * @return the intArr */ public Integer[] getIntArr() &#123; return intArr; &#125; /** * @param intArr the intArr to set */ public void setIntArr(Integer[] intArr) &#123; this.intArr = intArr; &#125;&#125; 调用 example： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * File Name: Main.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import java.util.ArrayList;import java.util.List;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.Employee;import apache.commons.beanutils.example.pojo.IndexedBean;/** * * @author PiChen * @version 2017年5月29日 */public class IndexedPropertiesAccess&#123; /** * * * @param args * @throws NoSuchMethodException * @throws InvocationTargetException * @throws IllegalAccessException */ public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; // 初始工作 IndexedBean indexedBean = new IndexedBean(); List&lt;Employee&gt; employeeList = new ArrayList&lt;Employee&gt;(); Employee e1 = new Employee(); e1.setLastName("Chen"); Employee e2 = new Employee(); e2.setLastName("Wang"); employeeList.add(e1); employeeList.add(e2); indexedBean.setEmployeeList(employeeList); indexedBean.setIntArr(new Integer[]&#123; 0, 1, 2 &#125;); // API测试 int index0 = 0; String name0 = "employeeList[" + index0 + "]"; Employee employee0 = (Employee) PropertyUtils.getIndexedProperty(indexedBean, name0); System.out.println(employee0.getLastName()); int index1 = 1; String name1 = "employeeList[" + index1 + "]"; Employee employee1 = (Employee) PropertyUtils.getIndexedProperty(indexedBean, name1); System.out.println(employee1.getLastName()); Employee employee00 = (Employee) PropertyUtils.getIndexedProperty(indexedBean,"employeeList", 0); Employee employee11 = (Employee) PropertyUtils.getIndexedProperty(indexedBean,"employeeList", 1); System.out.println(employee00.getLastName()); System.out.println(employee11.getLastName()); Integer i = (Integer) PropertyUtils.getIndexedProperty(indexedBean,"intArr", 1); System.out.println(i); &#125;&#125; 访问 Map 映射类型的 Bean 属性简述： 常见的 HashMap，TreeMap 等，可以通过 key 来访问 Bean 属性值，同理可设置 value； 访问 API: PropertyUtils.getMappedProperty(Object, String) PropertyUtils.getMappedProperty(Object, String, String) PropertyUtils.setMappedProperty(Object, String, Object) PropertyUtils.setMappedProperty(Object, String, String, Object) 调用示例： map bean: 12345678910111213141516171819202122232425262728293031323334353637/* * File Name: MappedBean.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.pojo;import java.util.Map;/** * * @author PiChen * @version 2017年5月29日 */public class MappedBean&#123; private Map&lt;String, Object&gt; mapProperty; /** * @return the mapProperty */ public Map&lt;String, Object&gt; getMapProperty() &#123; return mapProperty; &#125; /** * @param mapProperty the mapProperty to set */ public void setMapProperty(Map&lt;String, Object&gt; mapProperty) &#123; this.mapProperty = mapProperty; &#125;&#125; 使用 example： 123456789101112131415161718192021222324252627282930313233343536373839/* * File Name: MapPropertyAccess.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.MappedBean;/** * * @author PiChen * @version 2017年5月29日 */public class MapPropertyAccess&#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; MappedBean employee = new MappedBean(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //employee.setMapProperty(map); PropertyUtils.setSimpleProperty(employee, "mapProperty", map); PropertyUtils.setMappedProperty(employee, "mapProperty", "testKey1", "testValue1"); PropertyUtils.setMappedProperty(employee, "mapProperty(testKey2)", "testValue2"); System.out.println(employee.getMapProperty().get("testKey1")); System.out.println(employee.getMapProperty().get("testKey2")); &#125;&#125; 访问嵌套类型的 Bean 属性简述： 指的是对象内嵌套对象 访问 API: PropertyUtils.getNestedProperty(Object, String) [PropertyUtils.setNestedProperty(Object, String, Object)](http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setNestedProperty-java.lang.Object-java.lang.String-java.lang.Object-) 调用示例： 嵌套 bean： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * File Name: NestedBean.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.pojo;import java.util.List;import java.util.Map;/** * * @author PiChen * @version 2017年5月29日 */public class NestedBean&#123; private List&lt;Employee&gt; listProperty; private Map&lt;String, Employee&gt; mapProperty; /** * @return the listProperty */ public List&lt;Employee&gt; getListProperty() &#123; return listProperty; &#125; /** * @param listProperty the listProperty to set */ public void setListProperty(List&lt;Employee&gt; listProperty) &#123; this.listProperty = listProperty; &#125; /** * @return the mapProperty */ public Map&lt;String, Employee&gt; getMapProperty() &#123; return mapProperty; &#125; /** * @param mapProperty the mapProperty to set */ public void setMapProperty(Map&lt;String, Employee&gt; mapProperty) &#123; this.mapProperty = mapProperty; &#125;&#125; 使用 example： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * File Name: NestedPropertyAccess.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.Employee;import apache.commons.beanutils.example.pojo.NestedBean;/** * * @author PiChen * @version 2017年5月29日 */public class NestedPropertyAccess&#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Employee e = new Employee(); e.setLastName("Chen"); NestedBean nestedBean = new NestedBean(); List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); list.add(e); Map&lt;String, Employee&gt; map = new HashMap&lt;String, Employee&gt;(); map.put("testKey", e); nestedBean.setListProperty(list); nestedBean.setMapProperty(map); String lastName = (String) PropertyUtils.getNestedProperty(nestedBean, "mapProperty(testKey).lastName"); System.out.println(lastName); String lastName2 = (String) PropertyUtils.getNestedProperty(nestedBean, "listProperty[0].lastName"); System.out.println(lastName2); &#125;&#125; 访问所有类型的 Bean 属性简述 通过以上 API 的使用，我们了解了各类 bean 属性的访问方法，其实还有一种通用的方法，适用于各类 bean 属性类型； 访问 API PropertyUtils.getProperty(Object, String) PropertyUtils.setProperty(Object, String, Object) 使用示例，这里直接以嵌套类型属性为例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * File Name: NestedPropertyAccess.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.Employee;import apache.commons.beanutils.example.pojo.NestedBean;/** * * @author PiChen * @version 2017年5月29日 */public class NestedPropertyAccess&#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Employee e = new Employee(); e.setLastName("Chen"); NestedBean nestedBean = new NestedBean(); List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); list.add(e); Map&lt;String, Employee&gt; map = new HashMap&lt;String, Employee&gt;(); map.put("testKey", e); nestedBean.setListProperty(list); nestedBean.setMapProperty(map); String lastName2 = (String) PropertyUtils.getProperty(nestedBean, "listProperty[0].lastName"); System.out.println(lastName2); PropertyUtils.setProperty(nestedBean, "listProperty[0].lastName", "Hello World"); System.out.println(nestedBean.getListProperty().get(0).getLastName()); &#125;&#125; 参考：http://www.cnblogs.com/chenpi/p/6917499.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>待阅</tag>
        <tag>工具类</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache commons lang学习]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25-3%2F</url>
    <content type="text"><![CDATA[概述跟 java.lang 这个包的作用类似，Commons Lang 这一组 API 也是提供一些基础的、通用的操作和处理，如自动生成 toString() 的结果、自动实现 hashCode() 和 equals() 方法、数组操作、枚举、日期和时间的处理等等。 这一组 API 的所有包名都以 org.apache.commons.lang 开头，共有如下 8 个包： org.apache.commons.langorg.apache.commons.lang.builderorg.apache.commons.lang.enumorg.apache.commons.lang.enumsorg.apache.commons.lang.exceptionorg.apache.commons.lang.mathorg.apache.commons.lang.mutableorg.apache.commons.lang.time 其中的 lang.enum 已不建议使用，替代它的是紧随其后的 lang.enums 包。 lang 包主要是一些可以高度重用的 Util 类；lang.builder 包包含了一组用于产生每个 Java 类中都常使用到的 toString()、hashCode()、equals()、compareTo() 等等方法的构造器；lang.enums 包顾名思义用于处理枚举；lang.exception 包用于处理 Java 标准 API 中的 exception，为 1.4 之前版本提供 Nested Exception 功能；lang.math 包用于处理数字；lang.mutable 用于包装值型变量；lang.time 包提供处理日期和时间的功能。 下面讲下最常用的三个类 ArrayUtils数组是我们经常需要使用到的一种数据结构，但是由于 Java 本身并没有提供很好的 API 支持，使得很多操作实际上做起来相当繁琐，以至于我们实际编码中甚至会不惜牺牲性能去使用 Collections API，用 Collection 当然能够很方便的解决我们的问题，但是我们一定要以性能为代价吗？ArrayUtils 帮我们解决了处理类似情况的大部分问题。 常量数组1234567public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0]; public static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class[0]; public static final String[] EMPTY_STRING_ARRAY = new String[0]; public static final long[] EMPTY_LONG_ARRAY = new long[0]; public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0]; public static final int[] EMPTY_INT_ARRAY = new int[0]; public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0]; 转换为 MaptoMap(Object[] array)将二维数组转换为 Map。 12345Map colorMap = ArrayUtils.toMap(new String[][] &#123; &#123;"RED", "#FF0000"&#125;, &#123;"GREEN", "#00FF00"&#125;, &#123;"BLUE", "#0000FF"&#125;&#125;); 生成数组T[] toArray(final T… items)将不定参数转换为数组。 12String[] array = ArrayUtils.toArray("1", "2"); String[] emptyArray = ArrayUtils.&lt;String&gt;toArray(); null 转空数组Object[] nullToEmpty(Object[] array)将 null 数组转为对应类型的空数组，如果 array 不是 null，则返回 array。 1String[] arr = ArrayUtils.nullToEmpty((String[]) null); 数组操作T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)截取数组开始索引位置和结束索引位置的数组为子数组 12Object[]s1=ArrayUtils.subarray(newObject[]&#123;"aa","bb","cc"&#125;,0,1); // ["aa"] Object[]s2=ArrayUtils.subarray(newObject[]&#123;"aa","bb","cc"&#125;,0,2); // ["aa", "bb"] reverse(long[] array)反转数组。 1ArrayUtils.reverse(new String[]&#123;"aa","bb"&#125;);//结果是：&#123;"bb"，"aa"&#125; swap(Object[] array, int offset1, int offset2)交换数组中的元素。 12345ArrayUtils.swap(["1", "2", "3"], 0, 2) -&gt; ["3", "2", "1"] ArrayUtils.swap(["1", "2", "3"], 0, 0) -&gt; ["1", "2", "3"] ArrayUtils.swap(["1", "2", "3"], 1, 0) -&gt; ["2", "1", "3"] ArrayUtils.swap(["1", "2", "3"], 0, 5) -&gt; ["1", "2", "3"] ArrayUtils.swap(["1", "2", "3"], -1, 1) -&gt; ["2", "1", "3"] 数组元素查找int indexOf(Object[] array, Object objectToFind)数组元素所在的索引位置, 如果没有则返回 - 1, 可指定起始搜索位置。 123ArrayUtils.indexOf(new String[]&#123;"aa","bb","cc"&#125;,"cc"); // 2 ArrayUtils.indexOf(new String[]&#123;"aa","bb","bb"&#125;,"bb",2); // 2 ArrayUtils.indexOf(newObject[]&#123;"aa","bb","cc"&#125;,"cc",3); // -1 int lastIndexOf(Object[] array, Object objectToFind, int startIndex)同indexOf(Object[] array, Object objectToFind)相反。反向查询某个 object 在数组中的位置，可以指定起始搜索位置。 contains(Object[] array, Object objectToFind)判断数组中是否包含某个元素。 1ArrayUtils.contains(new String[]&#123;"a", "b", "c"&#125;, "a"); // true 数组判空boolean isEmpty(Object[] array)判断数组是否为空。 1234ArrayUtils.isEmpty(new String[]&#123;"21","是"&#125;); // false ArrayUtils.isEmpty(new String[]&#123;""&#125;); // false ArrayUtils.isEmpty(new String[]&#123;null&#125;); // false ArrayUtils.isEmpty(new String[]&#123;&#125;); // true boolean isNotEmpty(T[] array)同 boolean isEmpty 相反。判断数组是否不为空。 合并数组元素T[] addAll(T[] array1, T… array2)合并多个数组到某一个数组中。 123456ArrayUtils.addAll(null, null) = null ArrayUtils.addAll(array1, null) = cloned copy of array1 ArrayUtils.addAll(null, array2) = cloned copy of array2 ArrayUtils.addAll([], []) = [] ArrayUtils.addAll([null], [null]) = [null, null] ArrayUtils.addAll(["a", "b", "c"], ["1", "2", "3"]) = ["a", "b", "c", "1", "2", "3"] T[] add(T[] array, T element)将单个元素合并到数组中。 12345ArrayUtils.add(null, null) = IllegalArgumentException ArrayUtils.add(null, "a") = ["a"] ArrayUtils.add(["a"], null) = ["a", null] ArrayUtils.add(["a"], "b") = ["a", "b"] ArrayUtils.add(["a", "b"], "c") = ["a", "b", "c"] T[] add(T[] array, int index, T element)将单个元素合并到指定索引位置的数组中。 12345ArrayUtils.add(null, 0, null) = IllegalArgumentException ArrayUtils.add(null, 0, "a") = ["a"] ArrayUtils.add(["a"], 1, null) = ["a", null] ArrayUtils.add(["a"], 0, "b") = ["b", "a"] ArrayUtils.add(["a", "b"], 1, "c") = ["a", "c", "b"] 移除数组元素T[] remove(T[] array, int index)移除数组中指定索引位置的元素。 1234ArrayUtils.remove(["a"], 0) = [] ArrayUtils.remove(["a", "b"], 0) = ["b"] ArrayUtils.remove(["a", "b"], 1) = ["a"] ArrayUtils.remove(["a", "b", "c"], 1) = ["a", "c"] T[] removeAll(T[] array, int… indices)同&lt;T&gt; T[] remove(T[] array, int index)相似，移除数组中所有指定索引位置的元素。 12ArrayUtils.removeAll(["a", "b", "c"], 0, 2) = ["b"] ArrayUtils.removeAll(["a", "b", "c"], 1, 2) = ["a"] T[] removeElement(T[] array, Object element)移除数组中的第一个 element 元素。 12345ArrayUtils.removeElement(null, "a") = null ArrayUtils.removeElement([], "a") = [] ArrayUtils.removeElement(["a"], "b") = ["a"] ArrayUtils.removeElement(["a", "b"], "a") = ["b"] ArrayUtils.removeElement(["a", "b", "a"], "a") = ["b", "a"] 字符串的处理类（StringUtils）处理文本对 Java 应用来说应该算是家常便饭了，在 1.4 出现之前，Java 自身提供的 API 非常有限，如 String、StringTokenizer、StringBuffer，操作也比较单一。无非就是查找 substring、分解、合并等等。到 1.4 的出现可以说 Java 的文字处理上了一个台阶，因为它支持 regular expression 了。这可是个重量级而方便的东东啊，缺点是太复杂，学习起来有一定难度。相较而言，Jakarta Commons 提供的 StringUtils 和 WordUtils 至今还维持着那种简洁而强大的美，使用起来也很顺手。 org.apache.commons.lang3.StringUtils 继承 Object,Operations onString that are null safe。所谓的 null safe 就是对 String 进行操作不会出现 NullPointerException 异常，很实用有没有！以后再也不怕到处出现空指针异常了。先看看官方文档中这个类都有些什么方法： 判断空字符串isEmpty(CharSequence cs)判断是否是空字符串，代码示例： 12345StringUtils.isEmpty(null) = true StringUtils.isEmpty("") = true StringUtils.isEmpty(" ") = false StringUtils.isEmpty("bob") = false StringUtils.isEmpty(" bob ") = false isNotEmpty(CharSequence cs)判断是否不是空字符串，与isEmpty(CharSequence cs)相反。 isAnyEmpty(CharSequence… css)判断是否含有空字符串，代码示例： 1234567StringUtils.isAnyEmpty(null) = true StringUtils.isAnyEmpty(null, "foo") = true StringUtils.isAnyEmpty("", "bar") = true StringUtils.isAnyEmpty("bob", "") = true StringUtils.isAnyEmpty(" bob ", null) = true StringUtils.isAnyEmpty(" ", "bar") = false StringUtils.isAnyEmpty("foo", "bar") = false isNoneEmpty(CharSequence… css)判断是否都不是空字符串，与isAnyEmpty(CharSequence... css)相反。 isAllEmpty(CharSequence… css)判断是否都是空字符串，代码示例： 123456789StringUtils.isAllEmpty(null) = true StringUtils.isAllEmpty(null, "") = true StringUtils.isAllEmpty(new String[] &#123;&#125;) = true StringUtils.isAllEmpty(null, "foo") = false StringUtils.isAllEmpty("", "bar") = false StringUtils.isAllEmpty("bob", "") = false StringUtils.isAllEmpty(" bob ", null) = false StringUtils.isAllEmpty(" ", "bar") = false StringUtils.isAllEmpty("foo", "bar") = false isBlank(CharSequence cs)判断是否是 “大空字符串”，代码示例： 12345StringUtils.isBlank(null) = true StringUtils.isBlank("") = true StringUtils.isBlank(" ") = true StringUtils.isBlank("bob") = false StringUtils.isBlank(" bob ") = false isNotBlank(CharSequence cs)判断是否不是 “大空字符串”，与isBlank(CharSequence cs)相反，与isNotEmpty(CharSequence cs)相似。 isAnyBlank(CharSequence… css)判断是否有 “大空字符串”，与isAnyEmpty(CharSequence... css)相似。 isNoneBlank(CharSequence… css)判断是否都不是 “大空字符串”，与isAnyBlank(CharSequence... css)相反，与isNoneEmpty(CharSequence... css)相似。 isAllBlank(CharSequence… css)判断是否都是 “大空字符串”，与isAllEmpty(CharSequence... css)相似。 截取字符串trim(String str)去除字符串前后的控制符，代码示例： 12345StringUtils.trim(null) = null StringUtils.trim("") = "" StringUtils.trim(" ") = "" StringUtils.trim("abc") = "abc" StringUtils.trim(" abc ") = "abc" trimToNull(String str)去除字符串前后的控制符，如何是空字符串则转为null，代码示例： 12345StringUtils.trimToNull(null) = null StringUtils.trimToNull("") = null StringUtils.trimToNull(" ") = null StringUtils.trimToNull("abc") = "abc" StringUtils.trimToNull(" abc ") = "abc" trimToEmpty(String str)去除字符串前后的控制符，如何是null则转为空字符串，代码示例： 12345StringUtils.trimToEmpty(null) = "" StringUtils.trimToEmpty("") = "" StringUtils.trimToEmpty(" ") = "" StringUtils.trimToEmpty("abc") = "abc" StringUtils.trimToEmpty(" abc ") = "abc" truncate(String str, int maxWidth)截断字符串，具有以下特点： 如果 str 字符串的长度小于 maxWidth，则直接返回 str。 不满足第一条时，则为substring(str, 0, maxWidth)。 如果 maxWidth 小于 0，则抛出 IllegalArgumentException。 在任何情况下都不会返回长度大于 maxWidth 的字符串。 代码示例： 12345678StringUtils.truncate(null, 0) = null StringUtils.truncate(null, 2) = null StringUtils.truncate("", 4) = "" StringUtils.truncate("abcdefg", 4) = "abcd" StringUtils.truncate("abcdefg", 6) = "abcdef" StringUtils.truncate("abcdefg", 7) = "abcdefg" StringUtils.truncate("abcdefg", 8) = "abcdefg" StringUtils.truncate("abcdefg", -1) = throws an IllegalArgumentException truncate(String str, int offset, int maxWidth)截断字符串，具有以下特点： 如果 str 字符串的长度小于 maxWidth，则直接返回 str。 不满足第一条时，则为substring(str, offset, maxWidth)。 如果 maxWidth 或者 offset 小于 0，则抛出 IllegalArgumentException。 在任何情况下都不会返回长度大于 maxWidth 的字符串。 代码示例： 123456789101112131415161718192021222324252627282930StringUtils.truncate(null, 0, 0) = null StringUtils.truncate(null, 2, 4) = null StringUtils.truncate("", 0, 10) = "" StringUtils.truncate("", 2, 10) = "" StringUtils.truncate("abcdefghij", 0, 3) = "abc" StringUtils.truncate("abcdefghij", 5, 6) = "fghij" StringUtils.truncate("raspberry peach", 10, 15) = "peach" StringUtils.truncate("abcdefghijklmno", 0, 10) = "abcdefghij" StringUtils.truncate("abcdefghijklmno", -1, 10) = throws an IllegalArgumentException StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, 10) = "abcdefghij" StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, Integer.MAX_VALUE) = "abcdefghijklmno" StringUtils.truncate("abcdefghijklmno", 0, Integer.MAX_VALUE) = "abcdefghijklmno" StringUtils.truncate("abcdefghijklmno", 1, 10) = "bcdefghijk" StringUtils.truncate("abcdefghijklmno", 2, 10) = "cdefghijkl" StringUtils.truncate("abcdefghijklmno", 3, 10) = "defghijklm" StringUtils.truncate("abcdefghijklmno", 4, 10) = "efghijklmn" StringUtils.truncate("abcdefghijklmno", 5, 10) = "fghijklmno" StringUtils.truncate("abcdefghijklmno", 5, 5) = "fghij" StringUtils.truncate("abcdefghijklmno", 5, 3) = "fgh" StringUtils.truncate("abcdefghijklmno", 10, 3) = "klm" StringUtils.truncate("abcdefghijklmno", 10, Integer.MAX_VALUE) = "klmno" StringUtils.truncate("abcdefghijklmno", 13, 1) = "n" StringUtils.truncate("abcdefghijklmno", 13, Integer.MAX_VALUE) = "no" StringUtils.truncate("abcdefghijklmno", 14, 1) = "o" StringUtils.truncate("abcdefghijklmno", 14, Integer.MAX_VALUE) = "o" StringUtils.truncate("abcdefghijklmno", 15, 1) = "" StringUtils.truncate("abcdefghijklmno", 15, Integer.MAX_VALUE) = "" StringUtils.truncate("abcdefghijklmno", Integer.MAX_VALUE, Integer.MAX_VALUE) = "" StringUtils.truncate("abcdefghij", 3, -1) = throws an IllegalArgumentException StringUtils.truncate("abcdefghij", -2, 4) = throws an IllegalArgumentException left(String str, int len)得到一个字符串最左边的 len 个字符 123StringUtils.left("abc", 0) = "" StringUtils.left("abc", 2) = "ab" StringUtils.left("abc", 4) = "abc" right(String str, int len)同left(String str, int len)相反，从右边截取 len 个字符。 mid(String str, int pos, int len)得到一个字符串中间的 len 个字符。 12345StringUtils.mid("abc", 0, 2) = "ab" StringUtils.mid("abc", 0, 4) = "abc" StringUtils.mid("abc", 2, 4) = "c" StringUtils.mid("abc", 4, 2) = "" StringUtils.mid("abc", -2, 2) = "ab" substringBefore(String str, String separator)得到一个字符串第一个分隔符字符串之前的字符串。 123456StringUtils.substringBefore("abc", "a") = "" StringUtils.substringBefore("abcba", "b") = "a" StringUtils.substringBefore("abc", "c") = "ab" StringUtils.substringBefore("abc", "d") = "abc" StringUtils.substringBefore("abc", "") = "" StringUtils.substringBefore("abc", null) = "abc" substringAfter(String str, String separator)同substringBefore(String str, String separator)相反。得到一个字符串第一个分隔符字符串之后的字符串。 substringBetween(String str, String open, String close)得到一个字符串两个字符串之间字符串。 123456StringUtils.substringBetween("", "", "") = "" StringUtils.substringBetween("", "", "]") = null StringUtils.substringBetween("", "[", "]") = null StringUtils.substringBetween("yabcz", "", "") = "" StringUtils.substringBetween("yabcz", "y", "z") = "abc" StringUtils.substringBetween("yabczyabcz", "y", "z") = "abc" substringBetween(String str, String tag)是substringBetween(String str, String open, String close)的特殊情形。得到一个字符串中同一个字符串之间的字符串。 比较字符串equals(CharSequence cs1, CharSequence cs2)判断两字符串相等，代码示例： 12345StringUtils.equals(null, null) = true StringUtils.equals(null, "abc") = false StringUtils.equals("abc", null) = false StringUtils.equals("abc", "abc") = true StringUtils.equals("abc", "ABC") = false equalsIgnoreCase(CharSequence str1, CharSequence str2)判断两字符串相等，忽略大小写，代码示例： 12345StringUtils.equalsIgnoreCase(null, null) = true StringUtils.equalsIgnoreCase(null, "abc") = false StringUtils.equalsIgnoreCase("abc", null) = false StringUtils.equalsIgnoreCase("abc", "abc") = true StringUtils.equalsIgnoreCase("abc", "ABC") = true equalsAny(CharSequence string, CharSequence… searchStrings)比较一个字符串是否与其后的某个字符串相等，代码示例： 123456StringUtils.equalsAny(null, (CharSequence[]) null) = false StringUtils.equalsAny(null, null, null) = true StringUtils.equalsAny(null, "abc", "def") = false StringUtils.equalsAny("abc", null, "def") = false StringUtils.equalsAny("abc", "abc", "def") = true StringUtils.equalsAny("abc", "ABC", "DEF") = false equalsAnyIgnoreCase(CharSequence string, CharSequence…searchStrings)比较一个字符串是否与其后的某个字符串相等，忽略大小写，代码示例： 123456StringUtils.equalsAnyIgnoreCase(null, (CharSequence[]) null) = false StringUtils.equalsAnyIgnoreCase(null, null, null) = true StringUtils.equalsAnyIgnoreCase(null, "abc", "def") = false StringUtils.equalsAnyIgnoreCase("abc", null, "def") = false StringUtils.equalsAnyIgnoreCase("abc", "abc", "def") = true StringUtils.equalsAnyIgnoreCase("abc", "ABC", "DEF") = true compare(String str1, String str2)比较两字符串的大小，代码示例： 12345678StringUtils.compare(null, null) = 0 StringUtils.compare(null , "a") &lt; 0 StringUtils.compare("a", null) &gt; 0 StringUtils.compare("abc", "abc") = 0 StringUtils.compare("a", "b") &lt; 0 StringUtils.compare("b", "a") &gt; 0 StringUtils.compare("a", "B") &gt; 0 StringUtils.compare("ab", "abc") &lt; 0 compareIgnoreCase(String str1, String str2)比较两字符串的大小，忽略大小写，代码示例： 12345678910StringUtils.compareIgnoreCase(null, null) = 0 StringUtils.compareIgnoreCase(null , "a") &lt; 0 StringUtils.compareIgnoreCase("a", null) &gt; 0 StringUtils.compareIgnoreCase("abc", "abc") = 0 StringUtils.compareIgnoreCase("abc", "ABC") = 0 StringUtils.compareIgnoreCase("a", "b") &lt; 0 StringUtils.compareIgnoreCase("b", "a") &gt; 0 StringUtils.compareIgnoreCase("a", "B") &lt; 0 StringUtils.compareIgnoreCase("A", "b") &lt; 0 StringUtils.compareIgnoreCase("ab", "ABC") &lt; 0 查找元素indexOf(CharSequence seq, int searchChar)查找某个字符在字符串中第一次出现时的索引位置，代码示例： 12StringUtils.indexOf("aabaabaa", 'a') = 0 StringUtils.indexOf("aabaabaa", 'b') = 2 indexOf(CharSequence seq, CharSequence searchSeq)同indexOf(CharSequence seq, int searchChar)相似。 12345StringUtils.indexOf("aabaabaa", "c") = -1 StringUtils.indexOf("aabaabaa", "a") = 0 StringUtils.indexOf("aabaabaa", "b") = 2 StringUtils.indexOf("aabaabaa", "ab") = 1 StringUtils.indexOf("aabaabaa", "") = 0 indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos)同indexOf(CharSequence seq, int searchChar)相似。 12345678StringUtils.indexOf("aabaabaa", "a", 0) = 0 StringUtils.indexOf("aabaabaa", "b", 0) = 2 StringUtils.indexOf("aabaabaa", "ab", 0) = 1 StringUtils.indexOf("aabaabaa", "b", 3) = 5 StringUtils.indexOf("aabaabaa", "b", 9) = -1 StringUtils.indexOf("aabaabaa", "b", -1) = 2 StringUtils.indexOf("aabaabaa", "", 2) = 2 StringUtils.indexOf("abc", "", 9) = 3 indexOfIgnoreCase(CharSequence str, CharSequence searchStr)同indexOf(CharSequence seq, int searchChar)相似, 忽略大小写。 lastIndexOf(CharSequence seq, int searchChar)同indexOf(CharSequence seq, int searchChar)相似，从后面开始查找。 contains(CharSequence seq, CharSequence searchSeq)判断某字符串是否包含某子字符串。 1234StringUtils.contains("", "") = true StringUtils.contains("abc", "") = true StringUtils.contains("abc", "a") = true StringUtils.contains("abc", "z") = false containsIgnoreCase(CharSequence str, CharSequence searchStr)同contains(CharSequence seq, CharSequence searchSeq)相似，忽略大小写。 containsWhitespace(final CharSequence seq)是contains(CharSequence seq, CharSequence searchSeq)的特殊情形，判断是否包含空白字符。 containsAny(CharSequence cs, CharSequence… searchCharSequences)判断某字符串是否包含其后的任意一个字符串。 123StringUtils.containsAny("abcd", "ab", null) = true StringUtils.containsAny("abcd", "ab", "cd") = true StringUtils.containsAny("abc", "d", "abc") = true containsNone(CharSequence cs, String invalidChars)判断某字符串是否不含其后字符串的任意一个字符。 1234StringUtils.containsNone("ab", "") = true StringUtils.containsNone("abab", "xyz") = true StringUtils.containsNone("ab1", "xyz") = true StringUtils.containsNone("abz", "xyz") = false 分割字符串split(String str, String separatorChars)将某字符串按字符分割成数组，默认按空格分组。 1234StringUtils.split("abc def", null) = ["abc", "def"] StringUtils.split("abc def", " ") = ["abc", "def"] StringUtils.split("abc def", " ") = ["abc", "def"] StringUtils.split("ab:cd:ef", ":") = ["ab", "cd", "ef"] split(String str, String separatorChars, int max)将某字符串按字符分割成最大 max 长度的数组，默认按空格分组。 1234StringUtils.split("ab cd ef", null, 0) = ["ab", "cd", "ef"] StringUtils.split("ab cd ef", null, 0) = ["ab", "cd", "ef"] StringUtils.split("ab:cd:ef", ":", 0) = ["ab", "cd", "ef"] StringUtils.split("ab:cd:ef", ":", 2) = ["ab", "cd:ef"] splitByCharacterType(final String str)按字符串类型划分字符串为数组。 123456789StringUtils.splitByCharacterType(null) = null StringUtils.splitByCharacterType("") = [] StringUtils.splitByCharacterType("ab de fg") = ["ab", " ", "de", " ", "fg"] StringUtils.splitByCharacterType("ab de fg") = ["ab", " ", "de", " ", "fg"] StringUtils.splitByCharacterType("ab:cd:ef") = ["ab", ":", "cd", ":", "ef"] StringUtils.splitByCharacterType("number5") = ["number", "5"] StringUtils.splitByCharacterType("fooBar") = ["foo", "B", "ar"] StringUtils.splitByCharacterType("foo200Bar") = ["foo", "200", "B", "ar"] StringUtils.splitByCharacterType("ASFRules") = ["ASFR", "ules"] 连接字符串join(T… elements)无连接符连接字符串。 12345StringUtils.join(null) = null StringUtils.join([]) = "" StringUtils.join([null]) = "" StringUtils.join(["a", "b", "c"]) = "abc" StringUtils.join([null, "", "a"]) = "a" join(Object[] array, String separator)将提供的数组按连接符连成字符串。 123456StringUtils.join(null, *) = null StringUtils.join([], *) = "" StringUtils.join([null], *) = "" StringUtils.join(["a", "b", "c"], ';') = "a;b;c" StringUtils.join(["a", "b", "c"], null) = "abc" StringUtils.join([null, "", "a"], ';') = ";;a" 删除字符串deleteWhitespace(String str)删除空白字符。 1234StringUtils.deleteWhitespace(null) = null StringUtils.deleteWhitespace("") = "" StringUtils.deleteWhitespace("abc") = "abc" StringUtils.deleteWhitespace(" ab c ") = "abc" removeStart(String str, String remove)删除指定字符串前缀的字符串。 1234StringUtils.removeStart("www.domain.com", "www.") = "domain.com" StringUtils.removeStart("domain.com", "www.") = "domain.com" StringUtils.removeStart("www.domain.com", "domain") = "www.domain.com" StringUtils.removeStart("abc", "") = "abc" removeStartIgnoreCase(String str, String remove)同removeStart(String str, String remove)相似，忽略大小写。 removeEnd(String str, String remove)同removeStart(String str, String remove)相反。 removeEndIgnoreCase(String str, String remove)同removeEnd(String str, String remove)相似，忽略大小写。 remove(String str, String remove)移除字符串中指定的字符串。 12StringUtils.remove("queued", "ue") = "qd" StringUtils.remove("queued", "zz") = "queued" removeIgnoreCase(String str, String remove)同remove(String str, String remove)相似，忽略大小写。 替换字符串replace(String text, String searchString, String replacement)替换某字符串为另一个字符串。 123StringUtils.replace("aba", "a", null) = "aba" StringUtils.replace("aba", "a", "") = "b" StringUtils.replace("aba", "a", "z") = "zbz" replaceIgnoreCase(String text, String searchString, String replacement)同replace(String text, String searchString, String replacement)相似，忽略大小写。 replace(String text, String searchString, String replacement, int max)替换某字符串为另一个字符串, 从左到右替换最大 max 次。 123456StringUtils.replace("abaa", "a", null, -1) = "abaa" StringUtils.replace("abaa", "a", "", -1) = "b" StringUtils.replace("abaa", "a", "z", 0) = "abaa" StringUtils.replace("abaa", "a", "z", 1) = "zbaa" StringUtils.replace("abaa", "a", "z", 2) = "zbza" StringUtils.replace("abaa", "a", "z", -1) = "zbzz" replaceEach(String text, String[] searchList, String[] replacementList)替换某些字符串为另一些字符串。 12345678StringUtils.replaceEach("aba", null, null) = "aba" StringUtils.replaceEach("aba", new String[0], null) = "aba" StringUtils.replaceEach("aba", null, new String[0]) = "aba" StringUtils.replaceEach("aba", new String[]&#123;"a"&#125;, null) = "aba" StringUtils.replaceEach("aba", new String[]&#123;"a"&#125;, new String[]&#123;""&#125;) = "b" StringUtils.replaceEach("aba", new String[]&#123;null&#125;, new String[]&#123;"a"&#125;) = "aba" StringUtils.replaceEach("abcde", new String[]&#123;"ab", "d"&#125;, new String[]&#123;"w", "t"&#125;) = "wcte" StringUtils.replaceEach("abcde", new String[]&#123;"ab", "d"&#125;, new String[]&#123;"d", "t"&#125;) = "dcte" 填充字符串repeat(final String str, final int repeat)生成重复的字符串，repeat 代表生成次数。 123456StringUtils.repeat(null, 2) = null StringUtils.repeat("", 0) = "" StringUtils.repeat("", 2) = "" StringUtils.repeat("a", 3) = "aaa" StringUtils.repeat("ab", 2) = "abab" StringUtils.repeat("a", -2) = "" repeat(String str, String separator, int repeat)生成重复的字符串，repeat 代表生成次数。 123456StringUtils.repeat(null, null, 2) = null StringUtils.repeat(null, "x", 2) = null StringUtils.repeat("", null, 0) = "" StringUtils.repeat("", "", 2) = "" StringUtils.repeat("", "x", 3) = "xxx" StringUtils.repeat("?", ", ", 3) = "?, ?, ?" 字符串计数countMatches(CharSequence str, CharSequence sub)计算某字符串在字符串中的出现次数。 12345StringUtils.countMatches("abba", null) = 0 StringUtils.countMatches("abba", "") = 0 StringUtils.countMatches("abba", "a") = 2 StringUtils.countMatches("abba", "ab") = 1 StringUtils.countMatches("abba", "xxx") = 0 字符测试isAlpha(CharSequence cs)判断字符串是否是 Unicode 字母。 123456StringUtils.isAlpha(null) = false StringUtils.isAlpha("") = false StringUtils.isAlpha(" ") = false StringUtils.isAlpha("abc") = true StringUtils.isAlpha("ab2c") = false StringUtils.isAlpha("ab-c") = false isAlphaSpace(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是 Unicode 字母或空格。 1234567StringUtils.isAlphaSpace(null) = false StringUtils.isAlphaSpace("") = true StringUtils.isAlphaSpace(" ") = true StringUtils.isAlphaSpace("abc") = true StringUtils.isAlphaSpace("ab c") = true StringUtils.isAlphaSpace("ab2c") = false StringUtils.isAlphaSpace("ab-c") = false isAlphanumeric(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是 Unicode 字母或数字。 isAlphanumericSpace(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是 Unicode 字母、空格或数字。 isNumeric(CharSequence cs)判断字符串是否是数字。 1234567StringUtils.isNumeric("123") = true StringUtils.isNumeric("12 3") = false StringUtils.isNumeric("ab2c") = false StringUtils.isNumeric("12-3") = false StringUtils.isNumeric("12.3") = false StringUtils.isNumeric("-123") = false StringUtils.isNumeric("+123") = false isNumericSpace(CharSequence cs)同isNumeric(CharSequence cs)相似。判断字符串是否是空格或数字。 getDigits(String str)从字符串中提取出数字为字符串。 123456StringUtils.getDigits(null) = null StringUtils.getDigits("") = "" StringUtils.getDigits("abc") = "" StringUtils.getDigits("1000$") = "1000" StringUtils.getDigits("1123~45") = "12345" StringUtils.getDigits("(541) 754-3010") = "5417543010" isWhitespace(CharSequence cs)判断是否是空格。 123456StringUtils.isWhitespace(null) = false StringUtils.isWhitespace("") = true StringUtils.isWhitespace(" ") = true StringUtils.isWhitespace("abc") = false StringUtils.isWhitespace("ab2c") = false StringUtils.isWhitespace("ab-c") = false isAllLowerCase(CharSequence cs)判断字符串是否都是小写。 12345678StringUtils.isAllLowerCase(null) = false StringUtils.isAllLowerCase("") = false StringUtils.isAllLowerCase(" ") = false StringUtils.isAllLowerCase("abc") = true StringUtils.isAllLowerCase("abC") = false StringUtils.isAllLowerCase("ab c") = false StringUtils.isAllLowerCase("ab1c") = false StringUtils.isAllLowerCase("ab/c") = false isAllUpperCase(CharSequence cs)同isAllLowerCase相反。判断字符串是否都是大写。 isMixedCase(CharSequence cs)同isAllLowerCase相似。判断字符串是否大小写都有。 默认字符串defaultString(String str)得到默认字符串，默认空字符串。 123StringUtils.defaultString(null) = "" StringUtils.defaultString("") = "" StringUtils.defaultString("bat") = "bat" defaultString(String str, String defaultStr)如果是 null，则得到默认字符串。 123StringUtils.defaultString(null, &quot;NULL&quot;) = &quot;NULL&quot; StringUtils.defaultString(&quot;&quot;, &quot;NULL&quot;) = &quot;&quot; StringUtils.defaultString(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot; defaultIfEmpty(T str, T defaultStr)同defaultString(String str, String defaultStr)相似。如果是空字符串，则得到默认字符串。 反转字符串reverse(final String str)反转字符串。 123StringUtils.reverse(null) = null StringUtils.reverse("") = "" StringUtils.reverse("bat") = "tab" 缩写字符串abbreviate(String str, int maxWidth)缩写字符串为最大 maxWidth 长度的字符串，使用...作为缩写的后缀，maxWidth 不能小于等于 3。 123456StringUtils.abbreviate("", 4) = "" StringUtils.abbreviate("abcdefg", 6) = "abc..." StringUtils.abbreviate("abcdefg", 7) = "abcdefg" StringUtils.abbreviate("abcdefg", 8) = "abcdefg" StringUtils.abbreviate("abcdefg", 4) = "a..." StringUtils.abbreviate("abcdefg", 3) = IllegalArgumentException abbreviate(String str, String abbrevMarker, int maxWidth)缩写字符串为最大 maxWidth 长度的字符串，使用abbrevMarker作为缩写的后缀，maxWidth 不能小于等于abbrevMarker的长度。 12345678StringUtils.abbreviate("", "...", 4) = "" StringUtils.abbreviate("abcdefg", ".", 5) = "abcd." StringUtils.abbreviate("abcdefg", ".", 7) = "abcdefg" StringUtils.abbreviate("abcdefg", ".", 8) = "abcdefg" StringUtils.abbreviate("abcdefg", "..", 4) = "ab.." StringUtils.abbreviate("abcdefg", "..", 3) = "a.." StringUtils.abbreviate("abcdefg", "..", 2) = IllegalArgumentException StringUtils.abbreviate("abcdefg", "...", 3) = IllegalArgumentException 字符串钱后缀startsWith(CharSequence str, CharSequence prefix)判断某字符串是否包含有指定前缀的字符串。 12345StringUtils.startsWith(null, null) = true StringUtils.startsWith(null, "abc") = false StringUtils.startsWith("abcdef", null) = false StringUtils.startsWith("abcdef", "abc") = true StringUtils.startsWith("ABCDEF", "abc") = false startsWithIgnoreCase(CharSequence str, CharSequence prefix)同startsWith(CharSequence str, CharSequence prefix)相似。忽略大小写。 startsWithAny(CharSequence sequence, CharSequence… searchStrings)判断某字符串是否包含有其后任意一个指定前缀的字符串。 12345678StringUtils.startsWithAny(null, null) = false StringUtils.startsWithAny(null, new String[] &#123;"abc"&#125;) = false StringUtils.startsWithAny("abcxyz", null) = false StringUtils.startsWithAny("abcxyz", new String[] &#123;""&#125;) = true StringUtils.startsWithAny("abcxyz", new String[] &#123;"abc"&#125;) = true StringUtils.startsWithAny("abcxyz", new String[] &#123;null, "xyz", "abc"&#125;) = true StringUtils.startsWithAny("abcxyz", null, "xyz", "ABCX") = false StringUtils.startsWithAny("ABCXYZ", null, "xyz", "abc") = false endsWith(CharSequence str, CharSequence suffix)同startsWith(CharSequence str, CharSequence prefix)相反。 endsWithIgnoreCase(CharSequence str, CharSequence suffix)同startsWithIgnoreCase(CharSequence str, CharSequence prefix)相反。 endsWithAny(CharSequence sequence, CharSequence… searchStrings)同startsWithAny(CharSequence sequence, CharSequence... searchStrings)相反。 日期时间工具类FastDateFormatFastDateFormat是一个快速且线程安全的时间操作类，它完全可以替代SimpleDateFromat。因为是线程安全的，所以你可以把它作为一个类的静态字段使用。构造方法为 protected，不允许直接构造它的对象，可以通过工厂方法获取。FastDateFormat 之所以是线程安全的，是因为这个类是无状态的：内部的成员在构造时就完成了初始化，并在对象存活期，不提供任何 API 供外界修改他们。 getInstance(String pattern)获取指定日期时间格式的FastDateFormat实例。 format(Date date)将日期时间格式化为字符串。 1FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss").format(new Date()); // 2017-06-03 23:32:31 format(long millis)同format(Date date)相似。 format(Calendar calendar)同format(Date date)相似。 DateFormatUtils将时间转化为字符串的工具类。不可实例化对象且线程安全，依赖于FastDateFormat。 预定义的日期格式DateFormatUtils预定义的日期格式有如下几种： 123456public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss"); public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_TIME_ZONE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ssZZ"); public static final FastDateFormat ISO_8601_EXTENDED_DATE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd"); public static final FastDateFormat ISO_8601_EXTENDED_TIME_FORMAT = FastDateFormat.getInstance("HH:mm:ss"); public static final FastDateFormat ISO_8601_EXTENDED_TIME_TIME_ZONE_FORMAT = FastDateFormat.getInstance("HH:mm:ssZZ"); public static final FastDateFormat SMTP_DATETIME_FORMAT = FastDateFormat.getInstance("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US); format(Date date, String pattern)将日期格式化为字符串。 123DateFormatUtils.format(new Date(), "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:03:53 DateFormatUtils.ISO_8601_EXTENDED_DATETIME_FORMAT.format(new Date()); // 2017-06-03T23:09:52 DateFormatUtils.format(System.currentTimeMillis(), "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:16:59 format(long millis, String pattern)同format(Date date, String pattern)相似。 format(Calendar calendar, String pattern)同format(Date date, String pattern)相似。 DateUtilsDateUtils提供了很多很方便的功能，减轻了使用 Date 的复杂性。把原来需用Calendar才能完成的功能统一集中了起来，也就是说没有对应的CalendarUtils类。在 JDK 中，Date 与 Calendar 概念本身就有些混淆，只是为了保持兼容性才引入的 Calendar。相对于 Calendar 提供的方法，DateUtils 提供了更加合理的方法，对时间的单个字段操作变得更加的容易。 常量1234public static final long MILLIS_PER_SECOND = 1000; // 1秒钟的毫秒数 public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; // 1分钟的毫秒数 public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; // 1小时的毫秒数 public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; // 1天的毫秒数 boolean isSameDay(Date date1, Date date2)判断两个日期是否是同一天。 1DateUtils.isSameDay(new Date(), new Date()); // true boolean isSameDay(Calendar cal1, Calendar cal2)同isSameDay(Date date1, Date date2)相似。 Date parseDate(String str, String… parsePatterns)解析日期时间字符串日期时间 Date 对象，通过尝试各种不同的解析器来解析表示日期的字符串。 12DateUtils.parseDate("2017-06-03 23:51:44", "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:51:44 DateUtils.parseDate("2017年06月03日 23时51分44秒", "yyyy-MM-dd HH:mm:ss", "yyyy年MM月dd日 HH时mm分ss秒"); Date addYears(Date date, int amount)得到date日期时间后（前）amount年后的日期时间。 12Date d3 = DateUtils.addYears(new Date(), 3); // 2020-06-04 00:06:21 Date d3 = DateUtils.addYears(new Date(), -2); // 2015-06-04 00:06:21 Date addMonths(Date date, int amount)同addYears(Date date, int amount)相似，对月份数进行加减。 Date addWeeks(Date date, int amount)同addYears(Date date, int amount)相似，对周数进行加减。 Date addDays(Date date, int amount)同addYears(Date date, int amount)相似，对天数进行加减。 Date addHours(Date date, int amount)同addYears(Date date, int amount)相似，对小时数进行加减。 Date addMinutes(Date date, int amount)同addYears(Date date, int amount)相似，对分钟数进行加减。 Date addSeconds(Date date, int amount)同addYears(Date date, int amount)相似，对秒数进行加减。 Date addMilliseconds(Date date, int amount)同addYears(Date date, int amount)相似，对毫秒数进行加减。 Date setYears(Date date, int amount)对给定的日期时间设置年份。 1Date d4 = DateUtils.setYears(new Date(), 2028); // 2028-06-04 00:16:48 Date setMonths(Date date, int amount)同setYears(Date date, int amount)相似，对月数进行设置。 Date setDays(Date date, int amount)同setYears(Date date, int amount)相似，对天数进行设置。 Date setHours(Date date, int amount)同setYears(Date date, int amount)相似，对小时数进行设置。 Date setMinutes(Date date, int amount)同setYears(Date date, int amount)相似，对分钟数进行设置。 Date setSeconds(Date date, int amount)同setYears(Date date, int amount)相似，对秒钟数进行设置。 Date setMilliseconds(Date date, int amount)同setYears(Date date, int amount)相似，对毫秒数进行设置。 toCalendar(Date date)将日期转为Calendar实例。 Date round(Date date, int field)对日期时间进行四舍五入。filed 指定取整的字段，可以取的值为 Calendar.SECOND Calendar.MINUTE Calendar.HOUR_OF_DAY Calendar.DAY_OF_MONTH Calendar.MONTH Calendar.YEAR … 12345678// 当前时间为'2017-06-04 00:44:41'，则执行以下代码DateUtils.round(new Date(), Calendar.YEAR); // 2017-01-01 00:00:00 DateUtils.round(new Date(), Calendar.MONTH); // 2017-06-01 00:00:00 DateUtils.round(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 01:00:00 DateUtils.round(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-04 00:00:00 DateUtils.round(new Date(), Calendar.HOUR); // 2017-06-04 01:00:00 DateUtils.round(new Date(), Calendar.MINUTE); // 2017-06-04 00:45:00 DateUtils.round(new Date(), Calendar.SECOND); // 2017-06-04 00:44:43 Date truncate(Date date, int field)从给定字段开始格式化截取日期。对一个时间对象的某个字段进行截断。 12345678// 当前时间为'2017-06-04 00:56:05'，则执行以下代码DateUtils.truncate(new Date(), Calendar.YEAR); // 2017-01-01 00:00:00 DateUtils.truncate(new Date(), Calendar.MONTH); // 2017-06-01 00:00:00 DateUtils.truncate(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 00:00:00 DateUtils.truncate(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-04 00:00:00 DateUtils.truncate(new Date(), Calendar.HOUR); // 2017-06-04 00:00:00 DateUtils.truncate(new Date(), Calendar.MINUTE); // 2017-06-04 00:56:00 DateUtils.truncate(new Date(), Calendar.SECOND); // 2017-06-04 00:56:05 Date ceiling(Date date, int field)从给定字段开始 “向上” 格式化日期。 12345678// 当前时间为'2017-06-04 01:02:31'，则执行以下代码DateUtils.ceiling(new Date(), Calendar.YEAR); // 2018-01-01 00:00:00 DateUtils.ceiling(new Date(), Calendar.MONTH); // 2017-07-01 00:00:00 DateUtils.ceiling(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 02:00:00 DateUtils.ceiling(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-05 00:00:00 DateUtils.ceiling(new Date(), Calendar.HOUR); // 2017-06-04 02:00:00 DateUtils.ceiling(new Date(), Calendar.MINUTE); // 2017-06-04 01:03:00 DateUtils.ceiling(new Date(), Calendar.SECOND); // 2017-06-04 01:02:32 long getFragmentInDays(Date date, int fragment)返回一个指定时间的天数。关键的是参数fragment，它的作用非常重要。它的值必须是 Calendar 的时间常量字段。 注意：小时必须用 24 小时制的，即Calendar.HOUR_OF_DAY，而不能用Calendar.HOUR字段。 123// 当前时间为'2017-06-04 01:12:31'，则执行以下代码DateUtils.getFragmentInDays(new Date(), Calendar.YEAR); // 155 DateUtils.getFragmentInDays(new Date(), Calendar.MONTH); // 4 long getFragmentInMilliseconds(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInSeconds(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInMinutes(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInHours(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 boolean truncatedEquals(Date date1, Date date2, int field)比较日历对应字段是否相等。 StopWatchStopWatch是一个方便的计时器。 使用示例12345StopWatch stopWatch = new StopWatch(); stopWatch.start(); ...stopWatch.stop(); System.out.println(stopWatch.getTime()); 主要方法： start() 开始计时 stop() 停止计时 reset() 重置计时 suspend() 暂停计时 resume() 继续计时 getTime() 获取消耗的毫秒数 getNanoTime() 获取消耗的纳秒数 getStartTime() 获取开始的毫秒数 isStarted() 是否开始 isSuspended() 是否暂停 isStopped() 是否停止 其它类简介RandomStringUtils: 1234567//随机生成n位数数字RandomStringUtils.randomNumeric(n);//在指定字符串中生成长度为n的随机字符串RandomStringUtils.random(n, "abcdefghijk");//指定从字符或数字中生成随机字符串System.out.println(RandomStringUtils.random(n, true, false)); System.out.println(RandomStringUtils.random(n, false, true)); NumberUtils: 123456//从数组中选出最大值NumberUtils.max(new int[] &#123; 1, 2, 3, 4 &#125;);//---4//判断字符串是否全是整数NumberUtils.isDigits("153.4");//--false//判断字符串是否是有效数字NumberUtils.isNumber("0321.1");//---false 结语 只是简单的介绍了 commons-lang 中的一些常用工具类，还有许多挺实用的就不一一列举。还是要自己去查阅文档试用了才能体会到它的简便。 参考：https://blog.csdn.net/terryzero/article/details/4317320http://www.cnblogs.com/DreamDrive/p/4282323.htmlhttp://blinkfox.com/tag/commons/]]></content>
      <tags>
        <tag>Java</tag>
        <tag>工具类</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[guava入门实战]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25-2%2F</url>
    <content type="text"><![CDATA[实战操作教程：https://www.yiibai.com/guava/参考官方中文文档：http://ifeve.com/google-guava/guava官方项目：https://github.com/google/guava]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式三种实现----饿汉式 饱汉式(懒汉式) 双重锁模式]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25-1%2F</url>
    <content type="text"><![CDATA[在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。Java 中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。” 一、什么时候使用单例模式：当实例存在多个会引起程序逻辑错误的时候 二、好处：1、减少内存的占用 2、单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。 3、因为类控制了实例化过程，所以类可以灵活更改实例化过程 三、单例模式的三种模式：1、饿汉式 1234567891011121314151617181920212223package com.lxk.designPattern.singleton;/** * 饿汉式--就是屌丝，穷，不给准备好，担心饿死。类加载就给准备好 * * Created by lxk on 2017/3/23 */public class SingletonPattern1 &#123; //有的会加final修饰符（更为严谨），添加final修饰符之后，指向的引用不能再做更改。 //这是final的用法：final成员变量表示常量，只能被赋值一次，赋值后值不能再改变。 //这句话得这么理解： //对于一个final变量。 // 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改； // 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 private static final SingletonPattern1 singletonInstance = new SingletonPattern1(); private SingletonPattern1() &#123; &#125; public static SingletonPattern1 getSingletonInstance() &#123; return singletonInstance; &#125;&#125; 2、饱汉式（也叫懒汉式）– 延迟加载 123456789101112131415161718192021222324252627282930313233343536373839package com.lxk.designPattern.singleton;/** * 饱汉式（懒汉式）----就是有钱，豪，用的时候再new（线程不安全） * * Created by lxk on 2017/3/23 */public class SingletonPattern2 &#123; //这个就不能加final，因为要在其他地方给他再次赋值呢。 //加了final，那就默认一直是null啦，而且还不能再次给此属性赋值。 //此属性是静态，那么就是共享数据，多线程并发操作共享数据是有可能的。那么就会出现下面的线程不安全现象。 private static SingletonPattern2 singletonInstance; private SingletonPattern2() &#123; &#125; public static SingletonPattern2 getSingletonInstance() &#123; if (singletonInstance == null) &#123; //在这个地方,多线程的时候， //可能A线程挂起，此属性还是null，那么B线程可能也判断条件OK也进来啦。 //然后A线程可以执行的时候就会new个对象，线程B也会new个对象。 //就不能保证内存的唯一性。也就是线程不安全 singletonInstance = new SingletonPattern2(); &#125; return singletonInstance; &#125; ///** // * 为了应对上述的不安全，可以简单的如下操作给方法添加[synchronized],使之成为同步函数。 // * 但是： // * 在很多线程的情况下，就每个线程访问都得判断锁，效率就是问题。所以，才有后面的[双重锁形式] // */ //public static synchronized SingletonPattern2 getSingletonInstance() &#123; // if (singletonInstance == null) &#123; // singletonInstance = new SingletonPattern2(); // &#125; // return singletonInstance; //&#125;&#125; 3、双重锁形式 这个模式将同步内容下放到 if 内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。避免土豪模式下创建单例，可能存在的线程不安全问题。 123456789101112131415161718192021222324252627282930313233343536package com.lxk.designPattern.singleton;/** * 双重锁形式 * 这个模式将同步内容下放到if内部，提高了执行的效率，不必每次获取对象时都进行同步， * 只有第一次才同步，创建了以后就没必要了。避免土豪模式下创建单例，可能存在的线程不安全问题。 * &lt;p&gt; * Created by lxk on 2017/3/23 */public class SingletonPattern3 &#123; private static SingletonPattern3 singletonInstance; private SingletonPattern3() &#123; &#125; /** * 静态方法同步的时候，使用的锁，就不能是this，而是类.class */ public static SingletonPattern3 getSingletonInstance() &#123; if (singletonInstance == null) &#123; //这个地方可能有多个线程，在这排队，ABCD..。 synchronized (SingletonPattern3.class) &#123; if (singletonInstance == null) &#123; //假设第一次A线程走到这，然后，呈挂起状态。这个时候，单例对象还未创建； // 假设此时，B线程也来了判断单例对象==null成立，但是，因为A线程已经给里层的if判断上锁，所以，B只能在外等着。 //假设A线程被唤醒，那么，单例就会下面语句赋值，单例对象就创建啦。然后释放锁。B就可以进来啦。 //B线程进来之后，先判断单例对象是否为null，发现已经不是null啦，那么就不需要创建啦。 //CD线程同样， //再往后面来的，第一个if就进不来啦，那就不会判断锁了。 singletonInstance = new SingletonPattern3(); &#125; &#125; &#125; return singletonInstance; &#125;&#125; 重点就是：1. 私有 (private) 静态 (static) 的单例对象(object)2. 构造函数 (struct)—– 可在构造方法初始化单例对象3. 提供对外 (public)，静态方法获得单例对象 原文：https://blog.csdn.net/qq_27093465/article/details/50978916]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列五：JUC线程池]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25%2F</url>
    <content type="text"><![CDATA[01 线程池架构概要前面分别介绍了 “Java 多线程基础 “、”JUC 原子类 “和”JUC 锁 “。本章介绍 JUC 的最后一部分的内容——线程池。内容包括：线程池架构图线程池示例 线程池架构图线程池的架构图如下： 1. Executor 它是 “执行者” 接口，它是来执行任务的。准确的说，Executor 提供了 execute() 接口来执行已提交的 Runnable 任务的对象。Executor 存在的目的是提供一种将 “任务提交” 与 “任务如何运行” 分离开来的机制。它只包含一个函数接口： 1void execute(Runnable command) 2. ExecutorService ExecutorService 继承于 Executor。它是 “执行者服务” 接口，它是为 “执行者接口 Executor” 服务而存在的；准确的话，ExecutorService 提供了 “将任务提交给执行者的接口 (submit 方法)”，”让执行者执行任务 (invokeAll, invokeAny 方法)” 的接口等等。 ExecutorService 的函数列表 123456789101112131415161718192021222324// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。boolean awaitTermination(long timeout, TimeUnit unit)// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)// 如果此执行程序已关闭，则返回 true。boolean isShutdown()// 如果关闭后所有任务都已完成，则返回 true。boolean isTerminated()// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。void shutdown()// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。List&lt;Runnable&gt; shutdownNow()// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。Future&lt;?&gt; submit(Runnable task)// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) 3. AbstractExecutorService AbstractExecutorService 是一个抽象类，它实现了 ExecutorService 接口。AbstractExecutorService 存在的目的是为 ExecutorService 中的函数接口提供了默认实现。 AbstractExecutorService 函数列表由于它的函数列表和 ExecutorService 一样，这里就不再重复列举了。 4. ThreadPoolExecutor ThreadPoolExecutor 就是大名鼎鼎的 “线程池”。它继承于 AbstractExecutorService 抽象类。 ThreadPoolExecutor 函数列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)// 用给定的初始参数和默认的线程工厂创建新的 ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)// 用给定的初始参数和默认被拒绝的执行处理程序创建新的 ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)// 用给定的初始参数创建新的 ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)// 基于完成执行给定 Runnable 所调用的方法。protected void afterExecute(Runnable r, Throwable t)// 如果在保持活动时间内没有任务到达，新任务到达时正在替换（如果需要），则设置控制核心线程是超时还是终止的策略。void allowCoreThreadTimeOut(boolean value)// 如果此池允许核心线程超时和终止，如果在 keepAlive 时间内没有任务到达，新任务到达时正在替换（如果需要），则返回 true。boolean allowsCoreThreadTimeOut()// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。boolean awaitTermination(long timeout, TimeUnit unit)// 在执行给定线程中的给定 Runnable 之前调用的方法。protected void beforeExecute(Thread t, Runnable r)// 在将来某个时间执行给定任务。void execute(Runnable command)// 当不再引用此执行程序时，调用 shutdown。protected void finalize()// 返回主动执行任务的近似线程数。int getActiveCount()// 返回已完成执行的近似任务总数。long getCompletedTaskCount()// 返回核心线程数。int getCorePoolSize()// 返回线程保持活动的时间，该时间就是超过核心池大小的线程可以在终止前保持空闲的时间值。long getKeepAliveTime(TimeUnit unit)// 返回曾经同时位于池中的最大线程数。int getLargestPoolSize()// 返回允许的最大线程数。int getMaximumPoolSize()// 返回池中的当前线程数。int getPoolSize()// 返回此执行程序使用的任务队列。BlockingQueue&lt;Runnable&gt; getQueue()// 返回用于未执行任务的当前处理程序。RejectedExecutionHandler getRejectedExecutionHandler()// 返回曾计划执行的近似任务总数。long getTaskCount()// 返回用于创建新线程的线程工厂。ThreadFactory getThreadFactory()// 如果此执行程序已关闭，则返回 true。boolean isShutdown()// 如果关闭后所有任务都已完成，则返回 true。boolean isTerminated()// 如果此执行程序处于在 shutdown 或 shutdownNow 之后正在终止但尚未完全终止的过程中，则返回 true。boolean isTerminating()// 启动所有核心线程，使其处于等待工作的空闲状态。int prestartAllCoreThreads()// 启动核心线程，使其处于等待工作的空闲状态。boolean prestartCoreThread()// 尝试从工作队列移除所有已取消的 Future 任务。void purge()// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。boolean remove(Runnable task)// 设置核心线程数。void setCorePoolSize(int corePoolSize)// 设置线程在终止前可以保持空闲的时间限制。void setKeepAliveTime(long time, TimeUnit unit)// 设置允许的最大线程数。void setMaximumPoolSize(int maximumPoolSize)// 设置用于未执行任务的新处理程序。void setRejectedExecutionHandler(RejectedExecutionHandler handler)// 设置用于创建新线程的线程工厂。void setThreadFactory(ThreadFactory threadFactory)// 按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。void shutdown()// 尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。List&lt;Runnable&gt; shutdownNow()// 当 Executor 已经终止时调用的方法。protected void terminated() 5. ScheduledExecutorService ScheduledExecutorService 是一个接口，它继承于于 ExecutorService。它相当于提供了 “延时” 和 “周期执行” 功能的 ExecutorService。ScheduledExecutorService 提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。 ScheduledExecutorService 函数列表 12345678// 创建并执行在给定延迟后启用的 ScheduledFuture。&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)// 创建并执行在给定延迟后启用的一次性操作。ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) 6. ScheduledThreadPoolExecutor ScheduledThreadPoolExecutor 继承于 ThreadPoolExecutor，并且实现了 ScheduledExecutorService 接口。它相当于提供了 “延时” 和 “周期执行” 功能的 ScheduledExecutorService。ScheduledThreadPoolExecutor 类似于 Timer，但是在高并发程序中，ScheduledThreadPoolExecutor 的性能要优于 Timer。 ScheduledThreadPoolExecutor 函数列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor(int corePoolSize)// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)// 修改或替换用于执行 callable 的任务。protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)// 修改或替换用于执行 runnable 的任务。protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)// 使用所要求的零延迟执行命令。void execute(Runnable command)// 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()// 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()// 返回此执行程序使用的任务队列。BlockingQueue&lt;Runnable&gt; getQueue()// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。boolean remove(Runnable task)// 创建并执行在给定延迟后启用的 ScheduledFuture。&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)// 创建并执行在给定延迟后启用的一次性操作。ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)// 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。void shutdown()// 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。List&lt;Runnable&gt; shutdownNow()// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。Future&lt;?&gt; submit(Runnable task)// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) 7. Executors Executors 是个静态工厂类。它通过静态工厂方法返回 ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。 Executors 函数列表 12345678910111213141516171819202122232425262728293031323334353637383940// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。static Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action)// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。static Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action)// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。static Callable&lt;Object&gt; callable(Runnable task)// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)// 返回用于创建新线程的默认线程工厂。static ThreadFactory defaultThreadFactory()// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。static ExecutorService newCachedThreadPool()// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。static ExecutorService newFixedThreadPool(int nThreads)// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。static ExecutorService newSingleThreadExecutor()// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。static ScheduledExecutorService newSingleThreadScheduledExecutor()// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。static &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable)// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。static &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable)// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。static ThreadFactory privilegedThreadFactory()// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。static ExecutorService unconfigurableExecutorService(ExecutorService executor)// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) 线程池示例下面通过示例来对线程池的使用做简单演示。 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;public class ThreadPoolDemo1 &#123; public static void main(String[] args) &#123; // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread ta = new MyThread(); Thread tb = new MyThread(); Thread tc = new MyThread(); Thread td = new MyThread(); Thread te = new MyThread(); // 将线程放入池中进行执行 pool.execute(ta); pool.execute(tb); pool.execute(tc); pool.execute(td); pool.execute(te); // 关闭线程池 pool.shutdown(); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+ " is running."); &#125;&#125; 运行结果： 12345pool-1-thread-1 is running.pool-1-thread-2 is running.pool-1-thread-1 is running.pool-1-thread-2 is running.pool-1-thread-1 is running. 结果说明：主线程中创建了线程池 pool，线程池的容量是 2。即，线程池中最多能同时运行 2 个线程。紧接着，将 ta,tb,tc,td,te 这 3 个线程添加到线程池中运行。最后，通过 shutdown() 关闭线程池。 02 线程池原理(一)概要在上一章 “Java 多线程系列 –“JUC 线程池”01 之 线程池架构 “ 中，我们了解了线程池的架构。线程池的实现类是 ThreadPoolExecutor 类。本章，我们通过分析 ThreadPoolExecutor 类，来了解线程池的原理。内容包括：ThreadPoolExecutor 简介ThreadPoolExecutor 数据结构线程池调度 ThreadPoolExecutor 简介ThreadPoolExecutor 是线程池类。对于线程池，可以通俗的将它理解为 “存放一定数量线程的一个线程集合。线程池允许若干个线程同时运行，允许同时运行的线程数量就是线程池的容量；当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。” ThreadPoolExecutor 数据结构ThreadPoolExecutor 的数据结构如下图所示： 各个数据在 ThreadPoolExecutor.java 中的定义如下： 123456789101112131415161718192021222324// 阻塞队列。private final BlockingQueue&lt;Runnable&gt; workQueue;// 互斥锁private final ReentrantLock mainLock = new ReentrantLock();// 线程集合。一个Worker对应一个线程。private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();// “终止条件”，与“mainLock”绑定。private final Condition termination = mainLock.newCondition();// 线程池中线程数量曾经达到过的最大值。private int largestPoolSize;// 已完成任务数量private long completedTaskCount;// ThreadFactory对象，用于创建线程。private volatile ThreadFactory threadFactory;// 拒绝策略的处理句柄。private volatile RejectedExecutionHandler handler;// 保持线程存活时间。private volatile long keepAliveTime;private volatile boolean allowCoreThreadTimeOut;// 核心池大小private volatile int corePoolSize;// 最大池大小private volatile int maximumPoolSize; 1. workers workers 是 HashSet 类型，即它是一个 Worker 集合。而一个 Worker 对应一个线程，也就是说线程池通过 workers 包含了 “一个线程集合”。当 Worker 对应的线程池启动时，它会执行线程池中的任务；当执行完一个任务后，它会从线程池的阻塞队列中取出一个阻塞的任务来继续运行。 wokers 的作用是，线程池通过它实现了 “允许多个线程同时运行”。 2. workQueue workQueue 是 BlockingQueue 类型，即它是一个阻塞队列。当线程池中的线程数超过它的容量的时候，线程会进入阻塞队列进行阻塞等待。 通过 workQueue，线程池实现了阻塞功能。 3. mainLock mainLock 是互斥锁，通过 mainLock 实现了对线程池的互斥访问。 4. corePoolSize 和 maximumPoolSize corePoolSize 是 “ 核心池大小 “，maximumPoolSize 是” 最大池大小 “。它们的作用是调整” 线程池中实际运行的线程的数量 “。 例如，当新任务提交给线程池时 (通过 execute 方法)。 – 如果此时，线程池中运行的线程数量 &lt; corePoolSize，则创建新线程来处理请求。 – 如果此时，线程池中运行的线程数量 &gt; corePoolSize，但是却 &lt; maximumPoolSize；则仅当阻塞队列满时才创建新线程。 如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。在大多数情况下，核心池大小和最大池大小的值是在创建线程池设置的；但是，也可以使用 setCorePoolSize(int) 和 setMaximumPoolSize(int) 进行动态更改。 5. poolSize poolSize 是当前线程池的实际大小，即线程池中任务的数量。 6. allowCoreThreadTimeOut 和 keepAliveTime allowCoreThreadTimeOut 表示是否允许 “线程在空闲状态时，仍然能够存活”；而 keepAliveTime 是当线程池处于空闲状态的时候，超过 keepAliveTime 时间之后，空闲的线程会被终止。 7. threadFactory threadFactory 是 ThreadFactory 对象。它是一个线程工厂类，”线程池通过 ThreadFactory 创建线程”。 8. handler handler 是 RejectedExecutionHandler 类型。它是 “线程池拒绝策略” 的句柄，也就是说 “当某任务添加到线程池中，而线程池拒绝该任务时，线程池会通过 handler 进行相应的处理”。 综上所说，线程池通过 workers 来管理 “线程集合”，每个线程在启动后，会执行线程池中的任务；当一个任务执行完后，它会从线程池的阻塞队列中取出任务来继续运行。阻塞队列是管理线程池任务的队列，当添加到线程池中的任务超过线程池的容量时，该任务就会进入阻塞队列进行等待。 线程池调度我们通过下面的图看看下面线程池中任务的调度策略，加深对线程池的理解。 图 - 01: 图 - 02: 说明： 在 “图 - 01” 中，线程池中有 N 个任务。”任务 1”, “任务 2”, “任务 3” 这 3 个任务在执行，而 “任务 3” 到 “任务 N” 在阻塞队列中等待。正在执行的任务，在 workers 集合中，workers 集合包含 3 个 Worker，每一个 Worker 对应一个 Thread 线程，Thread 线程每次处理一个任务。 当 workers 集合中处理完某一个任务之后，会从阻塞队列中取出一个任务来继续执行，如图 - 02 所示。图 - 02 表示 “任务 1” 处理完毕之后，线程池将 “任务 4” 从阻塞队列中取出，放到 workers 中进行处理。 03 线程池原理(二)概要在前面一章 “Java 多线程系列 –“JUC 线程池”02 之 线程池原理 (一)“ 中介绍了线程池的数据结构，本章会通过分析线程池的源码，对线程池进行说明。内容包括：线程池示例参考代码 (基于 JDK1.7.0_40)线程池源码分析 (一) 创建 “线程池” (二) 添加任务到 “线程池” (三) 关闭 “线程池” 线程池示例在分析线程池之前，先看一个简单的线程池示例。 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;public class ThreadPoolDemo1 &#123; public static void main(String[] args) &#123; // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread ta = new MyThread(); Thread tb = new MyThread(); Thread tc = new MyThread(); Thread td = new MyThread(); Thread te = new MyThread(); // 将线程放入池中进行执行 pool.execute(ta); pool.execute(tb); pool.execute(tc); pool.execute(td); pool.execute(te); // 关闭线程池 pool.shutdown(); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+ " is running."); &#125;&#125; 运行结果： 12345pool-1-thread-1 is running.pool-1-thread-2 is running.pool-1-thread-1 is running.pool-1-thread-2 is running.pool-1-thread-1 is running. 示例中，包括了线程池的创建，将任务添加到线程池中，关闭线程池这 3 个主要的步骤。稍后，我们会从这 3 个方面来分析 ThreadPoolExecutor。 参考代码 (基于 JDK1.7.0_40)Executors 完整源码Executors.java完整源码ThreadPoolExecutor 完整源码ThreadPoolExecutor.java完整源码 线程池源码分析(一) 创建 “线程池” 下面以 newFixedThreadPool() 介绍线程池的创建过程。 1. newFixedThreadPool() newFixedThreadPool() 在 Executors.java 中定义，源码如下： 123public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 说明：newFixedThreadPool(int nThreads) 的作用是创建一个线程池，线程池的容量是 nThreads。 newFixedThreadPool() 在调用 ThreadPoolExecutor() 时，会传递一个 LinkedBlockingQueue() 对象，而 LinkedBlockingQueue 是单向链表实现的阻塞队列。在线程池中，就是通过该阻塞队列来实现 “当线程池中任务数量超过允许的任务数量时，部分任务会阻塞等待”。关于 LinkedBlockingQueue 的实现细节，读者可以参考 “Java 多线程系列 –“JUC 集合”08 之 LinkedBlockingQueue“。 2. ThreadPoolExecutor() ThreadPoolExecutor() 在 ThreadPoolExecutor.java 中定义，源码如下： 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 说明：该函数实际上是调用 ThreadPoolExecutor 的另外一个构造函数。该函数的源码如下： 1234567891011121314151617181920212223242526public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 核心池大小 this.corePoolSize = corePoolSize; // 最大池大小 this.maximumPoolSize = maximumPoolSize; // 线程池的等待队列 this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); // 线程工厂对象 this.threadFactory = threadFactory; // 拒绝策略的句柄 this.handler = handler;&#125; 说明：在 ThreadPoolExecutor() 的构造函数中，进行的是初始化工作。corePoolSize, maximumPoolSize, unit, keepAliveTime 和 workQueue 这些变量的值是已知的，它们都是通过 newFixedThreadPool() 传递而来。下面看看 threadFactory 和 handler 对象。 2.1 ThreadFactory 线程池中的 ThreadFactory 是一个线程工厂，线程池创建线程都是通过线程工厂对象 (threadFactory) 来完成的。上面所说的 threadFactory 对象，是通过 Executors.defaultThreadFactory() 返回的。Executors.java 中的 defaultThreadFactory() 源码如下： 123public static ThreadFactory defaultThreadFactory() &#123; return new DefaultThreadFactory();&#125; defaultThreadFactory() 返回 DefaultThreadFactory 对象。Executors.java 中的 DefaultThreadFactory() 源码如下： 123456789101112131415161718192021222324252627282930static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-"; &#125; // 提供创建线程的API。 public Thread newThread(Runnable r) &#123; // 线程对应的任务是Runnable对象r Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); // 设为“非守护线程” if (t.isDaemon()) t.setDaemon(false); // 将优先级设为“Thread.NORM_PRIORITY” if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 说明：ThreadFactory 的作用就是提供创建线程的功能的线程工厂。 它是通过 newThread()提供创建线程功能的，下面简单说说 newThread()。newThread()创建的线程对应的任务是 Runnable 对象，它创建的线程都是 “非守护线程” 而且“线程优先级都是 Thread.NORM_PRIORITY”。 2.2 RejectedExecutionHandler handler 是 ThreadPoolExecutor 中拒绝策略的处理句柄。所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。线程池默认会采用的是 defaultHandler 策略，即 AbortPolicy 策略。在 AbortPolicy 策略中，线程池拒绝任务时会抛出异常！defaultHandler 的定义如下： 1private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); AbortPolicy 的源码如下： 12345678910public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; // 抛出异常 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); &#125;&#125; (二) 添加任务到 “线程池” 1. execute() execute() 定义在 ThreadPoolExecutor.java 中，源码如下： 1234567891011121314151617181920212223242526272829public void execute(Runnable command) &#123; // 如果任务为null，则抛出异常。 if (command == null) throw new NullPointerException(); // 获取ctl对应的int值。该int值保存了"线程池中任务的数量"和"线程池状态"信息 int c = ctl.get(); // 当线程池中的任务数量 &lt; "核心池大小"时，即线程池中少于corePoolSize个任务。 // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 当线程池中的任务数量 &gt;= "核心池大小"时， // 而且，"线程池处于允许状态"时，则尝试将任务添加到阻塞队列中。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；然后通过reject()执行相应的拒绝策略的内容。 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 否则，如果"线程池中任务数量"为0，则通过addWorker(null, false)尝试新建一个线程，新建线程对应的任务为null。 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。 else if (!addWorker(command, false)) reject(command);&#125; 说明：execute() 的作用是将任务添加到线程池中执行。它会分为 3 种情况进行处理： 情况 1 – 如果 “线程池中任务数量” &lt; “核心池大小” 时，即线程池中少于 corePoolSize 个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。 情况 2 – 如果 “线程池中任务数量” &gt;= “核心池大小”，并且 “线程池是允许状态”；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认 “线程池的状态”，如果 “第 2 次读到的线程池状态” 和 “第 1 次读到的线程池状态” 不同，则从阻塞队列中删除该任务。 情况 3 – 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过 reject() 拒绝该任务。 2. addWorker() addWorker() 的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: // 更新"线程池状态和计数"标记，即更新ctl。 for (;;) &#123; // 获取ctl对应的int值。该int值保存了"线程池中任务的数量"和"线程池状态"信息 int c = ctl.get(); // 获取线程池状态。 int rs = runStateOf(c); // 有效性检查 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; // 获取线程池中任务的数量。 int wc = workerCountOf(c); // 如果"线程池中任务的数量"超过限制，则返回false。 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 通过CAS函数将c的值+1。操作失败的话，则退出循环。 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl // 检查"线程池状态"，如果与之前的状态不同，则从retry重新开始。 if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; // 添加任务到线程池，并启动任务所在的线程。 try &#123; final ReentrantLock mainLock = this.mainLock; // 新建Worker，并且指定firstTask为Worker的第一个任务。 w = new Worker(firstTask); // 获取Worker对应的线程。 final Thread t = w.thread; if (t != null) &#123; // 获取锁 mainLock.lock(); try &#123; int c = ctl.get(); int rs = runStateOf(c); // 再次确认"线程池状态" if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 将Worker对象(w)添加到"线程池的Worker集合(workers)"中 workers.add(w); // 更新largestPoolSize int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; // 如果"成功将任务添加到线程池"中，则启动任务所在的线程。 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; // 返回任务是否启动。 return workerStarted;&#125; 说明： addWorker(Runnable firstTask, boolean core) 的作用是将任务 (firstTask) 添加到线程池中，并启动该任务。 core 为 true 的话，则以 corePoolSize 为界限，若 “线程池中已有任务数量 &gt;=corePoolSize”，则返回 false；core 为 false 的话，则以 maximumPoolSize 为界限，若 “线程池中已有任务数量 &gt;=maximumPoolSize”，则返回 false。 addWorker() 会先通过 for 循环不断尝试更新 ctl 状态，ctl 记录了 “线程池中任务数量和线程池状态”。 更新成功之后，再通过 try 模块来将任务添加到线程池中，并启动任务所在的线程。 从 addWorker() 中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的 Worker 对象；而一个 Workder 对象包含一个 Thread 对象。(01) 通过将 Worker 对象添加到 &quot;线程的 workers 集合&quot; 中，从而实现将任务添加到线程池中。 (02) 通过启动 Worker 对应的 Thread 线程，则执行该任务。 3. submit() 补充说明一点，submit() 实际上也是通过调用 execute() 实现的，源码如下： 123456public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125; (三) 关闭 “线程池” shutdown() 的源码如下： 1234567891011121314151617181920public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; // 检查终止线程池的“线程”是否有权限。 checkShutdownAccess(); // 设置线程池的状态为关闭状态。 advanceRunState(SHUTDOWN); // 中断线程池中空闲的线程。 interruptIdleWorkers(); // 钩子函数，在ThreadPoolExecutor中没有任何动作。 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; // 尝试终止线程池 tryTerminate();&#125; 说明：shutdown() 的作用是关闭线程池。 04 线程池原理(三)本章介绍线程池的生命周期。在 “Java 多线程系列 –“基础篇”01 之 基本概念 “ 中，我们介绍过，线程有 5 种状态：新建状态，就绪状态，运行状态，阻塞状态，死亡状态。线程池也有 5 种状态；然而，线程池不同于线程，线程池的 5 种状态是：Running, SHUTDOWN, STOP, TIDYING, TERMINATED。 线程池状态定义代码如下： 12345678910private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 说明：ctl 是一个 AtomicInteger 类型的原子对象。ctl 记录了 “线程池中的任务数量” 和 “线程池状态”2 个信息。ctl 共包括 32 位。其中，高 3 位表示 “线程池状态”，低 29 位表示 “线程池中的任务数量”。 RUNNING – 对应的高3位值是111。SHUTDOWN – 对应的高3位值是000。STOP – 对应的高3位值是001。TIDYING – 对应的高3位值是010。TERMINATED – 对应的高3位值是011。 线程池各个状态之间的切换如下图所示： 1. RUNNING (01) 状态说明：线程池处在 RUNNING 状态时，能够接收新任务，以及对已添加的任务进行处理。(02) 状态切换：线程池的初始化状态是 RUNNING。换句话说，线程池被一旦被创建，就处于 RUNNING 状态！道理很简单，在 ctl 的初始化代码中 (如下)，就将它初始化为 RUNNING 状态，并且 “任务数量” 初始化为 0。 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 2. SHUTDOWN (01) 状态说明：线程池处在 SHUTDOWN 状态时，不接收新任务，但能处理已添加的任务。(02) 状态切换：调用线程池的 shutdown() 接口时，线程池由 RUNNING -&gt; SHUTDOWN。 3. STOP (01) 状态说明：线程池处在 STOP 状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。(02) 状态切换：调用线程池的 shutdownNow() 接口时，线程池由 (RUNNING or SHUTDOWN ) -&gt; STOP。 4. TIDYING TIDYING: adj. 整齐的；整洁的 (01) 状态说明：当所有的任务已终止，ctl 记录的 “任务数量” 为 0，线程池会变为 TIDYING 状态。当线程池变为 TIDYING 状态时，会执行钩子函数 terminated()。terminated() 在 ThreadPoolExecutor 类中是空的，若用户想在线程池变为 TIDYING 时，进行相应的处理；可以通过重载 terminated() 函数来实现。 【钩子方法】：原理就是实现为空的方法，在某任务之前、之后、 执行中、报异常后调用的方法（是不是有种熟悉的感觉）。 通常钩子方法是通过抽象类或是本类中的空方法来实现的。 (02) 状态切换：当线程池在 SHUTDOWN 状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。当线程池在 STOP 状态下，线程池中执行的任务为空时，就会由 STOP -&gt; TIDYING。 5. TERMINATED(01) 状态说明：线程池彻底终止，就变成 TERMINATED 状态。(02) 状态切换：线程池处在 TIDYING 状态时，执行完 terminated() 之后，就会由 TIDYING -&gt; TERMINATED。 05 线程池原理(四)概要本章介绍线程池的拒绝策略。内容包括：拒绝策略介绍拒绝策略对比和示例 拒绝策略介绍线程池的拒绝策略，是指当任务添加到线程池中被拒绝，而采取的处理措施。当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制。 线程池共包括 4 种拒绝策略，它们分别是：AbortPolicy, CallerRunsPolicy, DiscardOldestPolicy 和 DiscardPolicy。 AbortPolicy – 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。CallerRunsPolicy – 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。DiscardOldestPolicy – 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。DiscardPolicy – 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。 线程池默认的处理策略是 AbortPolicy！ 拒绝策略对比和示例下面通过示例，分别演示线程池的 4 种拒绝策略。1. DiscardPolicy 示例2. DiscardOldestPolicy 示例3. AbortPolicy 示例4. CallerRunsPolicy 示例 1. DiscardPolicy 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.ThreadPoolExecutor.DiscardPolicy;public class DiscardPolicyDemo &#123; private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception &#123; // 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为"丢弃" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) &#123; Runnable myrun = new MyRunnable("task-"+i); pool.execute(myrun); &#125; // 关闭线程池 pool.shutdown(); &#125;&#125;class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(this.name + " is running."); Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12task-0 is running.task-1 is running. 结果说明：线程池 pool 的 “最大池大小” 和 “核心池大小” 都为 1(THREADS_SIZE)，这意味着 “线程池能同时运行的任务数量最大只能是 1”。线程池 pool 的阻塞队列是 ArrayBlockingQueue，ArrayBlockingQueue 是一个有界的阻塞队列，ArrayBlockingQueue 的容量为 1。这也意味着线程池的阻塞队列只能有一个线程池阻塞等待。根据 “” 中分析的 execute() 代码可知：线程池中共运行了 2 个任务。第 1 个任务直接放到 Worker 中，通过线程去执行；第 2 个任务放到阻塞队列中等待。其他的任务都被丢弃了！ 2. DiscardOldestPolicy 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy;public class DiscardOldestPolicyDemo &#123; private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception &#123; // 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为"DiscardOldestPolicy" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) &#123; Runnable myrun = new MyRunnable("task-"+i); pool.execute(myrun); &#125; // 关闭线程池 pool.shutdown(); &#125;&#125;class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(this.name + " is running."); Thread.sleep(200); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12task-0 is running.task-9 is running. 结果说明：将 “线程池的拒绝策略” 由 DiscardPolicy 修改为 DiscardOldestPolicy 之后，当有任务添加到线程池被拒绝时，线程池会丢弃阻塞队列中末尾的任务，然后将被拒绝的任务添加到末尾。 3. AbortPolicy 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.lang.reflect.Field;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.ThreadPoolExecutor.AbortPolicy;import java.util.concurrent.RejectedExecutionException;public class AbortPolicyDemo &#123; private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception &#123; // 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为"抛出异常" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); try &#123; // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) &#123; Runnable myrun = new MyRunnable("task-"+i); pool.execute(myrun); &#125; &#125; catch (RejectedExecutionException e) &#123; e.printStackTrace(); // 关闭线程池 pool.shutdown(); &#125; &#125;&#125;class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(this.name + " is running."); Thread.sleep(200); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; (某一次) 运行结果： 1234567java.util.concurrent.RejectedExecutionException at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:1774) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:768) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:656) at AbortPolicyDemo.main(AbortPolicyDemo.java:27)task-0 is running.task-1 is running. 结果说明：将 “线程池的拒绝策略” 由 DiscardPolicy 修改为 AbortPolicy 之后，当有任务添加到线程池被拒绝时，会抛出 RejectedExecutionException。 4. CallerRunsPolicy 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.lang.reflect.Field;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;public class CallerRunsPolicyDemo &#123; private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception &#123; // 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为"CallerRunsPolicy" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) &#123; Runnable myrun = new MyRunnable("task-"+i); pool.execute(myrun); &#125; // 关闭线程池 pool.shutdown(); &#125;&#125;class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(this.name + " is running."); Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; (某一次) 运行结果： 12345678910task-2 is running.task-3 is running.task-4 is running.task-5 is running.task-6 is running.task-7 is running.task-8 is running.task-9 is running.task-0 is running.task-1 is running. 结果说明：将 “线程池的拒绝策略” 由 DiscardPolicy 修改为 CallerRunsPolicy 之后，当有任务添加到线程池被拒绝时，线程池会将被拒绝的任务添加到 “线程池正在运行的线程” 中取运行。 06 Callable和Future概要本章介绍线程池中的 Callable 和 Future。Callable 和 Future 简介示例和源码分析 (基于 JDK1.7.0_40) Callable 和 Future 简介 Callable 和 Future 是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到它们。Callable 用于产生结果，Future 用于获取结果。 1. Callable Callable 是一个接口，它只包含一个 call() 方法。Callable 是一个返回结果并且可能抛出异常的任务。 为了便于理解，我们可以将 Callable 比作一个 Runnable 接口，而 Callable 的 call() 方法则类似于 Runnable 的 run() 方法。 Callable 的源码如下： 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 说明：从中我们可以看出 Callable 支持泛型。 2. Future Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。 Future 的源码如下： 1234567891011121314151617public interface Future&lt;V&gt; &#123; // 试图取消对此任务的执行。 boolean cancel(boolean mayInterruptIfRunning) // 如果在任务正常完成前将其取消，则返回 true。 boolean isCancelled() // 如果任务已完成，则返回 true。 boolean isDone() // 如有必要，等待计算完成，然后获取其结果。 V get() throws InterruptedException, ExecutionException; // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 说明： Future 用于表示异步计算的结果。它的实现类是 FutureTask，在讲解 FutureTask 之前，我们先看看 Callable, Future, FutureTask 它们之间的关系图，如下： 说明：(01) RunnableFuture 是一个接口，它继承了 Runnable 和 Future 这两个接口。RunnableFuture 的源码如下： 123public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; (02) FutureTask 实现了 RunnableFuture 接口。所以，我们也说它实现了 Future 接口。 示例和源码分析 (基于 JDK1.7.0_40)我们先通过一个示例看看 Callable 和 Future 的基本用法，然后再分析示例的实现原理。 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.Callable;import java.util.concurrent.Future;import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;import java.util.concurrent.ExecutionException;class MyCallable implements Callable &#123; @Override public Integer call() throws Exception &#123; int sum = 0; // 执行任务 for (int i=0; i&lt;100; i++) sum += i; //return sum; return Integer.valueOf(sum); &#125; &#125;public class CallableTest1 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException&#123; //创建一个线程池 ExecutorService pool = Executors.newSingleThreadExecutor(); //创建有返回值的任务 Callable c1 = new MyCallable(); //执行任务并获取Future对象 Future f1 = pool.submit(c1); // 输出结果 System.out.println(f1.get()); //关闭线程池 pool.shutdown(); &#125;&#125; 运行结果： 14950 结果说明： 在主线程 main 中，通过 newSingleThreadExecutor() 新建一个线程池。接着创建 Callable 对象 c1，然后再通过 pool.submit(c1) 将 c1 提交到线程池中进行处理，并且将返回的结果保存到 Future 对象 f1 中。然后，我们通过 f1.get() 获取 Callable 中保存的结果；最后通过 pool.shutdown() 关闭线程池。 1. submit() submit() 在 java/util/concurrent/AbstractExecutorService.java 中实现，它的源码如下： 123456789public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); // 创建一个RunnableFuture对象 RunnableFuture&lt;T&gt; ftask = newTaskFor(task); // 执行“任务ftask” execute(ftask); // 返回“ftask” return ftask;&#125; 说明：submit() 通过 newTaskFor(task) 创建了 RunnableFuture 对象 ftask。它的源码如下： 123protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125; 2. FutureTask 的构造函数 FutureTask 的构造函数如下： 12345678public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); // callable是一个Callable对象 this.callable = callable; // state记录FutureTask的状态 this.state = NEW; // ensure visibility of callable&#125; 3. FutureTask 的 run() 方法 我们继续回到 submit() 的源码中。在 newTaskFor() 新建一个 ftask 对象之后，会通过 execute(ftask) 执行该任务。此时 ftask 被当作一个 Runnable 对象进行执行，最终会调用到它的 run() 方法；ftask 的 run() 方法在 java/util/concurrent/FutureTask.java 中实现，源码如下： 1234567891011121314151617181920212223242526272829303132public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; // 将callable对象赋值给c。 Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; // 执行Callable的call()方法，并保存结果到result中。 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; // 如果运行成功，则将result保存 if (ran) set(result); &#125; &#125; finally &#123; runner = null; // 设置“state状态标记” int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 说明：run() 中会执行 Callable 对象的 call() 方法，并且最终将结果保存到 result 中，并通过 set(result) 将 result 保存。 之后调用 FutureTask 的 get() 方法，返回的就是通过 set(result) 保存的值。 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列四：JUC集合]]></title>
    <url>%2F2018%2F03%2F24%2F2018-03-24-2%2F</url>
    <content type="text"><![CDATA[01 框架概要之前，在 “Java 集合系列目录 (Category)“中，讲解了 Java 集合包中的各个类。接下来，将展开对 JUC 包中的集合进行学习。在学习之前，先温习一下”Java 集合包 “。本章内容包括：Java 集合包JUC 中的集合类 Java 集合包在 “Java 集合系列 01 之 总体框架” 中，介绍 java 集合的架构。主体内容包括 Collection 集合和 Map 类；而 Collection 集合又可以划分为 List(队列) 和 Set(集合)。 1. List 的实现类主要有: LinkedList, ArrayList, Vector, Stack。 (01) LinkedList 是双向链表实现的双端队列；它不是线程安全的，只适用于单线程。(02) ArrayList 是数组实现的队列，它是一个动态数组；它也不是线程安全的，只适用于单线程。(03) Vector 是数组实现的矢量队列，它也一个动态数组；不过和 ArrayList 不同的是，Vector 是线程安全的，它支持并发。(04) Stack 是 Vector 实现的栈；和 Vector 一样，它也是线程安全的。 2. Set 的实现类主要有: HastSet 和 TreeSet。 (01) HashSet 是一个没有重复元素的集合，它通过 HashMap 实现的；HashSet 不是线程安全的，只适用于单线程。(02) TreeSet 也是一个没有重复元素的集合，不过和 HashSet 不同的是，TreeSet 中的元素是有序的；它是通过 TreeMap 实现的；TreeSet 也不是线程安全的，只适用于单线程。 3.Map 的实现类主要有: HashMap，WeakHashMap, Hashtable 和 TreeMap。 (01) HashMap 是存储 “键 - 值对” 的哈希表；它不是线程安全的，只适用于单线程。(02) WeakHashMap 是也是哈希表；和 HashMap 不同的是，HashMap 的 “键” 是强引用类型，而 WeakHashMap 的 “键” 是弱引用类型，也就是说当 WeakHashMap 中的某个键不再正常使用时，会被从 WeakHashMap 中被自动移除。WeakHashMap 也不是线程安全的，只适用于单线程。(03) Hashtable 也是哈希表；和 HashMap 不同的是，Hashtable 是线程安全的，支持并发。(04) TreeMap 也是哈希表，不过 TreeMap 中的 “键 - 值对” 是有序的，它是通过 R-B Tree(红黑树)实现的；TreeMap 不是线程安全的，只适用于单线程。更多关于这些集合类的介绍，可以参考 “Java 集合系列目录 (Category)”。 为了方便，我们将前面介绍集合类统称为”java 集合包 “。java 集合包大多是 “非线程安全的”，虽然可以通过 Collections 工具类中的方法获取 java 集合包对应的同步类，但是这些同步类的并发效率并不是很高。为了更好的支持高并发任务，并发大师 Doug Lea 在 JUC(java.util.concurrent) 包中添加了 java 集合包中单线程类的对应的支持高并发的类。例如，ArrayList 对应的高并发类是 CopyOnWriteArrayList，HashMap 对应的高并发类是 ConcurrentHashMap，等等。 JUC 包在添加”java 集合包 “对应的高并发类时，为了保持 API 接口的一致性，使用了”Java 集合包 “中的框架。例如，CopyOnWriteArrayList 实现了 “Java 集合包” 中的 List 接口，HashMap 继承了 “java 集合包” 中的 AbstractMap 类，等等。得益于 “JUC 包使用了 Java 集合包中的类”，如果我们了解了 Java 集合包中的类的思想之后，理解 JUC 包中的类也相对容易；理解时，最大的难点是，对 JUC 包是如何添加对“高并发” 的支持的！ JUC 中的集合类下面，我们先了解 JUC 包中集合类的框架；为了方便讲诉，我将 JUC 包中的集合类划分为 3 部分来进行说明。在简单的了解 JUC 包中集合类的框架之后，后面的章节再逐步对各个类进行介绍。 1. List 和 Set JUC 集合包中的 List 和 Set 实现类包括: CopyOnWriteArrayList, CopyOnWriteArraySet 和 ConcurrentSkipListSet。ConcurrentSkipListSet 稍后在说明 Map 时再说明，CopyOnWriteArrayList 和 CopyOnWriteArraySet 的框架如下图所示： (01) CopyOnWriteArrayList 相当于线程安全的 ArrayList，它实现了 List 接口。CopyOnWriteArrayList 是支持高并发的。(02) CopyOnWriteArraySet 相当于线程安全的 HashSet，它继承于 AbstractSet 类。CopyOnWriteArraySet 内部包含一个 CopyOnWriteArrayList 对象，它是通过 CopyOnWriteArrayList 实现的。 2. Map JUC 集合包中 Map 的实现类包括: ConcurrentHashMap 和 ConcurrentSkipListMap。它们的框架如下图所示： (01) ConcurrentHashMap 是线程安全的哈希表 (相当于线程安全的 HashMap)；它继承于 AbstractMap 类，并且实现 ConcurrentMap 接口。ConcurrentHashMap 是通过“锁分段” 来实现的，它支持并发。(02) ConcurrentSkipListMap 是线程安全的有序的哈希表 (相当于线程安全的 TreeMap); 它继承于 AbstractMap 类，并且实现 ConcurrentNavigableMap 接口。ConcurrentSkipListMap 是通过“跳表” 来实现的，它支持并发。(03) ConcurrentSkipListSet 是线程安全的有序的集合 (相当于线程安全的 TreeSet)；它继承于 AbstractSet，并实现了 NavigableSet 接口。ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，它也支持并发。 3. Queue JUC 集合包中 Queue 的实现类包括: ArrayBlockingQueue, LinkedBlockingQueue, LinkedBlockingDeque, ConcurrentLinkedQueue 和 ConcurrentLinkedDeque。它们的框架如下图所示： (01) ArrayBlockingQueue 是数组实现的线程安全的有界的阻塞队列。(02) LinkedBlockingQueue 是单向链表实现的 (指定大小) 阻塞队列，该队列按 FIFO（先进先出）排序元素。(03) LinkedBlockingDeque 是双向链表实现的 (指定大小) 双向并发阻塞队列，该阻塞队列同时支持 FIFO 和 FILO 两种操作方式。(04) ConcurrentLinkedQueue 是单向链表实现的无界队列，该队列按 FIFO（先进先出）排序元素。(05) ConcurrentLinkedDeque 是双向链表实现的无界队列，该队列同时支持 FIFO 和 FILO 两种操作方式。 接下来，将逐个对 JUC 包中的集合类进行学习。 02 CopyOnWriteArrayList概要本章是 “JUC 系列 “ 的 CopyOnWriteArrayList 篇。接下来，会先对 CopyOnWriteArrayList 进行基本介绍，然后再说明它的原理，接着通过代码去分析，最后通过示例更进一步的了解 CopyOnWriteArrayList。内容包括：CopyOnWriteArrayList 介绍 CopyOnWriteArrayList 原理和数据结构CopyOnWriteArrayList 函数列表CopyOnWriteArrayList 源码分析 (JDK1.7.0_40 版本)CopyOnWriteArrayList 示例 CopyOnWriteArrayList 介绍它相当于线程安全的 ArrayList。和 ArrayList 一样，它是个可变数组；但是和 ArrayList 不同的时，它具有以下特性：1. 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。2. 它是线程安全的。3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。4. 迭代器支持 hasNext(), next() 等不可变操作，但不支持可变 remove() 等操作。5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 建议：在学习 CopyOnWriteArraySet 之前，先通过 “Java 集合系列 03 之 ArrayList 详细介绍 (源码解析) 和使用示例 “ 对 ArrayList 进行了解！ CopyOnWriteArrayList 原理和数据结构CopyOnWriteArrayList 的数据结构，如下图所示： 说明：1. CopyOnWriteArrayList 实现了 List 接口，因此它是一个队列。2. CopyOnWriteArrayList 包含了成员 lock。每一个 CopyOnWriteArrayList 都和一个互斥锁 lock 绑定，通过 lock，实现了对 CopyOnWriteArrayList 的互斥访问。3. CopyOnWriteArrayList 包含了成员 array 数组，这说明 CopyOnWriteArrayList 本质上通过数组实现的。 下面从 “动态数组” 和“线程安全”两个方面进一步对 CopyOnWriteArrayList 的原理进行说明。 CopyOnWriteArrayList 的 “动态数组” 机制 – 它内部有个 “volatile 数组”(array) 来保持数据。在 “添加 / 修改 / 删除” 数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给 “volatile 数组”。这就是它叫做 CopyOnWriteArrayList 的原因！CopyOnWriteArrayList 就是通过这种方式实现的动态数组；不过正由于它在“添加 / 修改 / 删除” 数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，效率比较高。 CopyOnWriteArrayList 的 “线程安全” 机制 – 是通过 volatile 和互斥锁来实现的。(01) CopyOnWriteArrayList 是通过 “volatile 数组” 来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了 “读取到的数据总是最新的” 这个机制的保证。(02) CopyOnWriteArrayList 通过互斥锁来保护数据。在 “添加 / 修改 / 删除” 数据时，会先 “获取互斥锁”，再修改完毕之后，先将数据更新到“volatile 数组” 中，然后再“释放互斥锁”；这样，就达到了保护数据的目的。 CopyOnWriteArrayList 函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 创建一个空列表。CopyOnWriteArrayList()// 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。CopyOnWriteArrayList(Collection&lt;? extends E&gt; c)// CopyOnWriteArrayList(E[] toCopyIn)创建一个保存给定数组的副本的列表。// 将指定元素添加到此列表的尾部。boolean add(E e)// 在此列表的指定位置上插入指定元素。void add(int index, E element)// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。boolean addAll(Collection&lt;? extends E&gt; c)// 从指定位置开始，将指定 collection 的所有元素插入此列表。boolean addAll(int index, Collection&lt;? extends E&gt; c)// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。int addAllAbsent(Collection&lt;? extends E&gt; c)// 添加元素（如果不存在）。boolean addIfAbsent(E e)// 从此列表移除所有元素。void clear()// 返回此列表的浅表副本。Object clone()// 如果此列表包含指定的元素，则返回 true。boolean contains(Object o)// 如果此列表包含指定 collection 的所有元素，则返回 true。boolean containsAll(Collection&lt;?&gt; c)// 比较指定对象与此列表的相等性。boolean equals(Object o)// 返回列表中指定位置的元素。E get(int index)// 返回此列表的哈希码值。int hashCode()// 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。int indexOf(E e, int index)// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。int indexOf(Object o)// 如果此列表不包含任何元素，则返回 true。boolean isEmpty()// 返回以恰当顺序在此列表元素上进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。int lastIndexOf(E e, int index)// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。int lastIndexOf(Object o)// 返回此列表元素的列表迭代器（按适当顺序）。ListIterator&lt;E&gt; listIterator()// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。ListIterator&lt;E&gt; listIterator(int index)// 移除此列表指定位置上的元素。E remove(int index)// 从此列表移除第一次出现的指定元素（如果存在）。boolean remove(Object o)// 从此列表移除所有包含在指定 collection 中的元素。boolean removeAll(Collection&lt;?&gt; c)// 只保留此列表中包含在指定 collection 中的元素。boolean retainAll(Collection&lt;?&gt; c)// 用指定的元素替代此列表指定位置上的元素。E set(int index, E element)// 返回此列表中的元素数。int size()// 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。List&lt;E&gt; subList(int fromIndex, int toIndex)// 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。Object[] toArray()// 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a)// 返回此列表的字符串表示形式。String toString() CopyOnWriteArrayList 源码分析 (JDK1.7.0_40 版本)JDK1.7.0_40 版本中 CopyOnWriteArrayList.java 的完整源码如下： CopyOnWriteArrayList.java 的完整源码 下面我们从 “创建，添加，删除，获取，遍历” 这 5 个方面去分析 CopyOnWriteArrayList 的原理。 1. 创建 CopyOnWriteArrayList 共 3 个构造函数。它们的源码如下： 1234567891011121314public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements = c.toArray(); if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); setArray(elements);&#125;public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));&#125; 说明：这 3 个构造函数都调用了 setArray()，setArray() 的源码如下： 123456789private volatile transient Object[] array;final Object[] getArray() &#123; return array;&#125;final void setArray(Object[] a) &#123; array = a;&#125; 说明：setArray() 的作用是给 array 赋值；其中，array 是 volatile transient Object[] 类型，即 array 是 “volatile 数组”。关于 volatile 关键字，我们知道 “volatile 能让变量变得可见”，即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。正在由于这种特性，每次更新了“volatile 数组” 之后，其它线程都能看到对它所做的更新。关于 transient 关键字，它是在序列化中才起作用，transient 变量不会被自动序列化。transient 不是本文关注的重点，了解即可。关于 transient 的更多内容，请参考：http://www.cnblogs.com/skywang12345/p/io_06.html 2. 添加 以 add(E e)为例，来对 “CopyOnWriteArrayList 的添加操作” 进行说明。下面是 add(E e)的代码： 123456789101112131415161718192021public boolean add(E e) &#123; final ReentrantLock lock = this.lock; // 获取“锁” lock.lock(); try &#123; // 获取原始”volatile数组“中的数据和数据长度。 Object[] elements = getArray(); int len = elements.length; // 新建一个数组newElements，并将原始数据拷贝到newElements中； // newElements数组的长度=“原始数组的长度”+1 Object[] newElements = Arrays.copyOf(elements, len + 1); // 将“新增加的元素”保存到newElements中。 newElements[len] = e; // 将newElements赋值给”volatile数组“。 setArray(newElements); return true; &#125; finally &#123; // 释放“锁” lock.unlock(); &#125;&#125; 说明：add(E e) 的作用就是将数据 e 添加到”volatile 数组 “中。它的实现方式是，新建一个数组，接着将原始的”volatile 数组 “的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile 数组 “。在 add(E e) 中有两点需要关注。 第一，在” 添加操作 “开始前，获取独占锁 (lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁 (lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock 的定义如下： transient final ReentrantLock lock = new ReentrantLock(); 关于 ReentrantLock 的更多内容，可以参考：Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock 第二，操作完毕时，会通过 setArray()来更新”volatile 数组 “。而且，前面我们提过” 即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入“；这样，每次添加元素之后，其它线程都能看到新添加的元素。 3. 获取 以 get(int index)为例，来对 “CopyOnWriteArrayList 的删除操作” 进行说明。下面是 get(int index)的代码： 1234567public E get(int index) &#123; return get(getArray(), index);&#125;private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 说明：get(int index) 的实现很简单，就是返回”volatile 数组 “中的第 index 个元素。 4. 删除 以 remove(int index)为例，来对 “CopyOnWriteArrayList 的删除操作” 进行说明。下面是 remove(int index)的代码： 12345678910111213141516171819202122232425262728public E remove(int index) &#123; final ReentrantLock lock = this.lock; // 获取“锁” lock.lock(); try &#123; // 获取原始”volatile数组“中的数据和数据长度。 Object[] elements = getArray(); int len = elements.length; // 获取elements数组中的第index个数据。 E oldValue = get(elements, index); int numMoved = len - index - 1; // 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。 // 否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组“。 if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; // 释放“锁” lock.unlock(); &#125;&#125; 说明：remove(int index)的作用就是将”volatile 数组 “中第 index 个元素删除。它的实现方式是，如果被删除的是最后一个元素，则直接通过 Arrays.copyOf() 进行处理，而不需要新建数组。否则，新建数组，然后将”volatile 数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile 数组“。 和 add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是 “；并且” 在操作完成时，会通过将数据更新到 volatile 数组中“。 5. 遍历 以 iterator()为例，来对 “CopyOnWriteArrayList 的遍历操作” 进行说明。下面是 iterator()的代码： 123public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125; 说明：iterator() 会返回 COWIterator 对象。 COWIterator 实现额 ListIterator 接口，它的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot; private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; // 获取下一个元素 @SuppressWarnings("unchecked") public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; // 获取上一个元素 @SuppressWarnings("unchecked") public E previous() &#123; if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor-1; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; public void add(E e) &#123; throw new UnsupportedOperationException(); &#125;&#125; 说明：COWIterator 不支持修改元素的操作。例如，对于 remove(),set(),add() 等操作，COWIterator 都会抛出异常！另外，需要提到的一点是，CopyOnWriteArrayList 返回迭代器不会抛出 ConcurrentModificationException 异常，即它不是 fail-fast 机制的！关于 fail-fast 机制，可以参考 “Java 集合系列 04 之 fail-fast 总结 (通过 ArrayList 来说明 fail-fast 的原理、解决办法)”。 CopyOnWriteArrayList 示例下面，我们通过一个例子去对比 ArrayList 和 CopyOnWriteArrayList。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * CopyOnWriteArrayList是“线程安全”的动态数组，而ArrayList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历list”的示例 * (01) 当list是CopyOnWriteArrayList对象时，程序能正常运行。 * (02) 当list是ArrayList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class CopyOnWriteArrayListTest1 &#123; // TODO: list是ArrayList对象时，程序会出错。 //private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对list进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value = null; Iterator iter = list.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+"-"+i; list.add(val); // 通过“Iterator”遍历List。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112ta-1, tb-1, ta-1, tb-1, ta-1, ta-1, tb-1, tb-1, tb-2, tb-2, ta-1, ta-2, tb-1, ta-1, tb-2, tb-1, ta-2, tb-2, tb-3, ta-2, ta-1, tb-3, tb-1, ta-3, tb-2, ta-1, ta-2, tb-1, tb-3, tb-2, ta-3, ta-2, tb-4, tb-3, ta-1, ta-3, tb-1, tb-4, tb-2, ta-4, ta-2, ta-1, tb-3, tb-1, ta-3, tb-2, tb-4, ta-2, ta-4, tb-3, tb-5, ta-3, ta-1, tb-4, tb-1, ta-4, tb-2, tb-5, ta-2, ta-5, tb-3, ta-1, ta-3, tb-1, tb-4, tb-2, ta-4, ta-2, tb-5, tb-3, ta-5, ta-3, tb-6, tb-4, ta-4, tb-5, ta-5, tb-6, ta-6, 结果说明：如果将源码中的 list 改成 ArrayList 对象时，程序会产生 ConcurrentModificationException 异常。 03 CopyOnWriteArraySet概要本章是 JUC 系列中的 CopyOnWriteArraySet 篇。接下来，会先对 CopyOnWriteArraySet 进行基本介绍，然后再说明它的原理，接着通过代码去分析，最后通过示例更进一步的了解 CopyOnWriteArraySet。内容包括：CopyOnWriteArraySet 介绍 CopyOnWriteArraySet 原理和数据结构CopyOnWriteArraySet 函数列表CopyOnWriteArraySet 源码 (JDK1.7.0_40 版本)CopyOnWriteArraySet 示例 CopyOnWriteArraySet 介绍它是线程安全的无序的集合，可以将它理解成线程安全的 HashSet。有意思的是，CopyOnWriteArraySet 和 HashSet 虽然都继承于共同的父类 AbstractSet；但是，HashSet 是通过 “散列表 (HashMap)” 实现的，而 CopyOnWriteArraySet 则是通过 “动态数组 (CopyOnWriteArrayList)” 实现的，并不是散列表。和 CopyOnWriteArrayList 类似，CopyOnWriteArraySet 具有以下特性：1. 它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。2. 它是线程安全的。3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。4. 迭代器支持 hasNext(), next() 等不可变操作，但不支持可变 remove() 等 操作。5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 建议：在学习 CopyOnWriteArraySet 之前，先通过 “Java 集合系列 16 之 HashSet 详细介绍 (源码解析) 和使用示例 “ 对 HashSet 进行了解。 CopyOnWriteArraySet 原理和数据结构CopyOnWriteArraySet 的数据结构，如下图所示： 说明： 1. CopyOnWriteArraySet 继承于 AbstractSet，这就意味着它是一个集合。 2. CopyOnWriteArraySet 包含 CopyOnWriteArrayList 对象，它是通过 CopyOnWriteArrayList 实现的。而 CopyOnWriteArrayList 本质是个动态数组队列，所以 CopyOnWriteArraySet 相当于通过通过动态数组实现的 “集合”！ CopyOnWriteArrayList 中允许有重复的元素；但是，CopyOnWriteArraySet 是一个集合，所以它不能有重复集合。因此，CopyOnWriteArrayList 额外提供了 addIfAbsent() 和 addAllAbsent()这两个添加元素的 API，通过这些 API 来添加元素时，只有当元素不存在时才执行添加操作！ 至于 CopyOnWriteArraySet 的 “线程安全” 机制，和 CopyOnWriteArrayList 一样，是通过 volatile 和互斥锁来实现的。这个在前一章节介绍 CopyOnWriteArrayList 时数据结构时，已经进行了说明，这里就不再重复叙述了。 CopyOnWriteArraySet 函数列表123456789101112131415161718192021222324252627282930313233// 创建一个空 set。CopyOnWriteArraySet()// 创建一个包含指定 collection 所有元素的 set。CopyOnWriteArraySet(Collection&lt;? extends E&gt; c)// 如果指定元素并不存在于此 set 中，则添加它。boolean add(E e)// 如果此 set 中没有指定 collection 中的所有元素，则将它们都添加到此 set 中。boolean addAll(Collection&lt;? extends E&gt; c)// 移除此 set 中的所有元素。void clear()// 如果此 set 包含指定元素，则返回 true。boolean contains(Object o)// 如果此 set 包含指定 collection 的所有元素，则返回 true。boolean containsAll(Collection&lt;?&gt; c)// 比较指定对象与此 set 的相等性。boolean equals(Object o)// 如果此 set 不包含任何元素，则返回 true。boolean isEmpty()// 返回按照元素添加顺序在此 set 中包含的元素上进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 如果指定元素存在于此 set 中，则将其移除。boolean remove(Object o)// 移除此 set 中包含在指定 collection 中的所有元素。boolean removeAll(Collection&lt;?&gt; c)// 仅保留此 set 中那些包含在指定 collection 中的元素。boolean retainAll(Collection&lt;?&gt; c)// 返回此 set 中的元素数目。int size()// 返回一个包含此 set 所有元素的数组。Object[] toArray()// 返回一个包含此 set 所有元素的数组；返回数组的运行时类型是指定数组的类型。&lt;T&gt; T[] toArray(T[] a) CopyOnWriteArraySet 源码 (JDK1.7.0_40 版本)CopyOnWriteArraySet.java 的完整源码如下： CopyOnWriteArraySet.java 的完整源码 CopyOnWriteArraySet 是通过 CopyOnWriteArrayList 实现的，它的 API 基本上都是通过调用 CopyOnWriteArrayList 的 API 来实现的。相信对 CopyOnWriteArrayList 了解的话，对 CopyOnWriteArraySet 的了解是水到渠成的事；所以，这里就不再对 CopyOnWriteArraySet 的代码进行详细的解析了。若对 CopyOnWriteArrayList 不了解，请参考 “Java 多线程系列 –“JUC 集合”02 之 CopyOnWriteArrayList”。 CopyOnWriteArraySet 示例下面，我们通过一个例子去对比 HashSet 和 CopyOnWriteArraySet。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * CopyOnWriteArraySet是“线程安全”的集合，而HashSet是非线程安全的。 * * 下面是“多个线程同时操作并且遍历集合set”的示例 * (01) 当set是CopyOnWriteArraySet对象时，程序能正常运行。 * (02) 当set是HashSet对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class CopyOnWriteArraySetTest1 &#123; // TODO: set是HashSet对象时，程序会出错。 //private static Set&lt;String&gt; set = new HashSet&lt;String&gt;(); private static Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对set进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value = null; Iterator iter = set.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 10) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName() + "-" + (i%6); set.add(val); // 通过“Iterator”遍历set。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 1234567891011121314151617181920ta-1, tb-1, ta-1, tb-1, ta-1, tb-1, ta-1, ta-2, tb-1, ta-1, ta-2, tb-1, tb-2, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-1, ta-3, tb-1, tb-3, ta-2, ta-4, tb-2, ta-1, ta-3, tb-1, tb-3, ta-2, ta-4, tb-2, tb-4, ta-3, ta-1, tb-3, tb-1, ta-4, ta-2, tb-4, tb-2, ta-5, ta-3, ta-1, tb-3, tb-1, ta-4, ta-2, tb-4, tb-2, ta-5, ta-3, tb-5, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, tb-0, ta-4, ta-1, tb-4, tb-1, ta-5, ta-2, tb-5, tb-2, ta-0, ta-3, tb-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-5, ta-0, tb-0, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-4, ta-3, tb-4, tb-3, ta-5, ta-4, tb-5, tb-4, ta-0, ta-5, tb-0, tb-5, ta-1, ta-0, tb-1, tb-0, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-4, ta-3, tb-4, tb-3, ta-5, tb-5, ta-0, tb-0, ta-4, ta-1, tb-4, tb-1, ta-5, ta-2, tb-5, tb-2, ta-0, ta-3, tb-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, tb-0, ta-4, tb-4, ta-5, tb-5, ta-0, tb-0, 结果说明：由于 set 是集合对象，因此它不会包含重复的元素。如果将源码中的 set 改成 HashSet 对象时，程序会产生 ConcurrentModificationException 异常。 04 ConcurrentHashMap概要本章是 JUC 系列的 ConcurrentHashMap 篇。内容包括：ConcurrentHashMap 介绍 ConcurrentHashMap 原理和数据结构ConcurrentHashMap 函数列表ConcurrentHashMap 源码分析 (JDK1.7.0_40 版本)ConcurrentHashMap 示例 ConcurrentHashMap 介绍ConcurrentHashMap 是线程安全的哈希表。HashMap, Hashtable, ConcurrentHashMap 之间的关联如下： HashMap 是非线程安全的哈希表，常用于单线程程序中。 Hashtable 是线程安全的哈希表，它是通过 synchronized 来保证线程安全的；即，多线程通过同一个 “对象的同步锁” 来实现并发控制。Hashtable 在线程竞争激烈时，效率比较低(此时建议使用 ConcurrentHashMap)！因为当一个线程访问 Hashtable 的同步方法时，其它线程就访问 Hashtable 的同步方法时，可能会进入阻塞状态。 ConcurrentHashMap 是线程安全的哈希表，它是通过 “锁分段” 来保证线程安全的。ConcurrentHashMap 将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。 关于 HashMap,Hashtable 以及 ReentrantLock 的更多内容，可以参考： Java 集合系列 10 之 HashMap 详细介绍 (源码解析) 和使用示例 Java 集合系列 11 之 Hashtable 详细介绍 (源码解析) 和使用示例 Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock ConcurrentHashMap 原理和数据结构要想搞清 ConcurrentHashMap，必须先弄清楚它的数据结构： (01) ConcurrentHashMap 继承于 AbstractMap 抽象类。 (02) Segment 是 ConcurrentHashMap 中的内部类，它就是 ConcurrentHashMap 中的 “锁分段” 对应的存储结构。ConcurrentHashMap 与 Segment 是组合关系，1 个 ConcurrentHashMap 对象包含若干个 Segment 对象。在代码中，这表现为 ConcurrentHashMap 类中存在 “Segment 数组” 成员。 (03) Segment 类继承于 ReentrantLock 类，所以 Segment 本质上是一个可重入的互斥锁。 (04) HashEntry 也是 ConcurrentHashMap 的内部类，是单向链表节点，存储着 key-value 键值对。Segment 与 HashEntry 是组合关系，Segment 类中存在 “HashEntry 数组” 成员，“HashEntry 数组”中的每个 HashEntry 就是一个单向链表。 对于多线程访问对一个 “哈希表对象” 竞争资源，Hashtable 是通过一把锁来控制并发；而 ConcurrentHashMap 则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap 对并发的控制更加细腻，它也更加适应于高并发场景！ ConcurrentHashMap 函数列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。ConcurrentHashMap()// 创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。ConcurrentHashMap(int initialCapacity)// 创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (16) 的新的空映射。ConcurrentHashMap(int initialCapacity, float loadFactor)// 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)// 构造一个与给定映射具有相同映射关系的新映射。ConcurrentHashMap(Map&lt;? extends K,? extends V&gt; m)// 从该映射中移除所有映射关系void clear()// 一种遗留方法，测试此表中是否有一些与指定值存在映射关系的键。boolean contains(Object value)// 测试指定对象是否为此表中的键。boolean containsKey(Object key)// 如果此映射将一个或多个键映射到指定值，则返回 true。boolean containsValue(Object value)// 返回此表中值的枚举。Enumeration&lt;V&gt; elements()// 返回此映射所包含的映射关系的 Set 视图。Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()// 返回指定键所映射到的值，如果此映射不包含该键的映射关系，则返回 null。V get(Object key)// 如果此映射不包含键-值映射关系，则返回 true。boolean isEmpty()// 返回此表中键的枚举。Enumeration&lt;K&gt; keys()// 返回此映射中包含的键的 Set 视图。Set&lt;K&gt; keySet()// 将指定键映射到此表中的指定值。V put(K key, V value)// 将指定映射中所有映射关系复制到此映射中。void putAll(Map&lt;? extends K,? extends V&gt; m)// 如果指定键已经不再与某个值相关联，则将它与给定值关联。V putIfAbsent(K key, V value)// 从此映射中移除键（及其相应的值）。V remove(Object key)// 只有目前将键的条目映射到给定值时，才移除该键的条目。boolean remove(Object key, Object value)// 只有目前将键的条目映射到某一值时，才替换该键的条目。V replace(K key, V value)// 只有目前将键的条目映射到给定值时，才替换该键的条目。boolean replace(K key, V oldValue, V newValue)// 返回此映射中的键-值映射关系数。int size()// 返回此映射中包含的值的 Collection 视图。Collection&lt;V&gt; values() ConcurrentHashMap 源码分析 (JDK1.7.0_40 版本)ConcurrentHashMap.java 的完整源码如下： ConcurrentHashMap.java 的完整源码 下面从 ConcurrentHashMap 的创建，获取，添加，删除这 4 个方面对 ConcurrentHashMap 进行分析。 1 创建 下面以 ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) 来进行说明。 123456789101112131415161718192021222324252627282930313233343536373839@SuppressWarnings("unchecked")public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; // 参数有效性判断 if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); // concurrencyLevel是“用来计算segments的容量” if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; int sshift = 0; int ssize = 1; // ssize=“大于或等于concurrencyLevel的最小的2的N次方值” while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; // 初始化segmentShift和segmentMask this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; // 哈希表的初始容量 // 哈希表的实际容量=“segments的容量” x “segments中数组的长度” if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // “哈希表的初始容量” / “segments的容量” int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; // cap就是“segments中的HashEntry数组的长度” int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // segments Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss;&#125; 说明：(01) 前面我们说过，ConcurrentHashMap 采用了 “锁分段” 技术；在代码中，它通过 “segments 数组” 对象来保存各个分段。segments 的定义如下： 1final Segment&lt;K,V&gt;[] segments; concurrencyLevel 的作用就是用来计算 segments 数组的容量大小。先计算出 “大于或等于 concurrencyLevel 的最小的 2 的 N 次方值”，然后将其保存为 “segments 的容量大小 (ssize)”。(02) initialCapacity 是哈希表的初始容量。需要注意的是，哈希表的实际容量 =“segments 的容量” x “segments 中数组的长度”。(03) loadFactor 是加载因子。它是哈希表在其容量自动增加之前可以达到多满的一种尺度。 ConcurrentHashMap 的构造函数中涉及到的非常重要的一个结构体，它就是 Segment。下面看看 Segment 的声明： 1234567891011121314151617static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; ... transient volatile HashEntry&lt;K,V&gt;[] table; // threshold阈，是哈希表在其容量自动增加之前可以达到多满的一种尺度。 transient int threshold; // loadFactor是加载因子 final float loadFactor; Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123; this.loadFactor = lf; this.threshold = threshold; this.table = tab; &#125; ...&#125; 说明：Segment 包含 HashEntry 数组，HashEntry 保存了哈希表中的键值对。此外，还需要说明的 Segment 继承于 ReentrantLock。这意味着，Segment 本质上就是可重入的互斥锁。 HashEntry 的源码如下： 123456789101112131415static final class HashEntry&lt;K,V&gt; &#123; final int hash; // 哈希值 final K key; // 键 volatile V value; // 值 volatile HashEntry&lt;K,V&gt; next; // 下一个HashEntry节点 HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ...&#125; 说明：和 HashMap 的节点一样，HashEntry 也是链表。这就说明，ConcurrentHashMap 是链式哈希表，它是通过 “拉链法” 来解决哈希冲突的。 2 获取 下面以 get(Object key) 为例，对 ConcurrentHashMap 的获取方法进行说明。 1234567891011121314151617181920public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // 获取key对应的Segment片段。 // 如果Segment片段不为null，则在“Segment片段的HashEntry数组中”中找到key所对应的HashEntry列表； // 接着遍历该HashEntry链表，找到于key-value键值对对应的HashEntry节点。 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; 说明：get(Object key) 的作用是返回 key 在 ConcurrentHashMap 哈希表中对应的值。它首先根据 key 计算出来的哈希值，获取 key 所对应的 Segment 片段。如果 Segment 片段不为 null，则在 “Segment 片段的 HashEntry 数组中” 中找到 key 所对应的 HashEntry 列表。Segment 包含 “HashEntry 数组” 对象，而每一个 HashEntry 本质上是一个单向链表。接着遍历该 HashEntry 链表，找到于 key-value 键值对对应的 HashEntry 节点。 下面是 hash() 的源码 123456789101112131415161718private int hash(Object k) &#123; int h = hashSeed; if ((0 != h) &amp;&amp; (k instanceof String)) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; 3 增加 下面以 put(K key, V value) 来对 ConcurrentHashMap 中增加键值对来进行说明。 12345678910111213public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); // 获取key对应的哈希值 int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; // 如果找不到该Segment，则新建一个。 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false);&#125; 说明：(01) put() 根据 key 获取对应的哈希值，再根据哈希值找到对应的 Segment 片段。如果 Segment 片段不存在，则新增一个 Segment。(02) 将 key-value 键值对添加到 Segment 片段中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // tryLock()获取锁，成功返回true，失败返回false。 // 获取锁失败的话，则通过scanAndLockForPut()获取锁，并返回”要插入的key-value“对应的”HashEntry链表“。 HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; // tab代表”当前Segment中的HashEntry数组“ HashEntry&lt;K,V&gt;[] tab = table; // 根据”hash值“获取”HashEntry数组中对应的HashEntry链表“ int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; // 如果”HashEntry链表中的当前HashEntry节点“不为null， if (e != null) &#123; K k; // 当”要插入的key-value键值对“已经存在于”HashEntry链表中“时，先保存原有的值。 // 若”onlyIfAbsent“为true，即”要插入的key不存在时才插入”，则直接退出； // 否则，用新的value值覆盖原有的原有的值。 if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; // 如果node非空，则将first设置为“node的下一个节点”。 // 否则，新建HashEntry链表 if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; // 如果添加key-value键值对之后，Segment中的元素超过阈值(并且，HashEntry数组的长度没超过限制)，则rehash； // 否则，直接添加key-value键值对。 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; // 释放锁 unlock(); &#125; return oldValue;&#125; 说明：put() 的作用是将 key-value 键值对插入到 “当前 Segment 对应的 HashEntry 中”，在插入前它会获取 Segment 对应的互斥锁，插入后会释放锁。具体的插入过程如下：(01) 首先根据 “hash 值” 获取 “当前 Segment 的 HashEntry 数组对象” 中的“HashEntry 节点”，每个 HashEntry 节点都是一个单向链表。(02) 接着，遍历 HashEntry 链表。 若在遍历 HashEntry 链表时，找到与 “要 key-value 键值对” 对应的节点，即 “要插入的 key-value 键值对” 的 key 已经存在于 HashEntry 链表中。则根据 onlyIfAbsent 进行判断，若 onlyIfAbsent 为 true，即“当要插入的 key 不存在时才插入”，则不进行插入，直接返回；否则，用新的 value 值覆盖原始的 value 值，然后再返回。 若在遍历 HashEntry 链表时，没有找到与 “要 key-value 键值对” 对应的节点。当 node!=null 时，即在 scanAndLockForPut()获取锁时，已经新建了 key-value 对应的 HashEntry 节点，则”将 HashEntry 添加到 Segment 中 “；否则，新建 key-value 对应的 HashEntry 节点，然后再“将 HashEntry 添加到 Segment 中”。 在” 将 HashEntry 添加到 Segment 中 “前，会判断是否需要 rehash。如果在添加 key-value 键值之后，容量会超过阈值，并且 HashEntry 数组的长度没有超过限制，则进行 rehash；否则，直接通过 setEntryAt() 将 key-value 键值对添加到 Segment 中。 在介绍 rehash() 和 setEntryAt() 之前，我们先看看自旋函数 scanAndLockForPut()。下面是它的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123; // 第一个HashEntry节点 HashEntry&lt;K,V&gt; first = entryForHash(this, hash); // 当前的HashEntry节点 HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null; // 重复计数(自旋计数器) int retries = -1; // negative while locating node // 查找”key-value键值对“在”HashEntry链表上对应的节点“； // 若找到的话，则不断的自旋；在自旋期间，若通过tryLock()获取锁成功则返回；否则自旋MAX_SCAN_RETRIES次数之后，强制获取”锁“并退出。 // 若没有找到的话，则新建一个HashEntry链表。然后不断的自旋。 // 此外，若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋工作！ while (!tryLock()) &#123; HashEntry&lt;K,V&gt; f; // to recheck first below // 1\. retries&lt;0的处理情况 if (retries &lt; 0) &#123; // 1.1 如果当前的HashEntry节点为空(意味着，在该HashEntry链表上上没有找到”要插入的键值对“对应的节点)，而且node=null；则新建HashEntry链表。 if (e == null) &#123; if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; &#125; // 1.2 如果当前的HashEntry节点是”要插入的键值对在该HashEntry上对应的节点“，则设置retries=0 else if (key.equals(e.key)) retries = 0; // 1.3 设置为下一个HashEntry。 else e = e.next; &#125; // 2\. 如果自旋次数超过限制，则获取“锁”并退出 else if (++retries &gt; MAX_SCAN_RETRIES) &#123; lock(); break; &#125; // 3\. 当“尝试了偶数次”时，就获取“当前Segment的第一个HashEntry”，即f。 // 然后，通过f!=first来判断“当前Segment的第一个HashEntry是否发生了改变”。 // 若是的话，则重置e，first和retries的值，并重新遍历。 else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123; e = first = f; // re-traverse if entry changed retries = -1; &#125; &#125; return node;&#125; 说明：scanAndLockForPut() 的目标是获取锁。流程如下： 它首先会调用 entryForHash()，根据 hash 值获取” 当前 Segment 中对应的 HashEntry 节点 (first)，即找到对应的 HashEntry 链表 “。 紧接着进入 while 循环。在 while 循环中，它会遍历”HashEntry 链表 (e)“，查找” 要插入的 key-value 键值对 “在” 该 HashEntry 链表上对应的节点“。 若找到的话，则不断的自旋，即不断的执行 while 循环。在自旋期间，若通过 tryLock() 获取锁成功则返回；否则，在自旋 MAX_SCAN_RETRIES 次数之后，强制获取锁并退出。 若没有找到的话，则新建一个 HashEntry 链表，然后不断的自旋。在自旋期间，若通过 tryLock() 获取锁成功则返回；否则，在自旋 MAX_SCAN_RETRIES 次数之后，强制获取锁并退出。 此外，若在自旋期间，HashEntry 链表的表头发生变化；则重新进行查找和自旋工作！ 理解 scanAndLockForPut()时，务必要联系”哈希表 “的数据结构。一个 Segment 本身就是一个哈希表，Segment 中包含了”HashEntry 数组“对象，而每一个 HashEntry 对象本身是一个” 单向链表“。 下面看看 rehash() 的实现代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void rehash(HashEntry&lt;K,V&gt; node) &#123; HashEntry&lt;K,V&gt;[] oldTable = table; // ”Segment中原始的HashEntry数组的长度“ int oldCapacity = oldTable.length; // ”Segment中新HashEntry数组的长度“ int newCapacity = oldCapacity &lt;&lt; 1; // 新的阈值 threshold = (int)(newCapacity * loadFactor); // 新的HashEntry数组 HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; int sizeMask = newCapacity - 1; // 遍历”原始的HashEntry数组“， // 将”原始的HashEntry数组“中的每个”HashEntry链表“的值，都复制到”新的HashEntry数组的HashEntry元素“中。 for (int i = 0; i &lt; oldCapacity ; i++) &#123; // 获取”原始的HashEntry数组“中的”第i个HashEntry链表“ HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) &#123; HashEntry&lt;K,V&gt; next = e.next; int idx = e.hash &amp; sizeMask; if (next == null) // Single node on list newTable[idx] = e; else &#123; // Reuse consecutive sequence at same slot HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123; int k = last.hash &amp; sizeMask; if (k != lastIdx) &#123; lastIdx = k; lastRun = last; &#125; &#125; newTable[lastIdx] = lastRun; // 将”原始的HashEntry数组“中的”HashEntry链表(e)“的值，都复制到”新的HashEntry数组的HashEntry“中。 for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123; V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); &#125; &#125; &#125; &#125; // 将新的node节点添加到“Segment的新HashEntry数组(newTable)“中。 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; table = newTable;&#125; 说明：rehash()的作用是将”Segment 的容量 “变为” 原始的 Segment 容量的 2 倍“。在将原始的数据拷贝到 “新的 Segment” 中后，会将新增加的 key-value 键值对添加到 “新的 Segment” 中。 setEntryAt() 的源码如下： 1234static final &lt;K,V&gt; void setEntryAt(HashEntry&lt;K,V&gt;[] tab, int i, HashEntry&lt;K,V&gt; e) &#123; UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e);&#125; UNSAFE 是 Segment 类中定义的 “静态 sun.misc.Unsafe” 对象。源码如下： 1static final sun.misc.Unsafe UNSAFE; Unsafe.java 在 openjdk6 中的路径是：openjdk6/jdk/src/share/classes/sun/misc/Unsafe.java。其中，putOrderedObject() 的源码下： 1public native void putOrderedObject(Object o, long offset, Object x); 说明：putOrderedObject() 是一个本地方法。它会设置 obj 对象中 offset 偏移地址对应的 object 型 field 的值为指定值。它是一个有序或者有延迟的 putObjectVolatile() 方法，并且不保证值的改变被其他线程立即看到。只有在 field 被 volatile 修饰并且期望被意外修改的时候，使用 putOrderedObject() 才有用。 总之，setEntryAt() 的目的是设置 tab 中第 i 位置元素的值为 e，且该设置会有延迟。 4 删除 下面以 remove(Object key) 来对 ConcurrentHashMap 中的删除操作来进行说明。 123456public V remove(Object key) &#123; int hash = hash(key); // 根据hash值，找到key对应的Segment片段。 Segment&lt;K,V&gt; s = segmentForHash(hash); return s == null ? null : s.remove(key, hash, null);&#125; 说明：remove()首先根据 “key 的计算出来的哈希值” 找到对应的 Segment 片段，然后再从该 Segment 片段中删除对应的“key-value 键值对”。 remove() 的方法如下： 123456789101112131415161718192021222324252627282930313233343536373839final V remove(Object key, int hash, Object value) &#123; // 尝试获取Segment对应的锁。 // 尝试失败的话，则通过scanAndLock()来获取锁。 if (!tryLock()) scanAndLock(key, hash); V oldValue = null; try &#123; // 根据“hash值”找到“Segment的HashEntry数组”中对应的“HashEntry节点(e)”，该HashEntry节点是一HashEntry个链表。 HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; e = entryAt(tab, index); HashEntry&lt;K,V&gt; pred = null; // 遍历“HashEntry链表”，删除key-value键值对 while (e != null) &#123; K k; HashEntry&lt;K,V&gt; next = e.next; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; V v = e.value; if (value == null || value == v || value.equals(v)) &#123; if (pred == null) setEntryAt(tab, index, next); else pred.setNext(next); ++modCount; --count; oldValue = v; &#125; break; &#125; pred = e; e = next; &#125; &#125; finally &#123; // 释放锁 unlock(); &#125; return oldValue;&#125; 说明：remove() 的目的就是删除 key-value 键值对。在删除之前，它会获取到 Segment 的互斥锁，在删除之后，再释放锁。它的删除过程也比较简单，它会先根据 hash 值，找到 “Segment 的 HashEntry 数组” 中对应的 “HashEntry” 节点。根据 Segment 的数据结构，我们知道 Segment 中包含一个 HashEntry 数组对象，而每一个 HashEntry 本质上是一个单向链表。 在找到 “HashEntry” 节点之后，就遍历该 “HashEntry” 节点对应的链表，找到 key-value 键值对对应的节点，然后删除。 下面对 scanAndLock() 进行说明。它的源码如下： 1234567891011121314151617181920212223242526272829303132333435private void scanAndLock(Object key, int hash) &#123; // 第一个HashEntry节点 HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; int retries = -1; // 查找”key-value键值对“在”HashEntry链表上对应的节点“； // 无论找没找到，最后都会不断的自旋；在自旋期间，若通过tryLock()获取锁成功则返回；否则自旋MAX_SCAN_RETRIES次数之后，强制获取”锁“并退出。 // 若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋！ while (!tryLock()) &#123; HashEntry&lt;K,V&gt; f; if (retries &lt; 0) &#123; // 如果“遍历完该HashEntry链表，仍然没找到”要删除的键值对“对应的节点” // 或者“在该HashEntry链表上找到”要删除的键值对“对应的节点”，则设置retries=0 // 否则，设置e为下一个HashEntry节点。 if (e == null || key.equals(e.key)) retries = 0; else e = e.next; &#125; // 自旋超过限制次数之后，获取锁并退出。 else if (++retries &gt; MAX_SCAN_RETRIES) &#123; lock(); break; &#125; // 当“尝试了偶数次”时，就获取“当前Segment的第一个HashEntry”，即f。 // 然后，通过f!=first来判断“当前Segment的第一个HashEntry是否发生了改变”。 // 若是的话，则重置e，first和retries的值，并重新遍历。 else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123; e = first = f; retries = -1; &#125; &#125;&#125; 说明：scanAndLock() 的目标是获取锁。它的实现与 scanAndLockForPut() 类似，这里就不再过多说明。 总结：ConcurrentHashMap 是线程安全的哈希表，它是通过 “锁分段” 来实现的。ConcurrentHashMap 中包括了 “Segment(锁分段) 数组”，每个 Segment 就是一个哈希表，而且也是可重入的互斥锁。第一，Segment 是哈希表表现在，Segment 包含了 “HashEntry 数组”，而“HashEntry 数组” 中的每一个 HashEntry 元素是一个单向链表。即 Segment 是通过链式哈希表。第二，Segment 是可重入的互斥锁表现在，Segment 继承于 ReentrantLock，而 ReentrantLock 就是可重入的互斥锁。对于 ConcurrentHashMap 的添加，删除操作，在操作开始前，线程都会获取 Segment 的互斥锁；操作完毕之后，才会释放。而对于读取操作，它是通过 volatile 去实现的，HashEntry 数组是 volatile 类型的，而 volatile 能保证 “即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”，即我们总能读到其它线程写入 HashEntry 之后的值。 以上这些方式，就是 ConcurrentHashMap 线程安全的实现原理。 ConcurrentHashMap 示例下面，我们通过一个例子去对比 HashMap 和 ConcurrentHashMap。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;import java.util.concurrent.*;/* * ConcurrentHashMap是“线程安全”的哈希表，而HashMap是非线程安全的。 * * 下面是“多个线程同时操作并且遍历map”的示例 * (01) 当map是ConcurrentHashMap对象时，程序能正常运行。 * (02) 当map是HashMap对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ConcurrentHashMapDemo1 &#123; // TODO: map是HashMap对象时，程序会出错。 //private static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); private static Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;String, String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对map进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String key, value; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); value = (String)entry.getValue(); System.out.print(key+" - "+value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; map.put(String.valueOf(i), val); // 通过“Iterator”遍历map。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 1234567891011121 - tb1, 1 - tb1, 1 - tb1, 1 - tb1, 2 - tb2, 2 - tb2, 1 - tb1, 3 - ta3, 1 - tb1, 2 - tb2, 3 - tb3, 1 - tb1, 2 - tb2, 3 - tb3, 1 - tb1, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 1 - tb1, 2 - tb2, 5 - ta5, 1 - tb1, 3 - tb3, 5 - tb5, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 1 - tb1, 2 - tb2, 5 - tb5, 1 - tb1, 6 - tb6, 5 - tb5, 3 - tb3, 6 - tb6, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 2 - tb2, 结果说明：如果将源码中的 map 改成 HashMap 对象时，程序会产生 ConcurrentModificationException 异常。 05 ConcurrentSkipListMap概要本章对 Java.util.concurrent 包中的 ConcurrentSkipListMap 类进行详细的介绍。内容包括：ConcurrentSkipListMap 介绍 ConcurrentSkipListMap 原理和数据结构ConcurrentSkipListMap 函数列表ConcurrentSkipListMap 源码分析 (JDK1.7.0_40 版本)ConcurrentSkipListMap 示例 ConcurrentSkipListMap 介绍ConcurrentSkipListMap 是线程安全的有序的哈希表，适用于高并发的场景。ConcurrentSkipListMap 和 TreeMap，它们虽然都是有序的哈希表。但是，第一，它们的线程安全机制不同，TreeMap 是非线程安全的，而 ConcurrentSkipListMap 是线程安全的。第二，ConcurrentSkipListMap 是通过跳表实现的，而 TreeMap 是通过红黑树实现的。关于跳表 (Skip List)，它是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。 ConcurrentSkipListMap 原理和数据结构ConcurrentSkipListMap 的数据结构，如下图所示： 说明： 先以数据 “7,14,21,32,37,71,85” 序列为例，来对跳表进行简单说明。 跳表分为许多层 (level)，每一层都可以看作是数据的索引，这些索引的意义就是加快跳表查找数据速度。每一层的数据都是有序的，上一层数据是下一层数据的子集，并且第一层(level 1) 包含了全部的数据；层次越高，跳跃性越大，包含的数据越少。跳表包含一个表头，它查找数据时，是从上往下，从左往右进行查找。现在 “需要找出值为 32 的节点” 为例，来对比说明跳表和普遍的链表。 情况 1：链表中查找 “32” 节点路径如下图 1-02 所示： 需要 4 步 (红色部分表示路径)。 情况 2：跳表中查找 “32” 节点路径如下图 1-03 所示： 忽略索引垂直线路上路径的情况下，只需要 2 步 (红色部分表示路径)。 下面说说 Java 中 ConcurrentSkipListMap 的数据结构。(01) ConcurrentSkipListMap 继承于 AbstractMap 类，也就意味着它是一个哈希表。(02) Index 是 ConcurrentSkipListMap 的内部类，它与 “跳表中的索引相对应”。HeadIndex 继承于 Index，ConcurrentSkipListMap 中含有一个 HeadIndex 的对象 head，head 是 “跳表的表头”。(03) Index 是跳表中的索引，它包含 “右索引的指针(right)”，“下索引的指针(down)” 和“哈希表节点 node”。node 是 Node 的对象，Node 也是 ConcurrentSkipListMap 中的内部类。 ConcurrentSkipListMap 函数列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 构造一个新的空映射，该映射按照键的自然顺序进行排序。ConcurrentSkipListMap()// 构造一个新的空映射，该映射按照指定的比较器进行排序。ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator)// 构造一个新映射，该映射所包含的映射关系与给定映射包含的映射关系相同，并按照键的自然顺序进行排序。ConcurrentSkipListMap(Map&lt;? extends K,? extends V&gt; m)// 构造一个新映射，该映射所包含的映射关系与指定的有序映射包含的映射关系相同，使用的顺序也相同。ConcurrentSkipListMap(SortedMap&lt;K,? extends V&gt; m)// 返回与大于等于给定键的最小键关联的键-值映射关系；如果不存在这样的条目，则返回 null。Map.Entry&lt;K,V&gt; ceilingEntry(K key)// 返回大于等于给定键的最小键；如果不存在这样的键，则返回 null。K ceilingKey(K key)// 从此映射中移除所有映射关系。void clear()// 返回此 ConcurrentSkipListMap 实例的浅表副本。ConcurrentSkipListMap&lt;K,V&gt; clone()// 返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。Comparator&lt;? super K&gt; comparator()// 如果此映射包含指定键的映射关系，则返回 true。boolean containsKey(Object key)// 如果此映射为指定值映射一个或多个键，则返回 true。boolean containsValue(Object value)// 返回此映射中所包含键的逆序 NavigableSet 视图。NavigableSet&lt;K&gt; descendingKeySet()// 返回此映射中所包含映射关系的逆序视图。ConcurrentNavigableMap&lt;K,V&gt; descendingMap()// 返回此映射中所包含的映射关系的 Set 视图。Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()// 比较指定对象与此映射的相等性。boolean equals(Object o)// 返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。Map.Entry&lt;K,V&gt; firstEntry()// 返回此映射中当前第一个（最低）键。K firstKey()// 返回与小于等于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。Map.Entry&lt;K,V&gt; floorEntry(K key)// 返回小于等于给定键的最大键；如果不存在这样的键，则返回 null。K floorKey(K key)// 返回指定键所映射到的值；如果此映射不包含该键的映射关系，则返回 null。V get(Object key)// 返回此映射的部分视图，其键值严格小于 toKey。ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey)// 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)// 返回与严格大于给定键的最小键关联的键-值映射关系；如果不存在这样的键，则返回 null。Map.Entry&lt;K,V&gt; higherEntry(K key)// 返回严格大于给定键的最小键；如果不存在这样的键，则返回 null。K higherKey(K key)// 如果此映射未包含键-值映射关系，则返回 true。boolean isEmpty()// 返回此映射中所包含键的 NavigableSet 视图。NavigableSet&lt;K&gt; keySet()// 返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。Map.Entry&lt;K,V&gt; lastEntry()// 返回映射中当前最后一个（最高）键。K lastKey()// 返回与严格小于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。Map.Entry&lt;K,V&gt; lowerEntry(K key)// 返回严格小于给定键的最大键；如果不存在这样的键，则返回 null。K lowerKey(K key)// 返回此映射中所包含键的 NavigableSet 视图。NavigableSet&lt;K&gt; navigableKeySet()// 移除并返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。Map.Entry&lt;K,V&gt; pollFirstEntry()// 移除并返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。Map.Entry&lt;K,V&gt; pollLastEntry()// 将指定值与此映射中的指定键关联。V put(K key, V value)// 如果指定键已经不再与某个值相关联，则将它与给定值关联。V putIfAbsent(K key, V value)// 从此映射中移除指定键的映射关系（如果存在）。V remove(Object key)// 只有目前将键的条目映射到给定值时，才移除该键的条目。boolean remove(Object key, Object value)// 只有目前将键的条目映射到某一值时，才替换该键的条目。V replace(K key, V value)// 只有目前将键的条目映射到给定值时，才替换该键的条目。boolean replace(K key, V oldValue, V newValue)// 返回此映射中的键-值映射关系数。int size()// 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)// 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey)// 返回此映射的部分视图，其键大于等于 fromKey。ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey)// 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)// 返回此映射中所包含值的 Collection 视图。Collection&lt;V&gt; values() ConcurrentSkipListMap 源码分析 (JDK1.7.0_40 版本)ConcurrentSkipListMap.java 的完整源码如下： ConcurrentSkipListMap.java源码 下面从 ConcurrentSkipListMap 的添加，删除，获取这 3 个方面对它进行分析。 1. 添加 下面以 put(K key, V value) 为例，对 ConcurrentSkipListMap 的添加方法进行说明。 12345public V put(K key, V value) &#123; if (value == null) throw new NullPointerException(); return doPut(key, value, false);&#125; 实际上，put() 是通过 doPut() 将 key-value 键值对添加到 ConcurrentSkipListMap 中的。 doPut() 的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private V doPut(K kkey, V value, boolean onlyIfAbsent) &#123; Comparable&lt;? super K&gt; key = comparable(kkey); for (;;) &#123; // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“key的前继节点的后继节点”，即n应该是“插入节点”的“后继节点” Node&lt;K,V&gt; n = b.next; for (;;) &#123; if (n != null) &#123; Node&lt;K,V&gt; f = n.next; // 如果两次获得的b.next不是相同的Node，就跳转到”外层for循环“，重新获得b和n后再遍历。 if (n != b.next) break; // v是“n的值” Object v = n.value; // 当n的值为null(意味着其它线程删除了n)；此时删除b的下一个节点，然后跳转到”外层for循环“，重新获得b和n后再遍历。 if (v == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; // 如果其它线程删除了b；则跳转到”外层for循环“，重新获得b和n后再遍历。 if (v == n || b.value == null) // b is deleted break; // 比较key和n.key int c = key.compareTo(n.key); if (c &gt; 0) &#123; b = n; n = f; continue; &#125; if (c == 0) &#123; if (onlyIfAbsent || n.casValue(v, value)) return (V)v; else break; // restart if lost race to replace value &#125; // else c &lt; 0; fall through &#125; // 新建节点(对应是“要插入的键值对”) Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(kkey, value, n); // 设置“b的后继节点”为z if (!b.casNext(n, z)) break; // 多线程情况下，break才可能发生(其它线程对b进行了操作) // 随机获取一个level // 然后在“第1层”到“第level层”的链表中都插入新建节点 int level = randomLevel(); if (level &gt; 0) insertIndex(z, level); return null; &#125; &#125;&#125; 说明：doPut() 的作用就是将键值对添加到 “跳表” 中。要想搞清 doPut()，首先要弄清楚它的主干部分 —— 我们先单纯的只考虑 “单线程的情况下，将 key-value 添加到跳表中”，即忽略 “多线程相关的内容”。它的流程如下：第 1 步：找到 “插入位置”。即，找到 “key 的前继节点(b)” 和“key 的后继节点(n)”；key 是要插入节点的键。第 2 步：新建并插入节点。即，新建节点 z(key 对应的节点)，并将新节点 z 插入到 “跳表” 中(设置“b 的后继节点为 z”，“z 的后继节点为 n”)。第 3 步：更新跳表。即，随机获取一个 level，然后在 “跳表” 的第 1 层～第 level 层之间，每一层都插入节点 z；在第 level 层之上就不再插入节点了。若 level 数值大于“跳表的层次”，则新建一层。主干部分 “对应的精简后的 doPut() 的代码”如下(仅供参考)： 1234567891011121314151617181920212223private V doPut(K kkey, V value, boolean onlyIfAbsent) &#123; Comparable&lt;? super K&gt; key = comparable(kkey); for (;;) &#123; // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为key的后继节点 Node&lt;K,V&gt; n = b.next; for (;;) &#123; // 新建节点(对应是“要被插入的键值对”) Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(kkey, value, n); // 设置“b的后继节点”为z b.casNext(n, z); // 随机获取一个level // 然后在“第1层”到“第level层”的链表中都插入新建节点 int level = randomLevel(); if (level &gt; 0) insertIndex(z, level); return null; &#125; &#125;&#125; 理清主干之后，剩余的工作就相对简单了。主要是上面几步的对应算法的具体实现，以及多线程相关情况的处理！ 2. 删除 下面以 remove(Object key) 为例，对 ConcurrentSkipListMap 的删除方法进行说明。 123public V remove(Object key) &#123; return doRemove(key, null);&#125; 实际上，remove() 是通过 doRemove() 将 ConcurrentSkipListMap 中的 key 对应的键值对删除的。 doRemove() 的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final V doRemove(Object okey, Object value) &#123; Comparable&lt;? super K&gt; key = comparable(okey); for (;;) &#123; // 找到“key的前继节点” Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) &#123; if (n == null) return null; // f是“当前节点n的后继节点” Node&lt;K,V&gt; f = n.next; // 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (n != b.next) // inconsistent read break; // 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 Object v = n.value; if (v == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; // 如果“前继节点b”被删除(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (v == n || b.value == null) // b is deleted break; int c = key.compareTo(n.key); if (c &lt; 0) return null; if (c &gt; 0) &#123; b = n; n = f; continue; &#125; // 以下是c=0的情况 if (value != null &amp;&amp; !value.equals(v)) return null; // 设置“当前节点n”的值为null if (!n.casValue(v, null)) break; // 设置“b的后继节点”为f if (!n.appendMarker(f) || !b.casNext(n, f)) findNode(key); // Retry via findNode else &#123; // 清除“跳表”中每一层的key节点 findPredecessor(key); // Clean index // 如果“表头的右索引为空”，则将“跳表的层次”-1。 if (head.right == null) tryReduceLevel(); &#125; return (V)v; &#125; &#125;&#125; 说明：doRemove() 的作用是删除跳表中的节点。和 doPut() 一样，我们重点看 doRemove() 的主干部分，了解主干部分之后，其余部分就非常容易理解了。下面是 “单线程的情况下，删除跳表中键值对的步骤”：第 1 步：找到 “被删除节点的位置”。即，找到 “key 的前继节点 (b)”，“key 所对应的节点 (n)”，“n 的后继节点 f”；key 是要删除节点的键。第 2 步：删除节点。即，将 “key 所对应的节点 n” 从跳表中移除 – 将 “b 的后继节点” 设为“f”！第 3 步：更新跳表。即，遍历跳表，删除每一层的 “key 节点”(如果存在的话)。如果删除“key 节点” 之后，跳表的层次需要 - 1；则执行相应的操作！主干部分 “对应的精简后的 doRemove() 的代码”如下(仅供参考)： 12345678910111213141516171819202122232425final V doRemove(Object okey, Object value) &#123; Comparable&lt;? super K&gt; key = comparable(okey); for (;;) &#123; // 找到“key的前继节点” Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) &#123; // f是“当前节点n的后继节点” Node&lt;K,V&gt; f = n.next; // 设置“当前节点n”的值为null n.casValue(v, null); // 设置“b的后继节点”为f b.casNext(n, f); // 清除“跳表”中每一层的key节点 findPredecessor(key); // 如果“表头的右索引为空”，则将“跳表的层次”-1。 if (head.right == null) tryReduceLevel(); return (V)v; &#125; &#125;&#125; 3. 获取 下面以 get(Object key) 为例，对 ConcurrentSkipListMap 的获取方法进行说明。 123public V get(Object key) &#123; return doGet(key);&#125; doGet 的源码如下： 123456789101112private V doGet(Object okey) &#123; Comparable&lt;? super K&gt; key = comparable(okey); for (;;) &#123; // 找到“key对应的节点” Node&lt;K,V&gt; n = findNode(key); if (n == null) return null; Object v = n.value; if (v != null) return (V)v; &#125;&#125; 说明：doGet() 是通过 findNode() 找到并返回节点的。 1234567891011121314151617181920212223242526272829303132333435private Node&lt;K,V&gt; findNode(Comparable&lt;? super K&gt; key) &#123; for (;;) &#123; // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) &#123; // 如果“n为null”，则跳转中不存在key对应的节点，直接返回null。 if (n == null) return null; Node&lt;K,V&gt; f = n.next; // 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (n != b.next) // inconsistent read break; Object v = n.value; // 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (v == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; if (v == n || b.value == null) // b is deleted break; // 若n是当前节点，则返回n。 int c = key.compareTo(n.key); if (c == 0) return n; // 若“节点n的key”小于“key”，则说明跳表中不存在key对应的节点，返回null if (c &lt; 0) return null; // 若“节点n的key”大于“key”，则更新b和n，继续查找。 b = n; n = f; &#125; &#125;&#125; 说明：findNode(key) 的作用是在返回跳表中 key 对应的节点；存在则返回节点，不存在则返回 null。先弄清函数的主干部分，即抛开 “多线程相关内容”，单纯的考虑单线程情况下，从跳表获取节点的算法。第 1 步：找到 “被删除节点的位置”。根据 findPredecessor() 定位 key 所在的层次以及找到 key 的前继节点 (b)，然后找到 b 的后继节点 n。第 2 步：根据 “key 的前继节点(b)” 和“key 的前继节点的后继节点 (n)” 来定位“key 对应的节点”。具体是通过比较 “n 的键值” 和“key”的大小。如果相等，则 n 就是所要查找的键。 ConcurrentSkipListMap 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;import java.util.concurrent.*;/* * ConcurrentSkipListMap是“线程安全”的哈希表，而TreeMap是非线程安全的。 * * 下面是“多个线程同时操作并且遍历map”的示例 * (01) 当map是ConcurrentSkipListMap对象时，程序能正常运行。 * (02) 当map是TreeMap对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ConcurrentSkipListMapDemo1 &#123; // TODO: map是TreeMap对象时，程序会出错。 //private static Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(); private static Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;String, String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对map进行操作！ new MyThread("a").start(); new MyThread("b").start(); &#125; private static void printAll() &#123; String key, value; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); value = (String)entry.getValue(); System.out.print("("+key+", "+value+"), "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "序号" String val = Thread.currentThread().getName()+i; map.put(val, "0"); // 通过“Iterator”遍历map。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112(a1, 0), (a1, 0), (b1, 0), (b1, 0),(a1, 0), (b1, 0), (b2, 0), (a1, 0), (a1, 0), (a2, 0), (a2, 0), (b1, 0), (b1, 0), (b2, 0), (b2, 0), (b3, 0), (b3, 0), (a1, 0), (a2, 0), (a3, 0), (a1, 0), (b1, 0), (a2, 0), (b2, 0), (a3, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (a1, 0), (b3, 0), (a2, 0), (b4, 0), (a3, 0), (a1, 0), (a4, 0), (a2, 0), (b1, 0), (a3, 0), (b2, 0), (a4, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (b5, 0), (b3, 0), (a1, 0), (b4, 0), (a2, 0), (b5, 0), (a3, 0), (a1, 0), (a4, 0), (a2, 0), (a5, 0), (a3, 0), (b1, 0), (a4, 0), (b2, 0), (a5, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (b5, 0), (b3, 0), (b6, 0), (b4, 0), (a1, 0), (b5, 0), (a2, 0), (b6, 0), (a3, 0), (a4, 0), (a5, 0), (a6, 0), (b1, 0), (b2, 0), (b3, 0), (b4, 0), (b5, 0), (b6, 0), 结果说明：示例程序中，启动两个线程 (线程 a 和线程 b) 分别对 ConcurrentSkipListMap 进行操作。以线程 a 而言，它会先获取 “线程名”+“序号”，然后将该字符串作为 key，将“0” 作为 value，插入到 ConcurrentSkipListMap 中；接着，遍历并输出 ConcurrentSkipListMap 中的全部元素。 线程 b 的操作和线程 a 一样，只不过线程 b 的名字和线程 a 的名字不同。当 map 是 ConcurrentSkipListMap 对象时，程序能正常运行。如果将 map 改为 TreeMap 时，程序会产生 ConcurrentModificationException 异常。 06 ConcurrentSkipListSet概要本章对 Java.util.concurrent 包中的 ConcurrentSkipListSet 类进行详细的介绍。内容包括：ConcurrentSkipListSet 介绍ConcurrentSkipListSet 原理和数据结构ConcurrentSkipListSet 函数列表ConcurrentSkipListSet 源码 (JDK1.7.0_40 版本)ConcurrentSkipListSet 示例 ConcurrentSkipListSet 介绍ConcurrentSkipListSet 是线程安全的有序的集合，适用于高并发的场景。ConcurrentSkipListSet 和 TreeSet，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet 是非线程安全的，而 ConcurrentSkipListSet 是线程安全的。第二，ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，而 TreeSet 是通过 TreeMap 实现的。 ConcurrentSkipListSet 原理和数据结构ConcurrentSkipListSet 的数据结构，如下图所示： 说明：(01) ConcurrentSkipListSet 继承于 AbstractSet。因此，它本质上是一个集合。(02) ConcurrentSkipListSet 实现了 NavigableSet 接口。因此，ConcurrentSkipListSet 是一个有序的集合。(03) ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的。它包含一个 ConcurrentNavigableMap 对象 m，而 m 对象实际上是 ConcurrentNavigableMap 的实现类 ConcurrentSkipListMap 的实例。ConcurrentSkipListMap 中的元素是 key-value 键值对；而 ConcurrentSkipListSet 是集合，它只用到了 ConcurrentSkipListMap 中的 key！ ConcurrentSkipListSet 函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 构造一个新的空 set，该 set 按照元素的自然顺序对其进行排序。ConcurrentSkipListSet()// 构造一个包含指定 collection 中元素的新 set，这个新 set 按照元素的自然顺序对其进行排序。ConcurrentSkipListSet(Collection&lt;? extends E&gt; c)// 构造一个新的空 set，该 set 按照指定的比较器对其元素进行排序。ConcurrentSkipListSet(Comparator&lt;? super E&gt; comparator)// 构造一个新 set，该 set 所包含的元素与指定的有序 set 包含的元素相同，使用的顺序也相同。ConcurrentSkipListSet(SortedSet&lt;E&gt; s)// 如果此 set 中不包含指定元素，则添加指定元素。boolean add(E e)// 返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。E ceiling(E e)// 从此 set 中移除所有元素。void clear()// 返回此 ConcurrentSkipListSet 实例的浅表副本。ConcurrentSkipListSet&lt;E&gt; clone()// 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。Comparator&lt;? super E&gt; comparator()// 如果此 set 包含指定的元素，则返回 true。boolean contains(Object o)// 返回在此 set 的元素上以降序进行迭代的迭代器。Iterator&lt;E&gt; descendingIterator()// 返回此 set 中所包含元素的逆序视图。NavigableSet&lt;E&gt; descendingSet()// 比较指定对象与此 set 的相等性。boolean equals(Object o)// 返回此 set 中当前第一个（最低）元素。E first()// 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。E floor(E e)// 返回此 set 的部分视图，其元素严格小于 toElement。NavigableSet&lt;E&gt; headSet(E toElement)// 返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement。NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive)// 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。E higher(E e)// 如果此 set 不包含任何元素，则返回 true。boolean isEmpty()// 返回在此 set 的元素上以升序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 返回此 set 中当前最后一个（最高）元素。E last()// 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。E lower(E e)// 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。E pollFirst()// 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。E pollLast()// 如果此 set 中存在指定的元素，则将其移除。boolean remove(Object o)// 从此 set 中移除包含在指定 collection 中的所有元素。boolean removeAll(Collection&lt;?&gt; c)// 返回此 set 中的元素数目。int size()// 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)// 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。NavigableSet&lt;E&gt; subSet(E fromElement, E toElement)// 返回此 set 的部分视图，其元素大于等于 fromElement。NavigableSet&lt;E&gt; tailSet(E fromElement)// 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) ConcurrentSkipListSet 源码 (JDK1.7.0_40 版本)ConcurrentSkipListSet.java 的完整源码如下： ConcurrentSkipListSet.java 的完整源码 ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，它的接口基本上都是通过调用 ConcurrentSkipListMap 接口来实现的。这里就不再对它的源码进行分析了。 ConcurrentSkipListSet 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * ConcurrentSkipListSet是“线程安全”的集合，而TreeSet是非线程安全的。 * * 下面是“多个线程同时操作并且遍历集合set”的示例 * (01) 当set是ConcurrentSkipListSet对象时，程序能正常运行。 * (02) 当set是TreeSet对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ConcurrentSkipListSetDemo1 &#123; // TODO: set是TreeSet对象时，程序会出错。 //private static Set&lt;String&gt; set = new TreeSet&lt;String&gt;(); private static Set&lt;String&gt; set = new ConcurrentSkipListSet&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对set进行操作！ new MyThread("a").start(); new MyThread("b").start(); &#125; private static void printAll() &#123; String value = null; Iterator iter = set.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 10) &#123; // “线程名” + "序号" String val = Thread.currentThread().getName() + (i%6); set.add(val); // 通过“Iterator”遍历set。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 1234567891011121314151617181920a1, b1, a1, a1, a2, b1, b1, a1, a2, a3, b1,a1, a2, a3, a1, a4, b1, b2, a2, a1, a2, a3, a4, a5, b1, b2, a3, a0, a4, a5, a1, b1, a2, b2, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, a0, b1, a1, b2, a2, b3, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, b4, b1, a0, b2, a1, b3, a2, b4, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, b4, b1, b5, b2, a0, a1, a2, a3, a4, a5, b3, b1, b4, b2, b5, b3, a0, b4, a1, b5, a2, a0, a3, a1, a4, a2, a5, a3, b0, a4, b1, a5, b2, b0, b3, b1, b4, b2, b5, b3, b4, a0, b5, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, 结果说明：示例程序中，启动两个线程 (线程 a 和线程 b) 分别对 ConcurrentSkipListSet 进行操作。以线程 a 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 ConcurrentSkipListSet 集合中；接着，遍历并输出集合中的全部元素。 线程 b 的操作和线程 a 一样，只不过线程 b 的名字和线程 a 的名字不同。当 set 是 ConcurrentSkipListSet 对象时，程序能正常运行。如果将 set 改为 TreeSet 时，程序会产生 ConcurrentModificationException 异常。 07 ArrayBlockingQueue概要本章对 Java.util.concurrent 包中的 ArrayBlockingQueue 类进行详细的介绍。内容包括：ArrayBlockingQueue 介绍 ArrayBlockingQueue 原理和数据结构ArrayBlockingQueue 函数列表ArrayBlockingQueue 源码分析 (JDK1.7.0_40 版本)ArrayBlockingQueue 示例 ArrayBlockingQueue 介绍ArrayBlockingQueue 是数组实现的线程安全的有界的阻塞队列。线程安全是指，ArrayBlockingQueue 内部通过 “互斥锁” 保护竞争资源，实现了多线程对竞争资源的互斥访问。而有界，则是指 ArrayBlockingQueue 对应的数组是有界限的。 阻塞队列，是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待；而且，ArrayBlockingQueue 是按 FIFO（先进先出）原则对元素进行排序，元素都是从尾部插入到队列，从头部开始返回。 注意：ArrayBlockingQueue 不同于 ConcurrentLinkedQueue，ArrayBlockingQueue 是数组实现的，并且是有界限的；而 ConcurrentLinkedQueue 是链表实现的，是无界限的。 ArrayBlockingQueue 原理和数据结构ArrayBlockingQueue 的数据结构，如下图所示： 说明： 1. ArrayBlockingQueue 继承于 AbstractQueue，并且它实现了 BlockingQueue 接口。 2. ArrayBlockingQueue 内部是通过 Object[] 数组保存数据的，也就是说 ArrayBlockingQueue 本质上是通过数组实现的。ArrayBlockingQueue 的大小，即数组的容量是创建 ArrayBlockingQueue 时指定的。 3. ArrayBlockingQueue 与 ReentrantLock 是组合关系，ArrayBlockingQueue 中包含一个 ReentrantLock 对象 (lock)。ReentrantLock 是可重入的互斥锁，ArrayBlockingQueue 就是根据该互斥锁实现 “多线程对竞争资源的互斥访问”。而且，ReentrantLock 分为公平锁和非公平锁，关于具体使用公平锁还是非公平锁，在创建 ArrayBlockingQueue 时可以指定；而且，ArrayBlockingQueue 默认会使用非公平锁。 4. ArrayBlockingQueue 与 Condition 是组合关系，ArrayBlockingQueue 中包含两个 Condition 对象 (notEmpty 和 notFull)。而且，Condition 又依赖于 ArrayBlockingQueue 而存在，通过 Condition 可以实现对 ArrayBlockingQueue 的更精确的访问 – (01) 若某线程 (线程 A) 要取数据时，数组正好为空，则该线程会执行 notEmpty.await()进行等待；当其它某个线程 (线程 B) 向数组中插入了数据之后，会调用 notEmpty.signal()唤醒 “notEmpty 上的等待线程”。此时，线程 A 会被唤醒从而得以继续运行。(02) 若某线程 (线程 H) 要插入数据时，数组已满，则该线程会它执行 notFull.await()进行等待；当其它某个线程 (线程 I) 取出数据之后，会调用 notFull.signal()唤醒“notFull 上的等待线程”。此时，线程 H 就会被唤醒从而得以继续运行。 关于 ReentrantLock，公平锁，非公平锁，以及 Condition 等更多的内容，可以参考： (01) Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock (02) Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) (03) Java 多线程系列 –“JUC 锁”04 之 公平锁 (二) (04) Java 多线程系列 –“JUC 锁”05 之 非公平锁 (05) Java 多线程系列 –“JUC 锁”06 之 Condition 条件 ArrayBlockingQueue 函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445// 创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。ArrayBlockingQueue(int capacity)// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。ArrayBlockingQueue(int capacity, boolean fair)// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c)// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException。boolean add(E e)// 自动移除此队列中的所有元素。void clear()// 如果此队列包含指定的元素，则返回 true。boolean contains(Object o)// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c)// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c, int maxElements)// 返回在此队列中的元素上按适当顺序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false。boolean offer(E e)// 将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间。boolean offer(E e, long timeout, TimeUnit unit)// 获取但不移除此队列的头；如果此队列为空，则返回 null。E peek()// 获取并移除此队列的头，如果此队列为空，则返回 null。E poll()// 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。E poll(long timeout, TimeUnit unit)// 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间。void put(E e)// 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的其他元素数量。int remainingCapacity()// 从此队列中移除指定元素的单个实例（如果存在）。boolean remove(Object o)// 返回此队列中元素的数量。int size()// 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。E take()// 返回一个按适当顺序包含此队列中所有元素的数组。Object[] toArray()// 返回一个按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a)// 返回此 collection 的字符串表示形式。String toString() ArrayBlockingQueue 源码分析 (JDK1.7.0_40 版本)ArrayBlockingQueue.java 的完整源码如下： ArrayBlockingQueue.java 的完整源码 下面从 ArrayBlockingQueue 的创建，添加，取出，遍历这几个方面对 ArrayBlockingQueue 进行分析。 1. 创建 下面以 ArrayBlockingQueue(int capacity, boolean fair) 来进行说明。 12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 说明：(01) items 是保存 “阻塞队列” 数据的数组。它的定义如下： final Object[] items; (02) fair 是 “可重入的独占锁(ReentrantLock)” 的类型。fair 为 true，表示是公平锁；fair 为 false，表示是非公平锁。notEmpty 和 notFull 是锁的两个 Condition 条件。它们的定义如下： final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull; 简单对 Condition 和 Lock 的用法进行说明，更多内容请参考 “Java 多线程系列 –“JUC 锁”06 之 Condition 条件”。Lock 的作用是提供独占锁机制，来保护竞争资源；而 Condition 是为了更加精细的对锁进行控制，它依赖于 Lock，通过某个条件对多线程进行控制。notEmpty 表示 “锁的非空条件”。当某线程想从队列中取数据时，而此时又没有数据，则该线程通过 notEmpty.await() 进行等待；当其它线程向队列中插入了元素之后，就调用 notEmpty.signal()唤醒 “之前通过 notEmpty.await() 进入等待状态的线程”。同理，notFull 表示 “锁的满条件”。当某线程想向队列中插入元素，而此时队列已满时，该线程等待；当其它线程从队列中取出元素之后，就唤醒该等待的线程。 2. 添加 下面以 offer(E e) 为例，对 ArrayBlockingQueue 的添加方法进行说明。 1234567891011121314151617181920public boolean offer(E e) &#123; // 创建插入的元素是否为null，是的话抛出NullPointerException异常 checkNotNull(e); // 获取“该阻塞队列的独占锁” final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 如果队列已满，则返回false。 if (count == items.length) return false; else &#123; // 如果队列未满，则插入e，并返回true。 insert(e); return true; &#125; &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 说明：offer(E e) 的作用是将 e 插入阻塞队列的尾部。如果队列已满，则返回 false，表示插入失败；否则，插入元素，并返回 true。(01) count 表示” 队列中的元素个数 “。除此之外，队列中还有另外两个遍历 takeIndex 和 putIndex。takeIndex 表示下一个被取出元素的索引，putIndex 表示下一个被添加元素的索引。它们的定义如下： 123456// 队列中的元素个数int takeIndex;// 下一个被取出元素的索引int putIndex;// 下一个被添加元素的索引int count; (02) insert() 的源码如下： 12345678910private void insert(E x) &#123; // 将x添加到”队列“中 items[putIndex] = x; // 设置”下一个被取出元素的索引“ putIndex = inc(putIndex); // 将”队列中的元素个数”+1 ++count; // 唤醒notEmpty上的等待线程 notEmpty.signal();&#125; insert() 在插入元素之后，会唤醒 notEmpty 上面的等待线程。 inc() 的源码如下： 123final int inc(int i) &#123; return (++i == items.length) ? 0 : i;&#125; 若 i+1 的值等于 “队列的长度”，即添加元素之后，队列满；则设置“下一个被添加元素的索引” 为 0。 3. 取出 下面以 take() 为例，对 ArrayBlockingQueue 的取出方法进行说明。 12345678910111213141516public E take() throws InterruptedException &#123; // 获取“队列的独占锁” final ReentrantLock lock = this.lock; // 获取“锁”，若当前线程是中断状态，则抛出InterruptedException异常 lock.lockInterruptibly(); try &#123; // 若“队列为空”，则一直等待。 while (count == 0) notEmpty.await(); // 取出元素 return extract(); &#125; finally &#123; // 释放“锁” lock.unlock(); &#125;&#125; 说明：take() 的作用是取出并返回队列的头。若队列为空，则一直等待。 extract() 的源码如下： 1234567891011121314private E extract() &#123; final Object[] items = this.items; // 强制将元素转换为“泛型E” E x = this.&lt;E&gt;cast(items[takeIndex]); // 将第takeIndex元素设为null，即删除。同时，帮助GC回收。 items[takeIndex] = null; // 设置“下一个被取出元素的索引” takeIndex = inc(takeIndex); // 将“队列中元素数量”-1 --count; // 唤醒notFull上的等待线程。 notFull.signal(); return x;&#125; 说明：extract() 在删除元素之后，会唤醒 notFull 上的等待线程。 4. 遍历 下面对 ArrayBlockingQueue 的遍历方法进行说明。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; Itr 是实现了 Iterator 接口的类，它的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private class Itr implements Iterator&lt;E&gt; &#123; // 队列中剩余元素的个数 private int remaining; // Number of elements yet to be returned // 下一次调用next()返回的元素的索引 private int nextIndex; // Index of element to be returned by next // 下一次调用next()返回的元素 private E nextItem; // Element to be returned by next call to next // 上一次调用next()返回的元素 private E lastItem; // Element returned by last call to next // 上一次调用next()返回的元素的索引 private int lastRet; // Index of last element returned, or -1 if none Itr() &#123; // 获取“阻塞队列”的锁 final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; lastRet = -1; if ((remaining = count) &gt; 0) nextItem = itemAt(nextIndex = takeIndex); &#125; finally &#123; // 释放“锁” lock.unlock(); &#125; &#125; public boolean hasNext() &#123; return remaining &gt; 0; &#125; public E next() &#123; // 获取“阻塞队列”的锁 final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; // 若“剩余元素&lt;=0”，则抛出异常。 if (remaining &lt;= 0) throw new NoSuchElementException(); lastRet = nextIndex; // 获取第nextIndex位置的元素 E x = itemAt(nextIndex); // check for fresher value if (x == null) &#123; x = nextItem; // we are forced to report old value lastItem = null; // but ensure remove fails &#125; else lastItem = x; while (--remaining &gt; 0 &amp;&amp; // skip over nulls (nextItem = itemAt(nextIndex = inc(nextIndex))) == null) ; return x; &#125; finally &#123; lock.unlock(); &#125; &#125; public void remove() &#123; final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; int i = lastRet; if (i == -1) throw new IllegalStateException(); lastRet = -1; E x = lastItem; lastItem = null; // only remove if item still at index if (x != null &amp;&amp; x == items[i]) &#123; boolean removingHead = (i == takeIndex); removeAt(i); if (!removingHead) nextIndex = dec(nextIndex); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; ArrayBlockingQueue 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * ArrayBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是ArrayBlockingQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ArrayBlockingQueueDemo1&#123; // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(20); public static void main(String[] args) &#123; // 同时启动两个线程对queue进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value; Iterator iter = queue.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112ta1, ta1, tb1, ta1, tb1, ta1, ta2, tb1, ta1, ta2, tb1, tb2, ta2, ta1, tb2, tb1, ta3, ta2, ta1, tb2, tb1, ta3, ta2, tb3, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, tb4, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, tb5, tb3, ta1, ta4, tb1, tb4, ta2, ta5, tb2, tb5, ta3, ta6, tb3, ta4, tb4, ta5, tb5, ta6, tb6, 结果说明：如果将源码中的 queue 改成 LinkedList 对象时，程序会产生 ConcurrentModificationException 异常。 08 LinkedBlockingQueue概要本章介绍 JUC 包中的 LinkedBlockingQueue。内容包括：LinkedBlockingQueue 介绍LinkedBlockingQueue 原理和数据结构LinkedBlockingQueue 函数列表LinkedBlockingQueue 源码分析 (JDK1.7.0_40 版本)LinkedBlockingQueue 示例 LinkedBlockingQueue 介绍LinkedBlockingQueue 是一个单向链表实现的阻塞队列。该队列按 FIFO（先进先出）排序元素，新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 此外，LinkedBlockingQueue 还是可选容量的 (防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于 Integer.MAX_VALUE。 LinkedBlockingQueue 原理和数据结构LinkedBlockingQueue 的数据结构，如下图所示： 说明：1. LinkedBlockingQueue 继承于 AbstractQueue，它本质上是一个 FIFO(先进先出) 的队列。2. LinkedBlockingQueue 实现了 BlockingQueue 接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。3. LinkedBlockingQueue 是通过单链表实现的。(01) head 是链表的表头。取出数据时，都是从表头 head 处插入。(02) last 是链表的表尾。新增数据时，都是从表尾 last 处插入。(03) count 是链表的实际大小，即当前链表中包含的节点个数。(04) capacity 是列表的容量，它是在创建链表时指定的。(05) putLock 是插入锁，takeLock 是取出锁；notEmpty 是 “非空条件”，notFull 是 “未满条件”。通过它们对链表进行并发控制。 LinkedBlockingQueue 在实现 “多线程对竞争资源的互斥访问” 时，对于 “插入” 和“取出 (删除)” 操作分别使用了不同的锁。对于插入操作，通过 “插入锁 putLock” 进行同步；对于取出操作，通过 “取出锁 takeLock” 进行同步。 此外，插入锁 putLock 和 “非满条件 notFull” 相关联，取出锁 takeLock 和 “非空条件 notEmpty” 相关联。通过 notFull 和 notEmpty 更细腻的控制锁。 – 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。 – 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。 关于 ReentrantLock 和 Condition 等更多的内容，可以参考： (01) Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock (02) Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) (03) Java 多线程系列 –“JUC 锁”04 之 公平锁 (二) (04) Java 多线程系列 –“JUC 锁”05 之 非公平锁 (05) Java 多线程系列 –“JUC 锁”06 之 Condition 条件 LinkedBlockingQueue 函数列表1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue。LinkedBlockingQueue()// 创建一个容量是 Integer.MAX_VALUE 的 LinkedBlockingQueue，最初包含给定 collection 的元素，元素按该 collection 迭代器的遍历顺序添加。LinkedBlockingQueue(Collection&lt;? extends E&gt; c)// 创建一个具有给定（固定）容量的 LinkedBlockingQueue。LinkedBlockingQueue(int capacity)// 从队列彻底移除所有元素。void clear()// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c)// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c, int maxElements)// 返回在队列中的元素上按适当顺序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 将指定元素插入到此队列的尾部（如果立即可行且不会超出此队列的容量），在成功时返回 true，如果此队列已满，则返回 false。boolean offer(E e)// 将指定元素插入到此队列的尾部，如有必要，则等待指定的时间以使空间变得可用。boolean offer(E e, long timeout, TimeUnit unit)// 获取但不移除此队列的头；如果此队列为空，则返回 null。E peek()// 获取并移除此队列的头，如果此队列为空，则返回 null。E poll()// 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。E poll(long timeout, TimeUnit unit)// 将指定元素插入到此队列的尾部，如有必要，则等待空间变得可用。void put(E e)// 返回理想情况下（没有内存和资源约束）此队列可接受并且不会被阻塞的附加元素数量。int remainingCapacity()// 从此队列移除指定元素的单个实例（如果存在）。boolean remove(Object o)// 返回队列中的元素个数。int size()// 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。E take()// 返回按适当顺序包含此队列中所有元素的数组。Object[] toArray()// 返回按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a)// 返回此 collection 的字符串表示形式。String toString() LinkedBlockingQueue 源码分析 (JDK1.7.0_40 版本)LinkedBlockingQueue.java 的完整源码如下： LinkedBlockingQueue.java 的完整源码下面从 LinkedBlockingQueue 的创建，添加，删除，遍历这几个方面对它进行分析。 1. 创建 下面以 LinkedBlockingQueue(int capacity) 来进行说明。 12345public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null);&#125; 说明：(01) capacity 是 “链式阻塞队列” 的容量。(02) head 和 last 是 “链式阻塞队列” 的首节点和尾节点。它们在 LinkedBlockingQueue 中的声明如下： 123456789101112// 容量private final int capacity;// 当前数量private final AtomicInteger count = new AtomicInteger(0);private transient Node&lt;E&gt; head; // 链表的表头private transient Node&lt;E&gt; last; // 链表的表尾// 用于控制“删除元素”的互斥锁takeLock 和 锁对应的“非空条件”notEmptyprivate final ReentrantLock takeLock = new ReentrantLock();private final Condition notEmpty = takeLock.newCondition();// 用于控制“添加元素”的互斥锁putLock 和 锁对应的“非满条件”notFullprivate final ReentrantLock putLock = new ReentrantLock();private final Condition notFull = putLock.newCondition(); 链表的节点定义如下： 123456static class Node&lt;E&gt; &#123; E item; // 数据 Node&lt;E&gt; next; // 下一个节点的指针 Node(E x) &#123; item = x; &#125;&#125; 2. 添加 下面以 offer(E e) 为例，对 LinkedBlockingQueue 的添加方法进行说明。 123456789101112131415161718192021222324252627282930313233public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); // 如果“队列已满”，则返回false，表示插入失败。 final AtomicInteger count = this.count; if (count.get() == capacity) return false; int c = -1; // 新建“节点e” Node&lt;E&gt; node = new Node(e); final ReentrantLock putLock = this.putLock; // 获取“插入锁putLock” putLock.lock(); try &#123; // 再次对“队列是不是满”的进行判断。 // 若“队列未满”，则插入节点。 if (count.get() &lt; capacity) &#123; // 插入节点 enqueue(node); // 将“当前节点数量”+1，并返回“原始的数量” c = count.getAndIncrement(); // 如果在插入元素之后，队列仍然未满，则唤醒notFull上的等待线程。 if (c + 1 &lt; capacity) notFull.signal(); &#125; &#125; finally &#123; // 释放“插入锁putLock” putLock.unlock(); &#125; // 如果在插入节点前，队列为空；则插入节点后，唤醒notEmpty上的等待线程 if (c == 0) signalNotEmpty(); return c &gt;= 0;&#125; 说明：offer() 的作用很简单，就是将元素 E 添加到队列的末尾。 enqueue() 的源码如下： 12345private void enqueue(Node&lt;E&gt; node) &#123; // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node;&#125; enqueue() 的作用是将 node 添加到队列末尾，并设置 node 为新的尾节点！ signalNotEmpty() 的源码如下： 123456789private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125; signalNotEmpty() 的作用是唤醒 notEmpty 上的等待线程。 3. 取出 下面以 take() 为例，对 LinkedBlockingQueue 的取出方法进行说明。 123456789101112131415161718192021222324252627public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; // 获取“取出锁”，若当前线程是中断状态，则抛出InterruptedException异常 takeLock.lockInterruptibly(); try &#123; // 若“队列为空”，则一直等待。 while (count.get() == 0) &#123; notEmpty.await(); &#125; // 取出元素 x = dequeue(); // 取出元素之后，将“节点数量”-1；并返回“原始的节点数量”。 c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; // 释放“取出锁” takeLock.unlock(); &#125; // 如果在“取出元素之前”，队列是满的；则在取出元素之后，唤醒notFull上的等待线程。 if (c == capacity) signalNotFull(); return x;&#125; 说明：take() 的作用是取出并返回队列的头。若队列为空，则一直等待。 dequeue() 的源码如下： 1234567891011private E dequeue() &#123; // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x;&#125; dequeue() 的作用就是删除队列的头节点，并将表头指向 “原头节点的下一个节点”。 signalNotFull() 的源码如下： 123456789private void signalNotFull() &#123; final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125;&#125; signalNotFull() 的作用就是唤醒 notFull 上的等待线程。 4. 遍历 下面对 LinkedBlockingQueue 的遍历方法进行说明。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; iterator() 实际上是返回一个 Iter 对象。 Itr 类的定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private class Itr implements Iterator&lt;E&gt; &#123; // 当前节点 private Node&lt;E&gt; current; // 上一次返回的节点 private Node&lt;E&gt; lastRet; // 当前节点对应的值 private E currentElement; Itr() &#123; // 同时获取“插入锁putLock” 和 “取出锁takeLock” fullyLock(); try &#123; // 设置“当前元素”为“队列表头的下一节点”，即为队列的第一个有效节点 current = head.next; if (current != null) currentElement = current.item; &#125; finally &#123; // 释放“插入锁putLock” 和 “取出锁takeLock” fullyUnlock(); &#125; &#125; // 返回“下一个节点是否为null” public boolean hasNext() &#123; return current != null; &#125; private Node&lt;E&gt; nextNode(Node&lt;E&gt; p) &#123; for (;;) &#123; Node&lt;E&gt; s = p.next; if (s == p) return head.next; if (s == null || s.item != null) return s; p = s; &#125; &#125; // 返回下一个节点 public E next() &#123; fullyLock(); try &#123; if (current == null) throw new NoSuchElementException(); E x = currentElement; lastRet = current; current = nextNode(current); currentElement = (current == null) ? null : current.item; return x; &#125; finally &#123; fullyUnlock(); &#125; &#125; // 删除下一个节点 public void remove() &#123; if (lastRet == null) throw new IllegalStateException(); fullyLock(); try &#123; Node&lt;E&gt; node = lastRet; lastRet = null; for (Node&lt;E&gt; trail = head, p = trail.next; p != null; trail = p, p = p.next) &#123; if (p == node) &#123; unlink(p, trail); break; &#125; &#125; &#125; finally &#123; fullyUnlock(); &#125; &#125;&#125; LinkedBlockingQueue 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import java.util.*;import java.util.concurrent.*;/* * LinkedBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是LinkedBlockingQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class LinkedBlockingQueueDemo1 &#123; // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对queue进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value; Iterator iter = queue.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112tb1, ta1, tb1, ta1, ta2, tb1, ta1, ta2, ta3, tb1, ta1, ta2, ta3, ta4, tb1, ta1, tb1, ta2, ta1, ta3, ta2, ta4, ta3, ta5, ta4, tb1, ta5, ta1, ta6, ta2, tb1, ta3, ta1, ta4, ta2, ta5, ta3, ta6, ta4, tb2, ta5, ta6, tb2, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb5, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb5, tb6, 结果说明：示例程序中，启动两个线程 (线程 ta 和线程 tb) 分别对 LinkedBlockingQueue 进行操作。以线程 ta 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 LinkedBlockingQueue 中；接着，遍历并输出 LinkedBlockingQueue 中的全部元素。 线程 tb 的操作和线程 ta 一样，只不过线程 tb 的名字和线程 ta 的名字不同。当 queue 是 LinkedBlockingQueue 对象时，程序能正常运行。如果将 queue 改为 LinkedList 时，程序会产生 ConcurrentModificationException 异常。 09 LinkedBlockingDeque概要本章介绍 JUC 包中的 LinkedBlockingDeque。内容包括：LinkedBlockingDeque 介绍LinkedBlockingDeque 原理和数据结构LinkedBlockingDeque 函数列表LinkedBlockingDeque 源码分析 (JDK1.7.0_40 版本)LinkedBlockingDeque 示例 LinkedBlockingDeque 介绍LinkedBlockingDeque 是双向链表实现的双向并发阻塞队列。该阻塞队列同时支持 FIFO 和 FILO 两种操作方式，即可以从队列的头和尾同时操作 (插入 / 删除)；并且，该阻塞队列是支持线程安全。 此外，LinkedBlockingDeque 还是可选容量的 (防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于 Integer.MAX_VALUE。 LinkedBlockingDeque 原理和数据结构LinkedBlockingDeque 的数据结构，如下图所示： 说明：1. LinkedBlockingDeque 继承于 AbstractQueue，它本质上是一个支持 FIFO 和 FILO 的双向的队列。2. LinkedBlockingDeque 实现了 BlockingDeque 接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。3. LinkedBlockingDeque 是通过双向链表实现的。3.1 first 是双向链表的表头。3.2 last 是双向链表的表尾。3.3 count 是 LinkedBlockingDeque 的实际大小，即双向链表中当前节点个数。3.4 capacity 是 LinkedBlockingDeque 的容量，它是在创建 LinkedBlockingDeque 时指定的。3.5 lock 是控制对 LinkedBlockingDeque 的互斥锁，当多个线程竞争同时访问 LinkedBlockingDeque 时，某线程获取到了互斥锁 lock，其它线程则需要阻塞等待，直到该线程释放 lock，其它线程才有机会获取 lock 从而获取 cpu 执行权。3.6 notEmpty 和 notFull 分别是 “非空条件” 和“未满条件”。通过它们能够更加细腻进行并发控制。 – 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。– 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。 关于 ReentrantLock 和 Condition 等更多的内容，可以参考： (01) Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock (02) Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) (03) Java 多线程系列 –“JUC 锁”04 之 公平锁 (二) (04) Java 多线程系列 –“JUC 锁”05 之 非公平锁 (05) Java 多线程系列 –“JUC 锁”06 之 Condition 条件 LinkedBlockingDeque 函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingDeque。LinkedBlockingDeque()// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingDeque，最初包含给定 collection 的元素，以该 collection 迭代器的遍历顺序添加。LinkedBlockingDeque(Collection&lt;? extends E&gt; c)// 创建一个具有给定（固定）容量的 LinkedBlockingDeque。LinkedBlockingDeque(int capacity)// 在不违反容量限制的情况下，将指定的元素插入此双端队列的末尾。boolean add(E e)// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头；如果当前没有空间可用，则抛出 IllegalStateException。void addFirst(E e)// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾；如果当前没有空间可用，则抛出 IllegalStateException。void addLast(E e)// 以原子方式 (atomically) 从此双端队列移除所有元素。void clear()// 如果此双端队列包含指定的元素，则返回 true。boolean contains(Object o)// 返回在此双端队列的元素上以逆向连续顺序进行迭代的迭代器。Iterator&lt;E&gt; descendingIterator()// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c)// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c, int maxElements)// 获取但不移除此双端队列表示的队列的头部。E element()// 获取，但不移除此双端队列的第一个元素。E getFirst()// 获取，但不移除此双端队列的最后一个元素。E getLast()// 返回在此双端队列元素上以恰当顺序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），并在成功时返回 true；如果当前没有空间可用，则返回 false。boolean offer(E e)// 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将在指定的等待时间内一直等待可用空间。boolean offer(E e, long timeout, TimeUnit unit)// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头，并在成功时返回 true；如果当前没有空间可用，则返回 false。boolean offerFirst(E e)// 将指定的元素插入此双端队列的开头，必要时将在指定的等待时间内等待可用空间。boolean offerFirst(E e, long timeout, TimeUnit unit)// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾，并在成功时返回 true；如果当前没有空间可用，则返回 false。boolean offerLast(E e)// 将指定的元素插入此双端队列的末尾，必要时将在指定的等待时间内等待可用空间。boolean offerLast(E e, long timeout, TimeUnit unit)// 获取但不移除此双端队列表示的队列的头部（即此双端队列的第一个元素）；如果此双端队列为空，则返回 null。E peek()// 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。E peekFirst()// 获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。E peekLast()// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素）；如果此双端队列为空，则返回 null。E poll()// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），如有必要将在指定的等待时间内等待可用元素。E poll(long timeout, TimeUnit unit)// 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。E pollFirst()// 获取并移除此双端队列的第一个元素，必要时将在指定的等待时间等待可用元素。E pollFirst(long timeout, TimeUnit unit)// 获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。E pollLast()// 获取并移除此双端队列的最后一个元素，必要时将在指定的等待时间内等待可用元素。E pollLast(long timeout, TimeUnit unit)// 从此双端队列所表示的堆栈中弹出一个元素。E pop()// 将元素推入此双端队列表示的栈。void push(E e)// 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将一直等待可用空间。void put(E e)// 将指定的元素插入此双端队列的开头，必要时将一直等待可用空间。void putFirst(E e)// 将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间。void putLast(E e)// 返回理想情况下（没有内存和资源约束）此双端队列可不受阻塞地接受的额外元素数。int remainingCapacity()// 获取并移除此双端队列表示的队列的头部。E remove()// 从此双端队列移除第一次出现的指定元素。boolean remove(Object o)// 获取并移除此双端队列第一个元素。E removeFirst()// 从此双端队列移除第一次出现的指定元素。boolean removeFirstOccurrence(Object o)// 获取并移除此双端队列的最后一个元素。E removeLast()// 从此双端队列移除最后一次出现的指定元素。boolean removeLastOccurrence(Object o)// 返回此双端队列中的元素数。int size()// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），必要时将一直等待可用元素。E take()// 获取并移除此双端队列的第一个元素，必要时将一直等待可用元素。E takeFirst()// 获取并移除此双端队列的最后一个元素，必要时将一直等待可用元素。E takeLast()// 返回以恰当顺序（从第一个元素到最后一个元素）包含此双端队列所有元素的数组。Object[] toArray()// 返回以恰当顺序包含此双端队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a)// 返回此 collection 的字符串表示形式。String toString() LinkedBlockingDeque 源码分析 (JDK1.7.0_40 版本)LinkedBlockingDeque.java 的完整源码如下： LinkedBlockingDeque.java 的完整源码 下面从 ArrayBlockingQueue 的创建，添加，取出，遍历这几个方面对 LinkedBlockingDeque 进行分析 1. 创建 下面以 LinkedBlockingDeque(int capacity) 来进行说明。 1234public LinkedBlockingDeque(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity;&#125; 说明：capacity 是 “链式阻塞队列” 的容量。 LinkedBlockingDeque 中相关的数据结果定义如下： 123456789101112// “双向队列”的表头transient Node&lt;E&gt; first;// “双向队列”的表尾transient Node&lt;E&gt; last;// 节点数量private transient int count;// 容量private final int capacity;// 互斥锁 , 互斥锁对应的“非空条件notEmpty”, 互斥锁对应的“未满条件notFull”final ReentrantLock lock = new ReentrantLock();private final Condition notEmpty = lock.newCondition();private final Condition notFull = lock.newCondition(); 说明：lock 是互斥锁，用于控制多线程对 LinkedBlockingDeque 中元素的互斥访问；而 notEmpty 和 notFull 是与 lock 绑定的条件，它们用于实现对多线程更精确的控制。 双向链表的节点 Node 的定义如下： 1234567static final class Node&lt;E&gt; &#123; E item; // 数据 Node&lt;E&gt; prev; // 前一节点 Node&lt;E&gt; next; // 后一节点 Node(E x) &#123; item = x; &#125;&#125; 2. 添加 下面以 offer(E e) 为例，对 LinkedBlockingDeque 的添加方法进行说明。 123public boolean offer(E e) &#123; return offerLast(e);&#125; offer() 实际上是调用 offerLast() 将元素添加到队列的末尾。 offerLast() 的源码如下： 123456789101112131415public boolean offerLast(E e) &#123; if (e == null) throw new NullPointerException(); // 新建节点 Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try &#123; // 将“新节点”添加到双向链表的末尾 return linkLast(node); &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 说明：offerLast() 的作用，是新建节点并将该节点插入到双向链表的末尾。它在插入节点前，会获取锁；操作完毕，再释放锁。 linkLast() 的源码如下： 123456789101112131415161718private boolean linkLast(Node&lt;E&gt; node) &#123; // 如果“双向链表的节点数量” &gt; “容量”，则返回false，表示插入失败。 if (count &gt;= capacity) return false; // 将“node添加到链表末尾”，并设置node为新的尾节点 Node&lt;E&gt; l = last; node.prev = l; last = node; if (first == null) first = node; else l.next = node; // 将“节点数量”+1 ++count; // 插入节点之后，唤醒notEmpty上的等待线程。 notEmpty.signal(); return true;&#125; 说明：linkLast() 的作用，是将节点插入到双向队列的末尾；插入节点之后，唤醒 notEmpty 上的等待线程。 3. 删除 下面以 take() 为例，对 LinkedBlockingDeque 的取出方法进行说明。 123public E take() throws InterruptedException &#123; return takeFirst();&#125; take() 实际上是调用 takeFirst() 队列的第一个元素。 takeFirst() 的源码如下： 123456789101112131415public E takeFirst() throws InterruptedException &#123; final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try &#123; E x; // 若“队列为空”，则一直等待。否则，通过unlinkFirst()删除第一个节点。 while ( (x = unlinkFirst()) == null) notEmpty.await(); return x; &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 说明：takeFirst() 的作用，是删除双向链表的第一个节点，并返回节点对应的值。它在插入节点前，会获取锁；操作完毕，再释放锁。 unlinkFirst() 的源码如下： 123456789101112131415161718192021private E unlinkFirst() &#123; // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; f = first; if (f == null) return null; // 删除并更新“第一个节点” Node&lt;E&gt; n = f.next; E item = f.item; f.item = null; f.next = f; // help GC first = n; if (n == null) last = null; else n.prev = null; // 将“节点数量”-1 --count; // 删除节点之后，唤醒notFull上的等待线程。 notFull.signal(); return item;&#125; 说明：unlinkFirst() 的作用，是将双向队列的第一个节点删除；删除节点之后，唤醒 notFull 上的等待线程。 4. 遍历 下面对 LinkedBlockingDeque 的遍历方法进行说明。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; iterator() 实际上是返回一个 Iter 对象。 Itr 类的定义如下： 123456private class Itr extends AbstractItr &#123; // “双向队列”的表头 Node&lt;E&gt; firstNode() &#123; return first; &#125; // 获取“节点n的下一个节点” Node&lt;E&gt; nextNode(Node&lt;E&gt; n) &#123; return n.next; &#125;&#125; Itr 继承于 AbstractItr，而 AbstractItr 的定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private abstract class AbstractItr implements Iterator&lt;E&gt; &#123; // next是下一次调用next()会返回的节点。 Node&lt;E&gt; next; // nextItem是next()返回节点对应的数据。 E nextItem; // 上一次next()返回的节点。 private Node&lt;E&gt; lastRet; // 返回第一个节点 abstract Node&lt;E&gt; firstNode(); // 返回下一个节点 abstract Node&lt;E&gt; nextNode(Node&lt;E&gt; n); AbstractItr() &#123; final ReentrantLock lock = LinkedBlockingDeque.this.lock; // 获取“LinkedBlockingDeque的互斥锁” lock.lock(); try &#123; // 获取“双向队列”的表头 next = firstNode(); // 获取表头对应的数据 nextItem = (next == null) ? null : next.item; &#125; finally &#123; // 释放“LinkedBlockingDeque的互斥锁” lock.unlock(); &#125; &#125; // 获取n的后继节点 private Node&lt;E&gt; succ(Node&lt;E&gt; n) &#123; // Chains of deleted nodes ending in null or self-links // are possible if multiple interior nodes are removed. for (;;) &#123; Node&lt;E&gt; s = nextNode(n); if (s == null) return null; else if (s.item != null) return s; else if (s == n) return firstNode(); else n = s; &#125; &#125; // 更新next和nextItem。 void advance() &#123; final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try &#123; // assert next != null; next = succ(next); nextItem = (next == null) ? null : next.item; &#125; finally &#123; lock.unlock(); &#125; &#125; // 返回“下一个节点是否为null” public boolean hasNext() &#123; return next != null; &#125; // 返回下一个节点 public E next() &#123; if (next == null) throw new NoSuchElementException(); lastRet = next; E x = nextItem; advance(); return x; &#125; // 删除下一个节点 public void remove() &#123; Node&lt;E&gt; n = lastRet; if (n == null) throw new IllegalStateException(); lastRet = null; final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try &#123; if (n.item != null) unlink(n); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; LinkedBlockingDeque 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * LinkedBlockingDeque是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是LinkedBlockingDeque对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class LinkedBlockingDequeDemo1 &#123; // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new LinkedBlockingDeque&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对queue进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value; Iterator iter = queue.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112ta1, ta1, tb1, tb1,ta1, ta1, tb1, tb1, tb2, tb2, ta2, ta2, ta1, ta1, tb1, tb1, tb2, tb2, ta2, ta2, tb3, tb3, ta3, ta3, ta1, tb1, ta1, tb2, tb1, ta2, tb2, tb3, ta2, ta3, tb3, tb4, ta3, ta4, tb4, ta1, ta4, tb1, tb5, tb2, ta1, ta2, tb1, tb3, tb2, ta3, ta2, tb4, tb3, ta4, ta3, tb5, tb4, ta5, ta4, ta1, tb5, tb1, ta5, tb2, tb6, ta2, ta1, tb3, tb1, ta3, tb2, tb4, ta2, ta4, tb3, tb5, ta3, ta5, tb4, tb6, ta4, ta6, tb5, ta5, tb6, ta6, 结果说明：示例程序中，启动两个线程 (线程 ta 和线程 tb) 分别对 LinkedBlockingDeque 进行操作。以线程 ta 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 LinkedBlockingDeque 中；接着，遍历并输出 LinkedBlockingDeque 中的全部元素。 线程 tb 的操作和线程 ta 一样，只不过线程 tb 的名字和线程 ta 的名字不同。当 queue 是 LinkedBlockingDeque 对象时，程序能正常运行。如果将 queue 改为 LinkedList 时，程序会产生 ConcurrentModificationException 异常。 10 ConcurrentLinkedQueue概要本章对 Java.util.concurrent 包中的 ConcurrentHashMap 类进行详细的介绍。内容包括：ConcurrentLinkedQueue 介绍ConcurrentLinkedQueue 原理和数据结构ConcurrentLinkedQueue 函数列表ConcurrentLinkedQueue 源码分析 (JDK1.7.0_40 版本)ConcurrentLinkedQueue 示例 ConcurrentLinkedQueue 介绍ConcurrentLinkedQueue 是线程安全的队列，它适用于 “高并发” 的场景。它是一个基于链接节点的无界线程安全队列，按照 FIFO（先进先出）原则对元素进行排序。队列元素中不可以放置 null 元素（内部实现的特殊节点除外）。 ConcurrentLinkedQueue 原理和数据结构ConcurrentLinkedQueue 的数据结构，如下图所示： 说明：1. ConcurrentLinkedQueue 继承于 AbstractQueue。2. ConcurrentLinkedQueue 内部是通过链表来实现的。它同时包含链表的头节点 head 和尾节点 tail。ConcurrentLinkedQueue 按照 FIFO（先进先出）原则对元素进行排序。元素都是从尾部插入到链表，从头部开始返回。3. ConcurrentLinkedQueue 的链表 Node 中的 next 的类型是 volatile，而且链表数据 item 的类型也是 volatile。关于 volatile，我们知道它的语义包含：“即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”。ConcurrentLinkedQueue 就是通过 volatile 来实现多线程对竞争资源的互斥访问的。 ConcurrentLinkedQueue 函数列表123456789101112131415161718192021222324252627// 创建一个最初为空的 ConcurrentLinkedQueue。ConcurrentLinkedQueue()// 创建一个最初包含给定 collection 元素的 ConcurrentLinkedQueue，按照此 collection 迭代器的遍历顺序来添加元素。ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c)// 将指定元素插入此队列的尾部。boolean add(E e)// 如果此队列包含指定元素，则返回 true。boolean contains(Object o)// 如果此队列不包含任何元素，则返回 true。boolean isEmpty()// 返回在此队列元素上以恰当顺序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 将指定元素插入此队列的尾部。boolean offer(E e)// 获取但不移除此队列的头；如果此队列为空，则返回 null。E peek()// 获取并移除此队列的头，如果此队列为空，则返回 null。E poll()// 从队列中移除指定元素的单个实例（如果存在）。boolean remove(Object o)// 返回此队列中的元素数量。int size()// 返回以恰当顺序包含此队列所有元素的数组。Object[] toArray()// 返回以恰当顺序包含此队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a) ConcurrentLinkedQueue 源码分析 (JDK1.7.0_40 版本)ConcurrentLinkedQueue 的完整源码如下： ConcurrentLinkedQueue.java的完整源码 下面从 ConcurrentLinkedQueue 的创建，添加，删除这几个方面对它进行分析。 1 创建 下面以 ConcurrentLinkedQueue() 来进行说明。 123public ConcurrentLinkedQueue() &#123; head = tail = new Node&lt;E&gt;(null);&#125; 说明：在构造函数中，新建了一个 “内容为 null 的节点”，并设置表头 head 和表尾 tail 的值为新节点。 head 和 tail 的定义如下： 12private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail; head 和 tail 都是 volatile 类型，他们具有 volatile 赋予的含义：“即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”。 Node 的声明如下： 1234567891011121314151617181920212223242526272829303132333435363738private static class Node&lt;E&gt; &#123; volatile E item; volatile Node&lt;E&gt; next; Node(E item) &#123; UNSAFE.putObject(this, itemOffset, item); &#125; boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val); &#125; boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("item")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("next")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 说明：Node 是个单向链表节点，next 用于指向下一个 Node，item 用于存储数据。Node 中操作节点数据的 API，都是通过 Unsafe 机制的 CAS 函数实现的；例如 casNext() 是通过 CAS 函数 “比较并设置节点的下一个节点”。 2. 添加 下面以 add(E e) 为例对 ConcurrentLinkedQueue 中的添加进行说明。 123public boolean add(E e) &#123; return offer(e);&#125; 说明：add() 实际上是调用的 offer() 来完成添加操作的。 offer() 的源码如下： 12345678910111213141516171819202122232425262728public boolean offer(E e) &#123; // 检查e是不是null，是的话抛出NullPointerException异常。 checkNotNull(e); // 创建新的节点 final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); // 将“新的节点”添加到链表的末尾。 for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; // 情况1：q为空 if (q == null) &#123; // CAS操作：如果“p的下一个节点为null”(即p为尾节点)，则设置p的下一个节点为newNode。 // 如果该CAS操作成功的话，则比较“p和t”(若p不等于t，则设置newNode为新的尾节点)，然后返回true。 // 如果该CAS操作失败，这意味着“其它线程对尾节点进行了修改”，则重新循环。 if (p.casNext(null, newNode)) &#123; if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; &#125; &#125; // 情况2：p和q相等 else if (p == q) p = (t != (t = tail)) ? t : head; // 情况3：其它 else p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; 说明：offer(E e) 的作用就是将元素 e 添加到链表的末尾。offer() 比较的地方是理解 for 循环，下面区分 3 种情况对 for 进行分析。 情况 1 – q 为空。这意味着 q 是尾节点的下一个节点。此时，通过 p.casNext(null, newNode) 将 “p 的下一个节点设为 newNode”，若设置成功的话，则比较 “p 和 t”(若 p 不等于 t，则设置 newNode 为新的尾节点)，然后返回 true。否则的话 (意味着 “其它线程对尾节点进行了修改”)，什么也不做，继续进行 for 循环。p.casNext(null, newNode)，是调用 CAS 对 p 进行操作。若 “p 的下一个节点等于 null”，则设置 “p 的下一个节点等于 newNode”；设置成功的话，返回 true，失败的话返回 false。 情况 2 – p 和 q 相等。这种情况什么时候会发生呢？通过 “情况 3”，我们知道，经过“情况 3” 的处理后，p 的值可能等于 q。此时，若尾节点没有发生变化的话，那么，应该是头节点发生了变化，则设置 p 为头节点，然后重新遍历链表；否则 (尾节点变化的话)，则设置 p 为尾节点。 情况 3 – 其它。我们将 p = (p != t &amp;&amp; t != (t = tail)) ? t : q; 转换成如下代码。 1234567891011if (p==t) &#123; p = q;&#125; else &#123; Node&lt;E&gt; tmp=t; t = tail; if (tmp==t) &#123; p=q; &#125; else &#123; p=t; &#125;&#125; 如果 p 和 t 相等，则设置 p 为 q。否则的话，判断 “尾节点是否发生变化”，没有变化的话，则设置 p 为 q；否则，设置 p 为尾节点。 checkNotNull() 的源码如下： 1234private static void checkNotNull(Object v) &#123; if (v == null) throw new NullPointerException();&#125; 3. 删除 下面以 poll() 为例对 ConcurrentLinkedQueue 中的删除进行说明。 1234567891011121314151617181920212223242526272829303132public E poll() &#123; // 设置“标记” restartFromHead: for (;;) &#123; for (Node&lt;E&gt; h = head, p = h, q;;) &#123; E item = p.item; // 情况1 // 表头的数据不为null，并且“设置表头的数据为null”这个操作成功的话; // 则比较“p和h”(若p!=h，即表头发生了变化，则更新表头，即设置表头为p)，然后返回原表头的item值。 if (item != null &amp;&amp; p.casItem(item, null)) &#123; if (p != h) // hop two nodes at a time updateHead(h, ((q = p.next) != null) ? q : p); return item; &#125; // 情况2 // 表头的下一个节点为null，即链表只有一个“内容为null的表头节点”。则更新表头为p，并返回null。 else if ((q = p.next) == null) &#123; updateHead(h, p); return null; &#125; // 情况3 // 这可能到由于“情况4”的发生导致p=q，在该情况下跳转到restartFromHead标记重新操作。 else if (p == q) continue restartFromHead; // 情况4 // 设置p为q else p = q; &#125; &#125;&#125; 说明：poll() 的作用就是删除链表的表头节点，并返回被删节点对应的值。poll() 的实现原理和 offer() 比较类似，下面根将 or 循环划分为 4 种情况进行分析。 情况 1：“表头节点的数据”不为 null，并且 “设置表头节点的数据为 null” 这个操作成功。p.casItem(item, null) – 调用 CAS 函数，比较 “节点 p 的数据值” 与 item 是否相等，是的话，设置节点 p 的数据值为 null。在情况 1 发生时，先比较 “p 和 h”，若 p!=h，即表头发生了变化，则调用 updateHead() 更新表头；然后返回删除节点的 item 值。updateHead() 的源码如下： 1234final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123; if (h != p &amp;&amp; casHead(h, p)) h.lazySetNext(h);&#125; 说明：updateHead() 的最终目的是更新表头为 p，并设置 h 的下一个节点为 h 本身。casHead(h,p) 是通过 CAS 函数设置表头，若表头等于 h 的话，则设置表头为 p。lazySetNext() 的源码如下： 123void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val);&#125; putOrderedObject()函数，我们在前面一章 “TODO” 中介绍过。h.lazySetNext(h)的作用是通过 CAS 函数设置 h 的下一个节点为 h 自身，该设置可能会延迟执行。 情况 2：如果表头的下一个节点为 null，即链表只有一个 “内容为 null 的表头节点”。则调用 updateHead(h, p)，将表头更新 p；然后返回 null。 情况 3：p=q在 “情况 4” 的发生后，会导致 p=q；此时，“情况 3”就会发生。当 “情况 3” 发生后，它会跳转到 restartFromHead 标记重新操作。 情况 4：其它情况。设置 p=q。 ConcurrentLinkedQueue 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import java.util.*;import java.util.concurrent.*;/* * ConcurrentLinkedQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是ConcurrentLinkedQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ConcurrentLinkedQueueDemo1 &#123; // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对queue进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value; Iterator iter = queue.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112ta1, ta1, tb1, tb1,ta1, ta1, tb1, tb1, ta2, ta2, tb2, tb2, ta1, ta1, tb1, tb1, ta2, ta2, tb2, tb2, ta3, tb3, ta3, ta1, tb3, tb1, ta4, ta2, ta1, tb2, tb1, ta3, ta2, tb3, tb2, ta4, ta3, tb4, tb3, ta1, ta4, tb1, tb4, ta2, ta5, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, tb4, ta3, ta5, tb3, tb5, ta4, ta1, tb4, tb1, ta5, ta2, tb5, tb2, ta6, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, tb5, tb3, ta6, ta4, tb6, tb4, ta5, tb5, ta6, tb6, 结果说明：如果将源码中的 queue 改成 LinkedList 对象时，程序会产生 ConcurrentModificationException 异常。 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列三：JUC锁]]></title>
    <url>%2F2018%2F03%2F24%2F2018-03-24-1%2F</url>
    <content type="text"><![CDATA[01 框架根据锁添加到 Java 中的时间，Java 中的锁，可以分为 “ 同步锁 “和”JUC 包中的锁 “。 同步锁 即通过 synchronized 关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0 版本中就已经支持同步锁了。 同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行 CPU 调度，从而在 CPU 上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运行。这就是，多线程通过同步锁进行同步的原理！ 关于 “同步锁” 的更多内容，请参考 “Java 锁的基础部分 “ 的内容。 JUC 包中的锁 相比同步锁，JUC 包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。 JUC 包中的锁，包括：Lock 接口，ReadWriteLock 接口，LockSupport 阻塞原语，Condition 条件，AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer 三个抽象类，ReentrantLock 独占锁，ReentrantReadWriteLock 读写锁。由于 CountDownLatch，CyclicBarrier 和 Semaphore 也是通过 AQS 来实现的；因此，我也将它们归纳到锁的框架中进行介绍。 先看看锁的框架图，如下所示。 01. Lock 接口 JUC 包中的 Lock 接口支持那些语义不同 (重入、公平等) 的锁规则。所谓语义不同，是指锁可是有 “公平机制的锁”、”非公平机制的锁”、”可重入的锁” 等等。”公平机制” 是指 “不同线程获取锁的机制是公平的”，而 “非公平机制” 则是指 “不同线程获取锁的机制是非公平的”，”可重入的锁” 是指同一个锁能够被一个线程多次获取。 02. ReadWriteLock ReadWriteLock 接口以和 Lock 类似的方式定义了一些读取者可以共享而写入者独占的锁。JUC 包只有一个类实现了该接口，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。 03. AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer AbstractQueuedSynchronizer 就是被称之为 AQS 的类，它是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器；ReentrantLock，ReentrantReadWriteLock，CountDownLatch，CyclicBarrier 和 Semaphore 等这些类都是基于 AQS 类实现的。AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。 04. LockSupport LockSupport 提供 “创建锁” 和“其他同步类的基本线程阻塞原语”。 LockSupport 的功能和 “Thread 中的 Thread.suspend()和 Thread.resume()有点类似”，LockSupport 中的 park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是 park()和 unpark()不会遇到 “Thread.suspend 和 Thread.resume 所可能引发的死锁” 问题。 05. Condition Condition 需要和 Lock 联合使用，它的作用是代替 Object 监视器方法，可以通过 await(),signal() 来休眠 / 唤醒线程。strong textCondition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 06. ReentrantLock Reentrant:可重入 ReentrantLock 是独占锁。所谓独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。ReentrantLock 锁包括 “公平的 ReentrantLock” 和 “非公平的 ReentrantLock”。”公平的 ReentrantLock” 是指 “不同线程获取锁的机制是公平的”，而 “非公平的 ReentrantLock” 则是指 “不同线程获取锁的机制是非公平的”，ReentrantLock 是 “可重入的锁”。 ReentrantLock 的 UML 类图如下： (01) ReentrantLock 实现了 Lock 接口。 (02) ReentrantLock 中有一个成员变量 sync，sync 是 Sync 类型；Sync 是一个抽象类，而且它继承于 AQS。 (03) ReentrantLock 中有 “公平锁类”FairSync 和 “非公平锁类”NonfairSync，它们都是 Sync 的子类。ReentrantReadWriteLock 中 sync 对象，是 FairSync 与 NonfairSync 中的一种，这也意味着 ReentrantLock 是 “公平锁” 或 “非公平锁” 中的一种，ReentrantLock 默认是非公平锁。 07. ReentrantReadWriteLock ReentrantReadWriteLock 是读写锁接口 ReadWriteLock 的实现类，它包括子类 ReadLock 和 WriteLock。ReentrantLock 是共享锁，而 WriteLock 是独占锁。 ReentrantReadWriteLock 的 UML 类图如下： (01) ReentrantReadWriteLock 实现了 ReadWriteLock 接口。 (02) ReentrantReadWriteLock 中包含 sync 对象，读锁 readerLock 和写锁 writerLock。读锁 ReadLock 和写锁 WriteLock 都实现了 Lock 接口。 (03) 和 “ReentrantLock” 一样，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平锁”FairSync 和 “非公平锁”NonfairSync。 08. CountDownLatch CountDownLatch 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 CountDownLatch 的 UML 类图如下： CountDownLatch 包含了 sync 对象，sync 是 Sync 类型。CountDownLatch 的 Sync 是实例类，它继承于 AQS。 09. CyclicBarrier CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 CyclicBarrier 的 UML 类图如下： CyclicBarrier 是包含了 “ReentrantLock 对象 lock” 和 “Condition 对象 trip”，它是通过独占锁实现的。 CyclicBarrier 和 CountDownLatch 的区别是： (01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。 (02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。 10. Semaphore Semaphore 是一个计数信号量，它的本质是一个 “共享锁”。 信号量维护了一个信号量许可集。线程可以通过调用 acquire() 来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过 release() 来释放它所持有的信号量许可。 Semaphore 的 UML 类图如下： 和 “ReentrantLock” 一样，Semaphore 包含了 sync 对象，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平信号量”FairSync 和 “非公平信号量”NonfairSync。 02 互斥锁ReentrantLock本章对 ReentrantLock 包进行基本介绍，这一章主要对 ReentrantLock 进行概括性的介绍，内容包括：ReentrantLock 介绍ReentrantLock 函数列表ReentrantLock 示例在后面的两章，会分别介绍 ReentrantLock 的两个子类 (公平锁和非公平锁) 的实现原理。 ReentrantLock 介绍ReentrantLock 是一个可重入的互斥锁，又被称为 “独占锁”。 顾名思义，ReentrantLock 锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock 锁，可以被单个线程多次获取。ReentrantLock分为 “公平锁” 和 “非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock 在同一个时间点只能被一个线程获取 (当某线程获取到“锁” 时，其它线程就必须等待)；ReentraantLock 是通过一个 FIFO 的等待队列来管理获取该锁所有线程的。在 “公平锁” 的机制下，线程依次排队获取锁；而 “非公平锁” 在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。 ReentrantLock 函数列表1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个 ReentrantLock ，默认是“非公平锁”。ReentrantLock()// 创建策略是fair的 ReentrantLock。fair为true表示是公平锁，fair为false表示是非公平锁。ReentrantLock(boolean fair)// 查询当前线程保持此锁的次数。int getHoldCount()// 返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。protected Thread getOwner()// 返回一个 collection，它包含可能正等待获取此锁的线程。protected Collection&lt;Thread&gt; getQueuedThreads()// 返回正等待获取此锁的线程估计数。int getQueueLength()// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition)// 返回等待与此锁相关的给定条件的线程估计数。int getWaitQueueLength(Condition condition)// 查询给定线程是否正在等待获取此锁。boolean hasQueuedThread(Thread thread)// 查询是否有些线程正在等待获取此锁。boolean hasQueuedThreads()// 查询是否有些线程正在等待与此锁有关的给定条件。boolean hasWaiters(Condition condition)// 如果是“公平锁”返回true，否则返回false。boolean isFair()// 查询当前线程是否保持此锁。boolean isHeldByCurrentThread()// 查询此锁是否由任意线程保持。boolean isLocked()// 获取锁。void lock()// 如果当前线程未被中断，则获取锁。void lockInterruptibly()// 返回用来与此Lock实例一起使用的 Condition 实例。Condition newCondition()// 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。boolean tryLock()// 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。boolean tryLock(long timeout, TimeUnit unit)// 试图释放此锁。void unlock() ReentrantLock 示例通过对比 “示例 1” 和“示例 2”, 我们能够清晰的认识 lock 和 unlock 的作用 示例 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;// LockTest1.java// 仓库class Depot &#123; private int size; // 仓库的实际数量 private Lock lock; // 独占锁 public Depot() &#123; this.size = 0; this.lock = new ReentrantLock(); &#125; public void produce(int val) &#123; lock.lock(); try &#123; size += val; System.out.printf("%s produce(%d) --&gt; size=%d\n", Thread.currentThread().getName(), val, size); &#125; finally &#123; lock.unlock(); &#125; &#125; public void consume(int val) &#123; lock.lock(); try &#123; size -= val; System.out.printf("%s consume(%d) &lt;-- size=%d\n", Thread.currentThread().getName(), val, size); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;; // 生产者class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) &#123; new Thread() &#123; public void run() &#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;// 消费者class Customer &#123; private Depot depot; public Customer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) &#123; new Thread() &#123; public void run() &#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest1 &#123; public static void main(String[] args) &#123; Depot mDepot = new Depot(); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); &#125;&#125; 运行结果： 12345Thread-0 produce(60) --&gt; size=60Thread-1 produce(120) --&gt; size=180Thread-3 consume(150) &lt;-- size=30Thread-2 consume(90) &lt;-- size=-60Thread-4 produce(110) --&gt; size=50 结果分析：(01) Depot 是个仓库。通过 produce()能往仓库中生产货物，通过 consume()能消费仓库中的货物。通过独占锁 lock 实现对仓库的互斥访问：在操作 (生产 / 消费) 仓库中货品前，会先通过 lock()锁住仓库，操作完之后再通过 unlock()解锁。(02) Producer 是生产者类。调用 Producer 中的 produce() 函数可以新建一个线程往仓库中生产产品。(03) Customer 是消费者类。调用 Customer 中的 consume() 函数可以新建一个线程消费仓库中的产品。(04) 在主线程 main 中，我们会新建 1 个生产者 mPro，同时新建 1 个消费者 mCus。它们分别向仓库中生产 / 消费产品。根据 main 中的生产 / 消费数量，仓库最终剩余的产品应该是 50。运行结果是符合我们预期的！ 这个模型存在两个问题：(01) 现实中，仓库的容量不可能为负数。但是，此模型中的仓库容量可以为负数，这与现实相矛盾！(02) 现实中，仓库的容量是有限制的。但是，此模型中的容量确实没有限制的！这两个问题，我们稍微会讲到如何解决。现在，先看个简单的示例 2；通过对比 “示例 1” 和“示例 2”, 我们能更清晰的认识 lock(),unlock()的用途。 示例 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;// LockTest2.java// 仓库class Depot &#123; private int size; // 仓库的实际数量 private Lock lock; // 独占锁 public Depot() &#123; this.size = 0; this.lock = new ReentrantLock(); &#125; public void produce(int val) &#123;// lock.lock();// try &#123; size += val; System.out.printf("%s produce(%d) --&gt; size=%d\n", Thread.currentThread().getName(), val, size);// &#125; catch (InterruptedException e) &#123;// &#125; finally &#123;// lock.unlock();// &#125; &#125; public void consume(int val) &#123;// lock.lock();// try &#123; size -= val; System.out.printf("%s consume(%d) &lt;-- size=%d\n", Thread.currentThread().getName(), val, size);// &#125; finally &#123;// lock.unlock();// &#125; &#125;&#125;; // 生产者class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) &#123; new Thread() &#123; public void run() &#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;// 消费者class Customer &#123; private Depot depot; public Customer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) &#123; new Thread() &#123; public void run() &#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest2 &#123; public static void main(String[] args) &#123; Depot mDepot = new Depot(); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); &#125;&#125; (某一次) 运行结果： 12345Thread-0 produce(60) --&gt; size=-60Thread-4 produce(110) --&gt; size=50Thread-2 consume(90) &lt;-- size=-60Thread-1 produce(120) --&gt; size=-60Thread-3 consume(150) &lt;-- size=-60 结果说明：“示例 2”在 “示例 1” 的基础上去掉了 lock 锁。在 “示例 2” 中，仓库中最终剩余的产品是 - 60，而不是我们期望的 50。原因是我们没有实现对仓库的互斥访问。 示例 3 在 “示例 3” 中，我们通过 Condition 去解决 “示例 1” 中的两个问题：“仓库的容量不可能为负数”以及“仓库的容量是有限制的”。解决该问题是通过 Condition。Condition 是需要和 Lock 联合使用的：通过 Condition 中的 await()方法，能让线程阻塞 [类似于 wait()]；通过 Condition 的 signal() 方法，能唤醒线程[类似于 notify()]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.Condition;// LockTest3.java// 仓库class Depot &#123; private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 private Lock lock; // 独占锁 private Condition fullCondtion; // 生产条件 private Condition emptyCondtion; // 消费条件 public Depot(int capacity) &#123; this.capacity = capacity; this.size = 0; this.lock = new ReentrantLock(); this.fullCondtion = lock.newCondition(); this.emptyCondtion = lock.newCondition(); &#125; public void produce(int val) &#123; lock.lock(); try &#123; // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left &gt; 0) &#123; // 库存已满时，等待“消费者”消费产品。 while (size &gt;= capacity) fullCondtion.await(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)&gt;capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf("%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\n", Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 emptyCondtion.signal(); &#125; &#125; catch (InterruptedException e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; public void consume(int val) &#123; lock.lock(); try &#123; // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left &gt; 0) &#123; // 库存为0时，等待“生产者”生产产品。 while (size &lt;= 0) emptyCondtion.await(); // 获取“实际消费的数量”(即库存中实际减少的数量) // 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”； // 否则，“实际消费量”=“客户要消费的数量”。 int dec = (size&lt;left) ? size : left; size -= dec; left -= dec; System.out.printf("%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\n", Thread.currentThread().getName(), val, left, dec, size); fullCondtion.signal(); &#125; &#125; catch (InterruptedException e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; public String toString() &#123; return "capacity:"+capacity+", actual size:"+size; &#125;&#125;; // 生产者class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) &#123; new Thread() &#123; public void run() &#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;// 消费者class Customer &#123; private Depot depot; public Customer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) &#123; new Thread() &#123; public void run() &#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest3 &#123; public static void main(String[] args) &#123; Depot mDepot = new Depot(100); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); &#125;&#125; (某一次) 运行结果： 12345678910Thread-0 produce( 60) --&gt; left= 0, inc= 60, size= 60Thread-1 produce(120) --&gt; left= 80, inc= 40, size=100Thread-2 consume( 90) &lt;-- left= 0, dec= 90, size= 10Thread-3 consume(150) &lt;-- left=140, dec= 10, size= 0Thread-4 produce(110) --&gt; left= 10, inc=100, size=100Thread-3 consume(150) &lt;-- left= 40, dec=100, size= 0Thread-4 produce(110) --&gt; left= 0, inc= 10, size= 10Thread-3 consume(150) &lt;-- left= 30, dec= 10, size= 0Thread-1 produce(120) --&gt; left= 0, inc= 80, size= 80Thread-3 consume(150) &lt;-- left= 0, dec= 30, size= 50 代码中的已经包含了很详细的注释，这里就不再说明了。更多 “生产者 / 消费者模型” 的更多内容，可以参考“Java 多线程系列 –“基础篇”11 之 生产消费者问题”。而关于 Condition 的内容，在后面我们会详细介绍。 03 公平锁(一)概要本章对 “公平锁” 的获取锁机制进行介绍(本文的公平锁指的是互斥锁的公平锁)，内容包括：基本概念 ReentrantLock 数据结构参考代码获取公平锁 (基于 JDK1.7.0_40) 一. tryAcquire() 二. addWaiter() 三. acquireQueued() 四. selfInterrupt()“公平锁” 的释放锁的机制在后面一章再做介绍，锁的使用示例请参考 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock”。 基本概念本章，我们会讲解 “线程获取公平锁” 的原理；在讲解之前，需要了解几个基本概念。后面的内容，都是基于这些概念的；这些概念可能比较枯燥，但从这些概念中，能窥见 “java 锁” 的一些架构，这对我们了解锁是有帮助的。1. AQS – 指 AbstractQueuedSynchronizer 类。 AQS 是 java 中管理 “锁” 的抽象类，锁的许多公共方法都是在这个类中实现。AQS 是独占锁 (例如，ReentrantLock) 和共享锁 (例如，Semaphore) 的公共父类。 2. AQS 锁的类别 – 分为 “独占锁” 和 “共享锁” 两种。 (01) 独占锁 – 锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为 “公平锁” 和 “非公平锁”。公平锁，是按照通过 CLH 等待线程按照先来先得的规则，公平的获取锁；而非公平锁，则当线程要获取锁时，它会无视 CLH 等待队列而直接获取锁。独占锁的典型实例子是 ReentrantLock，此外，ReentrantReadWriteLock.WriteLock 也是独占锁。 (02) 共享锁 – 能被多个线程同时拥有，能被共享的锁。JUC 包中的 ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch 和 Semaphore 都是共享锁。这些锁的用途和原理，在以后的章节再详细介绍。 CLH 队列 – Craig, Landin, and Hagersten lock queue CLH 队列是 AQS 中 “等待锁” 的线程队列。在多线程中，为了保护竞争资源不被多个线程同时操作而起来错误，我们常常需要通过锁来保护这些资源。在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；而其它线程则需要等待。CLH 就是管理这些 “等待锁” 的线程的队列。 CLH 是一个非阻塞的 FIFO 队列。也就是说往里面插入或移除一个节点的时候，在并发条件下不会阻塞，而是通过自旋锁和 CAS 保证节点插入和移除的原子性。 4. CAS 函数 – Compare And Swap CAS 函数，是比较并交换函数，它是原子操作函数；即，通过 CAS 操作的数据都是以原子方式进行的。例如，compareAndSetHead(), compareAndSetTail(), compareAndSetNext() 等函数。它们共同的特点是，这些函数所执行的动作是以原子的方式进行的。 本章是围绕 “公平锁” 如何获取锁而层次展开。“公平锁”涉及到的知识点比较多，但总的来说，不是特别难；如果读者能读懂 AQS 和 ReentrantLock.java 这两个类的大致意思，理解锁的原理和机制也就不成问题了。本章只是作者本人对锁的一点点理解，希望这部分知识能帮助您了解 “公平锁” 的获取过程，认识 “锁” 的框架。 ReentrantLock 数据结构ReentrantLock 的 UML 类图 从图中可以看出：(01) ReentrantLock 实现了 Lock 接口。(02) ReentrantLock 与 sync 是组合关系。ReentrantLock 中，包含了 Sync 对象；而且，Sync 是 AQS 的子类；更重要的是，Sync 有两个子类 FairSync(公平锁) 和 NonFairSync(非公平锁)。ReentrantLock 是一个独占锁，至于它到底是公平锁还是非公平锁，就取决于 sync 对象是 “FairSync 的实例” 还是 “NonFairSync 的实例”。 参考代码下面给出 Java1.7.0_40 版本中，ReentrantLock 和 AQS 的源码，仅供参考！ ReentranLock.java ReentranLock.java源码 AQS(AbstractQueuedSynchronizer.java) AbstractQueuedSynchronizer.java源码 获取公平锁 (基于 JDK1.7.0_40)通过前面 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock”的 “示例 1”，我们知道，获取锁是通过 lock() 函数。下面，我们以 lock()对获取公平锁的过程进行展开。 1. lock() lock() 在 ReentrantLock.java 的 FairSync 类中实现，它的源码如下： 123final void lock() &#123; acquire(1);&#125; 说明：“当前线程” 实际上是通过 acquire(1) 获取锁的。 这里说明一下 “1”的含义，它是设置 “锁的状态” 的参数。对于 “独占锁” 而言，锁处于可获取状态时，它的状态值是 0；锁被线程初次获取到了，它的状态值就变成了 1。 由于 ReentrantLock(公平锁 / 非公平锁)是可重入锁，所以 “独占锁” 可以被单个线程多此获取，每获取 1 次就将锁的状态 + 1。也就是说，初次获取锁时，通过 acquire(1)将锁的状态值设为 1；再次获取锁时，将锁的状态值设为 2；依次类推… 这就是为什么获取锁时，传入的参数是 1 的原因了。 可重入就是指锁可以被单个线程多次获取。 2. acquire() acquire() 在 AQS 中实现的，它的源码如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; (01) “当前线程” 首先通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列排序等待 (前面还有可能有需要线程在等待该锁)。(02) “当前线程”尝试失败的情况下，先通过 addWaiter(Node.EXCLUSIVE)来将 “当前线程” 加入到 “CLH 队列(非阻塞的 FIFO 队列)” 末尾。CLH 队列就是线程等待队列。(03) 再执行完 addWaiter(Node.EXCLUSIVE) 之后，会调用 acquireQueued() 来获取锁。由于此时 ReentrantLock 是公平锁，它会根据公平性原则来获取锁。(04) “当前线程” 在执行 acquireQueued() 时，会进入到 CLH 队列中休眠等待，直到获取锁了才返回！如果 “当前线程” 在休眠等待过程中被中断过，acquireQueued 会返回 true，此时 “当前线程” 会调用 selfInterrupt()来自己给自己产生一个中断。至于为什么要自己给自己产生一个中断，后面再介绍。 上面是对 acquire() 的概括性说明。下面，我们将该函数分为 4 部分来逐步解析。一. tryAcquire()二. addWaiter()三. acquireQueued()四. selfInterrupt() 一. tryAcquire()1. tryAcquire() 公平锁的 tryAcquire() 在 ReentrantLock.java 的 FairSync 类中实现，源码如下： 123456789101112131415161718192021222324252627protected final boolean tryAcquire(int acquires) &#123; // 获取“当前线程” final Thread current = Thread.currentThread(); // 获取“独占锁”的状态 int c = getState(); // c=0意味着“锁没有被任何线程锁拥有”， if (c == 0) &#123; // 若“锁没有被任何线程锁拥有”， // 则判断“当前线程”是不是CLH队列中的第一个线程线程， // 若是的话，则获取该锁，设置锁的状态，并切设置锁的拥有者为“当前线程”。 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 如果“独占锁”的拥有者已经为“当前线程”， // 则将更新锁的状态。 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 说明：根据代码，我们可以分析出，tryAcquire() 的作用就是尝试去获取锁。注意，这里只是尝试！ 尝试成功的话，返回 true；尝试失败的话，返回 false，后续再通过其它办法来获取该锁。后面我们会说明，在尝试失败的情况下，是如何一步步获取锁的。 2. hasQueuedPredecessors() hasQueuedPredecessors() 在 AQS 中实现，源码如下： 1234567public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 说明： 通过代码，能分析出，hasQueuedPredecessors() 是通过判断 “当前线程” 是不是在 CLH 队列的队首，来返回 AQS 中是不是有比 “当前线程” 等待更久的线程。下面对 head、tail 和 Node 进行说明。 3. Node 的源码 Node 就是 CLH 队列的节点。Node 在 AQS 中实现，它的数据结构如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private transient volatile Node head; // CLH队列的队首private transient volatile Node tail; // CLH队列的队尾// CLH队列的节点static final class Node &#123; static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; // 线程已被取消，对应的waitStatus的值 static final int CANCELLED = 1; // “当前线程的后继线程需要被unpark(唤醒)”，对应的waitStatus的值。 // 一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。 static final int SIGNAL = -1; // 线程(处在Condition休眠状态)在等待Condition唤醒，对应的waitStatus的值 static final int CONDITION = -2; // (共享锁)其它线程获取到“共享锁”，对应的waitStatus的值 static final int PROPAGATE = -3; // waitStatus为“CANCELLED, SIGNAL, CONDITION, PROPAGATE”时分别表示不同状态， // 若waitStatus=0，则意味着当前线程不属于上面的任何一种状态。 volatile int waitStatus; // 前一节点 volatile Node prev; // 后一节点 volatile Node next; // 节点所对应的线程 volatile Thread thread; // nextWaiter是“区别当前CLH队列是 ‘独占锁’队列 还是 ‘共享锁’队列 的标记” // 若nextWaiter=SHARED，则CLH队列是“独占锁”队列； // 若nextWaiter=EXCLUSIVE，(即nextWaiter=null)，则CLH队列是“共享锁”队列。 Node nextWaiter; // “共享锁”则返回true，“独占锁”则返回false。 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; // 返回前一节点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; // 构造函数。thread是节点所对应的线程，mode是用来表示thread的锁是“独占锁”还是“共享锁”。 Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; // 构造函数。thread是节点所对应的线程，waitStatus是线程的等待状态。 Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 说明：Node 是 CLH 队列的节点，代表 “等待锁的线程队列”。(01) 每个 Node 都会一个线程对应。(02) 每个 Node 会通过 prev 和 next 分别指向上一个节点和下一个节点，这分别代表上一个等待线程和下一个等待线程。(03) Node 通过 waitStatus 保存线程的等待状态。(04) Node 通过 nextWaiter 来区分线程是 “独占锁” 线程还是 “共享锁” 线程。如果是 “独占锁” 线程，则 nextWaiter 的值为 EXCLUSIVE；如果是 “共享锁” 线程，则 nextWaiter 的值是 SHARED。 4. compareAndSetState() compareAndSetState() 在 AQS 中实现。它的源码如下： 123protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 说明： compareAndSwapInt() 是 sun.misc.Unsafe 类中的一个本地方法。对此，我们需要了解的是 compareAndSetState(expect, update) 是以原子的方式操作当前线程；若当前线程的状态为 expect，则设置它的状态为 update。 5. setExclusiveOwnerThread() setExclusiveOwnerThread() 在 AbstractOwnableSynchronizer.java 中实现，它的源码如下： 12345// exclusiveOwnerThread是当前拥有“独占锁”的线程private transient Thread exclusiveOwnerThread;protected final void setExclusiveOwnerThread(Thread t) &#123; exclusiveOwnerThread = t;&#125; 说明：setExclusiveOwnerThread()的作用就是，设置线程 t 为当前拥有 “独占锁” 的线程。 6. getState(), setState() getState() 和 setState() 都在 AQS 中实现，源码如下： 12345678910// 锁的状态private volatile int state;// 设置锁的状态protected final void setState(int newState) &#123; state = newState;&#125;// 获取锁的状态protected final int getState() &#123; return state;&#125; 说明：state 表示锁的状态，对于 “独占锁” 而已，state=0 表示锁是可获取状态(即，锁没有被任何线程锁持有)。由于 java 中的独占锁是可重入的，state 的值可以 &gt; 1。 小结：tryAcquire()的作用就是让 “当前线程” 尝试获取锁。获取成功返回 true，失败则返回 false。 二. addWaiter(Node.EXCLUSIVE)addWaiter(Node.EXCLUSIVE)的作用是，创建 “当前线程” 的 Node 节点，且 Node 中记录 “当前线程” 对应的锁是 “独占锁” 类型，并且将该节点添加到 CLH 队列的末尾。 1.addWaiter() addWaiter() 在 AQS 中实现，源码如下： 12345678910111213141516private Node addWaiter(Node mode) &#123; // 新建一个Node节点，节点对应的线程是“当前线程”，“当前线程”的锁的模型是mode。 Node node = new Node(Thread.currentThread(), mode); Node pred = tail; // 若CLH队列不为空，则将“当前线程”添加到CLH队列末尾 if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 若CLH队列为空，则调用enq()新建CLH队列，然后再将“当前线程”添加到CLH队列中。 enq(node); return node;&#125; 说明：对于 “公平锁” 而言，addWaiter(Node.EXCLUSIVE)会首先创建一个 Node 节点，节点的类型是 “独占锁”(Node.EXCLUSIVE) 类型。然后，再将该节点添加到 CLH 队列的末尾。 2. compareAndSetTail() compareAndSetTail() 在 AQS 中实现，源码如下： 123private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update);&#125; 说明：compareAndSetTail 也属于 CAS 函数，也是通过 “本地方法” 实现的。compareAndSetTail(expect, update)会以原子的方式进行操作，它的作用是判断 CLH 队列的队尾是不是为 expect，是的话，就将队尾设为 update。 3. enq() enq() 在 AQS 中实现，源码如下： 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 说明： enq() 的作用很简单。如果 CLH 队列为空，则新建一个 CLH 表头；然后将 node 添加到 CLH 末尾。否则，直接将 node 添加到 CLH 末尾。 小结：addWaiter()的作用，就是将当前线程添加到 CLH 队列中。这就意味着将当前线程添加到等待获取 “锁” 的等待线程队列中了。 三. acquireQueued()前面，我们已经将当前线程添加到 CLH 队列中了。而 acquireQueued() 的作用就是逐步的去执行 CLH 队列的线程，如果当前线程获取到了锁，则返回；否则，当前线程进行休眠，直到唤醒并重新获取锁了才返回。下面，我们看看 acquireQueued() 的具体流程。 1. acquireQueued() acquireQueued() 在 AQS 中实现，源码如下： 12345678910111213141516171819202122232425final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; // interrupted表示在CLH队列的调度中， // “当前线程”在休眠时，有没有被中断过。 boolean interrupted = false; for (;;) &#123; // 获取上一个节点。 // node是“当前线程”对应的节点，这里就意味着“获取上一个等待锁的线程”。 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：acquireQueued() 的目的是从队列中获取锁。 2. shouldParkAfterFailedAcquire() shouldParkAfterFailedAcquire() 在 AQS 中实现，源码如下： 12345678910111213141516171819// 返回“当前线程是否应该阻塞”private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 前继节点的状态 int ws = pred.waitStatus; // 如果前继节点是SIGNAL状态，则意味这当前线程需要被unpark唤醒。此时，返回true。 if (ws == Node.SIGNAL) return true; // 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点’的前继节点”。 if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 说明：(01) 关于 waitStatus 请参考下表 (中扩号内为 waitStatus 的值)，更多关于 waitStatus 的内容，可以参考前面的 Node 类的介绍。 CANCELLED[1] – 当前线程已被取消SIGNAL[-1] – “当前线程的后继线程需要被unpark(唤醒)”。一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。CONDITION[-2] – 当前线程(处在Condition休眠状态)在等待Condition唤醒PROPAGATE[-3] – (共享锁)其它线程获取到“共享锁”[0] – 当前线程不属于上面的任何一种状态。 (02) shouldParkAfterFailedAcquire()通过以下规则，判断 “当前线程” 是否需要被阻塞。 规则1：如果前继节点状态为SIGNAL，表明当前节点需要被unpark(唤醒)，此时则返回true。规则2：如果前继节点状态为CANCELLED(ws&gt;0)，说明前继节点已经被取消，则通过先前回溯找到一个有效(非CANCELLED状态)的节点，并返回false。规则3：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，并返回false。 如果 “规则 1” 发生，即 “前继节点是 SIGNAL” 状态，则意味着 “当前线程” 需要被阻塞。接下来会调用 parkAndCheckInterrupt()阻塞当前线程，直到当前先被唤醒才从 parkAndCheckInterrupt()中返回。 3. parkAndCheckInterrupt()) parkAndCheckInterrupt() 在 AQS 中实现，源码如下： 123456private final boolean parkAndCheckInterrupt() &#123; // 通过LockSupport的park()阻塞“当前线程”。 LockSupport.park(this); // 返回线程的中断状态。 return Thread.interrupted();&#125; 说明：parkAndCheckInterrupt()的作用是阻塞当前线程，并且返回 “线程被唤醒之后” 的中断状态。它会先通过 LockSupport.park()阻塞 “当前线程”，然后通过 Thread.interrupted() 返回线程的中断状态。 这里介绍一下线程被阻塞之后如何唤醒。一般有 2 种情况：第 1 种情况：unpark() 唤醒。“前继节点对应的线程” 使用完锁之后，通过 unpark() 方式唤醒当前线程。第 2 种情况：中断唤醒。其它线程通过 interrupt() 中断当前线程。 补充：LockSupport() 中的 park(),unpark() 的作用 和 Object 中的 wait(),notify() 作用类似，是阻塞 / 唤醒。它们的用法不同，park(),unpark() 是轻量级的，而 wait(),notify() 是必须先通过 Synchronized 获取同步锁。关于 LockSupport，我们会在之后的章节再专门进行介绍！ 4. 再次 tryAcquire() 了解了 shouldParkAfterFailedAcquire() 和 parkAndCheckInterrupt() 函数之后。我们接着分析 acquireQueued() 的 for 循环部分。 1234567final Node p = node.predecessor();if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted;&#125; 说明：(01) 通过 node.predecessor() 获取前继节点。predecessor() 就是返回 node 的前继节点，若对此有疑惑可以查看下面关于 Node 类的介绍。(02) p == head &amp;&amp; tryAcquire(arg) 首先，判断 “前继节点” 是不是 CHL 表头。如果是的话，则通过 tryAcquire()尝试获取锁。 其实，这样做的目的是为了 “让当前线程获取锁”，但是为什么需要先判断 p==head 呢？理解这个对理解“公平锁” 的机制很重要，因为这么做的原因就是为了保证公平性！ (a) 前面，我们在 shouldParkAfterFailedAcquire()我们判断 “当前线程” 是否需要阻塞； (b) 接着，“当前线程”阻塞的话，会调用 parkAndCheckInterrupt()来阻塞线程。当线程被解除阻塞的时候，我们会返回线程的中断状态。而线程被解决阻塞，可能是由于 “线程被中断”，也可能是由于“其它线程调用了该线程的 unpark() 函数”。 (c) 再回到 p==head 这里。如果当前线程是因为其它线程调用了 unpark()函数而被唤醒，那么唤醒它的线程，应该是它的前继节点所对应的线程 (关于这一点，后面在“释放锁” 的过程中会看到)。 OK，是前继节点调用 unpark()唤醒了当前线程！ 此时，再来理解 p==head 就很简单了：当前继节点是 CLH 队列的头节点，并且它释放锁之后；就轮到当前节点获取锁了。然后，当前节点通过 tryAcquire() 获取锁；获取成功的话，通过 setHead(node) 设置当前节点为头节点，并返回。 总之，如果 “前继节点调用 unpark() 唤醒了当前线程”并且 “前继节点是 CLH 表头”，此时就是满足 p==head，也就是符合公平性原则的。否则，如果当前线程是因为“线程被中断” 而唤醒，那么显然就不是公平了。这就是为什么说 p==head 就是保证公平性！ 小结：acquireQueued()的作用就是 “当前线程” 会根据公平性原则进行阻塞等待，直到获取锁为止；并且返回当前线程在等待过程中有没有并中断过。 四. selfInterrupt()selfInterrupt() 是 AQS 中实现，源码如下： 123private static void selfInterrupt() &#123; Thread.currentThread().interrupt();&#125; 说明：selfInterrupt()的代码很简单，就是 “当前线程” 自己产生一个中断。但是，为什么需要这么做呢？这必须结合 acquireQueued() 进行分析。如果在 acquireQueued() 中，当前线程被中断过，则执行 selfInterrupt()；否则不会执行。 在 acquireQueued() 中，即使是线程在阻塞状态被中断唤醒而获取到 cpu 执行权利；但是，如果该线程的前面还有其它等待锁的线程，根据公平性原则，该线程依然无法获取到锁。它会再次阻塞！ 该线程再次阻塞，直到该线程被它的前面等待锁的线程锁唤醒；线程才会获取锁，然后 “真正执行起来”！也就是说，在该线程 “成功获取锁并真正执行起来” 之前，它的中断会被忽略并且中断标记会被清除！ 因为在 parkAndCheckInterrupt()中，我们线程的中断状态时调用了 Thread.interrupted()。该函数不同于 Thread 的 isInterrupted()函数，isInterrupted()仅仅返回中断状态，而 interrupted()在返回当前中断状态之后，还会清除中断状态。 正因为之前的中断状态被清除了，所以这里需要调用 selfInterrupt()重新产生一个中断！ 小结：selfInterrupt() 的作用就是当前线程自己产生一个中断。 总结 再回过头看看 acquire() 函数，它最终的目的是获取锁！ 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; (01) 先是通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，再通过 acquireQueued() 获取锁。(02) 尝试失败的情况下，会先通过 addWaiter()来将 “当前线程” 加入到 “CLH 队列” 末尾；然后调用 acquireQueued()，在 CLH 队列中排序等待获取锁，在此过程中，线程处于休眠状态。直到获取锁了才返回。 如果在休眠等待过程中被中断过，则调用 selfInterrupt()来自己产生一个中断。 04 公平锁(二)概要前面一章，我们学习了 “公平锁” 获取锁的详细流程；这里，我们再来看看 “公平锁” 释放锁的过程。内容包括：释放公平锁 (基于 JDK1.7.0_40)“公平锁” 的获取过程请参考 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)”，锁的使用示例请参考 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock”。注意：(01) 这里是以 “公平锁” 来进行说明。(02) 关于本章的术语，如 “AQS”，“CAS 函数”，“CLH 队列”，“公平锁”，“非公平锁”，“独占锁”，“共享锁” 等内容，请参考 Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) 的基本概念。 释放公平锁 (基于 JDK1.7.0_40)1. unlock() unlock() 在 ReentrantLock.java 中实现的，源码如下： 123public void unlock() &#123; sync.release(1);&#125; 说明：unlock() 是解锁函数，它是通过 AQS 的 release() 函数来实现的。在这里，“1”的含义和 “获取锁的函数 acquire(1) 的含义”一样，它是设置 “释放锁的状态” 的参数。由于 “公平锁” 是可重入的，所以对于同一个线程，每释放锁一次，锁的状态 - 1。 关于 AQS, ReentrantLock 和 sync 的关系如下： 12345678910public class ReentrantLock implements Lock, java.io.Serializable &#123; private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer &#123; ... &#125; ...&#125; 从中，我们发现：sync 是 ReentrantLock.java 中的成员对象，而 Sync 是 AQS 的子类。 2. release() release() 在 AQS 中实现的，源码如下： 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 说明：release() 会先调用 tryRelease() 来尝试释放当前线程锁持有的锁。成功的话，则唤醒后继等待线程，并返回 true。否则，直接返回 false。 3. tryRelease() tryRelease() 在 ReentrantLock.java 的 Sync 类中实现，源码如下： 1234567891011121314151617protected final boolean tryRelease(int releases) &#123; // c是本次释放锁之后的状态 int c = getState() - releases; // 如果“当前线程”不是“锁的持有者”，则抛出异常！ if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 如果“锁”已经被当前线程彻底释放，则设置“锁”的持有者为null，即锁是可获取状态。 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; // 设置当前线程的锁的状态。 setState(c); return free;&#125; 说明：tryRelease() 的作用是尝试释放锁。(01) 如果 “当前线程” 不是“锁的持有者”，则抛出异常。(02) 如果 “当前线程” 在本次释放锁操作之后，对锁的拥有状态是 0(即，当前线程彻底释放该 “锁”)，则设置“锁” 的持有者为 null，即锁是可获取状态。同时，更新当前线程的锁的状态为 0。getState(), setState() 在前一章已经介绍过，这里不再说明。getExclusiveOwnerThread(), setExclusiveOwnerThread() 在 AQS 的父类 AbstractOwnableSynchronizer.java 中定义，源码如下： 123456789101112131415161718public abstract class AbstractOwnableSynchronizer implements java.io.Serializable &#123; // “锁”的持有线程 private transient Thread exclusiveOwnerThread; // 设置“锁的持有线程”为t protected final void setExclusiveOwnerThread(Thread t) &#123; exclusiveOwnerThread = t; &#125; // 获取“锁的持有线程” protected final Thread getExclusiveOwnerThread() &#123; return exclusiveOwnerThread; &#125; ...&#125; 4. unparkSuccessor() 在 release()中 “当前线程” 释放锁成功的话，会唤醒当前线程的后继线程。根据 CLH 队列的 FIFO 规则，“当前线程”(即已经获取锁的线程) 肯定是 head；如果 CLH 队列非空的话，则唤醒锁的下一个等待线程。下面看看 unparkSuccessor() 的源码，它在 AQS 中实现。 1234567891011121314151617181920private void unparkSuccessor(Node node) &#123; // 获取当前线程的状态 int ws = node.waitStatus; // 如果状态&lt;0，则设置状态=0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); //获取当前节点的“有效的后继节点”，无效的话，则通过for循环进行获取。 // 这里的有效，是指“后继节点对应的线程状态&lt;=0” Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; // 唤醒“后继节点对应的线程” if (s != null) LockSupport.unpark(s.thread);&#125; 说明：unparkSuccessor() 的作用是 “唤醒当前线程的后继线程”。后继线程被唤醒之后，就可以获取该锁并恢复运行了。关于 node.waitStatus 的说明，请参考 “上一章关于 Node 类的介绍”。 总结 “释放锁”的过程相对 “获取锁” 的过程比较简单。释放锁时，主要进行的操作，是更新当前线程对应的锁的状态。如果当前线程对锁已经彻底释放，则设置 “锁” 的持有线程为 null，设置当前线程的状态为空，然后唤醒后继线程。 05 非公平锁概要前面两章分析了 “公平锁的获取和释放机制”，这一章开始对 “非公平锁” 的获取锁 / 释放锁的过程进行分析。内容包括：获取非公平锁 (基于 JDK1.7.0_40)释放非公平锁 (基于 JDK1.7.0_40)关于锁的数据结构请参考 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) “，锁的使用示例请参考 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock”。 获取非公平锁 (基于 JDK1.7.0_40)非公平锁和公平锁在获取锁的方法上，流程是一样的；它们的区别主要表现在 “尝试获取锁的机制不同”。简单点说，“公平锁” 在每次尝试获取锁时，都是采用公平策略 (根据等待队列依次排序等待)；而“非公平锁” 在每次尝试获取锁时，都是采用的非公平策略(无视等待队列，直接尝试获取锁，如果锁是空闲的，即可获取状态，则获取锁)。在前面的 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)” 中，已经详细介绍了获取公平锁的流程和机制；下面，通过代码分析以下获取非公平锁的流程。 1. lock() lock() 在 ReentrantLock.java 的 NonfairSync 类中实现，它的源码如下： 123456final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 说明：lock()会先通过 compareAndSet(0, 1)来判断 “锁” 是不是空闲状态。是的话，“当前线程”直接获取 “锁”；否则的话，调用 acquire(1) 获取锁。(01) compareAndSetState() 是 CAS 函数，它的作用是比较并设置当前锁的状态。若锁的状态值为 0，则设置锁的状态值为 1。(02) setExclusiveOwnerThread(Thread.currentThread())的作用是，设置 “当前线程” 为“锁”的持有者。 “公平锁”和 “非公平锁” 关于 lock()的对比 公平锁 – 公平锁的lock()函数，会直接调用acquire(1)。非公平锁 – 非公平锁会先判断当前锁的状态是不是空闲，是的话，就不排队，而是直接获取锁。 2. acquire() acquire() 在 AQS 中实现的，它的源码如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; (01) “当前线程” 首先通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列依次排序，然后获取锁。(02) “当前线程”尝试失败的情况下，会先通过 addWaiter(Node.EXCLUSIVE)来将 “当前线程” 加入到 “CLH 队列(非阻塞的 FIFO 队列)” 末尾。(03) 然后，调用 acquireQueued()获取锁。在 acquireQueued()中，当前线程会等待它在 “CLH 队列” 中前面的所有线程执行并释放锁之后，才能获取锁并返回。如果 “当前线程” 在休眠等待过程中被中断过，则调用 selfInterrupt()来自己产生一个中断。 “公平锁”和 “非公平锁” 关于 acquire()的对比 公平锁和非公平锁，只有 tryAcquire() 函数的实现不同；即它们尝试获取锁的机制不同。这就是我们所说的 “它们获取锁策略的不同所在之处”！在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)” 中，已经详细介绍了 acquire() 涉及到的各个函数。这里仅对它们有差异的函数 tryAcquire() 进行说明。 非公平锁的 tryAcquire() 在 ReentrantLock.java 的 NonfairSync 类中实现，源码如下： 123protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125; nonfairTryAcquire() 在 ReentrantLock.java 的 Sync 类中实现，源码如下： 12345678910111213141516171819202122232425final boolean nonfairTryAcquire(int acquires) &#123; // 获取“当前线程” final Thread current = Thread.currentThread(); // 获取“锁”的状态 int c = getState(); // c=0意味着“锁没有被任何线程锁拥有” if (c == 0) &#123; // 若“锁没有被任何线程锁拥有”，则通过CAS函数设置“锁”的状态为acquires。 // 同时，设置“当前线程”为锁的持有者。 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 如果“锁”的持有者已经是“当前线程”， // 则将更新锁的状态。 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 说明：根据代码，我们可以分析出，tryAcquire() 的作用就是尝试去获取锁。(01) 如果 “锁” 没有被任何线程拥有，则通过 CAS 函数设置 “锁” 的状态为 acquires，同时，设置 “当前线程” 为锁的持有者，然后返回 true。(02) 如果 “锁” 的持有者已经是当前线程，则将更新锁的状态即可。(03) 如果不术语上面的两种情况，则认为尝试失败。 “公平锁”和 “非公平锁” 关于 tryAcquire()的对比 公平锁和非公平锁，它们尝试获取锁的方式不同。公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。而非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。 释放非公平锁 (基于 JDK1.7.0_40)非公平锁和公平锁在释放锁的方法和策略上是一样的。而在前面的 “Java 多线程系列 –“JUC 锁”04 之 公平锁 (二) ”中，已经对 “释放公平锁” 进行了介绍；这里就不再重复的进行说明。 总结公平锁和非公平锁的区别，是在获取锁的机制上的区别。表现在，在尝试获取锁时 —— 公平锁，只有在当前线程是 CLH 等待队列的表头时，才获取锁；而非公平锁，只要当前锁处于空闲状态，则直接获取锁，而不管 CLH 等待队列中的顺序。只有当非公平锁尝试获取锁失败的时候，它才会像公平锁一样，进入 CLH 等待队列排序等待。 06 Condition条件概要前面对 JUC 包中的锁的原理进行了介绍，本章会 JUC 中对与锁经常配合使用的 Condition 进行介绍，内容包括:Condition 介绍Condition 函数列表Condition 示例 Condition 介绍Condition 的作用是对锁进行更精确的控制。Condition 中的 await() 方法相当于 Object 的 wait() 方法，Condition 中的 signal() 方法相当于 Object 的 notify() 方法，Condition 中的 signalAll() 相当于 Object 的 notifyAll() 方法。不同的是，Object 中的 wait(),notify(),notifyAll() 方法是和 “同步锁”(synchronized 关键字) 捆绑使用的；而 Condition 是需要与 “互斥锁”/“共享锁” 捆绑使用的。 Condition 函数列表1234567891011121314// 造成当前线程在接到信号或被中断之前一直处于等待状态。void await()// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。boolean await(long time, TimeUnit unit)// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。long awaitNanos(long nanosTimeout)// 造成当前线程在接到信号之前一直处于等待状态。void awaitUninterruptibly()// 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。boolean awaitUntil(Date deadline)// 唤醒一个等待线程。void signal()// 唤醒所有等待线程。void signalAll() Condition 示例示例 1 是通过 Object 的 wait(), notify() 来演示线程的休眠 / 唤醒功能。示例 2 是通过 Condition 的 await(), signal() 来演示线程的休眠 / 唤醒功能。示例 3 是通过 Condition 的高级功能。 示例 1 1234567891011121314151617181920212223242526272829303132333435public class WaitTest1 &#123; public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); synchronized(ta) &#123; // 通过synchronized(ta)获取“对象ta的同步锁” try &#123; System.out.println(Thread.currentThread().getName()+" start ta"); ta.start(); System.out.println(Thread.currentThread().getName()+" block"); ta.wait(); // 等待 System.out.println(Thread.currentThread().getName()+" continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; synchronized (this) &#123; // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+" wakup others"); notify(); // 唤醒“当前对象上的等待线程” &#125; &#125; &#125;&#125; 示例 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ConditionTest1 &#123; private static Lock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); lock.lock(); // 获取锁 try &#123; System.out.println(Thread.currentThread().getName()+" start ta"); ta.start(); System.out.println(Thread.currentThread().getName()+" block"); condition.await(); // 等待 System.out.println(Thread.currentThread().getName()+" continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; lock.lock(); // 获取锁 try &#123; System.out.println(Thread.currentThread().getName()+" wakup others"); condition.signal(); // 唤醒“condition所在锁上的其它线程” &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; &#125;&#125; 运行结果： 1234main start tamain blockta wakup othersmain continue 通过 “示例 1” 和“示例 2”，我们知道 Condition 和 Object 的方法有一下对应关系： 情况 Object Condition 休眠 wait await 唤醒某个线程 notify signal 唤醒所有线程 notifyAll signalAll Condition 除了支持上面的功能之外，它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个 Condition，在不同的情况下使用不同的 Condition。例如，假如多线程读 / 写同一个缓冲区：当向缓冲区中写入数据之后，唤醒 “读线程”；当从缓冲区读出数据之后，唤醒 “写线程”；并且当缓冲区满的时候，”写线程” 需要等待；当缓冲区为空时，”读线程” 需要等待。 如果采用 Object 类中的 wait(), notify(), notifyAll() 实现该缓冲区，当向缓冲区写入数据之后需要唤醒 “读线程” 时，不可能通过 notify() 或 notifyAll() 明确的指定唤醒 “读线程”，而只能通过 notifyAll 唤醒所有线程 (但是 notifyAll 无法区分唤醒的线程是读线程，还是写线程)。 但是，通过 Condition，就能明确的指定唤醒读线程。看看下面的示例 3，可能对这个概念有更深刻的理解。 示例 3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[5]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); //获取锁 try &#123; // 如果“缓冲已满”，则等待；直到“缓冲”不是满的，才将x添加到缓冲中。 while (count == items.length) notFull.await(); // 将x添加到缓冲中 items[putptr] = x; // 将“put统计数putptr+1”；如果“缓冲已满”，则设putptr为0。 if (++putptr == items.length) putptr = 0; // 将“缓冲”数量+1 ++count; // 唤醒take线程，因为take线程通过notEmpty.await()等待 notEmpty.signal(); // 打印写入的数据 System.out.println(Thread.currentThread().getName() + " put "+ (Integer)x); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); //获取锁 try &#123; // 如果“缓冲为空”，则等待；直到“缓冲”不为空，才将x从缓冲中取出。 while (count == 0) notEmpty.await(); // 将x从缓冲中取出 Object x = items[takeptr]; // 将“take统计数takeptr+1”；如果“缓冲为空”，则设takeptr为0。 if (++takeptr == items.length) takeptr = 0; // 将“缓冲”数量-1 --count; // 唤醒put线程，因为put线程通过notFull.await()等待 notFull.signal(); // 打印取出的数据 System.out.println(Thread.currentThread().getName() + " take "+ (Integer)x); return x; &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; &#125;public class ConditionTest2 &#123; private static BoundedBuffer bb = new BoundedBuffer(); public static void main(String[] args) &#123; // 启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)； // 启动10个“读线程”，从BoundedBuffer中不断的读数据。 for (int i=0; i&lt;10; i++) &#123; new PutThread("p"+i, i).start(); new TakeThread("t"+i).start(); &#125; &#125; static class PutThread extends Thread &#123; private int num; public PutThread(String name, int num) &#123; super(name); this.num = num; &#125; public void run() &#123; try &#123; Thread.sleep(1); // 线程休眠1ms bb.put(num); // 向BoundedBuffer中写入数据 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; static class TakeThread extends Thread &#123; public TakeThread(String name) &#123; super(name); &#125; public void run() &#123; try &#123; Thread.sleep(10); // 线程休眠1ms Integer num = (Integer)bb.take(); // 从BoundedBuffer中取出数据 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; (某一次) 运行结果： 1234567891011121314151617181920p1 put 1p4 put 4p5 put 5p0 put 0p2 put 2t0 take 1p3 put 3t1 take 4p6 put 6t2 take 5p7 put 7t3 take 0p8 put 8t4 take 2p9 put 9t5 take 3t6 take 6t7 take 7t8 take 8t9 take 9 结果说明：(01) BoundedBuffer 是容量为 5 的缓冲，缓冲中存储的是 Object 对象，支持多线程的读 / 写缓冲。多个线程操作 “一个 BoundedBuffer 对象” 时，它们通过互斥锁 lock 对缓冲区 items 进行互斥访问；而且同一个 BoundedBuffer 对象下的全部线程共用 “notFull” 和“notEmpty”这两个 Condition。 notFull 用于控制写缓冲，notEmpty 用于控制读缓冲。当缓冲已满的时候，调用 put 的线程会执行 notFull.await() 进行等待；当缓冲区不是满的状态时，就将对象添加到缓冲区并将缓冲区的容量 count+1，最后，调用 notEmpty.signal() 缓冲 notEmpty 上的等待线程 (调用 notEmpty.await 的线程)。 简言之，notFull 控制 “缓冲区的写入”，当往缓冲区写入数据之后会唤醒 notEmpty 上的等待线程。 同理，notEmpty 控制 “缓冲区的读取”，当读取了缓冲区数据之后会唤醒 notFull 上的等待线程。(02) 在 ConditionTest2 的 main 函数中，启动 10 个 “写线程”，向 BoundedBuffer 中不断的写数据 (写入 0-9)；同时，也启动 10 个 “读线程”，从 BoundedBuffer 中不断的读数据。(03) 简单分析一下运行结果。 12345678910111, p1线程向缓冲中写入1。 此时，缓冲区数据: | 1 | | | | |2, p4线程向缓冲中写入4。 此时，缓冲区数据: | 1 | 4 | | | |3, p5线程向缓冲中写入5。 此时，缓冲区数据: | 1 | 4 | 5 | | |4, p0线程向缓冲中写入0。 此时，缓冲区数据: | 1 | 4 | 5 | 0 | |5, p2线程向缓冲中写入2。 此时，缓冲区数据: | 1 | 4 | 5 | 0 | 2 |此时，缓冲区容量为5；缓冲区已满！如果此时，还有“写线程”想往缓冲中写入数据，会调用put中的notFull.await()等待，直接缓冲区非满状态，才能继续运行。6, t0线程从缓冲中取出数据1。此时，缓冲区数据: | | 4 | 5 | 0 | 2 |7, p3线程向缓冲中写入3。 此时，缓冲区数据: | 3 | 4 | 5 | 0 | 2 |8, t1线程从缓冲中取出数据4。此时，缓冲区数据: | 3 | | 5 | 0 | 2 |9, p6线程向缓冲中写入6。 此时，缓冲区数据: | 3 | 6 | 5 | 0 | 2 |... 07 LockSupport概述本章介绍 JUC(java.util.concurrent) 包中的 LockSupport。内容包括：LockSupport 介绍LockSupport 函数列表LockSupport 参考代码 (基于 JDK1.7.0_40)LockSupport 示例 LockSupport 介绍LockSupport 是用来创建锁和其他同步类的基本线程阻塞原语。LockSupport 中的 park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，而且 park()和 unpark()不会遇到 “Thread.suspend 和 Thread.resume 所可能引发的死锁” 问题。因为 park() 和 unpark() 有许可的存在；调用 park() 的线程和另一个试图将其 unpark() 的线程之间的竞争将保持活性。 LockSupport 函数列表12345678910111213141516// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。static Object getBlocker(Thread t)// 为了线程调度，禁用当前线程，除非许可可用。static void park()// 为了线程调度，在许可可用之前禁用当前线程。static void park(Object blocker)// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。static void parkNanos(long nanos)// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。static void parkNanos(Object blocker, long nanos)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(long deadline)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(Object blocker, long deadline)// 如果给定线程的许可尚不可用，则使其可用。static void unpark(Thread thread) LockSupport 参考代码 (基于 JDK1.7.0_40)LockSupport.java源码 说明：LockSupport 是通过调用 Unsafe 函数中的接口实现阻塞和解除阻塞的。 LockSupport 示例对比下面的 “示例 1” 和“示例 2”可以更清晰的了解 LockSupport 的用法。 示例 1 123456789101112131415161718192021222324252627282930313233343536public class WaitTest1 &#123; public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); synchronized(ta) &#123; // 通过synchronized(ta)获取“对象ta的同步锁” try &#123; System.out.println(Thread.currentThread().getName()+" start ta"); ta.start(); System.out.println(Thread.currentThread().getName()+" block"); // 主线程等待 ta.wait(); System.out.println(Thread.currentThread().getName()+" continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; synchronized (this) &#123; // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+" wakup others"); notify(); // 唤醒“当前对象上的等待线程” &#125; &#125; &#125;&#125; 示例 2 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.locks.LockSupport;public class LockSupportTest1 &#123; private static Thread mainThread; public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); // 获取主线程 mainThread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+" start ta"); ta.start(); System.out.println(Thread.currentThread().getName()+" block"); // 主线程阻塞 LockSupport.park(mainThread); System.out.println(Thread.currentThread().getName()+" continue"); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; System.out.println(Thread.currentThread().getName()+" wakup others"); // 唤醒“主线程” LockSupport.unpark(mainThread); &#125; &#125;&#125; 运行结果： 1234main start tamain blockta wakup othersmain continue 说明：park 和 wait 的区别。wait 让线程阻塞前，必须通过 synchronized 获取同步锁。 08 共享锁和ReentrantReadWriteLock概要Java 的 JUC(java.util.concurrent) 包中的锁包括 “独占锁” 和 “共享锁”。在 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock ”中，对 Java 的独占锁进行了说明。本章对 Java 的 “共享锁” 进行介绍，JUC 中的共享锁有 CountDownLatch, CyclicBarrier, Semaphore, ReentrantReadWriteLock 等；本章会以 ReentrantReadWriteLock 为蓝本对共享锁进行说明。内容包括：ReadWriteLock 和 ReentrantReadWriteLock 介绍ReadWriteLock 和 ReentrantReadWriteLock 函数列表 ReentrantReadWriteLock 数据结构参考代码 (基于 JDK1.7.0_40) 获取共享锁 释放共享锁 公平共享锁和非公平共享锁ReentrantReadWriteLock 示例 ReadWriteLock 和 ReentrantReadWriteLock 介绍ReadWriteLock，顾名思义，是读写锁。它维护了一对相关的锁 — — “读取锁” 和 “写入锁”，一个用于读取操作，另一个用于写入操作。“读取锁” 用于只读操作，它是 “共享锁”，能同时被多个线程获取。“写入锁” 用于写入操作，它是 “独占锁”，写入锁只能被一个线程锁获取。注意：不能同时存在读取锁和写入锁！ReadWriteLock 是一个接口。ReentrantReadWriteLock 是它的实现类，ReentrantReadWriteLock 包括子类 ReadLock 和 WriteLock。 ReadWriteLock 和 ReentrantReadWriteLock 函数列表ReadWriteLock 函数列表 1234// 返回用于读取操作的锁。Lock readLock()// 返回用于写入操作的锁。Lock writeLock() ReentrantReadWriteLock 函数列表 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个新的 ReentrantReadWriteLock，默认是采用“非公平策略”。ReentrantReadWriteLock()// 创建一个新的 ReentrantReadWriteLock，fair是“公平策略”。fair为true，意味着公平策略；否则，意味着非公平策略。ReentrantReadWriteLock(boolean fair)// 返回当前拥有写入锁的线程，如果没有这样的线程，则返回 null。protected Thread getOwner()// 返回一个 collection，它包含可能正在等待获取读取锁的线程。protected Collection&lt;Thread&gt; getQueuedReaderThreads()// 返回一个 collection，它包含可能正在等待获取读取或写入锁的线程。protected Collection&lt;Thread&gt; getQueuedThreads()// 返回一个 collection，它包含可能正在等待获取写入锁的线程。protected Collection&lt;Thread&gt; getQueuedWriterThreads()// 返回等待获取读取或写入锁的线程估计数目。int getQueueLength()// 查询当前线程在此锁上保持的重入读取锁数量。int getReadHoldCount()// 查询为此锁保持的读取锁数量。int getReadLockCount()// 返回一个 collection，它包含可能正在等待与写入锁相关的给定条件的那些线程。protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition)// 返回正等待与写入锁相关的给定条件的线程估计数目。int getWaitQueueLength(Condition condition)// 查询当前线程在此锁上保持的重入写入锁数量。int getWriteHoldCount()// 查询是否给定线程正在等待获取读取或写入锁。boolean hasQueuedThread(Thread thread)// 查询是否所有的线程正在等待获取读取或写入锁。boolean hasQueuedThreads()// 查询是否有些线程正在等待与写入锁有关的给定条件。boolean hasWaiters(Condition condition)// 如果此锁将公平性设置为 ture，则返回 true。boolean isFair()// 查询是否某个线程保持了写入锁。boolean isWriteLocked()// 查询当前线程是否保持了写入锁。boolean isWriteLockedByCurrentThread()// 返回用于读取操作的锁。ReentrantReadWriteLock.ReadLock readLock()// 返回用于写入操作的锁。ReentrantReadWriteLock.WriteLock writeLock() ReentrantReadWriteLock 数据结构ReentrantReadWriteLock 的 UML 类图如下： 从中可以看出： (01) ReentrantReadWriteLock 实现了 ReadWriteLock 接口。ReadWriteLock 是一个读写锁的接口，提供了 “获取读锁的 readLock() 函数” 和 “获取写锁的 writeLock() 函数”。(02) ReentrantReadWriteLock 中包含：sync 对象，读锁 readerLock 和写锁 writerLock。读锁 ReadLock 和写锁 WriteLock 都实现了 Lock 接口。读锁 ReadLock 和写锁 WriteLock 中也都分别包含了 “Sync 对象”，它们的 Sync 对象和 ReentrantReadWriteLock 的 Sync 对象 是一样的，就是通过 sync，读锁和写锁实现了对同一个对象的访问。(03) 和 “ReentrantLock” 一样，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平锁”FairSync 和 “非公平锁”NonfairSync。sync 对象是 “FairSync” 和 “NonfairSync” 中的一个，默认是 “NonfairSync”。 参考代码 (基于 JDK1.7.0_40)ReentrantReadWriteLock 的完整源码 ReentrantReadWriteLock.java源码 其中，共享锁源码相关的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class ReadLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = -5992448646407690164L; // ReentrantReadWriteLock的AQS对象 private final Sync sync; protected ReadLock(ReentrantReadWriteLock lock) &#123; sync = lock.sync; &#125; // 获取“共享锁” public void lock() &#123; sync.acquireShared(1); &#125; // 如果线程是中断状态，则抛出一场，否则尝试获取共享锁。 public void lockInterruptibly() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; // 尝试获取“共享锁” public boolean tryLock() &#123; return sync.tryReadLock(); &#125; // 在指定时间内，尝试获取“共享锁” public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; // 释放“共享锁” public void unlock() &#123; sync.releaseShared(1); &#125; // 新建条件 public Condition newCondition() &#123; throw new UnsupportedOperationException(); &#125; public String toString() &#123; int r = sync.getReadLockCount(); return super.toString() + "[Read locks = " + r + "]"; &#125;&#125; 说明：ReadLock 中的 sync 是一个 Sync 对象，Sync 继承于 AQS 类，即 Sync 就是一个锁。ReentrantReadWriteLock 中也有一个 Sync 对象，而且 ReadLock 中的 sync 和 ReentrantReadWriteLock 中的 sync 是对应关系。即 ReentrantReadWriteLock 和 ReadLock 共享同一个 AQS 对象，共享同一把锁。ReentrantReadWriteLock 中 Sync 的定义如下： final Sync sync; 下面，分别从 “获取共享锁” 和“释放共享锁”两个方面对共享锁进行说明。 获取共享锁获取共享锁的思想 (即 lock 函数的步骤)，是先通过 tryAcquireShared() 尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过 doAcquireShared()不断的循环并尝试获取锁，若有需要，则阻塞等待。doAcquireShared()在循环中每次尝试获取锁时，都是通过 tryAcquireShared()来进行尝试的。下面看看 “获取共享锁” 的详细流程。 1. lock() lock() 在 ReadLock 中，源码如下： 123public void lock() &#123; sync.acquireShared(1);&#125; 2. acquireShared() Sync 继承于 AQS，acquireShared() 定义在 AQS 中。源码如下： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 说明：acquireShared() 首先会通过 tryAcquireShared() 来尝试获取锁。尝试成功的话，则不再做任何动作 (因为已经成功获取到锁了)。尝试失败的话，则通过 doAcquireShared() 来获取锁。doAcquireShared() 会获取到锁了才返回。 3. tryAcquireShared() tryAcquireShared() 定义在 ReentrantReadWriteLock.java 的 Sync 中，源码如下： 123456789101112131415161718192021222324252627282930313233343536protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); // 获取“锁”的状态 int c = getState(); // 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取“读取锁”的共享计数 int r = sharedCount(c); // 如果“不需要阻塞等待”，并且“读取锁”的共享计数小于MAX_COUNT； // 则通过CAS函数更新“锁的状态”，将“读取锁”的共享计数+1。 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; // 第1次获取“读取锁”。 if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程 &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; // HoldCounter是用来统计该线程获取“读取锁”的次数。 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); // 将该线程获取“读取锁”的次数+1。 rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 说明：tryAcquireShared() 的作用是尝试获取 “共享锁”。如果在尝试获取锁时，“不需要阻塞等待” 并且 “读取锁的共享计数小于 MAX_COUNT”，则直接通过 CAS 函数更新 “读取锁的共享计数”，以及将 “当前线程获取读取锁的次数 + 1”。否则，通过 fullTryAcquireShared() 获取读取锁。 4. fullTryAcquireShared() fullTryAcquireShared() 在 ReentrantReadWriteLock 中定义，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758final int fullTryAcquireShared(Thread current) &#123; HoldCounter rh = null; for (;;) &#123; // 获取“锁”的状态 int c = getState(); // 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。 if (exclusiveCount(c) != 0) &#123; if (getExclusiveOwnerThread() != current) return -1; // 如果“需要阻塞等待”。 // (01) 当“需要阻塞等待”的线程是第1个获取锁的线程的话，则继续往下执行。 // (02) 当“需要阻塞等待”的线程获取锁的次数=0时，则返回-1。 &#125; else if (readerShouldBlock()) &#123; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程 if (firstReader == current) &#123; &#125; else &#123; if (rh == null) &#123; rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) &#123; rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); &#125; &#125; // 如果当前线程获取锁的计数=0,则返回-1。 if (rh.count == 0) return -1; &#125; &#125; // 如果“不需要阻塞等待”，则获取“读取锁”的共享统计数； // 如果共享统计数超过MAX_COUNT，则抛出异常。 if (sharedCount(c) == MAX_COUNT) throw new Error("Maximum lock count exceeded"); // 将线程获取“读取锁”的次数+1。 if (compareAndSetState(c, c + SHARED_UNIT)) &#123; // 如果是第1次获取“读取锁”，则更新firstReader和firstReaderHoldCount。 if (sharedCount(c) == 0) &#123; firstReader = current; firstReaderHoldCount = 1; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程， // 则将firstReaderHoldCount+1。 &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); // 更新线程的获取“读取锁”的共享计数 rh.count++; cachedHoldCounter = rh; // cache for release &#125; return 1; &#125; &#125;&#125; 说明：fullTryAcquireShared()会根据 “是否需要阻塞等待”，“读取锁的共享计数是否超过限制” 等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过 CAS 尝试获取锁，并返回 1。 5. doAcquireShared() doAcquireShared() 定义在 AQS 函数中，源码如下： 1234567891011121314151617181920212223242526272829303132private void doAcquireShared(int arg) &#123; // addWaiter(Node.SHARED)的作用是，创建“当前线程”对应的节点，并将该线程添加到CLH队列中。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取“node”的前一节点 final Node p = node.predecessor(); // 如果“当前线程”是CLH队列的表头，则尝试获取共享锁。 if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; // 如果“当前线程”不是CLH队列的表头，则通过shouldParkAfterFailedAcquire()判断是否需要等待， // 需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。若阻塞等待过程中，线程被中断过，则设置interrupted为true。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：doAcquireShared() 的作用是获取共享锁。它会首先创建线程对应的 CLH 队列的节点，然后将该节点添加到 CLH 队列中。CLH 队列是管理获取锁的等待线程的队列。如果 “当前线程” 是 CLH 队列的表头，则尝试获取共享锁；否则，则需要通过 shouldParkAfterFailedAcquire()判断是否阻塞等待，需要的话，则通过 parkAndCheckInterrupt()进行阻塞等待。doAcquireShared() 会通过 for 循环，不断的进行上面的操作；目的就是获取共享锁。需要注意的是：doAcquireShared() 在每一次尝试获取锁时，是通过 tryAcquireShared() 来执行的！ shouldParkAfterFailedAcquire(), parkAndCheckInterrupt() 等函数已经在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) ” 中详细介绍过，这里就不再重复说明了。 释放共享锁释放共享锁的思想，是先通过 tryReleaseShared() 尝试释放共享锁。尝试成功的话，则通过 doReleaseShared() 唤醒 “其他等待获取共享锁的线程”，并返回 true；否则的话，返回 flase。 1. unlock() public void unlock() { sync.releaseShared(1);} 说明：该函数实际上调用 releaseShared(1) 释放共享锁。 2. releaseShared() releaseShared() 在 AQS 中实现，源码如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 说明：releaseShared() 的目的是让当前线程释放它所持有的共享锁。它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。 3. tryReleaseShared() tryReleaseShared() 定义在 ReentrantReadWriteLock 中，源码如下： 123456789101112131415161718192021222324252627282930313233343536protected final boolean tryReleaseShared(int unused) &#123; // 获取当前线程，即释放共享锁的线程。 Thread current = Thread.currentThread(); // 如果想要释放锁的线程(current)是第1个获取锁(firstReader)的线程， // 并且“第1个获取锁的线程获取锁的次数”=1，则设置firstReader为null； // 否则，将“第1个获取锁的线程的获取次数”-1。 if (firstReader == current) &#123; // assert firstReaderHoldCount &gt; 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; // 获取rh对象，并更新“当前线程获取锁的信息”。 &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) rh = readHolds.get(); int count = rh.count; if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; --rh.count; &#125; for (;;) &#123; // 获取锁的状态 int c = getState(); // 将锁的获取次数-1。 int nextc = c - SHARED_UNIT; // 通过CAS更新锁的状态。 if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 说明：tryReleaseShared() 的作用是尝试释放共享锁。 4. doReleaseShared() doReleaseShared() 定义在 AQS 中，源码如下： 1234567891011121314151617181920212223242526private void doReleaseShared() &#123; for (;;) &#123; // 获取CLH队列的头节点 Node h = head; // 如果头节点不为null，并且头节点不等于tail节点。 if (h != null &amp;&amp; h != tail) &#123; // 获取头节点对应的线程的状态 int ws = h.waitStatus; // 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。 if (ws == Node.SIGNAL) &#123; // 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // 唤醒“头节点的下一个节点所对应的线程”。 unparkSuccessor(h); &#125; // 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; // 如果头节点发生变化，则继续循环。否则，退出循环。 if (h == head) // loop if head changed break; &#125;&#125; 说明：doReleaseShared()会释放 “共享锁”。它会从前往后的遍历 CLH 队列，依次“唤醒” 然后 “执行” 队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的锁。 公平共享锁和非公平共享锁和互斥锁 ReentrantLock 一样，ReadLock 也分为公平锁和非公平锁。 公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数 readerShouldBlock() 是不同的。公平锁的 readerShouldBlock() 的源码如下： 123final boolean readerShouldBlock() &#123; return hasQueuedPredecessors();&#125; 在公平共享锁中，如果在当前线程的前面有其他线程在等待获取共享锁，则返回 true；否则，返回 false。非公平锁的 readerShouldBlock() 的源码如下： 123final boolean readerShouldBlock() &#123; return apparentlyFirstQueuedIsExclusive();&#125; 在非公平共享锁中，它会无视当前线程的前面是否有其他线程在等待获取共享锁。只要该非公平共享锁对应的线程不为 null，则返回 true。 ReentrantReadWriteLock 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLockTest1 &#123; public static void main(String[] args) &#123; // 创建账户 MyCount myCount = new MyCount("4238920615242830", 10000); // 创建用户，并指定账户 User user = new User("Tommy", myCount); // 分别启动3个“读取账户金钱”的线程 和 3个“设置账户金钱”的线程 for (int i=0; i&lt;3; i++) &#123; user.getCash(); user.setCash((i+1)*1000); &#125; &#125; &#125; class User &#123; private String name; //用户名 private MyCount myCount; //所要操作的账户 private ReadWriteLock myLock; //执行操作所需的锁对象 User(String name, MyCount myCount) &#123; this.name = name; this.myCount = myCount; this.myLock = new ReentrantReadWriteLock(); &#125; public void getCash() &#123; new Thread() &#123; public void run() &#123; myLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() +" getCash start"); myCount.getCash(); Thread.sleep(1); System.out.println(Thread.currentThread().getName() +" getCash end"); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; myLock.readLock().unlock(); &#125; &#125; &#125;.start(); &#125; public void setCash(final int cash) &#123; new Thread() &#123; public void run() &#123; myLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() +" setCash start"); myCount.setCash(cash); Thread.sleep(1); System.out.println(Thread.currentThread().getName() +" setCash end"); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; myLock.writeLock().unlock(); &#125; &#125; &#125;.start(); &#125;&#125;class MyCount &#123; private String id; //账号 private int cash; //账户余额 MyCount(String id, int cash) &#123; this.id = id; this.cash = cash; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public int getCash() &#123; System.out.println(Thread.currentThread().getName() +" getCash cash="+ cash); return cash; &#125; public void setCash(int cash) &#123; System.out.println(Thread.currentThread().getName() +" setCash cash="+ cash); this.cash = cash; &#125; &#125; 运行结果： 123456789101112131415161718Thread-0 getCash startThread-2 getCash startThread-0 getCash cash=10000Thread-2 getCash cash=10000Thread-0 getCash endThread-2 getCash endThread-1 setCash startThread-1 setCash cash=1000Thread-1 setCash endThread-3 setCash startThread-3 setCash cash=2000Thread-3 setCash endThread-4 getCash startThread-4 getCash cash=2000Thread-4 getCash endThread-5 setCash startThread-5 setCash cash=3000Thread-5 setCash end 结果说明：(01) 观察 Thread0 和 Thread-2 的运行结果，我们发现，Thread-0 启动并获取到 “读取锁”，在它还没运行完毕的时候，Thread-2 也启动了并且也成功获取到 “读取锁”。因此，“读取锁” 支持被多个线程同时获取。(02) 观察 Thread-1,Thread-3,Thread-5 这三个 “写入锁” 的线程。只要 “写入锁” 被某线程获取，则该线程运行完毕了，才释放该锁。因此，“写入锁” 不支持被多个线程同时获取。 09 CountDownLatch原理和示例概要前面对 “ 独占锁 “和” 共享锁 “有了个大致的了解；本章，我们对 CountDownLatch 进行学习。和 ReadWriteLock.ReadLock 一样，CountDownLatch 的本质也是一个” 共享锁 “。本章的内容包括：CountDownLatch 简介 CountDownLatch 数据结构CountDownLatch 源码分析 (基于 JDK1.7.0_40)CountDownLatch 示例 CountDownLatch 简介CountDownLatch 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 CountDownLatch 和 CyclicBarrier 的区别(01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。(02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。关于 CyclicBarrier 的原理，后面一章再来学习。 CountDownLatch 函数列表 CountDownLatch(int count)构造一个用给定计数初始化的 CountDownLatch。 12345678910// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。void await()// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。boolean await(long timeout, TimeUnit unit)// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。void countDown()// 返回当前计数。long getCount()// 返回标识此锁存器及其状态的字符串。String toString() CountDownLatch 数据结构CountDownLatch 的 UML 类图如下： CountDownLatch 的数据结构很简单，它是通过 “ 共享锁 “ 实现的。它包含了 sync 对象，sync 是 Sync 类型。Sync 是实例类，它继承于 AQS。 CountDownLatch 源码分析 (基于 JDK1.7.0_40)CountDownLatch 完整源码 (基于 JDK1.7.0_40) CountDownLatch.java完整源码 CountDownLatch 是通过 “共享锁” 实现的。下面，我们分析 CountDownLatch 中 3 个核心函数: CountDownLatch(int count), await(), countDown()。 1. CountDownLatch(int count) 1234public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count);&#125; 说明：该函数是创建一个 Sync 对象，而 Sync 是继承于 AQS 类。Sync 构造函数如下： 123Sync(int count) &#123; setState(count);&#125; setState() 在 AQS 中实现，源码如下：123protected final void setState(long newState) &#123; state = newState;&#125; 说明：在 AQS 中，state 是一个 private volatile long 类型的对象。对于 CountDownLatch 而言，state 表示的”锁计数器 “。CountDownLatch 中的 getCount() 最终是调用 AQS 中的 getState()，返回的 state 对象，即”锁计数器“。 2. await() 123public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125; 说明：该函数实际上是调用的 AQS 的 acquireSharedInterruptibly(1); AQS 中的 acquireSharedInterruptibly() 的源码如下： 1234567public final void acquireSharedInterruptibly(long arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 说明：acquireSharedInterruptibly() 的作用是获取共享锁。如果当前线程是中断状态，则抛出异常 InterruptedException。否则，调用 tryAcquireShared(arg)尝试获取共享锁；尝试成功则返回，否则就调用 doAcquireSharedInterruptibly()。doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁 (或被中断) 才返回。 tryAcquireShared() 在 CountDownLatch.java 中被重写，它的源码如下： 123protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; 说明：tryAcquireShared() 的作用是尝试获取共享锁。如果 “锁计数器 = 0”，即锁是可获取状态，则返回 1；否则，锁是不可获取状态，则返回 - 1。 123456789101112131415161718192021222324252627282930private void doAcquireSharedInterruptibly(long arg) throws InterruptedException &#123; // 创建"当前线程"的Node节点，且Node中记录的锁是"共享锁"类型；并将该节点添加到CLH队列末尾。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 获取上一个节点。 // 如果上一节点是CLH队列的表头，则"尝试获取共享锁"。 final Node p = node.predecessor(); if (p == head) &#123; long r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; // (上一节点不是CLH队列的表头) 当前线程一直等待，直到获取到共享锁。 // 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：(01) addWaiter(Node.SHARED)的作用是，创建”当前线程 “的 Node 节点，且 Node 中记录的锁的类型是” 共享锁“(Node.SHARED)；并将该节点添加到 CLH 队列末尾。关于 Node 和 CLH 在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)“ 已经详细介绍过，这里就不再重复说明了。(02) node.predecessor() 的作用是，获取上一个节点。如果上一节点是 CLH 队列的表头，则” 尝试获取共享锁 “。(03) shouldParkAfterFailedAcquire() 的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回 true；否则，返回 false。(04) 当 shouldParkAfterFailedAcquire() 返回 ture 时，则调用 parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。doAcquireSharedInterruptibly() 中的 shouldParkAfterFailedAcquire(), parkAndCheckInterrupt 等函数在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)“ 中介绍过，这里也就不再详细说明了。 3. countDown() 123public void countDown() &#123; sync.releaseShared(1);&#125; 说明：该函数实际上调用 releaseShared(1) 释放共享锁。 releaseShared() 在 AQS 中实现，源码如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 说明：releaseShared() 的目的是让当前线程释放它所持有的共享锁。它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。 tryReleaseShared() 在 CountDownLatch.java 中被重写，源码如下： 1234567891011121314protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; // 获取“锁计数器”的状态 int c = getState(); if (c == 0) return false; // “锁计数器”-1 int nextc = c-1; // 通过CAS函数进行赋值。 if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 说明：tryReleaseShared()的作用是释放共享锁，将 “锁计数器” 的值 - 1。 总结：CountDownLatch 是通过 “共享锁” 实现的。在创建 CountDownLatch 中时，会传递一个 int 类型参数 count，该参数是 “锁计数器” 的初始状态，表示该 “共享锁” 最多能被 count 个线程同时获取。当某线程调用该 CountDownLatch 对象的 await()方法时，该线程会等待 “共享锁” 可用时，才能获取 “共享锁” 进而继续运行。而 “共享锁” 可用的条件，就是 “锁计数器” 的值为 0！而 “锁计数器” 的初始值为 count，每当一个线程调用该 CountDownLatch 对象的 countDown()方法时，才将 “锁计数器”减1；通过这种方式，必须有 count 个线程调用 countDown() 之后，“锁计数器”才为 0，而前面提到的等待线程才能继续运行！ 以上，就是 CountDownLatch 的实现原理。 CountDownLatch 的使用示例下面通过 CountDownLatch 实现：”主线程” 等待 “5 个子线程” 全部都完成 “指定的工作 (休眠 1000ms)” 之后，再继续运行。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.CountDownLatch;import java.util.concurrent.CyclicBarrier;public class CountDownLatchTest1 &#123; private static int LATCH_SIZE = 5; private static CountDownLatch doneSignal; public static void main(String[] args) &#123; try &#123; doneSignal = new CountDownLatch(LATCH_SIZE); // 新建5个任务 for(int i=0; i&lt;LATCH_SIZE; i++) new InnerThread().start(); System.out.println("main await begin."); // "主线程"等待线程池中5个任务的完成 doneSignal.await(); System.out.println("main await finished."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + " sleep 1000ms."); // 将CountDownLatch的数值减1 doneSignal.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234567main await begin.Thread-0 sleep 1000ms.Thread-2 sleep 1000ms.Thread-1 sleep 1000ms.Thread-4 sleep 1000ms.Thread-3 sleep 1000ms.main await finished. 结果说明：主线程通过 doneSignal.await() 等待其它线程将 doneSignal 递减至 0。其它的 5 个 InnerThread 线程，每一个都通过 doneSignal.countDown() 将 doneSignal 的值减 1；当 doneSignal 为 0 时，main 被唤醒后继续执行。 10 CyclicBarrier原理和示例概要本章介绍 JUC 包中的 CyclicBarrier 锁。内容包括：CyclicBarrier 简介CyclicBarrier 数据结构CyclicBarrier 源码分析 (基于 JDK1.7.0_40)CyclicBarrier 示例 CyclicBarrier 简介CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 注意比较 CountDownLatch 和 CyclicBarrier：(01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。(02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。 CyclicBarrier 函数列表 1234567891011121314151617CyclicBarrier(int parties)//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。CyclicBarrier(int parties, Runnable barrierAction)//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。int await()//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。int await(long timeout, TimeUnit unit)//在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。int getNumberWaiting()//返回当前在屏障处等待的参与者数目。int getParties()//返回要求启动此 barrier 的参与者数目。boolean isBroken()//查询此屏障是否处于损坏状态。void reset()//将屏障重置为其初始状态。 CyclicBarrier 数据结构CyclicBarrier 的 UML 类图如下： CyclicBarrier 是包含了 “ReentrantLock 对象 lock”和”Condition 对象 trip”，它是通过独占锁实现的。下面通过源码去分析到底是如何实现的。 CyclicBarrier 源码分析 (基于 JDK1.7.0_40)CyclicBarrier 完整源码 (基于 JDK1.7.0_40) CyclicBarrier.java源码 CyclicBarrier 是通过 ReentrantLock(独占锁) 和 Condition 来实现的。下面，我们分析 CyclicBarrier 中 3 个核心函数: 构造函数, await() 作出分析。 1. 构造函数 CyclicBarrier 的构造函数共 2 个：CyclicBarrier 和 CyclicBarrier(int parties, Runnable barrierAction)。第 1 个构造函数是调用第 2 个构造函数来实现的，下面第 2 个构造函数的源码。 123456789public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); // parties表示“必须同时到达barrier的线程个数”。 this.parties = parties; // count表示“处在等待状态的线程个数”。 this.count = parties; // barrierCommand表示“parties个线程到达barrier时，会执行的动作”。 this.barrierCommand = barrierAction;&#125; 2. 等待函数 CyclicBarrier.java 中 await() 方法如下： 1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen; &#125;&#125; 说明：await() 是通过 dowait() 实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; // 获取“独占锁(lock)” lock.lock(); try &#123; // 保存“当前的generation” final Generation g = generation; // 若“当前generation已损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; // 将“count计数器”-1 int index = --count; // 如果index=0，则意味着“有parties个线程到达barrier”。 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; // 如果barrierCommand不为null，则执行该动作。 final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; // 唤醒所有等待线程，并更新generation。 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; // 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生， // 当前线程才继续执行。 for (;;) &#123; try &#123; // 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。 if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; // 如果等待过程中，线程被中断，则执行下面的函数。 if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; Thread.currentThread().interrupt(); &#125; &#125; // 如果“当前generation已经损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果“generation已经换代”，则返回index。 if (g != generation) return index; // 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; // 释放“独占锁(lock)” lock.unlock(); &#125;&#125; 说明：dowait()的作用就是让当前线程阻塞，直到 “有 parties 个线程到达 barrier” 或 “当前线程被中断” 或 “超时” 这 3 者之一发生，当前线程才继续执行。(01) generation 是 CyclicBarrier 的一个成员遍历，它的定义如下： 12345private Generation generation = new Generation();private static class Generation &#123; boolean broken = false;&#125; 在 CyclicBarrier 中，同一批的线程属于同一代，即同一个 Generation；CyclicBarrier 中通过 generation 对象，记录属于哪一代。当有 parties 个线程到达 barrier，generation 就会被更新换代。 (02) 如果当前线程被中断，即 Thread.interrupted() 为 true；则通过 breakBarrier() 终止 CyclicBarrier。breakBarrier() 的源码如下： 12345private void breakBarrier() &#123; generation.broken = true; count = parties; trip.signalAll();&#125; breakBarrier()会设置当前中断标记 broken 为 true，意味着 “将该 Generation 中断”；同时，设置 count=parties，即重新初始化 count；最后，通过 signalAll() 唤醒 CyclicBarrier 上所有的等待线程。 (03) 将 “count 计数器”-1，即 –count；然后判断是不是 “有 parties 个线程到达 barrier”，即 index 是不是为 0。当 index=0 时，如果 barrierCommand 不为 null，则执行该 barrierCommand，barrierCommand 就是我们创建 CyclicBarrier 时，传入的 Runnable 对象。然后，调用 nextGeneration() 进行换代工作，nextGeneration() 的源码如下： 12345private void nextGeneration() &#123; trip.signalAll(); count = parties; generation = new Generation();&#125; 首先，它会调用 signalAll() 唤醒 CyclicBarrier 上所有的等待线程；接着，重新初始化 count；最后，更新 generation 的值。 (04) 在 for(;;)循环中。timed 是用来表示当前是不是 “超时等待” 线程。如果不是，则通过 trip.await()进行等待；否则，调用 awaitNanos()进行超时等待。 CyclicBarrier 的使用示例示例 1新建 5 个线程，这 5 个线程达到一定的条件时，它们才继续往后运行。 12345678910111213141516171819202122232425262728293031323334 import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest1 &#123; private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) &#123; cb = new CyclicBarrier(SIZE); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " wait for CyclicBarrier."); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + " continued."); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 12345678910Thread-1 wait for CyclicBarrier.Thread-2 wait for CyclicBarrier.Thread-3 wait for CyclicBarrier.Thread-4 wait for CyclicBarrier.Thread-0 wait for CyclicBarrier.Thread-0 continued.Thread-4 continued.Thread-2 continued.Thread-3 continued.Thread-1 continued. 结果说明：主线程中新建了 5 个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到 cb 中所有线程都达到 barrier 时，这些线程才继续运行！ 示例 2 新建 5 个线程，当这 5 个线程达到一定的条件时，执行某项任务。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest2 &#123; private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) &#123; cb = new CyclicBarrier(SIZE, new Runnable () &#123; public void run() &#123; System.out.println("CyclicBarrier's parties is: "+ cb.getParties()); &#125; &#125;); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " wait for CyclicBarrier."); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + " continued."); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011Thread-1 wait for CyclicBarrier.Thread-2 wait for CyclicBarrier.Thread-3 wait for CyclicBarrier.Thread-4 wait for CyclicBarrier.Thread-0 wait for CyclicBarrier.CyclicBarrier's parties is: 5Thread-0 continued.Thread-4 continued.Thread-2 continued.Thread-3 continued.Thread-1 continued. 结果说明：主线程中新建了 5 个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到 cb 中所有线程都达到 barrier 时，执行新建 cb 时注册的 Runnable 任务。 11 Semaphore信号量的原理和示例概要本章，我们对 JUC 包中的信号量 Semaphore 进行学习。内容包括：Semaphore 简介Semaphore 数据结构Semaphore 源码分析 (基于 JDK1.7.0_40)Semaphore 示例 Semaphore 简介Semaphore 是一个计数信号量，它的本质是一个 “ 共享锁 “。 信号量维护了一个信号量许可集。线程可以通过调用 acquire() 来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过 release() 来释放它所持有的信号量许可。 Semaphore 的函数列表 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建具有给定的许可数和非公平的公平设置的 Semaphore。Semaphore(int permits)// 创建具有给定的许可数和给定的公平设置的 Semaphore。Semaphore(int permits, boolean fair)// 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。void acquire()// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞，或者线程已被中断。void acquire(int permits)// 从此信号量中获取许可，在有可用的许可前将其阻塞。void acquireUninterruptibly()// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞。void acquireUninterruptibly(int permits)// 返回此信号量中当前可用的许可数。int availablePermits()// 获取并返回立即可用的所有许可。int drainPermits()// 返回一个 collection，包含可能等待获取的线程。protected Collection&lt;Thread&gt; getQueuedThreads()// 返回正在等待获取的线程的估计数目。int getQueueLength()// 查询是否有线程正在等待获取。boolean hasQueuedThreads()// 如果此信号量的公平设置为 true，则返回 true。boolean isFair()// 根据指定的缩减量减小可用许可的数目。protected void reducePermits(int reduction)// 释放一个许可，将其返回给信号量。void release()// 释放给定数目的许可，将其返回到信号量。void release(int permits)// 返回标识此信号量的字符串，以及信号量的状态。String toString()// 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。boolean tryAcquire()// 仅在调用时此信号量中有给定数目的许可时，才从此信号量中获取这些许可。boolean tryAcquire(int permits)// 如果在给定的等待时间内此信号量有可用的所有许可，并且当前线程未被中断，则从此信号量获取给定数目的许可。boolean tryAcquire(int permits, long timeout, TimeUnit unit)// 如果在给定的等待时间内，此信号量有可用的许可并且当前线程未被中断，则从此信号量获取一个许可。boolean tryAcquire(long timeout, TimeUnit unit) Semaphore 数据结构Semaphore 的 UML 类图如下： 从图中可以看出： (01) 和 “ReentrantLock“ 一样，Semaphore 也包含了 sync 对象，sync 是 Sync 类型；而且，Sync 是一个继承于 AQS 的抽象类。 (02) Sync 包括两个子类：”公平信号量”FairSync 和 “非公平信号量”NonfairSync。sync 是 “FairSync 的实例”，或者 “NonfairSync 的实例”；默认情况下，sync 是 NonfairSync(即，默认是非公平信号量)。 Semaphore 源码分析 (基于 JDK1.7.0_40)Semaphore 完整源码 (基于 JDK1.7.0_40) Semaphore.java源码 Semaphore 是通过共享锁实现的。根据共享锁的获取原则，Semaphore 分为 “公平信号量” 和 “非公平信号量”。 “公平信号量” 和 “非公平信号量” 的区别 “公平信号量” 和 “非公平信号量” 的释放信号量的机制是一样的！不同的是它们获取信号量的机制：线程在尝试获取信号量许可时，对于公平信号量而言，如果当前线程不在 CLH 队列的头部，则排队等候；而对于非公平信号量而言，无论当前线程是不是在 CLH 队列的头部，它都会直接获取信号量。该差异具体的体现在，它们的 tryAcquireShared() 函数的实现不同。 “公平信号量” 类 12345678910111213141516171819static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125;&#125; “非公平信号量” 类 1234567891011static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125;&#125; 下面，我们逐步的对它们的源码进行分析。 1. 信号量构造函数 1234567public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; 从中，我们可以信号量分为 “公平信号量(FairSync)” 和“非公平信号量 (NonfairSync)”。Semaphore(int permits) 函数会默认创建“非公平信号量”。 2. 公平信号量获取和释放 2.1 公平信号量的获取Semaphore 中的公平信号量是 FairSync。它的获取 API 如下： 12345678public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public void acquire(int permits) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.acquireSharedInterruptibly(permits);&#125; 信号量中的 acquire() 获取函数，实际上是调用的 AQS 中的 acquireSharedInterruptibly()。 acquireSharedInterruptibly() 的源码如下： 123456789public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 如果线程是中断状态，则抛出异常。 if (Thread.interrupted()) throw new InterruptedException(); // 否则，尝试获取“共享锁”；获取成功则直接返回，获取失败，则通过doAcquireSharedInterruptibly()获取。 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; Semaphore 中”公平锁 “对应的 tryAcquireShared() 实现如下： 12345678910111213141516protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; // 判断“当前线程”是不是CLH队列中的第一个线程线程， // 若是的话，则返回-1。 if (hasQueuedPredecessors()) return -1; // 设置“可以获得的信号量的许可数” int available = getState(); // 设置“获得acquires个信号量许可之后，剩余的信号量许可数” int remaining = available - acquires; // 如果“剩余的信号量许可数&gt;=0”，则设置“可以获得的信号量许可数”为remaining。 if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125; 说明：tryAcquireShared() 的作用是尝试获取 acquires 个信号量许可数。对于 Semaphore 而言，state 表示的是 “当前可获得的信号量许可数”。 下面看看 AQS 中 doAcquireSharedInterruptibly() 的实现： 123456789101112131415161718192021222324252627282930private void doAcquireSharedInterruptibly(long arg) throws InterruptedException &#123; // 创建”当前线程“的Node节点，且Node中记录的锁是”共享锁“类型；并将该节点添加到CLH队列末尾。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 获取上一个节点。 // 如果上一节点是CLH队列的表头，则”尝试获取共享锁“。 final Node p = node.predecessor(); if (p == head) &#123; long r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; // 当前线程一直等待，直到获取到共享锁。 // 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁 (或被中断) 才返回。(01) addWaiter(Node.SHARED)的作用是，创建”当前线程 “的 Node 节点，且 Node 中记录的锁的类型是” 共享锁“(Node.SHARED)；并将该节点添加到 CLH 队列末尾。关于 Node 和 CLH 在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)“ 已经详细介绍过，这里就不再重复说明了。(02) node.predecessor() 的作用是，获取上一个节点。如果上一节点是 CLH 队列的表头，则” 尝试获取共享锁 “。(03) shouldParkAfterFailedAcquire() 的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回 true；否则，返回 false。(04) 当 shouldParkAfterFailedAcquire() 返回 ture 时，则调用 parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。doAcquireSharedInterruptibly() 中的 shouldParkAfterFailedAcquire(), parkAndCheckInterrupt 等函数在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)“ 中介绍过，这里也就不再详细说明了。 2.2 公平信号量的释放 Semaphore 中公平信号量 (FairSync) 的释放 API 如下： 12345678public void release() &#123; sync.releaseShared(1);&#125;public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits);&#125; 信号量的 releases() 释放函数，实际上是调用的 AQS 中的 releaseShared()。 releaseShared() 在 AQS 中实现，源码如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 说明：releaseShared() 的目的是让当前线程释放它所持有的共享锁。它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。 Semaphore 重写了 tryReleaseShared()，它的源码如下： 12345678910111213protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; // 获取“可以获得的信号量的许可数” int current = getState(); // 获取“释放releases个信号量许可之后，剩余的信号量许可数” int next = current + releases; if (next &lt; current) // overflow throw new Error("Maximum permit count exceeded"); // 设置“可以获得的信号量的许可数”为next。 if (compareAndSetState(current, next)) return true; &#125;&#125; 如果 tryReleaseShared() 尝试释放共享锁失败，则会调用 doReleaseShared() 去释放共享锁。doReleaseShared() 的源码如下： 1234567891011121314151617181920212223242526private void doReleaseShared() &#123; for (;;) &#123; // 获取CLH队列的头节点 Node h = head; // 如果头节点不为null，并且头节点不等于tail节点。 if (h != null &amp;&amp; h != tail) &#123; // 获取头节点对应的线程的状态 int ws = h.waitStatus; // 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。 if (ws == Node.SIGNAL) &#123; // 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // 唤醒“头节点的下一个节点所对应的线程”。 unparkSuccessor(h); &#125; // 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; // 如果头节点发生变化，则继续循环。否则，退出循环。 if (h == head) // loop if head changed break; &#125;&#125; 说明：doReleaseShared()会释放 “共享锁”。它会从前往后的遍历 CLH 队列，依次“唤醒” 然后 “执行” 队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的信号量。 3 非公平信号量获取和释放 Semaphore 中的非公平信号量是 NonFairSync。在 Semaphore 中，“非公平信号量许可的释放 (release)” 与“公平信号量许可的释放 (release)” 是一样的。不同的是它们获取 “信号量许可” 的机制不同，下面是非公平信号量获取信号量许可的代码。 非公平信号量的 tryAcquireShared() 实现如下： 123protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires);&#125; nonfairTryAcquireShared() 的实现如下： 123456789101112final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; // 设置“可以获得的信号量的许可数” int available = getState(); // 设置“获得acquires个信号量许可之后，剩余的信号量许可数” int remaining = available - acquires; // 如果“剩余的信号量许可数&gt;=0”，则设置“可以获得的信号量许可数”为remaining。 if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125; 说明：非公平信号量的 tryAcquireShared()调用 AQS 中的 nonfairTryAcquireShared()。而在 nonfairTryAcquireShared()的 for 循环中，它都会直接判断 “当前剩余的信号量许可数” 是否足够；足够的话，则直接“设置可以获得的信号量许可数”，进而再获取信号量。而公平信号量的 tryAcquireShared() 中，在获取信号量之前会通过 if (hasQueuedPredecessors()) 来判断 “当前线程是不是在 CLH 队列的头部”，是的话，则返回 - 1。 Semaphore 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; public class SemaphoreTest1 &#123; private static final int SEM_MAX = 10; public static void main(String[] args) &#123; Semaphore sem = new Semaphore(SEM_MAX); //创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(3); //在线程池中执行任务 threadPool.execute(new MyThread(sem, 5)); threadPool.execute(new MyThread(sem, 4)); threadPool.execute(new MyThread(sem, 7)); //关闭池 threadPool.shutdown(); &#125;&#125;class MyThread extends Thread &#123; private volatile Semaphore sem; // 信号量 private int count; // 申请信号量的大小 MyThread(Semaphore sem, int count) &#123; this.sem = sem; this.count = count; &#125; public void run() &#123; try &#123; // 从信号量中获取count个许可 sem.acquire(count); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + " acquire count="+count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放给定数目的许可，将其返回到信号量。 sem.release(count); System.out.println(Thread.currentThread().getName() + " release " + count + ""); &#125; &#125;&#125; (某一次) 运行结果： 123456pool-1-thread-1 acquire count=5pool-1-thread-2 acquire count=4pool-1-thread-1 release 5pool-1-thread-2 release 4pool-1-thread-3 acquire count=7pool-1-thread-3 release 7 结果说明：信号量 sem 的许可总数是 10 个；共 3 个线程，分别需要获取的信号量许可数是 5,4,7。前面两个线程获取到信号量的许可后，sem 中剩余的可用的许可数是 1；因此，最后一个线程必须等前两个线程释放了它们所持有的信号量许可之后，才能获取到 7 个信号量许可。 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列二：JUC原子类]]></title>
    <url>%2F2018%2F03%2F24%2F2018-03-24%2F</url>
    <content type="text"><![CDATA[01 框架根据修改的数据类型，可以将 JUC 包中的原子操作类可以分为 4 类。 基本类型: AtomicInteger, AtomicLong, AtomicBoolean ; 数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ; 引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ; 对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。 这些类存在的目的是对相应的数据进行原子操作。所谓原子操作，是指操作过程不会被中断，保证数据操作是以原子方式进行的。 02 AtomicLong原子类概要AtomicInteger, AtomicLong 和 AtomicBoolean 这 3 个基本类型的原子类的原理和用法相似。本章以 AtomicLong 对基本类型的原子类进行介绍。内容包括：AtomicLong 介绍和函数列表AtomicLong 源码分析 (基于 JDK1.7.0_40)AtomicLong 示例 AtomicLong 介绍和函数列表AtomicLong 是作用是对长整形进行原子操作。在 32 位操作系统中，64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操作，所以不具有原子性。而使用 AtomicLong 能让 long 的操作保持原子型。 AtomicLong 函数列表 123456789101112131415161718192021222324252627282930313233343536// 构造函数AtomicLong()// 创建值为initialValue的AtomicLong对象AtomicLong(long initialValue)// 以原子方式设置当前值为newValue。final void set(long newValue) // 获取当前值final long get() // 以原子方式将当前值减 1，并返回减1后的值。等价于“--num”final long decrementAndGet() // 以原子方式将当前值减 1，并返回减1前的值。等价于“num--”final long getAndDecrement() // 以原子方式将当前值加 1，并返回加1后的值。等价于“++num”final long incrementAndGet() // 以原子方式将当前值加 1，并返回加1前的值。等价于“num++”final long getAndIncrement() // 以原子方式将delta与当前值相加，并返回相加后的值。final long addAndGet(long delta) // 以原子方式将delta添加到当前值，并返回相加前的值。final long getAndAdd(long delta) // 如果当前值 == expect，则以原子方式将该值设置为update。成功返回true，否则返回false，并且不修改原值。final boolean compareAndSet(long expect, long update)// 以原子方式设置当前值为newValue，并返回旧值。final long getAndSet(long newValue)// 返回当前值对应的int值int intValue() // 获取当前值对应的long值long longValue() // 以 float 形式返回当前值float floatValue() // 以 double 形式返回当前值double doubleValue() // 最后设置为给定值。延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。final void lazySet(long newValue)// 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但不创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。final boolean weakCompareAndSet(long expect, long update) AtomicLong 源码分析 (基于 JDK1.7.0_40)AtomicLong 的完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255/* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. *//* * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */package java.util.concurrent.atomic;import sun.misc.Unsafe;/** * A &#123;@code long&#125; value that may be updated atomically. See the * &#123;@link java.util.concurrent.atomic&#125; package specification for * description of the properties of atomic variables. An * &#123;@code AtomicLong&#125; is used in applications such as atomically * incremented sequence numbers, and cannot be used as a replacement * for a &#123;@link java.lang.Long&#125;. However, this class does extend * &#123;@code Number&#125; to allow uniform access by tools and utilities that * deal with numerically-based classes. * * @since 1.5 * @author Doug Lea */public class AtomicLong extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 1927816293512124184L; // setup to use Unsafe.compareAndSwapLong for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; /** * Records whether the underlying JVM supports lockless * compareAndSwap for longs. While the Unsafe.compareAndSwapLong * method works in either case, some constructions should be * handled at Java level to avoid locking user-visible locks. */ static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); /** * Returns whether underlying JVM supports lockless CompareAndSet * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS. */ private static native boolean VMSupportsCS8(); static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicLong.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile long value; /** * Creates a new AtomicLong with the given initial value. * * @param initialValue the initial value */ public AtomicLong(long initialValue) &#123; value = initialValue; &#125; /** * Creates a new AtomicLong with initial value &#123;@code 0&#125;. */ public AtomicLong() &#123; &#125; /** * Gets the current value. * * @return the current value */ public final long get() &#123; return value; &#125; /** * Sets to the given value. * * @param newValue the new value */ public final void set(long newValue) &#123; value = newValue; &#125; /** * Eventually sets to the given value. * * @param newValue the new value * @since 1.6 */ public final void lazySet(long newValue) &#123; unsafe.putOrderedLong(this, valueOffset, newValue); &#125; /** * Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value */ public final long getAndSet(long newValue) &#123; while (true) &#123; long current = get(); if (compareAndSet(current, newValue)) return current; &#125; &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return true if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update); &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;May &lt;a href="package-summary.html#Spurious"&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to &#123;@code compareAndSet&#125;. * * @param expect the expected value * @param update the new value * @return true if successful. */ public final boolean weakCompareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update); &#125; /** * Atomically increments by one the current value. * * @return the previous value */ public final long getAndIncrement() &#123; while (true) &#123; long current = get(); long next = current + 1; if (compareAndSet(current, next)) return current; &#125; &#125; /** * Atomically decrements by one the current value. * * @return the previous value */ public final long getAndDecrement() &#123; while (true) &#123; long current = get(); long next = current - 1; if (compareAndSet(current, next)) return current; &#125; &#125; /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the previous value */ public final long getAndAdd(long delta) &#123; while (true) &#123; long current = get(); long next = current + delta; if (compareAndSet(current, next)) return current; &#125; &#125; /** * Atomically increments by one the current value. * * @return the updated value */ public final long incrementAndGet() &#123; for (;;) &#123; long current = get(); long next = current + 1; if (compareAndSet(current, next)) return next; &#125; &#125; /** * Atomically decrements by one the current value. * * @return the updated value */ public final long decrementAndGet() &#123; for (;;) &#123; long current = get(); long next = current - 1; if (compareAndSet(current, next)) return next; &#125; &#125; /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */ public final long addAndGet(long delta) &#123; for (;;) &#123; long current = get(); long next = current + delta; if (compareAndSet(current, next)) return next; &#125; &#125; /** * Returns the String representation of the current value. * @return the String representation of the current value. */ public String toString() &#123; return Long.toString(get()); &#125; public int intValue() &#123; return (int)get(); &#125; public long longValue() &#123; return get(); &#125; public float floatValue() &#123; return (float)get(); &#125; public double doubleValue() &#123; return (double)get(); &#125;&#125; AtomicLong 的代码很简单，下面仅以 incrementAndGet() 为例，对 AtomicLong 的原理进行说明。incrementAndGet() 源码如下： 1234567891011public final long incrementAndGet() &#123; for (;;) &#123; // 获取AtomicLong当前对应的long值 long current = get(); // 将current加1 long next = current + 1; // 通过CAS函数，更新current的值 if (compareAndSet(current, next)) return next; &#125;&#125; 说明：(01) incrementAndGet() 首先会根据 get() 获取 AtomicLong 对应的 long 值。该值是 volatile 类型的变量，get() 的源码如下： 123456// value是AtomicLong对应的long值private volatile long value;// 返回AtomicLong对应的long值public final long get() &#123; return value;&#125; (02) incrementAndGet() 接着将 current 加 1, 然后通过 CAS 函数，将新的值赋值给 value。compareAndSet() 的源码如下： 123public final boolean compareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update);&#125; compareAndSet() 的作用是更新 AtomicLong 对应的 long 值。它会比较 AtomicLong 的原始值是否与 expect 相等，若相等的话，则设置 AtomicLong 的值为 update。 AtomicLong 示例12345678910111213141516171819202122232425262728293031// LongTest.java的源码import java.util.concurrent.atomic.AtomicLong;public class LongTest &#123; public static void main(String[] args)&#123; // 新建AtomicLong对象 AtomicLong mAtoLong = new AtomicLong(); mAtoLong.set(0x0123456789ABCDEFL); System.out.printf("%20s : 0x%016X\n", "get()", mAtoLong.get()); System.out.printf("%20s : 0x%016X\n", "intValue()", mAtoLong.intValue()); System.out.printf("%20s : 0x%016X\n", "longValue()", mAtoLong.longValue()); System.out.printf("%20s : %s\n", "doubleValue()", mAtoLong.doubleValue()); System.out.printf("%20s : %s\n", "floatValue()", mAtoLong.floatValue()); System.out.printf("%20s : 0x%016X\n", "getAndDecrement()", mAtoLong.getAndDecrement()); System.out.printf("%20s : 0x%016X\n", "decrementAndGet()", mAtoLong.decrementAndGet()); System.out.printf("%20s : 0x%016X\n", "getAndIncrement()", mAtoLong.getAndIncrement()); System.out.printf("%20s : 0x%016X\n", "incrementAndGet()", mAtoLong.incrementAndGet()); System.out.printf("%20s : 0x%016X\n", "addAndGet(0x10)", mAtoLong.addAndGet(0x10)); System.out.printf("%20s : 0x%016X\n", "getAndAdd(0x10)", mAtoLong.getAndAdd(0x10)); System.out.printf("\n%20s : 0x%016X\n", "get()", mAtoLong.get()); System.out.printf("%20s : %s\n", "compareAndSet()", mAtoLong.compareAndSet(0x12345679L, 0xFEDCBA9876543210L)); System.out.printf("%20s : 0x%016X\n", "get()", mAtoLong.get()); &#125;&#125; 运行结果： 123456789101112131415 get() : 0x0123456789ABCDEF intValue() : 0x0000000089ABCDEF longValue() : 0x0123456789ABCDEF doubleValue() : 8.1985529216486896E16 floatValue() : 8.1985531E16getAndDecrement() : 0x0123456789ABCDEFdecrementAndGet() : 0x0123456789ABCDEDgetAndIncrement() : 0x0123456789ABCDEDincrementAndGet() : 0x0123456789ABCDEF addAndGet(0x10) : 0x0123456789ABCDFF getAndAdd(0x10) : 0x0123456789ABCDFF get() : 0x0123456789ABCE0F compareAndSet() : false get() : 0x0123456789ABCE0F 03 AtomicLongArray原子类概要AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray 这 3 个数组类型的原子类的原理和用法相似。本章以 AtomicLongArray 对数组类型的原子类进行介绍。内容包括：AtomicLongArray 介绍和函数列表AtomicLongArray 源码分析 (基于 JDK1.7.0_40)AtomicLongArray 示例 AtomicLongArray 介绍和函数列表在 “Java 多线程系列 –“JUC 原子类”02 之 AtomicLong 原子类 “中介绍过，AtomicLong 是作用是对长整形进行原子操作。而 AtomicLongArray 的作用则是对” 长整形数组 “ 进行原子操作。 AtomicLongArray 函数列表 123456789101112131415161718192021222324252627282930313233// 创建给定长度的新 AtomicLongArray。AtomicLongArray(int length)// 创建与给定数组具有相同长度的新AtomicLongArray，并从给定数组复制其所有元素。AtomicLongArray(long[] array)// 以原子方式将给定值添加到索引 i 的元素。long addAndGet(int i, long delta)// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean compareAndSet(int i, long expect, long update)// 以原子方式将索引 i 的元素减1。long decrementAndGet(int i)// 获取位置 i 的当前值。long get(int i)// 以原子方式将给定值与索引 i 的元素相加。long getAndAdd(int i, long delta)// 以原子方式将索引 i 的元素减 1。long getAndDecrement(int i)// 以原子方式将索引 i 的元素加 1。long getAndIncrement(int i)// 以原子方式将位置 i 的元素设置为给定值，并返回旧值。long getAndSet(int i, long newValue)// 以原子方式将索引 i 的元素加1。long incrementAndGet(int i)// 最终将位置 i 的元素设置为给定值。void lazySet(int i, long newValue)// 返回该数组的长度。int length()// 将位置 i 的元素设置为给定值。void set(int i, long newValue)// 返回数组当前值的字符串表示形式。String toString()// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean weakCompareAndSet(int i, long expect, long update) AtomicLongArray 源码分析 (基于 JDK1.7.0_40)AtomicLongArray 的完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260 /* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. *//* * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */package java.util.concurrent.atomic;import sun.misc.Unsafe;import java.util.*;/** * A &#123;@code long&#125; array in which elements may be updated atomically. * See the &#123;@link java.util.concurrent.atomic&#125; package specification * for description of the properties of atomic variables. * @since 1.5 * @author Doug Lea */public class AtomicLongArray implements java.io.Serializable &#123; private static final long serialVersionUID = -2308431214976778248L; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final int base = unsafe.arrayBaseOffset(long[].class); private static final int shift; private final long[] array; static &#123; int scale = unsafe.arrayIndexScale(long[].class); if ((scale &amp; (scale - 1)) != 0) throw new Error("data type scale not a power of two"); shift = 31 - Integer.numberOfLeadingZeros(scale); &#125; private long checkedByteOffset(int i) &#123; if (i &lt; 0 || i &gt;= array.length) throw new IndexOutOfBoundsException("index " + i); return byteOffset(i); &#125; private static long byteOffset(int i) &#123; return ((long) i &lt;&lt; shift) + base; &#125; /** * Creates a new AtomicLongArray of the given length, with all * elements initially zero. * * @param length the length of the array */ public AtomicLongArray(int length) &#123; array = new long[length]; &#125; /** * Creates a new AtomicLongArray with the same length as, and * all elements copied from, the given array. * * @param array the array to copy elements from * @throws NullPointerException if array is null */ public AtomicLongArray(long[] array) &#123; // Visibility guaranteed by final field guarantees this.array = array.clone(); &#125; /** * Returns the length of the array. * * @return the length of the array */ public final int length() &#123; return array.length; &#125; /** * Gets the current value at position &#123;@code i&#125;. * * @param i the index * @return the current value */ public final long get(int i) &#123; return getRaw(checkedByteOffset(i)); &#125; private long getRaw(long offset) &#123; return unsafe.getLongVolatile(array, offset); &#125; /** * Sets the element at position &#123;@code i&#125; to the given value. * * @param i the index * @param newValue the new value */ public final void set(int i, long newValue) &#123; unsafe.putLongVolatile(array, checkedByteOffset(i), newValue); &#125; /** * Eventually sets the element at position &#123;@code i&#125; to the given value. * * @param i the index * @param newValue the new value * @since 1.6 */ public final void lazySet(int i, long newValue) &#123; unsafe.putOrderedLong(array, checkedByteOffset(i), newValue); &#125; /** * Atomically sets the element at position &#123;@code i&#125; to the given value * and returns the old value. * * @param i the index * @param newValue the new value * @return the previous value */ public final long getAndSet(int i, long newValue) &#123; long offset = checkedByteOffset(i); while (true) &#123; long current = getRaw(offset); if (compareAndSetRaw(offset, current, newValue)) return current; &#125; &#125; /** * Atomically sets the element at position &#123;@code i&#125; to the given * updated value if the current value &#123;@code ==&#125; the expected value. * * @param i the index * @param expect the expected value * @param update the new value * @return true if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(int i, long expect, long update) &#123; return compareAndSetRaw(checkedByteOffset(i), expect, update); &#125; private boolean compareAndSetRaw(long offset, long expect, long update) &#123; return unsafe.compareAndSwapLong(array, offset, expect, update); &#125; /** * Atomically sets the element at position &#123;@code i&#125; to the given * updated value if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;May &lt;a href="package-summary.html#Spurious"&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to &#123;@code compareAndSet&#125;. * * @param i the index * @param expect the expected value * @param update the new value * @return true if successful. */ public final boolean weakCompareAndSet(int i, long expect, long update) &#123; return compareAndSet(i, expect, update); &#125; /** * Atomically increments by one the element at index &#123;@code i&#125;. * * @param i the index * @return the previous value */ public final long getAndIncrement(int i) &#123; return getAndAdd(i, 1); &#125; /** * Atomically decrements by one the element at index &#123;@code i&#125;. * * @param i the index * @return the previous value */ public final long getAndDecrement(int i) &#123; return getAndAdd(i, -1); &#125; /** * Atomically adds the given value to the element at index &#123;@code i&#125;. * * @param i the index * @param delta the value to add * @return the previous value */ public final long getAndAdd(int i, long delta) &#123; long offset = checkedByteOffset(i); while (true) &#123; long current = getRaw(offset); if (compareAndSetRaw(offset, current, current + delta)) return current; &#125; &#125; /** * Atomically increments by one the element at index &#123;@code i&#125;. * * @param i the index * @return the updated value */ public final long incrementAndGet(int i) &#123; return addAndGet(i, 1); &#125; /** * Atomically decrements by one the element at index &#123;@code i&#125;. * * @param i the index * @return the updated value */ public final long decrementAndGet(int i) &#123; return addAndGet(i, -1); &#125; /** * Atomically adds the given value to the element at index &#123;@code i&#125;. * * @param i the index * @param delta the value to add * @return the updated value */ public long addAndGet(int i, long delta) &#123; long offset = checkedByteOffset(i); while (true) &#123; long current = getRaw(offset); long next = current + delta; if (compareAndSetRaw(offset, current, next)) return next; &#125; &#125; /** * Returns the String representation of the current values of array. * @return the String representation of the current values of array */ public String toString() &#123; int iMax = array.length - 1; if (iMax == -1) return "[]"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123; b.append(getRaw(byteOffset(i))); if (i == iMax) return b.append(']').toString(); b.append(',').append(' '); &#125; &#125;&#125; AtomicLongArray 的代码很简单，下面仅以 incrementAndGet() 为例，对 AtomicLongArray 的原理进行说明。incrementAndGet() 源码如下： 123public final long incrementAndGet(int i) &#123; return addAndGet(i, 1);&#125; 说明：incrementAndGet() 的作用是以原子方式将 long 数组的索引 i 的元素加 1，并返回加 1 之后的值。 addAndGet() 源码如下： 12345678910111213public long addAndGet(int i, long delta) &#123; // 检查数组是否越界 long offset = checkedByteOffset(i); while (true) &#123; // 获取long型数组的索引 offset 的原始值 long current = getRaw(offset); // 修改long型值 long next = current + delta; // 通过CAS更新long型数组的索引 offset的值。 if (compareAndSetRaw(offset, current, next)) return next; &#125;&#125; 说明：addAndGet() 首先检查数组是否越界。如果没有越界的话，则先获取数组索引 i 的值；然后通过 CAS 函数更新 i 的值。 getRaw() 源码如下： 123private long getRaw(long offset) &#123; return unsafe.getLongVolatile(array, offset);&#125; 说明：unsafe 是通过 Unsafe.getUnsafe() 返回的一个 Unsafe 对象。通过 Unsafe 的 CAS 函数对 long 型数组的元素进行原子操作。如 compareAndSetRaw() 就是调用 Unsafe 的 CAS 函数，它的源码如下： 123private boolean compareAndSetRaw(long offset, long expect, long update) &#123; return unsafe.compareAndSwapLong(array, offset, expect, update);&#125; AtomicLongArray 示例123456789101112131415161718192021222324252627 // LongArrayTest.java的源码import java.util.concurrent.atomic.AtomicLongArray;public class LongArrayTest &#123; public static void main(String[] args)&#123; // 新建AtomicLongArray对象 long[] arrLong = new long[] &#123;10, 20, 30, 40, 50&#125;; AtomicLongArray ala = new AtomicLongArray(arrLong); ala.set(0, 100); for (int i=0, len=ala.length(); i&lt;len; i++) System.out.printf("get(%d) : %s\n", i, ala.get(i)); System.out.printf("%20s : %s\n", "getAndDecrement(0)", ala.getAndDecrement(0)); System.out.printf("%20s : %s\n", "decrementAndGet(1)", ala.decrementAndGet(1)); System.out.printf("%20s : %s\n", "getAndIncrement(2)", ala.getAndIncrement(2)); System.out.printf("%20s : %s\n", "incrementAndGet(3)", ala.incrementAndGet(3)); System.out.printf("%20s : %s\n", "addAndGet(100)", ala.addAndGet(0, 100)); System.out.printf("%20s : %s\n", "getAndAdd(100)", ala.getAndAdd(1, 100)); System.out.printf("%20s : %s\n", "compareAndSet()", ala.compareAndSet(2, 31, 1000)); System.out.printf("%20s : %s\n", "get(2)", ala.get(2)); &#125;&#125; 运行结果： 12345678910111213get(0) : 100get(1) : 20get(2) : 30get(3) : 40get(4) : 50 getAndDecrement(0) : 100 decrementAndGet(1) : 19 getAndIncrement(2) : 30 incrementAndGet(3) : 41 addAndGet(100) : 199 getAndAdd(100) : 19 compareAndSet() : true get(2) : 1000 04 AtomicReference原子类概要本章对 AtomicReference 引用类型的原子类进行介绍。内容包括：AtomicReference 介绍和函数列表AtomicReference 源码分析 (基于 JDK1.7.0_40)AtomicReference 示例 AtomicReference 介绍和函数列表AtomicReference 的作用是对 “对象” 进行原子操作。 AtomicReference 函数列表 12345678910111213141516171819// 使用 null 初始值创建新的 AtomicReference。AtomicReference()// 使用给定的初始值创建新的 AtomicReference。AtomicReference(V initialValue)// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean compareAndSet(V expect, V update)// 获取当前值。V get()// 以原子方式设置为给定值，并返回旧值。V getAndSet(V newValue)// 最终设置为给定值。void lazySet(V newValue)// 设置为给定值。void set(V newValue)// 返回当前值的字符串表示形式。String toString()// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean weakCompareAndSet(V expect, V update) AtomicReference 源码分析 (基于 JDK1.7.0_40)在 JDK1.7.0_40 中 AtomicReference.java 的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123; private static final long serialVersionUID = -1848883965231344442L; // 获取Unsafe对象，Unsafe的作用是提供CAS操作 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // volatile类型 private volatile V value; public AtomicReference(V initialValue) &#123; value = initialValue; &#125; public AtomicReference() &#123; &#125; public final V get() &#123; return value; &#125; public final void set(V newValue) &#123; value = newValue; &#125; public final void lazySet(V newValue) &#123; unsafe.putOrderedObject(this, valueOffset, newValue); &#125; public final boolean compareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update); &#125; public final boolean weakCompareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update); &#125; public final V getAndSet(V newValue) &#123; while (true) &#123; V x = get(); if (compareAndSet(x, newValue)) return x; &#125; &#125; public String toString() &#123; return String.valueOf(get()); &#125;&#125; 说明：AtomicReference 的源码比较简单。它是通过 “volatile” 和 “Unsafe 提供的 CAS 函数实现” 原子操作。(01) value 是 volatile 类型。这保证了：当某线程修改 value 的值时，其他线程看到的 value 值都是最新的 value 值，即修改之后的 volatile 的值。(02) 通过 CAS 设置 value。这保证了：当某线程池通过 CAS 函数 (如 compareAndSet 函数) 设置 value 时，它的操作是原子的，即线程在操作 value 时不会被中断。 AtomicReference 示例123456789101112131415161718192021222324252627282930// AtomicReferenceTest.java的源码import java.util.concurrent.atomic.AtomicReference;public class AtomicReferenceTest &#123; public static void main(String[] args)&#123; // 创建两个Person对象，它们的id分别是101和102。 Person p1 = new Person(101); Person p2 = new Person(102); // 新建AtomicReference对象，初始化它的值为p1对象 AtomicReference ar = new AtomicReference(p1); // 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。 ar.compareAndSet(p1, p2); Person p3 = (Person)ar.get(); System.out.println("p3 is "+p3); System.out.println("p3.equals(p1)="+p3.equals(p1)); &#125;&#125;class Person &#123; volatile long id; public Person(long id) &#123; this.id = id; &#125; public String toString() &#123; return "id:"+id; &#125;&#125; 运行结果： 12p3 is id:102p3.equals(p1)=false 结果说明：新建 AtomicReference 对象 ar 时，将它初始化为 p1。紧接着，通过 CAS 函数对它进行设置。如果 ar 的值为 p1 的话，则将其设置为 p2。最后，获取 ar 对应的对象，并打印结果。p3.equals(p1) 的结果为 false，这是因为 Person 并没有覆盖 equals() 方法，而是采用继承自 Object.java 的 equals() 方法；而 Object.java 中的 equals() 实际上是调用 “==” 去比较两个对象，即比较两个对象的地址是否相等。 05 AtomicLongFieldUpdater原子类概要AtomicIntegerFieldUpdater, AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater 这 3 个修改类的成员的原子类型的原理和用法相似。本章以对基本类型的原子类进行介绍。内容包括：AtomicLongFieldUpdater 介绍和函数列表AtomicLongFieldUpdater 源码分析 (基于 JDK1.7.0_40)AtomicLongFieldUpdater 示例 转载请注明出处：http://www.cnblogs.com/skywang12345/p/3514623.html AtomicLongFieldUpdater 介绍和函数列表AtomicLongFieldUpdater 可以对指定 “类的’volatile long’类型的成员” 进行原子更新。它是基于反射原理实现的。 AtomicLongFieldUpdater 函数列表 1234567891011121314151617181920212223242526272829// 受保护的无操作构造方法，供子类使用。protected AtomicLongFieldUpdater()// 以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值。long addAndGet(T obj, long delta)// 如果当前值 == 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值。abstract boolean compareAndSet(T obj, long expect, long update)// 以原子方式将此更新器管理的给定对象字段当前值减 1。long decrementAndGet(T obj)// 获取此更新器管理的在给定对象的字段中保持的当前值。abstract long get(T obj)// 以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值。long getAndAdd(T obj, long delta)// 以原子方式将此更新器管理的给定对象字段当前值减 1。long getAndDecrement(T obj)// 以原子方式将此更新器管理的给定对象字段的当前值加 1。long getAndIncrement(T obj)// 将此更新器管理的给定对象的字段以原子方式设置为给定值，并返回旧值。long getAndSet(T obj, long newValue)// 以原子方式将此更新器管理的给定对象字段当前值加 1。long incrementAndGet(T obj)// 最后将此更新器管理的给定对象的字段设置为给定更新值。abstract void lazySet(T obj, long newValue)// 为对象创建并返回一个具有给定字段的更新器。static &lt;U&gt; AtomicLongFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName)// 将此更新器管理的给定对象的字段设置为给定更新值。abstract void set(T obj, long newValue)// 如果当前值 == 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值。abstract boolean weakCompareAndSet(T obj, long expect, long update) AtomicLongFieldUpdater 源码分析 (基于 JDK1.7.0_40)AtomicLongFieldUpdater 完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284/* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. *//* * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */package java.util.concurrent.atomic;import java.lang.reflect.*;import sun.misc.Unsafe;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;/** * A reflection-based utility that enables atomic updates to * designated &#123;@code volatile&#125; reference fields of designated * classes. This class is designed for use in atomic data structures * in which several reference fields of the same node are * independently subject to atomic updates. For example, a tree node * might be declared as * * &lt;pre&gt; &#123;@code * class Node &#123; * private volatile Node left, right; * * private static final AtomicReferenceFieldUpdater&lt;Node, Node&gt; leftUpdater = * AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "left"); * private static AtomicReferenceFieldUpdater&lt;Node, Node&gt; rightUpdater = * AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "right"); * * Node getLeft() &#123; return left; &#125; * boolean compareAndSetLeft(Node expect, Node update) &#123; * return leftUpdater.compareAndSet(this, expect, update); * &#125; * // ... and so on * &#125;&#125;&lt;/pre&gt; * * &lt;p&gt;Note that the guarantees of the &#123;@code compareAndSet&#125; * method in this class are weaker than in other atomic classes. * Because this class cannot ensure that all uses of the field * are appropriate for purposes of atomic access, it can * guarantee atomicity only with respect to other invocations of * &#123;@code compareAndSet&#125; and &#123;@code set&#125; on the same updater. * * @since 1.5 * @author Doug Lea * @param &lt;T&gt; The type of the object holding the updatable field * @param &lt;V&gt; The type of the field */public abstract class AtomicReferenceFieldUpdater&lt;T, V&gt; &#123; /** * Creates and returns an updater for objects with the given field. * The Class arguments are needed to check that reflective types and * generic types match. * * @param tclass the class of the objects holding the field. * @param vclass the class of the field * @param fieldName the name of the field to be updated. * @return the updater * @throws IllegalArgumentException if the field is not a volatile reference type. * @throws RuntimeException with a nested reflection-based * exception if the class does not hold field or is the wrong type. */ @CallerSensitive public static &lt;U, W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; newUpdater(Class&lt;U&gt; tclass, Class&lt;W&gt; vclass, String fieldName) &#123; return new AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;(tclass, vclass, fieldName, Reflection.getCallerClass()); &#125; /** * Protected do-nothing constructor for use by subclasses. */ protected AtomicReferenceFieldUpdater() &#123; &#125; /** * Atomically sets the field of the given object managed by this updater * to the given updated value if the current value &#123;@code ==&#125; the * expected value. This method is guaranteed to be atomic with respect to * other calls to &#123;@code compareAndSet&#125; and &#123;@code set&#125;, but not * necessarily with respect to other changes in the field. * * @param obj An object whose field to conditionally set * @param expect the expected value * @param update the new value * @return true if successful. */ public abstract boolean compareAndSet(T obj, V expect, V update); /** * Atomically sets the field of the given object managed by this updater * to the given updated value if the current value &#123;@code ==&#125; the * expected value. This method is guaranteed to be atomic with respect to * other calls to &#123;@code compareAndSet&#125; and &#123;@code set&#125;, but not * necessarily with respect to other changes in the field. * * &lt;p&gt;May &lt;a href="package-summary.html#Spurious"&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to &#123;@code compareAndSet&#125;. * * @param obj An object whose field to conditionally set * @param expect the expected value * @param update the new value * @return true if successful. */ public abstract boolean weakCompareAndSet(T obj, V expect, V update); /** * Sets the field of the given object managed by this updater to the * given updated value. This operation is guaranteed to act as a volatile * store with respect to subsequent invocations of &#123;@code compareAndSet&#125;. * * @param obj An object whose field to set * @param newValue the new value */ public abstract void set(T obj, V newValue); /** * Eventually sets the field of the given object managed by this * updater to the given updated value. * * @param obj An object whose field to set * @param newValue the new value * @since 1.6 */ public abstract void lazySet(T obj, V newValue); /** * Gets the current value held in the field of the given object managed * by this updater. * * @param obj An object whose field to get * @return the current value */ public abstract V get(T obj); /** * Atomically sets the field of the given object managed by this updater * to the given value and returns the old value. * * @param obj An object whose field to get and set * @param newValue the new value * @return the previous value */ public V getAndSet(T obj, V newValue) &#123; for (;;) &#123; V current = get(obj); if (compareAndSet(obj, current, newValue)) return current; &#125; &#125; private static final class AtomicReferenceFieldUpdaterImpl&lt;T,V&gt; extends AtomicReferenceFieldUpdater&lt;T,V&gt; &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private final long offset; private final Class&lt;T&gt; tclass; private final Class&lt;V&gt; vclass; private final Class cclass; /* * Internal type checks within all update methods contain * internal inlined optimizations checking for the common * cases where the class is final (in which case a simple * getClass comparison suffices) or is of type Object (in * which case no check is needed because all objects are * instances of Object). The Object case is handled simply by * setting vclass to null in constructor. The targetCheck and * updateCheck methods are invoked when these faster * screenings fail. */ AtomicReferenceFieldUpdaterImpl(Class&lt;T&gt; tclass, Class&lt;V&gt; vclass, String fieldName, Class&lt;?&gt; caller) &#123; Field field = null; Class fieldClass = null; int modifiers = 0; try &#123; field = tclass.getDeclaredField(fieldName); modifiers = field.getModifiers(); sun.reflect.misc.ReflectUtil.ensureMemberAccess( caller, tclass, null, modifiers); sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass); fieldClass = field.getType(); &#125; catch (Exception ex) &#123; throw new RuntimeException(ex); &#125; if (vclass != fieldClass) throw new ClassCastException(); if (!Modifier.isVolatile(modifiers)) throw new IllegalArgumentException("Must be volatile type"); this.cclass = (Modifier.isProtected(modifiers) &amp;&amp; caller != tclass) ? caller : null; this.tclass = tclass; if (vclass == Object.class) this.vclass = null; else this.vclass = vclass; offset = unsafe.objectFieldOffset(field); &#125; void targetCheck(T obj) &#123; if (!tclass.isInstance(obj)) throw new ClassCastException(); if (cclass != null) ensureProtectedAccess(obj); &#125; void updateCheck(T obj, V update) &#123; if (!tclass.isInstance(obj) || (update != null &amp;&amp; vclass != null &amp;&amp; !vclass.isInstance(update))) throw new ClassCastException(); if (cclass != null) ensureProtectedAccess(obj); &#125; public boolean compareAndSet(T obj, V expect, V update) &#123; if (obj == null || obj.getClass() != tclass || cclass != null || (update != null &amp;&amp; vclass != null &amp;&amp; vclass != update.getClass())) updateCheck(obj, update); return unsafe.compareAndSwapObject(obj, offset, expect, update); &#125; public boolean weakCompareAndSet(T obj, V expect, V update) &#123; // same implementation as strong form for now if (obj == null || obj.getClass() != tclass || cclass != null || (update != null &amp;&amp; vclass != null &amp;&amp; vclass != update.getClass())) updateCheck(obj, update); return unsafe.compareAndSwapObject(obj, offset, expect, update); &#125; public void set(T obj, V newValue) &#123; if (obj == null || obj.getClass() != tclass || cclass != null || (newValue != null &amp;&amp; vclass != null &amp;&amp; vclass != newValue.getClass())) updateCheck(obj, newValue); unsafe.putObjectVolatile(obj, offset, newValue); &#125; public void lazySet(T obj, V newValue) &#123; if (obj == null || obj.getClass() != tclass || cclass != null || (newValue != null &amp;&amp; vclass != null &amp;&amp; vclass != newValue.getClass())) updateCheck(obj, newValue); unsafe.putOrderedObject(obj, offset, newValue); &#125; public V get(T obj) &#123; if (obj == null || obj.getClass() != tclass || cclass != null) targetCheck(obj); return (V)unsafe.getObjectVolatile(obj, offset); &#125; private void ensureProtectedAccess(T obj) &#123; if (cclass.isInstance(obj)) &#123; return; &#125; throw new RuntimeException( new IllegalAccessException("Class " + cclass.getName() + " can not access a protected member of class " + tclass.getName() + " using an instance of " + obj.getClass().getName() ) ); &#125; &#125;&#125; 下面分析 LongFieldTest.java 的流程。 1. newUpdater()newUpdater() 的源码如下： 1234567public static &lt;U&gt; AtomicLongFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); if (AtomicLong.VM_SUPPORTS_LONG_CAS) return new CASUpdater&lt;U&gt;(tclass, fieldName, caller); else return new LockedUpdater&lt;U&gt;(tclass, fieldName, caller);&#125; 说明：newUpdater() 的作用是获取一个 AtomicIntegerFieldUpdater 类型的对象。它实际上返回的是 CASUpdater 对象，或者 LockedUpdater 对象；具体返回哪一个类取决于 JVM 是否支持 long 类型的 CAS 函数。CASUpdater 和 LockedUpdater 都是 AtomicIntegerFieldUpdater 的子类，它们的实现类似。下面以 CASUpdater 来进行说明。 CASUpdater 类的源码如下： 1234public boolean compareAndSet(T obj, long expect, long update) &#123; if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); return unsafe.compareAndSwapLong(obj, offset, expect, update);&#125; 说明：它实际上是通过 CAS 函数操作。如果类的 long 对象的值是 expect，则设置它的值为 update。 AtomicLongFieldUpdater 示例123456789101112131415161718192021222324252627282930// LongTest.java的源码import java.util.concurrent.atomic.AtomicLongFieldUpdater;public class LongFieldTest &#123; public static void main(String[] args) &#123; // 获取Person的class对象 Class cls = Person.class; // 新建AtomicLongFieldUpdater对象，传递参数是“class对象”和“long类型在类中对应的名称” AtomicLongFieldUpdater mAtoLong = AtomicLongFieldUpdater.newUpdater(cls, "id"); Person person = new Person(12345678L); // 比较person的"id"属性，如果id的值为12345678L，则设置为1000。 mAtoLong.compareAndSet(person, 12345678L, 1000); System.out.println("id="+person.getId()); &#125;&#125;class Person &#123; volatile long id; public Person(long id) &#123; this.id = id; &#125; public void setId(long id) &#123; this.id = id; &#125; public long getId() &#123; return id; &#125;&#125; 运行结果： 1id=1000 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列一：基础篇]]></title>
    <url>%2F2018%2F03%2F23%2F2018-03-23-1%2F</url>
    <content type="text"><![CDATA[01 基本概念多线程是 Java 中不可避免的一个重要主体。从本章开始，我们将展开对多线程的学习。接下来的内容，是对 “JDK 中新增 JUC 包” 之前的 Java 多线程内容的讲解，涉及到的内容包括，Object 类中的 wait(), notify()等接口；Thread 类中的接口；synchronized 关键字。 注：JUC 包是指，Java.util.concurrent 包，它是由 Java 大师 Doug Lea 完成并在 JDK1.5 版本添加到 Java 中的 在进入后面章节的学习之前，先了解一些多线程的相关概念。线程状态图 说明：线程共包括以下 5 种状态。1. 新建状态 (New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。2. 就绪状态 (Runnable): 也被称为 “可执行状态”。线程对象被创建后，其它线程调用了该对象的 start() 方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被 CPU 调度执行。3. 运行状态 (Running) : 线程获取 CPU 权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。4. 阻塞状态 (Blocked) : 阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： (01) 等待阻塞 – 通过调用线程的 wait() 方法，让线程等待某工作的完成。 (02) 同步阻塞 – 线程在获取 synchronized 同步锁失败 (因为锁被其它线程所占用)，它会进入同步阻塞状态。 (03) 其他阻塞 – 通过调用线程的 sleep() 或 join() 或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。5. 死亡状态 (Dead) : 线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期。 这 5 种状态涉及到的内容包括 Object 类, Thread 和 synchronized 关键字。这些内容我们会在后面的章节中逐个进行学习。Object 类，定义了 wait(), notify(), notifyAll() 等休眠 / 唤醒函数。Thread 类，定义了一些列的线程操作函数。例如，sleep() 休眠函数, interrupt() 中断函数, getName() 获取线程名称等。synchronized，是关键字；它区分为 synchronized 代码块和 synchronized 方法。synchronized 的作用是让线程获取对象的同步锁。在后面详细介绍 wait(),notify()等方法时，我们会分析为什么 “wait(), notify() 等方法要定义在 Object 类，而不是 Thread 类中”。 02 常用的实现多线程的两种方式概要本章，我们学习 “常用的实现多线程的 2 种方式”：Thread 和 Runnable。之所以说是常用的，是因为通过还可以通过 java.util.concurrent 包中的线程池来实现多线程。关于线程池的内容，我们以后会详细介绍；现在，先对的 Thread 和 Runnable 进行了解。本章内容包括：Thread 和 Runnable 的简介Thread 和 Runnable 的异同点Thread 和 Runnable 的多线程的示例 Thread 和 Runnable 简介Runnable 是一个接口，该接口中只包含了一个 run() 方法。它的定义如下： 123public interface Runnable &#123; public abstract void run();&#125; Runnable 的作用，实现多线程。我们可以定义一个类 A 实现 Runnable 接口；然后，通过 new Thread(new A()) 等方式新建线程。 Thread 是一个类。Thread 本身就实现了 Runnable 接口。它的声明如下： 1public class Thread implements Runnable &#123;&#125; Thread 的作用，实现多线程。 Thread 和 Runnable 的异同点Thread 和 Runnable 的相同点：都是 “多线程的实现方式”。Thread 和 Runnable 的不同点：Thread 是类，而 Runnable 是接口；Thread 本身是实现了 Runnable 接口的类。我们知道 “一个类只能有一个父类，但是却能实现多个接口”，因此 Runnable 具有更好的扩展性。此外，Runnable 还可以用于 “资源的共享”。即，多个线程都是基于某一个 Runnable 对象建立的，它们会共享 Runnable 对象上的资源。通常，建议通过 “Runnable” 实现多线程！ Thread 和 Runnable 的多线程示例1. Thread 的多线程示例下面通过示例更好的理解 Thread 和 Runnable，借鉴网上一个例子比较具有说服性的例子。 1234567891011121314151617181920212223// ThreadTest.java 源码class MyThread extends Thread&#123; private int ticket=10; public void run()&#123; for(int i=0;i&lt;20;i++)&#123; if(this.ticket&gt;0)&#123; System.out.println(this.getName()+" 卖票：ticket"+this.ticket--); &#125; &#125; &#125; &#125;;public class ThreadTest &#123; public static void main(String[] args) &#123; // 启动3个线程t1,t2,t3；每个线程各卖10张票！ MyThread t1=new MyThread(); MyThread t2=new MyThread(); MyThread t3=new MyThread(); t1.start(); t2.start(); t3.start(); &#125; &#125; 运行结果： 123456789101112131415161718192021222324252627282930Thread-0 卖票：ticket10Thread-1 卖票：ticket10Thread-2 卖票：ticket10Thread-1 卖票：ticket9Thread-0 卖票：ticket9Thread-1 卖票：ticket8Thread-2 卖票：ticket9Thread-1 卖票：ticket7Thread-0 卖票：ticket8Thread-1 卖票：ticket6Thread-2 卖票：ticket8Thread-1 卖票：ticket5Thread-0 卖票：ticket7Thread-1 卖票：ticket4Thread-2 卖票：ticket7Thread-1 卖票：ticket3Thread-0 卖票：ticket6Thread-1 卖票：ticket2Thread-2 卖票：ticket6Thread-2 卖票：ticket5Thread-2 卖票：ticket4Thread-1 卖票：ticket1Thread-0 卖票：ticket5Thread-2 卖票：ticket3Thread-0 卖票：ticket4Thread-2 卖票：ticket2Thread-0 卖票：ticket3Thread-2 卖票：ticket1Thread-0 卖票：ticket2Thread-0 卖票：ticket1 结果说明： (01) MyThread 继承于 Thread，它是自定义个线程。每个 MyThread 都会卖出 10 张票。(02) 主线程 main 创建并启动 3 个 MyThread 子线程。每个子线程都各自卖出了 10 张票。 2. Runnable 的多线程示例下面，我们对上面的程序进行修改。通过 Runnable 实现一个接口，从而实现多线程。 12345678910111213141516171819202122232425// RunnableTest.java 源码class MyThread implements Runnable&#123; private int ticket=10; public void run()&#123; for(int i=0;i&lt;20;i++)&#123; if(this.ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+" 卖票：ticket"+this.ticket--); &#125; &#125; &#125; &#125;; public class RunnableTest &#123; public static void main(String[] args) &#123; MyThread mt=new MyThread(); // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！ Thread t1=new Thread(mt); Thread t2=new Thread(mt); Thread t3=new Thread(mt); t1.start(); t2.start(); t3.start(); &#125; &#125; 运行结果： 12345678910Thread-0 卖票：ticket10Thread-2 卖票：ticket8Thread-1 卖票：ticket9Thread-2 卖票：ticket6Thread-0 卖票：ticket7Thread-2 卖票：ticket4Thread-1 卖票：ticket5Thread-2 卖票：ticket2Thread-0 卖票：ticket3Thread-1 卖票：ticket1 结果说明：(01) 和上面 “MyThread 继承于 Thread” 不同；这里的 MyThread 实现了 Thread 接口。(02) 主线程 main 创建并启动 3 个子线程，而且这 3 个子线程都是基于 “mt 这个 Runnable 对象” 而创建的。运行结果是这 3 个子线程一共卖出了 10 张票。这说明它们是共享了 MyThread 接口的。 03 Thread中start()和run()的区别概要Thread 类包含 start() 和 run() 方法，它们的区别是什么？本章将对此作出解答。本章内容包括：start() 和 run() 的区别说明start() 和 run() 的区别示例start() 和 run() 相关源码 (基于 JDK1.7.0_40) start() 和 run() 的区别说明start() : 它的作用是启动一个新线程，新线程会执行相应的 run() 方法。start() 不能被重复调用。run() : run() 就和普通的成员方法一样，可以被重复调用。单独调用 run() 的话，会在当前线程中执行 run()，而并不会启动新线程！ 下面以代码来进行说明。 123456class MyThread extends Thread&#123; public void run()&#123; ... &#125; &#125;;MyThread mythread = new MyThread(); mythread.start() 会启动一个新线程，并在新线程中运行 run() 方法。而 mythread.run() 则会直接在当前线程中运行 run() 方法，并不会启动一个新线程来运行 run()。 start() 和 run() 的区别示例下面，通过一个简单示例演示它们之间的区别。源码如下： 12345678910111213141516171819202122// Demo.java 的源码class MyThread extends Thread&#123; public MyThread(String name) &#123; super(name); &#125; public void run()&#123; System.out.println(Thread.currentThread().getName()+" is running"); &#125; &#125;; public class Demo &#123; public static void main(String[] args) &#123; Thread mythread=new MyThread("mythread"); System.out.println(Thread.currentThread().getName()+" call mythread.run()"); mythread.run(); System.out.println(Thread.currentThread().getName()+" call mythread.start()"); mythread.start(); &#125; &#125; 运行结果： 1234main call mythread.run()main is runningmain call mythread.start()mythread is running 结果说明：(01) Thread.currentThread().getName()是用于获取 “当前线程” 的名字。当前线程是指正在 cpu 中调度执行的线程。(02) mythread.run()是在 “主线程 main” 中调用的，该 run()方法直接运行在 “主线程 main” 上。(03) mythread.start()会启动 “线程 mythread”，“线程 mythread” 启动之后，会调用 run()方法；此时的 run()方法是运行在 “线程 mythread” 上。 start() 和 run() 相关源码 (基于 JDK1.7.0_40)Thread.java 中 start() 方法的源码如下： 1234567891011121314151617181920212223public synchronized void start() &#123; // 如果线程不是"就绪状态"，则抛出异常！ if (threadStatus != 0) throw new IllegalThreadStateException(); // 将线程添加到ThreadGroup中 group.add(this); boolean started = false; try &#123; // 通过start0()启动线程 start0(); // 设置started标记 started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125;&#125; 说明：start() 实际上是通过本地方法 start0() 启动线程的。而 start0() 会新运行一个线程，新线程会调用 run() 方法。 1private native void start0(); Thread.java 中 run() 的代码如下： 12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 说明：target 是一个 Runnable 对象。run() 就是直接调用 Thread 线程的 Runnable 成员的 run() 方法，并不会新建一个线程。 04 synchronized关键字概要本章，会对 synchronized 关键字进行介绍。涉及到的内容包括：1. synchronized 原理2. synchronized 基本规则3. synchronized 方法 和 synchronized 代码块4. 实例锁 和 全局锁 1. synchronized 原理在 java 中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当我们调用某对象的 synchronized 方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了 “obj 这个对象” 的同步锁。不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对 “对象 / 方法” 的互斥访问。 例如，现在有两个线程 A 和线程 B，它们都会访问 “对象 obj 的同步锁”。假设，在某一时刻，线程 A 获取到“obj 的同步锁” 并在执行一些操作；而此时，线程 B 也企图获取 “obj 的同步锁” —— 线程 B 会获取失败，它必须等待，直到线程 A 释放了“该对象的同步锁” 之后线程 B 才能获取到 “obj 的同步锁” 从而才可以运行。 2. synchronized 基本规则我们将 synchronized 的基本规则总结为下面 3 条，并通过实例对它们进行说明。 第一条: 当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程对 “该对象”的该 “synchronized 方法” 或者 “synchronized 代码块” 的访问将被阻塞。 第二条: 当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程仍然可以访问 “该对象” 的非同步代码块。 第三条: 当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程对 “该对象”的其他的 “synchronized 方法” 或者 “synchronized 代码块” 的访问将被阻塞。 第一条当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程对 “该对象” 的该 “synchronized 方法” 或者 “synchronized 代码块” 的访问将被阻塞。下面是 “synchronized 代码块” 对应的演示程序。 1234567891011121314151617181920212223242526 class MyRunable implements Runnable &#123; //注意这里是implements实现 @Override public void run() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125;public class Demo1_1 &#123; public static void main(String[] args) &#123; Runnable demo = new MyRunable(); // 新建“Runnable对象” Thread t1 = new Thread(demo, "t1"); // 新建“线程t1”, t1是基于demo这个Runnable对象 Thread t2 = new Thread(demo, "t2"); // 新建“线程t2”, t2是基于demo这个Runnable对象 t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” &#125; &#125; 运行结果： 12345678910t1 loop 0t1 loop 1t1 loop 2t1 loop 3t1 loop 4t2 loop 0t2 loop 1t2 loop 2t2 loop 3t2 loop 4 结果说明：run()方法中存在 “synchronized(this) 代码块”，而且 t1 和 t2 都是基于 “demo 这个 Runnable 对象” 创建的线程。这就意味着，我们可以将 synchronized(this)中的 this 看作是 “demo 这个 Runnable 对象”；因此，线程 t1 和 t2 共享“demo 对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程” 释放 “demo 的同步锁” 之后才能运行。 如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下： 1234567891011121314151617181920212223242526272829class MyThread extends Thread &#123; //注意这里是extends继承 public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125;public class Demo1_2 &#123; public static void main(String[] args) &#123; Thread t1 = new MyThread("t1"); // 新建“线程t1” Thread t2 = new MyThread("t2"); // 新建“线程t2” t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” &#125; &#125; 代码说明：比较 Demo1_2 和 Demo1_1，我们发现，Demo1_2 中的 MyThread 类是直接继承于 Thread，而且 t1 和 t2 都是 MyThread 子线程。幸运的是，在 “Demo1_2 的 run() 方法”也调用了 synchronized(this)，正如 “Demo1_1 的 run() 方法”也调用了 synchronized(this)一样！那么，Demo1_2 的执行流程是不是和 Demo1_1 一样呢？运行结果： 12345678910t1 loop 0t2 loop 0t1 loop 1t2 loop 1t1 loop 2t2 loop 2t1 loop 3t2 loop 3t1 loop 4t2 loop 4 结果说明：如果这个结果一点也不令你感到惊讶，那么我相信你对 synchronized 和 this 的认识已经比较深刻了。否则的话，请继续阅读这里的分析。synchronized(this)中的 this 是指 “当前的类对象”，即 synchronized(this) 所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。对于 Demo1_2 中，synchronized(this) 中的 this 代表的是 MyThread 对象，而 t1 和 t2 是两个不同的 MyThread 对象，因此 t1 和 t2 在执行 synchronized(this) 时，获取的是不同对象的同步锁。对于 Demo1_1 对而言，synchronized(this) 中的 this 代表的是 MyRunable 对象；t1 和 t2 共同一个 MyRunable 对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。 第二条当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程仍然可以访问 “该对象” 的非同步代码块。下面是 “synchronized 代码块” 对应的演示程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Count &#123; // 含有synchronized同步块的方法 public void synMethod() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " synMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; // 非同步的方法 public void nonSynMethod() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " nonSynMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class Demo2 &#123; public static void main(String[] args) &#123; final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.synMethod(); &#125; &#125;, "t1"); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.nonSynMethod(); &#125; &#125;, "t2"); t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125; 运行结果： 12345678910t1 synMethod loop 0t2 nonSynMethod loop 0t1 synMethod loop 1t2 nonSynMethod loop 1t1 synMethod loop 2t2 nonSynMethod loop 2t1 synMethod loop 3t2 nonSynMethod loop 3t1 synMethod loop 4t2 nonSynMethod loop 4 结果说明：主线程中新建了两个子线程 t1 和 t2。t1 会调用 count 对象的 synMethod()方法，该方法内含有同步块；而 t2 则会调用 count 对象的 nonSynMethod()方法，该方法不是同步方法。t1 运行时，虽然调用 synchronized(this)获取 “count 的同步锁”；但是并没有造成 t2 的阻塞，因为 t2 没有用到“count” 同步锁。 第三条当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程对 “该对象” 的其他的 “synchronized 方法” 或者 “synchronized 代码块” 的访问将被阻塞。我们将上面的例子中的 nonSynMethod() 方法体的也用 synchronized(this) 修饰。修改后的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 class Count &#123; // 含有synchronized同步块的方法 public void synMethod() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " synMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; // 也包含synchronized同步块的方法 public void nonSynMethod() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " nonSynMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125;public class Demo3 &#123; public static void main(String[] args) &#123; final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.synMethod(); &#125; &#125;, "t1"); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.nonSynMethod(); &#125; &#125;, "t2"); t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125; 运行结果： 12345678910t1 synMethod loop 0t1 synMethod loop 1t1 synMethod loop 2t1 synMethod loop 3t1 synMethod loop 4t2 nonSynMethod loop 0t2 nonSynMethod loop 1t2 nonSynMethod loop 2t2 nonSynMethod loop 3t2 nonSynMethod loop 4 结果说明：主线程中新建了两个子线程 t1 和 t2。t1 和 t2 运行时都调用 synchronized(this)，这个 this 是 Count 对象 (count)，而 t1 和 t2 共用 count。因此，在 t1 运行时，t2 会被阻塞，等待 t1 运行释放 “count 对象的同步锁”，t2 才能运行。 3. synchronized 方法 和 synchronized 代码块“synchronized 方法” 是用 synchronized 修饰方法，而 “synchronized 代码块” 则是用 synchronized 修饰代码块。 synchronized 方法示例 123public synchronized void foo1() &#123; System.out.println("synchronized methoed");&#125; synchronized 代码块 12345public void foo2() &#123; synchronized (this) &#123; System.out.println("synchronized methoed"); &#125;&#125; synchronized 代码块中的 this 是指当前对象。也可以将 this 替换成其他对象，例如将 this 替换成 obj，则 foo2() 在执行 synchronized(obj) 时就获取的是 obj 的同步锁。 synchronized 代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示： 123456789101112131415161718192021222324252627282930// Demo4.java的源码public class Demo4 &#123; public synchronized void synMethod() &#123; for(int i=0; i&lt;1000000; i++) ; &#125; public void synBlock() &#123; synchronized( this ) &#123; for(int i=0; i&lt;1000000; i++) ; &#125; &#125; public static void main(String[] args) &#123; Demo4 demo = new Demo4(); long start, diff; start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synMethod(); // 调用“synchronized方法” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println("synMethod() : "+ diff); start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synBlock(); // 调用“synchronized方法块” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println("synBlock() : "+ diff); &#125;&#125; (某一次) 执行结果： 12synMethod() : 11synBlock() : 3 4. 实例锁 和 全局锁实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。实例锁对应的就是 synchronized 关键字。全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 全局锁对应的就是 static synchronized（或者是锁在该类的 class 或者 classloader 对象上）。 关于 “实例锁” 和“全局锁”有一个很形象的例子： 123456pulbic class Something &#123; public synchronized void isSyncA()&#123;&#125; public synchronized void isSyncB()&#123;&#125; public static synchronized void cSyncA()&#123;&#125; public static synchronized void cSyncB()&#123;&#125;&#125; 假设，Something 有两个实例 x 和 y。分析下面 4 组表达式获取的锁的情况。(01) x.isSyncA() 与 x.isSyncB()(02) x.isSyncA() 与 y.isSyncA()(03) x.cSyncA() 与 y.cSyncB()(04) x.isSyncA() 与 Something.cSyncA() (01) 不能被同时访问。因为 isSyncA()和 isSyncB()都是访问同一个对象 (对象 x) 的同步锁！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// LockTest1.java的源码class Something &#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class LockTest1 &#123; Something x = new Something(); Something y = new Something(); // 比较(01) x.isSyncA()与x.isSyncB() private void test1() &#123; // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncA(); &#125; &#125;, "t11"); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncB(); &#125; &#125;, "t12"); t11.start(); // 启动t11 t12.start(); // 启动t12 &#125; public static void main(String[] args) &#123; LockTest1 demo = new LockTest1(); demo.test1(); &#125;&#125; 运行结果： 12345678910t11 : isSyncAt11 : isSyncAt11 : isSyncAt11 : isSyncAt11 : isSyncAt12 : isSyncBt12 : isSyncBt12 : isSyncBt12 : isSyncBt12 : isSyncB (02) 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA() 访问的是 x 的同步锁，而 y.isSyncA() 访问的是 y 的同步锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 // LockTest2.java的源码class Something &#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class LockTest2 &#123; Something x = new Something(); Something y = new Something(); // 比较(02) x.isSyncA()与y.isSyncA() private void test2() &#123; // 新建t21, t21会调用 x.isSyncA() Thread t21 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncA(); &#125; &#125;, "t21"); // 新建t22, t22会调用 x.isSyncB() Thread t22 = new Thread( new Runnable() &#123; @Override public void run() &#123; y.isSyncA(); &#125; &#125;, "t22"); t21.start(); // 启动t21 t22.start(); // 启动t22 &#125; public static void main(String[] args) &#123; LockTest2 demo = new LockTest2(); demo.test2(); &#125;&#125; 运行结果： 12345678910t21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncA (03) 不能被同时访问。因为 cSyncA() 和 cSyncB() 都是 static 类型，x.cSyncA() 相当于 Something.isSyncA()，y.cSyncB() 相当于 Something.isSyncB()，因此它们共用一个同步锁，不能被同时访问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// LockTest3.java的源码class Something &#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class LockTest3 &#123; Something x = new Something(); Something y = new Something(); // 比较(03) x.cSyncA()与y.cSyncB() private void test3() &#123; // 新建t31, t31会调用 x.isSyncA() Thread t31 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.cSyncA(); &#125; &#125;, "t31"); // 新建t32, t32会调用 x.isSyncB() Thread t32 = new Thread( new Runnable() &#123; @Override public void run() &#123; y.cSyncB(); &#125; &#125;, "t32"); t31.start(); // 启动t31 t32.start(); // 启动t32 &#125; public static void main(String[] args) &#123; LockTest3 demo = new LockTest3(); demo.test3(); &#125;&#125; 运行结果： 12345678910t31 : cSyncAt31 : cSyncAt31 : cSyncAt31 : cSyncAt31 : cSyncAt32 : cSyncBt32 : cSyncBt32 : cSyncBt32 : cSyncBt32 : cSyncB (04) 可以被同时访问。因为 isSyncA() 是实例方法，x.isSyncA() 使用的是对象 x 的锁；而 cSyncA() 是静态方法，Something.cSyncA() 可以理解对使用的是 “类的锁”。因此，它们是可以被同时访问的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// LockTest4.java的源码class Something &#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class LockTest4 &#123; Something x = new Something(); Something y = new Something(); // 比较(04) x.isSyncA()与Something.cSyncA() private void test4() &#123; // 新建t41, t41会调用 x.isSyncA() Thread t41 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncA(); &#125; &#125;, "t41"); // 新建t42, t42会调用 x.isSyncB() Thread t42 = new Thread( new Runnable() &#123; @Override public void run() &#123; Something.cSyncA(); &#125; &#125;, "t42"); t41.start(); // 启动t41 t42.start(); // 启动t42 &#125; public static void main(String[] args) &#123; LockTest4 demo = new LockTest4(); demo.test4(); &#125;&#125; 运行结果： 12345678910t41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncA 05 线程等待与唤醒概要本章，会对线程等待 / 唤醒方法进行介绍。涉及到的内容包括：1. wait(), notify(), notifyAll() 等方法介绍2. wait() 和 notify()3. wait(long timeout) 和 notify()4. wait() 和 notifyAll()5. 为什么 notify(), wait() 等函数定义在 Object 中，而不是 Thread 中 1.wait(), notify(), notifyAll() 等方法介绍在 Object.java 中，定义了 wait(), notify() 和 notifyAll() 等接口。wait() 的作用是让当前线程进入等待状态，同时，wait() 也会让当前线程释放它所持有的锁。而 notify() 和 notifyAll() 的作用，则是唤醒当前对象上的等待线程；notify() 是唤醒单个线程，而 notifyAll() 是唤醒所有的线程。 Object 类中关于等待 / 唤醒的 API 详细信息如下：notify() – 唤醒在此对象监视器上等待的单个线程。notifyAll() – 唤醒在此对象监视器上等待的所有线程。wait() – 让当前线程处于 “等待(阻塞) 状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout) – 让当前线程处于 “等待(阻塞) 状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout, int nanos) – 让当前线程处于 “等待(阻塞) 状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。 2. wait() 和 notify() 示例下面通过示例演示 “wait() 和 notify() 配合使用的情形”。 12345678910111213141516171819202122232425262728293031323334353637383940// WaitTest.java的源码class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName()+" call notify()"); // 唤醒当前的wait线程 notify(); &#125; &#125;&#125;public class WaitTest &#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); synchronized(t1) &#123; try &#123; // 启动“线程t1” System.out.println(Thread.currentThread().getName()+" start t1"); t1.start(); // 主线程等待t1通过notify()唤醒。 System.out.println(Thread.currentThread().getName()+" wait()"); //虽然 t1.wait()是通过 “线程 t1” 调用的 wait()方法，但是调用 t1.wait()的地方是在 “主线程 main” 中,t1.wait()是让 “主线程” 等待，而不是“线程 t1”！ t1.wait(); System.out.println(Thread.currentThread().getName()+" continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果: 1234main start t1main wait()t1 call notify()main continue 结果说明：如下图，说明了 “主线程” 和“线程 t1”的流程。 (01) 注意，图中 “主线程” 代表 “主线程 main”。”线程 t1” 代表 WaitTest 中启动的 “线程 t1”。 而 “锁” 代表 “t1 这个对象的同步锁”。(02) “主线程”通过 new ThreadA(“t1”) 新建 “线程 t1”。随后通过 synchronized(t1) 获取 “t1 对象的同步锁”。然后调用 t1.start() 启动“线程 t1”。(03) “主线程”执行 t1.wait()是让 “主线程” 等待，而不是“线程 t1”！ ,释放 “t1 对象的锁” 并且进入 “等待(阻塞) 状态”。等待 t1 对象上的线程通过 notify() 或 notifyAll()将其唤醒。(04) “线程 t1”运行之后，通过 synchronized(this)获取 “当前对象的锁”；接着调用 notify() 唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。(05) “线程 t1”运行完毕之后，释放 “当前对象的锁”。紧接着，“主线程” 获取“t1 对象的锁”，然后接着运行。 对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让 “线程 t1” 等待；但是，为什么却是让 “主线程 main” 等待了呢？在解答该问题前，我们先看看 jdk 文档中关于 wait 的一段介绍： Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.In other words, this method behaves exactly as if it simply performs the call wait(0).The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution. 中文意思大概是： 引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。 注意：jdk 的解释中，说 wait()的作用是让 “当前线程” 等待，而 “当前线程” 是指正在 cpu 上运行的线程！这也意味着，虽然 t1.wait()是通过 “线程 t1” 调用的 wait()方法，但是调用 t1.wait()的地方是在 “主线程 main” 中。而主线程必须是 “当前线程”，也就是运行状态，才可以执行 t1.wait()。所以，此时的“当前线程” 是“主线程 main”！因此，t1.wait()是让 “主线程” 等待，而不是“线程 t1”！ 3. wait(long timeout) 和 notify()wait(long timeout)会让当前线程处于 “等待(阻塞) 状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。下面的示例就是演示 wait(long timeout) 在超时情况下，线程被唤醒的情况。 1234567891011121314151617181920212223242526272829303132333435363738// WaitTimeoutTest.java的源码class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + " run "); // 死循环，不断运行。 while(true) ; &#125;&#125;public class WaitTimeoutTest &#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); synchronized(t1) &#123; try &#123; // 启动“线程t1” System.out.println(Thread.currentThread().getName() + " start t1"); t1.start(); // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。 System.out.println(Thread.currentThread().getName() + " call wait "); t1.wait(3000); System.out.println(Thread.currentThread().getName() + " continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234main start t1main call wait t1 run // 大约3秒之后...输出“main continue”main continue 结果说明：如下图，说明了 “主线程” 和“线程 t1”的流程。(01) 注意，图中 “主线程” 代表 WaitTimeoutTest 主线程 (即，线程 main)。”线程 t1” 代表 WaitTest 中启动的线程 t1。 而 “锁” 代表 “t1 这个对象的同步锁”。(02) 主线程 main 执行 t1.start() 启动 “线程 t1”。(03) 主线程 main 执行 t1.wait(3000)，此时，主线程进入 “阻塞状态”。需要“用于 t1 对象锁的线程通过 notify() 或者 notifyAll() 将其唤醒” 或者 “超时 3000ms 之后”，主线程 main 才进入到“就绪状态”，然后才可以运行。(04) “线程 t1” 运行之后，进入了死循环，一直不断的运行。(05) 超时 3000ms 之后，主线程 main 会进入到 “就绪状态”，然后接着进入 “运行状态”。 4. wait() 和 notifyAll()通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。下面，我们通过示例演示 notifyAll() 的用法；它的作用是唤醒在此对象监视器上等待的所有线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class NotifyAllTest &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); ThreadA t3 = new ThreadA("t3"); t1.start(); t2.start(); t3.start(); try &#123; System.out.println(Thread.currentThread().getName()+" sleep(3000)"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized(obj) &#123; // 主线程等待唤醒。 System.out.println(Thread.currentThread().getName()+" notifyAll()"); obj.notifyAll(); &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run() &#123; synchronized (obj) &#123; try &#123; // 打印输出结果 System.out.println(Thread.currentThread().getName() + " wait"); // 唤醒当前的wait线程 obj.wait(); // 打印输出结果 System.out.println(Thread.currentThread().getName() + " continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 运行结果： 12345678t1 waitmain sleep(3000)t3 waitt2 waitmain notifyAll()t2 continuet3 continuet1 continue 结果说明：参考下面的流程图。(01) 主线程中新建并且启动了 3 个线程 “t1”, “t2” 和 “t3”。(02) 主线程通过 sleep(3000) 休眠 3 秒。在主线程休眠 3 秒的过程中，我们假设 “t1”, “t2” 和 “t3” 这 3 个线程都运行了。以 “t1” 为例，当它运行的时候，它会执行 obj.wait() 等待其它线程通过 notify() 或额 nofityAll() 来唤醒它；相同的道理，”t2” 和 “t3” 也会等待其它线程通过 nofity() 或 nofityAll() 来唤醒它们。(03) 主线程休眠 3 秒之后，接着运行。执行 obj.notifyAll() 唤醒 obj 上的等待线程，即唤醒 “t1”, “t2” 和 “t3” 这 3 个线程。 紧接着，主线程的 synchronized(obj)运行完毕之后，主线程释放 “obj 锁”。这样，”t1”, “t2” 和 “t3” 就可以获取“obj 锁” 而继续运行了！ 5. 为什么 notify(), wait() 等函数定义在 Object 中，而不是 Thread 中Object 中的 wait(), notify()等函数，和 synchronized 一样，会对 “对象的同步锁” 进行操作。 wait()会使 “当前线程” 等待，因为线程进入等待状态，所以线程应该释放它锁持有的 “同步锁”，否则其它线程获取不到该“同步锁” 而无法运行！OK，线程调用 wait()之后，会释放它锁持有的 “同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被 notify() 或 notifyAll()唤醒。现在，请思考一个问题：notify() 是依据什么唤醒等待线程的？或者说，wait() 等待线程和 notify() 之间是通过什么关联起来的？答案是：依据 “对象的同步锁”。 负责唤醒等待线程的那个线程 (我们称为 “唤醒线程”)，它只有在获取 “该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用 notify()或 notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有 “该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁” 之后，等待线程才能获取到 “对象的同步锁” 进而继续运行。 总之，notify(), wait()依赖于 “同步锁”，而“同步锁” 是对象锁持有，并且每个对象有且仅有一个！这就是为什么 notify(), wait()等函数定义在 Object 类，而不是 Thread 类中的原因。 06 线程让步概要本章，会对 Thread 中的线程让步方法 yield() 进行介绍。涉及到的内容包括：1. yield() 介绍2. yield() 示例3. yield() 与 wait() 的比较 1. yield() 介绍yield()的作用是让步。它能让当前线程由 “运行状态” 进入到 “就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用 yield() 之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到 “运行状态” 继续运行！ 2. yield() 示例下面，通过示例查看它的用法。 1234567891011121314151617181920212223// YieldTest.java的源码class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public synchronized void run()&#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s [%d]:%d\n", this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i%4 == 0) Thread.yield(); &#125; &#125; &#125; public class YieldTest&#123; public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; &#125; (某一次的) 运行结果: 1234567891011121314151617181920t1 [5]:0t2 [5]:0t1 [5]:1t1 [5]:2t1 [5]:3t1 [5]:4t1 [5]:5t1 [5]:6t1 [5]:7t1 [5]:8t1 [5]:9t2 [5]:1t2 [5]:2t2 [5]:3t2 [5]:4t2 [5]:5t2 [5]:6t2 [5]:7t2 [5]:8t2 [5]:9 结果说明：“线程 t1”在能被 4 整数的时候，并没有切换到 “线程 t2”。这表明，yield() 虽然可以让线程由 “运行状态” 进入到 “就绪状态”；但是，它不一定会让其它线程获取 CPU 执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程” 与当前调用 yield()的线程具有相同的优先级。 3. yield() 与 wait() 的比较我们知道，wait() 的作用是让当前线程由 “运行状态” 进入 “等待(阻塞) 状态”的同时，也会释放同步锁。而 yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：(01) wait()是让线程由 “运行状态” 进入到 “等待(阻塞) 状态”，而 yield()是让线程由 “运行状态” 进入到“就绪状态”。(02) wait() 会让线程释放它所持有对象的同步锁，而 yield() 方法不会释放锁。 下面通过示例演示 yield() 是不会释放锁的。 1234567891011121314151617181920212223242526272829 // YieldLockTest.java 的源码public class YieldLockTest&#123; private static Object obj = new Object(); public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; // 获取obj对象的同步锁 synchronized (obj) &#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s [%d]:%d\n", this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i%4 == 0) Thread.yield(); &#125; &#125; &#125; &#125; &#125; (某一次) 运行结果： 1234567891011121314151617181920t1 [5]:0t1 [5]:1t1 [5]:2t1 [5]:3t1 [5]:4t1 [5]:5t1 [5]:6t1 [5]:7t1 [5]:8t1 [5]:9t2 [5]:0t2 [5]:1t2 [5]:2t2 [5]:3t2 [5]:4t2 [5]:5t2 [5]:6t2 [5]:7t2 [5]:8t2 [5]:9 结果说明：主线程 main 中启动了两个线程 t1 和 t2。t1 和 t2 在 run() 会引用同一个对象的同步锁，即 synchronized(obj)。在 t1 运行过程中，虽然它会调用 Thread.yield()；但是，t2 是不会获取 cpu 执行权的。因为，t1 并没有释放 “obj 所持有的同步锁”！ 07 线程休眠概要本章，会对 Thread 中 sleep() 方法进行介绍。涉及到的内容包括：1. sleep() 介绍2. sleep() 示例3. sleep() 与 wait() 的比较 1. sleep() 介绍sleep() 定义在 Thread.java 中。sleep() 的作用是让当前线程休眠，即当前线程会从 “运行状态” 进入到 “休眠 (阻塞) 状态”。sleep() 会指定休眠时间，线程休眠的时间会大于 / 等于该休眠时间；在线程重新被唤醒时，它会由 “阻塞状态” 变成 “就绪状态”，从而等待 cpu 的调度执行。 2. sleep() 示例下面通过一个简单示例演示 sleep() 的用法。 12345678910111213141516171819202122232425// SleepTest.java的源码class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public synchronized void run() &#123; try &#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public class SleepTest&#123; public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); t1.start(); &#125; &#125; 运行结果： 12345678910t1: 0t1: 1t1: 2t1: 3t1: 4t1: 5t1: 6t1: 7t1: 8t1: 9 结果说明：程序比较简单，在主线程 main 中启动线程 t1。t1 启动之后，当 t1 中的计算 i 能被 4 整除时，t1 会通过 Thread.sleep(100) 休眠 100 毫秒。 3. sleep() 与 wait() 的比较我们知道，wait()的作用是让当前线程由 “运行状态” 进入 “等待(阻塞) 状态”的同时，也会释放同步锁。而 sleep()的作用是也是让当前线程由 “运行状态” 进入到 “休眠(阻塞) 状态”。但是，wait() 会释放对象的同步锁，而 sleep() 则不会释放锁。下面通过示例演示 sleep() 是不会释放锁的。 123456789101112131415161718192021222324252627282930313233// SleepLockTest.java的源码public class SleepLockTest&#123; private static Object obj = new Object(); public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; // 获取obj对象的同步锁 synchronized (obj) &#123; try &#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 运行结果： 1234567891011121314151617181920t1: 0t1: 1t1: 2t1: 3t1: 4t1: 5t1: 6t1: 7t1: 8t1: 9t2: 0t2: 1t2: 2t2: 3t2: 4t2: 5t2: 6t2: 7t2: 8t2: 9 结果说明：主线程 main 中启动了两个线程 t1 和 t2。t1 和 t2 在 run() 会引用同一个对象的同步锁，即 synchronized(obj)。在 t1 运行过程中，虽然它会调用 Thread.sleep(100)；但是，t2 是不会获取 cpu 执行权的。因为，t1 并没有释放 “obj 所持有的同步锁”！注意，若我们注释掉 synchronized (obj) 后再次执行该程序，t1 和 t2 是可以相互切换的。下面是注释调 synchronized(obj) 之后的源码： 123456789101112131415161718192021222324252627282930313233// SleepLockTest.java的源码(注释掉synchronized(obj))public class SleepLockTest&#123; private static Object obj = new Object(); public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; // 获取obj对象的同步锁// synchronized (obj) &#123; try &#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;// &#125; &#125; &#125; &#125; 08 join()概要本章，会对 Thread 中 join() 方法进行介绍。涉及到的内容包括：1. join() 介绍2. join() 源码分析 (基于 JDK1.7.0_40)3. join() 示例 1. join() 介绍join() 定义在 Thread.java 中。join() 的作用：让 “主线程” 等待 “子线程” 结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解： 123456789101112131415// 主线程public class Father extends Thread &#123; public void run() &#123; Son s = new Son(); s.start(); s.join(); ... &#125;&#125;// 子线程public class Son extends Thread &#123; public void run() &#123; ... &#125;&#125; 说明：上面的有两个类 Father(主线程类) 和 Son(子线程类)。因为 Son 是在 Father 中创建并启动的，所以，Father 是主线程类，Son 是子线程类。在 Father 主线程中，通过 new Son()新建 “子线程 s”。接着通过 s.start() 启动 “子线程 s”，并且调用 s.join()。在调用 s.join() 之后，Father 主线程会一直等待，直到 “子线程 s” 运行完毕；在 “子线程 s” 运行完毕之后，Father 主线程才能接着运行。 这也就是我们所说的 “join() 的作用，是让主线程会等待子线程结束之后才能继续运行”！ 2. join() 源码分析 (基于 JDK1.7.0_40)12345678910111213141516171819202122232425262728public final void join() throws InterruptedException &#123; join(0);&#125;public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 说明：从代码中，我们可以发现。当 millis==0 时，会进入 while(isAlive()) 循环；即只要子线程是活的，主线程就不停的等待。我们根据上面解释 join() 作用时的代码来理解 join() 的用法！问题：虽然 s.join()被调用的地方是发生在 “Father 主线程” 中，但是 s.join()是通过 “子线程 s” 去调用的 join()。那么，join()方法中的 isAlive()应该是判断 “子线程 s” 是不是 Alive 状态；对应的 wait(0)也应该是 “让子线程 s” 等待才对。但如果是这样的话，s.join()的作用怎么可能是 “让主线程等待，直到子线程 s 完成为止” 呢，应该是让 “子线程等待才对(因为调用子线程对象 s 的 wait 方法嘛)”？答案：wait() 的作用是让 “当前线程” 等待，而这里的 “当前线程” 是指当前在 CPU 上运行的线程。所以，虽然是调用子线程的 wait()方法，但是它是通过 “主线程” 去调用的；所以，休眠的是主线程，而不是“子线程”！ 3. join() 示例在理解 join() 的作用之后，接下来通过示例查看 join() 的用法。 12345678910111213141516171819202122232425262728293031// JoinTest.java的源码public class JoinTest&#123; public static void main(String[] args)&#123; try &#123; ThreadA t1 = new ThreadA("t1"); // 新建“线程t1” t1.start(); // 启动“线程t1” t1.join(); // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成” System.out.printf("%s finish\n", Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; System.out.printf("%s start\n", this.getName()); // 延时操作 for(int i=0; i &lt;1000000; i++) ; System.out.printf("%s finish\n", this.getName()); &#125; &#125; &#125; 运行结果： 123t1 startt1 finishmain finish 结果说明：运行流程如图(01) 在 “主线程 main” 中通过 new ThreadA(“t1”) 新建“线程 t1”。 接着，通过 t1.start() 启动“线程 t1”，并执行 t1.join()。(02) 执行 t1.join()之后，“主线程 main”会进入 “阻塞状态” 等待 t1 运行结束。“子线程 t1”结束之后，会唤醒 “主线程 main”，“主线程” 重新获取 cpu 执行权，继续运行。 09 interrupt()和线程终止方式概要本章，会对线程的 interrupt() 中断和终止方式进行介绍。涉及到的内容包括：1. interrupt() 说明2. 终止线程的方式 2.1 终止处于 “阻塞状态” 的线程 2.2 终止处于 “运行状态” 的线程3. 终止线程的示例4. interrupted() 和 isInterrupted() 的区别 1. interrupt() 说明在介绍终止线程的方式之前，有必要先对 interrupt() 进行了解。关于 interrupt()，java 的 djk 文档描述如下：http://docs.oracle.com/javase/7/docs/api/ 123456789101112Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.If this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.If none of the previous conditions hold then this thread's interrupt status will be set.Interrupting a thread that is not alive need not have any effect. 大致意思是： interrupt()的作用是中断本线程。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。 2. 终止线程的方式Thread 中的 stop() 和 suspend() 方法，由于固有的不安全性，已经建议不再使用！下面，我先分别讨论线程在 “阻塞状态” 和“运行状态”的终止方式，然后再总结出一个通用的方式。 2.1 终止处于 “阻塞状态” 的线程通常，我们通过 “中断” 方式终止处于 “阻塞状态” 的线程。当线程由于被调用了 sleep(), wait(), join() 等方法而进入阻塞状态；若此时调用线程的 interrupt() 将线程的中断标记设为 true。由于处于阻塞状态，中断标记会被清除，同时产生一个 InterruptedException 异常。将 InterruptedException 放在适当的位置就能终止线程，形式如下： 12345678910@Overridepublic void run() &#123; try &#123; while (true) &#123; // 执行任务... &#125; &#125; catch (InterruptedException ie) &#123; // 由于产生InterruptedException异常，退出while(true)循环，线程终止！ &#125;&#125; 说明：在 while(true) 中不断的执行任务，当线程处于阻塞状态时，调用线程的 interrupt() 产生 InterruptedException 中断。中断的捕获在 while(true) 之外，这样就退出了 while(true) 循环！注意：对 InterruptedException 的捕获务一般放在 while(true) 循环体的外面，这样，在产生异常时就退出了 while(true) 循环。否则，InterruptedException 在 while(true) 循环体之内，就需要额外的添加退出处理。形式如下： 123456789101112@Overridepublic void run() &#123; while (true) &#123; try &#123; // 执行任务... &#125; catch (InterruptedException ie) &#123; // InterruptedException在while(true)循环体内。 // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出 break; &#125; &#125;&#125; 说明：上面的 InterruptedException 异常的捕获在 whle(true) 之内。当产生 InterruptedException 异常时，被 catch 处理之外，仍然在 while(true) 循环体内；要退出 while(true) 循环体，需要额外的执行退出 while(true) 的操作。 2.2 终止处于 “运行状态” 的线程通常，我们通过 “标记” 方式终止处于 “运行状态” 的线程。其中，包括“中断标记” 和 “额外添加标记”。(01) 通过 “中断标记” 终止线程。形式如下： 123456@Overridepublic void run() &#123; while (!isInterrupted()) &#123; // 执行任务... &#125;&#125; 说明：isInterrupted() 是判断线程的中断标记是不是为 true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的 interrupt() 方法，使用线程的中断标记为 true，即 isInterrupted() 会返回 true。此时，就会退出 while 循环。注意：interrupt()并不会终止处于 “运行状态” 的线程！它会将线程的中断标记设为 true。 (02) 通过 “额外添加标记”。形式如下： 1234567891011private volatile boolean flag= true;protected void stopTask() &#123; flag = false;&#125;@Overridepublic void run() &#123; while (flag) &#123; // 执行任务... &#125;&#125; 说明：线程中有一个 flag 标记，它的默认值是 true；并且我们提供 stopTask() 来设置 flag 标记。当我们需要终止该线程时，调用该线程的 stopTask() 方法就可以让线程退出 while 循环。注意：将 flag 定义为 volatile 类型，是为了保证 flag 的可见性。即其它线程通过 stopTask() 修改了 flag 之后，本线程能看到修改后的 flag 的值。 综合线程处于 “阻塞状态” 和“运行状态”的终止方式，比较通用的终止线程的形式如下： 1234567891011@Overridepublic void run() &#123; try &#123; // 1\. isInterrupted()保证，只要中断标记为true就终止线程。 while (!isInterrupted()) &#123; // 执行任务... &#125; &#125; catch (InterruptedException ie) &#123; // 2\. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。 &#125;&#125; 3. 终止线程的示例interrupt()常常被用来终止 “阻塞状态” 线程。参考下面示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Demo1.java的源码class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; int i=0; while (!isInterrupted()) &#123; Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+" ("+this.getState()+") loop " + i); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() +" ("+this.getState()+") catch InterruptedException."); &#125; &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; try &#123; Thread t1 = new MyThread("t1"); // 新建“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is new."); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 运行结果： 1234567t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (TERMINATED) is interrupted now. 结果说明：(01) 主线程 main 中通过 new MyThread(“t1”) 创建线程 t1，之后通过 t1.start() 启动线程 t1。(02) t1 启动之后，会不断的检查它的中断标记，如果中断标记为 “false”；则休眠 100ms。(03) t1 休眠之后，会切换到主线程 main；主线程再次运行时，会执行 t1.interrupt()中断线程 t1。t1 收到中断指令之后，会将 t1 的中断标记设置 “false”，而且会抛出 InterruptedException 异常。在 t1 的 run() 方法中，是在循环体 while 之外捕获的异常；因此循环被终止。 我们对上面的结果进行小小的修改，将 run() 方法中捕获 InterruptedException 异常的代码块移到 while 循环体内。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Demo2.java的源码class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i=0; while (!isInterrupted()) &#123; try &#123; Thread.sleep(100); // 休眠100ms &#125; catch (InterruptedException ie) &#123; System.out.println(Thread.currentThread().getName() +" ("+this.getState()+") catch InterruptedException."); &#125; i++; System.out.println(Thread.currentThread().getName()+" ("+this.getState()+") loop " + i); &#125; &#125;&#125;public class Demo2 &#123; public static void main(String[] args) &#123; try &#123; Thread t1 = new MyThread("t1"); // 新建“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is new."); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;c 运行结果： 123456789101112131415t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (RUNNABLE) loop 3t1 (RUNNABLE) loop 4t1 (RUNNABLE) loop 5t1 (TIMED_WAITING) is interrupted now.t1 (RUNNABLE) loop 6t1 (RUNNABLE) loop 7t1 (RUNNABLE) loop 8t1 (RUNNABLE) loop 9... 结果说明：程序进入了死循环！为什么会这样呢？这是因为，t1 在 “等待(阻塞) 状态”时，被 interrupt()中断；此时，会清除中断标记 [即 isInterrupted() 会返回 false]，而且会抛出 InterruptedException 异常[该异常在 while 循环体内被捕获]。因此，t1 理所当然的会进入死循环了。解决该问题，需要我们在捕获异常时，额外的进行退出 while 循环的处理。例如，在 MyThread 的 catch(InterruptedException) 中添加 break 或 return 就能解决该问题。 下面是通过 “额外添加标记” 的方式终止 “状态状态” 的线程的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Demo3.java的源码class MyThread extends Thread &#123; private volatile boolean flag= true; public void stopTask() &#123; flag = false; &#125; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized(this) &#123; try &#123; int i=0; while (flag) &#123; Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+" ("+this.getState()+") loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; System.out.println(Thread.currentThread().getName() +" ("+this.getState()+") catch InterruptedException."); &#125; &#125; &#125;&#125;public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; MyThread t1 = new MyThread("t1"); // 新建“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is new."); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.stopTask(); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 运行结果： 1234567t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) loop 3t1 (TERMINATED) is interrupted now. 4. interrupted() 和 isInterrupted() 的区别最后谈谈 interrupted() 和 isInterrupted()。interrupted() 和 isInterrupted() 都能够用于检测对象的 “中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记 (即将中断标记设为 false)；而 isInterrupted() 仅仅返回中断标记。 10 线程优先级和守护线程概要本章，会对守护线程和线程优先级进行介绍。涉及到的内容包括：1. 线程优先级的介绍2. 线程优先级的示例3. 守护线程的示例 1. 线程优先级的介绍java 中的线程优先级的范围是 1～10，默认的优先级是 5。“高优先级线程”会优先于 “低优先级线程” 执行。 daemon：美 [‘dimən] java 中有两种线程：用户线程和守护线程。可以通过 isDaemon() 方法来区别它们：如果返回 false，则说明该线程是 “用户线程”；否则就是 “守护线程”。用户线程一般是用户执行的用户级任务，而守护线程也就是 “后台线程”，一般用来执行后台任务。需要注意的是：Java 虚拟机在“用户线程” 都结束后会后退出。 JDK 中关于线程优先级和守护线程的介绍如下： 1234567Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads. 大致意思是： 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：(01) 调用了exit()方法，并且exit()有权限被正常执行。(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。 2. 线程优先级的示例我们先看看优先级的示例 12345678910111213141516171819202122232425262728class MyThread extends Thread&#123; public MyThread(String name) &#123; super(name); &#125; public void run()&#123; for (int i=0; i&lt;5; i++) &#123; System.out.println(Thread.currentThread().getName() +"("+Thread.currentThread().getPriority()+ ")" +", loop "+i); &#125; &#125; &#125;; public class Demo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() +"("+Thread.currentThread().getPriority()+ ")"); Thread t1=new MyThread("t1"); // 新建t1 Thread t2=new MyThread("t2"); // 新建t2 t1.setPriority(1); // 设置t1的优先级为1 t2.setPriority(10); // 设置t2的优先级为10 t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125; 运行结果： 1234567891011main(5)t1(1), loop 0t2(10), loop 0t1(1), loop 1t2(10), loop 1t1(1), loop 2t2(10), loop 2t1(1), loop 3t2(10), loop 3t1(1), loop 4t2(10), loop 4 结果说明：(01) 主线程 main 的优先级是 5。(02) t1 的优先级被设为 1，而 t2 的优先级被设为 10。cpu 在执行 t1 和 t2 的时候，根据时间片轮循调度，所以能够并发执行。 3. 守护线程的示例下面是守护线程的示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Demo.javaclass MyThread extends Thread&#123; public MyThread(String name) &#123; super(name); &#125; public void run()&#123; try &#123; for (int i=0; i&lt;5; i++) &#123; Thread.sleep(3); System.out.println(this.getName() +"(isDaemon="+this.isDaemon()+ ")" +", loop "+i); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;; class MyDaemon extends Thread&#123; public MyDaemon(String name) &#123; super(name); &#125; public void run()&#123; try &#123; for (int i=0; i&lt;10000; i++) &#123; Thread.sleep(1); System.out.println(this.getName() +"(isDaemon="+this.isDaemon()+ ")" +", loop "+i); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;public class Demo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() +"(isDaemon="+Thread.currentThread().isDaemon()+ ")"); Thread t1=new MyThread("t1"); // 新建t1 Thread t2=new MyDaemon("t2"); // 新建t2 t2.setDaemon(true); // 设置t2为守护线程 t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125; 运行结果： 12345678910111213141516171819main(isDaemon=false)t2(isDaemon=true), loop 0t2(isDaemon=true), loop 1t1(isDaemon=false), loop 0t2(isDaemon=true), loop 2t2(isDaemon=true), loop 3t1(isDaemon=false), loop 1t2(isDaemon=true), loop 4t2(isDaemon=true), loop 5t2(isDaemon=true), loop 6t1(isDaemon=false), loop 2t2(isDaemon=true), loop 7t2(isDaemon=true), loop 8t2(isDaemon=true), loop 9t1(isDaemon=false), loop 3t2(isDaemon=true), loop 10t2(isDaemon=true), loop 11t1(isDaemon=false), loop 4t2(isDaemon=true), loop 12 结果说明：(01) 主线程 main 是用户线程，它创建的子线程 t1 也是用户线程。(02) t2 是守护线程。在 “主线程 main” 和“子线程 t1”(它们都是用户线程)执行完毕，只剩 t2 这个守护线程的时候，JVM 自动退出。 11 生产消费者问题概要本章，会对 “生产 / 消费者问题” 进行讨论。涉及到的内容包括：1. 生产 / 消费者模型2. 生产 / 消费者实现 1. 生产 / 消费者模型生产 / 消费者问题是个非常典型的多线程问题，涉及到的对象包括 “生产者”、“消费者”、“仓库” 和“产品”。他们之间的关系如下：(01) 生产者仅仅在仓储未满时候生产，仓满则停止生产。(02) 消费者仅仅在仓储有产品时候才能消费，仓空则等待。(03) 当消费者发现仓储没产品可消费时候会通知生产者生产。(04) 生产者在生产出可消费产品时候，应该通知等待的消费者去消费。 2. 生产 / 消费者实现下面通过 wait()/notify() 方式实现该模型 (后面在学习了线程池相关内容之后，再通过其它方式实现生产 / 消费者模型)。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 // Demo1.java// 仓库class Depot &#123; private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 public Depot(int capacity) &#123; this.capacity = capacity; this.size = 0; &#125; public synchronized void produce(int val) &#123; try &#123; // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left &gt; 0) &#123; // 库存已满时，等待“消费者”消费产品。 while (size &gt;= capacity) wait(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)&gt;capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf("%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\n", Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 notifyAll(); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; public synchronized void consume(int val) &#123; try &#123; // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left &gt; 0) &#123; // 库存为0时，等待“生产者”生产产品。 while (size &lt;= 0) wait(); // 获取“实际消费的数量”(即库存中实际减少的数量) // 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”； // 否则，“实际消费量”=“客户要消费的数量”。 int dec = (size&lt;left) ? size : left; size -= dec; left -= dec; System.out.printf("%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\n", Thread.currentThread().getName(), val, left, dec, size); notifyAll(); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; public String toString() &#123; return "capacity:"+capacity+", actual size:"+size; &#125;&#125; // 生产者class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) &#123; new Thread() &#123; public void run() &#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;// 消费者class Customer &#123; private Depot depot; public Customer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) &#123; new Thread() &#123; public void run() &#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; Depot mDepot = new Depot(100); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); &#125;&#125; 说明：(01) Producer 是 “生产者” 类，它与 “仓库(depot)” 关联。当调用 “生产者” 的 produce()方法时，它会新建一个线程并向 “仓库” 中生产产品。(02) Customer 是 “消费者” 类，它与 “仓库(depot)” 关联。当调用 “消费者” 的 consume()方法时，它会新建一个线程并消费 “仓库” 中的产品。(03) Depot 是 “仓库” 类，仓库中记录 “仓库的容量(capacity)” 以及“仓库中当前产品数目(size)”。 “仓库”类的生产方法 produce()和消费方法 consume()方法都是 synchronized 方法，进入 synchronized 方法体，意味着这个线程获取到了该 “仓库” 对象的同步锁。这也就是说，同一时间，生产者和消费者线程只能有一个能运行。通过同步锁，实现了对 “仓库” 的互斥访问。 对于生产方法 produce() 而言：当仓库满时，生产者线程等待，需要等待消费者消费产品之后，生产线程才能生产；生产者线程生产完产品之后，会通过 notifyAll() 唤醒同步锁上的所有线程，包括 “消费者线程”，即我们所说的 “通知消费者进行消费”。 对于消费方法 consume() 而言：当仓库为空时，消费者线程等待，需要等待生产者生产产品之后，消费者线程才能消费；消费者线程消费完产品之后，会通过 notifyAll() 唤醒同步锁上的所有线程，包括 “生产者线程”，即我们所说的 “通知生产者进行生产”。 (某一次) 运行结果： 123456789Thread-0 produce( 60) --&gt; left= 0, inc= 60, size= 60Thread-4 produce(110) --&gt; left= 70, inc= 40, size=100Thread-2 consume( 90) &lt;-- left= 0, dec= 90, size= 10Thread-3 consume(150) &lt;-- left=140, dec= 10, size= 0Thread-1 produce(120) --&gt; left= 20, inc=100, size=100Thread-3 consume(150) &lt;-- left= 40, dec=100, size= 0Thread-4 produce(110) --&gt; left= 0, inc= 70, size= 70Thread-3 consume(150) &lt;-- left= 0, dec= 40, size= 30Thread-1 produce(120) --&gt; left= 0, inc= 20, size= 50 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 并发 多线程 面试总结 top50+top40]]></title>
    <url>%2F2018%2F03%2F23%2F2018-03-23%2F</url>
    <content type="text"><![CDATA[不管你是新程序员还是老手，你一定在面试中遇到过有关线程的问题。Java 语言一个重要的特点就是内置了对并发的支持，让 Java 大受企业和程序员的欢迎。大多数待遇丰厚的 Java 开发职位都要求开发者精通多线程技术并且有丰富的 Java 程序开发、调试、优化经验，所以线程相关的问题在面试中经常会被提到。 在典型的 Java 面试中， 面试官会从线程的基本概念问起, 如：为什么你需要使用线程， 如何创建线程，用什么方式创建线程比较好（比如：继承 thread 类还是调用 Runnable 接口），然后逐渐问到并发问题像在 Java 并发编程的过程中遇到了什么挑战，Java 内存模型，JDK1.5 引入了哪些更高阶的并发工具，并发编程常用的设计模式，经典多线程问题如生产者消费者，哲学家就餐，读写器或者简单的有界缓冲区问题。仅仅知道线程的基本概念是远远不够的， 你必须知道如何处理死锁，竞态条件，内存冲突和线程安全等并发问题。掌握了这些技巧，你就可以轻松应对多线程和并发面试了。 许多 Java 程序员在面试前才会去看面试题，这很正常。因为收集面试题和练习很花时间，所以我从许多面试者那里收集了 Java 多线程和并发相关的 50 个热门问题。我只收集了比较新的面试题且没有提供全部答案。想必聪明的你对这些问题早就心中有数了， 如果遇到不懂的问题，你可以用 Google 找到答案。若你实在找不到答案，可以在文章的评论中向我求助。你也可以在这找到一些答案 Java 线程问答 Top 12。 50 道 Java 线程面试题下面是 Java 线程相关的热门面试题，你可以用它来好好准备面试。 1) 什么是线程？线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要 100 毫秒，那么用十个线程完成改任务只需 10 毫秒。Java 在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。欲了解更多详细信息请点击这里。 2) 线程和进程有什么区别？线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。更多详细信息请点击这里。 3) 如何在 Java 中实现线程？在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用 java.lang.Runnable 接口来执行，由于线程类本身就是调用的 Runnable 接口所以你可以继承 java.lang.Thread 类或者直接调用 Runnable 接口来重写 run() 方法实现线程。更多详细信息请点击这里. 4) 用 Runnable 还是 Thread？这个问题是上题的后续，大家都知道我们可以通过继承 Thread 类或者调用 Runnable 接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道 Java 不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用 Runnable 接口好了。更多详细信息请点击这里。 6) Thread 类中的 start() 和 run() 方法有什么区别？这个问题经常被问到，但还是能从此区分出面试者对 Java 线程模型的理解程度。start() 方法被用来启动新创建的线程，而且 start() 内部调用了 run() 方法，这和直接调用 run() 方法的效果不一样。当你调用 run() 方法的时候，只会是在原来的线程中调用，没有新的线程启动，start() 方法才会启动新线程。更多讨论请点击这里 7) Java 中 Runnable 和 Callable 有什么不同？Runnable 和 Callable 都代表那些要在不同的线程中执行的任务。Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的。它们的主要区别是 Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。我的博客有更详细的说明。 8) Java 中 CyclicBarrier 和 CountDownLatch 有什么不同？CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。点此查看更多信息和示例代码。 9) Java 内存模型是什么？Java 内存模型规定和指引 Java 程序在不同的内存架构、CPU 和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java 内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了： 线程内的代码能够按先后顺序执行，这被称为程序次序规则。 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。 一个线程内的任何操作必需在这个线程的 start() 调用之后，也叫作线程启动规则。 一个线程的所有操作都会在线程终止之前，线程终止规则。 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。 可传递性 我强烈建议大家阅读《Java 并发编程实践》第十六章来加深对 Java 内存模型的理解。 10) Java 中的 volatile 变量是什么？volatile 是一个特殊的修饰符，只有成员变量才能使用它。在 Java 并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile 变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的 volatile 变量规则。点击这里查看更多 volatile 的相关内容。 11) 什么是线程安全？Vector 是一个线程安全类吗？ （详见这里)如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的 ArrayList 不是线程安全的。 12) Java 中什么是竞态条件？ 举个例子说明。竞态条件会导致程序在并发情况下出现一些 bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的 bugs。这种 bugs 很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见答案。 13) Java 中如何停止一个线程？Java 提供了很丰富的 API 但没有为停止线程提供 API。JDK 1.0 本来有一些像 stop(), suspend() 和 resume() 的控制方法但是由于潜在的死锁威胁因此在后续的 JDK 版本中他们被弃用了，之后 Java API 的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当 run() 或者 call() 方法执行完的时候线程会自动结束, 如果要手动结束一个线程，你可以用 volatile 布尔变量来退出 run() 方法的循环或者是取消任务来中断线程。点击这里查看示例代码。 14) 一个线程运行时发生异常会怎样？这是我在一次面试中遇到的一个很刁钻的 Java 面试题, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 Thread.getUncaughtExceptionHandler() 来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException() 方法进行处理。 15） 如何在两个线程间共享数据？你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程《Java 线程间通信》(涉及到在两个线程间共享对象) 用 wait 和 notify 方法实现了生产者消费者模型。 16) Java 中 notify 和 notifyAll 有什么区别？这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify() 方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而 notifyAll() 唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。我的博客有更详细的资料和示例代码。 17) 为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object 类里是有意义的，还有不把它放在 Thread 类里的原因。一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的 wait() 方法就有意义了。如果 wait() 方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象。你也可以查看这篇文章了解更多。 18) 什么是 ThreadLocal 变量？ThreadLocal 是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让 SimpleDateFormat 变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是 ThreadLocalRandom 类，它在多线程环境中减少了创建代价高昂的 Random 对象的个数。查看答案了解更多。 19) 什么是 FutureTask？在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable 接口所以它可以提交给 Executor 来执行。 20) Java 中 interrupted 和 isInterruptedd 方法的区别？interrupted() 和 isInterrupted() 的主要区别是前者会将中断状态清除而后者不会。Java 多线程的中断机制是用内部标识来实现的，调用 Thread.interrupt() 来中断一个线程就会设置中断标识为 true。当中断线程调用静态方法 Thread.interrupted() 来检查中断状态时，中断状态会被清零。而非静态方法 isInterrupted() 用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出 InterruptedException 异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。 21) 为什么 wait 和 notify 方法要在同步块中调用？主要是因为 Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。 22) 为什么你应该在循环中检查等待条件?处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在 notify() 方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用 wait() 方法效果更好的原因，你可以在 Eclipse 中创建模板调用 wait 和 notify 试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。 23) Java 中的同步集合与并发集合有什么区别？同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像 ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见答案。 24） Java 中堆和栈有什么不同？为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。更多内容详见答案。 25） 什么是线程池？ 为什么要使用它？创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从 JDK1.5 开始，Java API 提供了 Executor 框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见这篇文章。 26） 如何写代码来解决生产者消费者问题？在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用 wait 和 notify 来解决这个问题，比较赞的办法是用 Semaphore 或者 BlockingQueue 来实现生产者消费者模型，这篇教程有实现它。 27） 如何避免死锁？Java 多线程中的死锁死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节。 28) Java 中活锁和死锁有什么区别？这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。 29） 怎么检测一个线程是否拥有锁？我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在 java.lang.Thread 中有一个方法叫 holdsLock()，它返回 true 如果当且仅当当前线程拥有某个具体对象的锁。你可以查看这篇文章了解更多。 30) 你如何在 Java 中获取线程堆栈？对于不同的操作系统，有多种方法来获得 Java 进程的线程堆栈。当你获取线程堆栈时，JVM 会把所有线程的状态存到日志文件或者输出到控制台。在 Windows 你可以使用 Ctrl + Break 组合键来获取线程堆栈，Linux 下用 kill -3 命令。你也可以用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。 31) JVM 中哪个参数是用来控制线程的栈堆栈小的这个问题很简单， -Xss 参数用来控制线程的堆栈大小。你可以查看 JVM 配置列表来了解这个参数的更多信息。 32） Java 中 synchronized 和 ReentrantLock 有什么不同？Java 在过去很长一段时间只能通过 synchronized 关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过 Lock 接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。你可以查看这篇文章了解更多 33） 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的 join() 方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个 (T3 调用 T2，T2 调用 T1)，这样 T1 就会先完成而 T3 最后完成。你可以查看这篇文章了解更多。 34) Thread 类中的 yield 方法有什么作用？Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield() 的线程有可能在进入到暂停状态后马上又被执行。点击这里查看更多 yield 方法的相关内容。 35） Java 中 ConcurrentHashMap 的并发度是什么？ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章 How ConcurrentHashMap works in Java。 36） Java 中 Semaphore 是什么？Java 中的 Semaphore 是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请点击这里。 37）如果你提交任务时，线程池队列已满。会时发会生什么？这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么 ThreadPoolExecutor’s submit() 方法将会抛出一个 RejectedExecutionException 异常。 38) Java 线程池中 submit() 和 execute() 方法有什么区别？两个方法都可以向线程池提交任务，execute() 方法的返回类型是 void，它定义在 Executor 接口中, 而 submit() 方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。更多详细信息请点击这里。 39) 什么是阻塞式方法？阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的 accept() 方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请点击这里。 40) Swing 是线程安全的吗？ 为什么？你可以很肯定的给出回答，Swing 不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说 swing 不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对 GUI 组件的更新都要在 AWT 线程中完成，而 Swing 提供了同步和异步两种回调方法来进行更新。点击这里查看更多 swing 和线程安全的相关内容。 41） Java 中 invokeAndWait 和 invokeLater 有什么区别？这两个方法是 Swing API 提供给 Java 开发者用来从当前线程而不是事件派发线程更新 GUI 组件用的。InvokeAndWait() 同步更新 GUI 组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用 invokeAndWait() 方法请求事件派发线程对组件进行相应更新。而 invokeLater() 方法是异步调用更新组件的。更多详细信息请点击这里。 42) Swing API 中那些方法是线程安全的？这个问题又提到了 swing 和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如 repaint(), revalidate()。 JTextComponent 的 setText() 方法和 JTextArea 的 insert() 和 append() 方法也是线程安全的。 43) 如何在 Java 中创建 Immutable 对象？这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable 对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是 Java 没有 @Immutable 这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供 setter 方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在 getter 方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章 how to make an object Immutable in Java 有详细的教程，看完你可以充满自信。 44） Java 中的 ReadWriteLock 是什么？一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java 中的 ReadWriteLock 是 Java 5 中新增的一个接口，一个 ReadWriteLock 维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用 JDK 中的 ReentrantReadWriteLock 来实现这个规则，它最多支持 65535 个写锁和 65535 个读锁。 45) 多线程中的忙循环是什么?忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看这篇文章获得更多信息。 46）volatile 变量和 atomic 变量有什么不同？这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子性的。而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如 getAndIncrement() 方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。 47) 如果同步块内的线程抛出异常会发生什么？这个问题坑了很多 Java 程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在 finally block 里释放锁实现。 48） 单例模式的双检锁是什么？这个问题在 Java 面试中经常被问到，但是面试官对回答此问题的满意度仅为 50%。一半的人写不出双检锁还有一半的人说不出它的隐患和 Java1.5 是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在 JDK1.4 中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看 how double checked locking on Singleton works 这篇文章获得更多信息。 49） 如何在 Java 中创建线程安全的 Singleton？这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建 Singleton 类的替代方法，你可以利用 JVM 的类加载和静态变量初始化特征来创建 Singleton 实例，或者是利用枚举类型来创建 Singleton，我很喜欢用这种方法。你可以查看这篇文章获得更多信息。 50) 写出 3 条你遵循的多线程最佳实践这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数 Java 程序员都应该遵循： 给你的线程起个有意义的名字。这样可以方便找 bug 或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至 JDK 都遵循这个最佳实践。 避免锁定和缩小同步的范围锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。 多用同步类少用 wait 和 notify首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用 wait 和 notify 很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的 JDK 中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。 多用并发集合少用同步集合这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到 map，你应该首先想到用 ConcurrentHashMap。我的文章 Java 并发集合有更详细的说明。 51) 如何强制启动一个线程？这个问题就像是如何强制进行 Java 垃圾回收，目前还没有觉得方法，虽然你可以使用 System.gc() 来进行垃圾回收，但是不保证能成功。在 Java 里面没有办法强制启动一个线程，它是被线程调度器控制着且 Java 没有公布相关的 API。 52) Java 中的 fork join 框架是什么？fork join 框架是 JDK7 中出现的一款高效的工具，Java 开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join 框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。你可以查看这篇文章获得更多信息。 53） Java 多线程中调用 wait() 和 sleep() 方法有什么不同？Java 程序中 wait 和 sleep 都会造成某种形式的暂停，它们可以满足不同的需要。wait() 方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep() 方法仅仅释放 CPU 资源或者让当前线程停止执行一段时间，但不会释放锁。你可以查看这篇文章获得更多信息。 以上就是 50 道热门 Java 多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有 Java 多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的 Java 开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。 原文链接： javarevisited 翻译： ImportNew.com - 李 广译文链接： http://www.importnew.com/12773.html[ 转载请保留原文出处、译者和译文链接。] 前言 Java 多线程分类中写了 21 篇多线程的文章，21 篇文章的内容很多，个人认为，学习，内容越多、越杂的知识，越需要进行深刻的总结，这样才能记忆深刻，将知识变成自己的。这篇文章主要是对多线程的问题进行总结的，因此罗列了 40 个多线程的问题。 这些多线程的问题，有些来源于各大网站、有些来源于自己的思考。可能有些问题网上有、可能有些问题对应的答案也有、也可能有些各位网友也都看过，但是本文写作的重心就是所有的问题都会按照自己的理解回答一遍，不会去看网上的答案，因此可能有些问题讲的不对，能指正的希望大家不吝指教。 40个问题汇总1、多线程有什么用？ （1）发挥多核 CPU 的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4 核、8 核甚至 16 核的也都不少见，如果是单线程的程序，那么在双核 CPU 上就浪费了 50%，在 4 核 CPU 上就浪费了 75%。单核 CPU 上所谓的 “多线程” 那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程 “同时” 运行罢了。多核 CPU 上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的。 （2）防止阻塞 从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核 CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 （3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 2、创建线程的方式 比较常见的一个问题了，一般就是两种： （1）继承 Thread 类 （2）实现 Runnable 接口 至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式 6 大原则的核心。 3、start() 方法和 run() 方法的区别 只有调用了 start() 方法，才会表现出多线程的特性，不同线程的 run() 方法里面的代码交替执行。如果只是调用 run() 方法，那么代码还是同步执行的，必须等待一个线程的 run() 方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码。 4、Runnable 接口和 Callable 接口的区别 有点深的问题了，也看出一个 Java 程序员学习知识的广度。 Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已；Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而 Callable+Future/FutureTask 却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 5、CyclicBarrier 和 CountDownLatch 的区别 两个看上去有点像的类，都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上，二者的区别在于： （1）CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值 - 1 而已，该线程继续运行 （2）CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务 （3）CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为 0 该 CountDownLatch 就不可再用了 6、volatile 关键字的作用 一个非常重要的问题，是每个学习、应用多线程的 Java 程序员都必须掌握的。理解 volatile 关键字的作用的前提是要理解 Java 内存模型，这里就不讲 Java 内存模型了，可以参见第 31 点，volatile 关键字的作用主要有两个： （1）多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据 （2）代码底层执行不像我们看到的高级语言 —-Java 程序这么简单，它的执行是 Java 代码 –&gt; 字节码 –&gt; 根据字节码执行对应的 C/C++ 代码 –&gt;C/C++ 代码被编译成汇编语言 –&gt; 和硬件电路交互，现实中，为了获取更好的性能 JVM 可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。 7、什么是线程安全 又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的： （1）不可变 像 String、Integer、Long 这些，都是 final 类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 （2）绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java 中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java 中也有，比方说 CopyOnWriteArrayList、CopyOnWriteArraySet （3）相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像 Vector 这种，add、remove 方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个 Vector、有个线程同时在 add 这个 Vector，99% 的情况下都会出现 ConcurrentModificationException，也就是 fail-fast 机制。 （4）线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap 等都是线程非安全的类 8、Java 中如何获取到线程 dump 文件 死循环、死锁、阻塞、页面打开慢等问题，打线程 dump 是最好的解决问题的途径。所谓线程 dump 也就是线程堆栈，获取到线程堆栈有两步： （1）获取到线程的 pid，可以通过使用 jps 命令，在 Linux 环境下还可以使用 ps -ef | grep java （2）打印线程堆栈，可以通过使用 jstack pid 命令，在 Linux 环境下还可以使用 kill -3 pid 另外提一点，Thread 类提供了一个 getStackTrace() 方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈， 9、一个线程如果出现了运行时异常会怎么样 如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放 10、如何在两个线程之间共享数据 通过在线程之间共享对象就可以了，然后通过 wait/notify/notifyAll、await/signal/signalAll 进行唤起和等待，比方说阻塞队列 BlockingQueue 就是为线程之间共享数据而设计的 11、sleep 方法和 wait 方法有什么区别 这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器 12、生产者消费者模型的作用是什么 这个问题很理论，但是很重要： （1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 13、ThreadLocal 有什么用 简单说 ThreadLocal 就是一种以空间换时间的做法，在每个 Thread 里面维护了一个以开地址法实现的 ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 14、为什么 wait() 方法和 notify()/notifyAll() 方法要在同步块中被调用 这是 JDK 强制的，wait() 方法和 notify()/notifyAll() 方法在调用前都必须先获得对象的锁 15、wait() 方法和 notify()/notifyAll() 方法在放弃对象监视器时有什么区别 wait() 方法和 notify()/notifyAll() 方法在放弃对象监视器的时候的区别在于：wait() 方法立即释放对象监视器，notify()/notifyAll() 方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 16、为什么要使用线程池 避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 17、怎么检测一个线程是否持有对象监视器 我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread 类提供了一个 holdsLock(Object obj) 方法，当且仅当对象 obj 的监视器被某条线程持有的时候才会返回 true，注意这是一个 static 方法，这意味着 “某条线程” 指的是当前线程。 18、synchronized 和 ReentrantLock 的区别 synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上： （1）ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁 （2）ReentrantLock 可以获取各种锁的信息 （3）ReentrantLock 可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word，这点我不能确定。 19、ConcurrentHashMap 的并发度是什么 ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有 16 条线程操作 ConcurrentHashMap，这也是 ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗？ 20、ReadWriteLock 是什么 首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁 ReadWriteLock。ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 21、FutureTask 是什么 这个其实前面有提到过，FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。 22、Linux 环境下如何查找哪个线程使用 CPU 最长 这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做： （1）获取项目的 pid，jps 或者 ps -ef | grep java，这个前面有讲过 （2）top -H -p pid，顺序不能改变 这样就可以打印出当前的项目，每条线程占用 CPU 时间的百分比。注意这里打出的是 LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署 Linux 环境下的 Java 工程，因此没有办法截图演示，网友朋友们如果公司是使用 Linux 环境部署项目的话，可以尝试一下。 使用 “top -H -p pid”+”jps pid” 可以很容易地找到某条占用 CPU 高的线程的线程堆栈，从而定位占用 CPU 高的原因，一般是因为不当的代码操作导致了死循环。 最后提一点，”top -H -p pid” 打出来的 LWP 是十进制的，”jps pid” 打出来的本地线程号是十六进制的，转换一下，就能定位到占用 CPU 高的线程的当前线程堆栈了。 23、Java 编程写一个会导致死锁的程序 第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程 A 和线程 B 相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。 真正理解什么是死锁，这个问题其实不难，几个步骤： （1）两个线程里面分别持有两个 Object 对象：lock1 和 lock2。这两个 lock 作为同步代码块的锁； （2）线程 1 的 run() 方法中同步代码块先获取 lock1 的对象锁，Thread.sleep(xxx)，时间不需要太多，50 毫秒差不多了，然后接着获取 lock2 的对象锁。这么做主要是为了防止线程 1 启动一下子就连续获得了 lock1 和 lock2 两个对象的对象锁 （3）线程 2 的 run)(方法中同步代码块先获取 lock2 的对象锁，接着获取 lock1 的对象锁，当然这时 lock1 的对象锁已经被线程 1 锁持有，线程 2 肯定是要等待线程 1 释放 lock1 的对象锁的 这样，线程 1”睡觉” 睡完，线程 2 已经获取了 lock2 的对象锁了，线程 1 此时尝试获取 lock2 的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java 多线程 7：死锁这篇文章里面有，就是上面步骤的代码实现。 24、怎么唤醒一个阻塞的线程 如果线程是因为调用了 wait()、sleep() 或者 join() 方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统。 25、不可变对象对多线程有什么帮助 前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 26、什么是多线程的上下文切换 多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。 27、如果你提交任务时，线程池队列已满，这时会发生什么 这里区分一下： 如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务 如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据 maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 28、Java 中用到的线程调度算法是什么 抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 29、Thread.sleep(0) 的作用是什么 这个问题和上面那个问题是相关的，我就连在一起了。由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU 控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用 Thread.sleep(0) 手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制权的一种操作。 30、什么是自旋 很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 31、什么是 Java 内存模型 Java 内存模型定义了一种多线程访问 Java 内存的规范。Java 内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下 Java 内存模型的几部分内容： （1）Java 内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次 Java 线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 （2）定义了几个原子操作，用于操作主内存和工作内存中的变量 （3）定义了 volatile 变量的使用规则 （4）happens-before，即先行发生原则，定义了操作 A 必然先行发生于操作 B 的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁 unlock 的动作一定先行发生于后面对于同一个锁进行锁定 lock 的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的 happens-before 规则，则这段代码一定是线程非安全的 32、什么是 CAS CAS，全称为 Compare and Swap，即比较 - 替换。假设有三个操作数：内存值 V、旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false。当然 CAS 一定要 volatile 变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功。 33、什么是乐观锁和悲观锁 （1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较 - 替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。 34、什么是 AQS 简单说一下 AQS，AQS 全称为 AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。 如果说 java.util.concurrent 的基础是 CAS 的话，那么 AQS 就是整个 Java 并发包的核心了，ReentrantLock、CountDownLatch、Semaphore 等等都用到了它。AQS 实际上以双向队列的形式连接所有的 Entry，比方说 ReentrantLock，所有等待的线程都被放在一个 Entry 中并连成双向队列，前面一个线程使用 ReentrantLock 好了，则双向队列实际上的第一个 Entry 开始运行。 AQS 定义了对双向队列所有的操作，而只开放了 tryLock 和 tryRelease 方法给开发者使用，开发者可以根据自己的实现重写 tryLock 和 tryRelease 方法，以实现自己的并发功能。 35、单例模式的线程安全性 老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： （1）饿汉式单例模式的写法：线程安全 （2）懒汉式单例模式的写法：非线程安全 （3）双检锁单例模式的写法：线程安全 36、Semaphore 有什么作用 Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。 37、Hashtable 的 size() 方法中明明只有一条语句 “return count”，为什么还要做同步？ 这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是 size() 方法明明只有一条语句，为什么还要加锁？ 关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点： （1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B 则可以正常调用 size() 方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对 size++，线程 B 就已经读取 size 了，那么对于线程 B 来说读取到的 size 一定是不准确的。而给 size() 方法加了同步之后，意味着线程 B 调用 size() 方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性 （2）CPU 执行代码，执行的不是 Java 代码，这点很关键，一定得记住。Java 代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到 Java 代码只有一行，甚至你看到 Java 代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句 “return count” 假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。 38、线程类的构造方法、静态块是被哪个线程调用的 这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new 这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了 Thread1，main 函数中 new 了 Thread2，那么： （1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run() 方法是 Thread2 自己调用的 （2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run() 方法是 Thread1 自己调用的 39、同步方法和同步块，哪个是更好的选择 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。 借着这一条，我额外提一点，虽说同步的范围越少越好，但是在 Java 虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说 StringBuffer，它是一个线程安全的类，自然最常用的 append() 方法是一个同步方法，我们写代码的时候会反复 append 字符串，这意味着要进行反复的加锁 -&gt; 解锁，这对性能不利，因为这意味着 Java 虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此 Java 虚拟机会将多次 append 方法调用的代码进行一个锁粗化的操作，将多次的 append 的操作扩展到 append 方法的头尾，变成一个大的同步块，这样就减少了加锁 –&gt; 解锁的次数，有效地提升了代码执行的效率。 40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？ 这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是： （1）高并发、任务执行时间短的业务，线程池线程数可以设置为 CPU 核数 + 1，减少线程上下文的切换 （2）并发不高、任务执行时间长的业务要区分开看： a）假如是业务时间长集中在 IO 操作上，也就是 IO 密集型的任务，因为 IO 操作并不占用 CPU，所以不要让所有的 CPU 闲下来，可以加大线程池中的线程数目，让 CPU 处理更多的业务 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。 原文：http://www.cnblogs.com/xrq730/p/5060921.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 笔记四]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22-3%2F</url>
    <content type="text"><![CDATA[第四章 对象的组合Composing Objects4.1 设计线程安全的类在设计线程安全类的过程中，需要包含三个步骤：1）找出构成对象状态的所有变量。2）找出约束状态变量的不变形条件。3）建立对象状态的并发访问管理策略。 对象的域：是指对象中的变量。对象的状态：如果对象中的所有域都是基本类型的变量，那么这些域将构成对象的全部状态。如果对象中引用了其他对象，那么该对象的状态将包含被引用对象的域。 4.1.1 收集同步需求如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助原子性和封装性。说的更简略些是 Java 线程安全问题都是因为共享变量，共享变量后会因为多个线程同时修改导致不正确的问题，所以收集一共有多少处会涉及到这些需要同步的变量，只有收集说有可能出问题的因素基于此之上保证所有元素线程安全也才能保证程序是线程安全的。 4.1.2 依赖状态的操作在某些对象的方法中还包含一些基于状态的先验条件，如删除前的非空判断，这样的操作就被称为依赖状态的操作。要想实现某个等待先验条件为真时才执行的操作，一种简单的方法是通过现有库中的类，如阻塞队列 Blocking Queue 或者信号量 Semaphore 来实现依赖状态的行为。 4.1.3 状态的所有权单独一个基本对象比较保证其安全性，但是如果是包含对象的集合（容器类 例如：ArrayList），容器类通常表现出一种 “所有权分离” 的形式。即使用线程安全的容器类（Collections.synchronizedList(List)），也只能保证容器相关的操作是线程安全的，如果发布了可变对象的引用，就不会拥有独占的控制权。（非线程安全） 4.2 实例封闭将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。Java 监听器模式遵循 java 监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。示例： 1234567891011121314public class Counter &#123; private long value = 0; public synchronized long getValue()&#123; return this.value; &#125; public synchronized long increment()&#123; if(value == Long.MAX_VALUE)&#123; throw new IllegalStateException(&quot;counter overflow&quot;); &#125; return ++value; &#125;&#125; 或者： 12345678910111213141516171819public class Counter &#123; private Long value = 0l; public long getValue()&#123; synchronized (value) &#123; return this.value; &#125; &#125; public long increment()&#123; synchronized (value) &#123; if(value == Long.MAX_VALUE)&#123; throw new IllegalStateException(&quot;counter overflow&quot;); &#125; return ++value; &#125; &#125;&#125; 使用私有的锁对象而不是对象的内置锁，有许多优点，私有的锁对象可以将锁封装起来，使客户端代码无法获取到锁，以便参与到它的同步策略中，避免产生活跃性问题。 synchronized 为什么不能修饰基本数据类型？因为基本数据类型是放在栈里面的，栈数据是可共享的，所以不能加 synchronized。 4.3 线程安全性委托1、客户端加锁机制 使用某个对象的代码时必须使用该对象本身用于保护其状态的锁，不推荐（同步的实现被分到两个不相关的类中）在客户端加锁，但要确保使加锁对象在实现客户端加锁或者外部加锁时使用同一个锁。 123456789101112@ThreadSafe public class ListHelper&lt;E&gt;&#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x)&#123; synchronized(list)&#123;//使List在实现客户端加锁或者外部加锁时使用同一个锁 boolean absent = !list.contains(x); if(absent) list.add(x); return absent; &#125; &#125; &#125; 另外一个更好的方式是使用组合 12345678910111213@ThreadSafe public class ImprovedList&lt;T&gt; implements List&lt;T&gt;&#123; private final List&lt;T&gt; list; public ImprovedList(List&lt;T&gt; list)&#123; this.list = list; &#125; public synchronized boolean putIfAbsent(T x)&#123; boolean contains = list.contains(x); if(!contains) list.add(x); return !contains; &#125; &#125; 4.4 在现有的安全类中添加功能 扩展类 123456789101112ThreadSafepublic class BetterVector &lt;E&gt; extends Vector&lt;E&gt; &#123; // When extending a serializable class, you should redefine serialVersionUID static final long serialVersionUID = -3963416950630760754L; public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !contains(x); if (absent) add(x); return absent; &#125;&#125; 这种方法比较脆弱，同步策略分散在多个类中单独维护，比如Vector变了实现，这里面就失效了。 4.4.1 客户端加锁1234567891011@NotThreadSafeclass BadListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125;&#125; 非常经典的例子，本来是想做到安全，但是不是用的同一把锁。正确的如下： 12345678910111213@ThreadSafeclass GoodListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x) &#123; synchronized (list) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125; &#125;&#125; 4.4.2 组合1234567891011121314151617@ThreadSafepublic class ImprovedList&lt;T&gt; implements List&lt;T&gt; &#123; private final List&lt;T&gt; list; /** * PRE: list argument is thread-safe. */ public ImprovedList(List&lt;T&gt; list) &#123; this.list = list; &#125; public synchronized boolean putIfAbsent(T x) &#123; boolean contains = list.contains(x); if (contains) list.add(x); return !contains; &#125; //...&#125; 完全不暴露list出去，额外一层加锁。 4.5 将同步策略文档化在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 笔记三]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22-2%2F</url>
    <content type="text"><![CDATA[第三章 对象的共享 我们已经知道了同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字 synchronized 只能用于实现原子性和确定 “临界区 (Critical Section)”。同步还有另一个重要的方面：内存可见性 (Memory Visibility)。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。你可以通过显式的同步或者类库中内置的同步来确保对象被安全的发布。 3.1 可见性可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。在单线程环境中，如果向某个变量先写入值，然后在没有其他写入的情况下读取这个变量，那么总能得到相同的值。然而，当读取操作和写入操作在不同的线程中执行时，情况却并非如此。通常，我们无法确保执行读取操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制，例如： 12345678910111213141516171819public class NoVisibility &#123; private static boolean ready; private static int number; private static class ReaderThread extends Thread &#123; public void run() &#123; while(!ready) Thread.yield(); System.out.println(number); &#125; &#125; public static void main(String[] args) &#123; // 从代码上来看，先执行run函数，在设置number和ready的值 new ReaderThread().start(); number = 42; ready = true; &#125;&#125; NoVisibility 可能会持续循环下去，因为读线程可能永远都看不到 ready 的值。一种更奇怪的现象是，NoVisibility 可能会输出 0，因为读线程可能看到了写入 ready 的值，但却没有看到之后写入 number 的值，这种现象被称为 “重排序 (Reordering)”。只要在某个线程中无法检测到重排序情况，那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主程序先写入 number，然后在没有同步的情况下写入 ready，那么读线程看到的顺序可能与写入的顺序完全相反。 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。 3.1.1 失效数据NoVisibility 展示了在缺乏同步的程序中可能产生的错误结果的一种：失效数据。当读线程查看 ready 变量时，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步。否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。再看来一个例子： 123456789101112// 线程不安全public class MutableInteger &#123; private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125;&#125; MutableInteger 不是线程安全的，因为 get 和 set 都是在没有同步的情况下访问 value 的。如果某个线程调用了 set，那么另一个正在调用 get 的线程可能会看到更新后的 value 值，也可能看不到。下面将该类改写成线程安全的： 123456789101112// 线程安全public class MutableInteger &#123; private int value; public synchronized int getValue() &#123; return value; &#125; public synchronized void setValue(int value) &#123; this.value = value; &#125;&#125; 通过对 get 和 set 等方法进行同步，可以使 MutableInteger 成为一个线程安全的类。仅仅对 set 方法进行同步是不够的，调用 get 的线程仍然会看到失效值。 3.1.2 非原子的 64 位操作 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性 (out-of-thin-airsafety)。 最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值变量 (double 和 long)。Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非 volatile 类型的 long 和 double 变量，JVM 允许将 64 位的读操作或写操作分解为两个 32 位的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的 long 和 double 等类型的变量也不是安全的，除非用关键字 volatile 来声明他们，或者用锁保护起来。 3.1.3 加锁与可见性在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下读取某个变量，那么读到的可能是一个失效值。 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读取操作或者写入操作的线程都必须在同一个锁上同步。 3.1.4 Volatile 变量Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器在运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一个重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。 注意，在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。 volatile 变量对可见性的影响比 volatile 变量本身更为重要。从内存可见性的角度来看，写入 volatile 变量相当于退出同步代码块，而读取 volatile 变量相当于进入同步代码块。然而，并不建议过度依赖 volatile 变量提供可见性。 仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。 volatile 变量的正确使用方式包括：确保他们自身的状态的可见性，确保他们所引用的对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）。 虽然 volatile 变量很方便，但也存在一些局限性。volatile 变量通常用作某个操作完成、发生中断或者状态的标志。尽管 volatile 变量也可以用于表示其他的状态信息，但在使用时要非常小心。例如，volatile 的语义不足以确保递增操作 (count++) 的原子性，除非你能确保只有一个线程对变量执行写操作。 加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。 当且仅当满足一下所有条件时，才应该使用 volatile 变量： 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值； 该变量不会与其他状态变量一起纳入不变性条件中； 在访问变量时不需要加锁； 3.2 发布与逸出 发布 (Publish) 一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们有需要发布这个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态会破坏封装性，并使程序难以维持不变性条件。当某个不应该发布的对象被发布时，这种情况就被称为逸出(Escape)。例如： 12345public static Set&lt;Secret&gt; knownSecrets;public void initialize() &#123; knownSecrets = new HashSet&lt;Secret&gt;();&#125; 在 initialize 方法中实例化一个新的 HashSet 对象，并将对象的引用保存到 knownSecrets 中以发布对象。 3.2.1 避免内部的可变状态逸出当发布某个对象时，可能会间接发布其他对象。如果将一个 Secret 对象添加到集合 knownSecrets 中，那么同样会发布这个对象，因为任何代码都可以遍历这个集合，并获得对这个新 Secret 对象的引用。同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。看一段代码： 1234567class UnsafeStates &#123; private String[] states = new String[] &#123; "AK", "AL", ... &#125;; public String[] getStates() &#123; return states; &#125;&#125; 如果按照上面的代码发布 states，就会出现问题，因为任何调用者都能修改这个数组的内容。在这个例子中，数组 states 已经逸出了它所在的作用域，因为这个本应是私有的变量已经被发布了。 当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。 3.2.2 隐式地使 this 引用逸出最后一种发布对象或其内部状态的机制就是发布一个内部的类实例，例如： 1234567891011publi class ThisEscape &#123; public ThisEscape(EventSource source) &#123; source.registerListener &#123; new EventListener() &#123; public void onEvent(Event e) &#123; doSomething(e); &#125; &#125; &#125;; &#125;&#125; 不要在构造过程中使 this 引用逸出。 当内部的 EventListener 实例发布时，在外部封装的 ThisEscape 实例也逸出了。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果 this 引用在构造过程中逸出，那么这种对象就被认为是不正确构造。 可以使用工厂方式来防治 this 引用在构造过程中逸出。 3.3 线程封闭当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭 (Thread Confinement)，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。 在 Java 语言中并没有强制规定某个变量必须由锁来保护，同样在 Java 语言中也无法强制将对象封闭在某个线程中。线程封闭式在程序设计中的一个考虑因素，必须在程序中实现。Java 语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和 ThreadLocal类 。但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。 3.3.1 Ad-hoc 线程封闭Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭式非常脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。事实上，对线程封闭对象的引用通常保存在公有变量中。 当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程子系统。在某些情况下，单线程子系统提供的简便性要胜过 Ad-hoc 线程封闭技术的脆弱性。 举个例子，在 volatile 变量上存在一种特殊的线程封闭。只要你能确定只有单个线程对共享的 volatile 变量执行写入操作，那么就可以安全的在这些共享的 volatile 变量上执行 “读取 - 修改 - 写入” 的操作。在这种情况下，相当于修改操作封闭在单个线程中以防止发生竞态条件，并且 volatile 变量的可见性保证还确保了其他线程能看到最新的值。 由于 Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量少用它，可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭和 ThreadLocal 类）。 3.3.2 栈封闭栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。正如封装能使得代码更容易维持不变性条件那样，同步变量也能使对象更易于封闭在线程中。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比 Ad-hoc 线程封闭更易于维护，也更加健壮。 12345678910111213141516171819public int loadTheArk(Collection&lt;Animal&gt; candidates) &#123; SortedSet&lt;Animal&gt; animals; int numPairs = 0; Animal candidate = null; animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator()); animals.addAll(candidates); for (Animal a : animals) &#123; if (candidate == null || !candidate.isPotentialMate(a)) candidate = a; else &#123; ark.load(new AnimalPair(candidate, a)); ++numPairs; candidate = null; &#125; &#125; return numPairs;&#125; 在上面的代码中，numPairs 无论如何都不会破坏栈封闭性。由于任何方法都无法获得对基本类型的引用，因此 Java 语言的这种语义就确保了基本类型的局部变量封闭在线程内。 在维持对象引用的栈封闭性时，程序员需要多做一些工作以确保被引用的对象不会逸出。在 loadTheArk 中实例化一个 TreeSet 对象，并将指向该对象的一个引用确保到 animals 中。此时，只有一个引用指向集合 animals，这个引用被封闭在局部变量中，因此也被封闭在执行线程中。然而，如果发布了对集合 animals 的引用，那么封闭性将被破坏，并导致对象 animals 的逸出。 3.3.3 ThreadLocal 类维持线程封闭性的一种更规范方式是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本。因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。 ThreadLocal 对象通常用于防止对可变的单实例变量 (Singleton) 或全局变量进行共享。例如 Connection 对象，由于 JDBC 的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的链接，例如： 12345678910111213141516171819 public class ConnectionDispenser &#123; static String DB_URL = "jdbc:mysql://localhost/mydatabase"; private ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123; public Connection initialValue() &#123; try &#123; return DriverManager.getConnection(DB_URL); &#125; catch (SQLException e) &#123; throw new RuntimeException("Unable to acquire Connection, e"); &#125; &#125;; &#125;; public Connection getConnection() &#123; return connectionHolder.get(); &#125;&#125; 在实现应用程序框架时大量使用了 ThreadLocal。例如，在 EJB 调用期间，J2EE 容器需要将一个事务上下文 (Transaction Context) 与某个执行中的线程关联起来。通过将事务上下文保存在静态的 ThreadLocal 对象中，可以很容易地实现这个功能：当框架代码需要判断当前运行的是哪一个事务时，只需从这个 ThreadLocal 对象中读取事务上下文。 开发人员经常滥用 ThreadLocal，例如将所有的全局变量都作为 ThreadLocal 对象，或者作为一种 “隐藏” 方法参数的手段。ThreadLocal 变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时需要格外小心。 3.4 不变性如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象 (Immutable Object)。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。 不可变对象一定是线程安全的。 不可变对象很简单。它们只有一种状态，并且该状态由构造函数来控制。在程序设计中，一个最困难的地方就是判断复杂对象的可能状态。然而，判断不可变对象的状态却很简单。 同样，不可变对象也更加安全。如果将一个可变对象传递给不可信的代码，或者将该对象发布到不可信代码可以访问它的地方，那么就很危险 —— 不可信代码会改变它们的状态，更糟的是，在代码中将保留一个对该对象的引用并稍后再其他线程中修改对象的状态。另一方面，不可变对象不会像这样被恶意代码或者有问题的代码破坏，因此可以安全地共享和发布这些对象，而无须创建保护性的副本。 虽然在 Java 语言规范和 Java 内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为 final 类型，即使对象中所有的域都是 final 类型的，这个对象也仍然是可变的，因为在 final 类型的域中可以保存对可变对象的引用。 当满足一下条件时，对象才是不可变的： 对象创建以后其状态就不能修改； 对象的所有域都是 fianl 类型； 对象是正确创建的； 关键字 final 可以视为 C++ 中 const 机制的一种受限版本，用于构造不可变性对象。final 类型的域是不能修改的。然而，在 Java 内存模型中，final 域还有着特殊的语义。final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步。 即使对象是可变的，通过将对象的某些域声明为 final 类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。仅包含一个或两个可变状态的 “基本不可变” 对象仍然比包含多个可变状态的对象简单。通过将域声明为 final 类型，也相当于告诉维护人员这些域是不会变化的。 除非需要某个域是可变的，否则应将其声明为 final 域。 3.5 安全发布到目前为止，我们重点讨论的是如何确保对象不被发布，例如让对象封闭在线程或另一个对象的内部。当然，在某些情况下我们希望在多个线程之间共享对象，此时必须确保安全的进行共享。看一段代码： 1234public Holder holder;public void initialize() &#123; holder = new Holder(42);&#125; 这段代码中，将引用对象保存到公有域中，那么还不足以安全得发布这个对象。由于存在可见性问题，其他线程看到的 Holder 对象将处于一个不一致的状态，即便在该对象的构造函数中已经正确的构造了不变性条件。这种不正确的发布导致其他线程看到尚未创建完成的对象。 3.5.1 不正确的发布：正确的对象被破坏你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。例如： 123456789public class Holder &#123; private int n; public Holder(int n) &#123;this.n = n;&#125; public void assertSanity() &#123; if (n != n) throw new AssertionError("this statement is false."); &#125;&#125; 由于没有使用同步来确保 Holder 对象对其他线程可见，因此将 Holder 称为 “未被正确发布”。这里面存在两个问题，首先，除了发布对象的线程外，其他线程可以看到的 Holder 域是一个失效值，因此将看到一个空引用或者之前的旧值。然而，更糟的情况是线程看到 Holder 引用的值是最新的，但 Holder 状态的值却是失效的。情况变得更加不可预测的是，某个线程在第一次读取域时得到失效值，而再次读取这个域时会得到一个更新值，这也是 assertSainty 抛出 AssertionError 的原因。 3.5.2 不可变对象与初始化安全性由于不可变对象是一种非常重要的对象，因此 Java 内存模型为不可变对象提供了一种特殊的初始化安全性保证。我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一直的视图，就必须使用同步。 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。 3.5.3 安全发布的常用模式要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布： 在静态初始化函数中初始化一个对象引用； 将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中； 将对象的引用保存到某个正确构造对象的 final 类型域中； 将对象的引用保存到一个由锁保护的域中； 在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如 Vector 或 synchronizedList 时，将满足上述最后一条需求。 3.5.4 事实不可变对象如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将是可见的，并且如果对象状态不会再改变，那么就足以确保任何访问都是安全的。 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。 3.5.5 可变对象如果对象在构造后可以修改，那么安全发布只能确保 “发布当时” 状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。 对象的发布需求取决于它的可变性： 不可变对象可以通过任意机制来发布； 事实不可变对象必须通过安全方式来发布； 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来； 3.5.6 安全的共享对象在并发程序中使用和共享对象时，可以使用一些实用的策略，包括： 线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改； 只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象； 线程安全共享：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步； 保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象； 参考：https://my.oschina.net/u/2450666/blog/737432]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程习惯分析 实现方法]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22%2F</url>
    <content type="text"><![CDATA[「需输入密码」 Decrypt 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]]></content>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 笔记二]]></title>
    <url>%2F2018%2F03%2F21%2F2018-03-21%2F</url>
    <content type="text"><![CDATA[第二章 线程安全性Thread Safety 对象的状态指存储在状态变量（实例变量、静态域）中的数据，对象的状态可能包括其他依赖对象的域 “共享” 意味着变量可以由多个线程访问；“可变” 意味着变量的值在其声明周期内可以发生变化 多个线程访问同一个可变的状态变量没有使用合适的同步，就可能出现错误，有三种方式可以修复这个问题 a. 不在线程之间共享该状态变量 b. 将该状态变量修改为不可变的变量 c. 在使用状态变量时使用同步 2.1 什么是线程安全性正确性：某个类的行为与其规范完全一致 当多个线程访问某个类时，不管运行环境采用何种调用方式或者这些线程如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的 无状态类一定是线程安全的 2.2 原子性2.2.1 竞态条件由于不恰当的执行时序而出现的不正确的结果的情况称为竞态条件 最常见的竞态条件类型就是 “先检查后执行（Check-then-Act）” “读取 - 修改 - 写入” 操作也是一种竞态条件 一个很常见的例子就是延迟初始化。当一个线程根据观察结果为空进行初始化时，一个线程可能已经建立了初始化。 1234567891011@NotThreadSafepublic class LazyInitRace &#123; private SampleClass sample; public SampleClass getInstance() &#123; if (instance == null) &#123; instance = new SampleClass(); &#125; return instance; &#125;&#125; 2.2.2 延迟初始化中的竞态条件2.2.3 复合操作原子操作：对于访问同一个状态的所有操作（包括操作本身）来说，这个操作是一个以原子方式执行的操作 复合操作：包含了一组必须以原子方式执行的操作以保证线程安全性 当在无状态的类中加入一个状态时，如果该状态完全由线程安全的对象管理，那么这个类仍旧是线程安全的 2.3 加锁机制要保证状态一致性，就需要单个原子操作中更新所有相关的状态变量 2.3.1 内置锁Java提供的一种内置锁机制：同步代码块。同步代码块包括两个部分：有个作为锁的对象引用，一个作为由这个锁保护的代码块，常见的有synchronized关键字： 123synchronized (lock) &#123; // TODO&#125; 同步代码块（Synchronized Block） 每个 Java 对象都可以用作一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或者监视器锁（Monitor Lock） 内置锁是一种互斥锁，最多只有一个线程持有这个锁 2.3.2 重入重入意味着获取锁的操作的粒度是 “线程”，而不是 “调用” 重入提升了加锁行为的封装性，因此简化了面向对象并发代码的执行 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞。而如果这个线程试图获取已经由它自己持有的锁，则这个请求就会成功。否则，就会导致死锁的发生。简单示例如下： 1234567public class Parent &#123; public synchronized void parentMethod &#123; ... &#125;&#125;public class Child extends Parent &#123; public synchronized void childMethod &#123; ... &#125;&#125; 2.4 用锁来保护状态锁能够使其被保护的对象以串行方式来执行 一种常见的加锁机制：将所有可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得该对象上不会发生并发访问 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护 2.5 活跃性与性能通常，在简单性与性能之间存在着相互制约因素，但是实现某个同步策略时，一定不要为了性能而牺牲简单性（这可能会破坏安全性） 当执行时间较长的计算或者可能无法快速完成的操作（例如网络 I/O 或者控制台 I/O）, 一定不要持有锁 参考:https://www.jianshu.com/p/facf03fb385a]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读十一：ConcurrentHashMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-14%2F</url>
    <content type="text"><![CDATA[概述ConcurrentHashMap 是 Java 并发框架中很重要的一个类，是实现支持高并发、高吞吐量的线程安全的 HashMap。当然不能直接对整个 hashtable 加锁，所以在 ConcurrentHashMap 中，数据的组织结构和 HashMap 有所区别。 与 HashTable 区别下面这幅图直观展示了 ConcurrentHashMap 与 HashTable 的区别，可以看到 HashTable 是对整个 Hash 表进行加锁，而 ConcurrentHashMap 则是分段加锁，加锁的基本单元为 Segment ConcurrentHashMap 原理分析ConcurrentHashMap 的结构是比较复杂的，深究去本质，其实也就是数组和链表而已。我们由浅入深慢慢的分析其结构。 SegmentSegment 是 ConcurrentHashMap 的内部类，Segment 的类定义为 1static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable 其继承于 ReentrantLock 类，从而使得 Segment 对象可以充当锁的角色。Segment 中包含 HashEntry 的数组，其可以守护其包含的若干个桶（HashEntry 的数组）。Segment 在某些意义上有点类似于 HashMap 了，都是包含了一个数组，而数组中的元素可以是一个链表。 tabletable 是由 HashEntry 对象组成的数组如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表 table 数组的数组成员代表散列映射表的一个桶每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16。 count 变量是计数器，表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 的链表）包含的 HashEntry 对象的个数。之所以在每个 Segment 对象中包含一个 count 计数器，而不在 ConcurrentHashMap 中使用全局的计数器，是为了避免出现 “热点域” 而影响并发性。 HashEntryHashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。其类的定义为： 123456789101112131415static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ... ...&#125; HashEntry 的学习可以类比着 HashMap 中的 Entry。我们的存储键值对的过程中，散列的时候如果发生 “碰撞”，将采用“分离链表法” 来处理碰撞：把碰撞的 HashEntry 对象链接成一个链表。 并发 put 操作在 ConcurrentHashMap 中，当执行 put 方法的时候，会需要加锁来完成。我们通过代码来解释一下具体过程： 当我们 new 一个 ConcurrentHashMap 对象，并且执行 put 操作的时候，首先会执行 ConcurrentHashMap 类中的 put 方法，该方法源码为： 123456789101112@SuppressWarnings(&quot;unchecked&quot;) public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false); &#125; 我们通过注释可以了解到，ConcurrentHashMap 不允许空值。该方法首先有一个 Segment 的引用 s，然后会通过 hash() 方法对 key 进行计算，得到哈希值；继而通过调用 Segment 的 put(K key, int hash, V value, boolean onlyIfAbsent) 方法进行存储操作。该方法源码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; //加锁，这里是锁定的Segment而不是整个ConcurrentHashMap HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value); V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; //得到hash对应的table中的索引index int index = (tab.length - 1) &amp; hash; //找到hash对应的是具体的哪个桶，也就是哪个HashEntry链表 HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; //解锁 unlock(); &#125; return oldValue;&#125; 关于该方法的某些关键步骤，在源码上加上了注释。 需要注意的是：加锁操作是针对的 hash 值对应的某个 Segment，而不是整个 ConcurrentHashMap。因为 put 操作只是在这个 Segment 中完成，所以并不需要对整个 ConcurrentHashMap 加锁。所以，此时，其他的线程也可以对另外的 Segment 进行 put 操作，因为虽然该 Segment 被锁住了，但其他的 Segment 并没有加锁。同时，读线程并不会因为本线程的加锁而阻塞。 正是因为其内部的结构以及机制，所以 ConcurrentHashMap 在并发访问的性能上要比 Hashtable 和同步包装之后的 HashMap 的性能提高很多。在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。 get 操作Get 方法的实现 12345678910111213141516V get(Object key, int hash) &#123; if(count != 0) &#123; // 首先读 count 变量 HashEntry&lt;K,V&gt; e = getFirst(hash); while(e != null) &#123; if(e.hash == hash &amp;&amp; key.equals(e.key)) &#123; V v = e.value; if(v != null) return v; // 如果读到 value 域为 null，说明发生了重排序，加锁后重新读取 return readValueUnderLock(e); &#125; e = e.next; &#125; &#125; return null; &#125; ConcurrentHashMap 中的读方法不需要加锁，所有的修改操作在进行结构修改时都会在最后一步写 count 变量，通过这种机制保证 get 操作能够得到几乎最新的结构更新。 总结在实际的应用中，散列表一般的应用场景是：除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。正是基于这个前提，ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得 大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。 ConcurrentHashMap 的高并发性主要来自于三个方面： 用分离锁实现多个线程间的更深层次的共享访问。 用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读十：HashTable]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-13%2F</url>
    <content type="text"><![CDATA[HashTable 介绍 HashTable 经常和 HashMap 拿来做对比。HashTable 同样是基于哈希表实现的，同样每个元素都是 key-value 对，其内部也是通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。Hashtable 也是 JDK1.0 引入的类，是线程安全的，能用于多线程环境中。Hashtable 同样实现了 Serializable 接口，它支持序列化，实现了 Cloneable 接口，能被克隆。 HashTable 类层次结构如下 HashTable 源码HashTable 源码如下，加入了比较详细的注释，(基于 Sun JDK 1.7)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835package java.util;import java.io.*;public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; // 保存key-value的数组。 // Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表 private transient Entry&lt;K,V&gt;[] table; // Hashtable中键值对的数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数，用于fail-fast机制的实现 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; /** * The default threshold of map capacity above which alternative hashing is * used for String keys. Alternative hashing reduces the incidence of * collisions due to weak hash code calculation for String keys. * &lt;p&gt; * This value may be overridden by defining the system property * &#123;@code jdk.map.althashing.threshold&#125;. A property value of &#123;@code 1&#125; * forces alternative hashing to be used at all times whereas * &#123;@code -1&#125; value ensures that alternative hashing is never used. */ static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE; /** * holds values which can&apos;t be initialized until after VM is booted. */ private static class Holder &#123; /** * Table capacity above which to switch to use alternative hashing. */ static final int ALTERNATIVE_HASHING_THRESHOLD; static &#123; String altThreshold = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction( &quot;jdk.map.althashing.threshold&quot;)); int threshold; try &#123; threshold = (null != altThreshold) ? Integer.parseInt(altThreshold) : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT; // disable alternative hashing if -1 if (threshold == -1) &#123; threshold = Integer.MAX_VALUE; &#125; if (threshold &lt; 0) &#123; throw new IllegalArgumentException(&quot;value must be positive integer.&quot;); &#125; &#125; catch(IllegalArgumentException failed) &#123; throw new Error(&quot;Illegal value for &apos;jdk.map.althashing.threshold&apos;&quot;, failed); &#125; ALTERNATIVE_HASHING_THRESHOLD = threshold; &#125; &#125; // 指定“容量大小”的构造函数 final boolean initHashSeedAsNeeded(int capacity) &#123; boolean currentAltHashing = hashSeed != 0; boolean useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean switching = currentAltHashing ^ useAltHashing; if (switching) &#123; hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(this) : 0; &#125; return switching; &#125; private int hash(Object k) &#123; // hashSeed will be zero if alternative hashing is disabled. return hashSeed ^ k.hashCode(); &#125; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); initHashSeedAsNeeded(initialCapacity); &#125; // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f); &#125; // 默认构造函数。 public Hashtable() &#123; // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); &#125; // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t); &#125; public synchronized int size() &#123; return count; &#125; public synchronized boolean isEmpty() &#123; return count == 0; &#125; // 返回“所有key”的枚举对象 public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; // 返回“所有value”的枚举对象 public synchronized Enumeration&lt;V&gt; elements() &#123; return this.&lt;V&gt;getEnumeration(VALUES); &#125; // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) &#123; if (value == null) &#123; throw new NullPointerException(); &#125; Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean containsValue(Object value) &#123; return contains(value); &#125; // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false; &#125; // 返回key对应的value，没有的话返回null public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 调整Hashtable的长度，将长度变成原来的2倍+1 protected void rehash() &#123; int oldCapacity = table.length; Entry&lt;K,V&gt;[] oldMap = table; // overflow-conscious code int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; &#125; Entry&lt;K,V&gt;[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); boolean rehash = initHashSeedAsNeeded(newCapacity); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; if (rehash) &#123; e.hash = hash(e.key); &#125; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; &#125; &#125; &#125; // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; modCount++; if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; hash = hash(key); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; return null; &#125; // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null; &#125; // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue()); &#125; // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() &#123; Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0; &#125; // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() &#123; try &#123; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) &#123; t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; &#125; t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); &#125; &#125; public synchronized String toString() &#123; int max = size() - 1; if (max == -1) return &quot;&#123;&#125;&quot;; StringBuilder sb = new StringBuilder(); Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator(); sb.append(&apos;&#123;&apos;); for (int i = 0; ; i++) &#123; Map.Entry&lt;K,V&gt; e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? &quot;(this Map)&quot; : key.toString()); sb.append(&apos;=&apos;); sb.append(value == this ? &quot;(this Map)&quot; : value.toString()); if (i == max) return sb.append(&apos;&#125;&apos;).toString(); sb.append(&quot;, &quot;); &#125; &#125; // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。 private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return Collections.emptyEnumeration(); &#125; else &#123; return new Enumerator&lt;&gt;(type, false); &#125; &#125; // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) &#123; if (count == 0) &#123; return Collections.emptyIterator(); &#125; else &#123; return new Enumerator&lt;&gt;(type, true); &#125; &#125; // Views // Hashtable的“key的集合”。它是一个Set，没有重复元素 private transient volatile Set&lt;K&gt; keySet = null; // Hashtable的“key-value的集合”。它是一个Set，没有重复元素 private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素 private transient volatile Collection&lt;V&gt; values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;K&gt; keySet() &#123; if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; &#125; // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return getIterator(KEYS); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return Hashtable.this.remove(o) != null; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; &#125;// Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return getIterator(ENTRIES); &#125; public boolean add(Map.Entry&lt;K,V&gt; o) &#123; return super.add(o); &#125; // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash &amp;&amp; e.equals(entry)) return true; return false; &#125; // 删除元素Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，删除链表中的元素Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e.hash==hash &amp;&amp; e.equals(entry)) &#123; modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; &#125; &#125; return false; &#125; public int size() &#123; return count; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection&lt;V&gt; values() &#123; if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; &#125; // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return getIterator(VALUES); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // Comparison and hashing // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o; if (t.size() != size()) return false; try &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(t.get(key)==null &amp;&amp; t.containsKey(key))) return false; &#125; else &#123; if (!value.equals(t.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true; &#125; // 计算Entry的hashCode // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。 // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。 public synchronized int hashCode() &#123; int h = 0; if (count == 0 || loadFactor &lt; 0) return h; // Returns zero loadFactor = -loadFactor; // Mark hashCode computation in progress Entry[] tab = table; for (Entry&lt;K,V&gt; entry : tab) while (entry != null) &#123; h += entry.hashCode(); entry = entry.next; &#125; loadFactor = -loadFactor; // Mark hashCode computation complete return h; &#125; // java.io.Serializable的写入函数 // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; Entry&lt;K, V&gt; entryStack = null; synchronized (this) &#123; // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements s.writeInt(table.length); s.writeInt(count); // Stack copies of the entries in the table for (int index = 0; index &lt; table.length; index++) &#123; Entry&lt;K,V&gt; entry = table[index]; while (entry != null) &#123; entryStack = new Entry&lt;&gt;(0, entry.key, entry.value, entryStack); entry = entry.next; &#125; &#125; &#125; // Write out the key/value objects from the stacked entries while (entryStack != null) &#123; s.writeObject(entryStack.key); s.writeObject(entryStack.value); entryStack = entryStack.next; &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it&apos;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that&apos;s not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry&lt;K,V&gt;[] newTable = new Entry[length]; threshold = (int) Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1); count = 0; initHashSeedAsNeeded(length); // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(newTable, key, value); &#125; this.table = newTable; &#125; /** * The put method used by readObject. This is provided because put * is overridable and should not be called in readObject since the * subclass will not yet be initialized. * * &lt;p&gt;This differs from the regular put method in several ways. No * checking for rehashing is necessary since the number of elements * initially in the table is known. The modCount is not incremented * because we are creating a new instance. Also, no return value * is needed. */ private void reconstitutionPut(Entry&lt;K,V&gt;[] tab, K key, V value) throws StreamCorruptedException &#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; &#125; // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 哈希值 int hash; final K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; protected Object clone() &#123; return new Entry&lt;&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); &#125; // Map.Entry Ops public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; // 设置value。若value是null，则抛出异常。 public V setValue(V value) &#123; if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; &#125; // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry)o; return key.equals(e.getKey()) &amp;&amp; value.equals(e.getValue()); &#125; public int hashCode() &#123; return (Objects.hashCode(key) ^ Objects.hashCode(value)); &#125; public String toString() &#123; return key.toString()+&quot;=&quot;+value.toString(); &#125; &#125; // Types of Enumerations/Iterations private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null; &#125; // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;); &#125; // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() &#123; return hasMoreElements(); &#125; // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException(&quot;Hashtable Enumerator&quot;); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125; &#125;&#125; 重点解析从以上的源码中，我们可以看到，HashTable 和 HashMap 还是非常相似的。 相同点 二者的存储结构和解决冲突的方法都是相同的。HashTable 同样是基于哈希表实现的，同样每个元素都是 key-value 对，其内部也是通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。 Hashtable 同样实现了 Serializable 接口，它支持序列化，实现了 Cloneable 接口，能被克隆。 不同点 最重要一点 HashTable 是很多方法都加了同步，因此支持多线程并发执行，是线程同步的而 HashMap 不是线程同步的。 HashTable 在不指定容量的情况下的默认容量为 11，而 HashMap 为 16，Hashtable 不要求底层数组的容量一定要为 2 的整数次幂，而 HashMap 则要求一定为 2 的整数次幂。 Hashtable 中 key 和 value 都不允许为 null，而 HashMap 中 key 和 value 都允许为 null（key 只能有一个为 null，而 value 则可以有多个为 null）。但是如果在 Hashtable 中有类似 put(null,null) 的操作，编译同样可以通过，因为 key 和 value 都是 Object 类型，但运行时会抛出NullPointerException异常，这是 JDK 的规范规定的。 Hashtable 扩容时，将容量变为原来的 2 倍加 1，而 HashMap 扩容时，将容量变为原来的 2 倍。 Hashtable 计算 hash 值，直接用 key 的 hashCode()，而 HashMap 重新计算了 key 的 hash 值，Hashtable 在求 hash 值对应的位置索引时，用取模运算，而 HashMap 在求位置索引时，则用与运算，且这里一般先用 hash&amp;0x7FFFFFFF 后，再对 length 取模，&amp;0x7FFFFFFF 的目的是为了将负的 hash 值转化为正值，因为 hash 值有可能为负数，而 &amp; 0x7FFFFFFF 后，只有符号外改变，而后面的位都不变。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读九：HashTable]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-12%2F</url>
    <content type="text"><![CDATA[Vector 介绍Vector 也是基于数组实现的，是一个动态数组，其容量能自动增长。Vector 是 JDK1.0 引入了，它的很多实现方法都加入了同步语句，因此是线程安全的（其实也只是相对安全，有些时候还是要加入同步语句来保证线程的安全），可以用于多线程环境。Vector 实现了 Serializable 接口，可以被序列化，Cloneable 接口，能被克隆，实现了 RandomAccess 接口，支持快速随机访问。 Vector 类层次 Vector 源码分析以下是 Vector 的源码，基于 Sun JDK1.7 版本，加入了较为详细的注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606package java.util;public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 保存Vector中数据的数组 protected Object[] elementData; // 实际数据的数量 protected int elementCount; // 容量增长系数 protected int capacityIncrement; // Vector的序列版本号 private static final long serialVersionUID = -2767605614048989439L; // 指定Vector&quot;容量大小&quot;和&quot;增长系数&quot;的构造函数 public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; &#125; // 指定Vector容量大小的构造函数 public Vector(int initialCapacity) &#123; this(initialCapacity, 0); &#125; // Vector构造函数。默认容量是10。 public Vector() &#123; this(10); &#125; // 指定集合的Vector构造函数。 public Vector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); &#125; // 将数组Vector的全部元素都拷贝到数组anArray中 public synchronized void copyInto(Object[] anArray) &#123; System.arraycopy(elementData, 0, anArray, 0, elementCount); &#125; // 将当前容量值设为 =实际元素个数 public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125; &#125; // 确定Vector的容量。 public synchronized void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) &#123; modCount++; ensureCapacityHelper(minCapacity); &#125; &#125; // 确认“Vector容量”的帮助函数 private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize; &#125; // 返回“Vector的总的容量” public synchronized int capacity() &#123; return elementData.length; &#125; // 返回“Vector的实际大小”，即Vector中元素个数 public synchronized int size() &#123; return elementCount; &#125; // 判断Vector是否为空 public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; // 返回“Vector中全部元素对应的Enumeration” public Enumeration&lt;E&gt; elements() &#123; // 通过匿名类实现Enumeration return new Enumeration&lt;E&gt;() &#123; int count = 0; // 是否存在下一个元素 public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; // 获取下一个元素 public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return elementData(count++); &#125; &#125; throw new NoSuchElementException(&quot;Vector Enumeration&quot;); &#125; &#125;; &#125; // 返回Vector中是否包含对象(o) public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0; &#125; // 返回Vector中是否包含对象(o) public int indexOf(Object o) &#123; return indexOf(o, 0); &#125; // 从index位置开始向后查找元素(o)。 // 若找到，则返回元素的索引值；否则，返回-1 public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; // 若查找元素为null，则正向找出null元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; // 若查找元素不为null，则正向找出该元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 从后向前查找元素(o)。并返回元素的索引 public synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1); &#125; // 从后向前查找元素(o)。开始位置是从前向后的第index个数； // 若找到，则返回元素的“索引值”；否则，返回-1。 public synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot;+ elementCount); if (o == null) &#123; // 若查找元素为null，则反向找出null元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; // 若查找元素不为null，则反向找出该元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回Vector中index位置的元素。 // 若index越界，则抛出异常 public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; return elementData(index); &#125; // 获取Vector中的第一个元素。 // 若失败，则抛出异常！ public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; // 获取Vector中的最后一个元素。 // 若失败，则抛出异常！ public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; // 设置index位置的元素值为obj public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; elementData[index] = obj; &#125; // 删除index位置的元素 public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */ &#125; // 在index位置处插入元素(obj) public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt; &quot; + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; &#125; // 将“元素obj”添加到Vector末尾 public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; // 在Vector中查找并删除元素obj。 // 成功的话，返回true；否则，返回false。 public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false; &#125; // 删除Vector中的全部元素 public synchronized void removeAllElements() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0; &#125; // 克隆函数 public synchronized Object clone() &#123; try &#123; @SuppressWarnings(&quot;unchecked&quot;) Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, elementCount); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); &#125; &#125; // 返回Object数组 public synchronized Object[] toArray() &#123; return Arrays.copyOf(elementData, elementCount); &#125; // 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型 @SuppressWarnings(&quot;unchecked&quot;) public synchronized &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; Vector的元素个数； // 则新建一个T[]数组，数组大小是“Vector的元素个数”，并将“Vector”全部拷贝到新数组中 if (a.length &lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); // 若数组a的大小 &gt;= Vector的元素个数； // 则将Vector的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, elementCount); if (a.length &gt; elementCount) a[elementCount] = null; return a; &#125; // Positional Access Operations @SuppressWarnings(&quot;unchecked&quot;) E elementData(int index) &#123; return (E) elementData[index]; &#125; // 获取index位置的元素 public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); &#125; // 设置index位置的值为element。并返回index位置的原始值 public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; // 将“元素e”添加到Vector最后。 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; // 删除Vector中的元素o public boolean remove(Object o) &#123; return removeElement(o); &#125; // 在index位置添加元素element public void add(int index, E element) &#123; insertElementAt(element, index); &#125; // 删除index位置的元素，并返回index位置的原始值 public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue; &#125; // 清空Vector public void clear() &#123; removeAllElements(); &#125; // Bulk Operations // 返回Vector是否包含集合c public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123; return super.containsAll(c); &#125; // 将集合c添加到Vector中 public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; &#125; // 删除集合c的全部元素 public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123; return super.removeAll(c); &#125; // 删除“非集合c中的元素” public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123; return super.retainAll(c); &#125; // 从index位置开始，将集合c添加到Vector中 public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; modCount++; if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); int numMoved = elementCount - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0; &#125; // 返回两个对象是否相等 public synchronized boolean equals(Object o) &#123; return super.equals(o); &#125; // 计算哈希值 public synchronized int hashCode() &#123; return super.hashCode(); &#125; // 调用父类的toString() public synchronized String toString() &#123; return super.toString(); &#125; // 获取Vector中fromIndex(包括)到toIndex(不包括)的子集 public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); &#125; // 删除Vector中fromIndex到toIndex的元素 protected synchronized void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = elementCount - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; &#125; // java.io.Serializable的写入函数 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; final java.io.ObjectOutputStream.PutField fields = s.putFields(); final Object[] data; synchronized (this) &#123; fields.put(&quot;capacityIncrement&quot;, capacityIncrement); fields.put(&quot;elementCount&quot;, elementCount); data = elementData.clone(); &#125; fields.put(&quot;elementData&quot;, data); s.writeFields(); &#125; //返回从指定位置处开始的listIterator public synchronized ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; elementCount) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); return new ListItr(index); &#125; //返回listIterator public synchronized ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public synchronized Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; // Racy but within spec, since modifications are checked // within or after synchronization in next/previous return cursor != elementCount; &#125; public E next() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor; if (i &gt;= elementCount) throw new NoSuchElementException(); cursor = i + 1; return elementData(lastRet = i); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.remove(lastRet); expectedModCount = modCount; &#125; cursor = lastRet; lastRet = -1; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ final class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public E previous() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); cursor = i; return elementData(lastRet = i); &#125; &#125; public void set(E e) &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.set(lastRet, e); &#125; &#125; public void add(E e) &#123; int i = cursor; synchronized (Vector.this) &#123; checkForComodification(); Vector.this.add(i, e); expectedModCount = modCount; &#125; cursor = i + 1; lastRet = -1; &#125; &#125;&#125; 重点分析从上述源码可以看到，Vector 总体与 ArrayList 类似，但还是有区别的，关于 ArrayList 的分析可以查看《Java 集合框架源码分析 (一)——ArrayList》。 相同点 Vector 内部使用数组来保存元素。 Vector 实现了 RandomAccess, Cloneable, java.io.Serializable 三个标记接口，表示它自身支持快速随机访问，克隆，序列化。 如果不指定容量大小，默认情况下，Vector 容量为 10, 在 JDk1.7 中 Vector 最大容量为 Integer.MAX_VALUE - 8. 内部具备自动扩容机制，当容量不足时，会自动申请内存空间。 同样在查找给定元素索引值等的方法中，源码都将该元素的值分为 null 和不为 null 两种情况处理，Vector 中也允许元素为 null。 不同点1 . 并发性很多方法都加入了 synchronized 同步语句，来保证线程安全。2. 扩容实现方案 Vector 具体的扩容最终会调用到 grow 方法。 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; 详细扩容过程：当容量不足以容纳当前的元素个数时，就先看构造方法中传入的容量增长量参数 CapacityIncrement 是否为 0，如果不为 0，就设置新的容量为就容量加上容量增长量，如果为 0，就设置新的容量为旧的容量的 2 倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后同样用 Arrays.copyof() 方法将元素拷贝到新的数组。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读八：WeakHashMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-11%2F</url>
    <content type="text"><![CDATA[WeakHashMap总体介绍一个特殊的成员：WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。 更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况： 调用两次size()方法返回不同的值； 两次调用isEmpty()方法，第一次返回false，第二次返回true； 两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key； 两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。 遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，WeekHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。 要明白 WeekHashMap 的工作原理，还需要引入一个概念：弱引用（WeakReference）。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。 WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。 关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。 具体实现WeakHashMap的存储结构类似于HashMap，读者可自行参考前文，这里不再赘述。 关于强弱引用的管理方式，博主将会另开专题单独讲解。 Weak HashSet?如果你看过前几篇关于 Map 和 Set 的讲解，一定会问：既然有 WeekHashMap，是否有 WeekHashSet 呢？答案是没有:( 。不过Java Collections工具类给出了解决方案，Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)方法可以将任何 Map包装成一个Set。通过如下方式可以快速得到一个 Weak HashSet： 123// 将WeakHashMap包装成一个SetSet&lt;Object&gt; weakHashSet = Collections.newSetFromMap( new WeakHashMap&lt;Object, Boolean&gt;()); 不出你所料，newSetFromMap()方法只是对传入的 Map做了简单包装： 12345678910111213141516171819202122232425262728293031323334// Collections.newSetFromMap()用于将任何Map包装成一个Setpublic static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) &#123; return new SetFromMap&lt;&gt;(map);&#125;private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Serializable&#123; private final Map&lt;E, Boolean&gt; m; // The backing map private transient Set&lt;E&gt; s; // Its keySet SetFromMap(Map&lt;E, Boolean&gt; map) &#123; if (!map.isEmpty()) throw new IllegalArgumentException("Map is non-empty"); m = map; s = map.keySet(); &#125; public void clear() &#123; m.clear(); &#125; public int size() &#123; return m.size(); &#125; public boolean isEmpty() &#123; return m.isEmpty(); &#125; public boolean contains(Object o) &#123; return m.containsKey(o); &#125; public boolean remove(Object o) &#123; return m.remove(o) != null; &#125; public boolean add(E e) &#123; return m.put(e, Boolean.TRUE) == null; &#125; public Iterator&lt;E&gt; iterator() &#123; return s.iterator(); &#125; public Object[] toArray() &#123; return s.toArray(); &#125; public &lt;T&gt; T[] toArray(T[] a) &#123; return s.toArray(a); &#125; public String toString() &#123; return s.toString(); &#125; public int hashCode() &#123; return s.hashCode(); &#125; public boolean equals(Object o) &#123; return o == this || s.equals(o); &#125; public boolean containsAll(Collection&lt;?&gt; c) &#123;return s.containsAll(c);&#125; public boolean removeAll(Collection&lt;?&gt; c) &#123;return s.removeAll(c);&#125; public boolean retainAll(Collection&lt;?&gt; c) &#123;return s.retainAll(c);&#125; // addAll is the only inherited implementation ......&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读七：PriorityQueue]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-10%2F</url>
    <content type="text"><![CDATA[PriorityQueue总体介绍前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，类似于C++的仿函数）。 Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现。 上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系： leftNo = parentNo*2+1 rightNo = parentNo*2+2 parentNo = (nodeNo-1)/2 通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。 PriorityQueue的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。 方法剖析add()和offer()add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。 新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。 123456789101112131415//offer(E e)public boolean offer(E e) &#123; if (e == null)//不允许放入null元素 throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1);//自动扩容 size = i + 1; if (i == 0)//队列原来为空，这是插入的第一个元素 queue[0] = e; else siftUp(i, e);//调整 return true;&#125; 上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。 123456789101112//siftUp()private void siftUp(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2 Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法 break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125; 新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。 element()和peek()element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。 代码也就非常简洁： 123456//peek()public E peek() &#123; if (size == 0) return null; return (E) queue[0];//0下标处的那个元素就是最小的那个&#125; remove()和poll()remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。 代码如下： 123456789101112public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0];//0下标处的那个元素就是最小的那个 E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x);//调整 return result;&#125; 上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）。重点是siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。 123456789101112131415161718//siftDown()private void siftDown(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标 int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1 Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c;//然后用c取代原来的值 k = child; &#125; queue[k] = x;&#125; remove(Object o)remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。 具体代码如下： 1234567891011121314151617//remove(Object o)public boolean remove(Object o) &#123; //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标 int i = indexOf(o); if (i == -1) return false; int s = --size; if (s == i) //情况1 queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved);//情况2 ...... &#125; return true;&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读六：LinkedHashSet and LinkedHashMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-9%2F</url>
    <content type="text"><![CDATA[LinkedHashSet and LinkedHashMap总体介绍如果你已看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文将要讲解的LinkedHashSet和LinkedHashMap其实也是一回事。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。因此本文将重点分析LinkedHashMap。 LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。 事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。 除了可以保证迭代历顺序，这种结构还有一个好处：迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。 有两个参数可以影响LinkedHashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@OverridehashCode()和equals()方法。 通过如下方式可以得到一个跟源Map 迭代顺序一样的LinkedHashMap： 1234void foo(Map m) &#123; Map copy = new LinkedHashMap(m); ...&#125; 出于性能原因，LinkedHashMap是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成（wrapped）同步的： Map m = Collections.synchronizedMap(new LinkedHashMap(...)); 方法剖析get()get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行参考前文，这里不再赘述。 put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。 注意，这里的插入有两重含义： 从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。 从header的角度看，新的entry需要插入到双向链表的尾部。 addEntry()代码如下： 123456789101112131415// LinkedHashMap.addEntry()void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);// 自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);// hash%table.length &#125; // 1.在冲突链表头部插入新的entry HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; // 2.在双向链表的尾部插入新的entry e.addBefore(header); size++;&#125; 上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下： 1234567// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; 上述代码只是简单修改相关entry的引用而已。 remove()remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟get()方法类似。 注意，这里的删除也有两重含义： 从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。 从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。 removeEntryForKey()对应的代码如下： 12345678910111213141516171819202122232425// LinkedHashMap.removeEntryForKey()，删除key值对应的entryfinal Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);// hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;// 遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;// 找到要删除的entry modCount++; size--; // 1. 将e从对应bucket的冲突链表中删除 if (prev == e) table[i] = next; else prev.next = next; // 2. 将e从双向链表中删除 e.before.after = e.after; e.after.before = e.before; return e; &#125; prev = e; e = next; &#125; return e;&#125; LinkedHashSet前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。 1234567891011121314public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ...... // LinkedHashSet里面有一个LinkedHashMap public LinkedHashSet(int initialCapacity, float loadFactor) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125; LinkedHashMap经典用法LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法：可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下： 12345678910111213/** 一个固定大小的FIFO替换策略的缓存 */class FIFOCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt;&#123; private final int cacheSize; public FIFOCache(int cacheSize)&#123; this.cacheSize = cacheSize; &#125; // 当Entry个数超过cacheSize时，删除最老的Entry @Override protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return size() &gt; cacheSize; &#125;&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读五：HashSet and HashMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-8%2F</url>
    <content type="text"><![CDATA[HashSet and HashMap总体介绍之所以把HashSet和HashMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap（适配器模式）。因此本文将重点分析HashMap。 HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟Hashtable大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。Java HashMap采用的是冲突链表方式。 从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。 有两个参数可以影响HashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到HashMap或HashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@OverridehashCode()和equals()方法。 方法剖析get()get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。 上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。 1234567891011121314//getEntry()方法final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表 e != null; e = e.next) &#123;//依次遍历冲突链表中的每个entry Object k; //依据equals()方法判断是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。 123456789101112//addEntry()void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);//hash%table.length &#125; //在冲突链表头部插入新的entry Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; remove()remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟getEntry()过程类似。 123456789101112131415161718192021//removeEntryForKey()final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);//hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];//得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;//遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;//找到要删除的entry modCount++; size--; if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry else prev.next = next; return e; &#125; prev = e; e = next; &#125; return e;&#125; HashSet前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。 12345678910111213141516//HashSet是对HashMap的简单包装public class HashSet&lt;E&gt;&#123; ...... private transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读四：TreeSet and TreeMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-7%2F</url>
    <content type="text"><![CDATA[总体介绍之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap（适配器模式）。因此本文将重点分析TreeMap。 Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。 TreeMap底层通过红黑树（Red-Black tree）实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。 出于性能原因，TreeMap是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成（wrapped）同步的： SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...)); 红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）： 每个节点要么是红色，要么是黑色。 根节点必须是黑色 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。 对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。 在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。 预备知识前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（RotateRight）。 左旋左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 TreeMap中左旋代码如下： 123456789101112131415161718//Rotate Leftprivate void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125; 右旋右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 TreeMap中右旋代码如下： 12345678910111213141516//Rotate Rightprivate void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 寻找节点后继对于一棵二叉查找树，给定节点t，其后继（树中比大于t的最小的那个元素）可以通过如下方式找到： t的右子树不空，则t的后继是其右子树中最小的那个元素。 t的右孩子为空，则t的后继是其第一个向左走的祖先。 后继节点在红黑树的删除操作中将会用到。 TreeMap中寻找节点后继的代码如下： 12345678910111213141516171819// 寻找节点后继函数successor()static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123;// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素 Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123;// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; 方法剖析get()get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。 具体代码如下： 123456789101112131415161718//getEntry()方法final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... if (key == null)//不允许key值为null throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0)//向左找 p = p.left; else if (cmp &gt; 0)//向右找 p = p.right; else return p; &#125; return null;&#125; put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改变某些节点的颜色）。 123456789101112131415161718192021public V put(K key, V value) &#123; ...... int cmp; Entry&lt;K,V&gt; parent; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left;//向左找 else if (cmp &gt; 0) t = t.right;//向右找 else return t.setValue(value); &#125; while (t != null); Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e);//调整 size++; return null;&#125; 上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。 调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。 12345678910111213141516171819202122232425262728293031323334353637383940//红黑树调整函数fixAfterInsertion()private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况1 setColor(y, BLACK); // 情况1 setColor(parentOf(parentOf(x)), RED); // 情况1 x = parentOf(parentOf(x)); // 情况1 &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); // 情况2 rotateLeft(x); // 情况2 &#125; setColor(parentOf(x), BLACK); // 情况3 setColor(parentOf(parentOf(x)), RED); // 情况3 rotateRight(parentOf(parentOf(x))); // 情况3 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况4 setColor(y, BLACK); // 情况4 setColor(parentOf(parentOf(x)), RED); // 情况4 x = parentOf(parentOf(x)); // 情况4 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); // 情况5 rotateRight(x); // 情况5 &#125; setColor(parentOf(x), BLACK); // 情况6 setColor(parentOf(parentOf(x)), RED); // 情况6 rotateLeft(parentOf(parentOf(x))); // 情况6 &#125; &#125; &#125; root.color = BLACK;&#125; remove()remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。 getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。 由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况： 删除点p的左右子树都为空，或者只有一棵子树非空。 删除点p的左右子树都非空。 对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）。 基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下： 123456789101112131415161718192021222324252627282930313233343536// 红黑树entry删除函数deleteEntry()private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; if (p.left != null &amp;&amp; p.right != null) &#123;// 2. 删除点p的左右子树都非空。 Entry&lt;K,V&gt; s = successor(p);// 后继 p.key = s.key; p.value = s.value; p = s; &#125; Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123;// 1. 删除点p只有一棵子树非空。 replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; p.left = p.right = p.parent = null; if (p.color == BLACK) fixAfterDeletion(replacement);// 调整 &#125; else if (p.parent == null) &#123; root = null; &#125; else &#123; // 1. 删除点p的左右子树都为空 if (p.color == BLACK) fixAfterDeletion(p);// 调整 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。 跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。 上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。 删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况1 setColor(parentOf(x), RED); // 情况1 rotateLeft(parentOf(x)); // 情况1 sib = rightOf(parentOf(x)); // 情况1 &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况2 x = parentOf(x); // 情况2 &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); // 情况3 setColor(sib, RED); // 情况3 rotateRight(sib); // 情况3 sib = rightOf(parentOf(x)); // 情况3 &#125; setColor(sib, colorOf(parentOf(x))); // 情况4 setColor(parentOf(x), BLACK); // 情况4 setColor(rightOf(sib), BLACK); // 情况4 rotateLeft(parentOf(x)); // 情况4 x = root; // 情况4 &#125; &#125; else &#123; // 跟前四种情况对称 Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况5 setColor(parentOf(x), RED); // 情况5 rotateRight(parentOf(x)); // 情况5 sib = leftOf(parentOf(x)); // 情况5 &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况6 x = parentOf(x); // 情况6 &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); // 情况7 setColor(sib, RED); // 情况7 rotateLeft(sib); // 情况7 sib = leftOf(parentOf(x)); // 情况7 &#125; setColor(sib, colorOf(parentOf(x))); // 情况8 setColor(parentOf(x), BLACK); // 情况8 setColor(leftOf(sib), BLACK); // 情况8 rotateRight(parentOf(x)); // 情况8 x = root; // 情况8 &#125; &#125; &#125; setColor(x, BLACK);&#125; TreeSet前面已经说过TreeSet是对TreeMap的简单包装，对TreeSet的函数调用都会转换成合适的TreeMap方法，因此TreeSet的实现非常简单。这里不再赘述。 1234567891011121314151617// TreeSet是对TreeMap的简单包装public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; ...... private transient NavigableMap&lt;E,Object&gt; m; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public TreeSet() &#123; this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap &#125; ...... public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; ......&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读三：Stack and Queue]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-6%2F</url>
    <content type="text"><![CDATA[前言Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）。 总体介绍要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口： Queue Method Equivalent Deque Method 说明 add(e) addLast(e) 向队尾插入元素，失败则抛出异常 offer(e) offerLast(e) 向队尾插入元素，失败则返回false remove() removeFirst() 获取并删除队首元素，失败则抛出异常 poll() pollFirst() 获取并删除队首元素，失败则返回null element() getFirst() 获取但不删除队首元素，失败则抛出异常 peek() peekFirst() 获取但不删除队首元素，失败则返回null 下表列出了Deque与Stack对应的接口： Stack Method Equivalent Deque Method 说明 push(e) addFirst(e) 向栈顶插入元素，失败则抛出异常 无 offerFirst(e) 向栈顶插入元素，失败则返回false pop() removeFirst() 获取并删除栈顶元素，失败则抛出异常 无 pollFirst() 获取并删除栈顶元素，失败则返回null peek() peekFirst() 获取但不删除栈顶元素，失败则抛出异常 无 peekFirst() 获取但不删除栈顶元素，失败则返回null 上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（false或null）。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。 ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。 从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。 上图中我们看到，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。 方法剖析addFirst()addFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[--head] = e即可。 实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。 12345678//addFirst(E e)public void addFirst(E e) &#123; if (e == null)//不允许放入null throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界 if (head == tail)//1.空间是否够用 doubleCapacity();//扩容&#125; 上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。 下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数（其实只可能是-1），则相当于对其取相对于elements.length的补码。 下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示： 图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。 12345678910111213141516//doubleCapacity()private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // head右边元素的个数 int newCapacity = n &lt;&lt; 1;//原空间的2倍 if (newCapacity &lt; 0) throw new IllegalStateException("Sorry, deque too big"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分 System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分 elements = (E[])a; head = 0; tail = n;&#125; addLast()addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。 1234567public void addLast(E e) &#123; if (e == null)//不允许放入null throw new NullPointerException(); elements[tail] = e;//赋值 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理 doubleCapacity();//扩容&#125; 下标越界处理方式addFirt()中已经讲过，不再赘述。 pollFirst()pollFirst()的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当elements[head] == null时，意味着容器为空。 12345678public E pollFirst() &#123; E result = elements[head]; if (result == null)//null值意味着deque为空 return null; elements[h] = null;//let GC work head = (head + 1) &amp; (elements.length - 1);//下标越界处理 return result;&#125; pollLast()pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。 123456789public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素 E result = elements[t]; if (result == null)//null值意味着deque为空 return null; elements[t] = null;//let GC work tail = t; return result;&#125; peekFirst()peekFirst()的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回elements[head]即可。 123public E peekFirst() &#123; return elements[head]; // elements[head] is null if deque empty&#125; peekLast()peekLast()的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。 123public E peekLast() &#123; return elements[(tail - 1) &amp; (elements.length - 1)];&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读二：LinkedList]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-5%2F</url>
    <content type="text"><![CDATA[总体介绍LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类（它是个接口名字）。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList（当作栈或队列使用时）更好的性能。 LinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，而将Queue和Stack以及Deque相关的知识放在下一节讲。双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。 1234567891011//Node内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。 方法剖析add()add()方法有两个版本，一个是add(E e)，该方法在LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。 结合上图，可以看出add(E e)的逻辑非常简单。123456789101112//add(E e)public boolean add(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode;//原来链表为空，这是插入的第一个元素 else l.next = newNode; size++; return true;&#125; add(int index, E element)的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。 123456789101112131415161718//add(int index, E element)public void add(int index, E element) &#123; checkPositionIndex(index);//index &gt;= 0 &amp;&amp; index &lt;= size; if (index == size)//插入位置是末尾，包括列表为空的情况 add(element); else&#123; Node&lt;E&gt; succ = node(index);//1.先根据index找到要插入的位置 //2.修改引用，完成插入操作。 final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null)//插入位置为0 first = newNode; else pred.next = newNode; size++; &#125;&#125; 上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。 remove()remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。 两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。 在寻找被删元素引用的时候remove(Object o)调用的是元素的equals方法，而remove(int index)使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个revome()方法都是通过unlink(Node&lt;E&gt; x)方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。 123456789101112131415161718192021//unlink(Node&lt;E&gt; x)，删除一个NodeE unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123;//删除的是第一个元素 first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123;//删除的是最后一个元素 last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null;//let GC work size--; return element;&#125; get()get(int index)得到指定下标处元素的引用，通过调用上文中提到的node(int index)方法实现。1234public E get(int index) &#123; checkElementIndex(index);//index &gt;= 0 &amp;&amp; index &lt; size; return node(index).item;&#125; set()set(int index, E element)方法将指定下标处的元素修改成指定值，也是先通过node(int index)找到对应下表元素的引用，然后修改Node中item的值。1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element;//替换新值 return oldVal;&#125; 参考： LinkedList 简介LinkedList 是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当作链表来操作外，它还可以当作栈，队列和双端队列来使用。 LinkedList 同样是非线程安全的，只在单线程下适合使用。 LinkedList 实现了 Serializable 接口，因此它支持序列化，能够通过序列化传输，实现了 Cloneable 接口，能被克隆。 LinkedList 源码剖析源码如下（加入了比较详细的注释） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637package java.util; public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() &#123; header.next = header.previous = header; &#125; // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; // 获取LinkedList的第一个元素 public E getFirst() &#123; if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; &#125; // 获取LinkedList的最后一个元素 public E getLast() &#123; if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; &#125; // 删除LinkedList的第一个元素 public E removeFirst() &#123; return remove(header.next); &#125; // 删除LinkedList的最后一个元素 public E removeLast() &#123; return remove(header.previous); &#125; // 将元素添加到LinkedList的起始位置 public void addFirst(E e) &#123; addBefore(e, header.next); &#125; // 将元素添加到LinkedList的结束位置 public void addLast(E e) &#123; addBefore(e, header); &#125; // 判断LinkedList是否包含元素(o) public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; // 返回LinkedList的大小 public int size() &#123; return size; &#125; // 将元素(E)添加到LinkedList中 public boolean add(E e) &#123; // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; &#125; // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) &#123; if (o==null) &#123; // 若o为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // 若o不为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) &#123; Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; &#125; successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; &#125; // 清空双向链表 public void clear() &#123; Entry&lt;E&gt; e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) &#123; Entry&lt;E&gt; next = e.next; e.next = e.previous = null; e.element = null; e = next; &#125; header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; &#125; // 返回LinkedList指定位置的元素 public E get(int index) &#123; return entry(index).element; &#125; // 设置index位置对应的节点的值为element public E set(int index, E element) &#123; Entry&lt;E&gt; e = entry(index); E oldVal = e.element; e.element = element; return oldVal; &#125; // 在index前添加节点，且节点的值为element public void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index))); &#125; // 删除index位置的节点 public E remove(int index) &#123; return remove(entry(index)); &#125; // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e; &#125; // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) &#123; int index = 0; if (o==null) &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (e.element==null) return index; index++; &#125; &#125; else &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) return index; index++; &#125; &#125; return -1; &#125; // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) &#123; int index = size; if (o==null) &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (e.element==null) return index; &#125; &#125; else &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (o.equals(e.element)) return index; &#125; &#125; return -1; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() &#123; if (size==0) return null; return getFirst(); &#125; // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() &#123; return getFirst(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() &#123; if (size==0) return null; return removeFirst(); &#125; // 将e添加双向链表末尾 public boolean offer(E e) &#123; return add(e); &#125; // 将e添加双向链表开头 public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; // 将e添加双向链表末尾 public boolean offerLast(E e) &#123; addLast(e); return true; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() &#123; if (size==0) return null; return getFirst(); &#125; // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() &#123; if (size==0) return null; return getLast(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() &#123; if (size==0) return null; return removeFirst(); &#125; // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() &#123; if (size==0) return null; return removeLast(); &#125; // 将e插入到双向链表开头 public void push(E e) &#123; addFirst(e); &#125; // 删除并返回第一个节点 public E pop() &#123; return removeFirst(); &#125; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) &#123; if (o==null) &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; // List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) &#123; // index的有效性处理 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; &#125; else &#123; next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; &#125; &#125; // 是否存在下一个元素 public boolean hasNext() &#123; // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; &#125; // 获取下一个元素 public E next() &#123; checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; &#125; // 是否存在上一个元素 public boolean hasPrevious() &#123; // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; &#125; // 获取上一个元素 public E previous() &#123; if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; &#125; // 获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; // 获取上一个元素的索引 public int previousIndex() &#123; return nextIndex-1; &#125; // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() &#123; checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try &#123; LinkedList.this.remove(lastReturned); &#125; catch (NoSuchElementException e) &#123; throw new IllegalStateException(); &#125; if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; &#125; // 设置当前节点为e public void set(E e) &#123; if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; &#125; // 将e添加到当前节点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; &#125; // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) &#123; if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; &#125; // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; // 反向迭代器实现类。 private class DescendingIterator implements Iterator &#123; final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() &#123; return itr.hasPrevious(); &#125; // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() &#123; return itr.previous(); &#125; // 删除当前节点 public void remove() &#123; itr.remove(); &#125; &#125; // 返回LinkedList的Object[]数组 public Object[] toArray() &#123; // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; &#125; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; &#125; // 克隆函数。返回LinkedList的克隆对象。 public Object clone() &#123; LinkedList&lt;E&gt; clone = null; // 克隆一个LinkedList克隆对象 try &#123; clone = (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; &#125; // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); &#125; // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); &#125; &#125; 总结关于 LinkedList 的源码，给出几点比较重要的总结： 1、从源码中很明显可以看出，LinkedList 的实现是基于双向循环链表的，且头结点中不存放数据。 2、注意两个不同的构造方法。无参构造方法直接建立一个仅包含 head 节点的空链表，包含 Collection 的构造方法，先调用无参构造方法建立一个空链表，然后将 Collection 中的数据加入到链表的尾部后面。 3、在查找和删除某元素时，源码中都划分为该元素为 null 和不为 null 两种情况来处理，LinkedList 中允许元素为 null。 4、LinkedList 是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。 5、注意源码中的 Entry entry(int index) 方法。该方法返回双向链表中指定位置处的节点，而链表中是没有下标索引的，要指定位置出的元素，就要遍历该链表，从源码的实现中，我们看到这里有一个加速动作。源码中先将 index 与长度 size 的一半比较，如果 index &lt; size/2，就只从位置 0 往后遍历到位置 index 处，而如果 index &gt; size/2，就只从位置 size 往前遍历到位置 index 处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。 6、注意链表类对应的数据结构 Entry。如下 123456789101112131415161718192021222324// 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; 7、LinkedList 是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。 8、要注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读一：ArrayList]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-4%2F</url>
    <content type="text"><![CDATA[简介ArrayList 中是平常比较常用的一个集合类，经常帮助我们封装一些实体 Bean 的 List 集合。典型使用场景如下： 1234List&lt;Book&gt; bookList=new ArrayList&lt;Book&gt;();bookList.add(book1);bookList.add(book2);... ArrayList 位于java.util 属于 Java 集合框架的一部分。层次关系如下。 java.util类 ArrayListjava.lang.Object—- 继承者 java.util.AbstractCollection—– 继承者 java.util.AbstractList—–继承者 java.util.ArrayList 总体介绍ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。 size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。 方法剖析set()既然底层是一个数组, ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。123456public E set(int index, E element) &#123; rangeCheck(index);//下标越界检查 E oldValue = elementData(index); elementData[index] = element;//赋值到指定位置，复制的仅仅是引用 return oldValue;&#125; get()get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。1234public E get(int index) &#123; rangeCheck(index); return (E) elementData[index];//注意类型转换&#125; add()跟C++ 的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。123456789private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//原来的1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制&#125; 由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。 空间的问题解决后，插入过程就显得非常简单。 add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。 addAll()addAll()方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的addAll(Collection&lt;? extends E&gt; c)方法，一个是从指定位置开始插入的addAll(int index, Collection&lt;? extends E&gt; c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。 remove()remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。12345678910public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; //清除该位置的引用，让GC起作用 return oldValue;&#125; 关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。 源码分析以下是 ArrayList 部分源码（基于 sun JDK 1.7.） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506package java.util;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始化容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 用于空实例使用的一个共享的初始化为空的数组。 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 用于保存具体元素的数组。 */ private transient Object[] elementData; /** * ArrayList的大小(包含的元素数量) */ private int size; /** * 根据指定容量大小，构造一个空的ArrayList * */ public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; /** * 构造空的list,默认容量为10 */ public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; /** *构造一个包含指定 collection 的元素的列表， * 这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; /** * 将此 ArrayList 实例的容量调整为列表的当前大小。应用程序可以使用此操作来最小化 ArrayList 实例的存储量。 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; /** 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** *可以分配的Array最大容量。 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 扩容方法 */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 返回list中的元素个数 * * */ public int size() &#123; return size; &#125; /** * 返回当前列表是否为空。 * */ public boolean isEmpty() &#123; return size == 0; &#125; /** 如果此列表中包含指定的元素，则返回 true。更确切地讲，当且仅当此列表包含至少一个满 足 (o==null ? e==null : o.equals(e)) 的元素 e 时，则返回 true。 */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。更确切地讲，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最低索引 i ，如果不存在此类索引，则返回 -1。 */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。更确切地讲，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最高索引 i，如果不存在此类索引，则返回 -1。 */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回ArrayList的浅拷贝。 * */ public Object clone() &#123; try &#123; @SuppressWarnings("unchecked") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; /** * 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的 * 运行时类型是指定数组的运行时类型。 * */ @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // 位置访问函数 @SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 获取list指定位置出的元素。 */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 用指定的元素替代此列表中指定位置上的元素。 */ public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; /** * 将指定的元素添加到此列表的尾部。 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * 将指定的元素插入此列表中的指定位置。向右移动当前位于该位置的元素（如果有）以及所有后续元素（将其索引加 1）。 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** *移除此列表中指定位置上的元素。向左移动所有后续元素（将其索引减 1）。 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; /** *移除此列表中首次出现的指定元素（如果存在）。如果列表不包含此元素，则列表不做改动。更确切地讲，移除满足 (o==null ? get(i)==null : o.equals(get(i))) 的最低索引的元素（如果存在此类元素）。如果列表中包含指定的元素，则返回 true（或者等同于这种情况：如果列表由于调用而发生更改，则返回 true）。 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /** * * 私有remove方法跳过边界检查并且不返回被移除的value. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 清空当前list. */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素 * 添加到此列表的尾部。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。 */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 边界检查 */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 用于add 和addAll操作的边界检查方法。 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 构造IndexOutOfBoundsException异常信息封装。 */ private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size; &#125; /** *找到ArrayLis中 与Collection的交集部分并从当前List中移除 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false); &#125; /** * 保留ArrayList 与Collection的交集，并将剩余部分移除 */ public boolean retainAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, true); &#125; /** * removeAll(Collection&lt;?&gt; c) retainAll(Collection&lt;?&gt; c)两个方法的具体实现 */ private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; /** * 将ArrayList实例的保存至流中，序列化。 */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 反序列化，从流中还原ArrayList实例。 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125;//省略其余部分...&#125; 为了便于理解，对源码进行了中文注释。ArrayList 直接继承于 AbstractList 类，这是一个抽象类，定义了一些基本操作。至少从源码中我们可以得到以下几点：1. ArrayList 内部使用数组来保存元素。2. ArrayList 实现了 RandomAccess, Cloneable, java.io.Serializable 三个标记接口，表示它自身支持快速随机访问，克隆，序列化。3. ArrayList 不具备并发访问特性，因为所有的方法没有加锁机制。4. 如果不指定容量大小，默认情况下，ArrayList 容量为 10, 在 JDk1.7 中 ArrayList 最大容量MAX_ARRAY_SIZE为 Integer.MAX_VALUE - 8.5. ArrayList 内部具备自动扩容机制，当容量不足时，会自动申请内存空间。 扩容实现方案ArrayList 具体的扩容最终会调用到grow方法。 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 具体扩容过程 首先得到数组的旧容量，然后进行oldCapacity + (oldCapacity &gt;&gt; 1)，将 oldCapacity 右移一位，其效果相当于 oldCapacity /2，我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的 1.5 倍，然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，接着，再检查新容量是否超出了 ArrayList 所定义的最大容量，若超出了，则调用 hugeCapacity() 来比较minCapacity和MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为 ArrayList 定义的最大容量，否则，新容量大小则为 minCapacity。 特别注意还有一点需要注意的是，扩容是创建一个新的数组，然后将旧数组上的数组 copy 到新数组，最终调用的是 System 类中的 native 方法。 12public static native void arraycopy(Object src, int srcPos,Object dest, int destPos,int length); 这是一个很大的消耗，所以在我们使用 ArrayList 时，最好能预计数据的大小，在第一次创建时就申请够内存。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antlr学习]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20%2F</url>
    <content type="text"><![CDATA[参考：《ANTLR 4权威指南》http://codemany.com/blog/archives/https://dohkoos.gitbooks.io/antlr4-short-course/content/getting-started.htmlhttp://blog.csdn.net/dc_726/article/details/45399371https://www.jianshu.com/p/1f5e72156075]]></content>
      <tags>
        <tag>antlr</tag>
        <tag>语法树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 笔记一]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-9%2F</url>
    <content type="text"><![CDATA[1.1 并发简史操作系统多进程出现的原因 资源利用率：一个程序等待某个外部操作的时候运行另一个程序 公平性：粗粒度的时间分片共享计算机资源 便利性：多个程序执行多个任务 促使进程出现的因素同样也促使着线程的出现 线程允许同一个进程中同时存在多条程序控制流。线程共享进程范围内的资源，例如内存句柄、文件句柄 每个线程有各自的程序计数器、栈以及局部变量 线程也称作轻量级进程 1.2 线程的优势1.2.1 发挥多处理的的强大能力操作系统调度单位是线程，如果一个程序只有一个线程，那么只能在一个处理器上运行 多线程程序可以再多个处理器上运行，如果设计正确，可以通过处理器资源利用率来提升系统的吞吐率 多线程有助于单处理器系统上获得更高的吞吐率 1.2.2 建模的简单性可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在单独的线程中运行，并在特定的同步位置进行交互 1.2.3 异步事件的简化处理1.2.4 响应更灵敏的用户界面1.3 线程带来的风险1.3.1 安全性问题永远不发生糟糕的事情 1.3.2 活跃性问题某件正确的事情最终会发生 1.3.3 性能问题1.4 线程无处不在Timer Servlet 和 JSP RMI Swing 和 AWT 参考：https://www.jianshu.com/p/bdbb55de64e4]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 准备]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-8%2F</url>
    <content type="text"><![CDATA[并发项目推荐 基础并发工具：Google Guava（ https://github.com/google/guava ） 并发技术应用：Zookeeper（ http://zookeeper.apache.org/ ） 并发技术应用：Alibaba Dubbo（ http://dubbo.io/ ） 延伸应用：Akka（ http://akka.io/ ） 实战练习 对一个业务工程师，使用并发技术的场景较少，但仍然是有一些使用场景的，例如： 一些异步执行系统，需要使用线程池来管理多个异步任务。 在一些消息中间件的业务处理端，从接收到消息到分发处理，往往需要线程池来管理。 在一些基础架构岗位上，并发技术使用较多，主要有： 微服务架构的通讯层（包括 I/O、数据序列化处理等）、业务处理层都需要并发技术。 消息中间件的消息调度、消息分级处理等，需要并发技术。 学习重点 ConcurrentHashMap AtomicInteger/AtomicLong ReentranLock ExecuteService 参考:https://github.com/neoremind/coddding/blob/master/codding/src/main/java/net/neoremind/mycode/concurrent/JAVA_CONCURRENCY_IN_PRACTICE_NOTES.mdhttp://zhouchaofei2010.iteye.com/category/346380https://my.oschina.net/indestiny/blog?search=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-7%2F</url>
    <content type="text"><![CDATA[以下内容来自《深入了解java虚拟机》的后几章 物理机如何处理并发问题？运算任务，除了需要处理器计算之外，还需要与内存交互，如读取运算数据、存储运算结果等（不能仅靠寄存器来解决）。计算机的存储设备和处理器的运算速度差了几个数量级，所以不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache），作为内存与处理器之间的缓冲：将运算需要的数据复制到缓存中，让运算快速运行。当运算结束后再从缓存同步回内存，这样处理器就无需等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓存，它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存时，可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时遵循缓存一致性协议。同时为了使得处理器充分被利用，处理器可能会对输出代码进行乱序执行优化。Java 虚拟机的即时编译器也有类似的指令重排序优化。 Java 内存模型什么是 Java 内存模型？Java 虚拟机的规范，用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各个平台下都能达到一致的并发效果。 Java 内存模型的目标？定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。此处的变量包括实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是线程私有的，不会被共享，所以不存在竞争问题。 主内存与工作内存所以的变量都存储在主内存，每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存。 内存间的交互操作一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存，Java 内存模型定义了 8 种操作： 原子性、可见性、有序性 原子性：对基本数据类型的访问和读写是具备原子性的。对于更大范围的原子性保证，可以使用字节码指令 monitorenter 和 monitorexit 来隐式使用 lock 和 unlock 操作。这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字。因此 synchronized 块之间的操作也具有原子性。 可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取之前从主内存刷新变量值来实现可见性的。volatile 的特殊规则保证了新值能够立即同步到主内存，每次使用前立即从主内存刷新。synchronized 和 final 也能实现可见性。final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么其他线程中就能看见 final 字段的值。 有序性：Java 程序的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）；如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序和工作内存与主内存同步延迟线性）。 volatile什么是 volatile？关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。当一个变量被定义成 volatile 之后，具备两种特性： 保证此变量对所有线程的可见性。当一条线程修改了这个变量的值，新值对于其他线程是可以立即得知的。而普通变量做不到这一点。 禁止指令重排序优化。普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。 为什么基于 volatile 变量的运算在并发下不一定是安全的？volatile 变量在各个线程的工作内存，不存在一致性问题（各个线程的工作内存中 volatile 变量，每次使用前都要刷新到主内存）。但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。 为什么使用 volatile？在某些情况下，volatile 同步机制的性能要优于锁（synchronized 关键字），但是由于虚拟机对锁实行的许多消除和优化，所以并不是很快。 volatile 变量读操作的性能消耗与普通变量几乎没有差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 并发与线程并发与线程的关系？并发不一定要依赖多线程，PHP 中有多进程并发。但是 Java 里面的并发是多线程的。 什么是线程？线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O），又可以独立调度（线程是 CPU 调度的最基本单位）。 实现线程有哪些方式？ 使用内核线程实现 使用用户线程实现 使用用户线程 + 轻量级进程混合实现 Java 线程的实现操作系统支持怎样的线程模型，在很大程度上就决定了 Java 虚拟机的线程是怎样映射的。 Java 线程调度什么是线程调度？线程调度是系统为线程分配处理器使用权的过程。 线程调度有哪些方法？ 协同式线程调度：实现简单，没有线程同步的问题。但是线程执行时间不可控，容易系统崩溃。 抢占式线程调度：每个线程由系统来分配执行时间，不会有线程导致整个进程阻塞的问题。 虽然 Java 线程调度是系统自动完成的，但是我们可以建议系统给某些线程多分配点时间——设置线程优先级。Java 语言有 10 个级别的线程优先级，优先级越高的线程，越容易被系统选择执行。 但是并不能完全依靠线程优先级。因为 Java 的线程是被映射到系统的原生线程上，所以线程调度最终还是由操作系统说了算。如 Windows 中只有 7 种优先级，所以 Java 不得不出现几个优先级相同的情况。同时优先级可能会被系统自行改变。Windows 系统中存在一个 “优先级推进器”，当系统发现一个线程执行特别勤奋，可能会越过线程优先级为它分配执行时间。 线程安全的定义？当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。 Java 语言操作的共享数据，包括哪些？ 不可变 绝对线程安全 相对线程安全 线程兼容 线程对立 不可变在 Java 语言里，不可变的对象一定是线程安全的，只要一个不可变的对象被正确构建出来，那其外部的可见状态永远也不会改变，永远也不会在多个线程中处于不一致的状态。 如何实现线程安全？虚拟机提供了同步和锁机制。 阻塞同步（互斥同步） 非阻塞同步 阻塞同步（互斥同步）互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。Java 中最基本的同步手段就是 synchronized 关键字，其编译后会在同步块的前后分别形成 monitorenter 和 monitorexit 两个字节码指令。这两个字节码都需要一个 Reference 类型的参数指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那么这个对象就是 Reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去获取对应的对象实例或 Class 对象作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。 如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器 + 1；当执行 monitorexit 指令时将锁计数器 - 1。当计数器为 0 时，锁就被释放了。 如果获取对象失败了，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。 除了 synchronized 之外，还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步。ReentrantLock 比 synchronized 增加了高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，对处理执行时间非常长的同步块很有用。 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的。 非阻塞同步互斥同步最大的问题，就是进行线程阻塞和唤醒所带来的性能问题，是一种悲观的并发策略。总是认为只要不去做正确的同步措施（加锁），那就肯定会出问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。 锁优化是在 JDK 的那个版本？JDK1.6 的一个重要主题，就是高效并发。HotSpot 虚拟机开发团队在这个版本上，实现了各种锁优化： 适应性自旋 锁消除 锁粗化 轻量级锁 偏向锁 为什么要提出自旋锁？互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来很大压力。同时很多应用共享数据的锁定状态，只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。先不挂起线程，等一会儿。 自旋锁的原理？如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，让后面请求锁的线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放。为了让线程等待，我们只需让线程执行一个忙循环（自旋）。 自旋的缺点？自旋等待本身虽然避免了线程切换的开销，但它要占用处理器时间。所以如果锁被占用的时间很短，自旋等待的效果就非常好；如果时间很长，那么自旋的线程只会白白消耗处理器的资源。所以自旋等待的时间要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，那就应该使用传统的方式挂起线程了。 什么是自适应自旋？自旋的时间不固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果一个锁对象，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行，那么虚拟机认为这次自旋仍然可能成功，进而运行自旋等待更长的时间。 如果对于某个锁，自旋很少成功，那在以后要获取这个锁，可能省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机也会越来越聪明。 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。 程序员怎么会在明知道不存在数据竞争的情况下使用同步呢？很多不是程序员自己加入的。 锁粗化原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。 锁粗化就是增大锁的作用域。 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 偏向锁消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。即在无竞争的情况下，把整个同步都消除掉。这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。 以下内容来自《java核心技术 卷一 第14章》 第十四章：并发Thread：static Thread currentThread() 获取当前线程static void sleep(long millis) 休眠指定的毫秒数 (当前线程)static void yield() 导致当前线程处于让步状态 (当前线程)static boolean interrupted() 检测线程中断状态并置位为 false(当前线程)boolean isInterrupted() 只检测线程中断状态void interrupt() 向线程发送请求，请求中断线程void join() 等待终止指定的线程 (其他线程调用)Thread.State getState() 得到线程状态 (6 种)void setPriority(int newPriority) 设置线程优先级 MIN_PRIORITY=1/NORM_PRIORITY=5/MAX_PRIORITY=10void setDaemon(boolean isDaemon) 设置线程为守护线程，必须在线程启动之前调用 Object：void wait() 导致线程进入等待状态直到它被通知void nitify() 随机选择一个在该对象上调用 wait 方法的线程，解除其阻塞状态vodi notifyAll() 解除那些在该对象上调用 wait 方法的线程的阻塞状态 多线程： 几个概念：• 多任务系统：操作系统将 CPU 时间片分配给每一个进程，给人以并行处理的感觉。但是并发进程数并不是由 CPU 数目制约的。• 多线程程序：一个程序 (进程) 可以同时执行多个任务，同时运行一个以上的线程。• 进程与线程：每个进程拥有自己的一套变量，而每个线程共享数据。一个进程相当于一个应用程序，一个进程中可以包含多个线程，其中有一个主线程，其余都是工作线程，线程更轻量级。 不要直接调用 Thread 或 Runnable 的run()方法，它只会执行一个线程中的任务 (当前线程)，而不会启动一个新线程，要使用thread.start()来开启 (Runnable 就是包装业务逻辑的类，在指定的时间和线程中执行某段代码)。 没有什么强制终止线程的方法，interrupt()用来请求终止线程；如果线程被阻塞 (调用 sleep 或 wait 方法)，interrupt()将抛出异常；如果在中断状态被置位时调用sleep()不会引起休眠且会清除中断状态并抛异常，因此中断置位后就别进行其他操作了；中断请求只是先标记一个状态，被中断的线程可以决定如何响应中断。 静态方法interrupted()检测当前线程是否中断且清除中断状态；实例方法isInterrupt()检测是否被中断且不改变中断状态；实例方法interrupt()请求中断。 线程的 6 种状态：New(新创建)、Runnable(可运行)、Blocked(被阻塞)、Waiting(等待)、Timed waiting(计时等待)、Terminated(被终止)。 调用start()后线程进入可执行状态，不一定是立即执行，取决于操作系统给线程提供运行的时间。这里安卓的Handler.post()是等本方法体执行完，才有可能执行 runnable 里的逻辑，而线程的start()方法后 runnable 里的执行逻辑和本方法体里的下一行不一定谁先执行呢。 两种操作系统调度方式：• 抢占式调度：系统给每一个可运行线程分配时间片来执行任务，当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。• 协作式调度：一个线程只有在调用 yield 方法、被阻塞或等待时，线程才会失去控制权。 几种状态的区别：• 阻塞状态：一个线程试图获取一个对象的内部对象锁，而该锁被其他线程所持有，则该线程进入阻塞状态，当其他线程释放该锁，且线程调度器允许本线程持有它的时候，该线程变为非阻塞状态 (正常竞争对象锁)，相当于自动解锁。• 等待状态：可理解为阻塞的一种，当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。如调用 Object.wait()、thread.join()、Lock 或 Condition 时出现 (手动阻塞，必须被其他线程主动唤醒，可能出现死锁)。• 计时等待：等待状态一直保持到超时期满或者接收到适当的通知。如调用 Thread.sleep()、Object.wait()、thread.join()、Lock.tryLock() 或 Condition.await() 时出现。 每个线程有一个优先级，默认继承父线程优先级，范围为 MIN_PRIORITY(1)~MAX_PRIORITY(10) 之间，NORM_PRIORITY 为 5。当线程调度器有机会选择新线程时，它会优先选择优先级较高的线程，但是这个过程是高度依赖于操作系统的。 守护线程：调用thread.setDaemon(true)将线程转换为守护线程，唯一用途是为其他线程服务，当只剩下守护线程时，虚拟机就退出了。守护线程应该永远不去访问固有资源、文件等，因为它会在任何时候发生中断。 线程的run()方法不能抛出任何受查异常，但是，非受查异常会导致线程终止。这时候可以用setUncaughtExceptionHandler(实例方法) 来为任何一个线程安装一个处理器。也可以用Thread.setDefaultUncaughtExceptionHandler(静态方法) 来为所有线程安装一个默认的处理器。默认处理器默认为 null，实例处理器默认为线程的 ThreadGroup 对象。ThreadGruop 内部其实还是优先使用父处理器 -&gt; 默认处理器等来处理的，如果都没就 System.err 输出日志并崩溃退出。 同步： 同步的作用就是要保证一组操作的原子性。如线程安全队列保证了对该队列操作的线程安全 (队列的内部锁)，但是外部调用时如果有判断逻辑，就要保证判断逻辑上下的原子性 (外部调用者的对象锁)，最好每次使用都判下空，其实也没有绝对的线程安全。 锁对象 Lock： Java 提供了synchronized关键字和 Java SE5 中引入的ReentrantLock类来解决线程同步问题，将某一段代码控制为原子性操作。 一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句，但其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。把解锁操作放在finally语句中很重要，如果代码抛出异常，锁必须被释放 (注意异常退出的话要回滚避免对象损坏)。如果使用锁，就不能使用带资源的 try 语句。 注意例子中每个对象有自己的ReentrantLock锁对象，如果两个线程试图访问同一个对象，那么锁以串行的方式提供服务。访问不同的对象，则不会发生阻塞。 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数器来跟踪 lock 方法的嵌套调用。线程在每一次调用lock()后都要调用unlock()来释放锁。被一个锁保护的代码可以调用另一个使用相同的锁的方法。注意异常时要先回滚，否则对象可能处于一种受损状态。 条件对象 Condition： 数据结构本身是安全的话 (如例子中的 Bank 类的 transfer 方法)，在外部调用如果有判断逻辑还是可能会不安全 (如上面所讲锁对象已经不是一个层级的了)，这时要么在外部使用加锁控制判断逻辑，要么在内部 transfer 方法添加条件锁判断逻辑。 条件对象：一个锁可以有一个或多个相关的条件对象。等待获得锁的线程和调用了 await 方法的线程本质上不同。一旦一个线程调用await()，它进入该条件的等待集，当锁可用时，该线程不是马上解除阻塞，而是等待直到另一线程调用同一条件上的signalAll()方法为止 (阻塞是得到锁自己就唤醒，等待是必须由其他线程来唤醒 (相互 await 死锁现象，死锁发生的原因是有超出条件限制的操作导致可能同时双方都不满足条件而相互等待))。 signalAll()不会立即激活一个等待线程，它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对象的访问。signal()注意是 “随机” 解除一个线程的阻塞。仅可在该条件上调用await()、singal()或singalAll()。被激活的线程从之前await()的方法出继续执行。 Synchronized 关键字： Java 中的每一个对象都有一个内部锁，如果方法用synchronized声明，那么对象锁将保护整个方法。内部对象锁只有一个相关条件，wait()方法添加一个线程到等待集中，notify()/nitifyAll()方法解除等待线程的阻塞状态。这三个方法必须在synchronized代码块中，也就是必须先拿到锁才能等待 (condition 也是先 lock() 后才能 await()等)。缺陷：不能中断一个正在获得锁的线程、锁不能设置超时、条件是单一的。 实例方法上加synchronized关键字锁的是该实例的这个和所有同步实例方法，通过获取该对象的内部锁来实现；静态方法上加synchronized关键字锁的是同一个类的这个或任何其它的同步静态方法，通过获取该类对象的内部锁实现。 实现同步的两种方式：①在方法上添加synchronized关键字来实现同步 (使用自己的内部对象锁)。②通过synchronized(obj)进入一个同步阻塞。(使用一个其他 Obj 的对象锁，道理其实是一样的，都是拿到对象的内部锁来 lock) 注意条件对象有await()、singal()、singalAll()方法；对象是wait()、notify()、notifyAll()方法。对象的几个方法内也是获取内部锁对象进行同步的，要放到synchronized代码块中，先lock()获取锁才能wait()等操作。 volatile 关键字：• 为实例域的同步访问提供一种免锁机制，更轻量级，如果声明一个域为volatile，那么编译器和虚拟机就知道该域可能被另一个线程并发更新。• 作用：禁止指令重排序 (操作系统可以对指令集重排序的(分配内存 -&gt; 初始化对象 -&gt;赋值空间地址给引用)；实现可见性(针对变量)；保证有序性(long、double 等类型)。• 注意：volatile 保证可见性、有序性，不保证原子性，因为有序、可见是针对域的锁定，原子性是一系列操作，已经不是同一级别的锁了，可以在原子操作外部加锁，也可使用 CAS(轻量级的判断 / 再赋值锁)。 线程安全方法 有时候要避免共享变量，使用 ThreadLocal 辅助类可以为各个线程构造单独的实例。ThreadLocal 提供了set()和get()访问器用来访问与当前线程相关联的线程局部变量；ThreadLocal 中有个内部类 ThreadLocalMap，key 为 ThreadLocal，value 为变量 T；每个线程有个变量threadLocals(即 ThreadLocalMap)，在调用set()方法时会取到线程当前这个 map 是否为空，空的话就createMap()，否则就将 key 设为 ThreadLocal，value 设为原共享变量 T 的副本存进去，因此每个线程可以放多个 ThreadLocal 包装过的变量，这些变量线程间独享。 lock()方法获取锁会阻塞；tryLock()方法试图申请一个锁，在成功获得锁后返回 true，否则立即返回 false。lock()方法不能被中断，如果出现死锁lock()就无法终止；带超时的tryLock()方法被中断会抛异常，允许程序打破死锁。 读写锁ReentrantReadWriteLock的readLock()得到一个允许多线程读，排斥写的锁，或者writeLock()得到一个排斥其他读写操作的锁。 线程的stop()方法会立即终止所有未结束的方法，包括run()方法，因此有可能导致对象状态损坏，因此被弃用了。应当在合适的时候中断线程，线程会在安全的时候停止。 阻塞队列 对多线程问题，可以用一个或多个队列以安全的方式将其形式化，生产者向线程队列中插入元素，消费者从中取出它们；可以将例子中的转账指令插入某一队列，而另一个线程从队列中取指令执行，不直接操作 bank 对象，队列自己控制好线程安全即可，对 bank 对象进行操作 (单线程执行，类似 Handler，避免显示控制同步)。 当队列为空或者已满时，阻塞队列将导致操作的线程阻塞：add()/remove()/element()方法会抛异常、offer()/poll()/peek()方法不阻塞也不会抛异常、take()/put()方法会导致阻塞。 阻塞队列的几种类型：• ArrayBlockingQueue(带有指定容量的循环数组阻塞队列)• LinkedBlockingQueue(无上限链表阻塞队列)• PriorityBlockingQueue(无边界的优先堆阻塞队列)• DelayQueue(无边界的阻塞时间有限的阻塞队列) 几种线程安全的集合：• ConcurrenHashMap• ConcurrentSkipListMap• ConcurrentSkipListSet• ConcurrentLinkedQueue集合返回弱一致性的迭代器，不一定能反映出他们被构造之后的所有修改。 并发集视图：ConcurrentHashMap.&lt;T&gt;newKeySet()。写数组拷贝：CopyOnWriteArrayList、CopyOnWriteArraySet，并发读，写的时候生成一个副本，占用双倍内存。 任何集合类都可以使用同步包装器变为线程安全的：Collections.synchronizedList(new ArrayList&lt;E&gt;())、Collections.synchronizedMap(new HashMap&lt;K,V&gt;())。 线程池 Runnable 封装一个无返回值的异步任务，可用在线程或线程池中；Callable 封装一个有返回值的异步任务，只能放在线程池中。 Future 保存并管理异步计算的结果；FutureTask 实现了 Ruannable 和 Future 两个接口，可把自己提交给线程池，完了从自己拿处理结果。 如果程序中创建了大量生命周期很短的线程，或为了减少并发线程的数目，就应该使用线程池。 四种常用线程池：• CachedThreadPool(核心 = 0，最大 = MAX，0 长度阻塞队列，空线程保持 60s，适用于较多异步任务)• FixedThreadPool(核心 = 最大 = 固定数，MAX 长度阻塞队列，适用快速执行任务)• SingleThreadPool(核心 = 固定 = 1，顺序执行任务)• ScheduledThreadPool(延迟执行或延迟后周期执行的线程池)。 submit()方法提交任务，得到一个 Future 对象用于管理结果；shutdown()方法启动线程池关闭序列，被关闭的线程池不再接受新任务，所有任务执行完后线程池死亡；shotdownNow()方法取消尚未开始的所有任务并试图中断正在执行的线程。 同步器 几种常用同步器：• 信号量 Semaphore：一个信号量管理许多的许可证，为了通过信号量，线程通过调用acquire()方法请求许可，否则等待，信号量其实仅维护一个计数，因此用于控制同一时刻的线程数量。任何线程都可以通过release()释放任意数目的许可。• 倒计时门栓 CountDownLatch：让一个线程集等待直到计数器变为 0，用于暂停某个线程等待其他线程执行完必备操作后继续执行。它是一次性的，一旦计数器变为 0，就不能再重用了。• 循环栅栏 CyclicBarrier：允许线程集到达一个公共栅栏 (等待到指定数目) 后执行某段逻辑，然后各自再继续执行(先到达的先 await)。如果任何一个在栅栏上等待的线程离开了栅栏，栅栏就被破坏了，如等待线程的 await 方法超时或者被中断了，这时其他线程的 await 方法会抛异常，那些已经等待的线程会立即终止 await 的调用。 同步队列：将生产者和消费者线程配对的机制。当一个线程调用 SynchronousQueue 的put()方法时，它会阻塞直到另一个线程调用take()方法为止，反之亦然。数据仅沿一个方向传递，从生产者到消费者。它不是一个队列，没有包含任何元素，size()方法总是返回 0。重点：都很重要 补充知识点 Java 内存分配：①运行时数据区域：方法区、堆区、栈区 (虚拟机栈、本地方法栈)、程序计数器。前两者是线程共享区、后面的是线程隔离区。②各部分作用：• 程序计数器：当前线程所执行的字节码的行号指示器，这个计数器记录的是在正在执行的虚拟机字节码指令的地址，当执行的是 Native 方法，这个计数器值为空。此内存区域是唯一一个没有规定任何 OutOfMemoryError 情况的区域 。• Java 虚拟机栈：线程私有的 ，它的生命周期与线程相同。存储方法执行时的局部变量表、操作数栈、方法出口等，含有基本数据类型、引用类型的空间地址。如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。• 本地方法栈：与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。• Java 堆：所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例 ，是垃圾收集器管理的主要区域，由 GC 管理内存的回收，有一套自己的回收机制。如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出 OutOfMemoryError 异常。• 方法区：又称静态存储区，各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 ，运行时常量也是其中一部分。垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需要时，将抛出 OutOfMemoryError 异常。③对象的创建过程：创建一个对象通常是需要 new 关键字，当虚拟机遇到一条 new 指令时，首先检查这个指令的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有那么执行相应的类加载过程。类加载检查通过后，虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。Java 程序通过栈上的 reference 数据来操作堆上的具体对象。主要的访问方式有使用句柄和直接指针两种：句柄就是引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 ；直接指针指引用中存储的就是对象地址 。 ClassLoader• ClassLoader 的具体作用就是将 class 文件加载到 jvm 虚拟机中去，程序就可以正确运行了。但是，jvm 启动的时候，并不会一次性加载所有的 class 文件，而是根据需要去动态加载。• class 文件是字节码格式文件，java 虚拟机并不能直接识别我们平常编写的. java 源文件，所以需要 javac 这个命令转换成. class 文件。其他语言编写的代码只要能编译成. class 文件都可以被 java 虚拟机运行。• 三种 ClassLoader：①BootstrapClassLoader：最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib 下的 rt.jar、resources.jar、charsets.jar 和 class 等。②ExtClassLoader：扩展的类加载器，加载目录 %JRE_HOME%\lib\ext 目录下的 jar 包和 class 文件。③AppClassLoader：也称为 SystemAppClass 加载当前应用的 classpath 的所有类。• 加载顺序：BootstrapClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader。• ExtClassLoader 和 AppClassLoader 都是 UrlClassLoader 的子类。每个类加载器都有一个父加载器，AppClassLoader 的父加载器是 ExtClassLoader，ExtClassLoader 的父加载器是 null。一个 ClassLoader 创建时可以直接指定 parent，如果没有指定 parent，那么它的 parent 默认就是Launcher.getClassLoader()，即 AppClassLoader。• Bootstrap ClassLoader 是由 C/C++ 编写的，它本身是虚拟机的一部分，所以它并不是一个 JAVA 类，也就是无法在 java 代码中获取它的引用。• 双亲委托机制：一个类加载器查找 class 和 resource 时，是通过 “委托模式” 进行的，它首先判断这个 class 是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到 Bootstrap ClassLoader，如果 Bootstrap Classloader 找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象，再找不到就抛异常了。虽然 ExtClassLoader 的 parent 为 null，但是在找类时如果 parent 为 null 就调用findBootstrapClassOrNull(name)Bootstrap ClassLoader 去找。• 自定义 ClassLoader 可以根据自定义路径去加载 class 文件，从而将外部类加载进来并使用。一般复写findClass()方法和在findClass()方法中调用defineClass()方法。可以根据自己的规定来进行类加密解密操作，并自定义类加载器来解析类。]]></content>
      <tags>
        <tag>并发</tag>
        <tag>待阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 的类之间的关系及UML表示：继承、依赖、关联、实现、聚合、组合]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-20-2%2F</url>
    <content type="text"><![CDATA[UML基础类： 矩形框代表一个类 (如图 - 1), 类图分为三层，第一层为类的名称，如果是抽象类类名用斜体字表示，如图中动物类所示。第二层是类的特性(通常就是类的字段和属性)。第三层为类的操作（通常就是方法或行为）。注意前面的符号，“+” 表示 public，“-”表示 private,“#”表示 protected. （图 - 1） 动物类是一抽象类，它是不能被实例化的，而猪类可以被实例化。 接口： 接口有两种表示方法：矩形表示法（如图 - 2 中的飞翔的接口）和棒棒糖表示法 (如图 - 2 中唐老鸭类中实现讲人话的接口)。矩形表示法，顶端有&lt;&lt;接口&gt;&gt; 或者&lt;&gt;，第一行：接口名称，第二行：接口方法。棒棒糖表示法，圆圈旁为接口名称，接口方法在实现类中出现，如唐老鸭类中的讲话。 （图 - 2） 泛化（继承）：• 泛化关系 (Generalization) 也就是继承关系，也称为 “is-a-kind-of” 关系，泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在 UML 中，泛化关系用带空心三角形的直线来表示。• 在代码实现时，使用面向对象的继承机制来实现泛化关系，如在 Java 语言中使用 extends 关键字、在 C++/C# 中使用冒号 “：” 来实现。泛化对应 Java 中继承关系，即子类继承父类中出 private 修饰外的所有东西（变量、方法等）。示例代码： 1234public class Animal &#123;&#125;public class Tiger extends Animal &#123;&#125; 在 UML 当中，对泛化关系有三个要求：1、子类与父类应该完全一致，父类所具有的属性、操作，子类应该都有； 2、子类中除了与父类一致的信息以外，还包括额外的信息； 3、可以使用父类的实例的地方，也可以使用子类的实例； 依赖：• 依赖关系 (Dependency) 是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。• 在 UML 中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 123456public class Screwdriver &#123; //螺丝刀，作为人类的工具，是用来被人类使用的&#125;public class Person&#123; public void screw(Screwdriver src)&#123; //拧螺丝，需使用螺丝刀&#125;&#125; 依赖关系有如下三种情况：1、A 类是 B 类中的（某中方法的）局部变量； 2、A 类是 B 类方法当中的一个参数； 3、A 类向 B 类发送消息，从而影响 B 类发生变化； 关联（Association）：是一种结构关系，说明一个事物的对象与另一个事物的对象相联系。给定有关联的两个类，可以从一个类的对象得到另一个类的对象。关联有两元关系和多元关系。两元关系是指一种一对一的关系，多元关系是一对多或多对一的关系。两个类之间的简单关联表示了两个同等地位类之间的结构关系。当你想要表示结构化关系时使用关联。• 关联关系 (Association) 是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。• 在 UML 类图中，用实线连接有关联的对象所对应的类，在使用 Java、C# 和 C++ 等编程语言实现关联关系时，通常将一个类的对象作为另一个类的属性。• 在使用类图表示关联关系时可以在关联线上标注角色名。 分为几种情况：双向关联12345678910public class Customer &#123; private Product[] products; …… &#125; public class Product &#123; private Customer customer; …… &#125; 单向关联12345678910public class Customer &#123; private Address address; …… &#125; public class Address &#123; …… &#125; 自关联12345public class Node &#123; private Node subNode; …… &#125; 聚合关系（Aggregation）• 聚合关系 (Aggregation) 表示一个整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。• 在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在 UML 中，聚合关系用带空心菱形的直线表示。 12345public class Student&#123;&#125;public class School&#123; private List&lt;Student&gt; students ; //学校与学生是聚合关系&#125; 例子： 组合关系（Composition）组合关系 (Composition) 也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之 间具有同生共死的关系。• 在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。在 UML 中，组合关系用带实心菱形的直线表示。 12345public class Menu&#123;&#125;public class Window&#123; private List&lt;Menu&gt; menus ;&#125; 菜单的存在前提是窗口的存在，两者之间存在很强的拥有关系。且窗口对菜单的生命周期负责，只有在窗口创建之后，菜单才能够创建，菜单必须在窗口销毁之前销毁。因此 Window 与 Menu 之间是组合关系。 实现关系（Implementation)• 接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系 (Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所 声明的操作。在 UML 中，类与接口之间的实现关系用带空心三角形的虚线来表示。 123456789101112131415161718public interface Vehicle &#123; public void move(); &#125; public class Ship implements Vehicle &#123; public void move() &#123; …… &#125; &#125; public class Car implements Vehicle &#123; public void move() &#123; …… &#125; &#125; 总结：关于关联，聚合，组合在实现上并没有显著区别，相区别他们只有通过判断关系双方之间的实际关系，如关系强弱、创建与销毁之间有无必要关联等。它们的强弱关系是没有异议的：依赖 &lt; 关联 &lt; 聚合 &lt; 组合 &lt; 泛化（继承） 实现方式区别：1) 依赖关系：关系对象出现在局部变量或者方法的参数里，或者关系类的静态方法被调用(2) 关联关系：关系对象出现在实例变量中(3) 聚合关系: 关系对象出现在实例变量中(4) 组合关系：关系对象出现在实例变量中(5) 泛化（继承）: extends(6) 实现： implements 参考：http://blog.csdn.net/lpjishu/article/details/51491779]]></content>
      <tags>
        <tag>Java</tag>
        <tag>类关系</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读：集合框架概述]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-18-3%2F</url>
    <content type="text"><![CDATA[学习:《算法 第四版》 关于 Java 集合框架，我们首先应该把握住几个核心的接口，请看下图： 我们还要了解到这些接口描述了一组什么样的机制，然后以此作为出发点，去了解具体哪些类实现了哪些机制。像这样自顶向下的学习，我们很快就能掌握常见集合类的用法。对于一些我们平常经常使用的类，我们还可以阅读一下它的源码，了解它的实现细节，这样我们以后使用起来会更加得心应手。不过阅读一些集合类（比如 TreeMap、HashMap）的源码需要我们具备一定的数据结构与算法的基础知识，这方面推荐阅读 算法（第 4 版） (豆瓣)。 集合框架介绍 Java 集合工具包位于 Java.util 包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习 Java 集合框架下大致可以分为如下五个部分：List 列表、Set 集合、Map 映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。 Java 集合类的整体框架如下： 从上图中可以看出，集合类主要分为两大类：Collection 和 Map。 Collection 是 List、Set 等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List 和 Set。 List 接口 List 接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为 ArrayList 和 LinkedList，另外还有不常用的 Vector。另外，LinkedList 还是实现了 Queue 接口，因此也可以作为队列使用。 Set 接口 Set 接口通常表示一个集合，其中的元素不允许重复（通过 hashcode 和 equals 函数保证），常用实现类有 HashSet 和 TreeSet，HashSet 是通过 Map 中的 HashMap 实现的，而 TreeSet 是通过 Map 中的 TreeMap 实现的。另外，TreeSet 还实现了 SortedSet 接口，因此是有序的集合（集合中的元素要实现 Comparable 接口，并覆写 Compartor 函数才行）。 我们看到，抽象类 AbstractCollection、AbstractList 和 AbstractSet 分别实现了 Collection、List 和 Set 接口，这就是在 Java 集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。 Map 接口 Map 是一个映射接口，其中的每个元素都是一个 key-value 键值对，同样抽象类 AbstractMap 通过适配器模式实现了 Map 接口中的大部分函数，TreeMap、HashMap、WeakHashMap 等实现类都通过继承 AbstractMap 来实现，另外，不常用的 HashTable 直接实现了 Map 接口，它和 Vector 都是 JDK1.0 就引入的集合类。 Iterator 迭代器 Iterator 是遍历集合的迭代器（不能遍历 Map，只用来遍历 Collection），Collection 的实现类都实现了 iterator() 函数，它返回一个 Iterator 对象，用来遍历集合，ListIterator 则专门用来遍历 List。而 Enumeration 则是 JDK1.0 时引入的，作用与 Iterator 相同，但它的功能比 Iterator 要少，它只能在 Hashtable、Vector 和 Stack 中使用。 工具类 Arrays 和 Collections 是用来操作数组、集合的两个工具类，例如在 ArrayList 和 Vector 中大量调用了 Arrays.Copyof() 方法，而 Collections 中有很多静态方法可以返回各集合类的 synchronized 版本，即线程安全的版本，当然了，如果要用线程安全的集合类，首选 Concurrent 并发包下的对应的集合类。 参考专栏：http://blog.csdn.net/column/details/12706.htmlhttps://crowhawk.github.io/tags/#Java%E5%9F%BA%E7%A1%80https://www.jianshu.com/p/b9d8814c3654]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读零：集合框架概述]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-20-1%2F</url>
    <content type="text"><![CDATA[集合框架介绍 Java 集合工具包位于 Java.util 包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习 Java 集合框架下大致可以分为如下五个部分：List 列表、Set 集合、Map 映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。 Java 集合类的整体框架如下： 从上图中可以看出，集合类主要分为两大类：Collection 和 Map。 Collection 是 List、Set 等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List 和 Set。 List 接口 List 接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为 ArrayList 和 LinkedList，另外还有不常用的 Vector。另外，LinkedList 还是实现了 Queue 接口，因此也可以作为队列使用。 Set 接口 Set 接口通常表示一个集合，其中的元素不允许重复（通过 hashcode 和 equals 函数保证），常用实现类有 HashSet 和 TreeSet，HashSet 是通过 Map 中的 HashMap 实现的，而 TreeSet 是通过 Map 中的 TreeMap 实现的。另外，TreeSet 还实现了 SortedSet 接口，因此是有序的集合（集合中的元素要实现 Comparable 接口，并覆写 Compartor 函数才行）。 我们看到，抽象类 AbstractCollection、AbstractList 和 AbstractSet 分别实现了 Collection、List 和 Set 接口，这就是在 Java 集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。 Map 接口 Map 是一个映射接口，其中的每个元素都是一个 key-value 键值对，同样抽象类 AbstractMap 通过适配器模式实现了 Map 接口中的大部分函数，TreeMap、HashMap、WeakHashMap 等实现类都通过继承 AbstractMap 来实现，另外，不常用的 HashTable 直接实现了 Map 接口，它和 Vector 都是 JDK1.0 就引入的集合类。 Iterator 迭代器 Iterator 是遍历集合的迭代器（不能遍历 Map，只用来遍历 Collection），Collection 的实现类都实现了 iterator() 函数，它返回一个 Iterator 对象，用来遍历集合，ListIterator 则专门用来遍历 List。而 Enumeration 则是 JDK1.0 时引入的，作用与 Iterator 相同，但它的功能比 Iterator 要少，它只能再 Hashtable、Vector 和 Stack 中使用。 工具类 Arrays 和 Collections 是用来操作数组、集合的两个工具类，例如在 ArrayList 和 Vector 中大量调用了 Arrays.Copyof() 方法，而 Collections 中有很多静态方法可以返回各集合类的 synchronized 版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选 Concurrent 并发包下的对应的集合类。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客加密文章测试]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-6%2F</url>
    <content type="text"><![CDATA[「密码不能告诉你」 Decrypt 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]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog无法输入双括号的解决方法]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-4%2F</url>
    <content type="text"><![CDATA[1&#123;% raw %&#125;&#123;&#123;message&#125;&#125;&#123;% endraw %&#125;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第9章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-5%2F</url>
    <content type="text"><![CDATA[第九章：集合（重点掌握源码）概述Java 集合框架由 Java 类库的一系列接口、抽象类以及具体实现类组成。我们这里所说的集合就是把一组对象组织到一起，然后再根据不同的需求操纵这些数据。集合类型就是容纳这些对象的一个容器。也就是说，最基本的集合特性就是把一组对象放一起集中管理。根据集合中是否允许有重复的对象、对象组织在一起是否按某种顺序等标准来划分的话，集合类型又可以细分为许多种不同的子类型。 Java 集合框架为我们提供了一组基本机制以及这些机制的参考实现，其中基本的集合接口是 Collection 接口，其他相关的接口还有 Iterator 接口、RandomAccess 接口等。这些集合框架中的接口定义了一个集合类型应该实现的基本机制，Java 类库为我们提供了一些具体集合类型的参考实现，根据对数据组织及使用的不同需求，只需要实现不同的接口即可。Java 类库还为我们提供了一些抽象类，提供了集合类型功能的部分实现，我们也可以在这个基础上去进一步实现自己的集合类型。 Collection 接口迭代器我们先来看下这个接口的定义： 1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; 首先，它使用了一个类型参数；其次，它实现了 Iterable 接口，我们再来看下 Iterable 接口的定义： 123public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; 我们可以看到这个接口只定义了一个方法，这个方法要求我们返回一个实现了 Iterator 类型的对象，所以我们看下 Iterator 的定义： 12345public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125; 说到这里，我们简单地说一下迭代器（Iterator）这个东西。上面我们一共提到了两个和迭代器相关的接口：Iterable 接口和 Iterator 接口，从字面意义上来看，前者的意思是 “可迭代的”，后者的意思是 “迭代器。所以我们可以这么理解这两个接口：实现了 Iterable 接口的类是可迭代的；实现了 Iterator 接口的类是一个迭代器。 迭代器就是一个我们用来遍历集合中的对象的东西。也就是说，对于集合，我们不是像对原始类型数组那样通过数组索引来直接访问相应位置的元素，而是通过迭代器来遍历。这么做的好处是将对于集合类型的遍历行为与被遍历的集合对象分离，这样一来我们无需关心该集合类型的具体实现是怎样的。只要获取这个集合对象的迭代器, 便可以遍历这个集合中的对象了。而像遍历对象的顺序这些细节，全部由它的迭代器来处理。现在我们来梳理一下前面提到的这些东西：首先，Collection 接口实现了 Iterable 接口，这意味着所有实现了 Collection 接口的具体集合类都是可迭代的。那么既然要迭代，我们就需要一个迭代器来遍历相应集合中的对象，所以 Iterable 接口要求我们实现 iterator 方法，这个方法要返回一个迭代器对象。一个迭代器对象也就是实现了 Iterator 接口的对象，这个接口要求我们实现 hasNext()、next()、remove() 这三个方法。其中 hasNext 方法判断是否还有下一个元素（即是否遍历完对象了），next 方法会返回下一个元素（若没有下一个元素了调用它会引起抛出一个 NoSuchElementException 异常），remove 方法用于移除最近一次调用 next 方法返回的元素（若没有调用 next 方法而直接调用 remove 方法会报错）。我们可以想象在开始对集合进行迭代前，有个指针指向集合第一个元素的前面，第一次调用 next 方法后，这个指针会” 扫过” 第一个元素并返回它，调用 hasNext 方法就是看这个指针后面还有没有元素了。也就是说这个指针始终指向刚遍历过的元素和下一个待遍历的元素之间。通常，迭代一个集合对象的代码是这个样子的： 123456Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; iter = c.iterator();while (iter.hasNext()) &#123; String element = iter.next(); //do something with element&#125; 从 Java SE 5.0 开始，我们可以使用与以上代码段等价但是更加简洁的版本： 123for (String element : c) &#123; //do something with element&#125; 上面我们提到过 Iterator 接口的 remove 方法必须在 next 方法返回一个元素后才能调用，这对 Java 类库中为我们提供的实现了 Collection 接口的类来说是这样的。当然我们可以通过自己定义一个实现 Collection 接口的集合类来改变这一默认行为（除非有充足的理由，否则最好不要这样做）。 Collection 接口我们先来看一下它的官方定义： The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Setand List. 大概的意思就是：Collection 接口是集合层级结构的根接口。一个集合代表了一组对象，这组对象被称为集合的元素。一些集合允许重复的元素而其他不允许；一些是有序的而一些是无序的。Java 类库中并未提供任何对这个接口的直接实现，而是提供了对于它的更具体的子接口的实现（比如 Set 接口和 List 接口）。 我们知道，接口是一组对需求的描述，那么让我们看看 Collection 接口提出了哪些需求。Collection 接口中定义了以下方法： 123456789101112131415boolean add(E e) //向集合中添加一个元素，若添加元素后集合发生了变化就返回true，若没有发生变化，就返回false。(optional operation).boolean addAll(Collection&lt;? extends E&gt; c) //添加给定集合c中的所有元素到该集合中(optional operation).void clear() //(optional operation).boolean contains(Object o) //判断该集合中是否包含指定对象boolean containsAll(Collection&lt;?&gt; c)boolean equals(Object o)int hashCode()boolean isEmpty()Iterator&lt;E&gt; iterator()boolean remove(Object o) //移除给定对象的一个实例（有的具体集合类型允许重复元素） (optional operation).boolean removeAll(Collection&lt;?&gt; c) //(optional operation).boolean retainAll(Collection&lt;?&gt; c) //仅保留给定集合c中的元素(optional operation).int size()Object[] toArray()&lt;T&gt; T[] toArray(T[] a) 我们注意到有些方法后面注释中标注了 “optional operation”，意思是 Collection 接口的实现类究竟需不需要实现这个方法视具体情况而定。比如有些具体的集合类型不允许向其中添加对象，那么它就无需实现 add 方法。我们可以看到，Collection 对象必须实现的方法有：contains 方法、containsAll 方法、isEmpty 方法、iterator 方法、size 方法、两个 toArray 方法以及 equals 方法、hashCode 方法，其中最后两个方法继承自 Object 类。 我们来说一下两个 toArray 方法，它们的功能都是都是返回这个集合的对象数组。第二个方法接收一个 arrayToFill 参数，当这个参数数组足够大时，就把集合中的元素都填入这个数组（多余空间填 null）；当 arrayToFill 不够大时，就会创建一个大小与集合相同，类型与 arrayToFill 相同的数组，并填入集合元素。 Collection 接口的直接子接口主要有三个：List 接口、Set 接口和 Queue 接口。下面我们对它们进行逐一介绍。 List 接口我们同样先看下它的官方定义： An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list.Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. 大概意思是：List 是一个有序的集合类型（也被称作序列）。使用 List 接口可以精确控制每个元素被插入的位置，并且可以通过元素在列表中的索引来访问它。列表允许重复的元素，并且在允许 null 元素的情况下也允许多个 null 元素。 我们再来看下它定义了哪些方法： 123456ListIterator&lt;E&gt; listIterator();void add(int i, E element);E remove(int i);E get(int i);E set(int i, E element);int indexOf(Object element); 我们可以看到，列表支持对指定位置元素的读写与移除。我们注意到，上面有一个 listIterator 方法，它返回一个列表迭代器。我们来看一看 ListIterator 接口都定义了哪些方法： 12345678void add(E e) //在当前位置添加一个元素boolean hasNext() //返回ture如果还有下个元素（在正向遍历列表时使用）boolean hasPrevious() //反向遍历列表时使用E next() //返回下一个元素并将cursor（也就是我们上文提到的”指针“）前移一个位置int nextIndex() //返回下一次调用next方法将返回的元素的索引E previous() //返回前一个元素并将cursor向前移动一个位置int previousIndex() //返回下一次调用previous方法将返回的元素的索引void remove() //从列表中移除最近一次调用next方法或previous方法返回的元素void set(E e) //用e替换最近依次调用next或previous方法返回的元素 ListIterator 是 Iterator 的子接口，它支持像双向迭代这样更加特殊化的操作。综合以上，我们可以看到，List 接口支持两种访问元素的方式：使用列表迭代器顺序访问或者使用 get/set 方法随机访问。 Java 类库中常见的实现了 List 接口的类有：ArrayList， LinkedList，Stack，Vector，AbstractList，AbstractSequentialList 等等。 ArrayListArrayList 是一个可动态调整大小的数组，允许 null 类型的元素。我们知道，Java 中的数组大小在初始化时就必须确定下来，而且一旦确定就不能改变，这会使得在很多场景下不够灵活。ArrayList 很好地帮我们解决了这个问题，当我们需要一个能根据包含元素的多少来动态调整大小的数组时，那么 ArrayList 正是我们所需要的。 我们先来看看这个类的常用方法： 1234567891011121314boolean add(E e) //添加一个元素到数组末尾void add(int index, E element) //添加一个元素到指定位置void clear()boolean contains(Object o)void ensureCapacity(int minCapacity) //确保ArrayList至少能容纳参数指定数目的对象，若有需要会增加ArrayList实例的容量。E get(int index) //返回指定位置的元素int indexOf(Object o)boolean isEmpty()Iterator&lt;E&gt; iterator()ListIterator&lt;E&gt; listIterator()E remove(int index)boolean remove(Object o)E set(int index, E element)int size() 当我们插入了比较多的元素，导致 ArrayList 快要装满时，它会自动增长容量。ArrayList 内部使用一个 Object 数组来存储元素，自动增长容量是通过创建一个新的容量更大的 Object 数组，并将元素从原 Object 数组复制到新 Object 数组来实现的。若要想避免这种开销，在知道大概会容纳多少数据时，我们可以在构造时指定好它的大小以尽量避免它自动增长的发生；我们也可以调用 ensureCapacity 方法来增加 ArrayList 对象的容量到我们指定的大小。ArrayList 有以下三个构造器： 123ArrayList()ArrayList(Collection&lt;? extends E&gt; c)ArrayList(int initialCapacity) //指定初始capacity，即内部Object数组的初始大小 LinkedList 类LinkedList 类代表了一个双向链表，允许 null 元素。这个类同 ArrayList 一样，不是线程安全的。这个类中主要有以下的方法： 123456void addFirst(E element);void addLast(E element);E getFirst();E getLast();E removeFirst();E removeLast(); 这些方法的含义正如它们的名字所示。LinkedList 作为 List 接口的实现类，自然包含了 List 接口中定义的 add 等方法。LinkedList 的 add 方法实现有以下两种： 12boolean add(E e) //把元素e添加到链表末尾void add(int index, E element) //在指定索引处添加元素 LinkedList 的一个缺陷在于它不支持对元素的高效随机访问，要想随机访问其中的元素，需要逐个扫描直到遇到符合条件的元素。只有当我们需要减少在列表中间添加或删除元素操作的代价时，可以考虑使用 LinkedList。 Set 接口Set 接口与 List 接口的重要区别就是它不支持重复的元素，至多可以包含一个 null 类型元素。Set 接口定义的是数学意义上的 “集合” 概念。Set 接口主要定义了以下方法： 1234567891011boolean add(E e)void clear()boolean contains(Object o)boolean isEmpty()boolean equals(Object obj)Iterator&lt;E&gt; iterator()boolean remove(Object o)boolean removeAll(Collection&lt;?&gt; c)int size()Object[] toArray()&lt;T&gt; T[] toArray(T[] a) Set 接口并没有显式要求其中的元素是有序或是无序的，它有一个叫做 SortedSet 的子接口，这个接口可以用来实现对 Set 元素的排序，SortedSet 还有叫做 NavigableSet 的子接口，这个接口定义的方法可以在有序 Set 中进行查找和遍历。Java 类库中实现了 Set 接口的类主要有：AbstractSet，HashSet，TreeSet，EnumSet，LinkedHashSet 等等。其中，HashSet 与 TreeSet 都是 AbstractSet 的子类。那么，为什么 Java 类库要提供 AbstractSet 这个抽象类呢？答案是为了让我们在自定义实现 Set 接口的类时不必 “从零开始”，AbstractSet 这个抽象类已经为我们实现了 Set 接口中的一些常规方法，而一些灵活性比较强的方法可以由我们自己来定义，我们只需要继承 AbstractSet 这个抽象类即可。类似的抽象类还有很多，比如我们上面提到的实现了 List 接口的 AbstractList 抽象类就是 LinkedList 和 ArrayList 的父类。Java 官方文档中提到，HashSet 和 TreeSet 分别基于 HashMap 和 TreeMap 实现（我们在后面会简单介绍 HashMap 和 TreeMap），他们的区别在于 Set 接口是一个对象的集（数学意义上的” 集合“），Map&lt;K, V &gt; 是一个键值对的集合。而且由于它们分别是对 Set 和 Map&lt;K, V &gt; 接口的实现，相应添加与删除元素的方法也取决于具体接口的定义。 Queue 接口Queue 接口是对队列这种数据结构的抽象。一般的队列实现允许我们高效的在队尾添加元素，在队列头部删除元素（First in, First out)。Queue 接口还有一个名为 Deque 的子接口，它允许我们高效的在队头或队尾添加 / 删除元素，实现了 Deque 的接口的集合类即为双端队列的一种实现（比如 LinkedList 就实现了 Deque 接口）。Queue 接口定义了以下方法： 123456boolean add(E e) //添加一个元素到队列中，若队列已满会抛出一个IllegalStateException异常E element() //获取队头元素boolean offer(E e) //添加一个元素到队列中，若队列已满返回falseE peek() //获取队头元素，若队列为空返回nullE poll() //返回并移除队头元素，若队列为空返回nullE remove() //返回并移除队头元素 我们注意观察下上面的方法：add 与 offer，element 与 peek，remove 与 poll 看似是三对儿功能相同的方法。它们之间的重要区别在于前者若操作失败会抛出一个异常，后者若操作失败会从返回值体现出来（比如返回 false 或 null），我们可以根据具体需求调用它们中的前者或后者。 实现 Queue 接口的类主要有：AbstractQueue， ArrayDeque， LinkedList，PriorityQueue，DelayQueue 等等。关于它们具体的介绍可参考官方文档或相关的文章。 Map 接口我们先来看下它的定义： An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.The Mapinterface provides three collection views, which allow a map’s contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map’s collection views return their elements. Some map implementations, like the TreeMapclass, make specific guarantees as to their order; others, like the HashMapclass, do not. 大概意思是这样的：一个把键映射到值的对象被称作一个 Map 对象。映射表不能包含重复的键，每个键至多可以与一个值关联。Map 接口提供了三个集合视图（关于集合视图的概念我们下面会提到）：键的集合视图、值的集合视图以及键值对的集合视图。一个映射表的顺序取决于它的集合视图的迭代器返回元素的顺序。一些 Map 接口的具体实现（比如 TreeMap）保证元素有一定的顺序，其它一些实现（比如 HashMap）则不保证元素在其内部有序。 也就是说，Map 接口定义了一个类似于 “字典” 的规范，让我们能够根据键快速检索到它所关联的值。我们先来看看 Map 接口定义了哪些方法： 1234567891011void clear()boolean containsKey(Object key) //判断是否包含指定键boolean containsValue(Object value) //判断是否包含指定值boolean isEmpty()V get(Object key) //返回指定键映射的值V put(K key, V value) //放入指定的键值对V remove(Object key)int size()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Set&lt;K&gt; keySet()Collection&lt;V&gt; values() 后三个方法在我们下面介绍集合视图时会具体讲解。 Map 接口的具体实现类主要有：AbstractMap，EnumMap，HashMap，LinkedHashMap，TreeMap。HashTable。 HashMap我们看一下 HashMap 的官方定义： HashMap&lt;K, V&gt; 是基于哈希表这个数据结构的 Map 接口具体实现，允许 null 键和 null 值。这个类与 HashTable 近似等价，区别在于 HashMap 不是线程安全的并且允许 null 键和 null 值。由于基于哈希表实现，所以 HashMap 内部的元素是无序的。HashMap 对与 get 与 put 操作的时间复杂度是常数级别的（在散列均匀的前提下）。对 HashMap 的集合视图进行迭代所需时间与 HashMap 的 capacity（bucket 的数量）加上 HashMap 的尺寸（键值对的数量）成正比。因此，若迭代操作的性能很重要，不要把初始 capacity 设的过高（不要把 load factor 设的过低）。 有两个因素会影响一个 HashMap 对象的性能：intial capacity（初始容量）和 load factor（负载因子）。intial capacity 就是 HashMap 对象刚创建时其内部的哈希表的 “桶” 的数量（请参考哈希表的定义）。load factor 等于 maxSize / capacity，也就是 HashMap 所允许的最大键值对数与桶数的比值。增大 load factor 可以节省空间但查找一个元素的时间会增加，减小 load factor 会占用更多的存储空间，但是 get 与 put 的操作会更快。当 HashMap 中的键值对数量超过了 maxSize（即 load factor 与 capacity 的乘积），它会再散列，再散列会重建内部数据结构，桶数（capacity）大约会增加到原来的两倍。 HashMap 默认的 load factor 大小为 0.75，这个数值在时间与空间上做了很好的权衡。当我们清楚自己将要大概存放多少数据时，也可以自定义 load factor 的大小。 HashMap 的构造器如下： 1234HashMap()HashMap(int initialCapacity)HashMap(int initialCapacity, float loadFactor)HashMap(Map&lt;? extends K,? extends V&gt; m) //创建一个新的HashMap，用m的数据填充 常用方法如下： 1234567891011void clear()boolean containsKey(Object key)boolean containsValue(Object value)V get(Object key)V put(K key, V value)boolean isEmpty()V remove(Object key)int size()Collection&lt;V&gt; values()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()Set&lt;K&gt; keySet() 它们的功能都很直观，更多的使用细节可以参考 Java 官方文档，这里就不贴上来了。这里简单地提一下 WeakHashMap，它与 HashMap 的区别在于，存储在其中的 key 是 “弱引用” 的，也就是说，当不再存在对 WeakHashMap 中的键的外部引用时，相应的键值对就会被回收。关于 WeakHashMap 和其他类的具体使用方法及注意事项，大家可以参考官方文档。下面我们来简单地介绍下另一个 Map 接口的具体实现——TreeMap。 TreeMap它的官方定义是这样的： TreeMap&lt;K, V&gt; 一个基于红黑树的 Map 接口实现。TreeMap 中的元素是有序的，排序的依据是存储在其中的键的 natural ordering（自然序，也就是数字从小到大，字母的话按照字典序）或者根据在创建 TreeMap 时提供的 Comparator 对象，这取决于使用了哪个构造器。TreeMap 的 containsKey, get, put 和 remove 操作的时间复杂度均为 log(n)。 TreeMap 有以下构造器： 1234TreeMap() //使用自然序对其元素进行排序TreeMap(Comparator&lt;? super K&gt; comparator) //使用一个比较器对其元素进行排序TreeMap(Map&lt;? extends K,? extends V&gt; m) //构造一个与映射表m含有相同元素的TreeMap，用自然序进行排列TreeMap(SortedMap&lt;K,? extends V&gt; m) //构造一个与有序映射表m含有相同元素及元素顺序的TreeMap 它的常见方法如下： 12345678910111213141516Map.Entry&lt;K,V&gt; ceilingEntry(K key) //返回一个最接近且大于等于指定key的键值对。K ceilingKey(K key)void clear()Comparator&lt;? super K&gt; comparator() //返回使用的比较器，若按自然序则返回nullboolean containsKey(Object key)boolean containsValue(Object value)NavigableSet&lt;K&gt; descendingKeySet() //返回一个包含在TreeMap中的键的逆序的NavigableSet视图NavigableMap&lt;K,V&gt; descendingMap()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()Map.Entry&lt;K,V&gt; firstEntry() //返回键最小的键值对Map.Entry&lt;K,V&gt; floorEntry(K key) //返回一个最接近指定key且小于等于它的键对应的键值对K floorKey(K key)V get(Object key)Set&lt;K&gt; keySet()Map.Entry&lt;K,V&gt; lastEntry() //返回与最大的键相关联的键值对K lastKey() 建议大家先了解下红黑树这个数据结构的原理及实现（可参考算法（第 4 版） (豆瓣)），然后再去看官方文档中关于这个类的介绍，这样学起来会事半功倍。 最后再简单地介绍下 NavigableMap&lt;K, V&gt; 这个接口： 实现了这个接口的类支持一些 navigation methods，比如 lowerEntry（返回小于指定键的最大键所关联的键值对），floorEntry（返回小于等于指定键的最大键所关联的键值对），ceilingEntry（返回大于等于指定键的最小键所关联的键值对）和 higerEntry（返回大于指定键的最小键所关联的键值对）。一个 NavigableMap 支持对其中存储的键按键的递增顺序或递减顺序的遍历或访问。NavigableMap&lt;K, V&gt; 接口还定义了 firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 等方法，以准确获取指定位置的键值对。 总的来说，NavigableMap&lt;K, V&gt; 接口正如它的名字所示，支持我们在映射表中” 自由的航行 “，正向或者反向迭代其中的元素并获取我们需要的指定位置的元素。TreeMap 实现了这个接口。 视图（View）与包装器下面我们来解决一个上面遗留的问题，也就是介绍一下集合视图的概念。Java 中的集合视图是用来查看集合中全部或部分数据的一个”窗口 “，只不过通过视图我们不仅能查看相应集合中的元素，对视图的操作还可能会影响到相应的集合。通过使用视图可以获得其他的实现了 Map 接口或 Collection 接口的对象。比如我们上面提到的 TreeMap 和 HashMap 的 keySet() 方法就会返回一个相应映射表对象的视图。也就是说，keySet 方法返回的视图是一个实现了 Set 接口的对象，这个对象中又包含了一系列键对象。 轻量级包装器Arrays.asList 会发挥一个包装了 Java 数组的集合视图（实现了 List 接口）。请看以下代码： 1234567public static void main(String[] args) &#123; String[] strings = &#123;"first", "second", "third"&#125;; List&lt;String&gt; stringList = Arrays.asList(strings); String s1 = stringList.get(0); System.out.println(s1); stringList.add(0, "new first");&#125; 以上代码会编译成功，但是在运行时会抛出一个 UnsupportedOperationException 异常，原因是调用了改变列表大小的 add 方法。Arrays.asList 方法返回的封装了底层数组的集合视图不支持对改变数组大小的方法（如 add 方法和 remove 方法）的调用（但是可以改变数组中的元素）。实际上，这个方法调用了以下方法： 1Collections.nCopies(n, anObject); 这个方法会返回一个实现了 List 接口的不可修改的对象。这个对象包含了 n 个元素（anObject）。 子范围我们可以为很多集合类型建立一个称为子范围（subrange）的集合视图。例如以下代码抽出 group 中的第 10 到 19 个元素（从 0 开始计数）组成一个子范围： 1List subgroup = group.subList(10, 20); //group为一个实现了List接口的列表类型 List 接口所定义的操作都可以应用于子范围，包括那些会改变列表大小的方法，比如以下方法会把 subgroup 列表清空，同时 group 中相应的元素也会从列表中移除： 1subgroup.clear(); 对于实现了 SortedSet 接口的有序集或是实现了 SortedMap&lt;K, V &gt; 接口的有序映射表，我们也可以为他们创建子范围。SortedSet 接口定义了以下三个方法： 123SortedSet&lt;E&gt; subSet(E from, E to); SortedSet&lt;E&gt; headSet(E to);SortedSet&lt;E&gt; tailSet(E from); SortedMap 也定义了类似的方法： 123SortedMap&lt;K, V&gt; subMap(K from, K to);SortedMap&lt;K, V&gt; headMap(K to);SortedMap&lt;K, V&gt; tailMap(K from); 不可修改的视图Collections 类中的一些方法可以返回不可修改视图（unmodifiable views)： 123456Collections.unmodifiableCollectionCollections.unmodifiableListCollections.unmodifiableSetCollections.unmodifiableSortedSetCollections.unmodifiableMapCollections.unmodifiableSortedMap 同步视图若集合可能被多个线程并发访问，那么我们就需要确保集合中的数据不会被破坏。Java 类库的设计者使用视图机制来确保常规集合的线程安全。比如，我们可以调用以下方法将任意一个实现了 Map 接口的集合变为线程安全的： 1Map&lt;String, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;()); 被检验视图我们先看一下这段代码： 123ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;();ArrayList rawList = strings;rawList.add(new Date()); 在以上代码的第二行，我们把泛型数组赋值给了一个原始类型数组，这通常只会产生一个警告。而第三行我们往 rawList 中添加一个 Date 对象时，并不会产生任何错误。因为 rawList 内部存储的实际上是 Object 对象，而任何对象都可以转换为 Object 对象。那么我们怎么避免这一问题呢，请看以下代码： 1234ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;();List&lt;String&gt; safeStrings = Collections.checkedList(strings, String.class);ArrayList rawList = safeStrings;rawList.add(new Date()); //Checked list throws a ClassCastException 在上面，我们通过包装 strings 得到一个被检验视图 safeStrings。这样在尝试添加非 String 对象时，便会抛出一个 ClassCastException 异常。 集合视图的本质集合视图本身不包含任何数据，它只是对相应接口的包装。集合视图所支持的所有操作都是通过访问它所关联的集合类实例来实现的。我们来看看 HashMap 的 keySet 方法的源码： 12345678910111213141516171819202122232425262728293031323334353637public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks; return (ks = keySet) == null ? (keySet = new KeySet()) : ks;&#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125;&#125; 我们可以看到，实际上 keySet() 方法返回一个内部 final 类 KeySet 的实例。我们可以看到 KeySet 类本身没有任何实例变量。我们再看 KeySet 类定义的 size() 实例方法，它的实现就是通过直接返回 HashMap 的实例变量 size。还有 clear 方法，实际上调用的就是 HashMap 对象的 clear 方法。 keySet 方法能够让你直接访问到 Map 的键集，而不需要复制数据或者创建一个新的数据结构，这样做往往比复制数据到一个新的数据结构更加高效。考虑这样一个场景：你需要把一个之前创建的数组传递给一个接收 List 参数的方法，那么你可以使用 Arrays.asList 方法返回一个包装了数组的视图（这需要的空间复杂度是常数级别的），而不用创建一个新的 ArrayList 再把原数组中的数据复制过去。 Collections 类我们要注意到 Collections 类与 Collection 接口的区别：Collection 是一个接口，而 Collections 是一个类（可以看做一个静态方法库）。下面我们看一下官方文档对 Collections 的描述： Collections 类包含了大量用于操作或返回集合的静态方法。它包含操作集合的多态算法，还有包装集合的包装器方法等等。这个类中的所有方法在集合或类对象为空时均会抛出一个 NullPointerException。 关于 Collections 类中的常用方法，我们上面已经做了一些介绍，更加详细的介绍大家可以参考 Java 官方文档。 总结关于 Java 集合框架，我们首先应该把握住几个核心的接口，请看下图： 我们还要了解到这些接口描述了一组什么样的机制，然后以此作为出发点，去了解具体哪些类实现了哪些机制。像这样自顶向下的学习，我们很快就能掌握常见集合类的用法。对于一些我们平常经常使用的类，我们还可以阅读一下它的源码，了解它的实现细节，这样我们以后使用起来会更加得心应手。不过阅读一些集合类（比如 TreeMap、HashMap）的源码需要我们具备一定的数据结构与算法的基础知识，这方面推荐阅读 算法（第 4 版） (豆瓣)。 参考资料 《Java 核心技术（卷一）》 What is a view of a collection? Java SE 7 Docs 总结： 概念：• Java 集合类库将接口与实现分离，接口定义增删改查等方法，具体分为集合和映射两种基本接口 (Collection 和 Map)。Collection 接口实现了 Iterable 接口，往下又分为 List、Set 和 Queue，Set 往下有 SortSet 等；Map 下有 SortedMap 等 (都是接口)。RandomAccess 接口用于判断该集合是否支持高效的随机访问。• 集合没有 key 值，映射有 key 和 value。集合的实现可以使用具体的数据结构来存储数据，每种数据结构的特点不同。注意 Tree、优先级队列等是随机插入，按指定顺序输入；而 Linked 是按插入顺序输出。• 常用的几种具体集合和映射：ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet、LinkedBlockingDeque 等 (Collection 集合)；HashMap、LinkedHashMap、WeadHashMap 等 (Map 映射)。• Java 集合接口可以定义不同的实现，不同实现使用不同的数据结构，各种数据结构有自己的特点，另外结合泛型、迭代器，因此可以定义各种不同的数据存储方式。接口从Collection-&gt;List等有不同等级，每层接口定义的方法不同，逐步完善。中间也提供了一些抽象父类完成了一些基本实现，如元素默认判等使用equals()方法，因此 Set 也要求我们自定义equals()方法。 接口 List 可以添加重复元素，是有序的；Set 不能添加重复元素，是无序的。所以元素被访问的顺序取决于集合类型。 迭代器：• Java 的迭代器位于两个元素之间，调用next()时，迭代器越过下一个元素，并返回刚刚越过的元素。调用remove()时将删除上次调用next()越过的那个元素。调用remove()之前没有调用next()是不合法的 (不能连续两次调用 remove())。• add()方法插入元素到光标之前。add()方法依赖于迭代器位置，remove()方法依赖于迭代器状态。迭代器可以并发读，要控制并发写。listIterator 的set()方法用一个新元素的值取代越过返回的那个元素，可返回局部迭代器。 集 set 中要适当的定义集的equals()方法，如只要两个集包含数据相同的元素 (不要求顺序相同，不要求是同一个对象)，就认为是相等的。相等的两个集合要求要有相同的散列码 hashCode(注意是子元素这一层定义 equals()、hashCode() 等方法，集合这一层的 equals()里根据子元素再自定义判等)。 List 是有序集合，访问可以通过迭代器顺序访问或通过下标随机访问，但是不同数据结构随机访问性能差别很大，如随机插入、删除使用 LinkedList(双向链表结构，数据保存在节点中，每个节点保存着前驱和后继的节点，便于插入删除；但是随机访问要挨个移动指针，因此不支持快速随机访问)；随机查询使用 ArrayList，可以通过索引来访问 (动态数组结构，支持二分查找随机访问，中间增删要移动和赋值数据，效率低，需要把插入位置后所有元素往后移动)。因此 ArrayList 使索引访问更快，LinkedList 最好使用迭代器遍历。数组动态查询之所以快是因为开辟连续的内存地址存储数据，找到一个位置就能知道其他位置，也因此是有界的，且动态插入效率低；而链表是将数据放在节点中，真正的数据内存地址不需连续，因此随机查询效率低，每次都要找出内存地址，但是随机插入高效，只需要改节点的指针即可，也满足了无界。 LinkedList 列表的get()方法实际上做了微小的优化，如果索引大于size()/2的话就从列表尾端开始搜索元素。但是 for 循环中的list.get(i)是效率很低的，每次都要从头遍历，因此随机查询不建议使用 LinkedList。插入时add()方法默认插入到尾部，插入中间可以用add(i)或迭代器listIterable.add()插入 (依赖光标位置)，listIterable 迭代器也能返回局部迭代列表。 Vector 类和 HashTable 类的方法都是同步的，可以线程安全的访问对象，但是因此效率比较低。不考虑线程安全的话建议使用 ArrayList 和 HashMap。 散列表：提供快速查找的数据结构，为每一个对象计算一个整数，称为散列码，散列码是由对象的实例域产生的一个整数。Java 中散列表用链表数组实现，每个列表被称为桶。查找表中对象的位置，先计算散列码，与桶的总数取余，结果就是保存这个元素的桶的索引，因此只需要在这个桶中找数据即可。 桶中已有一个元素的情况称为 “散列冲突” 或“哈希冲突”，这时默认策略是按列表继续往后放元素 (也有策略是寻找下一个桶)，桶满时(有个默认桶满值如 8) 会从列表变为平衡二叉树(树结构查询更快)。如果散列表太满(不论元素在哪个桶中，总的 size / 总桶数大于填充因子就算满了)，就需要再散列(以 2 的倍数扩桶)。创建一个桶更多的表将所有元素插入到这个新表中，丢弃原来的表。装填因子决定何时对散列表再散列，默认为 0.75。 所谓 Set 是无序的，因为算出的桶索引是无序的，add 的元素不一定在哪个索引下；另外 Set 无重复元素因为hashCode()算出的桶索引基本不会一样，如果一样了，还会继续判equals()是否一致，一致则覆盖，否则往后链表里加。 queals()方法和hashCode()的定义必须兼容，如果x.equals(y)为 true，x.hashCode()也必须等于y.hashCode()。 树集 TreeSet 是一个有序集合，按任意顺序插入，迭代器遍历时会顺序输出，排序使用红黑树实现。使用树集必须能够比较元素，因此元素必须实现 Comparator 接口或构造方法中传入一个 Comparator。将一个元素插入到树中比插入到散列集要稍微慢一点点，但是检查数组或链表中的重复元素，树稍微快一点，所以单个桶满会将链表变二叉树。 队列接口可以在尾部添加元素，在头部删除元素，不可在中间插入，并且可以查找队列中元素的个数。队列接口的实现方式通常有循环数组 (有界) 和列表 (无界) 两种方式。 优先级队列的元素可以按任意方式插入，却总是按排序的顺序进行检索。内部使用堆 (可自我调整的二叉树，每次插入完就已经是有序的了) 来存储数据，迭代并不是按照元素顺序访问，而删除却总是删除掉优先级最小的那个元素，也需要提供 Comparator。多用于任务调度中任务队列的实现。 映射：不同于集合直接存放精确数据副本，而是用来存放键值对。通用分为 HashMap 和 TreeMap，散列映射对键进行散列，树映射用键的整体顺序来排序。get()时没有对应键的信息，则返回null；键可以为 null，值不能为 null；重复调用put()方法会覆盖掉上一次的值，put()方法返回上一次的旧值 (没有返回 null)。 视图：集合框架认为映射本身不是一个集合，但它的视图是实现了 Collection 接口或某个子接口的对象。有三种：键集 (Set)、值集合 (Collection)、键 / 值对集 (Set)。KeySet 并不是 HashSet 或 TreeSet，只是实现了 Set 接口的某个类对象。既然是集合，就有迭代器，但是仅对原映射集可删除不能增加。 WeakedHashMap 弱散列映射解决映射强引用问题，当元素只被散列条目引用时，会将其加入到弱引用队列，等待垃圾回收机制将其回收。LinkedHashMap/Set 可以记录插入顺序，但是使用访问顺序进行迭代 (同一个桶中元素被访问后会从当前节点删除加入到链表尾部)，且重写removeEldestEntry()方法可以实现类似 LRU 算法的 Map，不过这种迭代顺序的影响只有发生散列冲突时才能看出来。 Collections 的静态方法synchronizedMap()方法可以将任意一个映射表转成线程安全的 Map。不管是集合还是映射，是有并发问题的，不可一个迭代器正在修改，另一个迭代器在读，会抛出异常。 Collections 的sort()方法可以进行排序，shuffle()方法可以进行乱序，binarySearch()方法进行二分查找等，类似 Arrays 的一些方法。 属性映射 Property 是一种特殊的映射结构，键值都是字符串，可以load(InputStream is)加载，也可store(OutputStream out,String str)写出。 栈 Stack 后进先出，有push()、pop()、peek()等方法，注意pop()和peek()如果站内无元素是会抛异常。 位集 BitSet 可高效存储位序列，元素包装在字节里，比 ArrayList 存 Boolean 效率高。 几种数据结构比较：• 数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)。• 链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)。• 二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。• 哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。 HashMap 的实现原理：内部采用散列表进行存储，散列表数据结构为数组 + 链表，数组保证快速定位，链表保证哈希冲突 (策略有开放地址法、再散列函数法和链地址法)。JDK1.7 中默认容量 16，链表变树临界值 8，填充因子 0.75，size表示当前 Entry 总数 (不管是单桶还是多桶中)，threshold表示临界扩容桶值。在第一次put()中才给table赋值，hash()对 key 值取 hashCode 进行一系列异或位移操作保证均匀分布，indexFor()这里要求桶数每次都是 2 的幂，这样桶数 - 1 后二进制一定是全 1，不管是直接计算索引值还是再散列时对之前的所有元素重新计算 index 时，需要尽可能快，而 hashCode 不论多大与全 1 进行&amp;运算时，前面全部是非，裁掉了，后面得出的结果就是余数大小，小小算法有点叼 (位运算性能更高吧)。一般来说，对单桶，大于链表变树临界值则将链表变为树结构 (树的查询更快)，对多桶，总数大于threshold临界值则需扩容，但是桶总数 64 之前，该链表变树时优先扩容，桶数大于 64 之后再该变树变树该扩容扩容，可能是优先尽量避免哈希冲突吧。重点：都很重要 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-1%2F</url>
    <content type="text"><![CDATA[见《java核心技术》笔记各章后总结 在看完java集合框架源码和多线程内容后会总结该部分。 参考：https://www.cnblogs.com/BYRans/p/Java.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（7~8章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-4%2F</url>
    <content type="text"><![CDATA[第七章：异常、断言和日志7.1 处理错误需要关注的问题 用户输入错误 设备错误 物理限制 代码错误 7.1.1 异常分类 派生于 RuntimeException 的异常包含下面几种情况: 错误的类型转换 数组访问越界 访问 null 指针 不是派生于 RuntimeException 的异常包括 试图在文件尾部后面读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在 7.1.2 声明受检查异常 使用 throws 关键字，在方法的首部同所有的异常类。每个异常类之间用逗号隔开。 7.1.3 使用 throws new Exception();7.1.4 创建异常类派生于 Exception 类或派生于 Exception 的子类 7.2 捕获异常7.2.1 捕获异常123try&#123;&#125; catch (Exception e)&#123;&#125; 7.2.2 捕获多个异常 Java 7 以后，在 catch 子句中可以捕获多个异常. 使用 | 7.2.3 再次抛出异常与异常链 在 catch 子句中，可以改变异常的类型，进行再次抛出 7.2.4 finally 子句 不管异常是否被捕获，finally 子句中的代码都被执行。 12345678InputStream in = new FileInputStream("c:\\a.txt");try&#123; try&#123; &#125; finally &#123; &#125;&#125; catch(IOException e) &#123; //异常处理的语句&#125; 7.2.5 带资源的 try 语句前提：资源属于实现了 AutoCloseable 接口的类 12try(Resourse res = ...) &#123;&#125; 7.2.6 分析堆栈轨迹元素 getStackTrace 方法，可以得到 stackTraceelElement 对象的一个数组，可以在你的程序中分析这个对象数组。 7.3 使用异常机制的技巧 异常处理不能代替简单的测试 不要过分的细化异常 利用异常层次结构 不要压制异常 在检测时，“苛刻” 比放任要好 不要羞于传递异常 7.4 使用断言 (JDK 自带的，基本不使用)7.4.1 断言的概念断言机制允许在测试期间向代码中插入一些检查语句，使用关键字 assert. 7.4.2 启用和禁用断言 在默认情况下，断言被禁用。使用 java -ea: 选项启用 7.4.3 使用断言完成参数检查7.4.4 为文档假设使用断言7.5 记录日志7.5.1 基本日志 使用全局日志记录器 (global logger) Logger.getGlobal().info(、、、); 7.5.2 高级日志 日志级别: 七种 SEVRE WARNING INFO CONFIG FINE FINER FINEST 7.5.3 修改日志管理器配置7.5.4 本地化7.5.5 处理器7.5.6 过滤器7.5.7 格式化器7.5.8 日志记录说明总结 总结： 所有的异常类都是由 Throwable 继承而来，下层分为 Error 和 Exception，Exception 又分为 IOException 和 RuntimeException。只有 IOException 是受查异常 (代码提示的异常)，其余都是非受查异常 (平时的崩溃，自己无法控制)。 Error 是 Java 形式内部错误和资源耗尽错误，我们无能为力；而程序中如果出现了 RuntimeException，那一定是程序员自己的问题。对于异常要么 throws 抛出去给别人处理，要么try catch自己处理。一个方法必须声明所有可能抛出的受查异常，而非受查异常是不可控的，应该避免。 子类覆盖超类的方法时，子类声明的受查异常不能比超类中声明的更通用；若超类中没有抛出任何受查异常，子类也不能抛出。 异常可以捕获也可以继续抛出，应该捕获那些知道应该如何处理的异常，而将那些不知道怎样处理的继续抛出 (如工具类中的异常抛出，由调用者自己来分别处理)。 catch 语句中可以继续抛出异常，并将原始异常设置为新异常的原因initCause()，可以让用户抛出子系统中的高级异常，而不会丢失原异常的细节。 try 语句中可以只有 finally 而没有 catch 块，不管异常是否被捕获，finally 语句块都会被执行，finally 语句在方法返回前被执行，所以不要在 finally 中写 return 语句，它会覆盖掉原方法中的 return。 堆栈轨迹 (stack trace) 是一个方法调用过程的列表，它包含了程序执行过程中方法的调用位置。t.getStackTrace()可以获取到一个 StackTraceElementp[] 数组，它包含了方法的 name、className 和调用行 lineNumber 等信息。 一般我们给Thread.setDefaultUnchaughtExceptionHandler()后，在程序非受查崩溃时会回调到 Handler 的uncaughtException(thread,throwable)，在这里可以将throwable.printStackTrace(writer)输出到文件里，然后将文件上传服务器帮助我们分析程序崩溃。 断言：• 定义：断言机制允许在程序测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检查语句会自动被移除。• 表现形式：assert 条件 / assert 条件: 表达式。• 开启断言：默认下断言是被禁用的，启用或禁用断言是类加载器 (ClassLoader) 的功能。启用或禁用使用java -ea/-da，可针对整个项目或某个特定 class 或 package 作用域。• 作用：断言相当于自己做了一层判断，如果符合预期则没什么，如果不符合预期会自动抛出一个 AssertionError 的非受查异常，不用在方法上自己去写 throw 了。重点：264 异常分类、捕获异常 第八章：泛型程序设计（了解） 泛型程序设计指编写的代码可以被许多不同类型的对象所重用，使程序具有更好的可读性和安全性。 泛型变量指域和局部变量及方法的返回类型。泛型可以用于类中也可用于方法中，泛型方法中的类型变量放在修饰符后面，返回类型的前面。 泛型可以用extends关键字指定子类型来做限制，可以 extends 多个类型，用&amp;符间隔。 类型擦除：虚拟机中没有泛型类型对象，把泛型类加载到虚拟机中后，所有定义的泛型 T 都会被擦除成原始类型。有限定类型的话擦除类型变量替换为限定类型 (extends 多继承时取第一个类型 因此标签接口尽量往后放)，无限定类型的话为 Object。 类型擦除与多态的冲突：由于泛型擦除，一个泛型类指向其子类的引用，子类中如果对父类的方法重载 (其实重载不了，父类参数是擦除后的 Object，子类是具体的类型)，在调用方法时，其实先调了父类的方法 (Object 类型)，然后参数强转桥接到了子类的重载方法 (具体类型)。严格上说不能重载，因此子类里是有两个方法的 (可查看子类. class 文件)。 Java 泛型转换总结：• 虚拟机中无泛型，只有普通类和方法；• 所有的参数类型都要用它们的限定类型替换；• 桥方法被合成用来保持多态；为保持类型安全性，必要时插入强制类型转换。 泛型约束：• 不能用类型参数代替基本类型；• 类型检测只会检测原始类型；• 不能实例化参数化类型数组 (不安全)；• 不能实例化类型变量；• 不能在静态域或方法中引用类型变量；• 不能抛出和捕获泛型异常。 泛型之间无联系，不论S与T有什么联系，Pair&lt;S&gt;与Pair&lt;T&gt;无任何联系。Class 类本身是泛型，如String.class是一个Class&lt;String&gt;的实例。 通配符类型中，允许类型参数变化。有&lt;? super X&gt;与&lt;? extends X&gt;，带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。 泛型 与通配符 &lt;?&gt; 的区别：泛型 T 指定一种类型参数的表示，实例化时是什么就是什么；通配符? 代表一种限制，只要符合条件类型是什么都行，可以有多种。重点：P316 泛型擦除 P330 通配符 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射由浅入深 | 进阶必备]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-2%2F</url>
    <content type="text"><![CDATA[一、Java 反射机制 Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 反射机制很重要的一点就是 “运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。 不知道上面的理论你能否明白，反正刚接触反射时我一脸懵比，后来写了几个例子之后：哦~~ 原来是这个意思！ 若暂时不明白理论没关系，先往下看例子，之后再回来看相信你就能明白了。 二、使用反射获取类的信息为使得测试结果更加明显，我首先定义了一个 FatherClass 类（默认继承自 Object 类），然后定义一个继承自 FatherClass 类的 SonClass 类，如下所示。可以看到测试类中变量以及方法的访问权限不是很规范，是为了更明显得查看测试结果而故意设置的，实际项目中不提倡这么写。 FatherClass.java 123456public class FatherClass &#123; public String mFatherName; public int mFatherAge; public void printFatherMsg()&#123;&#125;&#125; SonClass.java 123456789101112131415161718192021222324252627public class SonClass extends FatherClass&#123; private String mSonName; protected int mSonAge; public String mSonBirthday; public void printSonMsg()&#123; System.out.println("Son Msg - name : " + mSonName + "; age : " + mSonAge); &#125; private void setSonName(String name)&#123; mSonName = name; &#125; private void setSonAge(int age)&#123; mSonAge = age; &#125; private int getSonAge()&#123; return mSonAge; &#125; private String getSonName()&#123; return mSonName; &#125;&#125; 1. 获取类的所有变量信息12345678910111213141516171819202122232425/** * 通过反射获取类的所有变量 */private static void printFields()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的变量 // 包括本类声明的和从父类继承的 Field[] fields = mClass.getFields(); //2.2 获取所有本类声明的变量（不问访问权限） //Field[] fields = mClass.getDeclaredFields(); //3\. 遍历变量并输出变量信息 for (Field field :fields) &#123; //获取访问权限并输出 int modifiers = field.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //输出变量的类型及变量名 System.out.println(field.getType().getName() + " " + field.getName()); &#125;&#125; 以上代码注释很详细，就不再解释了。需要注意的是注释中 2.1 的 getFields() 与 2.2 的 getDeclaredFields() 之间的区别，下面分别看一下两种情况下的输出。看之前强调一下：SonClass extends FatherClass extends Object ： 调用 getFields() 方法，输出 SonClass 类以及其所继承的父类 ( 包括 FatherClass 和 Object ) 的 public 方法。注：Object 类中没有成员变量，所以没有输出。 1234类的名称：obj.SonClasspublic java.lang.String mSonBirthdaypublic java.lang.String mFatherNamepublic int mFatherAge 调用 getDeclaredFields() ， 输出 SonClass 类的所有成员变量，不问访问权限。 1234类的名称：obj.SonClassprivate java.lang.String mSonNameprotected int mSonAgepublic java.lang.String mSonBirthday 2. 获取类的所有方法信息123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 通过反射获取类的所有方法 */private static void printMethods()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的方法 //包括自己声明和从父类继承的 Method[] mMethods = mClass.getMethods(); //2.2 获取所有本类的的方法（不问访问权限） //Method[] mMethods = mClass.getDeclaredMethods(); //3.遍历所有方法 for (Method method : mMethods) &#123; //获取并输出方法的访问权限（Modifiers：修饰符） int modifiers = method.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //获取并输出方法的返回值类型 Class returnType = method.getReturnType(); System.out.print(returnType.getName() + " " + method.getName() + "( "); //获取并输出方法的所有参数 Parameter[] parameters = method.getParameters(); for (Parameter parameter: parameters) &#123; System.out.print(parameter.getType().getName() + " " + parameter.getName() + ","); &#125; //获取并输出方法抛出的异常 Class[] exceptionTypes = method.getExceptionTypes(); if (exceptionTypes.length == 0)&#123; System.out.println(" )"); &#125; else &#123; for (Class c : exceptionTypes) &#123; System.out.println(" ) throws " + c.getName()); &#125; &#125; &#125;&#125; 同获取变量信息一样，需要注意注释中 2.1 与 2.2 的区别，下面看一下打印输出： 调用 getMethods() 方法获取 SonClass 类所有 public 访问权限的方法，包括从父类继承的。打印信息中，printSonMsg() 方法来自 SonClass 类， printFatherMsg() 来自 FatherClass 类，其余方法来自 Object 类。 123456789101112类的名称：obj.SonClasspublic void printSonMsg( )public void printFatherMsg( )public final void wait( ) throws java.lang.InterruptedExceptionpublic final void wait( long arg0,int arg1, ) throws java.lang.InterruptedExceptionpublic final native void wait( long arg0, ) throws java.lang.InterruptedExceptionpublic boolean equals( java.lang.Object arg0, )public java.lang.String toString( )public native int hashCode( )public final native java.lang.Class getClass( )public final native void notify( )public final native void notifyAll( ) 调用 getDeclaredMethods() 方法 打印信息中，输出的都是 SonClass 类的方法，不问访问权限。 123456类的名称：obj.SonClassprivate int getSonAge( )private void setSonAge( int arg0, )public void printSonMsg( )private void setSonName( java.lang.String arg0, )private java.lang.String getSonName( ) 三、访问或操作类的私有变量和方法在上面，我们成功获取了类的变量和方法信息，验证了在运行时 动态的获取信息 的观点。那么，仅仅是获取信息吗？我们接着往后看。 都知道，对象是无法访问或操作类的私有变量和方法的，但是，通过反射，我们就可以做到。没错，反射可以做到！下面，让我们一起探讨如何利用反射访问 类对象的私有方法 以及修改 私有变量或常量。 老规矩，先上测试类。 注： 请注意看测试类中变量和方法的修饰符（访问权限）； 测试类仅供测试，不提倡实际开发时这么写 : ) TestClass.java 123456789101112public class TestClass &#123; private String MSG = "Original"; private void privateMethod(String head , int tail)&#123; System.out.print(head + tail); &#125; public String getMsg()&#123; return MSG; &#125;&#125; 3.1 访问私有方法以访问 TestClass 类中的私有方法 privateMethod(...) 为例，方法加参数是为了考虑最全的情况，很贴心有木有？先贴代码，看注释，最后我会重点解释部分代码。 1234567891011121314151617181920212223242526272829/** * 访问对象的私有方法 * 为简洁代码，在方法上抛出总的异常，实际开发别这样 */private static void getPrivateMethod() throws Exception&#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有方法 //第一个参数为要获取的私有方法的名称 //第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null //方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125; Method privateMethod = mClass.getDeclaredMethod("privateMethod", String.class, int.class); //3\. 开始操作方法 if (privateMethod != null) &#123; //获取私有方法的访问权 //只是获取访问权，并不是修改实际权限 privateMethod.setAccessible(true); //使用invoke反射调用私有方法 //privateMethod是获取到的私有方法 //testClass要操作的对象 //后面两个参数传实参 privateMethod.invoke(testClass, "Java Reflect ", 666); &#125;&#125; 需要注意的是，第 3 步中的 setAccessible(true) 方法，是获取私有方法的访问权限，如果不加会报异常 IllegalAccessException，因为当前方法访问权限是 “private” 的，如下： 1java.lang.IllegalAccessException: Class MainClass can not access a member of class obj.TestClass with modifiers "private" 正常运行后，打印如下，调用私有方法成功： 1Java Reflect 666 3.2 修改私有变量以修改 TestClass 类中的私有变量 MSG 为例，其初始值为 “Original” ，我们要修改为 “Modified”。老规矩，先上代码看注释。 12345678910111213141516171819202122232425262728/** * 修改对象私有变量的值 * 为简洁代码，在方法上抛出总的异常 */private static void modifyPrivateFiled() throws Exception &#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3\. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 此处代码和访问私有方法的逻辑差不多，就不再赘述，从输出信息看出 修改私有变量 成功： 12Before Modify：MSG = OriginalAfter Modify：MSG = Modified 3.3 修改私有常量在 3.2 中，我们介绍了如何修改私有 变量，现在来说说如何修改私有 常量， 01. 真的能修改吗？常量是指使用 final 修饰符修饰的成员属性，与变量的区别就在于有无 final 关键字修饰。在说之前，先补充一个知识点。 Java 虚拟机（JVM）在编译 .java 文件得到 .class 文件时，会优化我们的代码以提升效率。其中一个优化就是：JVM 在编译阶段会把引用常量的代码替换成具体的常量值，如下所示（部分代码）。 编译前的 .java 文件： 123456//注意是 String 类型的值private final String FINAL_VALUE = "hello";if(FINAL_VALUE.equals("world"))&#123; //do something&#125; 编译后得到的 .class 文件（当然，编译后是没有注释的）： 12345private final String FINAL_VALUE = "hello";//替换为"hello"if("hello".equals("world"))&#123; //do something&#125; 但是，并不是所有常量都会优化。经测试对于 int 、long 、boolean 这些基本类型 JVM 会优化，而对于 Integer 、Long 、Boolean 这种包装类型，或者其他诸如 Date 、Object 类型则不会被优化。 总结来说：对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值。 这么说来，在实际开发中，如果我们想修改某个类的常量值，恰好那个常量是基本类型的，岂不是无能为力了？反正我个人认为除非修改源码，否则真没办法！ 这里所谓的无能为力是指：我们在程序运行时刻依然可以使用反射修改常量的值（后面会代码验证），但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了。 下面我们验证这一点，在测试类 TestClass 类中添加如下代码： 1234567//String 会被 JVM 优化private final String FINAL_VALUE = "FINAL";public String getFinalValue()&#123; //剧透，会被优化为: return "FINAL" ,拭目以待吧 return FINAL_VALUE;&#125; 接下来，是修改常量的值，先上代码，请仔细看注释： 12345678910111213141516171819202122232425262728293031323334353637/** * 修改对象私有常量的值 * 为简洁代码，在方法上抛出总的异常，实际开发别这样 */private static void modifyFinalFiled() throws Exception &#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有常量 Field finalField = mClass.getDeclaredField("FINAL_VALUE"); //3\. 修改常量的值 if (finalField != null) &#123; //获取私有常量的访问权 finalField.setAccessible(true); //调用 finalField 的 getter 方法 //输出 FINAL_VALUE 修改前的值 System.out.println("Before Modify：FINAL_VALUE = " + finalField.get(testClass)); //修改私有常量 finalField.set(testClass, "Modified"); //调用 finalField 的 getter 方法 //输出 FINAL_VALUE 修改后的值 System.out.println("After Modify：FINAL_VALUE = " + finalField.get(testClass)); //使用对象调用类的 getter 方法 //获取值并输出 System.out.println("Actually ：FINAL_VALUE = " + testClass.getFinalValue()); &#125;&#125; 上面的代码不解释了，注释巨详细有木有！特别注意一下第 3 步的注释，然后来看看输出，已经迫不及待了，擦亮双眼： 123Before Modify：FINAL_VALUE = FINALAfter Modify：FINAL_VALUE = ModifiedActually ：FINAL_VALUE = FINAL 结果出来了: 第一句打印修改前 FINAL_VALUE 的值，没有异议； 第二句打印修改后常量的值，说明FINAL_VALUE确实通过反射修改了； 第三句打印通过 getFinalValue() 方法获取的 FINAL_VALUE 的值，但还是初始值，导致修改无效！ 这结果你觉得可信吗？什么，你还不信？问我怎么知道 JVM 编译后会优化代码？那要不这样吧，一起来看看 TestClass.java 文件编译后得到的 TestClass.class 文件。为避免说代码是我自己手写的，我决定不粘贴代码，直接截图： TestClass.class 文件 看到了吧，有图有真相，getFinalValue() 方法直接 return &quot;FINAL&quot;！同时也说明了，程序运行时是根据编译后的 .class 来执行的。 顺便提一下，如果你有时间，可以换几个数据类型试试，正如上面说的，有些数据类型是不会优化的。你可以修改数据类型后，根据我的思路试试，看输出觉得不靠谱就直接看 .classs 文件，一眼就能看出来哪些数据类型优化了 ，哪些没有优化。下面说下一个知识点。 02. 想办法也要修改！不能修改，这你能忍？别着急，不知你发现没，刚才的常量都是在声明时就直接赋值了。你可能会疑惑，常量不都是在声明时赋值吗？不赋值不报错？当然不是啦。 方法一 事实上，Java 允许我们声明常量时不赋值，但必须在构造函数中赋值。你可能会问我为什么要说这个，这就解释： 我们修改一下 TestClass 类，在声明常量时不赋值，然后添加构造函数并为其赋值，大概看一下修改后的代码（部分代码 ）： 1234567891011public class TestClass &#123; //...... private final String FINAL_VALUE; //构造函数内为常量赋值 public TestClass()&#123; this.FINAL_VALUE = "FINAL"; &#125; //......&#125; 现在，我们再调用上面贴出的修改常量的方法，发现输出是这样的： 123Before Modify：FINAL_VALUE = FINALAfter Modify：FINAL_VALUE = ModifiedActually ：FINAL_VALUE = Modified 纳尼，最后一句输出修改后的值了？对，修改成功了！想知道为啥，还得看编译后的 TestClass.class 文件的贴图，图中有标注。 解释一下：我们将赋值放在构造函数中，构造函数是我们运行时 new 对象才会调用的，所以就不会像之前直接为常量赋值那样，在编译阶段将 getFinalValue() 方法优化为返回常量值，而是指向 FINAL_VALUE ，这样我们在运行阶段通过反射修改敞亮的值就有意义啦。但是，看得出来，程序还是有优化的，将构造函数中的赋值语句优化了。再想想那句 程序运行时是根据编译后的 .class 来执行的 ，相信你一定明白为什么这么输出了！ 方法二 请你务必将上面捋清楚了再往下看。接下来再说一种改法，不使用构造函数，也可以成功修改常量的值，但原理上都一样。去掉构造函数，将声明常量的语句改为使用三目表达式赋值： 12private final String FINAL_VALUE = null == null ? "FINAL" : null; 其实，上述代码等价于直接为 FINAL_VALUE 赋值 “FINAL”，但是他就是可以！至于为什么，你这么想：null == null ? &quot;FINAL&quot; : null 是在运行时刻计算的，在编译时刻不会计算，也就不会被优化，所以你懂得。 总结来说，不管使用构造函数还是三目表达式，根本上都是避免在编译时刻被优化，这样我们通过反射修改常量之后才有意义！好了，这一小部分到此结束！ 最后的强调： 必须提醒你的是，无论直接为常量赋值 、 通过构造函数为常量赋值 还是 使用三目运算符，实际上我们都能通过反射成功修改常量的值。而我在上面说的修改 “成功” 与否是指：我们在程序运行阶段通过反射肯定能修改常量值，但是实际执行优化后的 .class 文件时，修改的后值真的起到作用了吗？换句话说，就是编译时是否将常量替换为具体的值了？如果替换了，再怎么修改常量的值都不会影响最终的结果了，不是吗？。 其实，你可以直接这么想：反射肯定能修改常量的值，但修改后的值是否有意义？ 03. 到底能不能改？到底能不能改？也就是说反射修改后到底有没有意义？ 如果你上面看明白了，答案就简单了。俗话说 “一千句话不如一张图”，下面允许我用不太规范的流程图直接表达答案哈。 注：图中 “没法修改” 可以理解为 “能修改值但没有意义”；”可以修改” 是指 “能修改值且有意义”。 判断能不能改 四、总结好了，本次记录就到这儿了，突然不知不觉发现写了好多，感谢耐心听我叨逼完。我想这篇博客如果你认真的看完，肯定会有收获的！最后，因为内容较多，知识点较多，如果文中有任何错误或欠妥的地方，还望指正。欢迎留言交流！ 原文：https://juejin.im/post/598ea9116fb9a03c335a99a4]]></content>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第6章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-3%2F</url>
    <content type="text"><![CDATA[第六章：接口、lambda 表达式与内部类6.1 接口6.1.1 接口概念在 Java 中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。例如：Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了 Comparable 接口。 12345//这是 Comparable 的代码public interface Comparable&lt;T&gt;&#123; int compareTo(T other);&#125; 接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字 public。接口可以定义常量，接口绝不能含有实例域。 Comparable int compareTo(T other)：建议实现用这个对象与 other 进行比较。如果这个对象小于 other 则返回负值；如果相等则返回 0；否则返回正值。 Arrays static void sort(Object[] a)：使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了 Comparable 接口的类，并且元素之间必须是可比较的。 Integer &amp; Double static int compare(int x, int y) static int compare(double x, double y) x y 返回 1 6.1.2 接口的特性接口不是类，尤其不能使用 new 实例化一个接口。然而，尽管不能构造接口的对象，却能声明接口的变量：Comparable x;接口变量必须引用了实现接口的类对象：x = new Employee()接下来，可以使用 instanceof 检测一个对象是否实现了某个特定的接口if(anObject instanceof Comparable)接口可以实现继承，而且可以多继承。虽然在接口中不能包含实例域或静态方法，却可以包含常量，接口中的域将被自动设为 public static final。尽管每个类只能拥有一个父类，但却可以实现多个接口。 6.1.3 接口与抽象类接口与抽象类的目的差不多，都想让实现类实现自己的抽象方法，但 Java 是单继承的，如果没有接口，只有抽象类，那一个类继承完抽象类后，就不能再继承其他类了，所以接口显得更加灵活。 6.1.4 静态方法在 Java8 中，允许在接口中添加静态方法。 6.1.5 默认方法可以为接口方法提供一个默认实现。必须用 default 修饰符标记这个方法。不过一般没有什么作用，因为实现了接口的类往往会重新实现这个方法，如果设置了 default，那么在实现接口的时候就不会强制要求你实现这个抽象方法了。 123default int compareTo(Object other) &#123; return 0; &#125; 6.1.6 解决默认方法冲突如果先在一个接口中将一个方法定义为默认方法，然后又在父类或另一个接口中定义了同样的方法，会发生什么情况？ 父类优先。如果父类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。 接口冲突。如果一个父接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须 override 这个方法来解决冲突。 12345678910111213141516//两个接口，同样的方法，一个设置为 default public interface Named &#123; default String getName() &#123; return &quot;d&quot;; &#125;&#125;interface Person &#123; String getName();&#125;//当你同时实现这两个接口的时候，编译器会强制要求你实现一个 getName() 方法//而不是直接使用 Named 的 default 方法class Student implements Named,Person&#123;&#125; 那么父类和接口拥有同样的方法会发生什么呢？ 123456789101112131415public interface Named &#123; default String getName() &#123; return &quot;d&quot;; &#125;&#125;public class Student extends Person implements Named &#123;&#125;class Person &#123; public String getName() &#123; return &quot;superClass&quot;; &#125;&#125; 此时的话，是 “类优先” 的，无论 Named 的方法加不加 default，父类的方法都会 override 接口的方法。 6.2 接口示例6.2.1 接口与回调回调 (callback) 是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。 6.2.2 Comparator(比较器) 接口之前我们已经了解了如何对一个对象数组排序，前提是这些对象是实现了 Comparator 接口的类的实例。例如，可以对一个字符串数组排序，因为 String 类实现了 Comparable&lt;String&gt;，而且 String.compareTo 方法可以对字典顺序比较字符串。 1234567public static void main(String[] args) &#123; String[] staff = &#123; "fgfgfgf", "v", "zdgdgdgdgdgdgdg", "adgdgdgfgdgdgdgdgdg", "d", "m", "q" &#125;; Arrays.sort(staff); System.out.println(Arrays.toString(staff)); &#125; //[adgdgdgfgdgdgdgdgdg, d, fgfgfgf, m, q, v, zdgdgdgdgdgdgdg] //是用字典顺序规律排序的，无视长度 假设我们现在希望用长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序，如果要实现这种情况，可以选用 Arrays.sort 方法的第二个版本，有一个数组和一个比较器 (comparator) 作为参数，comparator 是实现了 Comparator 接口的类的实例。 12345678910111213141516171819public class LengthComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String s, String t1) &#123; return s.length() - t1.length(); &#125;&#125;public class EmployeeSortTest &#123; public static void main(String[] args) &#123; String[] staff = &#123; "fgfgfgf", "v", "zdgdgdgdgdgdgdg", "adgdgdgfgdgdgdgdgdg", "d", "m", "q" &#125;; Arrays.sort(staff); System.out.println(Arrays.toString(staff)); Arrays.sort(staff, new LengthComparator()); System.out.println(Arrays.toString(staff)); &#125;&#125;//[adgdgdgfgdgdgdgdgdg, d, fgfgfgf, m, q, v, zdgdgdgdgdgdgdg]//[d, m, q, v, fgfgfgf, zdgdgdgdgdgdgdg, adgdgdgfgdgdgdgdgdg] 6.2.3 对象克隆本节会讨论 Cloneable 接口，这个接口指示一个类提供了一个安全的 clone 方法。(克隆并不太常见，可以稍作了解，等真正需要时再深入学习)。先来回忆为一个包含对象引用的变量建立副本时会发生什么。原变量和副本都是同一个对象的引用。这说明，任何一个变量改变都会影响另一个变量。 123Employee original = new Employee("John Public", 50000); Employee copy = original; copy.raiseSalary(10); 此时，改变 copy 的状态，就会改变 original 的状态。如果我们希望 copy 是一个新对象，它的初始状态与 original 相同，但是之后它们各自会有自己不同的状态，这种情况下就可以使用 clone 方法。 1234Employee original = new Employee("John Public", 50000); Employee copy =original.clone(); copy.raiseSalary(10); //此时 original 不会发生改变 不过并没有这么简单。clone 方法是 Object 的一个 protected 方法，如果我们使用从 Object 继承得到的 clone 方法，从 A 克隆出一个 B 的话，它们的域如果都是基本数据类型的话，那么是可以实现互不干涉的，但是假设它们的域中包含引用对象，那么 A 和 B 的引用对象域仍然会存在共享的情况。这种默认的 clone 操作叫做浅拷贝，存在缺陷。不过，通常子对象都是可变的，必须重新定义 clone 方法来建立一个深拷贝，同时克隆所有子对象。对于一个类需要确定： 默认的 clone 方法是否满足要求； 是否可以在可变的子对象上调用 clone 来修补默认的 clone 方法； 是否不该使用 Clone。如果选择第 1 项或第 2 项，类必须： 实现 Cloneable 接口 重新定义 clone 方法，并指定 public 修饰符。Cloneable 接口是 Java 提供的一组标记接口 (tagging interface) 之一。也可以称为记号接口 (marker interface)。 即使 clone 的浅拷贝用法也能够满足要求，还是需要实现 Cloneable 接口，将 clone 重新定义为 public，再调用 super.clone()。下面是个例子。 123456class Employee implements Cloneable&#123;@Override public Employee clone() throws CloneNotSupportedException &#123; return (Employee) super.clone(); &#125; &#125; 下面来看一个深拷贝的 clone 方法的例子： 123456@Overridepublic CloneTest clone() throws CloneNotSupportedException &#123; CloneTest copy = (CloneTest) super.clone(); copy.mEmployee = mEmployee.clone(); return copy;&#125; 另外，所有数组类型都有一个 public 的 clone 方法，而不是 protected。可以用这个方法建立一个新数组，包含原数组所有元素的副本，例如： 123int[] luckyNumbers= &#123;2,3,5,7,11,13&#125;int[] cloned = luckyNumbers.clone();cloned[5] = 12; //不会改变 luckyNumbers[5] 的数值 6.3 lambda 表达式了解如何使用 lambda 表达式采用一种简洁的语法定义代码块，以及如何编写处理 lambda 表达式的代码。 6.3.1 为什么引入lambda表达式lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。在 Java 中，不能直接传递代码块。必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。lambda 的设计，是为了解决 Java 如何做到函数式编程。 6.3.2 lambda 表达式的语法(String first, String second) -&gt; first.length() - second.length()参数，箭头 → 以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 {} 中，并包含显式的 return 语句。例如： 123456(String first, String second) -&gt;&#123; if(first.length() &lt; second.length()) return -1; else if(first.length() &gt; second.length()) return 1; else return 0;&#125; 即使 lambda 表达式没有参数，仍然要提供空括号，就像无参数方法一样 1() -&gt; &#123;for (int i=100;i&gt;=0;i--) System.out.println(i);``&#125; 如果可以推导出一个 lambda 表达式的参数类型，则可以忽略其类型。例如： 1Comparator&lt;String&gt; comp = (first, second) -&gt;first.length() - second.length(); 在这里，编译器可以推导出 first 和 second 必然是字符串，因为这个 lambda 表达式将赋给一个字符串比较器。如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号； 1ActionListener listener = event -&gt; System.out.println(&quot;The time is&quot; +new Date()&quot;); 无需指定 lambda 表达式的返回类型。lambda 表达式的返回类型总是由上下文推导得出。(String first, String second) -&gt; first.length() - second.length()，可以在需要 int 类型结果的上下文中使用。 1234567891011public static void main(String[] args) &#123; String[] planets = new String[] &#123; "Mercury", "Venus", "Earth", "Jupiter", "Saturn", "Uranus", "Neptune" &#125;; System.out.println(Arrays.toString(planets)); System.out.println("Sorted in dictionary order:"); Arrays.sort(planets); System.out.println(Arrays.toString(planets)); System.out.println("Sorted by length"); Arrays.sort(planets, (first, second) -&gt; first.length() - second.length()); System.out.println(Arrays.toString(planets)); &#125; 6.3.3 函数式接口对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式。这种接口称为函数式接口 (functionnal interface)。最好把 lambda 表达式看作是一个函数，而不是一个对象，另外要接受 lambda表达式可以传递到函数式接口。lambda 表达式可以转换为接口，这一点让 lambda 表达式很有吸引力。 12//这是将 lambda 转换为函数式接口的例子BiFunction&lt;String, Integer, Boolean&gt; comp = (name, age) -&gt; name.length() &gt; age; ArrayList 类有一个 removeIf 方法，它的参数就是一个 Predicate。public interface Predicate&lt;T&gt; {boolean test(T t);}，这也是一个函数式接口，所以我们可以使用 lambda。 1234567891011121314ArrayList&lt;String&gt; a = new ArrayList&lt;&gt;(); a.add(null); a.add(null); a.add(null); a.add(null); a.add("dsada"); a.add("czxzd"); a.add("gadga"); a.add("zcbzc"); a.removeIf(e -&gt; e == null); for (int i = 0; i &lt; a.size(); i++) &#123; System.out.println(a.get(i)); &#125; //Predicate 的泛型是根据 ArrayList 的泛型的，这里的代码就是将 ArrayList 中的 null 值都删除了。 6.3.4 方法引用有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。Timer t = new Timer(10000,System.out::println), 等价于 x -&gt; System.out.println(x)再来看一个例子，假设你想对字符串排序，而不考虑字母的大小写。可以传递以下方法表达式：Arrays.sort(strings,String::compareToIgonreCase)从这些例子可以看出，要用 :: 操作符分隔方法名与对象或类名。主要有 3 种情况： object::instanceMethod Class::staticMethod Class::instanceMethod在前 2 种情况种，方法引用等价于提供方法参数的 lambda 表达式。前面已经提到，System.out::println 等价于 x -&gt; System.out.println(x)。类似地，Math::pow 等价于 (x,y) -&gt;Math.pow(x,y)。对于第 3 种情况，第 1 个参数会成为方法的目标。例如，String::compareToIgnoreCase 等同于 (x,y) -&gt; x.compareToIgnoreCase(y)。可以在方法引用中使用 this 参数。例如，this::equals 等同于 x-&gt; this.equals(x)。使用 super 也是合法的。下面的方法表达式super:instanceMethod 6.3.5 构造器引用构造器引用与方法引用很类似，只不过方法名为 new。例如，Person::new 是 Person 构造器的一个引用。哪一个构造器呢？这取决于上下文。 12345678public static void main(String[] args) &#123; ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); Stream&lt;Person&gt; stream = names.stream().map(Person::new); &#125;&#125;class Person &#123; Person(String name) &#123; 重点是 map 方法会为各个列表元素调用 Person(String) 构造器。可以用数组类型建立构造器引用。例如，int[]::new 是一个构造器引用，它有一个参数：即数组的长度。这等价于 lambda 表达式 x -&gt; new int[x]。 123456@FunctionalInterface interface Fuck &#123; int[] createIntegerArray(int length);&#125;public static void main(String[] args) &#123; Fuck fuck = int[]::new; &#125; Java 有一个限制，无法构造泛型类型 T 的数组。数组构造器引用对于客服这个限制很有用。表达式 new T[n] 会产生错误，因为这会改为 new Object[n]。不过 toArray 有一个重载方法，引用一个函数式接口，解决了这个问题。 1&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; var1); 6.3.6 变量作用域通常，你可能希望能够在 lambda 表达式中访问外围方法或类中的变量。 12345public static void repeatMessage(String test, int delay) &#123; ActionListener listener = event -&gt; System.out.println(test);//这里只是实现了接口的方法而已，并没有马上调用 test = "Change";//当我们改变test值的时候，编译器会报错 &#125; Variable used in lambda expression should be final or effectively final lambda 表达式有 3 个部分： 一个代码块 参数 自由变量的值，这是指非参数而且不在代码中定义的变量。在我们的代码中，lambda 有 1 个自由变量 test。表示lambda的数据结构必须存储自由变量的值。在这里就是字符串 test。我们说它被 lambda 捕获 (captured)。例如，可以把一个 lambda 转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中。关于代码块以及自由变量值有一个术语：闭包 (closure)，在 Java 中，lambda 表达式就是闭包。在 lambda 中，只能引用值不会改变的变量，也不能在 lambda 中改变自由变量的值。在一个 lambda 中使用 this 关键字时，是指创建这个 lambda 的方法的 this 参数。 12345678910public class Application()&#123; public void init() &#123; ActionListener listener = event -&gt; &#123; System.out.println(this.toString()); &#125; &#125;&#125; 这里会调用 Application 对象的 toString 方法，而不是 ActionListener 实例的方法。 6.3.7 处理 lambda 表达式下面来看如何编写方法处理 lambda 表达式。使用 lambda 的重点是延迟执行 (deferred execution)。之所以希望以后再执行代码，这有很多原因 在一个单独的线程中运行代码 多次运行代码 在算法适当位置运行代码 发生某种情况执行代码，点击了一个按钮，数据到达，等等 只在必要时才运行代码可以为你自己设计的函数式接口打上 @FunctionalInterface 标记。 6.4 内部类内部类 (inner class) 是定义在另一个类中的类，为什么要使用内部类呢？ 内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据。 内部类可以对同一个包中的其他类隐藏起来 当想要定义一个回调函数且不想编写大量代码时，使用匿名 (anonymous) 内部类比较便捷。 6.4.1 使用内部类访问对象状态1234567891011121314151617181920public class TalkingClock &#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) &#123; this.interval = interval; this.beep = beep; &#125; public void start() &#123; &#125; public class TimePrinter implements ActionListener &#123; String name; @Override public void actionPerformed(ActionEvent actionEvent) &#123; &#125; &#125;&#125; 需要注意，这里的 TimePrinter 类位于 TalkingClock 类内部。这并不意味着每个 TalkingClock 都有一个 TimePrinter 实例域。TimePrinter 是内部类，内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。这个引用在内部类的定义中是不可见的，我们可以将外围类对象的引用假想为 outer，那么当我们在 TimePrinter 类中使用 beep 变量时，与 outer.beep 是等价的。 6.4.2 内部类的特殊语法规则OuterClass.this 表示外部类引用。例如：TalkingClock.this.beep反过来，可以采用下列语法格式更加明确地编写内部对象的构造器ActionListener listener = this.new TimePrinter();如果 TimePrinter 是一个公有内部类，我们就可以在任何地方创建内部类的对象。 123TalkingClock clock = new TalkingClock(1000, true); clock.start(); TalkingClock.TimePrinter a = clock.new TimePrinter(); 在外部类的作用域之外，可以这样引用内部类：OuterClass.InnerClass。 6.4.3 内部类是否有用，必要和安全内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $ 分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。 6.4.4 局部内部类如果仔细阅读以下之前的实例代码会发现，TimePrinter 这个类名字只在 start 方法中创建这个类型的对象时使用了一次。当遇到这类情况时，可以在一个方法中定义局部类。 1234567891011public void start() &#123; class TimePrinter implements ActionListener &#123; String name; @Override public void actionPerformed(ActionEvent actionEvent) &#123; System.out.println("At the tone, the time is" + new Date()); if (beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125; &#125; 局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。局部类有一个优势，对外部世界可以完全地隐藏起来。 6.4.5 由外部方法访问变量局部类不仅能够访问包含它们的外部类，还可以访问局部变量，不过那些局部变量必须事实上为 final。 6.4.6 匿名内部类假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类 (anonymous inner class)。通用的语法格式为： 1234new SuperType(construction parameters)&#123; inner class methods and date&#125; 还可以这样构造一个数组列表 1init(new ArrayList&lt;String&gt;() &#123;&#123;add(&quot;Harry&quot;);add(&quot;Tony&quot;);&#125;&#125;); 6.4.7 静态内部类有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并需要内部类引用外部类对象，为此，可以将内部类声明为 static，以便取消产生的引用。 6.5 代理proxy，利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才由必要使用。 6.5.1 何时使用代理假设由一个表示接口的 Class 对象，它的确切类型在编译时无法指定，要想构造一个实现这些接口的类，就需要使用 newInstance 方法或反射找出这个类的构造器。但是，不能实例化一个接口，需要在程序处于运行状态时定义一个新类。代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法： 指定接口所需要的全部方法 Object 类中的全部方法，例如，toString、equals 等。然而，不能在运行时定义这些方法的新代码，而是要提供一个调用处理器 (invocation handler)。是实现了 InvocationHandler 接口的类对象。在这个接口中只有一个方法：Object invoke(Object proxy,Method method, Object[] args) 6.5.2 创建代理对象要想创建一个代理对象，需要使用 Proxy 类的 newProxyInstance 方法。这个方法需要三个参数。 一个类加载器 一个 Class 对象数组，每个元素都是需要实现的接口 一个调用处理器 123456789101112131415161718192021222324252627282930313233343536public class ProxyTest &#123; public static void main(String[] args) &#123; Object[] elements = new Object[1000]; for (int i = 0; i &lt; elements.length; i++) &#123; Integer value = i + 1; InvocationHandler handler = new TraceHandler(value); Object proxy = Proxy.newProxyInstance(null, new Class[] &#123; Comparable.class &#125;, handler); elements[i] = proxy; &#125; Integer key = new Random().nextInt(elements.length) + 1; int result = Arrays.binarySearch(elements,key); if(result&gt;=0)System.out.println(elements[result]); &#125;&#125;class TraceHandler implements InvocationHandler &#123; private Object target; public TraceHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; System.out.print(target); System.out.print(&quot;.&quot; + method.getName() + &quot;(&quot;); if (objects != null) &#123; for (int i = 0; i &lt; objects.length; i++) &#123; System.out.print(objects[i]); if (i &lt; objects.length - 1) System.out.print(&quot;,&quot;); &#125; &#125; System.out.println(&quot;)&quot;); return method.invoke(target, objects); &#125;&#125; 总结 接口有三个主要作用：①定义 / 描述统一的的业务方法规范，作为参数，传递实现类给别人调用；②自己默认实现好逻辑交给他人备用，在该回调的时候触发回调；③作为标签接口，标注某一种类型，如 Serializable、Cloneable 等。 接口中的所有实例域属于 public static final 的，所有方法属于 public 的，不能含有实例域。接口和抽象类的本质区别是接口是为了描述一组行为，抽象类是实现，可作为父类完成一部分统一功能，可变部分交给子类去实现。 Java8 中允许接口含有静态方法。default 关键字提供默认方法，提供默认方法后实现类就可以不用全实现每个方法，可以复写该实现的方法。 方法冲突时两个原则：①超类和接口的默认方法冲突时，始终超类优先；②两个接口的默认方法冲突时，只要有其中任一个方法被默认实现了，子类就要选择性复写该方法 (Person.super.getName())，会影响到每个接口。 对象的拷贝：引用赋值指创建一个栈内存引用，指向一个堆内存实际对象，然后另一个引用也指向这个堆内存，那么修改堆内存的对象对两个引用都是有影响的；拷贝是指完全克隆出一个独立的堆内存对象，这样修改旧不影响两个引用了。• 浅拷贝：对象的基本数据类型可以拷贝，但是子引用类型没有被拷贝，还是同一个引用，两个引用还是会共享一些信息，修改时会影响两个引用。• 深拷贝：对象的基本数据类型和引用数据类型都被拷贝，改变 clone 对象的值不会影响原对象。 对象的克隆：• Object 的clone()方法是 protected 的，默认是浅拷贝，返回 Object。如果对象想实现克隆，需要实现 Cloneable 接口和重写 clone() 方法，指定为 public，且手动实现深拷贝，创建所有子引用类型并返回。• Cloneable 只是一个标记接口，没有任何方法，实现它只是为了标记一下该类具有克隆能力，instanceof可以通过。实现深拷贝的话该类和类中的引用类型都要实现 Cloneable 接口。• 即使clone()的默认浅拷贝可以实现需求，也得重写改为 public 才能调用，一般可以先super.clone()拿到原父类返回的浅拷贝引用，再重定义对象里每个引用变量的值 (实现深拷贝)，并返回这个克隆对象。ps：使用 Gson 序列化反序列化也能实现克隆功能。 lambda 表达式：• lambda 表达式是一个可传递的代码块，可以在以后反复执行一次或多次，用于代替只有一个方法的接口。表现形式：参数，箭头(-&gt;)以及一个表达式。(没有参数要提供空 ()，只有一个参数可不带 ()，表达式多行可用 {}，不用指定返回类型)• lambda 表达式中不能只在一个分支返回值而在其他分支不返回。lambda 表达式中引用的外部自由变量的值必须是不可改变的。lambda 表达式中 this 关键字指的是外围原对象 this。• lambda 表达式表现的就是一个函数式接口，但 Java 是不能直接传递方法的引用的，其实还是封装了一层，内部应该也是传递对象的引用。 方法的引用：&quot;::&quot;操作符分割对象或类名与方法名，如Class::Method/object::Method。构造器引用如Class::new。 内部类：• 定义：表示一种类之间的嵌套关系，而不是对象。解决命名控制和访问控制问题。内有内部类可以是私有的，外部类必须是包可见性或共有的。• 构造方式：Outer.inner in = new Outer.inner()或Outer.inner = outer.new Inner()。• 特点：可以访问自身数据域，也可访问外围数据域；内部类中所有静态域必须是 final 类型的；内部类初始化时都会包含一个外部类的隐式引用，以便访问外部类的域和方法，因此说内部类会持有外部类的引用。• 由于内部类会持有外部类的引用，因此在 Activity 中一般定义 Handler 的时候，如果进行耗时操作，handler 中持有外部 Activity，且 Handler 不会被销毁，这就可能会引起内存泄露 (Act 该销毁却没被销毁)。• 特殊：局部内部类是定义在方法中的，不能有任何修饰符，对外部世界完全隐藏，访问的外部类实例域必须是 final 的 (匿名内部类也是)。• 匿名内部类多用于传递方法参数中的接口，无构造方法，需要在后面加 {}内实现内部需要实现的方法。ArrayList 的双括号初始化 {{ }} 可构造出有初始化数据的 List。• 静态内部类不需要引用外围类对象，将内部类声明为 static，可以取消产生的引用。如果内部类不需要访问外围类的实例域，最好声明为静态内部类。静态内部类可以有静态域和方法。 动态代理 (proxy)：• 定义：可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用，代理类可以在运行时创建全新的类。• 作用：代理的作用的是中间层，代理的是接口、方法，而不是对象，对于原本的对象和原方法的实现逻辑是可有可无的。代理的 invocationHandler 拿到方法后可以自己做逻辑处理，因此代理就是一个使用过程中的中间层替换作用。• 应用场景：①只有接口，没有实现类时 (编译期还不知道要怎么实现) 时，使用代理可以动态创建出这些接口的实现类，在每个接口方法被调用时，动态去实现相应的业务逻辑。如 Retrofit 中对 Api 类的解析。②如果某个接口已经有实现类，并在工厂方法中返回了该实现类，如果需要对原本的实现逻辑前后加一些自己的业务逻辑，可以在工厂方法中 Proxy.newInsrance 创建代理类，实现自己新增的一些逻辑后将代理类返回，这时候可以把原来的类作为参数传入 invocationHandler，原本的处理逻辑还是用原来的类去执行的。③我们可以模仿 Retrofit，定义业务接口，通过注解添加各种动态业务条件，然后在代理类invoke()中分析方法并做各种动态处理，提高了业务逻辑的灵活性。• 使用：Proxy.newInstance(Classloader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)。InvocationHandler 中的invoke()方法会统一所有接口方法的调用回调，在此能拿到 method 以及参数 args，可以做自己对方法的实现逻辑。如果需要用到原对象和实现逻辑，可以把原对象也传进来。• 特点：①代理类一旦被创建就和普通类没啥区别了；代理类本身只有一个实例域——调用处理器，因此任何附加数据和原对象实例都要传到调用处理器中去使用。②代理类一定是 public 和 final，可以用 isProxyClass() 方法检测一个特定的 Class 对象是否代表一个代理类。重点：P225 对象的克隆 P258 代理 注意：代理与反射的区别是，反射构建对象时已经有该类的，只是动态去创建一个已存在类的实例；而代理是针对接口的，编译时还没该接口的具体实现类，因此动态去构建实现类和方法的实现逻辑，所有接口方法的分析都做好了放到 invoke 里的 method 里了，相当于在方法调用处加了统一的监听。 参考：https://www.jianshu.com/p/559d35944079https://www.kancloud.cn/zhangzihao/read-java-core/352483]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第5章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-2%2F</url>
    <content type="text"><![CDATA[第五章：继承（inheritance）利用继承，我们可以基于已存在的类构造一个新类。本章还会介绍反射 (reflection) 的概念，反射是指在程序运行期间发现更多的类及其属性的能力。 5.1 类、超类和子类继承主要是为了重用代码，也表明了 is-a 的关系。 5.1.1 定义子类关键字 extends 表示继承。 1234public class Manager extends Employee&#123;&#125; 可以用下面几个单词来表示父类和子类 父类：superclass、base class、parent class 子类：subclass、derived class、childclass在 Java 中，子类的功能往往比父类的功能强大。应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。 5.1.2 覆盖方法当子类从父类继承得到的方法，并不适用于子类的时候，就需要使用覆盖 (override)。super 关键字可以帮助我们在子类中调用父类的方法 (因为父类的方法会被继承，而我们将继承的方法重写了，这时候方法名是相同，但执行的代码不同，所以需要用到 super)，如 super.doSomething()。在覆盖一个方法的时候，子类方法不能低于父类方法的可见性。 5.1.3 子类构造器当调用子类构造器时，如果没有显式地使用 super(name,salary,year,month) 来执行父类的构造器，那么就会隐式地调用父类无参的构造器。使用 super 调用构造器的语句必须是子类构造器的第一条语句。一个对象变量可以指示多种实际类型的现象被称为多态 (polymorphism)。在运行时能够自动地选择调用哪个方法的现象称为 动态绑定 (dynamic binding)。 5.1.4 继承层次一个父类可以有多个子类，但一个子类只能继承一个父类。 5.1.5 多态多态的特性表明程序中出现父类对象的任何地方都可以用子类对象置换。但反过来是不行的。 5.1.7 阻止继承：final 类和方法有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。类中特定的方法也可以被声明为 final。如果这样做，子类就不能 override 这个方法。(final 类中的所有方法自动地成为 final 方法，不过全局变量是不会变成 final 的)。将方法或类声明为 final 的主要目的是：确保它们不会在子类中改变语义，例如一个变量是 String 对象的引用，那么它一定是一个 String 对象，而不可能是其他类的对象。 5.1.8 强制类型转换将一个类型强制转换成另外一个类型的过程被称为类型转换。将一个子类的引用赋值给一个父类的变量，编译器是允许的。但将一个父类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。我们可以通过 instanceof 来检查。 5.1.9 抽象类为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的，除了抽象方法之外，抽象类还可以包含具体数据和具体方法。例如 Person 类还保存着姓名和一个返回姓名的具体方法。 1234567891011121314public abstract class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; //抽象方法 public abstract String getDescription(); //普通方法 public String getName() &#123; return name; &#125;&#125; extends 抽象类有两种方法： 在抽象类中定义部分抽象方法或不定义抽象方法，这样必须将子类也标记为抽象类 定义全部的抽象方法，这样一来，子类就不是抽象的了。抽象类不能被实例化。但是可以创建一个具体子类的对象。Person p = new Student(&quot;Bob&quot;,&quot;CS&quot;); 5.1.10 受保护访问大家都指定，最好将类中的全局变量标记为 private，而方法标记为 public。然而，有些时候，人们希望父类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为 protected。下面归纳一下 Java 用于控制可见性的 4 个访问修饰符： 仅对本类可见：private 对所有类可见：public 对本包和所有子类可见：protected 对本包可见：default 不需要修饰符 5.2 Object 所有类的超类在 Java 中，每个类都是由它扩展而来的，但是并不需要这样写：public class Employee extends Object如果没有明确地指出超类，Object 就被认为是这个类的超类。在 Java 中，只有基本类型 (primitive types) 不是对象。例如数值、字符和布尔类型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都 extends Object。 1234int a = 1; int[] staff = new int[10]; Object obj2 = a;//其实是将 int 先自动转换为 Integer，然后才成功赋值的。 Object obj = staff; 5.2.1 equals 方法Object 中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用，如果具有，则相等，然而对于大多数类来说，这样的比较不是很有意义，比如两个 Person 类，当我们进行 equlas 的时候，我们希望比较它们的状态，比如姓名，薪水等。我们可以 override 从 Object 继承得到的 equals 方法。 12345678public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return name.equals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.equals(other.hireDay); &#125; //这样写是有漏洞的，因为 name 和 hireDay 是String 类型，可能为null，如果为null，调用equals方法的话就会崩溃，我们可以利用 Object.equals 方法改写。 Object.equals 的另一个 overload 形式是：Object.equals(Object a,Object b) 如果两个参数都为 null，方法将返回 true。如果其中一个参数为 null，则返回 false；否则，如果两个参数都不为 null，则调用 a.equals(b)。利用这个方法，我们可以进行改写。 1return Object.equlas(name,other.name)&amp;&amp;salary==other.salary&amp;&amp;Object.equlas(hireDay,other.hireDay); 5.2.2 相等测试与继承如果隐式和显式的参数不属于同一个类，那么 euqals 方法将如何处理呢？在前面的例子中，如果发现 类不匹配，equals 方法就返回 false。但是许多程序员喜欢使用 instanceof 检测：if(!(otherObject instanceof Employee)) return false;，这是不推荐的写法。Java 要求 equal 方法具有下面的特性： 自反性：对于任何非空引用 x，x.equals(x) 应该返回 true。 对称性：对于任何引用 x 和 y，当且仅当 y.equals(x) 返回 true，x.equals(y) 也应该返回 true 传递性：对于任何引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，x.equals(z) 也应该返回 true。 一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。 对于任意非空引用 x，x.equals(null) 应该返回 false。如果子类能够拥有自己的相等概念，则对称性需要将强制采用 getClass 进行检测。如果由父类决定相等概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。 下面给出编写一个完美的 equals 方法的建议： 显式参数命名为 otherObject，稍后需要将它转换成另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象 if(this == otherObject) return true 检测 otherObject 是否为 null，如果为 null，返回 false。这项检测是很必要的。if (otherObject ==nul )return false; 可选 getClass 或 instanceof 将 otherObject 转换为相应的类类型变量：ClassName other = (ClassName) otherObject 开始比较全局变量。对于数组类型的域，可以使用静态的 Arrays.equals 方法检测相应的数组元素是否相等。 5.2.3 hashCode 方法散列码 (hash code) 是由对象导出的一个整型值。散列码没有规律。如果 x 和 y 是两个不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。如果重新定义 equals 方法，就必须重新定义 hashCode 方法，以便用户可以将对象插入到散列表中。hashCode 方法应该返回一个 int 值 (也可以是附属)，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。 12345public class Employee&#123; public int hashCode()&#123; return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode() &#125;&#125; 下面我们还可以优化一下，使用 Objects.hashCode 方法为对象计算 hash 值，避免空指针。使用基本数据类型对象的静态方法来避免创建多余的对象。 123456public int hashCode()&#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);&#125; 还有更好的写法return Objects.hash(name,salary,hireDay)Equals 和 hashCode 的定义必须一致，如果 x.equals(y) 返回 true，那么 x.hashCode() 就必须与 y.hashCode() 具有相同的值。如果存在数组类型的变量，可以使用静态的 Arrays.hashCode 方法计算一个 hashCode 值，这个散列码由数组元素的散列码组成。Objects API： int hashCode() static int hash(Object… objects) static int hashCode(Object a)，如果为 null 返回 0基本数据类型的对象，Integer|Double… static int hashCode()Arrays API static int hashCode(type[] a) 5.2.4 toString 方法Object 中还有一个重要的方法，就是 toString 方法，它用于返回表示对象值的字符串。一般的格式是：类的名字，随后是一对方括号括起来的域值。下面是 Employee 类中的 toString 方法的实现，我们可以调用 getClass().getName() 获得类名的字符串，而不是将类名硬加到 toString 方法中。 12345678public String toString()&#123; return getClass().getName() + &quot;[name=&quot; + name + &quot;,salary=&quot; + salary + &quot;,hireDay=&quot;+ hireDay + &quot;]&quot;;&#125; Object 类的 toString 方法则是打印类名 + hashCode 值。数组就是继承了 Object.toString 方法，所以如果想获取数组的元素，则可以使用 Arrays.toString；多维数组使用 Arrays.deepToString。 Object &amp;&amp; Class API Object: Class getClass() 返回包含对象信息的类对象 boolean equals(Object otherObject) String toString() Class String getName() 返回这个类的名字 Class getSuperclass() 以 Class 对象的形式返回这个类的超类信息 5.3 泛型数组列表ArrayList 是一个典型的数组列表，如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用 ensureCapacity 方法：staff.ensureCapacity(100)，另外，还可以把初始容量传递给 ArrayList 构造器 ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100)，size 方法将返回数组列表中包含的实际元素数目。例如：staff.size()，一旦能够确认数组列表的大小不再发生变化，就可以调用 trimToSize 方法，这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数量。垃圾回收器将回收多余的存储空间。 5.3.1 访问数组列表元素使用 get 和 set 方法实现访问或改变数组元素的操作，而不使用人们喜欢 [] 语法格式。staff.set(i,harry)使用 add 方法为数组添加新元素，而不要使用 set 方法，它只能替换数组中已经存在的元素内容。下面这个技巧可以一举二得，既可以灵活地扩展数组，又可以方便地访问数组元素。首先，创建一个数组，并添加所有的元素。 123456ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;();while(...)&#123; x = ...; list.add(x);&#125; 执行完上述操作之后，使用 toArray 方法将数组元素拷贝到一个数组中。 12X[] a = new X[list.size()];list.toArray(a); 除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素，使用带索引参数的 add 方法。同样地，也可以从数组列表中间删除一个元素。 123456//addint n = staff.size()/ 2staff.add(n,e);//removeEmployee e = staff.remove(n); 为了插入一个新元素，位于 n 之后的所有元素都要向后移动一个位置。如果删除，位于这个位置之后的所有元素都要向前移动一个位置，并且数组大小减 1。所以对于数组实施插入和删除元素的操作其效率比较低。如果元素数过多，且经常需要在中间位置插入、删除元素，就应该考虑使用链表了。可以使用 for each 循环遍历数组列表。 5.3.2 类型化与原始数组列表的兼容性在确保安全的情况下，可以使用 @SuppressWarnings(&quot;unchecked&quot;) 标记这个变量能够接收类型转换。 5.4 对象包装器与自动装箱有时，需要将 int 这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。这些类称为 包装器 (wrapper) (如 Integer - int)。wrapper 是不可变的，一旦构造了 wrapper，就不允许更改包装在其中的值。同时 wrapper 是 final 修饰的，不能定义它们的子类。int 是无法作为泛型参数的，所以我们可以使用 ArrayList&lt;Integer&gt;。幸运的是，有一个很有用的特性，例如 123456list.add(3)//这行代码将会自动变换成list.add(Integer.valueOf(3)); //这种变化被称为 autoboxing//相对的，也有一种情况叫自动拆箱int n = list.get(i);//这行代码将会自动变换成int n = list.get(i).intValue() 一般我们要比较 wrapper 对象的时候，习惯用 equals ，不过 autoboxing 规范要求：boolean、byte、char &lt;=127，介于 -128 ~ 127 之间的 shore 和 int 被包装到固定的对象中，所以下面代码： 1234567Integer a= 100;Integer b = 100;System.out.println(a==b) //trueInteger a= 200;Integer b = 200;System.out.println(a==b) //false Integer API int intValue() static String toString(int i) static String toString(int i, int radix) static int parseInt(String s) static int parseInt(String s,int radix) static Integer valueOf(String s) static Integer valueOf(String s,int radix) NumberFormat Number parse(String s) 5.5 参数可变的方法现在的 Java 版本提供了可以用可变的参数数量调用的方法 (有时称为 “变参” 方法)。具体的形式如下 12345678public static double max(double.. values)&#123; double largest = Double.NEGATIVE_INFINITY; for (double v : values) if (v &gt; largest) largest = v; return largest;&#125;//其过程就向给 max 方法传入了一个数组， 5.6 枚举类public enum Size {SMALL, MEDIUM,LARGE,EXTRA_LARGE};实际上，这个声明定义的类型是一个类，它刚好有 4 个实例，在此尽量不要构造新对象。因此，在比较两个枚举类型的值时，永远不需要调用 equals，而直接使用 “==” 就可以了。如果需要的话，可以在枚举类型中添加一些构造器，方法和域。当然，构造器只是在构造枚举常量的时候被调用。下面是一个实例： 12345678910111213public enum Size &#123; SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;), EXTRA_LARGE(&quot;XL&quot;); private String abbreviation; Size(String abbreviation) &#123; this.abbreviation = abbreviation; &#125; public String getAbbreviation() &#123; return abbreviation; &#125;&#125; 所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。其中最有用的一个是 toString，这个方法能够返回枚举常量名。例如，Size.SMALL.toString() 将返回字符串 SMALL。toString 的逆方法是静态方法 valueOf。例如，语句：Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;);。每个枚举类型都有一个静态的 values 方法，它将返回一个包含全部枚举值的数组。例如：Size[] values = Size.values();，ordinal 方法返回 enum 声明中枚举常量的位置，位置从 0 开始计数。例如：Size.MEDIUM.ordinal() 返回 1。 static Enum valueOf(Class enumClass,String name) String toString() int ordinal() int compareTo(E other) // 如果枚举常量出现在 other 之前，则返回一个负值；如果 this==other，则返回 0；否则，返回正值。枚举常量的出现次序在 enum 声明中给出。 5.7 反射反射库 (reflection library) 提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。能够分析类能力的程序称为反射 (reflection)。反射机制可以用来： 在运行时分析类的能力。 在运行时查看对象，例如，编写一个 toString 方法供所有类使用。 实现通用的数组操作代码 利用 Method 对象。 5.7.1 Class 类在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。然而，可以通过专门的 Java 类访问这些信息。保存这些信息的类被称为 Class，Object 类中的 getClass() 方法将会返回一个 Class 类型的实例。获取到 Class 类型的实例后，可以使用 getName，这个方法将返回类的名字。如果类在一个包里，包的名字也作为类名的一部分： 123Person p = new Person(); Class clazz = p.getClass(); System.out.println(clazz.getName());//com.example.Person 还可以调用静态方法 forName 获得类名对应的 Class 对象 12Class clazz = Class.forName(&quot;com.example.Person&quot;);//这个方法会产生异常，需要除了 System.out.println(clazz.getName()); 获得 Class 类对象的第三种方法非常简单。如果 T 是任意的 Java 类型 (或 void 关键字),T.class 将代表匹配的类对象。例如： 1Class clazz = Person.class; 一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int 不是类，但 int.class 是一个 Class 类型的对象。虚拟机为每个类型管理一个 Class 对象。因此，可以使用 == 运算符实现两个类对象比较的操作。例如： 1234Person p = new Person(); if(Person.class==p.getClass())&#123; System.out.println(&quot;HelloWorld&quot;); &#125; 还有一个很有用的方法 newInstance()，可以用来动态地创建一个类的实例。例如： 12Person p = new Person();Person b = p.getClass().newInstance(); newInstance 方法调用默认的构造器 (空参的构造器) 初始化新创建的对象。如果这个类没有默认的构造器，就会抛出一个异常。如果需要创建的类提供参数，必须使用 Constructor 类中的 newInstance 方法。 123Constructor c =Person.class.getDeclaredConstructor(String.class,int.class); Person b = (Person)c.newInstance(&quot;张子浩&quot;,123); System.out.println(b.name); 5.7.2 捕获异常异常有两种类型：未检查异常和已检查异常。对于已检查异常，编译器将会检查是否提供了处理器。然而，有很多常见的异常，例如，访问 null 引用，都属于未检查异常。 5.7.3 利用反射分析类的能力下面介绍反射机制最重要的内容 - 检查类的结构在 java.lang.reflect 包中有三个类 Field、Method 和 Constructor 分别描述类的域、方法和构造器。这三个类都有一个叫做 getName 的方法，用来返回项目的名称。Field 类有一个 getType 方法，用来返回描述域所属类型的 Class 对象。Method 和 Constructor 类有能够报告参数类型的方法，Method 类还有一个可以报告返回类型的方法。这三个类还有一个叫 getModifiers 的方法，它将返回一个整型数值，用不同的位开关描述 public 和 static 这样的修饰符使用情况。另外，还可以利用 java.lang.reflect 包中的 Modifier 类的静态方法分析 getModifiers 返回的整型数值。例如，可以使用 Modifier 类中的 isPublic、isPrivate 或 isFinal 判断方法或构造器是否是 public、private 或 final。我们需要做的全部工作就是调用 Modifier 类的相应方法，并对返回的整型数值进行分析，另外，还可以利用 Modifier.toString 方法将修饰符打印出来。Class 类中的 getFields、getMethods 和 getConstructor 方法将分别返回类提供的 public 域、方法和构造器数组，其中包括父类的公有成员。Class 类的 getDeclaredFields、getDeclaredMethods 和 getDeclaredConstructors 分别返回类中声明的所有全局变量、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。下面的代码可以完整打印出一个类的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; Scanner in = new Scanner(System.in); System.out.println(&quot;Enter class name (e.g. java.util.Date):&quot;); name = in.next(); try &#123; Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.println(&quot;class &quot; + name); if (supercl != null &amp;&amp; supercl != Object.class) &#123; System.out.print(&quot; extends &quot; + supercl.getName()); &#125; System.out.print(&quot;\n&#123;\n&quot;); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println(&quot;&#125;&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c : constructors) &#123; String name = c.getName(); System.out.print(&quot; &quot;); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.print(name + &quot;(&quot;); Class[] parameterTypes = c.getParameterTypes(); for (int j = 0; j &lt; parameterTypes.length; j++) &#123; if (j &gt; 0) System.out.print(&quot;,&quot;); System.out.print(parameterTypes[j].getName()); &#125; System.out.println(&quot;);&quot;); &#125; &#125; public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); for (Method m : methods) &#123; Class retType = m.getReturnType(); String name = m.getName(); System.out.print(&quot; &quot;); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;); Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(&quot; ,&quot;); System.out.print(paramTypes[j].getName()); &#125; System.out.println(&quot;);&quot;); &#125; &#125; public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); for (Field f : fields) &#123; System.out.print(&quot; &quot;); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.println(f.getName() + &quot; ;&quot;); &#125; &#125;&#125; Class&amp;Field&amp;Method&amp;Constructor&amp;Modifier API Class Field[] getFields() Field[] getDeclaredFields() Method[] getMethods() Method[] getDeclaredMethods() Constructor[] getConstructor() Constructor[] getDeclaredConstructor() Field &amp; Method &amp; Constructor Class getDeclaringClass() Class[] getExceptionTypes() Field 无这个方法 int getModifiers() String getName() Class[] getParameterTypes() Field 无这个方法 Class getReturnType() 只有在 Method 类中 Modifier static String toString(int modifiers) static boolean isAbstract(int modifiers) static boolean isFinal(int modifiers) static boolean isInterface(int modifiers) static boolean isNative(int modifiers) static boolean isPrivate(int modifiers) static boolean isProtected(int modifiers) static boolean isPublic(int modifiers) static boolean isStatic(int modifiers) static boolean isStrict(int modifiers) static boolean isSynchronized(int modifiers) static boolean isVolatile(int modifiers) 5.7.4 在运行时使用反射分析对象在编写程序时，如果知道想要查看的域名和类型，查看指定的域是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的对象域。 1234567Person p = new Person(&quot;bob&quot;); Class cl = p.getClass(); Field f = cl.getDeclaredField(&quot;name&quot;); f.setAccessible(true);//设置访问权限 f.set(p,&quot;zzzz&quot;);//可以将 p 的值进行替换 Object v = f.get(p);//可以获取 p 的值 System.out.println(v+&quot;&quot;); setAccessible 是 AccessibleObject 类中的一个方法，它是 Field、Method 和 Constructor 类的公共父类。 AccessibleObject &amp; Class &amp; Field API AccessibleObject void setAccessible(boolean flag) boolean isAccessible static void setAccessible(AccessibleObject[] array,boolean flag); Class Field getField(String name) Field[] getField() Field getDeclaredField(String name) Field[] getDeclaredFields() Field Object get(Object obj) void set(Object ob,Object newValue) 5.7.5 使用反射编写泛型数组代码java.lang.reflect 包中的 Array 类允许动态地创建数组。例如，将这个特性应用到 Array 类中的 copyOf 方法实现中。关于 Java 数组类型的转换：Java 数组会记住每个元素的类型，将一个 Employee[] 临时地转换成 Object[] 数组，然后再把它转换回来是可以的，但一个从开始就是 Object[] 数组却永远也不能转换成 Employee[] 数组。为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。 12345678910111213Employee[] a = new Employee[100]...//array is fulla = Arrays.copyOf(a,2*a.length);//正确的转换Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; 5.7.6 调用任意方法反射机制允许你调用任意方法。Method 类中有一个 invoke 方法，它允许调用包装在当前 Method 对象中的方法。invoke 方法的形式是 Object invoke(Object obj,Object.. args)第一个参数是隐式参数，其余的对象提供了显式参数，对于静态方法，第一个参数可以被忽略，即可以将它设置为 null。获得 Method 对象的方法是 Method getMethod(String name, Class... parameterTypes)，下面是代码演示： 123456789101112131415161718192021222324252627public class CopyOfTest &#123; public static void main(String[] args) throws Exception &#123; Method square = CopyOfTest.class.getMethod("square", double.class); Method sqrt = Math.class.getMethod("sqrt", double.class); printTable(1,10,10,square); printTable(1,10,10,sqrt); &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from, double to, int n, Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for (double x = from; x &lt;= to; x += dx) &#123; try &#123; double y = (Double) f.invoke(null, x); System.out.printf("%10.4f | %10.4f%n", x, y); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 5.8 继承的设计技巧 将公共操作和域放在父类 不要使用受保护的域 使用继承实现 is-a 的关系 除非所有继承的方法都有意义，否则不要使用继承 在 override 方法时，不要改变预期的行为 使用多态，而非类型信息 不要过多地使用反射 总结： 总结： 反射：指在程序运行期间发现更多的类及其属性的能力。 super 不是一个对象的引用，不能将其赋给另一个对象变量，它只是一个指示编译器调用超类方法的关键字。构造方法中 super 语句必须放到第一行。 若子类构造器没有显示调用父类的构造器，则系统自动调用父类的无参构造器；若父类没有无参构造器 (有其他构造器)，子类也没显示调用父类其他构造器，则编译报错。 系统在运行时能自动选择调用哪个方法的现象称为动态绑定 (重写的调用 系统知道引用类型是谁就行)；编译时就能知道该调用那个方法称为静态绑定 (如 privite/static/final 方法)。 Java 中只能单继承，但是继承链可以是有多层。 可以将一个子类实例赋值给超类变量 (向下转型)；不能将一个超类实例直接赋值给子类变量 (需要强制类型转换)。 子类重写 (覆盖) 方法中，可见性不能低于超类，若是 final 方法将不能被重写(覆盖)，不想它们在子类中改变语义。 包含一个或多个 abstract 方法的类必须被声明为抽象类；抽象类可以有自己的实例域和方法，子类必须重写父类的所有抽象方法，否则自己还是个抽象类；抽象类不能被实例化，只能实例化为具体的自类。 Object 类是所有类的超类，可以用它引用任何类型的变量，Java 中只有基本数据类型不是对象。 equals()方法默认判断的是内存地址，在子类定义 equals 方法时，首先调用超类的 equals，如果失败直接返回 false，然后再逐一对比子类自己的每个实例域。如果重新定义equals()方法就必须重新定义hashCode()方法，保证 hashCode 相同则对象就相等，为了插入到散列表中的验证。 Objects.equals(a,b)方法可避免两个变量都为 null 引起的问题；Arrays.equals()方法可以检测两个数组是否相等 (已重写判断每位是否相等的逻辑，类似 String.equals())。 散列码 (hash code) 是由对象导出的一个整型值，是无规律的，每个对象的默认散列码是对象的存储地址。两个相等的对象要求返回相等的散列码(内存地址都一样了，指向同一个堆对象，所以可以用来判断对象相等)。 ArrayList 是一个泛型类，动态数组实现，动态查询时效率高，但是在中间插入和删除效率就不行了 (后面的所有元素都要做位移)，动态插入删除链表 LinkedList 效率高一些，只修改那个元素前后的指针即可。 Java 中所有基本数据类型都有一个与之对应的类称为包装器，一旦构造是不许更改的，在许多场景下可以自动装箱与拆箱。== 判断的是地址。装箱和拆箱是编译器认可的，而不是虚拟机。 反射：能够在运行时动态分析类的能力，构造类，调用类的方法的行为。可使用 Class 类的newInstance()方法来动态构造类，Method 的invoke()来动态调用方法。 Class 类：• 定义：在程序运行期间，Java 运行时系统始终为所有对象维护着一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类，虚拟机利用运行时类型信息来选择相应的方法执行。独立于对象，存储着类的各种信息 (构造器 / 域 / 方法)。• 获取方式：①Object.class(只能获取到该类的 class 不区分父类子类引用)②obj.getClass()(当前 obj 的 class 区分父类子类)③Class.forName(pkgClassName)(动态获取 class 可能不存在 反射一般用的多)• 使用方法：Class 的newInstance()方法调用默认的构造器 (无参构造器) 动态创建一个类的实例，如果这个类没有默认构造器，则必须使用 Constructor 类中的newInstance()中带参数的构造方法。• 特点：一个 Class 对象实际上表示的是一个类型，而这个类型未必是一种类。例如，int 不是类，int.class 是一个 Class 类型的对象。Class 类实际上是一个泛型类。虚拟机为每个类型管理一个 Class 对象，可用obj.getClass()==Object.class来比较。 反射相关类：• 在 java.lang.reflect 包中有三个常用类：Field、Method 和 Constructor 分别用于描述类的域、方法和构造器。它们包含了一系列方法来分析类的各种属性和能力。外加一个 Modifier 类判断修饰符用，AccessibleObject 三者公有的超类。• 以上三个类有着公有的超类，以及各自的一些方法。getFields()方法返回类及其父类的公有域；getDeclaredFields()方法返回类的全部域，不包括父类。• 如果 f 是一个 Field 类型的对象，obj 是某个包含 f 域的类的对象，f.get(obj) 将返回一个对象 (Object 类型 基本类型则返回包装器)，其值为 obj 域的当前值 (就类似拷贝一个域的对象而已)。• f.set(obj,value) 可以将 obj 对象的 f 域设置成新值。基本数据类型的域获取域使用如getDouble()方法返回包装器。 反射机制默认行为受限于 Java 的访问控制，可以调用setAccessible()方法来为反射对象设置可访问标志。setAccessible()其实是 AccessibleObject 中的方法，它是 Field、Method 和 Constructor 的公有超类。 ObjectAnalyzer 将记录已经被访问过的对象。如：new ObjectAnalyzer().toString(this)。 反射常用方法：• Class 的getMethod(String name,Class&lt;?&gt;... parameterTypes)方法返回一个 method 类 (可以传入 class… 也可传入 new Class[]{} 数组)；• Method 类中的invoke(Object o,Object... args)方法调用包装在当前 Method 对象中的方法 (可以传入 obj… 也可传入 new Object[]{} 数组)，如果返回类型是基本类型，invoke 方法返回其包装器类型；对于静态方法，可以把null作为隐式参数传入；显示参数没有的话也传 null。 程序中不要过多的使用反射，反射会影响性能，并且编译器很难发现程序错误，只有在运行时才会发现并导致异常。 反射创建数组：• java.lang.reflect 包中的 Array 类允许动态构建数组，Java 数组会记住每个元素的类型 (创建时指定)，可以将一个特定数组临时转为 Object[]，然后可以强转回来，如果一开始就是个 Object[]，则不能强转。• Array.newInstance(componentType,newLength) 方法动态创建数组，getComponentType()是 Class 的方法，getLength()是 Array 的方法。创建得到的是 Object 数组，可以强转回来。Arrays.copyOf()底层就是这么做的。 注意：int[] 可以转为 Object，而不能转为 Object[]。 重写、重载、覆盖、多态的区别：• 重写 (覆盖)：方法级别的概念；@Override，出现在子类中，方法名和参数类型完全相同，子类重新实现父类定义的函数；但是访问权限不能小于父类的，抛出的的异常也不能大于父类；静态方法不能被重写为非静态方法。• 重载：方法级别的概念；@Overload，出现在父类中，方法名相同，参数不同，类似多态的不同实现。不能通过访问权限、返回类型和抛出异常不同来重载。• 多态：类级别的概念；父类的引用 -&gt; 子类的实例，使得父类可以调用子类中更多的方法。继承是子类使用父类的方法，而多态是父类调用子类的方法。重点：P166 Object、equals 方法 P190 反射 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第4章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-1%2F</url>
    <content type="text"><![CDATA[第四章：对象与类4.1 面向对象程序设计概述面向对象程序设计，简称 OOP。Java 是完全面向对象的，必须熟悉 OOP 才能够编写 Java 程序。 4.1.1 类class 是构造对象的模板或蓝图，由类构造 (construct) 对象的过程称为创建类的实例 (instance)。封装 (encapsulation，有时称为数据隐藏)，对象中的数据称为实例域 (instance field)，操作数据的过程称为方法 (method)。对于每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态 (state)。实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。OOP 的另一个原则就是可以通过扩展一个类来建立另外一个新的类，在 Java 中，所有的类都源自于 Object。通过扩展一个类来建立另外一个类的过程称为继承 (inheritance)。 4.1.2 对象对象的三个主要特性 对象的行为 (behavior)：可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态 (state)：当施加那些方法时，对象如何响应？ 对象标识 (identity)：如何辨别具有相同行为与状态的不同对象？ 4.1.3 识别类识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。 4.1.4 类之间的关系 依赖：uses-a 一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合：has-a 一个类的对象包含另一个类的对象 继承：is-a 一个类是另一个类的子类或者父类，类之间进行了扩展。 4.2 使用预定义类Java 中没有类就不能做任何事情，然而，并不是所有的类都具有面向对象特征。例如 Math 类，在程序中，可以使用 Math 类的方法，只需要知道方法名和参数，而不必了解它的具体实现过程，这正是封装的关键所在，但是 Math 类只封装了功能，它不需要也不必隐藏数据，由于没有数据，因此也不必担心生成对象以及初始化实例域。 4.2.1 对象与对象变量要想使用对象，必须首先构造对象，并指定其初始状态。然后，对对象应用方法。在 Java 中，使用构造器 (constructor) 构造新实例，构造器是一种特殊的方法，用来构造并初始化对象。构造器的名字应该与类名相同，要想构造一个类的对象，需要在构造器前面加上 new 操作符。new Date()`System.out.println(new Date());String s = new Date().toString();在上述例子种，构造的对象仅使用了一次，如果希望多次使用，需要将对象存放在一个变量中。Date birthday = new Date();`一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 4.2.2 Java 类库中的 LocalDate 类Date 类用来表示时间点，LocalDate 用来表示大家熟悉的日历表达法。LocalDate.now()// 2017-07-08还可以调用 LocalDate.of(1999,12,6) 方法来构造对应一个特定日期的对象。一旦有了一个 LocalDate 对象，可以使用方法 geetYear 、getMonthValue、getDayOfMonth得到年、月、日。下列的方法可以得到未来的日期或者过去的日期。 123LocalDate c = LocalDate.now();//c 是当前时间System.out.println(c.plusDays(1));//明天System.out.println(c.plusDays(-1));//昨天 4.2.2 更改器方法与访问器方法Java 库的一个较早版本曾经有另一个类来处理日历，名为 GregorianCalendar 与 c.plusDays(1) 不同，GregorianCalendar.add 方法与 plusDays 方法功能差不多，但是是一个更改器方法 (mutator method)。调用这个方法后，GregorianCalendar 对象的状态会改变。 1234GregorianCalendar c = new GregorianCalendar(1999,1,10);c.add(Calendar.YEAR, 1);int year = c.get(Calendar.YEAR);System.out.println(year); 相反，只访问对象而不修改对象的方法有时称为访问器方法 (accessor method)。例如 LocalDate.get 和 GregorianCalendar.get 。 下面的代码可以构建一个当月的日历。 1234567891011121314151617181920212223242526272829303132333435//带 * 号表示今天Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8* 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ------------------------------------LocalDate date = LocalDate.now(); int month = date.getMonthValue();// 7 int today = date.getDayOfMonth();// 8 date = date.minusDays(today - 1);// 返回到月初 DayOfWeek weekday = date.getDayOfWeek();// 得到星期几 int value = weekday.getValue();//得到月初的星期 System.out.println(&quot;Mon Tue Wed Thu Fri Sat Sun&quot;);//先打印好星期行 for (int i = 1; i &lt; value; i++) &#123;//控制 1 出现的位置 System.out.print(&quot; &quot;); &#125; while (date.getMonthValue() == month) &#123;// System.out.printf(&quot;%3d&quot;, date.getDayOfMonth());//打印1 if (date.getDayOfMonth() == today) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; System.out.print(&quot; &quot;); &#125; date = date.plusDays(1); if (date.getDayOfWeek().getValue() == 1) &#123; System.out.println(); &#125; &#125; LocalDate API LocalTime now() LocalTime of(int year, int month, int day) int getYear() int getMonthValue() int getDayOfMonth() DayOfWeek getDayOfWeek LocalDate plusDays(int n) LocalDate minusDays(int n) 4.3 用户自定义类要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有 main 方法。 4.3.1 Employee 类123456789101112class ClassName&#123; field; field; ... constructor1 constructor2 ... method1 method2 ...&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Demo01 &#123; public static void main(String[] args) throws Exception &#123; Employee[] staff = new Employee[3]; staff[0] = new Employee(&quot;Carl Cracker&quot;, 75000, 1987, 12, 15); staff[1] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1); staff[2] = new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15); for (Employee e : staff) &#123; e.raiseSalary(5); &#125; for(Employee e :staff)&#123; System.out.println(&quot;+e.getHireDay()); &#125; &#125;&#125;class Employee &#123; private String name; private double salary; private LocalDate hireDay; //constructor public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; // a method public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125;&#125; 当我们的 .java 文件包含 2 个类的时候，我们编译时可以采用这两种方法 12javac Employee*.java //可以使用通配符，所有与通配符匹配的源文件都将被编译成类文件javac Demo01.java //Java编译器会自动搜索使用的Employee类，并编译 4.3.4 从构造器开始1234567public Employee(String n, double s, int year, int month, int day)&#123; name = n ; salary = s; LocalDate hireDay = LocalDate.of(year,month,day);&#125;构造器与类同名，构造器与其他的方法有一个重要的不同。构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用 constructor 来达到重新设置实例域的目的，例如`james.Employee(&quot;James Bond&quot;,250000,1950,1,1)`//ERROR,会产生编译错误。 构造器的基本特点： 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有 0 个、1 个或多个参数 构造器没有返回值 构造器总是伴随着 new 操作一起调用 4.3.5 隐式参数与显式参数12345678public void raiseSalary(double byPercent)&#123; double raise = salary * byPercent / 100 salary +=raise; //salary的前面省略了参数， //完整的写法是 double raise = number007.salary * byPercent / 100 number007.salary +=raise;&#125; raiseSalary 有两个参数，第一个参数称为隐式参数 (implicit) 参数，是出现在方法名前的 Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式 (explicit) 参数。隐式参数也被称为方法调用的目标或接收者。在每个方法中，关键字 this 表示隐式参数。如果需要的话，可以用下列方式编写 raiseSalary 方法： 1234public void raiseSalary(double Percent)&#123; double raise = this.salary * byPercent / 100; salary +=raise;&#125; 4.3.6 封装的优点使用 public get 方法来代替 public name，将全局变量设置为 private 可以防止受到外界的破坏。注意：不要编写返回引用可变对象的 get 方法，因为它本身是可变的话，会破坏封装性，我们应该只能通过 set 方法来改变对象的状态，如果必须要这样做，那么我们可以使用 clone。 123456class Employee&#123; public Date getHireDay() &#123; return (Date) hireDay.clone(); &#125;&#125; 4.3.7 基于类的访问权限123public boolean equals(Employee other) &#123; return name.equals(other.name); &#125; 这段代码中 Employee 类的 name 变量是 private 修饰的，other.name 意味着我们访问了另一个对象的 private 属性，这与我们之前说的是对不起来的，其原因是： other 是 Employee 类对象，而 Employee 类的方法可以访问 Employee 类的任何一个对象的私有域。 4.3.8 私有方法有时，可能希望将一个计算代码划分为若干个独立的赋值方法。通常，这些辅助方法不应该成为公有接口的一部分，最好将这样的方法设计为 private。 4.3.9 final实例域构造对象时必须初始化这样的域，也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。如果将 final 用在一个可变对象上，那么 final 只表示该变量的对象引用不会更改，对象本身是可以更改的。 4.4 静态域与静态方法 static4.4.1 静态域如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。static 修饰的属性属于类，而不属于任何独立的对象。 4.4.2 静态常量静态变量用得比较少，但静态常量却使用得比较多。例如 Math.PI 123public class Math&#123; public static final double PI = 3.14159265358979323846;&#125; 这样做的好处就是，我们可以不需要构建 Math 的对象，直接通过 Math.PI 来进行访问，同时，设置为 fanal，避免了被修改的问题。 4.4.3 静态方法静态方法是一种不能向对象实施操作的方法，例如，Math 类的 pow 方法就是一个静态方法。Math.pow(x,a)，在运算时，不使用任何 Math 对象。换句话说，没有隐式的参数。可以认为静态方法是没有 this 参数的方法，这也说明了为什么静态方法无法调用非静态变量。在下面两种情况下使用静态方法： 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供，例如：Math.pow 一个方法只需要访问类的静态域，例如：Employee.getNextId 4.4.4 工厂方法静态方法还有另外一种常见的用途。类似 LocalDate 和 NumberFormat 的类使用静态工程方法 (factory method) 来构造对象。 12345NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(); NumberFormat percentFormatter = NumberFormat.getPercentInstance(); double x = 0.1; System.out.println(currencyFormatter.format(x)); // ￥0.10 System.out.println(percentFormatter.format(x)); // 10% 为什么 NumberFormat 不利用 构造器 来完成这些操作呢？ 无法命名构造器，构造器的名字必须要和类名一样，但是，这里希望将得到的货币实例和百分比实例采用不同的名字。 当使用构造器时，无法改变所构造的对象类型，而 Factory 方法将返回一个 DecimalFormat 类对象，这是 NumberFormat 的子类。 4.4.5 main 方法需要注意，不需要使用对象调用静态方法。例如，不需要构造 Math 类对象就可以调用 Math.pow。每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。例如，可以在 Employee 类中添加一个 main 方法，如果想要独立地测试 Employee 类，只需要执行 java Employee，如果 Employee 类是一个更大型应用程序的一部分，就可以使用下面这条语句运行程序 java Application，Employee 类的 main 方法永远不会执行。 4.5 方法参数按值调用 (call by value) 表示方法接收的是调用者提供的值。而按引用调用 (call by reference) 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。call by 是一个标准的计算机科学术语。Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。 1234567//假定一个方法：试图将参数值增加至3倍public static void tripleValue(double x)&#123; x = 3 * x ;&#125;double percent = 10;tripleValue(percent) 不过，并没有实现把参数增加到 3 倍。让我们一步步来细化： x 被初始化为 percent 值的一个拷贝 (也就是 10) x 被乘以 3 后等于 30，但是 percent 还是 10 这个方法结束之后，参数变量 x 不再使用然后，方法参数共有两种类型： 基本数据类型 (数字、布尔值) 对象引用下面这段代码实现了当对象引用作为参数的时候，方法修改了参数。 12345public static void tripleDSalary(Employee x)&#123; x.raiseSalary(200);&#125;harry = new Employee(...);tripleSalary(harry) 具体的执行过程是： x 被初始化为 harry 值的拷贝，这是一个对象的引用 raiseSalary 方法应用于这个对象引用。x 和 harry 同时引用的那个 Employee 对象的 salary 提高了 200% 方法结束后，参数变量 x 不再使用，当然，对象变量 harry 继续引用那个薪金增至 3 倍的雇员对象。下面总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型) 一个方法可以改变一个对象参数的状态 一个方法不能让对象参数引用一个新的对象 4.6 对象构造由于对象构造非常重要，所以 Java 提供了多种编写构造器的机制。 4.6.1 重载有些类有多个 constructor，例如，可以如下构造一个空的 StringBuilder 对象。StringBuilder messages = new StringBuilder();或者，可以指定一个初始字符串：StringBuilder todoList = new StringBuilder(&quot;To do:\n&quot;);这种特征叫做重载 (overloading)。如果多个方法有相同的名字、不同的参数，便产生了 overload。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。要注意的是，重载与返回值无关，也就是说，不能有方法名相同，参数相同，返回值类型不相同的两个方法。 4.6.2 默认域初始化如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值；数值为 0、布尔值为 false、对象引用为 null。 1这是全局变量与局部变量的主要不同点。必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的全局变量，将会被自动初始化为默认值 (0、false或null)。 4.6.3 无参数的构造器只有当类没有提供任何构造器时，系统才会提供一个默认的无参构造器。 4.6.4 显式域初始化123class Employee&#123; private String name =&quot;&quot;;&#125; 在执行构造器之前，会先执行显式赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方法特别有用。 4.6.5 参数名在编写很小的构造器时，常常在参数命名上出现错误。通常，参数用单个字符命名，但是我们推荐这样做： 123456789public Employee(String aName, double aSalary)&#123; name = aName; salary = aSalary;&#125;public Employee(String name, double salary)&#123; this.name = name; this.salary = salary;&#125; 4.6.6 调用另一个构造器关键字 this 引用方法的隐式参数。然而，这个关键字还有另外一个含义。如果构造器的第一个语句形如 this(...)，这个构造器将调用同一个类的另一个构造器。下面是个典型的例子： 12345public Employee(double s)&#123; //call Employee(String, double) this(&quot;Employee #&quot;+nextId,s); nextId++:&#125; 4.6.7 初始化块前面已经讲过两种初始化数据域的方法： 在构造器中设置值 在声明中赋值实际上，Java 还有第三种机制，称为初始化块 (initialization block)。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如， 12345678910111213141516171819202122232425class Employee&#123; private static int nextId; private int id; private String name; private double salary; &#123; d = nextId; nextId++: &#125; public Employee(String n, double s) &#123; name = n ; salary = s; &#125; public Employee() &#123; name = &quot;&quot;; salary = 0; &#125;&#125; 通常会直接将初始化代码放在构造器中。由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱，下面是具体处理步骤： 所有数据域被初始化为默认值 (0、false 或 null)。 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。 执行这个构造器的主体。还可以使用静态代码块，在类第一次加载的时候，将会进行静态域的初始化。 Random API Random() // 构造一个新的随机数生成器 int nextInt(int n)// 返回一个 0~ n-1 之间的随机数 4.6.8 对象析构域 finalize 方法由于 Java 有自动的垃圾回收器，不需要人工回收内存，所以 Java 不支持析构器。 4.7 包Java 允许使用 包 (package) 将类组织起来，借助于包可以方便地组织自己的代码。使用包的主要原因是确保类名的唯一性。 4.7.1 类的导入一个类可以使用所属包中的所有类，以及其他包中的公有类 (public class)，我们可以采用两种方式访问另一个包中的共有类。第一种方式是在每个类名之前添加完整的包名。 1java.time.LocalDate today = java.time.LocalDate.now(); 这样比较麻烦，我们推荐使用 import 导包，import 语句应该位于源文件的顶部 (但位于 package 语句的后面)。例如，可以使用下面这条语句导入 java.util 包种所有的类。import java.util.*;，也可以导入特定的类 import java.time.LocalDate; 4.7.2 静态导入import 不仅可以导入类，还增加导入静态方法和静态域的功能。例如：import static java.lang.System.*;我们就可以使用 System 类的静态方法和静态域，而不必加类名前缀： 123out.println(&quot;Goodbye,World!&quot;);//还可以导入特定的方法或域import static java.lang.System.out; 4.7.3 将类放入包中要想将一个类放入包中，必须将包的名字放在源文件的开头，包中定义类的代码之前。 1234package com.horstmann.corejava;public class Employee&#123;&#125; 4.7.4 包作用域标记为 public 的部分可以被任意的类使用；标记为 private 的部分只能被定义它们的类使用。如果没有指定，则为 default，表示可以被同一个包中的所有方法访问。 4.9 文档注释JDK 包含一个很有用的工具，叫做 javadoc。它可以由源文件生成一个 HTML 文档。如果在源代码种 添加以专用的 /** 开始注释，那么可以很容易地生成一个看上去具有专业水准的文档。 4.9.1 注释的插入javadoc 从下面几个特性种抽取信息： 包 公有类与接口 公有的和受保护的构造器及方法 公有的和受保护的域每个 /** */文档注释在标记之后紧跟着自由格式文档。标记由 @ 开始，如 @author 或 @param。在自由格式文本中，可以使用 HTML 修饰符，例如：&lt;em&gt; &lt;/em&gt;，&lt;strong&gt; &lt;/strong&gt;。 4.9.2 类注释类注释必须放在 import 语句之后，类定义之前。 12345678package com.example;/** * Afdfsdfsdfsdf * sdfsdfsdfsdfs * fsdfdssfsdfsf */public class PackageTest &#123; 4.9.3 方法注释每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记： @param 变量描述 @return 描述 @throws 类描述下面是一个方法注释的实例： 123456789/** * 我用来说明方法的概要 * @param s 我用来说明参数的作用 * @param g 我用来说明参数的作用 * @return 我用来说明返回值的作用 */ public int gogogo(String s , int g )&#123; return 4; &#125; 4.9.4 域注释只需要对公有域 (通常指的是静态常量) 建立文档。例如 1234/** * 我用来说明常量作用 */public static final int YEAR = 5; 4.9.5 通用注释下面的标记可以用在类文档的注释中。 @author 姓名，将产生一个 “author” 条目，可以使用多个。 @version 版本，这个标记将产生一个 “version” 条目 @since 这个标记将产生一个 “since” 条目，这里的 text 可以是对引入特性的版本描述。 @deprecated 这个标记将对类、方法或变量添加一个不再使用的注释。 @see 引用，它可以用于类中，也可以用于方法中。它有三种情况 package.class#feature label &lt;a href=&quot;...&quot;&gt;label&lt;/a&gt; “text”@see 的第一种情况最常见。只要提供类、方法或变量的名字，javadoc 就在文档中插入一个超链接。例如：@see com.horstmann.corejava.Employee#raiseSalary(double)@see com.example.GoGoGo#fuck(String)@see GoGoGo#fuck(String) 也可以省略包名。如果 @see 标记后面有一个 &lt; 字符，许久需要指定一个超链接，可以超链接到任何 URL。 12see &lt;a href =&quot;wwww.baidu.com&quot;&gt;百度&lt;/a&gt;@see &quot;百度&quot; 如果愿意的话，还可以在注释中的任何位置放置指向其他类或方法的超级链接，以及插入一个专用的标记，例如：{@link GoGoGo#fuck(String) label} 4.9.6 包与概述注解类、方法、变量的注释都可以放置在 Java 源文件中，但是要想产生包注释，就需要在每一个包目录中添加一个单独的文件。可以有如下两个选择： 提供一个以 package.html 命名的 HTML 文件。在标记 &lt;body&gt;..&lt;/body&gt; 之间的所有文本都会被抽取出来。 提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 /** */界定的 Javadoc 注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。还可以为所有的源文件提供一个概述性的注释，这个注释将被放置在一个名为 overview.html 的文件中，这个文件位于包含所有源文件的父目录中。标记 &lt;body&gt;..&lt;/body&gt; 之间的所有文件将被抽取出来。当用户从导航栏中选择 “Overview” 时，就会显示出这些注释内容。 4.10 类设计技巧 一定要保证数据私有：将全局变量设置为 private。 一定要对数据初始化 不要在类中使用过多的基本类型 不是所有的变量都需要 get、set 方法 将职责过多的类进行分解 类名和方法名要能够体现它们的职责 优先使用不可变的类 总结： OOP 对象的三个主要特征：行为 (方法)、状态 (方法的执行结果)、标识 (多态)。 类之间常见的关系：依赖 (uses-a)、聚合 (has-a)、继承 (is-a)。 一个对象变量并没有实际包含一个对象，而是引用一个对象。任何对象变量的值都是对存储在另一个地方的一个对象的引用，实际的对象在堆内存中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。 有时候多态的实现可以使用工厂方法来实现。 所有的 Java 对象都是在堆中构造的，构造器伴随着 new 操作符一起使用，不能在构造器中定义与实例域重名的局部变量。 方法中的显示参数指传参，隐式参数指方法的主体类，即调用对象本身 (this)，如data.getTime()中的 data。 对一个对象进行数据域的拷贝可以用 Object 的clone()方法，不要直接返回一个类的引用本身。 final 实例域在构造器执行之后一定是赋上值的且不可改变；static 域属于类，不属于任何独立的对象。 类的成员方法可以访问静态变量，静态方法不能访问成员变量 (肯定了)。 方法参数分为按值传递和按引用传递：值传递不可改变原值，因为先拷贝再处理；引用传递虽然也拷贝了一份，但是是浅拷贝，指向同一个内存地址，因此可以改变引用的状态。 方法总结 (两种传递)：• 方法不能改变基本数据类型的参数 (值传递，会拷贝)。• 方法可以改变一个对象的状态 (值传递，浅拷贝，改变了实际的堆里对象状态)。• 方法不能让对象参数引用一个新的对象 (会拷贝，只要不改变对象状态，只修改引用没用，因为方法结束时变量拷贝被丢弃，原引用还是不会变)。 当且仅当类没有任何构造方法时，系统会为之创建一个无参构造方法；否则必须使用自己定义的构造方法。 初始化块会在构造类对象时被执行，先运行初始化块，然后才运行构造器主体部分。 类的加载顺序：静态变量、静态初始化块 (先父后子) -&gt; 实例变量、实例初始化块 (先父后子) -&gt; 构造器 (先父后子)。 finalize()方法会在垃圾回收器清除对象之前被调用；import 导入包时，可以导入包、类和静态方法和静态变量。 几个概念区别：• 重写 (覆盖)(override) 指方法名和参数完全相同；• 重载 (overload) 指方法名相同参数不同；• 多态 (polymorphlism) 是针对类来说的指父类的多种实现。 包权限优先级：public(任何地方) &gt; protected(本包和其他包自类) &gt; default(本包) &gt; private(本类)。 只有 public 级别的方法可以在 new 出来的对象中去显式调用，否则都不行 (只能在类中和子类中自己使用)。重点：P112 静态域、静态方法 P123 对象构造 注意：instanceof 关键字 运行时指出对象是否是一个特定类的实例 (它是判断不出来接口、继承等关系中的子类和父类的，都会返回 true)；需要判断具体类时使用. class 进行比较。 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第3章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19%2F</url>
    <content type="text"><![CDATA[第三章：Java 基本程序设计结构3.1 一个简单的 Java 应用程序12345public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &apos;Hello, World!&apos;&quot;); &#125;&#125; Java 区分大小写，如果出现了大小写拼写错误 (例如，将 main 拼写为 Main)，程序将无法运行。public 被称为访问修饰符，用于控制程序的其他部分对这段代码的访问级别。class 表明 Java 程序中的全部内容都包含在类中，Java 应用程序中的全部内容都必须放置在类中。FirstSample 就是类名，定义类名的规则是：必须以字母开头，后面可以跟字母与数字的任意组合，长度基本没有限制，但是不能与 Java 保留字重名 (比如取个类名叫 public)，类名不强制大写，但是标准的命名规范中规定需要大写，即约定俗成。骆驼命名法 (驼峰命名法)：如果名字中包含了多个单词，则每个单词的第一个字母应该大写。源文件的文件名必须与 public 类的名字相同，并用 .java 作为扩展名。当我们执行编译命令的时候，Java 虚拟机会找到类中的 main 方法，并开始执行，所以在 .java 文件中必须要又一个 main 方法。如何执行这段 Java 代码：编写 .java 文件 —-&gt; 利用 Java 编译器 —-&gt; 生成 .class 字节码文件 —-&gt; 启动 Java 虚拟机 —-&gt;Java 虚拟机找到 main() 方法，开始执行。 123&#123; System.out.println(&quot;We will not use &apos;Hello, World!&apos;&quot;);&#125; { }一对大括号代表了方法体的开始与结束，在 Java 中，每个语句必须要用分号结束，回车不代表结束。 3.2 注释Java 的注释不会出现在可执行程序中，因此，可以在源程序中添加任意多的注释，在 Java 中，有 3 种标记注释的方式。 / / ：适用于一段较长的注释，需要注意，无法嵌套使用 /* /：可以用来自动地生成文档 3.3 数据类型Java 是一种强类型语言，必须为每个变量声明一种类型。在 Java 中有 8 种基本类型：4 种整型，2 种浮点型，1 种用于表示 Unicode 编码的字符单元的字符类型 char，和一种用于表示真值的 boolean 类型 (String 和 数组都是对象)。 3.3.1整型：用于表示没有小数部分的数值，它允许是负数取值范围 -2^(位 - 1) —–2^(位 - 1)-1 一个字节代表 8 位 类型 存储需求 取值范围 具体值 int 4 字节 -2 的 32 次方~ 2 的 32 次方 - 1 -2147483646-2147483647(正好超过 20 亿) short 2 字节 -2 的 16 次方~ 2 的 16 次方 - 1 -32768~32767 long 8 字节 -2 的 64 次方~ 2 的 64 次方 - 1 -9223372036854775808~9223372036854775807 byte 1 字节 -2 的 8 次方~ 2 的 8 次方 - 1 -128~127 在 Java 中，整型的范围与运行 Java 代码的机器无关。长整型数值后面有一个 L 后缀，从 Java7 开始，加上前缀 0b 或 0B 就可以写二进制数。如 0b1001 就代表 9，还可以为数字字面量加下划线，如用 1_000_000 表示一百万，更加可读，编译器会去掉这些下划线。 12System.out.println(0b1001); // result : 9System.out.println(1_000_000); // result :1000000 3.3.2 浮点类型用于表示有小数部分的数值。Java 中有两种浮点类型。 类型 存储需求 取值范围 float 4 字节 -1.7 乘以 10 的 38 次方~ 1.7 乘以 10 的 38 次方 double 8 字节 -3.4 乘以 10 的 308 次方~ 3.4 乘以 10 的 308 次方 double 表示这种类型的数值精度是 float 类型的两倍 (也有人称之为双精度数值)，float 类型的数值后有一个后缀 F 或 f，没有后缀的默认为 double 类型，double 类型也可以加后缀 D 或 d 。注意浮点类型计算存在误差，是因为浮点数值采用二进制系统表示，在二进制系统中无法精确地表示分数 1/10 ，可以使用 BigDecimal 类代替实现。 12System.out.println(2.0-1.1);result : 0.8999999999999999 3.3.3 char 类型char 类型用于表示单个字符，不过现在有些变化，有些 Unicode 字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值。&#39;A&#39; 与 &quot;A&quot; 不同，前者是编码值为 65 所对应的字符常量，后者是包含一个字符 A 的字符串。char 类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff 。下面这行代码是符合语法标准的，\u005B 表示 [ ，\u005D 表示 ]。Unicode 转义序列会在解析代码之前得到处理。 1public static void main(String\u005B\u005D args) &#123;&#125; Java 中可以使用 \u + Unicode编码来进行转义，如 \u0022，除了这个以外，还有一些特殊的转义序列 转义序列 名称 Unicode 值 \b 退格 \u0008 \t 制表 \u0009 \n 换行 \u000a \r 回车 \u000d \” 双引号 \u0022 \’ 单引号 \u0027 \ 反斜杠 \u005c 3.3.5 boolean 类型boolean(布尔) 类型有两个值：false 和 true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。 3.4 变量在 Java 中，每个变量都一个类型 (type)。在声明变量时，变量的类型位于变量名之前，例如： 123double salary;int vacationDays;boolean done; 变量名必须要以字母开头，并由字母或数字组成的序列，不过这里的 “字母” 的概念不单指英文字母，字母包括 A~Z，a~z，_，$，或在某种语言中表示字母的任何 Unicode 字符，比如德国人就可以在变量名中使用字母 ä。 3.4.2 常量在 Java 中，利用关键字 final 指示常量，例如final int cout = 3 ;关键字 final 表示这个变量只能被赋值一次，一旦被赋值之后，就不能够再修改了，习惯上，常量名使用全大写。声明在类中，用 static final 声明的变量，也被称为类常量 3.5 运算符在 Java 中，使用算术运算符 +，-，*，/，表示加减乘除运算，当参与 / 运算的两个操作数都是整数时，表示整数触发；否则表示浮点除法。整数的求余操作 (有时称为取模)，用 % 表示。 1234a = 15 , b = 2 a/b=7a%b = 1;a=15.0a/b = 7.5 3.5.1 数学函数与常量在 Math 类中包含了各种各样的数学函数，比如这里有一个计算数值平方根的方法 123double x = 4;double y = Math.sqrt(x);// sqrt 接受一个 double 值System.out.println(y); 幂运算的方法 12// y 的值为 x 的 a 次幂，同样接受 double 值。double y = Math.pow(x,a); 3.5.2 数值类型之间的转换如果两个操作数中有一个是 double 类型，另一个操作数就会转换为 double 类型。否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。否则，如果其中一个操作数是 long 类型，另一个操作数将会转换为 long 类型。否则，两个操作数都将被转换为 int 类型。 3.5.4 结合赋值和运算符“+=”，“-=”，“*=”，“%=”，这些都是在赋值中使用二元运算符，但是不会改变数据的类型，例如： 123int x =2 ;x+=3.5;此时等价于： x = (int)(x+3.5)//先变成 double ，再被转换为 int 3.5.5 自增与自减运算符++n，n++，是两种不同的含义，如果把加号放在前缀，那么则会先自增，再运算表达式的值；如果放在后缀，那么则会先运算表达式的值，再自增。另外，++4，是错误的，自增与自减运算符只能用于变量，不能是数值。 1234567int a = 2;int c = 3;System.out.println(a++);System.out.println(++c);--------------------------24 3.5.6 关系和 boolean 运算符 == ：检测相等性 !=：检测不相等 &lt;，&gt;，&lt;=，&gt;=：小于，大于，小于等于，大于等于 &amp;&amp;：采用短路的做法，如果前者为 false ，则不计算后者 ||：采用短路的做法，如果前者为 true ，则不计算后者 ？： ：三元运算符，condition? expression1：expression2，如果 condition 为 true，就为第一个表达式的值，反之则为第二个表达式的值。 3.5.7 位运算符 &amp;：&amp; 在运算的时候，将 2 个数字的二进制做比较，当 2 个数字的值都为 1 时，才为 1，否则就是 0 |：数值运算符的时候 同样是比较 2 进制，当有一个数为 1，那么就取 1 ^：数值运算符的时候 同样是比较 2 进制， 只能有 1 个 1，那就取 1 ~：取反值 ：补最左边的数位时，会根据符号位， 符号是 1 就填充 1，符号是 0，就填充 0; &lt;&lt;：左移 &gt;&gt;&gt;：无符号右移: 对于正数 有符号与无符号的右移没有区别。 对于负数 来说，不管你是 0 还是 1，都会用 0 去补位 不管是正数还是负数，在底层，都是以补码的性质来存的1 1 1 1 1 1 1 1第一位是符号位，符号位是 0，就是正数，符号位是 1，就是负数00001010从最后一位开始计算 2 的 0 次方，2 的 1 次方，2 的 2 次方，2 的三次方 —-对于正数来说。原码，反码，补码 三码合一。负数的原码， 把最高位的 0 改为 1原码变为反码：各个位除符号位外取反，即 0 变成 1，1 变成 0反码变成补码 在反码的基础上 +1 3.5.8 括号与运算符级别如果不使用括号，就按照给出的运算符优先级次序进行计算，同一个级别的运算符按照从左到右的次序进行是计算 (除了右结合运算符)， 运算符 结合性 [] .()(方法调用) 从左向右 ! ~ ++ – +(一元运算) -(一元运算) ()(强制类型转换) new 从右向左 * / % 从左向右 +(正) -(负) 从左向右 &lt;&lt;&gt;&gt; &gt;&gt;&gt; 从左向右 &lt;&lt;=&gt; &gt;= instanceof 从左向右 == != 从左向右 &amp; 从左向右 ^ 从左向右 从左向右 &amp;&amp; 从左向右 逻辑或 从左向右 ?: 从右向左 = += -= *= /= %= &amp;= ^= &lt;&lt;=&gt;&gt;= &gt;&gt;&gt;= 从右向左 3.6 字符串Java 字符串就是 Unicode 字符序列，同时在标准 Java 类库中提供了一个预定义类 String substring()方法：可以从一个较大的字符串提取出一个字串 1234String greeting = &quot;Hello&quot;;String s = greeting.substring(0,3); result : Hel substring(a,b);//一般子串的长度就是 b-a 拼接：当将一个字符串与一个非字符串的值进行拼接时，后者会被转换为字符串。如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态 join 方法： 1234String all = String.join(&quot;-&quot;,&quot;name&quot;,&quot;age&quot;,&quot;school&quot; );System.out.println(all);result:name-age-school 不可变字符串在 Java 中，如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是：不能改变对象内的成员变量，其中基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。同时要区分对象和对象的引用 123456String abc = &quot;Hello&quot;;abc = &quot;GoGoGo&quot;;System.out.println(abc);------------GoGoGo//这里要说明的是，abc 只是一个 String 对象的引用，并不是对象本身，引用里面存放了它所指向的对象的地址，通过这个地址可以访问对象，这里其实是创建了一个新的 String 对象 &quot;GoGoGo&quot;，然后 abc 重新指向了这个对象。 3.6.4 检测字符串是否相等使用 equals 方法检测两个字符串是否相等，s.equals(t)，如果字符串 s 与字符串 t 相等，则返回 true，否则，返回 false。s 和 t 可以是字符串变量，也可以是字符串字面量： 123String abc = &quot;Hello&quot;;abc.equals(&quot;Hello&quot;);&quot;Hello&quot;.equals(abc); 如果你希望检测两个字符串是否相等，而不区分大小写，可以使用 equalsIgnoreCase 方法。不能使用== 来比较字符串是否相同，因为 == 比较的是变量的内存地址，而不是变量的值。 3.6.5 空串与 Null 串空串 “” 是长度为 0 的字符串，可以调用以下代码检查一个字符串是否为空。 12if(str.length()==0)if(str.equals(&quot;&quot;)) 空串是一个 Java 对象，有自己的串长度 (0) 和内容 (空) ，不过 String 变量还可以存放一个特殊值：null，表示目前没有任何对象与该变量关联，要检查一个字符串是否为 null，可以使用以下条件：if (str == null)有时要检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：if (str !=null &amp;&amp; str.length() != 0) 3.6.7 String API boolean equals(Object other) boolean equalsIgnoreCase(String other) boolean startWith(String prefix) 如果字符串以 prefix 开头，则返回 true boolean endsWith(String suffix) 如果字符串以 suffix 结尾，则返回 true int indexOf(String str) int indexOf(String str，int fromIndex) int indexOf(int cp) int indexOf(int cp，int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str，int fromIndex) int lastIndexOf(int cp) int lastIndexOf(int cp，int fromIndex) length() String replace(CharSequence oldString，CharSequence newString)，可以用 String 或 StringBuilder 对象作为 CharSequence 参数。 String substring(int beginIndex) String substring(int beginIndex，int endIndex) String toLowerCase() 转换为小写 String toUpperCase() 转换为大写 String trim() 这个字符串将删除原始字符串头部和尾部的空格 String join(CharSequence delimiter，CharSequence… elements) 3.6.9 构建字符串如果单纯用 String 来拼接字符串，每次连接字符串都会构建一个新的 String 对象，既耗时，又浪费空间，使用 StringBuilder 就可以避免这个问题的发生。 12345//构建一个空的字符串构建器 StringBuilder builder = new StringBuilder(); builder.append("Hello"); builder.append("World"); String completedString = builder.toString(); StringBuilder 的前身是 StringBuffer，StringBuffer 的效率略低，但是允许采用多线程的方式执行添加或删除字符的操作，如果所有字符串都再一个单线程中编辑，则应该使用 StringBuilder，这两个类的 API 是相同的。 StringBuilder() int length() StringBuilder append(String str) StringBuilder append(char c) StringBuilder insert(int offset,String str) StringBuilder insert(int offset,Char c) StringBuilder delete(int startIndex,int endIndex) String toString() 3.7 输入输出java.lang 不需要 import 加载。System.out 是标准输出流，System.in 是标准输入流，要想通过控制台输入，首先要构造一个 Scanner 对象，并与 System.in 关联。 1Scanner scanner = new Scanner(System.in); 1234scanner.nextLine()//读取输入的整行信息。scanner.next()//读取一个单词scanner.nextInt()//读取一个整数scanner.nextDouble()//读取一个浮点数 因为 Scanner 输入是可见的，所以不适用于从控制台读取密码。Java SE 6 引入了 Console 类来实现这个目的，想要读取一个密码，可以采用下列代码： 1234//在使用 Eclipse 或其他 IDE 的情况下，是无法获取 Console实例的Console cons =System.console();String userName = cons.readLine(&quot;User name:&quot;);char[] passWord = cons.readPassword(&quot;PassWord:&quot;); ScannerAPI Scanner(InputStream in) 用给定的输入流创建一个 Scanner 对象 String nextLine() String next() int nextInt() double nextDouble() boolean hesNext() boolean hasNextInt() boolean hasNextDouble() 3.7.2 格式化输出System.out.printf 沿用了 C 语言库函数中的 printf 方法，可以设置多个参数，例如： 123String name = &quot;Pudge&quot;; int age = 15; System.out.printf(&quot;Hello,%s. Next year,you&apos;ll be %d&quot;, name, age); 每一个以 % 字符开始的格式说明符都用相应的参数替换。个数说明符尾部的转换符将指示被格式化的数值类型： d 十进制整数 g 通用浮点数 s 字符串 c 字符 b 布尔用于 printf 的标志 $ 给定被格式化的参数索引，例如：%1$d printf 用于输出，可以使用 String.format 方法来创建一个格式化的字符串，而不打印输出。 3.7.3 文件输入与输出PrintWriter 3.8 控制流程Java 使用条件语句和循环结构确定控制流程。 3.8.1 块作用域块 (block，又复合语句)：由一对大括号括起来的若干条简单的 Java 语句。block 确定了变量的作用域。一个 block 可以嵌套在另一个 block 中， 12345678//在 main 方法块中嵌套另一个语句块的实例public static void main(String[] args) throws Exception &#123; int n; &#123; int k; &#125; &#125; 但是，不能在嵌套的两个块中声明同名的变量，例如下面的代码就又错误。 1234567public static void main(String[] args) throws Exception &#123; int n; &#123; int k; int n;//不能声明同名变量 &#125; &#125; 3.8.2 条件语句格式为 if(condition) statement，条件用括号括起来。else 子句与最邻近的 if 构成一组，例如：if (x&lt;=0) { if (x==0) sign = 0; else sign = -1;} 3.8.3 循环while (condition) statement，while 循环语句会首先检测循环条件，因此，循环体中的代码有可能不被执行。do/while 可以保证循环体至少执行一次，则应该将检测条件放在最后，语法格式为 do statement while (condition)，这种循环语句先执行语句 (通常是一个语句块)，再检测循环条件；然后重复语句，再检测循环条件，以此类推。for 循环是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或类似的变量来控制迭代次数。 123for (int i = 1; i&lt;=10; i++)&#123;System.out.println(i);&#125; 3.8.5 switch 语句switch 语句将从与选项值相匹配的 case 标签处开始执行，直到遇到 break 语句，或者执行到 switch 语句的结束处为止。如果没有相匹配的 case 标签，而有 default 子句，就执行这个子句。case 标签可以是： 类型为 char、byte、short、int 的常量表达式 枚举常量 从 Java 7 开始，case 标签还可以是字符串字面量 1234567//如果想让几个 case 执行相同的语句switch(name)&#123;case &quot;yes&quot;:case &quot;no&quot;: //sthbreak;&#125; 3.8.6 中断控制流程语句break 也可以中断循环或者条件语句，Java 还提供了一种带标签的 break 语句，用于跳出多重嵌套的循环语句。break 会跳出一个循环体，但假设这个循环体被外层循环嵌套，那么 break 是无法跳出外层循环的。continue 将控制转移到最内层循环的首部 (跳过本次循环)，同样的，continue 也可以使用标签机制。 3.9 大数值如果基本的整数和浮点数精度不能够满足需求，那么可以使用 java.math 包中的两个很有用的类：BigInteger 和 BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger 实现了任意精度的整数运算，BigDecimal 实现了任意精度的浮点数运算。 12345//使用静态的 valueOf 方法可以将普通的数值转换为大数值//不能使用+、-、*等运算符，需要使用add、multiply方法BigInteger a = BigInteger.valueOf(100);BigInteger c = a.add(b) // c = a + b BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); d = c *(b + 2); BigInteger API BigInteger add(BigInteger other)// 加法 BigInteger subtract(BigInteger other)// 减法 BigInteger multiply(BigInteger other)// 乘法 BigInteger divide(BigInteger other)// 除法 BigInteger mod(BigInteger other)// 取余 int compareTo(BigInteger other)// 比较，相等则返回 0，大于则返回 1，小于则返回 -1 BigDecimal API BigDecimal add(BigDecimal other) BigDecimal subtract(BigDecimal other) BigDecimal multiply(BigDecimal other) BigDecimal divide(BigDecimal other , RoundingMode mode)// 需要给出舍入方式，如 RoundingMode.HALF_UP 是在学校中学习的四舍五入方式 int compareTo(BigDecimal other) static BigDecimal valueOf(long x) static BigDecimal valueOf(long x, int scale)// x / 10^scale 3.10 数组是一种数据结构，用来存储同一类型值的集合。可以使用这两种形式来声明数组： 12int[] a ; int a[] ; 创建数组时，数字数组的初始值为 0，boolean 数组的初始值为 false。对象数组的初始值为 null。一旦创建了数组，那么数组的大小就不能再改变了。 3.10.1 for each 循环用来依次处理数组中的每个元素 (其他类型的元素集合亦可) 而不必为指定下标值而分心。for(variable : collection) statementcollection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象 (如 ArrayList)。如果想要快速打印一个数组的话，可以使用 Arrays.toString 方法。 3.10.2 数组初始化以及匿名数组int[] smallPrimes = {2,3,5,7,11,13} 这是一种简化书写形式，甚至可以初始化一个匿名的数组 new int[] {17, 19, 23, 29, 31, 37} 3.10.3 数组拷贝在 Java 中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组。这里要区别直接赋值与 copyOf 方法的区别。 12345678910111213141516171819public static void main(String[] args) throws Exception &#123; //声明三个数组 int[] a = &#123; 1, 2, 3, 4 &#125;; int[] b; int[] c; //直接赋值,a和b引用同一个数组,那么修改b,a也会受影响 b=a; b[0]=5; //此时把a再拷贝给c,如果a受影响,那么c[0]==5,反之c[0]==1 c =Arrays.copyOf(a, a.length); System.out.println(Arrays.toString(c)); //那么改变c的值,会影响a吗? c[0]=6; System.out.println(Arrays.toString(a)); &#125;------------------result:[5, 2, 3, 4][5, 2, 3, 4] 3.10.4 命令行参数main 方法中接收一个参数 String[] args，如果我们不使用任何 IDE，那么我们可以这样传递参数： 1234567891011121314151617181920212223//调用虚拟机运行 Java 程序//java 类名 参数1 参数2 参数3... //java FirstSample -g cruel worldpublic class FirstSample &#123; public static void main(String[] args) throws Exception &#123; if (args.length == 0 || args[0].equals(&quot;-h&quot;)) System.out.print(&quot;Hello,&quot;); else if (args[0].equals(&quot;-g&quot;)) ; System.out.print(&quot;Goodbye,&quot;); for (int i = 1; i &lt; args.length; i++) &#123; System.out.print(&quot; &quot; + args[i]); &#125; System.out.println(&quot;!&quot;); &#125;&#125;result ---------------------Goodbye, cruel world! 3.10.5 数组排序要想对数值型数组进行排序，可以使用 Arrays 类中的 sort 方法，这个方法使用了优化的快速排序算法。Math.random 方法将返回一个 0 到 1 之间 (包含 0，不包含 1) 的随机浮点数。 12345678910111213141516171819//小型抽奖。public static void main(String[] args) throws Exception &#123; int[] numbers = new int[20]; int[] result = new int[5]; for(int i =0;i&lt;numbers.length;i++)&#123; numbers[i] = i+1; &#125; int n = numbers.length; for(int i = 0;i&lt;result.length;i++)&#123; int r = (int)(Math.random() * n);//0&lt;=n&lt;19 result[i] = numbers[r];//19 numbers[r] = numbers[n-1];//把最后一位数字赋值给抽到过的数字。 n--;//18 &#125; Arrays.sort(result); for(int r:result)&#123; System.out.println(r); &#125; &#125; Arrays API String toString(type[] a) 返回包含数组数值的字符串 type copyOf(type[] a , int length) type copyRange(type[] a, int start, int end) end 终止下标 (不包含) void sort(type[] a ) int binarySearch(type[] a , type v) int binarySearch(type[] a, int start, int end, type v) 采用二分搜索算法查找值 v vod fill(type[] a, type v) 将数组的所有数据元素值设置为 v boolean equals(type[] a, type[] b) 如果两个数组大小相同，并且下标相同的元素都对应相等，返回 true。 String Arrays.deepToString(a) 打印一个二维数组列表 3.10.6 多维数组适用于表示表格或更加复杂的排列形式。多维数组又被称为叫二维数组，与一般数组的初始化方式相同 12345678double[][] balances;int[][] magicSquare = &#123; &#123;16,3,2,16&#125;, &#123;5,10,11,8&#125;, &#123;9,6,7,12&#125;, &#123;4,15,14,1&#125;&#125;//可以通过 magicSquare[][]的方式来访问。 要想循环遍历其中的数据，我们有这种嵌套循环的方法： 123456for(double[] row : a)&#123; for(double value : row) do something with value&#125;//如果要打印列表Arrays.deepToString(a) 3.10.7 不规则数组由于二维数组可以看成是数组的每个元素是数组，所以可以进行数组换行。 123double[] temp = balances[i]balances[i] = balances[i + 1]//把balances[i] 和 balances[i + 1]数据进行交换balances[i + 1] = temp 总结 总结： Java 是强类型语言，有 8 种基本数据类型：4 种整型、2 种浮点型、1 种字符型、1 种布尔型。分别为：byte、short、int、long、float、double、char、boolean。 占用字节数：byte:1 字节、short：2 字节、int：4 字节、long：8 字节、float：4 字节、double：8 字节。Java 中所有数值类型所占字节数量与平台无关。 byte 与 char 区别：• byte 是有符号型，char 是无符号型；byte 占 1 字节，8 位，表示 - 127 到 128，char 占 2 字节，16 位，表示 0~65536。• byte 可以初始化为数字或字符，最终表示的是数值，char 可以初始化为数字或字符，最终表示的是字符。• char 可以表示中文，byte 不可以；对于英文可以相互转化，byte 代表的是 ASCII 码，char 代表对应的字符。 注意不要用浮点型来进行金融计算，如（2.0-1.1=0.89999…），因为二进制无法精确表示 1/10；尽量不要在程序中使用 char 类型。 码点是指一个编码表中某个字符对应的代码值，在 Unicode 标准中采用 16 进制书写，并加上前缀 U+。UTF-16 编码采用不同长度表示码点，每个字符用 16 位表示，通常被称为代码单元，辅助字符一般采用一对连续的代码单元进行编码。因此最好别用 char 类型。 一个字符串与非字符串的值拼接时，后者会被转为字符串。 格式化输出：(&quot;%1$d,%2$s&quot;,99,&quot;abc&quot;)-&gt; 输出(99，abc)；% 是格式化关键字，$ 表示参数索引。索引必须在 % 后面，以 $ 结尾，以 1 开头。 &amp;&amp; 的优先级高于 ||，+= 是右结合运算符。a+=b+=c，会先进行 b+=c，然后在 +=a。 C++ 中可以在嵌套语句块中定义重名变量，内层会覆盖外层变量，但是 Java 不可以。 else 语句与相邻最近的一个 if 语句为一对。 case 标签可以是 char、byte、short、int、枚举常量和 String(Java SE7 后支持)。 break：跳出循环体；签名定义好标签 break label 可以跳出多层嵌套循环；continue：不执行后面的逻辑，直接进行下一次循环。 数组是一种数据结构，用来存储同一类型值的集合。创建数组时，数值型初始化为 0、布尔型初始化为 false、对象型初始化为 null。一旦创建后就不能改变它的大小了。 创建数组三种方法：• int[] a = new int[10];• int[] a = {1,2,3};• int[] a = new int[]{1,2,3}。 打印数组：Arrays.toString(a)；打印多维数组：Arrays.deepToString(a)。 数组的Arrays.copyOf()方法拷贝一个新的引用；Arrays.sort()方法使用了优化的快速排序算法来排序数组；Arrays.binarySearch()采取二分查找算法查询指定值。还有fill()、qeuals()等方法。 Arrays 具有封装好的许多静态方法提供给我们对数组进行使用。如toString()、copyOf()、copyOfRange()、sort()、binarySearch()、fill()、equals()等，更多 api 见 P85。 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（1~2章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18%2F</url>
    <content type="text"><![CDATA[第一章：Java 程序设计概述1.2 Java语言的设计特性 简单性 Java语法剔除了C++中很少或难以理解的特性，没有头文件，指针运算，结构等，语法相对纯净。 另一个简单是小，Java支持嵌入式，可在小型机器上运行，基本解释器和类仅40KB，再加上类库和对线程的支持也不过175KB。当然现在用于类库的扩大，有了独立专用的较小类库Java微型版(Java Micro Edition)用于嵌入式设备。 面向对象 简单说，面向对象设计是一种程序设计技术，重点关注数据(即对象)和对象的接口。本质上Java的面向对象能力与 C++一样，主要不同点在于多继承，Java取而代之的是简单的接口概念，并提供了更丰富的运行时自省功能。 网络功能(分布式) Java拥有扩展的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java程序可通过URL打开和访问网络对象，十分便捷。 健壮性 Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性，Java编译器能够检测许多其他语言仅在运行时刻才能检测出来的问题 安全性 Java在设计时就注意防范诸如运行时堆栈溢出，破坏自己的进程空间之外的内存，未经授权读写文件等问题。不可信代码将在沙箱中运行。 体系结构中立 体现了一处编译，到处运行的思想。编译器编译的字节码，可以在不同处理器上运行，而与计算机体系结构无关，只要有Java运行时系统就可以运行，可以通过Java虚拟机翻译成机器码，即即时编译。 可移植性 Java 中的 int 永远是 32 位，int 的大小不低于 short int，不高于 long int。C/C++ 中 int 可能是 16 位也可能是 32 位，或是编译器提供商指定的其他大小。 与C/C++不同，Java没有“可依赖具体实现”的地方，其基本数据类型的大小以及有关运算都做了明确说明。在Java中，数据类型具有固定大小，二进制数据以固定格式进行存储和传输(消除了字节顺序的困扰)，字符串用标准Unicode格式存储，这消除移植代码问题。 解释性 Java解释器可以在任何移植了解释器的机器上执行Java字节码。 高性能 字节码可以(在运行时刻)动态地翻译成对应运行此应用特定CPU的机器码。依赖虚拟机的即时编译或即时编译器。 多线程 多线程可以带来更好的交互响应和实时行为。在底层，主流平台的线程实现机制各不相同，但Java在不同机器上，调用多线程的代码完全相同，把多线程的实现交给底层的操作系统或线程库来完成。 动态性 相对C/C++，Java库中自由地添加新方法和实例变量，对客户端不会有影响，尤其是正在运行的程序时。 1.5 关于Java的常见误解 Java是HTML的扩展 Java是一种程序设计语言，HTML是一种描述网页结构的方式。二者没有共同之处。 使用XML，所以不需要Java XML是一种描述数据的方式，可以使用任何程序设计语言来处理XML数据，Java API对XML处理提供了很好的支持，也有很多XML第三方工具采用Java编写。 Java将成为适用于所有平台的通用性编程语言 理论上可能，实际上难度很大，Java在服务器端变成和跨平台客户端应用领域比较有优势 Java只不过一种程序设计语言 程序设计语言的成功取决于其支撑系统的能力或者解决问题的能力，而非语法，Java减少指针错误，编程效率更高，这并非Java成功的全部原因。 Java是解释型的，对关键应用程序速度太慢了 早期Java是解释型的，现在Java虚拟机采用即时编译器，运行速度和C++差不多。PS:现在随着计算机性能提升，解释性语言或者编译型语言对运行效率的影响已经很小了。 JavaScript是Java的简易版 JavaScript是一种网页中使用的脚本语言，其语法类似Java，除此之外再无关系。 第二章：Java 程序设计环境Java 程序执行流程下面这幅图简单说明了 Java 程序的执行过程。 Java 工具简介下面简单介绍一下 Java 的一些工具。 JVM JVM（Java Virtual Machine），Java 虚拟机 JVM 是 Java 平台无关性实现的关键 JDK JDK（Java Development Kit），Java 语言的软件开发工具包。 两个主要的组件1 javac – 编译器，将源程序转成字节码2 java – 运行编译后的 java 程序（.class 后缀的） JRE JRE（Java Runtime Environment），Java 运行环境 包括 Java 虚拟机（JVM），Java 核心类库和支持文件 如果只需要运行 Java 程序，下载并安装 JRE 即可 JDK、JRE、JVM 三者关系用下面一幅图表示 概括一下就是 JRE = JVM + JavaSE 标准类库 JDK = JRE + 开发工具集（例如 javac 编译工具等） Java 平台分类最后再补充的就是 Java 平台分类，Java 平台可以分成下面三类 JavaSE主要用于开发桌面程序，也称为 Java 标准版。 JavaEE主要用于 Web 程序开发，也称为 Java 企业版。 JavaME主要用于移动设备的开发，也称为 Java 微型版。不过自从 Android 和 iOS 兴起后它就用的很少了。 参考：https://www.jianshu.com/p/559d35944079第1章：http://xuer80.com/2017/11/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/第2章：https://www.jianshu.com/p/3dd960faf7ff]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“大话架构”阿里架构师分享的Java程序员需要突破的技术要点]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-4%2F</url>
    <content type="text"><![CDATA[一、源码分析源码分析是一种临界知识，掌握了这种临界知识，能不变应万变，源码分析对于很多人来说很枯燥，生涩难懂。 源码阅读，我觉得最核心有三点：技术基础 + 强烈的求知欲 + 耐心。 我认为是阅读源码的最核心驱动力。我见到绝大多数程序员，对学习的态度，基本上就是这几个层次 (很偏激哦)： 1、只关注项目本身，不懂就 baidu 一下。 2、除了做好项目，还会阅读和项目有关的技术书籍，看 wikipedia。 3、除了阅读和项目相关的书外，还会阅读 IT 行业的书，比如学 Java 时，还会去了解函数语言，如 LISP。 4、找一些开源项目看看，大量试用第三方框架，还会写写 demo。 5、阅读基础框架、J2EE 规范、Debug 服务器内核。 大多数程序都是第 1 种，到第 5 种不光需要浓厚的兴趣，还需要勇气：我能读懂吗？其实，你能够读懂的 耐心，真的很重要。因为你极少看到阅读源码的指导性文章或书籍，也没有人要求或建议你读。你读的过程中经常会卡住，而一卡主可能就陷进了迷宫。这时，你需要做的，可能是暂时中断一下，再从外围看看它：如 API 结构、框架的设计图。 下图是我总结出目前最应该学习的源码知识点： 二、分布式架构分布式系统是一个古老而宽泛的话题，而近几年因为 “大数据” 概念的兴起，又焕发出了新的青春与活力。除此之外，分布式系统也是一门理论模型与工程技法并重的学科内容。相比于机器学习这样的研究方向，学习分布式系统的同学往往会感觉：“入门容易，深入难”。的确，学习分布式系统几乎不需要太多数学知识。 分布式系统是一个复杂且宽泛的研究领域，学习一两门在线课程，看一两本书可能都是不能完全覆盖其所有内容的。 总的来说，分布式系统要做的任务就是把多台机器有机的组合、连接起来，让其协同完成一件任务，可以是计算任务，也可以是存储任务。如果一定要给近些年的分布式系统研究做一个分类的话，我个人认为大概可以包括三大部分： 分布式存储系统 分布式计算系统 分布式管理系统 下图是我总结近几年目前分布式最主流的技术： 三、微服务当前微服务很热，大家都号称在使用微服务架构，但究竟什么是微服务架构？微服务架构是不是发展趋势？对于这些问题，我们都缺乏清楚的认识。 为解决单体架构下的各种问题，微服务架构应运而生。与其构建一个臃肿庞大、难以驯服的怪兽，还不如及早将服务拆分。微服务的核心思想便是服务拆分与解耦，降低复杂性。微服务强调将功能合理拆解，尽可能保证每个服务的功能单一，按照单一责任原则（Single Responsibility Principle）明确角色。 将各个服务做轻，从而做到灵活、可复用，亦可根据各个服务自身资源需求，单独布署，单独作横向扩展。 下图是我总结出微服务需要学习的知识点： 四、性能优化不管是应付前端面试还是改进产品体验，性能优化都是躲不开的话题。 优化的目的是让用户有 “快” 的感受，那如何让用户感受到快呢？ 加载速度真的很快，用户打开输入网址按下回车立即看到了页面加载速度并没有变快，但用户感觉你的网站很快性能优化取决于多个因素，包括垃圾收集、虚拟机和底层操作系统（OS）设置。有多个工具可供开发人员进行分析和优化时使用，你可以通过阅读 Java Tools for Source Code Optimization and Analysis 来学习和使用它们。 必须要明白的是，没有两个应用程序可以使用相同的优化方式，也没有完美的优化 java 应用程序的参考路径。使用最佳实践并且坚持采用适当的方式处理性能优化。想要达到真正最高的性能优化，你作为一个 Java 开发人员，需要对 Java 虚拟机（JVM）和底层操作系统有正确的理解。 以上五大知识体系是我从业多年总结出来的经验，都是当前最主流的技术。想学习这些技术的朋友可以加群：478030634。群里会分享这些技术知识点供大家学习免费下载 下图是我总结性能优化应该学习理解的几大知识体系： 五、Java 工程化工欲善其事，必先利其器，不管是小白，还是资深开发，都需要先选择好的工具。提升开发效率何团队协作效率。让自己有更多时间来思考。 “大话架构” 阿里架构师分享的 Java 程序员需要突破的技术要点 原文：https://segmentfault.com/a/1190000013561054]]></content>
      <tags>
        <tag>待阅</tag>
        <tag>架构</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试中并发类问题的准备和学习]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-3%2F</url>
    <content type="text"><![CDATA[声明：本文主要讨论的是后端Java开发职位的面试 主题 又到面试季了，从课程的群里，看到许多同学分享了自己的面试题目，我也抽空在网上搜索了一些许多公司使用的面试题，目前校招和社招的面试题基本都集中在几个大方向上，主要是：Java基础、并发、JVM、算法、数据库、一些框架、分布式集群 等。这里呢，单独就面试中的【并发】问题的准备和学习发表一下个人的见解。 现状 关于对并发的学习和理解，通过和许多学员沟通及大家在课程群里的反馈，总结一下，主要包含以下几种： 完全不知道并发的存在 知道并发要学，但是不知道该学习什么 知道并发重要，自己买相关书籍学，但是看完了还是懵懵懂懂 知道并发重要，自己查资料学了一些，许多都学会了，但总能发现不会的，不知道并发到底都要学什么 已经完成进阶，并发的问题了然于胸，这样的学员目前很少 首先说一下，为什么Java面试要考并发，而且并发相关的题目占比又是那么的高。对并发有一定了解的同学，应该都知道，大家平时 只要做Java项目就会涉及到并发 ，个别同学说自己从没接触过并发，这只是个人还没意识到而已。当你定义好一个可以调用的接口时，这时其实就已经和并发有关系了，因为任何一个接口都可能同时被请求多次。当你在项目中已经可以熟练的使用synchronized、volatile、static、final这些基本的Java关键字时，其实你对并发已经有一些基础了。大家总说的：面试造火箭、入职拧螺丝，其实有一部分原因也是因为你还没意识到面试考的这些东西其实一直就伴随着你的日常开发。 我不自量力的去列一下并发涉及到的关键字、类及可以考察的知识点：CPU缓存、Java内存模型JMM、atomic、AtomicInteger、AtomicLong、LongAdder、AtomicReference、AtomicBoolean、CAS原理、Unsafe、synchronized、volatile、final、static、ThreadLocal、AQS、J.U.C、CountDownLatch、Semaphore、CyclicBarrier、ReentrantLock、ReentrantReadWriteLock、StampLock、Condition、FutureTask、Fork/Join、BlockingQueue、ThreadPoolExecutor、ExecutorService、Thread、Runnable、Future、Callable、HashMap、 HashTable、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、RateLimiter、SimpleDateFormat、StringBuffer、StringBuilder、ArrayList、Vector、HashSet、ConcurrentSkipListSet、Collections.synchronizedXXX、Guava Cache、Redis … 我尝试去写出脑海里与并发有关的类和名词，我发现根本写！不！完！是的，并发的知识太多了，以致于很难给出一个完整的囊括。 因此呢，如果你盲目的一个知识点一个知识的去学，你就会发现你怎么都学不完，也很难在脑海里形成一个完整的知识体系，带来的最直接结果就是，你每次去面试时都要去把并发相关的再过一下，生怕自己被问到还没接触的。这时候，你要做的就是，先要在脑海里有一个完整的并发知识体系，然后根据这个体系去不断完善这个体系里每个模块的细节。 并发 关于并发的学习，可以从JDK提供的并发包为核心开始，许多其他的类和封装都是对其进行扩展或者补充，我们来看一下Java并发包(java.util.concurrent包，简称J.U.C)的构成： J.U.C核心由5大块组成：atomic包、locks包、collections包、tools包（AQS）、executor包（线程池）。大家平时遇到许多并发相关的类都可以从这里找到。但是呢，要想系统的掌握并发，不能是打开J.U.C这个包，挨个类去看，这里只是提供了五大块，代表核心的五个方向。要想系统的学习并发，还需要从并发的角度学习，过程中覆盖J.U.C的这些知识。这里我直接给出并发的学习步骤图（包含对当前面试常见考点的覆盖，比如对HashMap和ConcurrentHashMap的源码分析）： 这个之前呢，还需要对Java并发的基础进行细致的学习，比如CPU缓存和Java内存模型（JMM），许多关键字比如volatile、synchronized等的特性都是在JMM里规定好的。 高并发 我们这篇手记题目里提到的并发其实包含两部分：并发和高并发。手记讲到现在，其实我们讲的都是两部分里的第一部分：并发。那么并发和高并发到底有什么区别呢？许多学员对这两个概念都是模糊的，我简单做一下区分。 当我们说多线程并发时，其实我们更多的是讨论多个线程操作了相同的资源，这时我们讨论点更多的是落在保证线程安全以及合理分配和使用资源上。而高并发主要指系统运行过程中遇到“短时间内遇到大量操作请求”的情况，主要发生在系统集中收到大量请求（例如：12306的抢票情况；天猫双十一活动）。当我们说高并发时，我们谈的是是如何提高现有程序的性能，更多的是对高并发场景的一些解决方案，思路啦、手段等等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等。这里呢，我直接给出高并发场景通常都会考虑的一些解决思路和手段： 结尾 如何有效的准备面试中并发类问题，我已经给出我的理解。希望这些能帮大家在脑海里建立起大致的并发知识体系，然后根据这个知识体系有针对性的的去准备面试。预祝大家能高分通过面试，拿到高薪！ 当然，光提概念光看图是没用的，还需要大家根据这些提纲去实际学习相关的知识点和类才行。我已经准备好了这些实际知识点学习的流程，相信聪明的你已经知道该怎么办了~ 原文地址 https://www.imooc.com/article/23969]]></content>
      <tags>
        <tag>并发</tag>
        <tag>面试</tag>
        <tag>待阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典Java面试题95道]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-2%2F</url>
    <content type="text"><![CDATA[1、面向对象的特征有哪些方面？ 答：面向对象的特征主要有以下几个方面： 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中关于桥梁模式的部分）。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 2、访问修饰符 public,private,protected, 以及不写（默认）时的区别？ 类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。 3、String 是最基本的数据类型吗？ 答：不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。 4、float f=3.4; 是否正确？ 答: 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float)3.4; 或者写成 float f =3.4F; 5、short s1 = 1; s1 = s1 + 1; 有错吗? short s1 = 1; s1 += 1; 有错吗？ 答：对于 short s1 = 1; s1 = s1 + 1; 由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1; 可以正确编译，因为 s1+= 1; 相当于 s1 = (short)(s1 + 1); 其中有隐含的强制类型转换。 6、Java 有没有 goto？ 答：goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 7、int 和 Integer 有什么区别？ 答：Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱 / 拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 12345678910class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示： 123456789public class Test03 &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，所以下面的 == 运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf，如果看看 valueOf 的源代码就知道发生了什么。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache 是 Integer 的内部类，其代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 简单的说，如果整型字面量的值在 - 128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1==f2 的结果是 true，而 f3==f4 的结果是 false。 提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。 8、&amp; 和 &amp;&amp; 的区别？ 答：&amp; 运算符有两种用法：(1) 按位与；(2) 逻辑与。&amp;&amp; 运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;&amp; 之所以称为短路运算是因为，如果 &amp;&amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用 &amp;&amp; 而不是 &amp;，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用 &amp; 运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 补充：如果你熟悉 JavaScript，那你可能更能感受到短路运算的强大，想成为 JavaScript 的高手就先从玩转短路运算开始吧。 9、解释内存中的栈 (stack)、堆(heap) 和方法区 (method area) 的用法。 答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”hello” 和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。 String str = new String(“hello”);上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而 “hello” 这个字面量是放在方法区的。 补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发展和 “逃逸分析” 技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。 补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的。 看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否一致。 123456String s1 = new StringBuilder(&quot;go&quot;) .append(&quot;od&quot;).toString();System.out.println(s1.intern() == s1);String s2 = new StringBuilder(&quot;ja&quot;) .append(&quot;va&quot;).toString();System.out.println(s2.intern() == s2); 10、Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少？ 答：Math.round(11.5) 的返回值是 12，Math.round(-11.5) 的返回值是 - 11。四舍五入的原理是在参数上加 0.5 然后进行下取整。 11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？ 答：在 Java 5 以前，switch(expr) 中，expr 只能是 byte、short、char、int。从 Java 5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 12、用最有效率的方法计算 2 乘以 8？ 答： 2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。 补充：我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答案你可以自己百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于 (num &lt;&lt; 5) - num，左移 5 位相当于乘以 2 的 5 次方再减去自身就相当于乘以 31，现在的 VM 都能自动完成这个优化。 1234567891011121314151617181920212223242526272829303132333435363738394041public class PhoneNumber &#123; private int areaCode; private String prefix; private String lineNumber; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + areaCode; result = prime * result + ((lineNumber == null) ? 0 : lineNumber.hashCode()); result = prime * result + ((prefix == null) ? 0 : prefix.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PhoneNumber other = (PhoneNumber) obj; if (areaCode != other.areaCode) return false; if (lineNumber == null) &#123; if (other.lineNumber != null) return false; &#125; else if (!lineNumber.equals(other.lineNumber)) return false; if (prefix == null) &#123; if (other.prefix != null) return false; &#125; else if (!prefix.equals(other.prefix)) return false; return true; &#125;&#125; 13、数组有没有 length() 方法？String 有没有 length() 方法？ 答：数组没有 length() 方法，有 length 的属性。String 有 length() 方法。JavaScript 中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。 14、在 Java 中，如何跳出当前的多重嵌套循环？ 答：在最外层循环前加一个标记如 A，然后用 break A; 可以跳出多重循环。（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++ 中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好） 15、构造器（constructor）是否可被重写（override）？ 答：构造器不能被继承，因此不能被重写，但可以被重载。 16、两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对？ 答：不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1) 如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；(2) 如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 补充：关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人也就是仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java 程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍 equals 方法的：首先 equals 方法必须满足自反性（x.equals(x) 必须返回 true）、对称性（x.equals(y) 返回 true 时，y.equals(x) 也必须返回 true）、传递性（x.equals(y) 和 y.equals(z) 都返回 true 时，x.equals(z) 也必须返回 true）和一致性（当 x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y) 应该得到同样的返回值），而且对于任何非 null 值的引用 x，x.equals(null) 必须返回 false。实现高质量的 equals 方法的诀窍包括：1. 使用 == 操作符检查 “参数是否为这个对象的引用”；2. 使用 instanceof 操作符检查 “参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性；5. 重写 equals 时总是要重写 hashCode；6. 不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉 @Override 注解。 17、是否可以继承 String 类？ 答：String 类是 final 类，不可以被继承。 补充：继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是按值传递还是按引用传递？ 答：是按值传递。Java 语言的方法调用只支持参数的按值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但在方法内部对对象引用的改变是不会影响到被调用者的。C++ 和 C# 中可以通过传引用或传输出参数来改变传入的参数的值。在 C# 中可以编写如下所示的代码，但是在 Java 中却做不到。 12345678910111213141516171819using System;namespace CS01 &#123; class Program &#123; public static void swap(ref int x, ref int y) &#123; int temp = x; x = y; y = temp; &#125; public static void Main (string[] args) &#123; int a = 5, b = 10; swap (ref a, ref b); // a = 10, b = 5; Console.WriteLine (&quot;a = &#123;0&#125;, b = &#123;1&#125;&quot;, a, b); &#125; &#125;&#125; 说明：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++ 转型为 Java 程序员的开发者无法容忍。 19、String 和 StringBuilder、StringBuffer 的区别？ 答：Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。 面试题 1 - 什么情况下用 + 运算符进行字符串连接比调用 StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？ 面试题 2 - 请说出下面程序的输出。 12345678910111213141516class StringEqualTest &#123; public static void main(String[] args) &#123; String s1 = &quot;Programming&quot;; String s2 = new String(&quot;Programming&quot;); String s3 = &quot;Program&quot;; String s4 = &quot;ming&quot;; String s5 = &quot;Program&quot; + &quot;ming&quot;; String s6 = s3 + s4; System.out.println(s1 == s2); System.out.println(s1 == s5); System.out.println(s1 == s6); System.out.println(s1 == s6.intern()); System.out.println(s2 == s2.intern()); &#125;&#125; 补充：解答上面的面试题需要清除两点：1. String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2. 字符串的 + 操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class 命令获得 class 文件对应的 JVM 字节码指令就可以看出来。 20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 面试题：华为的面试题中曾经问过这样一个问题 - “为什么不能根据返回类型来区分重载”，快说出你的答案吧！ 因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。 例如： 12float max(int a, int b);int max(int a, int b); 当调用 max(1, 2); 时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。 21、描述一下 JVM 加载 class 文件的原理机制？ 答：JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的. class 文件中的数据读入到内存中，通常是创建一个字节数组读入. class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2) 如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）； Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap； System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中加载类，是用户自定义加载器的默认父加载器。 22、char 型变量中能不能存贮一个中文汉字，为什么？ 答：char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。 补充：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体 / 共用体）共享内存的特征来实现了。 23、抽象类（abstract class）和接口（interface）有什么异同？ 答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 24、静态嵌套类 (Static Nested Class) 和内部类（Inner Class）的不同？ 答：Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 扑克类（一副扑克） * */public class Poker &#123; private static String[] suites = &#123;&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;&#125;; private static int[] faces = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13&#125;; private Card[] cards; /** * 构造器 * */ public Poker() &#123; cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) &#123; for(int j = 0; j &lt; faces.length; j++) &#123; cards[i * 13 + j] = new Card(suites[i], faces[j]); &#125; &#125; &#125; /** * 洗牌 （随机乱序） * */ public void shuffle() &#123; for(int i = 0, len = cards.length; i &lt; len; i++) &#123; int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; &#125; &#125; /** * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) &#123; return cards[index]; &#125; /** * 卡片类（一张扑克） * [内部类] * */ public class Card &#123; private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) &#123; this.suite = suite; this.face = face; &#125; @Override public String toString() &#123; String faceStr = &quot;&quot;; switch(face) &#123; case 1: faceStr = &quot;A&quot;; break; case 11: faceStr = &quot;J&quot;; break; case 12: faceStr = &quot;Q&quot;; break; case 13: faceStr = &quot;K&quot;; break; default: faceStr = String.valueOf(face); &#125; return suite + faceStr; &#125; &#125;&#125; 测试代码： 1234567891011121314class PokerTest &#123; public static void main(String[] args) &#123; Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A &#125;&#125; 面试题 - 下面的代码哪些地方会产生编译错误？ 123456789101112class Outer &#123; class Inner &#123;&#125; public static void foo() &#123; new Inner(); &#125; public void bar() &#123; new Inner(); &#125; public static void main(String[] args) &#123; new Inner(); &#125;&#125; 注意：Java 中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中 foo 和 main 方法都是静态方法，静态方法中没有 this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： 1new Outer().new Inner(); 25、Java 中会存在内存泄漏吗，请简单描述。 答：理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。例如 Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。 123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.EmptyStackException;public class MyStack&lt;T&#123; private T[] elements; private int size = 0; private static final int INIT_CAPACITY = 16; public MyStack() &#123; elements = (T[]) new Object[INIT_CAPACITY]; &#125; public void push(T elem) &#123; ensureCapacity(); elements[size++] = elem; &#125; public T pop() &#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) &#123; elements = Arrays.copyOf(elements, 2 * size + 1); &#125; &#125;&#125; 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发 Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成 OutOfMemoryError。 26、抽象的（abstract）方法是否可同时是静态的（static）, 是否可同时是本地方法（native），是否可同时被 synchronized 修饰？ 答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 27、阐述静态变量和实例变量的区别。 答：静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。 28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？ 答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。 29、如何实现对象克隆？ 答：有两种方式： 1). 实现 Cloneable 接口并重写 Object 类中的 clone() 方法； 2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下： 1234567891011121314151617181920212223242526import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T extends SerializableT clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 &#125;&#125; 下面是测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.io.Serializable;/** * 人类 * @author nnngu * */class Person implements Serializable &#123; private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) &#123; this.name = name; this.age = age; this.car = car; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return &quot;Person []&quot;; &#125;&#125;/** * 小汽车类 * @author nnngu * */class Car implements Serializable &#123; private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) &#123; this.brand = brand; this.maxSpeed = maxSpeed; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, maxSpeed=&quot; + maxSpeed + &quot;]&quot;; &#125;&#125;class CloneTest &#123; public static void main(String[] args) &#123; try &#123; Person p1 = new Person(&quot;郭靖&quot;, 33, new Car(&quot;Benz&quot;, 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand(&quot;BYD&quot;); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 30、GC 是什么？为什么要有 GC？ 答：GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显式操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显式的垃圾回收调用。 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的 Java 进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和清除，但是 Java 对其进行了改进，采用 “分代式垃圾收集”。这种方法会根据 Java 对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 与垃圾回收相关的 JVM 参数： -Xms / -Xmx — 堆的初始大小 / 堆的最大大小 -Xmn — 堆中年轻代的大小 -XX:-DisableExplicitGC — 让 System.gc() 不产生任何作用 -XX:+PrintGCDetails — 打印 GC 的细节 -XX:+PrintGCDateStamps — 打印 GC 操作的时间戳 -XX:NewSize / XX:MaxNewSize — 设置新生代大小 / 新生代最大大小 -XX:NewRatio — 可以设置老生代和新生代的比例 -XX:PrintTenuringDistribution — 设置每次新生代 GC 后输出幸存者乐园中对象年龄的分布 -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值 -XX:TargetSurvivorRatio：设置幸存区的目标使用率 31、String s = new String(“xyz”); 创建了几个字符串对象？ 答：两个对象，一个是静态区的 “xyz”，一个是用 new 创建在堆上的对象。 32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 答：接口可以继承接口，而且支持多重继承。抽象类可以实现 (implements) 接口，抽象类可继承具体类也可以继承抽象类。 举一个多继承的例子，我们定义一个动物（类）既是狗（父类 1）也是猫（父类 2），两个父类都有 “叫” 这个方法。那么当我们调用 “叫” 这个方法时，它就不知道是狗叫还是猫叫了，这就是多重继承的冲突。而接口没有具体的方法实现，所以多继承接口也不会出现这种冲突。 33、一个 “.java” 源文件中是否可以包含多个类（不是内部类）？有什么限制？ 答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。 34、Anonymous Inner Class(匿名内部类) 是否可以继承其它类？是否可以实现接口？ 答：可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来实现事件监听和回调。 35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。 36、Java 中的 final 关键字有哪些用法？ 答：(1) 修饰类：表示该类不能被继承；(2) 修饰方法：表示方法不能被重写；(3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 37、指出下面程序的运行结果。 123456789101112131415161718192021222324252627282930class A &#123; static &#123; System.out.print(&quot;1&quot;); &#125; public A() &#123; System.out.print(&quot;2&quot;); &#125;&#125;class B extends A&#123; static &#123; System.out.print(&quot;a&quot;); &#125; public B() &#123; System.out.print(&quot;b&quot;); &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; A ab = new B(); ab = new B(); &#125;&#125; 答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。 提示：如果不能给出此题的正确答案，说明之前第 21 题 Java 类加载机制还没有完全理解，赶紧再看看吧。 38、数据类型之间的转换： 如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？ 答： 调用基本数据类型对应的包装类中的方法 parseXXX(String) 或 valueOf(String) 即可返回相应基本类型； 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用 String 类中的 valueOf() 方法返回相应字符串 39、如何实现字符串的反转及替换？ 答：方法很多，可以自己写实现也可以使用 String 或 StringBuffer/StringBuilder 中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示： 12345public static String reverse(String originStr) &#123; if(originStr == null || originStr.length() &lt;= 1) return originStr; return reverse(originStr.substring(1)) + originStr.charAt(0);&#125; 40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？ 答：代码如下所示： 12String s1 = &quot;你好&quot;;String s2 = new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); 41、日期和时间： 如何取得年月日、小时分钟秒？如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？如何取得某月的最后一天？如何格式化日期？ 答： 问题 1：创建 java.util.Calendar 实例，调用其 get() 方法传入不同的参数即可获得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTimel 来获取，代码如下所示。 1234567891011121314151617181920public class DateTimeTest &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.println(cal.get(Calendar.YEAR)); System.out.println(cal.get(Calendar.MONTH)); // 0 - 11 System.out.println(cal.get(Calendar.DATE)); System.out.println(cal.get(Calendar.HOUR_OF_DAY)); System.out.println(cal.get(Calendar.MINUTE)); System.out.println(cal.get(Calendar.SECOND)); // Java 8 LocalDateTime dt = LocalDateTime.now(); System.out.println(dt.getYear()); System.out.println(dt.getMonthValue()); // 1 - 12 System.out.println(dt.getDayOfMonth()); System.out.println(dt.getHour()); System.out.println(dt.getMinute()); System.out.println(dt.getSecond()); &#125;&#125; 问题 2：以下方法均可获得该毫秒数。 123Calendar.getInstance().getTimeInMillis();System.currentTimeMillis();Clock.systemDefaultZone().millis(); // Java 8 问题 3：代码如下所示。 12Calendar time = Calendar.getInstance();time.getActualMaximum(Calendar.DAY_OF_MONTH); 问题 4：利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的 format(Date) 方法可将日期格式化。Java 8 中可以用 java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。 123456789101112131415161718import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.format.DateTimeFormatter;import java.util.Date;class DateFormatTest &#123; public static void main(String[] args) &#123; SimpleDateFormat oldFormatter = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); Date date1 = new Date(); System.out.println(oldFormatter.format(date1)); // Java 8 DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;); LocalDate date2 = LocalDate.now(); System.out.println(date2.format(newFormatter)); &#125;&#125; 补充：Java 的时间日期 API 一直以来都是被诟病的东西，为了解决这一问题，Java 8 中引入了新的时间日期 API，其中包括 LocalDate、LocalTime、LocalDateTime、Clock、Instant 等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。 42、打印昨天的当前时刻。 123456789import java.util.Calendar;class YesterdayCurrent &#123; public static void main(String[] args)&#123; Calendar cal = Calendar.getInstance(); cal.add(Calendar.DATE, -1); System.out.println(cal.getTime()); &#125;&#125; 在 Java 8 中，可以用下面的代码实现相同的功能。 1234567891011import java.time.LocalDateTime;class YesterdayCurrent &#123; public static void main(String[] args) &#123; LocalDateTime today = LocalDateTime.now(); LocalDateTime yesterday = today.minusDays(1); System.out.println(yesterday); &#125;&#125; 43、比较一下 Java 和 JavaSciprt。 答：JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。 下面对两种语言间的异同作如下比较： 基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率） 强类型变量和弱类型变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行时检查推断其数据类型。 代码格式不一样。补充：上面列出的四点是网上流传的所谓的标准答案。其实 Java 和 JavaScript 最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在 Java 中类（class）是一等公民，而 JavaScript 中函数（function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda 函数和闭包（closure），当然 Java 8 也开始支持函数式编程，提供了对 Lambda 表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。 44、什么时候用断言（assert）？ 答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表达式的值为 false，那么系统会报告一个 AssertionError。断言的使用如下面的代码所示： 1assert(a 0); // throws an AssertionError if a &lt;= 0 断言可以有两种形式： 1234assert Expression1;assert Expression1 : Expression2 ;Expression1 应该总是产生一个布尔值。Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。 要在运行时启用断言，可以在启动 JVM 时使用 - enableassertions 或者 - ea 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 - da 或者 - disableassertions 标记。要在系统类中启用或禁用断言，可使用 - esa 或 - dsa 标记。还可以在包的基础上启用或者禁用断言。 注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。 45、Error 和 Exception 有什么区别 #？ 答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 面试题：2005 年摩托罗拉的面试中曾经问过这么一个问题 “If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项 a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java 程序在运行时也可能会遭遇 StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是 c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示： 123456class StackOverflowErrorTest &#123; public static void main(String[] args) &#123; main(null); &#125;&#125; 提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。 46、try{} 里有一个 return 语句，那么紧跟在这个 try 后的 finally{} 里的代码会不会被执行，什么时候被执行，在 return 前还是后? 答：会执行，在方法返回前执行。 注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C# 中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse 中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。 47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？ 答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的 try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者最终将异常抛给 JVM。 48、运行时异常与受检异常有何异同？ 答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用给出了以下指导原则： 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常） 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 优先使用标准的异常 每个方法抛出的异常都要有文档 保持异常的原子性 不要在 catch 中忽略掉捕获到的异常 49、列出一些你常见的运行时异常？ 答： ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 50、阐述 final、finally、finalize 的区别。 答： final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方法也同样只能使用，不能在子类中被重写。 finally：通常放在 try…catch… 的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。 finalize：Object 类中定义的方法，Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。 51、类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。 有如下代码片断： 1234567try &#123; throw new ExampleB(&quot;b&quot;)&#125; catch（ExampleA e）&#123; System.out.println(&quot;ExampleA&quot;);&#125; catch（Exception e）&#123; System.out.println(&quot;Exception&quot;);&#125; 请问执行此段代码的输出是什么？ 答：输出：ExampleA。（根据里氏代换原则 [能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常） 面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书） 12345678910111213141516171819202122232425class Annoyance extends Exception &#123;&#125;class Sneeze extends Annoyance &#123;&#125;class Human &#123; public static void main(String[] args) throws Exception &#123; try &#123; try &#123; throw new Sneeze(); &#125; catch ( Annoyance a ) &#123; System.out.println(&quot;Caught Annoyance&quot;); throw a; &#125; &#125; catch ( Sneeze s ) &#123; System.out.println(&quot;Caught Sneeze&quot;); return ; &#125; finally &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;&#125; 52、List、Set、Map 是否继承自 Collection 接口？ 答：List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。 53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。 答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 补充：遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，Properties 是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个 Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中的 Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或 Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun 公司的工程师们也会犯这种低级错误，让人唏嘘不已。 54、Collection 和 Collections 的区别？ 答：Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 55、List、Map、Set 三个接口存取元素时，各有什么特点？ 答：List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals() 方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort() 方法如何比较元素？ 答：TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo() 方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象必须实现 Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。例子 1： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Student implements Comparable&lt;Student&#123; private String name; // 姓名 private int age; // 年龄 public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student []&quot;; &#125; @Override public int compareTo(Student o) &#123; return this.age - o.age; // 比较年龄(年龄的升序) &#125;&#125;import java.util.Set;import java.util.TreeSet;class Test01 &#123; public static void main(String[] args) &#123; Set&lt;Studentset = new TreeSet&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) set.add(new Student(&quot;Hao LUO&quot;, 33)); set.add(new Student(&quot;XJ WANG&quot;, 32)); set.add(new Student(&quot;Bruce LEE&quot;, 60)); set.add(new Student(&quot;Bob YANG&quot;, 22)); for(Student stu : set) &#123; System.out.println(stu); &#125;// 输出结果: // Student [name=Bob YANG, age=22]// Student [name=XJ WANG, age=32]// Student [name=Hao LUO, age=33]// Student [name=Bruce LEE, age=60] &#125;&#125; 例子 2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Student &#123; private String name; // 姓名 private int age; // 年龄 public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; /** * 获取学生姓名 */ public String getName() &#123; return name; &#125; /** * 获取学生年龄 */ public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Student []&quot;; &#125;&#125;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;class Test02 &#123; public static void main(String[] args) &#123; List&lt;Studentlist = new ArrayList&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) list.add(new Student(&quot;Hao LUO&quot;, 33)); list.add(new Student(&quot;XJ WANG&quot;, 32)); list.add(new Student(&quot;Bruce LEE&quot;, 60)); list.add(new Student(&quot;Bob YANG&quot;, 22)); // 通过sort方法的第二个参数传入一个Comparator接口对象 // 相当于是传入一个比较对象大小的算法到sort方法中 // 由于Java中没有函数指针、仿函数、委托这样的概念 // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调 Collections.sort(list, new Comparator&lt;Student() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getName().compareTo(o2.getName()); // 比较学生姓名 &#125; &#125;); for(Student stu : list) &#123; System.out.println(stu); &#125;// 输出结果: // Student [name=Bob YANG, age=22]// Student [name=Bruce LEE, age=60]// Student [name=Hao LUO, age=33]// Student [name=XJ WANG, age=32] &#125;&#125; 57、Thread 类的 sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别? 答：sleep() 方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第 66 题中的线程状态转换图）。wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。时下很时髦的 Node.js 就采用了单线程异步 I/O 的工作模式。 58、线程的 sleep() 方法和 yield() 方法有什么区别？ 答： ① sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（ready）状态； ③ sleep() 方法声明抛出 InterruptedException，而 yield() 方法没有声明任何异常； ④ sleep() 方法比 yield() 方法（跟操作系统 CPU 调度相关）具有更好的可移植性。 59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？ 答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。 60、请说出与线程同步以及线程调度相关的方法。 答： wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition() 方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire() 方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release() 方法）。 下面的例子演示了 100 个线程同时向一个银行账户中存入 1 元钱，在没有使用同步机制和使用同步机制情况下的执行情况。 银行账户类： 123456789101112131415161718192021222324252627282930/** * 银行账户 * @author nnngu * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 存钱线程类： 1234567891011121314151617181920/** * 存钱线程 * @author nnngu * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; account.deposit(money); &#125;&#125; 测试类： 1234567891011121314151617181920import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test01 &#123; public static void main(String[] args) &#123; Account account = new Account(); ExecutorService service = Executors.newFixedThreadPool(100); for(int i = 1; i &lt;= 100; i++) &#123; service.execute(new AddMoneyThread(account, 1)); &#125; service.shutdown(); while(!service.isTerminated()) &#123;&#125; System.out.println(&quot;账户余额: &quot; + account.getBalance()); &#125;&#125; 在没有同步的情况下，执行结果通常是显示账户余额在 10 元以下，出现这种状况的原因是，当一个线程 A 试图存入 1 元的时候，另外一个线程 B 也能够进入存款的方法中，线程 B 读取到的账户余额仍然是线程 A 存入 1 元钱之前的账户余额，因此也是在原来的余额 0 上面做了加 1 元的操作，同理线程 C 也会做类似的事情，所以最后 100 个线程执行结束时，本来期望账户余额为 100 元，但实际得到的通常在 10 元以下（很可能是 1 元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案： 在银行账户的存款（deposit）方法上加同步（synchronized）关键字 123456789101112131415161718192021222324252627282930/** * 银行账户 * @author nnngu * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public synchronized void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 在线程调用存款方法时对银行账户进行同步 12345678910111213141516171819202122/** * 存钱线程 * @author nnngu * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; synchronized (account) &#123; account.deposit(money); &#125; &#125;&#125; 通过 Java 5 显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 银行账户 * * @author nnngu * */public class Account &#123; private Lock accountLock = new ReentrantLock(); private double balance; // 账户余额 /** * 存款 * * @param money * 存入金额 */ public void deposit(double money) &#123; accountLock.lock(); try &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; finally &#123; accountLock.unlock(); &#125; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 按照上述三种方式对代码进行修改后，重写执行测试代码 Test01，将看到最终的账户余额为 100 元。当然也可以使用 Semaphore 或 CountdownLatch 来实现同步。 61、编写多线程程序有几种实现方式？ 答：Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一种是实现 Runnable 接口。两种方式都要通过重写 run() 方法来定义线程的行为，推荐使用后者，因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其他类了，显然使用 Runnable 接口更为灵活。 补充：Java 5 以后创建线程还有第三种方式：实现 Callable 接口，该接口中的 call 方法可以在线程执行结束时产生一个返回值，代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;class MyTask implements Callable&lt;Integer&#123; private int upperBounds; public MyTask(int upperBounds) &#123; this.upperBounds = upperBounds; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) &#123; sum += i; &#125; return sum; &#125;&#125;class Test &#123; public static void main(String[] args) throws Exception &#123; List&lt;Future&lt;Integer&gt;list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) &#123; list.add(service.submit(new MyTask((int) (Math.random() * 100)))); &#125; int sum = 0; for(Future&lt;Integerfuture : list) &#123; // while(!future.isDone()) ; sum += future.get(); &#125; System.out.println(sum); &#125;&#125; 62、synchronized 关键字的用法？ 答：synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用 synchronized(对象) { … } 定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。在第 60 题的例子中已经展示了 synchronized 关键字的用法。 63、举例说明同步和异步。 答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 64、启动一个线程是调用 run() 还是 start() 方法？ 答：启动一个线程是调用 start() 方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run() 方法是线程启动后要进行回调（callback）的方法。 65、什么是线程池（thread pool）？ 答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是” 池化资源” 技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 Java 5 + 中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 里面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。第 60 题的例子中演示了通过 Executors 工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用 newFixedThreadPool 方法来创建线程池，这样能获得更好的性能。 66、线程的基本状态以及状态之间的关系？ 答： 说明：其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait() 方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了 sleep() 方法或 join() 方法等待休眠或其他线程结束，或是因为发生了 I/O 中断。 67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？ 答：Lock 是 Java 5 以后引入的新的 API，和关键字 synchronized 相比主要相同点：Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。 68、Java 中如何实现序列化，有什么意义？ 答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object) 方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第 29 题）。 69、Java 中有几种类型的流？ 答：字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承于 Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于 Java 的 I/O 需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外 Java 中的流不同于 C# 的是它只有一个维度一个方向。 面试题 - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案） 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public final class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; public static void fileCopy(String source, String target) throws IOException &#123; try (InputStream in = new FileInputStream(source)) &#123; try (OutputStream out = new FileOutputStream(target)) &#123; byte[] buffer = new byte[4096]; int bytesToRead; while((bytesToRead = in.read(buffer)) != -1) &#123; out.write(buffer, 0, bytesToRead); &#125; &#125; &#125; &#125; public static void fileCopyNIO(String source, String target) throws IOException &#123; try (FileInputStream in = new FileInputStream(source)) &#123; try (FileOutputStream out = new FileOutputStream(target)) &#123; FileChannel inChannel = in.getChannel(); FileChannel outChannel = out.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(4096); while(inChannel.read(buffer) != -1) &#123; buffer.flip(); outChannel.write(buffer); buffer.clear(); &#125; &#125; &#125; &#125;&#125; 注意：上面用到 Java 7 的 TWR，使用 TWR 后可以不用在 finally 中释放外部资源 ，从而让代码更加优雅。 70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。 答：代码如下： 12345678910111213141516171819202122232425262728293031323334353637import java.io.BufferedReader;import java.io.FileReader;public final class MyUtil &#123; // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯) private MyUtil() &#123; throw new AssertionError(); &#125; /** * 统计给定文件中给定字符串的出现次数 * * @param filename 文件名 * @param word 字符串 * @return 字符串在文件中出现的次数 */ public static int countWordInFile(String filename, String word) &#123; int counter = 0; try (FileReader fr = new FileReader(filename)) &#123; try (BufferedReader br = new BufferedReader(fr)) &#123; String line = null; while ((line = br.readLine()) != null) &#123; int index = -1; while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) &#123; counter++; line = line.substring(index + word.length()); &#125; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return counter; &#125;&#125; 71、如何用 Java 代码列出一个目录下所有的文件？ 答： 如果只要求列出当前文件夹下的文件，代码如下所示： 12345678910111213import java.io.File;class Test12 &#123; public static void main(String[] args) &#123; File f = new File(&quot;/Users/nnngu/Downloads&quot;); for(File temp : f.listFiles()) &#123; if(temp.isFile()) &#123; System.out.println(temp.getName()); &#125; &#125; &#125;&#125; 如果需要对文件夹继续展开，代码如下所示： 1234567891011121314151617181920212223242526import java.io.File;class Test12 &#123; public static void main(String[] args) &#123; showDirectory(new File(&quot;/Users/nnngu/Downloads&quot;)); &#125; public static void showDirectory(File f) &#123; _walkDirectory(f, 0); &#125; private static void _walkDirectory(File f, int level) &#123; if(f.isDirectory()) &#123; for(File temp : f.listFiles()) &#123; _walkDirectory(temp, level + 1); &#125; &#125; else &#123; for(int i = 0; i &lt; level - 1; i++) &#123; System.out.print(&quot;\t&quot;); &#125; System.out.println(f.getName()); &#125; &#125;&#125; 在 Java 7 中可以使用 NIO.2 的 API 来做同样的事情，代码如下所示： 12345678910111213141516class ShowFileTest &#123; public static void main(String[] args) throws IOException &#123; Path initPath = Paths.get(&quot;/Users/nnngu/Downloads&quot;); Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println(file.getFileName().toString()); return FileVisitResult.CONTINUE; &#125; &#125;); &#125;&#125; 72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。 答： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class EchoServer &#123; private static final int ECHO_SERVER_PORT = 6789; public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) &#123; System.out.println(&quot;服务器已经启动...&quot;); while(true) &#123; Socket client = server.accept(); new Thread(new ClientHandler(client)).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private static class ClientHandler implements Runnable &#123; private Socket client; public ClientHandler(Socket client) &#123; this.client = client; &#125; @Override public void run() &#123; try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter pw = new PrintWriter(client.getOutputStream())) &#123; String msg = br.readLine(); System.out.println(&quot;收到&quot; + client.getInetAddress() + &quot;发送的: &quot; + msg); pw.println(msg); pw.flush(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意：上面的代码使用了 Java 7 的 TWR 语法，由于很多外部资源类都间接的实现了 AutoCloseable 接口（单方法回调接口），因此可以利用 TWR 语法在 try 结束的时候通过回调的方式自动调用外部资源类的 close() 方法，避免书写冗长的 finally 代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户 I/O 操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。 下面是一段回显客户端测试代码： 12345678910111213141516171819202122import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class EchoClient &#123; public static void main(String[] args) throws Exception &#123; Socket client = new Socket(&quot;localhost&quot;, 6789); Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入内容: &quot;); String msg = sc.nextLine(); sc.close(); PrintWriter pw = new PrintWriter(client.getOutputStream()); pw.println(msg); pw.flush(); BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println(br.readLine()); client.close(); &#125;&#125; 如果希望用 NIO 的多路复用套接字实现服务器，代码如下所示。NIO 的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;public class EchoServerNIO &#123; private static final int ECHO_SERVER_PORT = 6789; private static final int ECHO_SERVER_TIMEOUT = 5000; private static final int BUFFER_SIZE = 1024; private static ServerSocketChannel serverChannel = null; private static Selector selector = null; // 多路复用选择器 private static ByteBuffer buffer = null; // 缓冲区 public static void main(String[] args) &#123; init(); listen(); &#125; private static void init() &#123; try &#123; serverChannel = ServerSocketChannel.open(); buffer = ByteBuffer.allocate(BUFFER_SIZE); serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT)); serverChannel.configureBlocking(false); selector = Selector.open(); serverChannel.register(selector, SelectionKey.OP_ACCEPT); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private static void listen() &#123; while (true) &#123; try &#123; if (selector.select(ECHO_SERVER_TIMEOUT) != 0) &#123; Iterator&lt;SelectionKeyit = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); it.remove(); handleKey(key); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void handleKey(SelectionKey key) throws IOException &#123; SocketChannel channel = null; try &#123; if (key.isAcceptable()) &#123; ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel(); channel = serverChannel.accept(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; channel = (SocketChannel) key.channel(); buffer.clear(); if (channel.read(buffer) 0) &#123; buffer.flip(); CharBuffer charBuffer = CharsetHelper.decode(buffer); String msg = charBuffer.toString(); System.out.println(&quot;收到&quot; + channel.getRemoteAddress() + &quot;的消息：&quot; + msg); channel.write(CharsetHelper.encode(CharBuffer.wrap(msg))); &#125; else &#123; channel.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if (channel != null) &#123; channel.close(); &#125; &#125; &#125;&#125;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.charset.CharacterCodingException;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.charset.CharsetEncoder;public final class CharsetHelper &#123; private static final String UTF_8 = &quot;UTF-8&quot;; private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder(); private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder(); private CharsetHelper() &#123; &#125; public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException&#123; return encoder.encode(in); &#125; public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException&#123; return decoder.decode(in); &#125;&#125; 73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？ 答：XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束，其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。对 XML 的解析主要有 DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和 StAX（Java 6 中引入的新的解析 XML 的方式，Streaming API for XML），其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构占用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）；SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问；顾名思义，StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程序能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新颖（SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 74、你在项目中哪些地方用到了 XML？ 答：XML 的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML 将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从 XML 文件中还原相关信息进行处理，XML 曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被 JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用 XML 来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在 XML 文件中，Java 的很多框架也是这么做的，而且这些框架都选择了 dom4j 作为处理 XML 的工具，因为 Sun 公司的官方 API 实在不怎么好用。 补充：现在有很多时髦的软件（如 Sublime）已经开始将配置文件书写成 JSON 格式，我们已经强烈的感受到 XML 的另一项功能也将逐渐被业界抛弃。 75、阐述 JDBC 操作数据库的步骤。 答：下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。 123456789101112131415161718192021222324252627282930加载驱动。Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);创建连接。Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;, &quot;scott&quot;, &quot;tiger&quot;);创建语句。PreparedStatement ps = con.prepareStatement(&quot;select * from emp where sal between ? and ?&quot;);ps.setInt(1, 1000);ps.setInt(2, 3000);执行语句。ResultSet rs = ps.executeQuery();处理结果。while(rs.next()) &#123; System.out.println(rs.getInt(&quot;empno&quot;) + &quot; - &quot; + rs.getString(&quot;ename&quot;));&#125;关闭资源。 finally &#123; if(con != null) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。 76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？ 答：与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；③当批量处理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的 SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。 补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。 77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ 答：要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize() 方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。 78、在进行数据库编程时，连接池有什么作用？ 答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在 Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。 补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。 79、什么是 DAO 模式？ 答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 Data Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。 80、事务的 ACID 是指什么？ 答： 原子性 (Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； 一致性 (Consistent)：事务结束后系统状态是一致的； 隔离性 (Isolated)：并发执行的事务彼此无法看到对方的中间状态； 持久性 (Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类丢失更新）。 脏读（Dirty Read）：A 事务读取 B 事务尚未提交的数据并在此基础上操作，而 B 事务执行回滚，那么 A 读取到的数据就是脏数据。 不可重复读（Unrepeatable Read）：事务 A 重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务 B 修改过了。 幻读（Phantom Read）：事务 A 重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务 B 提交的行。 第 1 类丢失更新：事务 A 撤销时，把已经提交的事务 B 的更新数据覆盖了。 第 2 类丢失更新：事务 A 覆盖事务 B 已经提交的数据，造成事务 B 所做的操作丢失。 数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。 直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析 SQL 语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示： 隔离级别 脏读 不可重复读 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED 允许 允许 允许 不允许 允许 READCOMMITTED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZABLE 不允许 不允许 不允许 不允许 不允许 需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。 81、JDBC 中如何进行事务处理？ 答：Connection 提供了事务处理的方法，通过调用 setAutoCommit(false) 可以设置手动提交事务；当事务完成后用 commit() 显式提交事务；如果在事务处理过程中发生异常则通过 rollback() 进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。 82、JDBC 能否处理 Blob 和 Clob？ 答： Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Objec），因此其中 Blob 是为存储大的二进制数据而设计的，而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和 ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。下面的代码展示了如何使用 JDBC 操作 LOB： 下面以 MySQL 数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下： 123456create table tb_user(id int primary key auto_increment,name varchar(20) unique not null,photo longblob); 下面的 Java 代码向数据库中插入一条记录： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;class JdbcLobTest &#123; public static void main(String[] args) &#123; Connection con = null; try &#123; // 1\. 加载驱动（Java6以上版本可以省略） Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2\. 建立连接 con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;); // 3\. 创建语句对象 PreparedStatement ps = con.prepareStatement(&quot;insert into tb_user values (default, ?, ?)&quot;); ps.setString(1, &quot;郭靖&quot;); // 将SQL语句中第一个占位符换成字符串 try (InputStream in = new FileInputStream(&quot;test.jpg&quot;)) &#123; // Java 7的TWR ps.setBinaryStream(2, in); // 将SQL语句中第二个占位符换成二进制流 // 4\. 发出SQL语句获得受影响行数 System.out.println(ps.executeUpdate() == 1 ? &quot;插入成功&quot; : &quot;插入失败&quot;); &#125; catch(IOException e) &#123; System.out.println(&quot;读取照片失败!&quot;); &#125; &#125; catch (ClassNotFoundException | SQLException e) &#123; // Java 7的多异常捕获 e.printStackTrace(); &#125; finally &#123; // 释放外部资源的代码都应当放在finally中保证其能够得到执行 try &#123; if(con != null &amp;&amp; !con.isClosed()) &#123; con.close(); // 5\. 释放数据库连接 con = null; // 指示垃圾回收器可以回收该对象 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 83、简述正则表达式及其用途。 答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。 84、Java 中是如何支持正则表达式操作的？ 答：Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作，请参考下面面试题的代码。 面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市 (朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？ 1234567891011121314import java.util.regex.Matcher;import java.util.regex.Pattern;class RegExpTest &#123; public static void main(String[] args) &#123; String str = &quot;北京市(朝阳区)(西城区)(海淀区)&quot;; Pattern p = Pattern.compile(&quot;.*?(?=\\()&quot;); Matcher m = p.matcher(str); if(m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125; 说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式 30 分钟入门教程》。 85、获得一个类的类对象有哪些方式？ 答： 方法 1：类型. class，例如：String.class 方法 2：对象. getClass()，例如：”hello”.getClass() 方法 3：Class.forName()，例如：Class.forName(“java.lang.String”) 86、如何通过反射创建对象？ 答： 方法 1：通过类对象调用 newInstance() 方法，例如：String.class.newInstance() 方法 2：通过类对象的 getConstructor() 或 getDeclaredConstructor() 方法获得构造器（Constructor）对象并调用其 newInstance() 方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 87、如何通过反射获取和设置对象私有字段的值？ 答：可以通过类对象的 getDeclaredField() 方法获得字段（Field）对象，然后再通过字段对象的 setAccessible(true) 将其设置为可以访问，接下来就可以通过 get/set 方法来获取 / 设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如 ReflectionUtil.get(dog, “owner.car.engine.id”); 可以获得 dog 对象的主人的汽车的引擎的 ID 号。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.List;/** * 反射工具类 * @author nnngu * */public class ReflectionUtil &#123; private ReflectionUtil() &#123; throw new AssertionError(); &#125; /** * 通过反射取对象指定字段(属性)的值 * @param target 目标对象 * @param fieldName 字段的名字 * @throws 如果取不到对象指定字段的值则抛出异常 * @return 字段的值 */ public static Object getValue(Object target, String fieldName) &#123; Class&lt;?clazz = target.getClass(); String[] fs = fieldName.split(&quot;\\.&quot;); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); target = f.get(target); clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); return f.get(target); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 通过反射给对象的指定字段赋值 * @param target 目标对象 * @param fieldName 字段的名称 * @param value 值 */ public static void setValue(Object target, String fieldName, Object value) &#123; Class&lt;?clazz = target.getClass(); String[] fs = fieldName.split(&quot;\\.&quot;); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); Object val = f.get(target); if(val == null) &#123; Constructor&lt;?c = f.getType().getDeclaredConstructor(); c.setAccessible(true); val = c.newInstance(); f.set(target, val); &#125; target = val; clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); f.set(target, value); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 88、如何通过反射调用对象的方法？ 答：请看下面的代码： 12345678910import java.lang.reflect.Method;class MethodInvokeTest &#123; public static void main(String[] args) throws Exception &#123; String str = &quot;hello&quot;; Method m = str.getClass().getMethod(&quot;toUpperCase&quot;); System.out.println(m.invoke(str)); // HELLO &#125;&#125; 89、简述一下面向对象的 “六原则一法则”。 答： 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是 “高内聚”，写代码最终极的原则只有六个字 “高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字 “欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫 “因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而混乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。） 里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到 “低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。） 90、简述一下你了解的设计模式。 答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 在 GoF 的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型 [对类的实例化过程的抽象化]、结构型 [描述如何将类或对象结合在一起形成更大的结构]、行为型 [对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。 面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。 除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections 工具类和 I/O 系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 91、用 Java 写一个单例类。 答： 饿汉式单例 1234567public class Singleton &#123; private Singleton()&#123;&#125; private static Singleton instance = new Singleton(); public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉式单例 12345678public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123;&#125; public static synchronized Singleton getInstance()&#123; if (instance == null) instance ＝ new Singleton(); return instance; &#125;&#125; 注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring 的 IoC 容器可以为普通的类创建单例，它是怎么做到的呢？ 92、什么是 UML？ 答：UML 是统一建模语言（Unified Modeling Language）的缩写，它发表于 1997 年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用 UML 可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。 93、UML 中有哪些常用的图？ 答：UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。 用例图： 类图： 时序图： 94、用 Java 写一个冒泡排序。 答：冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Comparator;/** * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换) * @author nnngu * */public interface Sorter &#123; /** * 排序 * @param list 待排序的数组 */ public &lt;T extends Comparable&lt;T&gt;void sort(T[] list); /** * 排序 * @param list 待排序的数组 * @param comp 比较两个对象的比较器 */ public &lt;Tvoid sort(T[] list, Comparator&lt;Tcomp);&#125;import java.util.Comparator;/** * 冒泡排序 * * @author nnngu * */public class BubbleSorter implements Sorter &#123; @Override public &lt;T extends Comparable&lt;T&gt;void sort(T[] list) &#123; boolean swapped = true; for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123; swapped = false; for (int j = 0; j &lt; len - i; ++j) &#123; if (list[j].compareTo(list[j + 1]) 0) &#123; T temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; swapped = true; &#125; &#125; &#125; &#125; @Override public &lt;Tvoid sort(T[] list, Comparator&lt;Tcomp) &#123; boolean swapped = true; for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123; swapped = false; for (int j = 0; j &lt; len - i; ++j) &#123; if (comp.compare(list[j], list[j + 1]) 0) &#123; T temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; swapped = true; &#125; &#125; &#125; &#125;&#125; 95、用 Java 写一个折半查找。 答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是 O(logN)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Comparator;public class MyUtil &#123; public static &lt;T extends Comparable&lt;T&gt;int binarySearch(T[] x, T key) &#123; return binarySearch(x, 0, x.length- 1, key); &#125; // 使用循环实现的二分查找 public static &lt;Tint binarySearch(T[] x, T key, Comparator&lt;Tcomp) &#123; int low = 0; int high = x.length - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;1; int cmp = comp.compare(x[mid], key); if (cmp &lt; 0) &#123; low= mid + 1; &#125; else if (cmp 0) &#123; high= mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1; &#125; // 使用递归实现的二分查找 private static&lt;T extends Comparable&lt;T&gt;int binarySearch(T[] x, int low, int high, T key) &#123; if(low &lt;= high) &#123; int mid = low + ((high - low) &gt;1); if(key.compareTo(x[mid])== 0) &#123; return mid; &#125; else if(key.compareTo(x[mid])&lt; 0) &#123; return binarySearch(x,low, mid - 1, key); &#125; else &#123; return binarySearch(x,mid + 1, high, key); &#125; &#125; return -1; &#125;&#125; 说明：上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用 (high+ low) / 2 的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high - low) / 2 或 low + (high – low) &gt;1 或(low + high) &gt;&gt;1（&gt;&gt;&gt; 是逻辑右移，是不带符号位的右移） 转载自：https://www.imooc.com/u/6457959/articles 本文永久更新地址：github.com/nnngu/Learn… 感谢整理者：nnngu]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>待阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 知识点总结69题+25题]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-1%2F</url>
    <content type="text"><![CDATA[Spring 知识点总结69题1. 什么是 Spring？ Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。 2.Spring 有哪些优点？ 轻量级：Spring 在大小和透明性方面绝对属于轻量级的，基础版本的 Spring 框架大约只有 2MB。 控制反转 (IOC)：Spring 使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。 面向切面编程 (AOP)： Spring 支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。 容器：Spring 包含并管理应用程序对象的配置及生命周期。 MVC 框架：Spring 的 web 框架是一个设计优良的 web MVC 框架，很好的取代了一些 web 框架。 事务管理：Spring 对下至本地业务上至全局业务 (JAT) 提供了统一的事务管理接口。 异常处理：Spring 提供一个方便的 API 将特定技术的异常 (由 JDBC, Hibernate, 或 JDO 抛出) 转化为一致的、Unchecked 异常。 3.Spring 框架有哪些模块？ Spring 框架的基本模块如下所示： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaction module Web module Web-Servlet module Web-Struts module Web-Portlet module 4. 解释核心容器 (应用上下文) 模块 这是 Spring 的基本模块，它提供了 Spring 框架的基本功能。BeanFactory 是所有 Spring 应用的核心。Spring 框架是建立在这个模块之上的，这也使得 Spring 成为一个容器。 5.BeanFactory – BeanFactory 实例 BeanFactory 是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。 最常用的 BeanFactory 实现是 XmlBeanFactory 类。 6.XmlBeanFactory 最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory，它根据 XML 文件中定义的内容加载 beans。该容器从 XML 文件中读取配置元数据，并用它来创建一个完备的系统或应用。 7. 解释 AOP 模块 AOP 模块用来开发 Spring 应用程序中具有切面性质的部分。该模块的大部分服务由 AOP Aliance 提供，这就保证了 Spring 框架和其他 AOP 框架之间的互操作性。另外，该模块将元数据编程引入到了 Spring。 8. 解释抽象 JDBC 和 DAO 模块 通过使用抽象 JDBC 和 DAO 模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用 Spring 的 AOP 模块为 Spring 应用程序中的对象提供事务管理服务。 9. 解释对象 / 关系映射集成模块 Spring 通过提供 ORM 模块在 JDBC 的基础上支持对象关系映射工具。这样的支持使得 Spring 可以集成主流的 ORM 框架，包括 Hibernate, JDO, 及 iBATIS SQL Maps。Spring 的事务管理可以同时支持以上某种框架和 JDBC。 10. 解释 web 模块 Spring 的 web 模块建立在应用上下文 (application context) 模块之上，提供了一个适合基于 web 应用程序的上下文环境。该模块还支持了几个面向 web 的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。 11. 解释 Spring MVC 模块 Spring 提供 MVC 框架构建 web 应用程序。Spring 可以很轻松的同其他 MVC 框架结合，但 Spring 的 MVC 是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。 12.Spring 的配置文件 Spring 的配置文件是一个 XML 文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。 13.Spring IoC 容器是什么？ Spring IOC 负责创建对象、管理对象 (通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。 14.IOC 有什么优点？ IOC 或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或 JNDI 查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC 容器支持勤性单例及延迟加载服务。 15. 应用上下文是如何实现的？ FileSystemXmlApplicationContext 容器加载 XML 文件中 beans 的定义。XML Bean 配置文件的完整路径必须传递给构造器。 FileSystemXmlApplicationContext 容器也加载 XML 文件中 beans 的定义。注意，你需要正确的设置 CLASSPATH，因为该容器会在 CLASSPATH 中查看 bean 的 XML 配置文件。 WebXmlApplicationContext：该容器加载 xml 文件，这些文件定义了 web 应用中所有的 beans。 16.Bean Factory 和 ApplicationContext 有什么区别？ ApplicationContext 提供了一种解决文档信息的方法，一种加载文件资源的方式 (如图片)，他们可以向监听他们的 beans 发送消息。另外，容器或者容器中 beans 的操作，这些必须以 bean 工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了 MessageSource，该接口用于获取本地消息，实际的实现是可选的。 17.Spring 应用程序看起来像什么？ 一个定义功能的接口 实现包括属性，setter 和 getter 方法，功能等 Spring AOP Spring 的 XML 配置文件 使用该功能的客户端编程 依赖注入 18.Spring 中的依赖注入是什么？ 依赖注入作为控制反转 (IOC) 的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后 IOC 容器负责衔接。 19. 有哪些不同类型的 IOC(依赖注入)？ 构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。 Setter 方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用 bean 中的 setter 方法完成 Setter 方法依赖注入。 20. 你推荐哪种依赖注入？构造器依赖注入还是 Setter 方法依赖注入？ 你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用 setter 方法实现可选的依赖关系。 Spring Beans 21. 什么是 Spring Beans？ Spring Beans 是构成 Spring 应用核心的 Java 对象。这些对象由 Spring IOC 容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用 XML 文件中定义的 创建。 在 Spring 中创建的 beans 都是单例的 beans。在 bean 标签中有一个属性为”singleton”, 如果设为 true，该 bean 是单例的，如果设为 false，该 bean 是原型 bean。Singleton 属性默认设置为 true。因此，spring 框架中所有的 bean 都默认为单例 bean。 22.Spring Bean 中定义了什么内容？ Spring Bean 中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。 23. 如何向 Spring 容器提供配置元数据？ 有三种方式向 Spring 容器提供元数据: XML 配置文件 基于注解配置 基于 Java 的配置 24. 你如何定义 bean 的作用域？ 在 Spring 中创建一个 bean 的时候，我们可以声明它的作用域。只需要在 bean 定义的时候通过’scope’属性定义即可。例如，当 Spring 需要产生每次一个新的 bean 实例时，应该声明 bean 的 scope 属性为 prototype。如果每次你希望 Spring 返回一个实例，应该声明 bean 的 scope 属性为 singleton。 25. 说一下 Spring 中支持的 bean 作用域 Spring 框架支持如下五种不同的作用域： singleton：在 Spring IOC 容器中仅存在一个 Bean 实例，Bean 以单实例的方式存在。 prototype：一个 bean 可以定义多个实例。 request：每次 HTTP 请求都会创建一个新的 Bean。该作用域仅适用于 WebApplicationContext 环境。 session：一个 HTTP Session 定义一个 Bean。该作用域仅适用于 WebApplicationContext 环境. globalSession：同一个全局 HTTP Session 定义一个 Bean。该作用域同样仅适用于 WebApplicationContext 环境. bean 默认的 scope 属性是’singleton‘。 26.Spring 框架中单例 beans 是线程安全的吗？ 不是，Spring 框架中的单例 beans 不是线程安全的。 27. 解释 Spring 框架中 bean 的生命周期 Spring 容器读取 XML 文件中 bean 的定义并实例化 bean。 Spring 根据 bean 的定义设置属性值。 如果该 Bean 实现了 BeanNameAware 接口，Spring 将 bean 的 id 传递给 setBeanName() 方法。 如果该 Bean 实现了 BeanFactoryAware 接口，Spring 将 beanfactory 传递给 setBeanFactory() 方法。 如果任何 bean BeanPostProcessors 和该 bean 相关，Spring 调用 postProcessBeforeInitialization() 方法。 如果该 Bean 实现了 InitializingBean 接口，调用 Bean 中的 afterPropertiesSet 方法。如果 bean 有初始化函数声明，调用相应的初始化方法。 如果任何 bean BeanPostProcessors 和该 bean 相关，调用 postProcessAfterInitialization() 方法。 如果该 bean 实现了 DisposableBean，调用 destroy() 方法。 28. 哪些是最重要的 bean 生命周期方法？能重写它们吗？ 有两个重要的 bean 生命周期方法。第一个是 setup 方法，该方法在容器加载 bean 的时候被调用。第二个是 teardown 方法，该方法在 bean 从容器中移除的时候调用。 bean 标签有两个重要的属性 (init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring 也有相应的注解：@PostConstruct 和 @PreDestroy。 29. 什么是 Spring 的内部 bean？ 当一个 bean 被用作另一个 bean 的属性时，这个 bean 可以被声明为内部 bean。在基于 XML 的配置元数据中，可以通过把 元素定义在 或 &lt; constrtucor-arg &gt; 元素内部实现定义内部 bean。内部 bean 总是匿名的并且它们的 scope 总是 prototype。 30. 如何在 Spring 中注入 Java 集合类？ Spring 提供如下几种类型的集合配置元素： list 元素用来注入一系列的值，允许有相同的值。 set 元素用来注入一些列的值，不允许有相同的值。 map 用来注入一组” 键 - 值” 对，键、值可以是任何类型的。 props 也可以用来注入一组” 键 - 值” 对，这里的键、值都字符串类型。 31. 什么是 bean wiring？ Wiring，或者说 bean Wiring 是指 beans 在 Spring 容器中结合在一起的情况。当装配 bean 的时候，Spring 容器需要知道需要哪些 beans 以及如何使用依赖注入将它们结合起来。 32. 什么是 bean 自动装配？ Spring 容器可以自动配置相互协作 beans 之间的关联关系。这意味着 Spring 可以自动配置一个 bean 和其他协作 bean 之间的关系，通过检查 BeanFactory 的内容里没有使用 和 &lt; property &gt; 元素。 33. 解释自动装配的各种模式？ 自动装配提供五种不同的模式供 Spring 容器用来自动装配 beans 之间的依赖注入: no：默认的方式是不进行自动装配，通过手工设置 ref 属性来进行装配 bean。 byName：通过参数名自动装配，Spring 容器查找 beans 的属性，这些 beans 在 XML 配置文件中被设置为 byName。之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。 byType：通过参数的数据类型自动自动装配，Spring 容器查找 beans 的属性，这些 beans 在 XML 配置文件中被设置为 byType。之后容器试图匹配和装配和该 bean 的属性类型一样的 bean。如果有多个 bean 符合条件，则抛出错误。 constructor：这个同 byType 类似，不过是应用于构造函数的参数。如果在 BeanFactory 中不是恰好有一个 bean 与构造函数参数相同类型，则抛出一个严重的错误。 autodetect：如果有默认的构造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。 34. 自动装配有哪些局限性？ 自动装配有如下局限性： 重写：你仍然需要使用 和 &lt; property &gt; 设置指明依赖，这意味着总要重写自动装配。 原生数据类型: 你不能自动装配简单的属性，如原生类型、字符串和类。 模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。 35. 你可以在 Spring 中注入 null 或空字符串吗？ 完全可以。 Spring 注解 36. 什么是 Spring 基于 Java 的配置？给出一些注解的例子 基于 Java 的配置允许你使用 Java 的注解进行 Spring 的大部分配置而非通过传统的 XML 文件配置。 以注解 @Configuration 为例，它用来标记类，说明作为 beans 的定义，可以被 Spring IOC 容器使用。另一个例子是 @Bean 注解，它表示该方法定义的 Bean 要被注册进 Spring 应用上下文中。 37. 什么是基于注解的容器配置? 另外一种替代 XML 配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用 XML 描述 bean 之间的连线关系。 38. 如何开启注解装配？ 注解装配默认情况下在 Spring 容器中是不开启的。如果想要开启基于注解的装配只需在 Spring 配置文件中配置 context:annotation-config 元素即可。&lt;/context:annotation-config&gt; 39.@Required 注解 @Required 表明 bean 的属性必须在配置时设置，可以在 bean 的定义中明确指定也可通过自动装配设置。如果 bean 的属性未设置，则抛出 BeanInitializationException 异常。 40.@Autowired 注解 @Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像 @Required 一样自动装配 setter 方法、构造器、属性或者具有任意名称和 / 或多个参数的 PN 方法。 41. @Qualifier 注解 当有多个相同类型的 bean 而只有其中的一个需要自动装配时，将 @Qualifier 注解和 @Autowire 注解结合使用消除这种混淆，指明需要装配的 bean。 Spring 数据访问 42. 在 Spring 框架中如何更有效的使用 JDBC？ 使用 Spring JDBC 框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过 statements 和 queries 语句从数据库中存取数据。Spring 框架中通过使用模板类能更有效的使用 JDBC，也就是所谓的 JdbcTemplate(例子)。 43.JdbcTemplate JdbcTemplate 类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。 44.Spring 对 DAO 的支持 Spring 对数据访问对象 (DAO) 的支持旨在使它可以与数据访问技术 (如 JDBC, Hibernate 及 JDO) 方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。 45. 使用 Spring 可以通过什么方式访问 Hibernate？ 使用 Spring 有两种方式访问 Hibernate： 使用 Hibernate Template 的反转控制以及回调方法 继承 HibernateDAOSupport，并申请一个 AOP 拦截器节点 46.Spring 支持的 ORM Spring 支持一下 ORM： Hibernate iBatis JPA (Java -Persistence API) TopLink JDO (Java Data Objects) OJB 47. 如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？ 使用 Spring 的 SessionFactory 调用 LocalSessionFactory。结合过程分为以下三步： 配置 Hibernate SessionFactory 继承 HibernateDaoSupport 实现一个 DAO 使用 AOP 装载事务支持 48.Spring 支持的事务管理类型 Spring 支持如下两种方式的事务管理： 编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。 声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者 XML 配置管理事务。 49.Spring 框架的事务管理有哪些优点？ 它为不同的事务 API(如 JTA, JDBC, Hibernate, JPA, 和 JDO) 提供了统一的编程模型。 它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API(如 JTA). 它支持声明式事务管理。 它可以和 Spring 的多种数据访问技术很好的融合。 50. 你更推荐那种类型的事务管理？ 许多 Spring 框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理 (这种方式允许你通过代码控制业务)。 Spring 面向切面编程 (AOP) 51. 解释 AOP 面向切面编程, 或 AOP 允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。 52. 切面 (Aspect) AOP 的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组 API 提供 cross-cutting 功能。例如, 日志模块称为日志的 AOP 切面。根据需求的不同，一个应用程序可以有若干切面。在 Spring AOP 中，切面通过带有 @Aspect 注解的类实现。 53. 在 Spring AOP 中 concern 和 cross-cutting concern 的区别是什么？ Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern 可以定义为我们想要实现的功能。 Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于 Cross-cutting concern。 54. 连接点 (Join point) 连接点代表应用程序中插入 AOP 切面的地点。它实际上是 Spring AOP 框架在应用程序中执行动作的地点。 55. 通知 (Advice) 通知表示在方法执行前后需要执行的动作。实际上它是 Spring AOP 框架在程序执行过程中触发的一些代码。 Spring 切面可以执行一下五种类型的通知: before(前置通知)：在一个方法之前执行的通知。 after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 after-returning(后置通知)：在某连接点正常完成后执行的通知。 after-throwing(异常通知)：在方法抛出异常退出时执行的通知。 around(环绕通知)：在方法调用前后触发的通知。 56. 切入点 (Pointcut) 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。 57. 什么是引入？ 引入允许我们在已有的类上添加新的方法或属性。 58. 什么是目标对象？ 被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。 59. 什么是代理？ 代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 60. 有几种不同类型的自动代理？ BeanNameAutoProxyCreator：bean 名称自动代理创建器 DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器 Metadata autoproxying：元数据自动代理 61. 什么是织入？什么是织入应用的不同点？ 织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。 62. 解释基于 XML Schema 方式的切面实现 在这种情况下，切面由使用 XML 文件配置的类实现。 63. 解释基于注解方式 (基于 @AspectJ) 的切面实现 在这种情况下 (基于 @AspectJ 的实现)，指的是切面的对应的类使用 Java 5 注解的声明方式。 Spring 的 MVC 框架 64. 什么是 Spring 的 MVC 框架？ Spring 提供了一个功能齐全的 MVC 框架用于构建 Web 应用程序。Spring 框架可以很容易的和其他的 MVC 框架融合 (如 Struts)，该框架使用控制反转(IOC) 将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。 65.DispatcherServlet Spring 的 MVC 框架围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。 66.WebApplicationContext WebApplicationContext 继承了 ApplicationContext，并添加了一些 web 应用程序需要的功能。和普通的 ApplicationContext 不同，WebApplicationContext 可以用来处理主题样式，它也知道如何找到相应的 servlet。 67. 什么是 Spring MVC 框架的控制器？ 控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。 68.@Controller annotation @Controller 注解表示该类扮演控制器的角色。Spring 不需要继承任何控制器基类或应用 Servlet API。 69.@RequestMapping annotation @RequestMapping 注解用于将 URL 映射到任何一个类或者一个特定的处理方法上。 原文链接： javacodegeeks 翻译： ImportNew.com - 人晓译文链接： http://www.importnew.com/11657.html spring面试总结25题1、什么是 spring 框架？Spring 框架有哪些主要模块？ Spring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。Spring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。 Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成,、Web、 AOP（面向切面编程）、工具、消息和测试模块。 2、使用 Spring 框架能带来哪些好处？下面列举了一些使用 Spring 框架带来的主要好处： Dependency Injection(DI) 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。 与 EJB 容器相比较，IoC 容器更加趋向于轻量级。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下进行应用程序的开发和发布就变得十分有利。 Spring 并没有闭门造车, Spring 利用了已有的技术如 ORM 框架 logging 框架、J2EE、Quartz 和 JDK Timer, 以及其他视图技术. Spring 框架是按照模块的形式来组织的. 由包和类的编号就可以看出其所属的模块, 开发者仅仅需要选用他们需要的模块即可。 要测试一项用 Spring 开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。 Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 web 框架的选择上提供了一个除了主流框架 比如 Struts、过度设计的、不流行 web 框架的以外的有力选项。 Spring 提供了一个便捷的事务管理接口，适用于小型的本地事物处理 (比如在单 DB 的环境下) 和复杂的共同事物处理 (比如利用 JTA 的复杂 DB 环境)。 3、什么是控制反转 (IOC)? 什么是依赖注入?控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常 是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的 情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联 关系的定义抽象化。而绑定的过程是通过 “依赖注入” 实现的。 控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。 这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的 情况下，框架又怎么知道要创建哪个组件？ 在 Java 中依然注入有以下三种实现方式： 构造器注入 Setter 方法注入 接口注入 4、请解释下 Spring 框架中的 IoC?Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了 Spring 框架 IoC 容器的基础。 BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对 BeanFactory(是一个子接口) 进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成， 也提供了处理 message resource 的机制 (用于国际化)、事件传播以及应用层的特别配置， 比如针对 Web 应用的 WebApplicationContext。 org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。 BeanFactory 接口是 Spring IoC 容器的核心接口。 5、BeanFactory 和 ApplicationContext 有什么区别?BeanFactory 可以理解为含有 bean 集合的工厂类. BeanFactory 包含了种 bean 的定义, 以便在接收到客户端请求时将对应的 bean 实例化. BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。 BeanFactory 还包含了 bean 生命周期的控制, 调用客户端的初始化方法 (initialization methods) 和销毁方法(destruction methods)。 从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。 但 application context 在此基础上还提供了其他的功能。 1、提供了支持国际化的文本消息 2、统一的资源文件读取方式 3、已在监听器中注册的 bean 的事件 以下是三种较常见的 ApplicationContext 实现方式： 1、ClassPathXmlApplicationContext: 从 classpath 的 XML 配置文件中读取上下文, 并生成上下文定义. 应用程序上下文从程序环境变量中取得. 1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); 2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。 1ApplicationContext context = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;); 3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。 6、Spring 有几种配置方式?将 Spring 配置到应用开发中有以下三种方式： 1、基于 XML 的配置 2、基于注解的配置 3、基于 Java 的配置 7、如何用基于 XML 配置的方式配置 Spring?在 Spring 框架中，依赖和服务需要在专门的配置文件来实现，我常用的 XML 格式的配置文件。 这些配置文件的格式通常用开头，然后一系列的 bean 定义和专门的应用配置选项组成。 SpringXML 配置的主要目的时候是使所有的 Spring 组件都可以用 xml 文件的形式来进行配置。 这意味着不会出现其他的 Spring 配置类型 (比如声明的方式或基于 Java Class 的配置方式) Spring 的 XML 配置方式是使用被 Spring 命名空间的所支持的一系列的 XML 标签来实现的。 Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。 1234567&lt;beans&gt; &lt;!-- JSON Support --&gt; &lt;bean /&gt; &lt;bean /&gt; &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;&lt;/beans&gt; 下面这个 web.xml 仅仅配置了 DispatcherServlet, 这件最简单的配置便能满足应用程序配置运行时组件的需求。 123456789101112131415&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 8、如何用基于 Java 配置的方式配置 Spring?Spring 对 Java 配置的支持是由 @Configuration 注解和 @Bean 注解来实现的。由 @Bean 注解的方法将会实例化、 配置和初始化一个新对象，这个对象将由 Spring 的 IoC 容器来管理。@Bean 声明所起到的作用与 元素类似。 被 @Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被 @Configuration 声明的类可以 通过在同一个类的内部调用 @bean 方法来设置嵌入 bean 的依赖关系。 最简单的 @Configuration 声明类请参考下面的代码： 1234567@Configurationpublic class AppConfig&#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 对于上面的 @Beans 配置文件相同的 XML 配置文件如下： 123&lt;beans&gt; &lt;bean id=&quot;myService&quot; class=&quot;com.howtodoinjava.services.MyServiceImpl&quot;/&gt;&lt;/beans&gt; 上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化 12345public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff();&#125; 要使用组件组建扫描，仅需用 @Configuration 进行注解即可: 12345@Configuration@ComponentScan(basePackages = &quot;com.howtodoinjava&quot;)public class AppConfig &#123; ...&#125; 在上面的例子中，com.acme 包首先会被扫到，然后再容器内查找被 @Component 声明的类， 找到后将这些类按照 Sring bean 定义进行注册。 如果你要在你的 web 应用开发中选用上述的配置的方式的话, 需要用 AnnotationConfigWebApplicationContext 类来读取配置文件， 可以用来配置 Spring 的 Servlet 监听器 ContrextLoaderListener 或者 Spring MVC 的 DispatcherServlet。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;web-app&gt; &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext instead of the default XmlWebApplicationContext --&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Configuration locations must consist of one or more comma- or space-delimited fully-qualified @Configuration classes. Fully-qualified packages may also be specified for component-scanning --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.howtodoinjava.AppConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext instead of the default XmlWebApplicationContext --&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- Again, config locations must consist of one or more comma- or space-delimited and fully-qualified @Configuration classes --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.howtodoinjava.web.MvcConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 9、怎样用注解的方式配置 Spring？Spring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML 方式的 bean 描述， 可以将 bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。 注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。 注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。 如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 123456&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- bean definitions go here --&gt;&lt;/beans&gt; 在 context:annotation-config/ 标签配置完成以后, 就可以用注解的方式在 Spring 中向属性、方法和构造方法中自动装配变量。 下面是几种比较重要的注解类型： 1、@Required：该注解应用于设值方法。 2、@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 3、@Qualifier：该注解和 @Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。 4、JSR-250 Annotations：Spring 支持基于 JSR-250 注解的以下注解,@Resource、@PostConstruct 和 @PreDestroy。 10、请解释 Spring Bean 的生命周期?Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。 同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。 Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调 (call back) 方法组成。 1、初始化之后调用的回调方法。 2、销毁之前调用的回调方法。 Spring 框架提供了以下四种方式来管理 bean 的生命周期事件： InitializingBean 和 DisposableBean 回调接口 针对特殊行为的其他 Aware 接口 Bean 配置文件中的 Custom init() 方法和 destroy() 方法 @PostConstruct 和 @PreDestroy 注解方式 使用 customInit() 和 customDestroy() 方法管理 bean 生命周期的代码样例如下： 1234&lt;beans&gt; &lt;bean id=&quot;demoBean&quot; class=&quot;com.howtodoinjava.task.DemoBean&quot; init-method=&quot;customInit&quot; destroy-method=&quot;customDestroy&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 11、Spring Bean 的作用域之间有什么区别？Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的, 但是为了避免混淆, 还是让我们来解释一下： 1、singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例， 单例的模式由 bean factory 自身来维护。 2、prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。 3、request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例, 在请求完成以后, bean 会失效并被垃圾回收器回收. 4、Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。 5、global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。 如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。 全局作用域与 Servlet 中的 session 作用域效果相同。 12、什么是 Spring inner beans?在 Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean 声明为内部 bean。 内部 bean 可以用 setter 注入 “属性” 和构造方法注入 “构造参数” 的方式来实现。 比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个 Person 的实例， 然后在 Customer 内部使用。 123456789101112131415public class Customer&#123; private Person person; //Setters and Getters&#125;public class Person&#123; private String name; private String address; private int age; //Setters and Getters&#125; 内部 bean 的声明方式如下： 12345678910&lt;bean id=&quot;CustomerBean&quot; class=&quot;com.howtodoinjava.common.Customer&quot;&gt; &lt;property &gt; &lt;!-- This is inner bean --&gt; &lt;bean class=&quot;com.howtodoinjava.common.Person&quot;&gt; &lt;property /&gt; &lt;property /&gt; &lt;property /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 13、Spring 框架中的单例 Beans 是线程安全的么?Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。 但实际上，大部分的 Spring bean 并没有可变的状态 (比如 Serview 类和 DAO 类), 所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状态的话 (比如 View Model 对象)，就需要自行保证线程安全。 最浅显的解决办法就是将多态 bean 的作用域由 “singleton” 变更为 “prototype”。 14、请举例说明如何在 Spring 中注入一个 Java Collection?Spring 提供了以下四种集合类的配置元素： &lt;list&gt;:该标签用来装配可重复的 list 值。 &lt;set&gt;:该标签用来装配没有重复的 set 值。 &lt;map&gt;:该标签可用来注入键和值可以为任何类型的键值对。 &lt;props&gt;:该标签支持注入键和值都是字符串类型的键值对。 下面看一下具体的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;beans&gt; &lt;!-- Definition for javaCollection --&gt; &lt;bean id=&quot;javaCollection&quot; class=&quot;com.howtodoinjava.JavaCollection&quot;&gt; &lt;!-- java.util.List --&gt; &lt;property &gt; &lt;list&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- java.util.Set --&gt; &lt;property &gt; &lt;set&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- java.util.Map --&gt; &lt;property &gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt; &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt; &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt; &lt;entry key=&quot;4&quot; value=&quot;UK&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- java.util.Properties --&gt; &lt;property &gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 15、如何向 Spring Bean 中注入一个 Java.util.Properties?第一种方法是使用如下面代码所示的&lt;props&gt; 标签： 1234567891011&lt;bean id=&quot;adminUser&quot; class=&quot;com.howtodoinjava.common.Customer&quot;&gt; &lt;!-- java.util.Properties --&gt; &lt;property &gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 也可用 “util:” 命名空间来从 properties 文件中创建出一个 propertiesbean，然后利用 setter 方法注入 bean 的引用。 16、请解释 Spring Bean 的自动装配?在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的 关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。 自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。 下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配： 1&lt;bean id=&quot;employeeDAO&quot; class=&quot;com.howtodoinjava.EmployeeDAOImpl&quot; autowire=&quot;byName&quot; /&gt; 除了 bean 配置文件中提供的自动装配模式，还可以使用 @Autowired 注解来自动装配指定的 bean。 在使用 @Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。 1&lt;context:annotation-config /&gt; 也可以通过在配置文件中配置 AutowiredAnnotationBeanPostProcessor 达到相同的效果。 1&lt;bean class =&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt; 配置好以后就可以使用 @Autowired 来标注了。 1234@Autowiredpublic EmployeeDAOImpl ( EmployeeManager manager ) &#123; this.manager = manager;&#125; 17、请解释自动装配模式的区别?在 Spring 框架中共有 5 种自动装配，让我们逐一分析。 1、no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean 定义中用标签明确的设置依赖关系。 2、byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时， 容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 3、byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时， 容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 4、constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的 bean， 如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。 5、autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器， 如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byType 的自动装配方式。 18、如何开启基于注解的自动装配？要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现： 1、引入配置文件中的下引入 context:annotation-config 123&lt;beans&gt; &lt;context:annotation-config /&gt;&lt;/beans&gt; 2、在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor 123&lt;beans&gt; &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;&lt;/beans&gt; 19、请举例解释 @Required 注解?在产品级别的应用中，IoC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一 就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置 “dependency-check” 来解决这个问题。 在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正确配置。或者你宁可验证某个 bean 的特定属性是否被正确的设置。即使是用 “dependency-check” 属性也不能很好的解决这个问题, 在这种情况下, 你需要使用 @Required 注解。 需要用如下的方式使用来标明 bean 的设值方法。 123456789101112131415public class EmployeeFactoryBean extends AbstractFactoryBean&lt;Object&gt;&#123; private String designation; public String getDesignation() &#123; return designation; &#125; @Required public void setDesignation(String designation) &#123; this.designation = designation; &#125; //more code here&#125; RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被 @Required 注解的 bean 属性是否被正确的设置了。 在使用 RequiredAnnotationBeanPostProcesso 来验证 bean 属性之前，首先要在 IoC 容器中对其进行注册： 1&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot; /&gt; 但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个 BeanInitializationException 异常。 20、请举例解释 @Autowired 注解?@Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像 @Required 注解、 构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。 比如，可以在设值方法上使用 @Autowired 注解来替代配置文件中的 元素。 当 Spring 容器在 setter 方法上找到 @Autowired 注解时，会尝试用 byType 自动装配。 当然我们也可以在构造方法上使用 @Autowired 注解。带有 @Autowired 注解的构造方法意味着 在创建一个 bean 时将会被自动装配，即便在配置文件中使用 元素。 12345678910111213public class TextEditor &#123; private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker)&#123; System.out.println(&quot;Inside TextEditor constructor.&quot; ); this.spellChecker = spellChecker; &#125; public void spellCheck()&#123; spellChecker.checkSpelling(); &#125;&#125; 下面是没有构造参数的配置方式： 12345678910111213&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- Definition for textEditor bean without constructor-arg --&gt; &lt;bean id=&quot;textEditor&quot; class=&quot;com.howtodoinjava.TextEditor&quot;&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=&quot;spellChecker&quot; class=&quot;com.howtodoinjava.SpellChecker&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 21、请举例说明 @Qualifier 注解?@Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。 下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。 12345public class Customer&#123; @Autowired private Person person;&#125; 下面我们要在配置文件中来配置 Person 类。 123456789&lt;bean id=&quot;customer&quot; class=&quot;com.howtodoinjava.common.Customer&quot; /&gt;&lt;bean id=&quot;personA&quot; class=&quot;com.howtodoinjava.common.Person&quot; &gt; &lt;property /&gt;&lt;/bean&gt;&lt;bean id=&quot;personB&quot; class=&quot;com.howtodoinjava.common.Person&quot; &gt; &lt;property /&gt;&lt;/bean&gt; Spring 会知道要自动装配哪个 person bean 么? 不会的，但是运行上面的示例时，会抛出下面的异常： 123Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.howtodoinjava.common.Person] is defined: expected single matching bean but found 2: [personA, personB] 要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean： 123456public class Customer&#123; @Autowired @Qualifier(&quot;personA&quot;) private Person person;&#125; 22、构造方法注入和设值注入有什么区别?请注意以下明显的区别： 1、在设值注入方法支持大部分的依赖注入，如果我们仅需要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。 对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入， 因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 2、设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话， 那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。 3、在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。 而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 4、在设值注入时如果对象 A 和对象 B 互相依赖，在创建对象 A 时 Spring 会抛出 sObjectCurrentlyInCreationException 异常， 因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题， 因对象的设值方法是在对象被创建之前被调用的。 23、Spring 框架中有哪些不同类型的事件?Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。 我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件, 如果一个 bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。 12345678public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt;&#123; @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; //process event &#125;&#125; Spring 提供了以下 5 中标准的事件： 1、上下文更新事件 (ContextRefreshedEvent)：该事件会在 ApplicationContext 被初始化或者更新时发布。 也可以在调用 ConfigurableApplicationContext 接口中的 refresh() 方法时被触发。 2、上下文开始事件 (ContextStartedEvent)：当容器调用 ConfigurableApplicationContext 的 Start() 方法开始 / 重新开始容器时触发该事件。 3、上下文停止事件 (ContextStoppedEvent)：当容器调用 ConfigurableApplicationContext 的 Stop() 方法停止容器时触发该事件。 4、上下文关闭事件 (ContextClosedEvent)：当 ApplicationContext 被关闭时触发该事件。 容器被关闭时，其管理的所有单例 Bean 都被销毁。 5、请求处理事件 (RequestHandledEvent)：在 Web 应用中，当一个 http 请求（request）结束触发该事件。 除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。 12345678public class CustomApplicationEvent extends ApplicationEvent&#123; public CustomApplicationEvent ( Object source, final String msg ) &#123; super(source); System.out.println(&quot;Created a Custom event&quot;); &#125;&#125; 为了监听这个事件，还需要创建一个监听器： 1234567public class CustomEventListener implements ApplicationListener &lt; CustomApplicationEvent &gt;&#123; @Override public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123; //handle event &#125;&#125; 之后通过 applicationContext 接口的 publishEvent() 方法来发布自定义事件。 12CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext, &quot;Test message&quot;);applicationContext.publishEvent(customEvent); 24、FileSystemResource 和 ClassPathResource 有何区别?在 FileSystemResource 中需要给出 spring-config.xml 文件在你项目中的相对路径或者绝对路径。 在 ClassPathResource 中 spring 会在 ClassPath 中自动搜寻配置文件，所以要把 ClassPathResource 文件放在 ClassPath 下。 如果将 spring-config.xml 保存在了 src 文件夹下的话，只需给出配置文件的名称即可，因为 src 文件夹是默认。 简而言之，ClassPathResource 在环境变量中读取配置文件，FileSystemResource 在配置文件中读取配置文件。 25、Spring 框架中都用到了哪些设计模式？Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的： 1、代理模式—在 AOP 和 remoting 中被用的比较多。 2、单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。 3、模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 4、前端控制器—Spring 提供了 DispatcherServlet 来对请求进行分发。 5、视图帮助 (View Helper)—Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。 6、依赖注入—贯穿于 BeanFactory / ApplicationContext 接口的核心理念。 7、工厂模式—BeanFactory 用来创建对象的实例。 原文:http://blog.csdn.net/a724888/article/details/68925151]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记五]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17%2F</url>
    <content type="text"><![CDATA[第5章 构建Spring Web应用本章内容： 映射请求到Spring控制器 透明的绑定表单数据 校验表单提交 系统面临的挑战：状态管理、工作流、以及验证都是需要解决的重要特性。HTTP协议的无状态决定了这些问题都不是那么容易解决。 Spring的Web框架就是为了帮你解决这些关注点而设计的。Spring MVC基于模型-视图-控制器(Model-View-Controller MVC)模式实现的，他能够帮你构建向Spring框架那样灵活和松耦合的Web应用程序。 在本章中，将会介绍Spring MVC Web框架，并使用新的Spring MVC注解来构建处理各种Web请求、参数、和表单输入的控制器。 5.1 Spring MVC起步Spring将请求在调度Servlet、处理器映射(Handler Mappering)、控制器以及视图解析器(View resolver)之间移动，每一个Spring MVC中的组件都有特定的目的，并且也没那么复杂。 让我们看一下，请求是如何从客户端发起，经过Spring MVC中的组件，最终返回到客户端 5.1.1 跟踪Spring MVC每当用户在Web浏览器中点击链接或提交表单的时候，请求就开始工作了。请求是一个十分繁忙的家伙，从离开浏览器开始到获取响应返回，它会经历很多站，在每站都会留下一些信息，同时也会带上一些信息。 Spring工作流程描述原文在这里 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获； DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法） 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； ViewResolver 结合Model和View，来渲染视图 将渲染结果返回给客户端。 图片参考这里 Spring工作流程描述 为什么Spring只使用一个Servlet(DispatcherServlet)来处理所有请求？ 详细见J2EE设计模式-前端控制模式 Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler? 符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。 1、请求旅程的第一站是Spring的DispatcherServlet。与大多数基于Java的Web框架一样，Spring MVC所有的请求都会通过一个前端控制器(front contrller)Servlet.前端控制器是常用Web应用程序模式。在这里一个单实例的Servlet将请求委托给应用的其他组件来执行实际的处理。在Spring MVC中，DisPatcherServlet就是前端控制器。 2、DisPactcher的任务是将请求发送Spring MVC控制器(controller).控制器是一个用于处理请求的Spring组件。在典型的应用中可能会有多个控制器，DispatcherServlet需要知道应该将请求发送给那个哪个控制器。所以Dispactcher以会查询一个或 多个处理器映射(Handler mapping),来确定请求的下一站在哪里。处理映射器根据请求携带的 URL信息来进行决策。 3、一旦选择了合适的控制器，DispatcherServlet会将请求发送给选中的控制器。到了控制器，请求会卸下其负载(用户提交的信息)并耐心等待控制器处理这些信息。(实际上，设计良好的控制器 本身只是处理很少，甚至不处理工作，而是将业务逻辑委托给一个或多个服务器对象进行处理) 4、控制器在完成处理逻辑后，通常会产生一些信息。这些 信息需要返回给 用户，并在浏览器上显示。这些信息被称为模型(Model),不过仅仅给用户返回原始的信息是不够的—-这些信息需要以用户友好的方式进行格式化，一般会是HTML。所以，信息需要发送一个视图(View),通常会是JSP。 5、 控制器做的最后一件事就是将模型打包，并且表示出用于渲染输出的视图名。它接下来会将请求连同模型和视图发送回DispatcherServlet。 6、这样，*控制器就不会与特定的视图相耦合**传递给控制器的视图名并不直接表示某个特定的jsp。实际上，它甚至并不能确定视图就是JSP。相反，它仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。DispatcherServlet将会使用视图解析器(View resolver),来将逻辑视图名称匹配为一个特定的视图实现，他可能也可能不是JSP 7、虽然DispatcherServlet已经知道了哪个驶入渲染结果、那请求的任务基本上也就完成了，它的最后一站是试图的实现。在这里它交付给模型数据。请求的任务就结束了。视图将使用模型数据渲染输出。这个输出通过响应对象传递给客户端(不会像听上去那样硬编码) 可以看到，请求要经过很多步骤，最终才能形成返回给客户端的响应，大多数的 步骤都是在Spirng框架内部完成的。 5.1.2 搭建Spring MVC借助于最近几个Spring新特性的功能增强，开始使用SpringMVC变得非常简单了。使用最简单的方式配置Spring MVC；所要实现的功能仅限于运行我们所创建的控制器。 配置DisPatcherServlet DispatcherServlet是Spirng MVC的核心，在这里请求会第一次接触到框架，它要负责将请求路由到其他组件之中。 按照传统的方式，像DispatcherServlet这样的Servlet会配置在web.xml中。这个文件会放到应用的war包中。当然这是配置DispatcherServlet方法之一。借助于Servlet 3规范和Spring 3.1 的功能增强，这种方式已经不是唯一的方案来。 我们会使用Java将DispatcherServlet配置在Servlet容器中。而不会在使用web.xml文件 12345678910111213141516public class SpitterWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected String[] getServletMappings() &#123; //将DispatcherServlet映射到“/” return new String[]&#123;"/"&#125;; &#125; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt; [] &#123;RootConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt; [] &#123; WebConfig.class&#125;; &#125;&#125; 我们只需要知道扩展AbstractAnnotationConfigDispatcherServletInitializer的任意类都会自动的配置Dispatcherservlet和Spring应用上下文，Spirng的应用上下文会位于应用程序的Servlet上下文之中 在Servlet3.0环境中，容器会在类路径中 查找实现javax.servlet.ServletContainerInitialzer接口的类，如果能发现的话，就会用它来配置Servlet容器。 Spring提供了这个接口的实现名为SpringServletContainnerInitialzer,这个类反过来又会查找实现WebApplicationInitialzer的类，并将配置的任务交给他们来完成。Spring 3.2引入了一个遍历的WebApplicationInitialzer基础实现也就是AbstractAnnotationConfigDispatcherServletInitializer因为我们的Spittr-WebApplicationInitialzer扩展了AbstractAnnotationConfigDispatcherServletInitializer,(同时也就实现了WebApplicationInitialzer),因此当部署Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文 第一个方法getServletMappings(),它会将一个或多个路径映射到DispatcherServlet上，在本示例中，它映射的是“/”，表示它是应用默认的Servlet，它会处理应用的所有请求。 为了理解其他两个方法，我们首先需要理解DispatcherServlet和一个Servlet监听器(也就是ContextLoaderListener)的关系。 当DispatcherServlet启动的时候，它会创建应用上下文，并加载配置文件或配置类中声明的bean。在上面那个程序中的getServletConfigClasses()方法中，我们要求DispatcherServlet加载应用上下文时，使用定义在WebConfig配置类(使用Java配置)中的bean 但在Spring Web应用中，通常还会有另外一个应用上下文。另外这个就是由ContextLoaderListener创建. 我们希望DispatcherServlet加载包含Web组件的bean，如控制器，视图解析器，以及处理器映射，而ContextLoaderListener要加载应用中的其他bean。这些bean通常 是驱动应用后端的中间层和数据层组件。 实际上AbstractAnnotationConfigDispatcherServletInitializer会同时创建DispatcherServlet和ContextLoaderListener。getServletConfigClasses()方法会返回带有@Configuration注解的类将会用来定义DispatcherSerle应用上下文中的bean，getRootConfigClasses()会返回带有@Configuration注解的类将会用来配置ContextLoaderListener创建的应用上下文。 如果有必要两个可以同时存在，wex.xml和 AbstractAnnotationConfigDispatcherServletInitializer,但其实没有必要。 如果按照这种方式配置DispatcherServlet，而不是使用Web.xml的话，那么唯一的问题在于它能部署到支持Servlet3.0的服务器上才可以正常工作，如Tomcat7或更高版本，Servlet3.0规范在2009年12月份就发布了， 如果没有支持Servlet3.0，那别无选择了，只能使用web.xml配置类。 启用Spring MVC 我们有多种方式来启动DispatcherServlet，与之类似，启用Spring MVC组件的方式也不止一种，以前Spring是XMl进行配置的，你可以选择mvc:annotation-driver启用注解驱动的Spring MVC。 在第七章的时候会介绍mvc:annotaion-driver,现在会让Spring MVC搭建的过程尽可能简单，并基于Java进行配置。 我们所能创建最简单的Spring MVC配置就是一个带有@EnableWebMvc注解的类1234567import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@EnableWebMvcpublic class WebConfig &#123;&#125; 这可以运行起来，它的确能够启用Spring MVC，但还有不少问题要解决。 1、没有配置视图解析器，如果这样的话，Spring默认会使用BeanNameView-Resolver，这个视图解析器会查找ID与视图名称匹配的bean，并且查找的bean要实现View接口，它以这样的方式来解析视图。 2、没有启用组件扫描。这样的结果就是，Spirng只能找到显示声明在配置类中的控制器。 3、这样配置的话，DispatcherServlet会映射为默认的Servlet，所以他会处理所有的请求，包括对静态资源的请求，如图片 和样式表(在大多数情况下，这可能并不是你想要的结果)。 因此我们需要在WebConfig这个最小的Spring MVC配置上再加一些内容，从而让他变得真正实用。 12345678910111213141516171819202122@Configuration@EnableWebMvc //启用Spring MVC@ComponentScan("com.guo.spittr.web") //启用组件扫描public class WebConfig extends WebMvcConfigurerAdapter &#123; @Bean public ViewResolver viewResolver () &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); //配置JSP视图解析器 resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; @Override //我们要求DispatcherServlet将静态资源的请求转发到Servlet容器中默认的Servlet上， //而不是使用DispatcherServlet本来来处理此类请求。 public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; //配置静态资源的处理 configurer.enable(); &#125;&#125; 第一件需要注意的是WebConfig现在添加了@ComponentScan注解，此时将会扫描com.guo.spittr.web包来查找组件。稍后你会看到，我们编写的控制器将会带有@Controller注解，这会使其成为组件扫描时的候选bean。因此，我们不需要在配置类中显示声明任何的控制器。 接下来，我们添加了一个ViewResolver bean，更具体的将是InternalResourceViewResolver。将会在第6章更为详细的讨论视图解析器。我们只需要知道他会去查找jsp文件，在查找的时候，它会在视图名称上加一个特定的前缀和后缀。(例如：名为home的视图会被解析为/WEB-INF/views/home.jsp) 最后新的WebConfig类还扩展里WebMvcConfigurerAdapter并重写了其configureDefaultServletHandling()方法,通过调用DefaultServletHandlerConfigurer的enable()方法，我们要求DispatcherServlet将静态资源的请求转发到Servlet容器中默认的Servlet上，而不是使用DispatcherServlet本来来处理此类请求。 WebConfig已经就绪，那么RootConfig呢？因为本章聚焦于Web开发，而Web相关的配置通过DisPatcherServlet创建的应用上下文都已经配好了，因此现在的RootConfig相对很简单： 123456789101112131415import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.web.servlet.config.annotation.EnableWebMvc;/** * Created by guo on 23/2/2018. */@Configuration@ComponentScan(basePackages = &#123;"com.guo.spittr"&#125;, excludeFilters = &#123; @Filter(type = FilterType.ANNOTATION,value = EnableWebMvc.class)&#125;)public class RootConfig &#123;&#125; 唯一需要注意的是RootConfig使用了@ComponentScan注解，这样的话，我们就有很多机会用非Web的组件来完善RootConfig。 5.1.3 Spittr应用简介为了实现在线社交的功能，我们将要构造一个简单的微博(microblogging)应用，在很多方面，我们所构建的应用于最早的微博应用Twitter很类似，在这个过程中，我们会添加一些小的变化。当然我们使用Spirng技术来构建这个应用。 因为从Twitter借鉴了灵感并通过Spring来进行实现，所以它就有了一个名字：Spitter。 Spittr应用有两个基本的领域概念：Spitter(应用的用户)和Spittle(用户发布的简短状态更新)。当我们在书中完善Spittr应用的功能时，将会介绍这两个概念。在本章中，我们会构建应用的Web层，创建展现Spittle的控制器以及处理用户注册为Spitter的表单。 舞台已经搭建完成了，我们已经配置了DispatcherServlet，启用了基本的Spring MVC组件，并确定了目标应用。让我们进入本章的核心内容：使用Spring MVC 控制器处理Web请求。 5.2 编写 基本的控制器在SpringMVC中，控制器只是在方法上添加了@RequestMapping注解的类，这个注解声明了他们所要处理的请求。 开始的时候，我们尽可能简单，假设控制器类要处理对/的请求，并对渲染应用的首页。 123456789101112131415import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;/** * Created by guo on 24/2/2018. * 首页控制器 */@Controllerpublic class HomeController &#123; @RequestMapping(value = "/",method = RequestMethod.GET) //处理对“/”的Get请求 public String home() &#123; return "home"; //视图名为home &#125;&#125; 写完测试了下，好使， 你可能注意到第一件事就是HomeController带有@Controller注解，很显然这个注解是用来声明控制器的，但实际上这个注解对Spirng MVC 本身影响不大。 @Controller是一个构造型(stereotype)的注解。它基于@Component注解。在这里，它的目的就是辅助实现组件扫描。因为homeController带有@Controller注解，因此组件扫描器会自动去找到HomeController，并将其声明为Spring应用上下文中的bean。1234567Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller &#123; String value() default "";&#125; 其实你可以让HomeController带有@Component注解，它所实现的效果是一样的。但是在表意性上可能差一些，无法确定HomeController是什么组件类型。 HomeController唯一的一个方法，也就是Home方法，带有@RequestMapping注解，他的Value属性指定了这个方法所要处理的请求路径，method属性细化了它所能处理的HTTP方法，在本例中，当收到对‘/’的HTTP GET请求时，就会调用home方法。 home()方法其实并没有做太多的事情，它返回一个String类型的“home”，这个String将会被Spring MVC 解读为要渲染的视图名称。DispatcherServlet会要求视图解析器将这个逻辑名称解析为实际的视图。 鉴于我们配置InternalResourceViewResolver的方式，视图名“home”将会被解析为“/WEB-INF/views/home.jsp” Spittr应用的首页，定义为一个简单的JSP123456789101112131415&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ page session="false" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Spitter&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="&lt;c:url value="/resources/style.css" /&gt;" &gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to Spitter&lt;/h1&gt; &lt;a href="&lt;c:url value="/spittles" /&gt;"&gt;Spittles&lt;/a&gt; | &lt;a href="&lt;c:url value="/spitter/register" /&gt;"&gt;Register&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 测试控制器最直接的办法可能是构建并部署应用，然后通过浏览器对其进行访问，但是自动化测试可能会给你更快的反馈和更一致的独立结果，所以，让我们编写一个针对HomeController的测试 5.2.1 测试控制器编写一个简单的类来测试HomoController。12345678910import static org.junit.Assert.*;import org.junit.Test;public class HomeControllerTest &#123; @Test public void testHomePage() throws Exception &#123; HomeController controller = new HomeController(); assertEquals("home",controller.home()); &#125;&#125; 在测试中会直接调用home()方法，并断言返回包含 “home”值的String类型。它完全没有站在Spring MVC控制器的视角进行测试。这个测试没有断言当接收到针对“/”的GET请求时会调用home()方法。因为它返回的值就是“home”，所以没有真正判断home是试图的名称。 不过从Spring 3.2开始，我们可以按照控制器的方式进行测试Spring MVC中的控制器了。而不仅仅是POJO进行测试。Spring现在包含了一种mock Spirng MVC 并针对控制器执行 HTTP请求的机制。这样的话，在测试控制器的时候，就没有必要在启动Web服务器和Web浏览器了。 为了阐述如何测试Spirng MVC 容器，我们重写了HomeControllerTest并使用Spring MVC 中新的测试特性。 123456789101112131415161718import org.junit.Test;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.setup.MockMvcBuilders.*;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;/** * Created by guo on 24/2/2018. */public class HomeControllerTest1 &#123; @Test //大家在测试的时候注意静态导入的方法 public void testHomePage() throws Exception &#123; HomeController controller = new HomeController(); MockMvc mockMvc = standaloneSetup(controller).build(); //搭建MockMvc mockMvc.perform(get("/")) //对“/”执行GET请求， .andExpect(view().name("home")); //预期得到home视图 &#125;&#125; 这次我们不是直接调用home方法并测试它的返回值，而是发起了对”/“的请求，并断言结果视图的名称为home，它首先传递一个HomeController实例到MockMvcBuilders.strandaloneSetup()并调用build()来构建MockMvc实例，然后它使用MockMvc实例执行针对“/”的GET请求，并设置 期望得到的视图名称。 5.2.2 定义类级别的请求处理。现在，已经为HomeController编写了测试，那么我们可以做一些重构。并通过测试来保证不会对功能造成什么破坏。我们可以做的就是拆分@RequestMapping，并将其路径映射部分放到类级别上 12345678@Controller@RequestMapping("/")public class HomeController &#123; @RequestMapping(method = RequestMethod.GET) //处理对“/”的Get请求 public String home() &#123; return "home"; //视图名为home &#125;&#125; 在这个新版本的HomeController中，路径被转移到类级别的@RequestMapping上，而HTTP方法依然映射在方法级别上。当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上，处理器方法上的@RequestMapping注解会对类级别上的@RequestMapping的声明进行补充。 就HomeController而言，这里只有一个控制器方法，与类级别的@RequestMapping合并之后，这个方法的@RequestMapping表明home()将会处理对 “/”路径的GET请求。 有了测试，所以可以确保在这个过程中，没有对原有的功能造成破坏。 当我们修改@RequestMapping时，还可以对HomeController做另一个变更。@RequestMapping的value接受一个String类型的数组。到目前为止，我们给它设置的都是一个String类型的‘/’。但是，我们还可以将它映射到对“/Homepage”的请求，只需要将类级别的@RequestMapping改动下 12345@Controller@RequestMapping(&#123;"/","/Homepage"&#125;)public class HomeController &#123; ...&#125; 现在，HomeController的home()方法可以被映射到对“/”和“/homepage”的GET请求上。 5.2.3 传递模型数据到视图中到目前为止，就编写超级简单的控制器来说，HomeController已经是一个不错的样例了，但是大多数的控制器并不是那么简单。在Spring应用中，我们需要有一个页面展示最近提交的Spittle列表。因此，我们需要有一个新的方法来处理这个页面。 首先需要定义一个数据访问的Repository，为了实现解耦以及避免陷入数据库访问的细节中，我们将Repository定义为一个接口，并在稍后实现它(第十章)，此时，我们只需要一个能够获取Spittle列表的Repository，123456789package com.guo.spittr.data;import com.guo.spittr.Spittle;import java.util.List;/** * Created by guo on 24/2/2018. */public interface SpittleRepository &#123; List&lt;Spittle&gt; finfSpittles(long max, int count);&#125; findSpittles()方法接受两个参数，其中max参数代表所返回的Spittle中，Spittle ID属性的最大值，而count参数表明要返回多少个Spittle对象，为了获得最新的20个Spittle对象，我们可以这样调用方法。 1List&lt;Spittle&gt; recent = SpittleRepository.findSpittles(long.MAX_VALUE(),20) 它的属性包括消息内容，时间戳，以及Spittle发布时对应的经纬度。 12345678910111213141516171819202122232425262728293031public class Spittle &#123; private final Long id; private final String message; private final Date time; private Double latitude; private Double longitude; public Spittle(String message, Date time) &#123; this(null, message, time, null, null); &#125; public Spittle(Long id, String message, Date time, Double longitude, Double latitude) &#123; this.id = id; this.message = message; this.time = time; this.longitude = longitude; this.latitude = latitude; &#125; //Getter和Setter略 @Overridepublic boolean equals(Object that) &#123; return EqualsBuilder.reflectionEquals(this, that, "id", "time");&#125;@Overridepublic int hashCode() &#123; return HashCodeBuilder.reflectionHashCode(this, "id", "time");&#125; 需要注意的是，我们使用Apache Common Lang包来实现equals()和hashCode()方法，这些方法除了常规的作用以外，当我们为控制器的处理器方法编写测试时，它们也是有用的。 既然我们说到了测试，那么我们继续讨论这个话题，并为新的控制器方法编写测试， 123456789101112131415161718192021222324252627@Test public void houldShowRecentSpittles() throws Exception &#123; List&lt;Spittle&gt; expectedSpittles = createSpittleList(20); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findSpittles(Long.MAX_VALUE, 20)) .thenReturn(expectedSpittles); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller) .setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")) .build(); mockMvc.perform(get("/spittles")) .andExpect(view().name("spittles")) .andExpect(model().attributeExists("spittleList")) .andExpect(model().attribute("spittleList", hasItems(expectedSpittles.toArray()))); &#125;/.................佩服老外，测试代码一大堆，省略了好多，好好研究下，..................../ private List&lt;Spittle&gt; createSpittleList(int count) &#123; List&lt;Spittle&gt; spittles = new ArrayList&lt;Spittle&gt;(); for (int i=0; i &lt; count; i++) &#123; spittles.add(new Spittle("Spittle " + i, new Date())); &#125; return spittles; &#125;&#125; 测试首先会创建SpittleRepository接口的mock实现，这个实现会从他的findSpittles()方法中返回20个Spittle对象，然后将这个Repository注入到一个新的SpittleController实例中，然后创建MockMvc并使用这个控制器。 需要注意的是这个测试在MockMvc构造器上调用了setSingleView().这样的话，mock框架就不用解析控制器中的视图名了。在很多场景中，其实没必要这么做，但是对于这个控制器方法，视图和请求路径非常相似，这样按照默认的驶入解析规则，MockMvc就会发生失败，因为无法区分视图路径和控制器的路径，在这个测试中，构建InternalResourceViewResolver时所设置的路径是无关紧要的，但我们将其设置为InternalResourceViewResolver一致。 这个测试对“/spittles”发起Get请求，然后断言视图的名称为spittles并且模型中包含名为spittleList的属性，在spittleList中包含预期的内容。 当然如果此时运行测试的话，它将会失败。他不是运行失败，而是编译的时候就失败，这是因为我们还没编写SpittleController。 123456789101112131415@Controller@RequestMapping("/spittles")public class SpittleController &#123; private SpittleRepository spittleRepository; @Autowired public SpittleController(SpittleRepository spittleRepository) &#123; //注入SpittleRepository this.spittleRepository = spittleRepository; &#125; @RequestMapping(method = RequestMethod.GET) public String spittles(Model model) &#123; model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名 &#125;&#125; 我们可以看到SpittleController有一个构造器，这个构造器使用@Autowired注解，用来注入SpittleRepository。这个SpittleRepository随后又在spittls()方法中，用来获取最新的spittle列表。 需要注意的是我们在spittles()方法中给定了一个Model作为参数。这样，spittles()方法就可以将Repository中获取到的Spittle列表填充到模型中，Model实际上就是一个Map(也就是key-value的集合)它会传递给视图，这样数据就能渲染到客户端了。当调用addAttribute()方法并且指定key的时候，那么key会根据值的对象类型来推断确定。 sittles()方法最后一件事是返回spittles作为视图的名字，这个视图会渲染模型。 如果你希望显示模型的key的话，也可以指定，123456@RequestMapping(method = RequestMethod.GET)public String spittles(Model model) &#123; model.addAttribute("spittleList", spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名&#125; 如果你希望使用非Spring类型的话，那么可以使用java.util.Map来代替Model123456@RequestMapping(method = RequestMethod.GET)public String spittles(Map model) &#123; model.addAttribute("spittleList", spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名&#125; 既然我们现在提到了各种可替代方案，那下面还有另外一种方式来编写spittles()方法 1234@RequestMapping(method = RequestMethod.GET)public List&lt;String&gt; spittles() &#123; return spittleRepository.findSpittles(Long.MAX_VALUE,20));&#125; 这个并没有返回值，也没有显示的设定模型，这个方法返回的是Spittle列表。。当处理器方法像这样返回对象或集合时，这个值会放到模型中，模型的key会根据其类型推断得出。在本示例中也就是(spittleList) 逻辑视图的名称也会根据请求的路径推断得出。因为这个方法处理针对“/spittles”的GET请求，因此视图的名称将会是spittles，（去掉开头的线。） 不管使用哪种方式来编写spittles()方法，所达成的结果都是相同的。模型会存储一个Spittle列表，ket为spittleList，然后这个列表会发送到名为spittles的视图中。视图的jsp会是“/WEB-INF/views/spittles.jsp” 现在数据已经放到了模型中，在JSP中该如何访问它呢？实际上，当视图是JSP的时候，模型数据会作为请求属性放入到请求之中(Request) ,因此在spittles.jsp文件中可以使用JSTL(JavaServer Pages Standard Tag Library) 的&lt;c:forEach&gt;标签渲染spittle列表。 123456789&lt;c:forEach items="$&#123;spittleList&#125;" var="spittle" &gt; &lt;li id="spittle_&lt;c:out value="spittle.id"/&gt;"&gt; &lt;div class="spittleMessage"&gt;&lt;c:out value="$&#123;spittle.message&#125;" /&gt;&lt;/div&gt; &lt;div&gt; &lt;span class="spittleTime"&gt;&lt;c:out value="$&#123;spittle.time&#125;" /&gt;&lt;/span&gt; &lt;span class="spittleLocation"&gt;(&lt;c:out value="$&#123;spittle.latitude&#125;" /&gt;, &lt;c:out value="$&#123;spittle.longitude&#125;" /&gt;)&lt;/span&gt; &lt;/div&gt; &lt;/li&gt;&lt;/c:forEach&gt; 尽管SpittleController很简单，但是它依然比homeController更进一步，不过，SpittleController和HomeController都没有处理任何形式的输入。现在，让我们扩展SpittleContorller，让它从客户端接受一些输入。 5.3 接受请求的输入Spring MVC 允许以多种方法将客户端中的数据传送到控制器的处理器方法中 查询数据(Query Parameter) 表单参数(Form Parameter) 路径变量(Path Variable) 作为开始，先来看下如何处理带有查询参数的请求，这也是客户端往服务器发送数据时，最简单和最直接的方法。 5.3.1 处理查询参数在Spittr应用中，可能需要处理的一件事就是展现分页的Spittle列表，如果你想让用户每次查看某一页的Spittle历史，那么就需要提供一种方式让用户传递参数进来，进而确定展现那些Spittle列表。 为了实现这个分页功能，我们编写的处理方法要接受两个参数 before参数 (表明结果中所有的SPittle的ID均在这个值之前) count参数(彪悍在结果中要包含的Spittle数量) 为了实现这个功能，我们将程序修改为spittles()方法替换为使用before参数和count参数的新spittles()方法。 首先添加一个测试，这个测试反映了xinspittles()方法的功能 123456789101112131415161718@Testpublic void shouldShowPagedSpittles() throws Exception &#123; List&lt;Spittle&gt; expectedSpittles = createSpittleList(50); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findSpittles(238900, 50)) .thenReturn(expectedSpittles); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller) .setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")) .build(); mockMvc.perform(get("/spittles?max=238900&amp;count=50")) .andExpect(view().name("spittles")) .andExpect(model().attributeExists("spittleList")) .andExpect(model().attribute("spittleList", hasItems(expectedSpittles.toArray())));&#125; 这个测试方法关键点在于同时传入了max和count参数，它测试了这些参数存在时的处理方法，而另一个则测试了没有这些参数的情景。 在这个测试之后，我们就能确保不管控制器发生了什么样的变化，它都能够处理这两种类型的请求。 123456@RequestMapping(method = RequestMethod.GET)public List&lt;Spittle&gt; spittles( @RequestParam(value = "max") long max, @RequestParam(value = "count") int count) &#123; return spittleRepository.findSpittles(max, count);&#125; SittleController中的处理器方法同时要处理有参数和没参数的场景，那我们需要对其进行修改，让它能接受参数。同时如果这些参数在请求中不存在的话，就是用默认值Long.MAX_VALUE和20.@RequestParam注解的defaultValue属性可以完成这个任务。 123456@RequestMapping(method=RequestMethod.GET)public List&lt;Spittle&gt; spittles( @RequestParam(value="max", defaultValue=MAX_LONG_AS_STRING) long max, @RequestParam(value="count", defaultValue="20") int count) &#123; return spittleRepository.findSpittles(max, count);&#125; 现在如果max如果没有参数指定的话，它将会是Long的最大值。 因为查询参数都是String 类型 ，因此defaultValue属性需要String类型， 1private static final String MAX_LONG_AS_STRING = long.toString(Long.MAX.VALUE) 请求中的查询参数是往控制器中传递信息的常用手段。另外一种方式就是将传递的参数作为请求路径的一部分。 5.3.2 通过路径参数接受输入假设我们的应用程序需要根据给定的ID来展现某一个Spittle记录。其中一种方案就是编写处理器方法，通过使用@RequestParam注解，让它接受ID作为查询参数。 123456@RequestMapping(value="/show",method = RequestMethod.GET)public String showSpittle( @RequestParam("spittle_id") long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; 在理想情况下，要识别资源应用应该通过URL路径来标识，而不是通过查询参数。对“/spittles/12345”发起请求要优于对“/spittles/show?spittle_id=12345”发起的请求。前者能识别出要查询的资源，而后者描述的是带有参数的一个操作——本质上是通过HTTP发起的RPC。 既然已经以面向资源的控制器作为目标，那我们将这个需求转化为一个测试。 1234567891011121314@Testpublic void testSpittle() throws Exception &#123; Spittle expectedSpittle = new Spittle("Hello", new Date()); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findOne(12345)).thenReturn(expectedSpittle); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(get("/spittles/12345")) .andExpect(view().name("spittle")) //断言图片的名称为spittle .andExpect(model().attributeExists("spittle")) //预期Spittle放到了模型之中 .andExpect(model().attribute("spittle", expectedSpittle));&#125; 这个测试构建了一个mockRepository，一个控制器和MockMvc 到目前为止，我们所编写的控制器，所有的方法都映射到了静态定义好的路径上，还需要包含变量部分 为了实现这种路径变量，Spring MVC允许我们在@RequestMapping路径中添加占位符，占位符的名称需要({..}),路径中的其他部分要与所处理的请求完全匹配，但是占位符可是是任意的值。 12345@RequestMapping(value="/&#123;spittleId&#125;",method = RequestMethod.GET)public String showSpittle(@PathVariable("spittleId") long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; @PathVariable(“spittleId”) 表明在请求路径中，不管占位符部分的值是什么都会传递给处理器方法的showSpittle参数中。 也可以去掉这个value的值，因为方法的参数碰巧与占位符的名称相同。12345@RequestMapping(value="/&#123;spittleId&#125;",method = RequestMethod.GET)public String showSpittle(@PathVariable long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; 如果传递请求中少量的数据，那查询参数和路径变量是合适的，但通常我们还需要传递很多的数据，(表单数据)，那么查询显得有些笨拙和受限制了。 5.4 处理表单Web应用的功能不局限于为用户推送内容，大多数的应用允许用户填充表单，并将数据提交回应用中，通过这种方式实现与用户的交互。 使用表单分为两个方面：展现表单以及处理用户通过表单提交的数据。在Spittr应用中，我们需要有个表单让用户进行注册，SitterController是一个新的控制器，目前只有一个请求处理的方法来展现注册表单。 123456789@Controller@RequestMapping("/spitter")public class SpitterController &#123; //处理对“/spitter/register” @RequestMapping(value = "/register",method = RequestMethod.GET) public String showRegistrationForm() &#123; return "registerForm"; &#125;&#125; 测试展现表单的控制器方法(老外每次都测试) 12345678@Testpublic void shouldShowRegistration() throws Exception &#123; SpitterController controller = new SpitterController(); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(get("/spitter/register")) .andExpect(view().name("registerForm"));&#125;&#125; 这个JSP必须包含一个HTML标签，123456&lt;form method="POST" name="spittleForm"&gt; &lt;input type="hidden" name="latitude"&gt; &lt;input type="hidden" name="longitude"&gt; &lt;textarea name="message" cols="80" rows="5"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type="submit" value="Add" /&gt;&lt;/form&gt; 需要注意的是这里的标签中并没有设置action属性。在这种情况下，当表单体提交的时，它会提交到与展现时相同的URL路径上，它会提交到“/spitter/reqister”上。 这意味着需要在服务器端编写该HTTP POST请求。 5.4.1 编写处理表单的处理器当处理注册表单的POST请求时，控制器需要接受表单数据，并将表单数据保存为Spitter对象。最后为了防止重复提交(用户刷新页面)，应该将浏览器重定向到新创建用户的基本信息页面。 1234567891011121314151617181920@Testpublic void shouldProcessRegistration() throws Exception &#123; SpitterRepository mockRepository = mock(SpitterRepository.class); Spitter unsaved = new Spitter("jbauer", "24hours", "Jack", "Bauer", "jbauer@ctu.gov"); Spitter saved = new Spitter(24L, "jbauer", "24hours", "Jack", "Bauer", "jbauer@ctu.gov"); when(mockRepository.save(unsaved)).thenReturn(saved); SpitterController controller = new SpitterController(mockRepository); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(post("/spitter/register") .param("firstName", "Jack") .param("lastName", "Bauer") .param("username", "jbauer") .param("password", "24hours") .param("email", "jbauer@ctu.gov")) .andExpect(redirectedUrl("/spitter/jbauer")); verify(mockRepository, atLeastOnce()).save(unsaved);&#125; 希望大家也可以学会这样方式 在构建完SpitterRepository的mock实现以及所要执行的控制器和MockNvc之后，shouldProcessRegistration()对“/spitter/register”发起了一个POST请求，作为请求的一部分，用户信息以参数的形式放到request中，从而模拟提交的表单。 12345678910111213141516171819202122232425/** * Created by guo on 24/2/2018. */@Controller@RequestMapping("/spitter")public class SpitterController &#123; private SpitterRepository spitterRepository; @Autowired public SpitterController(SpitterRepository spitterRepository) &#123; //注入SpiterRepository this.spitterRepository = spitterRepository; &#125; @RequestMapping(value = "/register", method = RequestMethod.GET) public String showRegistrationForm() &#123; return "registerForm"; &#125; @RequestMapping(value = "/register",method = RequestMethod.POST) public String procesRegistration(Spitter spitter) &#123; spitterRepository.save(spitter); //保存Spitter return "redirect:/spitter/" + spitter.getUsername(); //重定向到基本信息页面 &#125;&#125; 返回一个String类型，用来指定视图。但是这个视图格式和以前有所不同。这里不仅返回了视图的名称供视图解析器查找目标视图，而且返回的值还带有重定向的格式return &quot;redirect:/spitter/&quot; 当看到视图格式中有“redirect：”前缀时，它就知道要将其解析为重定向的规则，而不是试图的名称。在本例中，它将会重定向到基本信息的页面。 需要注意的是除了可以“redirect”还可以识别“forward：”前缀，请求将会前(forward)往指定的URL路径，而不再是重定向。 在SpitterController中添加一个处理器方法，用来处理对基本信息页面的请求。 123456@RequestMapping(value = "/&#123;username&#125;",method = RequestMethod.GET)public String showSpitterProfile(@PathVariable String username, Model model) &#123; Spitter spitter = spitterRepository.findByUsername(username); model.addAttribute(spitter); return "profile";&#125; spitterRepository通过用户获取一个Spitter对象，showSpitterProfile()方法得到这个对象并将其添加到模型中，然后返回profile。也就是基本信息页面的逻辑视图。 123456&lt;body&gt; &lt;h1&gt;Your Profile&lt;/h1&gt; &lt;c:out value="$&#123;spitter.username&#125;" /&gt;&lt;br/&gt; &lt;c:out value="$&#123;spitter.firstName&#125;" /&gt; &lt;c:out value="$&#123;spitter.lastName&#125;" /&gt;&lt;br/&gt; &lt;c:out value="$&#123;spitter.email&#125;" /&gt;&lt;/body&gt; 注意：这里使用H2数据库，太有用了。123456789101112131415@Configurationpublic class DataConfig &#123; @Bean public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("schema.sql") .build(); &#125; @Bean public JdbcOperations jdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 如果表单中没有发送username或password，会发生什么情况呢？或者名字太长，由会怎么样？，接下来，让我们看一下为表单添加校验，而从避免数据呈现不一致性。 5.4.2 校验表单如果用户在提交表单的时候，username和password为空的话，那么将会导致在新建Spitter对象中，username和password是空的String。如果不处理，将会出项安全问题。 同时我们应该阻止用户提交空的名字。限制这些输入的长度。 从Spring 3.0 开始，在Spring MVC中提供了java校验的API的支持。只需要在类路径下包含这个JavaAPI的实现即可。比如Hibernate validator. Java校验API定义了多个注解，这些注解可以用在属性上，从而限制这些属性的值。 @Size :所注解的元素必须是String、集合、或数组，并且长度要符合要求 @Null ：所注解的值必须为Null @NotNull ：所注解的元素不能为Null。 @Max ：所注解的必须是数字，并且值要小于等于给定制。 @Min @Past ：所注解的元素必须是一个已过期的日期 @Future ：必须是一个将来的日期 @Pattern：必须匹配给定的正则表达式 1234567891011121314151617181920212223242526public class Spitter &#123; private Long id; @NotNull @Size(min=5, max=16) private String username; @NotNull @Size(min=5, max=25) private String password; @NotNull @Size(min=2, max=30) private String firstName; @NotNull @Size(min=2, max=30) private String lastName; @NotNull @Email private String email; 忽略其他方法。&#125; 1234567891011@RequestMapping(value="/register", method=POST) //老外喜欢静态导入特性public String processRegistration( @Valid Spitter spitter, //校验Spitter输入 Errors errors) &#123; if (errors.hasErrors()) &#123; return "registerForm"; //如果校验出现错误，则重新返回表单 &#125; spitterRepository.save(spitter); return "redirect:/spitter/" + spitter.getUsername();&#125; Spitter参数添加了@Valid注解，这会告诉Spring，需要确保这个对象满足校验限制。 如果表单出错的话，那么这些错误可以通过Errors进行反问。 很重要一点需要注意的是：Errors参数要紧跟在带有Valid注解参数的后面。@Valid注解所标注的就是要校验的参数。 如果没有错误的话，Spitter对象将会通过Repository进行保存，控制器会像之前那样重定向到基本信息页面。 5.5 小节在本章中，我们为编写应用程序的Web部分开来一个好头，可以看到Spring有一个强大而灵活的Web框架。借助于注解，Spring MVC 提供了近似于POJO的开发模式，这使得开发处理请求的控制器变得简单，同时也易于测试。 当编写控制器的处理方法时，Spring MVC及其灵活。概括来讲，如果你的处理器方法需要内容的话，只需将对应的对象作为参数，而他不需要的内容，则没有必要出现在参数列表中。这样，就为请求带来了无限的可能性，同时还能保持一种简单的编程模型。 尽管本章中很多内容都是关于控制器的请求处理的，但是渲染响应也同样重要，我们通过使用JSP的方式，简单了解了如何为控制器编写视图，但是，就Spring MVC视图来说，它并不是本章所看到的简单JSP。 在接下来的第6章，我们将会更深入的学习Spring视图，包括如何在JSP中使用Spring标签库，还会学习如何借助于Apache Tiles为视图添加一致的结构。同时，还会了解Thymeleaf，这是一个很有意思的JSP替代方法，Spring为其提供了内置的支持。 参考：https://github.com/guoxiaoxu/SpringInActionPractice]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记四]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16-1%2F</url>
    <content type="text"><![CDATA[第四章 面向切面的Spring本章主要内容： 面向切面编程的基本原理 通过POJO创建切面 使用@Aspect注解 为AspectJ切面注入依赖。 在软件开发中，散布于应用中多出功能被称为横切关注点(crosscutting concern)。通常来讲横切关注点从概念上是与应用的业务逻辑分离的。但往往是耦合在一起的，把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。 依赖注入(DI)管理我们的应用对象，DI有助于应用对象之间解耦。而AOP可以实现横切关注点与它们所影响的对象之间的耦合。 4.1 什么是面向切面编程切面能够帮我们模块化横切关注点。简而言之，横切关注点可以被描述为影响应用多处的功能。例如 安全，事务、日志等功能。 如果要重用对象的话，最常见的面向对象技术是继承、委托、组合。但是，如果整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系。而使用委托可能需要委托对象进行复杂的调用。 切面提供了取代继承和委托的另一种可选方案。在使用面向切面编程时，我们仍然在一个地方定义通知功能，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面(aspect). 这样做带来两个好处：每个关注点都集中到一个地方，而不是分散到多处代码中：其次，服务模块更简洁，因为它只包含了主要关注点(核心功能)的代码。而次要关注的代码被移到切面中了。 4.1.1 定义AOP术语描述切面的常用术语有：通知(advice)、切点(pointcut)、连接点。 通知(advice)通知定义了切面是什么以及何时使用。除了描述切面要完成的工作外，通知还解决了何时执行这个工作问题。它应该在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？ Spring切面可以应用5中类型的通知： 前置通知(Before):在目标方法被调用之前调用通知功能。 后置通知(After):在目标方法完成之后调用通知 返回通知(After-returning):在目标方法成功执行之后调用通知 异常通知(After-throwing):在目标方法抛出异常后调用通知 环绕通知(Around):在被通知方法调用之前和调用之后执行自定义的行为 连接点我们的应用可能有数以千计的时机应用通知，这些时机被称为连接点。连接点是在应用执行过程中能够插入的一个点。这个点可以是调用方法时，抛出异常时，甚至修改一个字段时。切面可以利用这些点插入到应用的正常流程之中，并添加新的行为。 切点如果说通知定义了切面的的“什么”和“何时”，那么切点定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。 切面切面是通知和切点的结合。通知和切点通过定义了切面的全部 内容——他是什么，在什么时候和在哪里完成其功能。 引入引入允许我们向现有的类添加新的方法或者属性。 织入织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象。在目标对象的生命周期里有多个点可以进行织入： 编译期：切面在目标类编译时被织入。Aspect的织入编译器就是以这种方式织入切面的。 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载(Classloader)，它可以在目标类被引入之前增强该目标类的字节码(CGlib) 运行期：切面在应用运行时的某个时刻被织入。AOP会为目标对象创建一个代理对象。Spring AOP就是以这种方式织入切面的。 通知包含了需要用于多个应用对象的横切关注点。连接点是程序执行过程中能够应用通知的所有点。切点定义了通知被应用的具体位置(在哪些连接点)，其中关键是切点定义了哪些连接点会得到通知。 4.1.2 Spring对AOP的支持并不是所有的AOP框架都是相同的，他们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别的通知，而另一些只支持与方法调用相关的连接点。它们织入切面的方式和时机也有所不同。但是，无论如何，创建切点来定义切面所织入的连接点是AOP的基本功能。 **Spring提供了4种类型的AOP支持： 基于代理的经典Spring AOP（不推荐） 纯POJO切面 @AspectJ注解驱动的切面 注入式AspectJ切面** 前三种都是Spirng AOP实现的变体，Spring AOP构建在动态代理基础上。因此，Spring对AOP的支持局限于方法拦截。 引入了简单的声明式AOP与基于注解的AOP之后，Spring经典的看起来就显得非常笨拙和过于复杂话，直接使用ProxyFactory bean 会让人感觉厌烦。 借助于Spring的aop命名空间，我们可以将纯POJO转为切面。 Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP，但是编程模型几乎与编写成熟的AspectJ注解切面完全一致。这种AOP风格的好处在于能够不使用XML来完成功能。 Spring通知是Java编写的Spring所创建的通知都是用标准的Java类编写的，定义通知所应用的切点通常会使用注解或在Spring配置文件里采用XML来编写 Spring在运行时通知对象 通知带代理类中包裹切面，Spring在运行时把切面织入到Spring所管理的bean中。代理类封装了目标类，并拦截被通知方法的调用。再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。直到应用需要被代理bean时，Spring才会创建代理对象。如果使用ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有的bean的时候，Spring才会创建被代理的对象。因为Spirng运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。 Spring只支持方法级别的连接点Spring基于动态代理，所以Spring只支持方法连接点。方便拦截可以满足大部分的需求。 4.2 通过切点来选择连接点切点用于准确定位应该在什么地方应用切面的通知。通知和切点是切面最基本的元素。 Spring仅支持AspectJ切点指示器的一个子集。Spring是基于代理的，而某些切点表达式是基于代理的AOP无关的。 Spring支持的指示器，只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要的指示器。 4.2.1编写切点为了阐述Spring中的切面， 我们需要有个主题来定义切面的切点。 1234package com.guo.cocert;public interface Performance &#123; public void perform();&#125; 1execution(* concert.Performance.perform(..)) 我们使用execution()指示器选择Performance的perform()方法，方法表达式以”*”号开始，表明了我们不关心方法返回值的类型。然后指明了全限定类名和方法名，对于方法参数列表，我们使用了两个点号(..)表明切点要选择任意的perform()方法，无论该方法的入参是什么。 现在假设我们需要配置的切点仅匹配concert包，可以使用within()指示器 1execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*) 因为“&amp;”在XMl中有特殊的含义，所以在Spring和XML配置中，描述切点时，可以使用and代替“&amp;&amp;”。 4.2.2 在切点中选择beanSpring引入了一个新的bean()指示器，它允许我们在切点表达式中使用bean的ID来标识bean。bean()使用bean ID 或 bean 名称作为参数来限制切点只匹配特定的bean。 1execution(* concert.Performance.perform(..)) and bean("woodsotck") 也可以这样 1execution(* concert.Performance.perform(..)) and ！bean("woodsotck") 切面的通知会被编织到所有ID不为woodsotck的bean中。 4.3.1 定义切面如果一场演出没有观众的话，那不能称之为演出。对不对？从演出的角度来看，观众是非常 重要的，但是对演出本身的功能来讲，它并不是核心，这是一个单独的关注点。因此，将观 众定义为一个切面，并将其应用到演出上就是较为明智的做法。 下面展现了Audience类，它定义了我们所需的一个切面 1234567891011121314151617181920212223242526272829package com.spring.sample.concert;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class Audience &#123; @Before("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void silenceCellPhones() &#123; System.out.println("Silencing cell phones"); &#125; @Before("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void takeSeats() &#123; System.out.println("Taking seats"); &#125; @AfterReturning("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void applause() &#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; @AfterThrowing("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void demandRefund() &#123; System.out.println("Demand a refund"); &#125;&#125; Audience类使用@AspectJ注解进行了标注。该注解表明Audience不仅仅是一个POJO， 还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。 Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众 要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出 很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的 话，观众会要求退款（demandRefund()）。 可以看到，这些方法都使用了通知注解来表明它们应该在什么时候调用。AspectJ提供了五个 注解来定义通知，如表4.2所示。 你可能已经注意到了，所有的这些注解都给定了一个切点表达式作为它的值，同时，这四个 方法的切点表达式都是相同的。其实，它们可以设置成不同的切点表达式，但是在这里，这 个切点表达式就能满足所有通知方法的需求。让我们近距离看一下这个设置给通知注解的切 点表达式，我们发现它会在Performance的perform()方法执行时触发。 相同的切点表达式我们重复了四遍，这可真不是什么光彩的事情。这样的重复让人感觉有些 不对劲。如果我们只定义这个切点一次，然后每次需要的时候引用它，那么这会是一个很好 的方案。 幸好，我们完全可以这样做：@Pointcut注解能够在一个@AspectJ切面内定义可重用的 切点。接下来的程序清单4.2展现了新的Audience，现在它使用了@Pointcut。 1234567891011121314151617181920212223242526272829package com.spring.sample.concert;import org.aspectj.lang.annotation.*;@Aspectpublic class Audience &#123; @Pointcut("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void performance() &#123;&#125; @Before("performance()") public void silenceCellPhones() &#123; System.out.println("Silencing cell phones"); &#125; @Before("performance()") public void takeSeats() &#123; System.out.println("Taking seats"); &#125; @AfterReturning("performance()") public void applause() &#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; @AfterThrowing("performance()") public void demandRefund() &#123; System.out.println("Demand a refund"); &#125;&#125; 除了作为标记的 performance() 方法，Audience 类完全是一个 POJO，因此它也可以像普通 Java 类一样使用： 1234@Beanpublic Audience audience() &#123; return new Audience();&#125; 到此为止，Audience 仅仅是位于 Spring 容器中的一个 bean，即使它被 AspectJ 注解修饰，如果没有别的配置解释这个注解，并创建能够将它转换成切面的代理，则它不会被当做切面使用。 如果你使用 JavaConfig，则可以通过类级别的 @EnableAspectJAutoProxy 注解开启自动代理机制，例子代码如下所示： 12345678910111213141516package com.spring.sample.concert;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@EnableAspectJAutoProxy //开启AspectJ的自动代理机制@ComponentScanpublic class ConcertConfig &#123; @Bean public Audience audience() &#123; //定义Audience的bean return new Audience(); &#125;&#125; 如果你使用 XML 配置，则可以使用 &lt;aop: aspectj-autoproxy /&gt; 元素开启 AspectJ 的自动代理机制，对应的配置代码如下： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.spring.sample.concert&quot; /&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;bean class=&quot;com.spring.sample.concert.Audience&quot; /&gt;&lt;/beans&gt; 无论使用 JavaConfig 还是 XML 配置文件，AspectJ 的自动代理机制使用由 @Aspect 注解修饰的 bean 为那些被切点指定的 beans 创建代理。在这个例子中，将会为 Performance 接口创建代理，并在 perform() 方法调用前或者调用后应用切面中的通知方法。 特别要记住：Spring 中的 AspectJ 自动代理机制本质上还是 Spring 中基于代理的切面，因此，虽然你使用了 @Aspect 注解，但是仍然仅能支持函数调用级别的拦截。如果你希望使用 AspectJ 的功能，那么你得使用 AspectJ 的运行时并且不要使用 Spring 创建基于代理的切面。 环绕通知（around advice）与其他通知类型不同，因此值得用一小节单独论述。 4.3.2 创建环绕通知环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起 来。实际上就像在一个通知方法中同时编写前置通知和后置通知。 为了阐述环绕通知，我们重写Audience切面。这次，我们使用一个环绕通知来代替之前多 个不同的前置通知和后置通知。 12345678910111213141516171819202122package com.spring.sample.concert;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;@Aspectpublic class Audience &#123; @Pointcut(&quot;execution(* com.spring.sample.concert.Performance.perform( .. ))&quot;) public void performance() &#123;&#125; @Around(&quot;performance()&quot;) public void watchPerformance(ProceedingJoinPoint joinPoint) &#123; try &#123; System.out.println(&quot;Silencing cell phones&quot;); System.out.println(&quot;Taking seats&quot;); joinPoint.proceed(); System.out.println(&quot;CLAP CLAP CLAP!!!&quot;); &#125; catch (Throwable e) &#123; System.out.println(&quot;Demanding a refund&quot;); &#125; &#125;&#125; @Around 注解表示 watchPerformance() 方法将作为环绕通知应用在与切点——performance() 匹配的方法上。这个方法实现的效果跟之前的四个函数完全相同，但是有一点不同，即该函数有一个参数——ProceedingJoinPoint 实例，这里需要通过这个参数主动调用业务函数——joinPoint.proceed();。在环绕通知中必须调用 proceed() 方法，如果没有，则应用的执行会阻塞在通知方法中。 你还可以在一个通知中多次调用 proceed() 方法，从而可以实现重试逻辑——业务逻辑可能失败，可以限定失败重试的次数。 4.3.3 处理通知中的参数截止目前为止，我们编写的切面都非常简单——没有接收输入参数。仅有的例外是环绕通知中需要使用 ProceedingJoinPoint 参数，除此之外其他通知都没有携带任何参数传入被通知的方法中，那是因为 perform() 方法本身不需要任何参数。 如果你的切面要通知的是一个带参数的函数？切面是否能访问传入函数的参数并使用它们？举个例子说明，BlankDisc 类中有一个 play() 方法，该方法的功能是遍历所有的 tracks 并利用每个 track 对象调用 playTrack() 方法。 1234567891011121314151617181920212223242526272829303132package com.spring.sample.soundsystem;import org.springframework.stereotype.Component;import java.util.List;@Componentpublic class BlankDisc implements CompactDisc &#123; private String title; private String artist; private List&lt;String&gt; tracks; public BlankDisc() &#123; &#125; public BlankDisc(String artist, String title, List&lt;String&gt; tracks) &#123; this.artist = artist; this.title = title; this.tracks = tracks; &#125; public void play() &#123; System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist); for (String track: tracks) &#123; System.out.println(&quot;-Track: &quot; + track); &#125; &#125; public void playTrack(int num) &#123; System.out.println(&quot;-Track: &quot; + tracks.get(num)); &#125; //setter和getter在此处省略&#125; 现在你希望记录每个 track 被调用的次数，一种方法是直接修改 playTrack() 方法，通过一个全局变量（例如 Map 数据结构）记录每个 track 被调用的次数。但是，track-counting 这个逻辑跟 play track 实际上是两个不同的关注点，因此应该考虑通过 AOP 实现。 首先定义一个切面，即 TrackCounter 类，并在 playTrack() 方法出进行通知，代码可列举如下： 1234567891011121314151617181920212223242526package com.spring.sample.soundsystem;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import java.util.HashMap;import java.util.Map;@Aspectpublic class TrackCounter &#123; private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;Integer, Integer&gt;(); @Pointcut( &quot;execution(* com.spring.sample.soundsystem.CompactDisc.playTrack( .. )) &quot; + &quot;&amp;&amp; args(trackNumber)&quot;) public void trackPlayed(int trackNumber) &#123;&#125; @Before(&quot;trackPlayed(trackNumber)&quot;) public void countTrack(int trackNumber) &#123; int currentCount = getPlayCount(trackNumber); trackCounts.put(trackNumber, currentCount + 1); &#125; public int getPlayCount(int trackNumber) &#123; return trackCounts.containsKey(trackNumber) ？ trackCounts.get(trackNumber) : 0; &#125;&#125; 跟上一小节创建的切面类似，首先利用 @Pointcut 注解定义一个切点，然后利用 @Before 注解定义前置通知。不同的地方在于切点的定义，除了指定被通知的方法，还指定了被通知方法需要的参数 trackNumber。下图展示如何理解切点的定义。 关键在于 args(trackNumber) 标识符，这表示每个传入业务函数 playTrack() 的 int 参数也将被传入通知，而且，args() 中参数的名称必须跟切点方法的签名中的参数名称相同，例如： 1234@Pointcut( &quot;execution(* com.spring.sample.soundsystem.CompactDisc.playTrack( .. )) &quot; + &quot;&amp;&amp; args(ex)&quot;)public void trackPlayed(int ex) &#123;&#125; 同样，@Before 注解中利用切点函数定义的参数名称，也必须与通知方法签名中的参数完全相同，例如： 12345@Before(&quot;trackPlayed(duqi)&quot;)public void countTrack(int duqi) &#123; int currentCount = getPlayCount(duqi); trackCounts.put(duqi, currentCount + 1);&#125; 然后在 Spring 的配置文件中配置 BlankDisc 和 TrackCounter，并开启 AspectJ 自动代理机制，配置文件代码如下： 1234567891011121314151617181920212223242526272829303132package com.spring.sample.soundsystem;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;import java.util.ArrayList;import java.util.List;@Configuration@EnableAspectJAutoProxypublic class TrackCounterConfig &#123; @Bean public CompactDisc sgtPeppers() &#123; BlankDisc cd = new BlankDisc(); cd.setTitle(&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;); cd.setArtist(&quot;The Beatles&quot;); List&lt;String&gt; tracks = new ArrayList&lt;String&gt;(); tracks.add(&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;); tracks.add(&quot;With a Little Help from My Friends&quot;); tracks.add(&quot;Lucky in the Sky with Diamonds&quot;); tracks.add(&quot;Getting Better&quot;); tracks.add(&quot;Fixing a Hole&quot;); tracks.add(&quot;testtest&quot;); tracks.add(&quot;hhhhhhhhhh&quot;); cd.setTracks(tracks); return cd; &#125; @Bean public TrackCounter trackCounter() &#123; return new TrackCounter(); &#125;&#125; 最后，为了验证我们的想法，需要写个单元测试用例进行验证，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738package com.spring.sample.soundsystem;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.*;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = TrackCounterConfig.class)public class TrackCounterTest &#123; @Autowired private CompactDisc cd; @Autowired private TrackCounter counter; @Test public void testTrackCounter() &#123; cd.playTrack(0); cd.playTrack(1); cd.playTrack(2); cd.playTrack(2); cd.playTrack(2); cd.playTrack(2); cd.playTrack(6); cd.playTrack(6); assertEquals(1, counter.getPlayCount(0)); assertEquals(1, counter.getPlayCount(1)); assertEquals(4, counter.getPlayCount(2)); assertEquals(0, counter.getPlayCount(3)); assertEquals(0, counter.getPlayCount(4)); assertEquals(0, counter.getPlayCount(5)); assertEquals(2, counter.getPlayCount(6)); &#125;&#125; TrackCounter 这个切面可以在显存函数的基础上进行进一步封装，不过除了函数封装，还可以利用切面给被通知的对象引入新的功能。 4.3.4 使用基于注解的切面引入新功能在一些动态语言（Ruby、Groovy）中，存在开放类的特性，这种特性支持在不修改原来类或者对象的基础上为该类添加新方法。不过，Java 不是动态语言，一旦一个类被编译，你几乎不能再对它进行修改。 不过，仔细思考下，上述说的这个需求：在不修改原有类的基础上为该类添加新方法，这不正是切面可以完成的工作么？在上个小节的例子中我们是为原有类的方法添加了新的功能，同样，也可以为原来的类添加新的方法。这里通过 AOP 引出一个新的概念引入（introductions），即通过切面为 Spring 的 beans 增加新方法。 Spring 中切面的本质就是一个代理对象，这个代理对象与目前对象实现同一个接口。既然如此，那么可以扩展一下，如果代理对象实现新的接口呢？这样被这个切面通知的 bean 就好像又实现了一个新的接口——增加了新的功能，即使底层并没有修改原来的类。下图展示了这个思路： 当 introduced 接口的某个方法被调用时，代理对象会把这个调用委托给一个实现了该 introduced 接口的对象。对于外部而言，就好像一个 bean 实现了多个接口。 举个例子，假设你要把下面这个 Encoreable 接口引入给 Performance 接口的任何实现。 123public interface Encoreable &#123; void performEncore();&#125; 你当然可以让原来 Performance 接口的实现也同时实现这个接口，但是关键是并不是所有的 Performance 实现都需要引入 Encoreable；而且，从应用维护的角度看，全部修改 Performance 的实现容易引入新的 bug；另外，如果 Performance 接口来自第三方库，你也没有办法接触到源码。 那么利用 Spring AOP 如何操作呢？首先准备一个 introduced 接口的默认实现类，代码如下： 1234567package com.spring.sample.concert;public class DefaultEncoreable implements Encoreable &#123; public void performEncore() &#123; System.out.println(&quot;perform the encore!&quot;); &#125;&#125; 然后新建一个切面，即 EncoreableIntroducer 类，代码列举如下： 1234567891011package com.spring.sample.concert;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.DeclareParents;@Aspectpublic class EncoreableIntroducer &#123; @DeclareParents(value = &quot;com.spring.sample.concert.Performance+&quot;, defaultImpl = DefaultEncoreable.class) public static Encoreable encoreable;&#125; EncoreableIntroducer 是一个切面，但和之前学过的切面不同在于它没有定义各种通知，它通过 @DeclareParents 注解将 Encoreable 接口引入到 Performance 接口的实现中。 @DeclareParents注解由三部分组成： value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现 Performance的类型。（标记符后面的加号表示是Performance的所有子类型，而 不是Performance本身。） defaultImpl属性指定了为引入功能提供实现的类。在这里，我们指定的 是DefaultEncoreable提供实现。 @DeclareParents注解所标注的静态属性指明了要引入了接口。在这里，我们所引入 的是Encoreable接口。 跟其他切面的用法类似，需要在 Spring 应用上下文中定义 EncoreableIntroducer bean，如果使用 JavaConfig，则代码如下： 1234@Beanpublic EncoreableIntroducer encoreableIntroducer() &#123; return new EncoreableIntroducer();&#125; Spring 的自动代理机制从这里获取这个 bean。当 Spring 发现一个被 @Aspect 注解修饰的 bean，就会自动为它创建一个代理对象，负责将外部的函数调用委托给目标 bean 或者新引入接口的实现，至于由哪个实现负责执行，取决于这个函数属于原接口还是新引入的接口。 书中没有的如果这个小节只说到这，你可能会有疑惑，那你说的这个引入新接口这么牛，什么场景下怎么使用呢？针对这个疑惑，我写了一个单元测试，代码如下： 12345678910111213141516171819202122package com.spring.sample.soundsystem;import com.spring.sample.concert.ConcertConfig;import com.spring.sample.concert.Encoreable;import com.spring.sample.concert.Performance;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = ConcertConfig.class)public class EncoreIntroducerTest &#123; @Autowired private Performance musicPerformance; @Test public void testEncore() &#123; Encoreable encoreable = (Encoreable)musicPerformance; //使用方法 encoreable.encore(); &#125;&#125; 可以看到，本来 musicPerformance 是 Performance 的实现，通过强转，我可以调用新接口中的方法了，而且没有修改原来的类和接口；而中间负责将函数调用委托给不同的实现对象的任务就是由切面自动完成。 4.4 在XML中声明切面之前，有这样一条原则：那就是基于注解的配置要优于Java的配置，基于Java的配置要优于XMl的配置，但是，如果你需要声明切面，但是又不能为通知类添加注解的时候 ，那么就必须转向XML配置了。 在Spring的aop命名空间中，提供了多个元素用来在XML中声明切面， 4.4.1 声明前置通知和后置通知我们会使用Spring aop命名空间中的一些元素，将没有注解的Aurience类转为切面 12345678910111213&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:before pointcut="execution(* * concert.Performance.perform(..))" method="silenceCellIphones"/&gt; &lt;aop:before pointcut="execution(* * concert.Performance.perform(..))" method="takeSeats"/&gt; &lt;aop:after-returning pointcut="execution(* * concert.Performance.perform(..))" method="applause"/&gt; &lt;aop:after-throwing pointcut="execution(* * concert.Performance.perform(..))" method="demandRefund"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 第一需要注意的就是大多数AOP配置元素必须在aop:config元素的上下文中使用。 在所有的通知元素中，pointcut属性定义了通知所应用的切点，它的值是使用AspectJ切点表达式语法所定义的切点。 在基于Aspectj注解的通知中，当发现在这些类型的重复时，使用@Pointcut注解来消除这些重复的内容。 如下的XMl配置展示了如何将通用的切点表达式抽取到一个切点声明中，这样，这个声明就能在所有的通知元素中使用了 1234567891011121314&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:pointcut id="performance" expression="execution(* * concert.Performance.perform(..))" /&gt; &lt;aop:before pointcut="" method="silenceCellIphones"/&gt; &lt;aop:before pointcut-ref="performance" method="takeSeats"/&gt; &lt;aop:after-returning pointcut-ref="performance" method="applause"/&gt; &lt;aop:after-throwing pointcut-ref="performance" method="demandRefund"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 现在的切点是一个地方定义的，并且被多个通知元素所引用，aop:pointcut元素定义了一个id为performance的切点，同时修改所有的通知元素，用pointcut0ref来引用这个命名切点。 4.4.2 声明环绕通知例如，假设除了进场关闭手机和表演结束后鼓掌，我们还希望观众确保一直关注演出，并报 告每个参赛者表演了多长时间。使用前置通知和后置通知实现该功能的唯一方式是在前置通 知中记录开始时间并在某个后置通知中报告表演耗费的时间。但这样的话我们必须在一个成 员变量中保存开始时间。因为Audience是单例的，如果像这样保存状态的话，将会存在线 程安全问题。 相比于前置通知和后置通知，环绕通知在这点上有明显的优势。使用环绕通知，我们可以完成前置通知和后置通知所实现的相同功能，而且只需要在一个方法中实现。因为整个通知逻辑都是在一个方法中实现的。 12345678&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:pointcut id="performance" expression="execution(* * concert.Performance.perform(..))" /&gt; &lt;aop:around pointcut-ref="performance" method="watchPerformance"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 像其他通知的XML元素一样，aop:around指定了一个切点和一个通知方法的名字。 4.4.3 为通知传递参数12 区别在于切点表达式中包含了一个参数，这个参数传递到通知方法中。还有区别就是这里使用了and关键字 4.4.4 通过切面引入新的功能借助于AspectJ的@DeclareParents注解为被通知的方法引入新的方法。但是AOP引入并不是Aspectj特有的。使用Spring aop命名空间中的aop:declare-parents元素，我们可以实现相同的功能 12345678&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:declare-parents types-matching="concert.Performance" implement-interface="concert.Encoreable" default-impl="concert.DefaoultEncoreable" &lt;/aop:aspect&gt; &lt;/aop:config&gt; 4.5 注入AspectJ切面虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP是一个功能比较弱的AOP解决方案，ASpect提供了Spring AOP 所不能支持的许多类型的切点。 Spring不能像之前那样使用声明来创建一个实例—-它已经在运行时由AspectJ创建完成了，Spring需要通过工厂方法获取切面的引用。然后像元素规定的那样在该对象上执行依赖注入 4.6 小节(重点中的重点)AOP是面向对象编程的一个强大补充，通过AspectJ，我们现在可以把之前分散在应用各处的行为放入可重用的模块中。我们显示地声明在何处如何应用该行为。这样有效减少了代码冗余，并让我们的类关注自身的主要功能。 Spring提供了一个AOP框架，让我们把切面插入到方法执行的周围。现在我们已经学会了如何把通知织入前置，后置和环绕方法的调用中，以及为处理异常增加自定义行为。 关于在Spirng应用中如何使用切面 ，我们可以有多种选择。通过使用@AspectJ注解和简化的配置命名空间，在Spring中装配通知和切点变得非常简单 最后，当Spring不能满足需求时，我们必须转向更为强大的AspectJ。对于这些场景，我们了解了如何使用Spring为AspectJ切面注入依赖。 此时此刻，我们已经覆盖了Spring框架的基础知识，了解到如何配置Spring容器以及如何为Spring管理的对象应用切面，这些技术为创建高内聚，低耦合的应用奠定了坚实的基础。 从下一章开始，首先看到的是如何使用Spring构建Web应用。。 参考：https://github.com/guoxiaoxu/SpringInActionPracticehttps://www.jianshu.com/p/8b95db8d7a1f]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记三]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16%2F</url>
    <content type="text"><![CDATA[第三章 高级装配本章内容： Spring profile 条件化的bean声明 自动装配与歧义性 bean的作用域 Spring表达式语言 本章中所介绍的技术也许你不会天天用到，但这并不意味着它们的价值会因此降低 3.1环境与profile在软件开发的时候，有一个很大的挑战就是将应用从一个环境迁移到另外一个环境。开发阶段中，某些环境相关的做法可能并不适合迁移到生产环境中，甚至即便迁移过去也无法工作。数据库配置、加密算法以及外部系统的集成是跨环境部署 在开发环境中，我们可能会使用切入式数据库，并预先加载测试数据。在Spring配置类中，可能会在一个带有@Bean注解的方法上使用EmbededDataBaseBuilder: 12345678@Bean(destroyMethod="shutdown")public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build();&#125; 这会创建一个类型为javax.sql.dataSource的bean，使用EmbededDatabaseBuilder会搭建一个切入式的Hypersonic数据库，它的模式(schema)定义izaischema.sql中，测试数据则是通过test-data.sql。 当你在开发环境中集成测试或者启动应用进行手动测试的时候非常有用。每次启动它的时候，都能让数据库处于一个给定的状态 尽管创建的DataSource非常适合于开发环境中，但是对于生产环境来说，这是一个糟糕的选择。在生产环境中你可能希望使用JNDI从容器中获取一个DataSource。 12345678@Beanpublic DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject();&#125; 通过JNDI获取的DataSource能够让容器决定如何创建这个DataSource，甚至包括切换为容器管理的连接池，即便如此，JNDI管理的Datasource更加适合与生产环境，对于简单的集成和开发测试来说，这会带来不必要的复杂性。 同时，在QA环境中，你可以选择完全不同的DataSource配置，可以配置为Commons DBCP连接池。 1234567891011@Bean(destroyMethod = "close")public DataSource dataSourceAO() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl("jdbc:h2:tcp://dbserver/～/test"); dataSource.setDriverClassName("org.h2.Driver"); dataSource.setUsername("guo"); dataSource.setPassword("guo"); dataSource.setInitialSize(20); dataSource.setMaxActive(30); return dataSource;&#125; 看起来简单的DataSource实际上并不是那么简单。它表现了在不同环境中某个bean会有所不同。我们必须有一种方式来配置DataSource，使其在每种环境下都会选择最为合适的配置。 其中一种方式就是在单独的配置类(或XML)中配置每个bean，然后在构造阶段确定要使用哪一个配置编译到可部署的环境中。这种方式的问题在于要为每种环境重新构建应用，当从开发阶段迁移到QA阶段时，重新构造也算不上什么大问题。但是，从QA阶段迁移到生产环境阶段时，重新构建可能引入BUG并且会在QA团队的成员中带来不安的情绪 3.1.1 配置profile beanSpring并不是在构造的时候做出这样的决策，而是到运行时再来确定，这样的结果就是在同一个部署单元能够适应所有的环境，没有必要重新构建. Spring引入了bean profile的功能，要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署到每个环境时，要确保对应的profile处于激活状态。 在Java配置中，可以使用@profile注解指定某个bean属于哪一个profile。 123456789101112@Configuration@Profile("dev")public class DataSourceConfig &#123; @Bean(destroyMethod="shutdown") public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build(); &#125;&#125; 需要注意的是@Profile注解应用到了类级别啥概念，它会告诉Spring这个配置来中的bean只有在dev profile激活时才创建。如果dev profile没有激活的话，那么带有@Bean注解的方法都会被忽略。 同时你可能需要一个适用于生产环境的配置 12345678910111213@Configuration@Profile("prod")public class DataSourceConfig &#123; @Bean public DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125;&#125; 在Spring3.1，只能在类级别上使用@Profile注解，不过在Spring3.2开始，你也可以在方法级别上使用@Profile注解，与@Bean注解一同使用，这样的话，就能将两个bean的声明放在同一个配置类中。 123456789101112131415161718192021222324252627282930313233343536/** * Created by guo on 22/2/2018. */@Configurationpublic class DataSourceConfig &#123; @Bean(destroyMethod="shutdown") @Profile("dev") public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build(); &#125; @Bean @Profile("prod") public DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125; @Bean(destroyMethod = "close") public DataSource dataSourceAO() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl("jdbc:h2:tcp://dbserver/～/test"); dataSource.setDriverClassName("org.h2.Driver"); dataSource.setUsername("guo"); dataSource.setPassword("guo"); dataSource.setInitialSize(20); dataSource.setMaxActive(30); return dataSource; &#125;&#125; 尽管每个DataSource bean 都被声明在一个profile中，并且只能当规定的profile激活时，相应的bean才会被创建，但是可能会有其他的bean并没有声明到一个给定的profile范围内。没有指定的profile的bean都会创建，与激活哪个profile没有关系 在XMl中配置profile我们也可以通过元素的profil属性，在XML中配置profile bean。 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ................................................................ &lt;beans profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; &lt;jdbc:script location="classpath:schema.sql" /&gt; &lt;jdbc:script location="classpath:test-data.sql" /&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile="qa"&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:url="jdbc:h2:tcp://dbserver/～/test" p:driverClassName="org.h2.Driver" p:username="guo" p:password="guo" p:initialSize="20" p:maxActive="39"/&gt; &lt;/beans&gt; &lt;beans profile="prod"&gt; &lt;jee:jndi-lookup id="dataSource" lazy-init="true" jndi-name="jdbc/myDatabase" resource-ref="true" proxy-interface="javax.sql.DataSource" /&gt; &lt;/beans&gt;&lt;/beans&gt; 除了所有的bean定义到同一个XML文件中，这种配置方式与定义单独的XML文件中实际效果是一样的。在运行时，只会创建一个bean，这取决于处于激活状态的是哪一个profile 3.1.2激活profileSpring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：sring.profiles.active和spring.profiles.default。如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active的话，那么Spring将会查找spring.profiles.default的值。如果两者都没有的话，那就没有激活的profile。 有多种方式来设置这两个属性 作为DispatcherServlet的初始化参数 作为Web的应用上下文参数 作为JNDI条目 作为环境变量 作为JVM的系统属性 在集成测试类上 作者喜欢的一种方式是使用DisPatcherServlet的参数将spring.profiles.default设置为开发环境，会在Servlet上下文中进行设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;taotao-rest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--为上下文设置默认的profile--&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- springmvc的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;taotao-rest&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+"-servlet.xml" --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--为Servlet设置默认的profile--&gt; &lt;init-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;taotao-rest&lt;/servlet-name&gt; &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 按照这种方式设置spring.profiles.default,所有开发人员能从版本控制软件中获得应用的程序源码，并使用开发环境的设置(如切入式数据库)运行代码而不需要任何额外的设置。 当应用程序部署到QA、生产、或其他环境中时，负责部署的人根据情况使用系统属性、环境变量、或JNDI设置spring.profiles.active即可。当设置spring.profiles.avtive后，至于spring.profiles.default设置成什么已经无所谓了：系统会优先使用spring.profiles.active中设置的profile 使用profi进行测试当运行集成测试时，通常会希望采用与生产环境相同的配置进行测试。但是，如果配置中的bean定义在了profile中，那么在测试运行时，我们就需要有一种方式来启动profile Spring提供了@ActiveProfiles注解，可以用它来指定运行测试时要激活哪个profile。在集成测试时，通常想要激活的是开发环境的profile。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import static org.junit.Assert.*;public class DataSourceConfigTest &#123; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = DataSourceConfig.class) @ActiveProfiles("dev") public static class DevDataSource&#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbededDatasourcr() &#123; JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query("select id, name from Things", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong("id") + ":" + rs.getString("name"); &#125; &#125;); assertEquals(1,results.size()); assertEquals("1:A",results.get(0)); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes=DataSourceConfig.class) @ActiveProfiles("prod") public static class ProductionDataSourceTest &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; // 应该是Null ，因为在JNDI中没有配置数据源 assertNull(dataSource); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:datasource-config.xml") @ActiveProfiles("dev") public static class DevDataSourceTest_XMLConfig &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; assertNotNull(dataSource); JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query("select id, name from Things", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong("id") + ":" + rs.getString("name"); &#125; &#125;); assertEquals(1, results.size()); assertEquals("1:A", results.get(0)); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:datasource-config.xml") @ActiveProfiles("prod") public static class ProductionDataSourceTest_XMLConfig &#123; @Autowired(required=false) private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; // 应该是Null ，因为在JNDI中没有配置数据源 assertNull(dataSource); &#125; &#125;&#125; 在条件化创建bean，Spring的profil机制是一种很好的方法，这里的条件要基于哪个profile处于激活状态来判断。Spring 4.0中提供了一种更为通用的机制来实现条件化的bean定义，这这种机制之中，条件化 完全由你来取定，Spring 4 和@Conditional注解定义条件化的bean。 3.2 条件化的bean假设你希望一个或所个bean只有在类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才创建，我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。 在Spring 4之前，很难实现这种级别的条件化配置，但是Spring 4.0 引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。 下面我们就根据环境变量中有没有magic变量来决定是否创建MagicBean: 1234567891011121314151617package com.cache.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;import com.cache.conditional.MagicExistsConditional;import com.cache.service.MagicBean;@Configurationpublic class ConditionalConfig &#123; @Bean @Conditional(MagicExistsConditional.class) //条件化的创建bean public MagicBean magicBean() &#123; return new MagicBean(); &#125;&#125; 可以看到MagicBean是否创建取决于@Conditional(MagicExistsConditional.class)中的情况，那么给@Conditional中的参数又是什么类型的呢，请看： 12345678910111213141516package com.cache.conditional;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class MagicExistsConditional implements Condition&#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment evn = context.getEnvironment(); return evn.containsProperty("magic"); &#125;&#125; 如你所见，设置给@Conditional的类可以是任意实现了Condition接口的的类型。而实现这个接口只需要实现matches方法，如果matches方法返回 true 就创建该 bean，如果返回 false 则不创建 bean，上例中我们就是根据环境变量中是否存在magic变量，来决定matches的返回值，进而决定是否创建MagicBean的。上例中我们只是使用到了ConditionContext的到Environment, 但Condition实现的考量因素可能会比这多的多。maches()方法会得到ConditionContext和AnnotatedTypeMetadata对象用来做决策。其实ConditionContext是一个接口： 1234567891011121314151617181920package org.springframework.context.annotation;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.core.env.Environment;import org.springframework.core.io.ResourceLoader;public interface ConditionContext &#123; BeanDefinitionRegistry getRegistry(); ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); ClassLoader getClassLoader();&#125; 通过 ConditionContext，我们可以做到如下几点： 方法 作用 getRegistry() 借助返回的 BeanDefinitionRegistry 检查 bean 的定义 getBeanFactory() 借助返回的 ConfigrableListableBeanFactory 检查是否存在，甚至检查 bean 的属性 getEnvironment() 借助返回 Environment 检查环境变量是否存在以及读取它的值是什么 getResourceLoader() 读取并检查它返回的 ResourceLoader 所加载的资源 getClassLoader() 借助它的返回的 ClassLoader 加载并检查类是否存在 AnnotatedTypeMetadata则能够让我们检查带有 @Bean 注解的方法上是否有其他注解： 1234567891011121314151617181920package org.springframework.core.type;import java.util.Map;import org.springframework.util.MultiValueMap;public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String annotationType); Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType); Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType, boolean classValuesAsString); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType, boolean classValuesAsString);&#125; 借助 isAnnotated() 方法，我们能够判断带有 @Bean 注解的方法是不是还有其他特定的注解。借助其他的方法，我们能够检查 @Bean 注解的方法上其他注解的属性。下面我们来看一下 Spring 4 使用 @Conditional 对 @Profile 的重构： 123456789101112131415161718192021package org.springframework.context.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.env.AbstractEnvironment;import org.springframework.core.env.ConfigurableEnvironment;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123; String[] value();&#125; @Profile的实现定义使用了，@Conditional注解和Condition接口，如下，ProfileCondition实现了Condition，并在matches方法中做出了是否创建@Profile的决策： 1234567891011121314151617181920212223242526package org.springframework.context.annotation;import org.springframework.core.type.AnnotatedTypeMetadata;import org.springframework.util.MultiValueMap;class ProfileCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if (context.getEnvironment() != null) &#123; MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) &#123; for (Object value : attrs.get("value")) &#123; if (context.getEnvironment().acceptsProfiles(((String[]) value))) &#123; return true; &#125; &#125; return false; &#125; &#125; return true; &#125;&#125; 我们可以看到，ProfileCondition通过AnnotatedTypeMetadata得到了用于 @Profile 注解的所有属性。借助该信息，他会明确地检查 value 属性，该属性包含了 bean 的 profile 名称。然后根据ConditionContext得到的Environment 来检查【借助acceptsProfiles()方法】该profile是否处于激活状态。 3.3 处理自动装配的歧义性之前，我们已经看到了如何使用自动装配让Spirng完全负责将bean引用注入到构造函数和属性中，自动装配能够提供很大的帮助，因为它会减少装配应用程序组件时所需的显示配置的数量。 不过仅有一个bean匹配所需的结果时，自动装配才是有效的。如果不仅一个bean能够匹配结果的话，这种歧义性会阻碍Spring自动装配属性、构造器或方法参数 为了阐述自动装配的歧义性，假设我们提供@Autowired注解标注了setDessert方法 1234@Autowiredpublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; Dessert是一个接口，并且有三个类实现了这个接口 12345678@Componentpublic class Cake implements Dessert &#123;...&#125;@Componentpublic class Cookies implements Dessert &#123; ...&#125;@Componentpublic class IceCream implements Dessert &#123;...&#125; 因为这三个实现均使用@Component注解，在组件进行扫描的时候，能够发现他们并将其创建为Spring应用上下文里面的bean，然后，当Spring试图自动装配的setDessert()中的Dessert参数时，它们并没有唯一、无歧义的可选值。 Spring此时别无选择，只好宣告失败并抛出异常，更准确的将。Spring会抛出：NoUniqueBeanDefinitionException 当Spring发生歧义时，Spring提供了多种可选方案来解决这样的问题。你可以将可选bean的某一个设为首选(primary)的bean，或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。 3.3.1 表示首选的bean在声明bean的时候，通过将一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。当遇到歧义性的时候，Spring将会使用首选的bean，而不是其它可选的bean。 假设冰激凌就是你最喜欢的甜点，在Spring中，可以通过@Primary来表达最喜欢的方案。@Primary能够与@Componnet组合用在组件扫描的bean上，也可以与@Bean组合用在Java配置的声明中。123@Component@Primarypublic class IceCream implements Dessert &#123;...&#125; 或者你通过JavaConfig显示配置地声明IceCream， 12345@Bean@Primarypublic Dessert IceCream() &#123; return new IceCream();&#125; 如果你喜欢使用XML配置bean的话，同样可以实现这样的功能。 123&lt;bean id="ceCream" class="com.guo.IceCream" primary="true"/&gt; 如果你标注了两个或者多个首选bean，那么就无法工作了。 123@Component@Primarypublic class Cake implements Dessert &#123; ...&#125; 就解决歧义性问题而言，限定符是一种更为强大的机制 3.2.2 限定自动装配的bean设置首选bean的局限性在于@Primary无法将可选方案的范围限定到唯一一个无歧义的选项中。它只能表示一个优先的可选方案。 Spring的限定符能够在所有可选的bean上进行缩小范围的操作，最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小范围。 @Qualifier注解是使用限定符的主要方式。它可以与@Autowired和Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。例如,我们确保要将IceCream注入到setDessert()之中。 12345@Autowired@Qualifier("iceCream")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; @Qualifier(“iceCream”)指向的是组件扫描时所创建的bean，并且这个bean是IceCream的实例。更具体一点：@Qualifier(“iceCream”)所引用的bean要具有String类型的“iceCream”作为限定符。没有没有则和ID一样。 基于默认的bean ID作为限定符是非常简单的，但这有可能会引入一些问题。如果你重构了IceCrean类，将其重名为“Gelato”的话，那此时会发生什么情况？如果是这样的话，bean的默认ID和默认的限定符会变为gelato，这就无法匹配setDessert()方法中的限定符，自动装配会失败。 这里的问题在于setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会导致限定符失败。 创建自定义的限定符我们可以为bean设置自己的限定符，而不是依赖于将ID作为限定符。在这里所需要做的就是在bean声明上加@Qualifier注解。 123@Component@Qualifier("cold")public class IceCream implements Dessert &#123;...&#125; 在这种情况下，cold限定符分配了IceCream bean。因为它没耦合类名，因此你可以随意重构IceCream，而不必担心会破坏自动装配。 在注入的地方，只要引用cold限定符就可以了 12345@Autowired@Qualifier("cold")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; 值得一提的是，当通过Java配置显式定义bean的时候i@Qualifier也可以与@Bean注解一起。 12345@Bean@Qualifierpublic Dessert dessert () &#123; return new IceCream();&#125; 当使用自定义的@Qualifier值时，最佳实践是为bean选择特征性或描述性的术语，而不是使用随意的名字。 使用自定义的限定符注释面向特性的限定符要比基于bean ID的限定符更好一些。但是如果多个bean都具备这个相同的特性的话，这种做法也会出现问题。 这里只有一个小问题：Java不允许在同一个条目上重复出现相同类型的多个注解。如果你试图这样做的话，编译器将会出错。 但是我们可以创建 自定义的注解，借助这样的注解来表达bean所希望限定的特性。这里需要做的就是创建一个注解，它本身要使用@Qualifier注解来标注。 1234@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface cold &#123;&#125; 当你不想用 @Qualifier注解的时候，可以类似的创建@Sort、@Crispy和@Fruity。通过在定义时添加@Qualifier注解。它就具有了@Qualifier注解的特性。 现在我们重新看一下IceCream，并为其添加@Cold和@Creamy注解 1234@Component@Clod@Creamypublic class IceCream implements Dessert &#123;...&#125; 类似的，Popsicle类可以添加@Cold和@Fruity注解 1234@Component@cold@Fruitypublic class Popsicle implements Dessert &#123;...&#125; 最终，在注入点，我们使用必要的限定符注解进行任意组合，从而将可选的范围缩小到只有一个bean满足需求。 为了得到IceCream bean 和 setDessert()方法可以这样使用注解： 123456@Autowired@Cold@Creamypublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; 通过声明自定义的限定符注解，我们可以同时使用多个限定符，不会再有Java编译器的限制或错误，与此同时，相对于原始的@Qualifier并借助于String类型来指定限定符，自定义的注解也是类型安全的。 在本节和前节中，我们讨论了几种通过自定义注解扩展Spring的方式，为了创建自定义的条件化注解，我们建议一个新的注解并在这个注解上添加了Conditional，为了创建自定义的限定符注解，我们创建一个新的注解并在这个注解上添加了@Qualifer。这种技术可以用到很多Spring注解中，从而能够将他们组合在一起形成特定目标的自定义注解。 3.4 bean的作用域默认情况下，Spring应用上下文中所有的bean都是作为以单例(singleton)的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多次，每次所注入的都是同一个bean。 在大多数情况下，单例bean是很理想的方案，初始化和垃圾回收对象实例所带来的成本只有一些小规模任务。在这些任务中，让对象保持无状态并且在应用中反复使用这些对象可能并不合理。 有时候可能发现，你所使用的类是异变的(mutable)，它们会保持一些状态，因此重复使用时不安全的。在这种情况下将class声明为单例的bean就不是什么好主意了。因为会污染对象，稍后重用的时候会出现意想不到的问题。 Spring定义了多种作用域可以基于这些作用域创建bean，包括： 单例(singleton):在整个应用中，只创建bean的一个实例 原型(prototype):每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例 会话(Session):在Web应用中，每个会话创建一个bean实例 请求(Request):在Web应用中，为每个请求创建一个bean实例。 单例是默认的作用域，但是正如之前所述，对于异变的类型，这并不适合。如果要选择其他作用域，要使用@Scope注解，它可以与@Component或@Bean一起使用。 如果你使用组件扫描来发现bean和生命bean，那么你可以在bean的类上使用@Scope注解，并将其声明为原型bean 1234@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class NotePad &#123;&#125; 在这里，使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常量设置了原型作用域。你当然可以使用@Scope(“prototype”),但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。 如果你想在JavaConfig中将NotePad声明为原型bean，那么可以组合使用@Scope和@Bean来指定所需的作用域 12345@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public NotePad notepad &#123; return new NotePad();&#125; 如果你想使用XMl来配置bean的话，你可以使用bean元素的scope属性来设置作用域123&lt;bean id="notepad" class="com.guo.myapp.NotePad" scope="prototype" 不管你使用哪种方式来声明作用域，每次注入或从Spirng应用上下文中检索该bean的时候，都会创建新的实例。这样导致的结果就是每次操作都能得到自己的NotePad实例。 3.4.1 使用会话和请求作用域在Web应用中，如果能够实例化在会话和请求范围内共享的bean，那将是非常有价值的事。例如：在典型的电子商务中，可能会有一个bean代表用户的购物车，如果这个购物车是单例的话，那么 将导致所有的用户都会像同一个购物车中添加商品。另一方面，如果购物车是原型作用域，那么在应用中某一个地方往购物车添加商品，在应用的另外一个地方可能就不可用了。因为这里注入的是另外一个原型作用域的购物车。就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大，要指定会话作用域，我们可以使用@Scope注解，它的使用方式和原型作用域是相同的。 1234@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public ShoppingCart cart() &#123;...&#125; 这里我们将value设置成WebapplicationConext.SCOPE.SESSION。这会告诉Spring为Web应用中的每个会话创建一个ShoppingCart。 需要注意跌是，@Scope同时还有另外一个ProxyMode属性，它被设置成了ScopeProxyMode.INTERFACES。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。在描述ProxyMode属性之前，我们先来看下proxyMode所解决问题的场景。 假设我们要将ShoppingCart bean 注入到单例StoreService bean的Setter方法中 1234567@Componentpublic class StoreService &#123;@Autowiredpublic void setShoppingCart(ShoppingCart shoppingCart) &#123; this.shoppingCart = shoppingCart;&#125;&#125; 因为StoreService是一个单例bean，会在Spring应用上下文加载的时候创建，当它创建的时候，Spring会试图将ShoppingCart注入到SetShoppingCart方法中，但是ShoppingCart是会话作用域的，此时并不存在。直到用户进入系统，创建了会话之后，才会出现ShoppingCart实例。 另外系统中将会有多个实例：每个用户一个。我们并不想让Spirng注入到某个固定的ShoppingCart实例到StoreService中，我们希望的是当StoreService处理购物车的时候，他所用使用的ShoppingCart实例恰好是当前会话所对应的一个。 Spring并不会将实例的ShoppingCart bean注入到StoreService，Spring会注入一个到ShoppingCart的代理。这个代理会暴露于ShoppingCart相同的方法。所以StoreService就会认为他是一个购物车。 但是当StoreService调用ShoppingCart的方法方法时，代理会对其进行解析，并将调用委托给会话作用域内真正的ShoppingCart。 现在我们带着这个 作用域的理解，讨论一下ProxyMode属性，如配置所示，proxyMode属性被设置成了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean 如果ShoppingCart是接口，而不是类的话，这是可以的，但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了，此时，它必须使用CGLIB来生成基于类的代理。所以，如果bean类型是具体的类的话，我们必须要将ProxyMode属性设置为ScopedProxyMOde.TARGET_CLASS.以此来表明要以生成目标类 扩展的方法创建代理。 尽管，我主要关注量会话作用域，但是请求作用域的bean会面临相同的装配问题，因此，请求作用域的bean应该也以作用域代理的方式进行注入 3.4.2 在XML中声明作用域代理如果你需要使用XML来声明会话或请求作用域的bean，那么就不能使用@Scope注解及其ProxyMode属性了元素能够设置bean的作用域，但是该怎样设置代理模式呢？ 要使用代理模式，我们需要使用Spring aop命名空间的一个新元素： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bean id="cart" class="com.guo.myapp.ShoppingCart" scope="session"&gt; &lt;aop:scoped-proxy/&gt;&lt;/bean&gt; aop:scoped-proxy是与@Scope注解的proxyMode属性功能相同的SpringXML配置元素，它会告诉Spring为bean创建一个作用域代理。默认情况下，它会使用CGLIB创建目标的代理。但是我们可以将proxy-target-class的属性设置为false，进而要求它生成基于接口的代理。 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bean id="cart" class="com.guo.myapp.ShoppingCart" scope="session"&gt; &lt;aop:scoped-proxy proxy-target-class = "false"/&gt;&lt;/bean&gt; 为了使用aop:scoped-proxy元素，必须在XML配置中声明Spring的aop命名空间： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; Spring高级配置的另一个可选方案：Spring表达式语言(Spring Expression Language) 3.5 运行时注入当讨论依赖注入的时候，我们通常讨论的是将一个bean引入到另一个bean的属性或构造器参数中。它通常来讲指的是将一个对象与另一个对象关联起来 但bean装配的另一个方面指的是将一个值注入到bean的属性或构造器参数中。 有时候硬编码是可行的，但有时候我们可能会希望避免硬编码。而是让这些值在运行时在确定，为了实现这些功能，Spring提供了运行时求值的方式： 属性占位符(Property placeholder) Spring表达式语言(SpEL) 这两种技术的用法是类似的，不过他们的目的和行为是有所差别的。 3.5.1 注入外部的值在Spring中，处理外部值的最简单方式就是声明属性源，并通过Spring的Enviroment来检索属性。 一个基本的Spring配置类，他使用外部的属性来装配BlankDisc bean。 12345678910111213@Configuration@PropertySource("classpath:/com/guo/soundsystem/app.properties")public class EnvironmentConfig &#123; @Autowired private Environment env; @Bean public BlankDisc blankDisc() &#123; return new BlankDisc( env.getProperty("disc.title"), env.getProperty("disc.artist")); &#125;&#125; @PropertySource 引用了类路径中一个名为app.properties的文件 这个属性文件加载到Spring的Environment中，同时blackDisc()方法中，会创建一个新的BlankDisc，它的构造参数是从属性文件中获取的，而这是通过getProperty()实现的。 深入学习Spirng的EnvironmentgetProperty() 方法并不是获取属性值的唯一方法，getProperty()方法有四个重载的变种形式 1234567891011121314151617181920package org.springframework.core.env;/** * Interface for resolving properties against any underlying source. * * @author Chris Beams * @since 3.1 * @see Environment * @see PropertySourcesPropertyResolver */public interface PropertyResolver &#123; String getProperty(String key); String getProperty(String key, String defaultValue); &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType); &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue); 前两种形式的getProperty()方法会返回String类型的值，但是你可以稍微对@Bean方法修改一些，这样在指定属性不存在的时候，会使用一个默认值。 123456@Beanpublic BlankDisc blankDisc() &#123; return new BlankDisc( env.getProperty("disc.title","guo go go"), env.getProperty("disc.artist","UU"));&#125; 剩下的两种getProperty()方法与前面的两种非常类似，但是他们不会将所有的值都视为String类型。假设你要获取的值所代表的连接池中所维持的连接数量，如果我们从属性文件中得到的是一个String类型的值，那么在使用之前还需要将其转化为Interge类型，但是如果使用重载的形式，就能非常便利的解决这个问题。 12int connectionCount = env.getProperty("db.connection.count",Interge.class,30); Environment还提供了几个与属性相关的方法，如果你在使用getProperty()方法的时候没有默认值，并且这个属性没有定义的话，获取到的值是null，如果你希望这个属性必须定义，那么可以使用getRequiredProperty()， 123456@Beanpublic BlankDisc blankDisc() &#123; return new BlankDisc( env.getRequiredProperty("disc.title"), env.getRequiredProperty("disc.artist"));&#125; 在这里，如果disc.title或者disc属性没有定义的话，将会抛出lllegalStateException异常 如果想要检查一个元素是否存在的话，可以调用Envrionment的contaiinsProperty()方法 1boolean titleeExists = env.containsProperty("disc.title"); 如果想将属性解析为类的话，可以使用getPropertyAsClass()方法 1Class&lt;CompactDisc&gt; cdClass = env.getPropertyAsClass("disc.class",CompactDisc.class); 除了属性的功能外，Environment还提供 一些方法来检查哪些Profile处于激活状态 12345678public interface Environment extends PropertyResolver &#123; String[] getActiveProfiles(); //返回激活profile名称的数组 String[] getDefaultProfiles(); //返回默认profile名称的数组 boolean acceptsProfiles(String... profiles); //如果environment支持给定的profile，则返回true&#125; 直接从Environment中检索属性是非常方便的，尤其是在Java配置中装配bean的时候，但是Spring也提供了通过占位符装配属性的方式，这些占位符的值会来源于一个属性源。 解析属性占位符Spring一直支持将属性定义到外部的属性配置文件中，并使用占位符值将其插入到Spring bean中， 123&lt;bean class="com.guo.soundsystem.BlankDisc" c:_0 = "$&#123;disc.title&#125;" c:_1 = "$&#123;disc.artist&#125;"/&gt; 按照这种方式，XML配置没有使用任何硬编码的值，它的值是从配置文件以外的一个源中解析得到的。 如果我们依赖于组件扫描和自动装配来创建和初始化应用组件的话，那么就没有占位符的配置文件了，在这种情况下，我们可以使用@Value注解，它的使用方式与@Autowired注解非常类似。 在BlankDisc类中，构造器可以改成如下显示： 123456public BlankDisc( @Value("$&#123;disc.title&#125;")String title, @Value("$&#123;disc.artist&#125;") String artist) &#123; this.title = title; this.artist = artist;&#125; 为了使用占位符，我们必须要配置一个PropertyPlaceholderConfigurer bean， 从Spring3.1开始，推荐使用propertySourcesPlaceholderConfigurer，因为它能够基于Spirnig Environment 及其属性源来加载占位符。 1234@Beanpublic static propertyplaceholderConfigurer placeholderConfigurer() &#123; return new propertyplaceholderConfigurer();&#125; 如果你想使用XML配置的话，Spring Context命名空间中的context:propertyplaceholder元素会为你生成 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;context:property-placeholder location="com/soundsystem/app.properties" /&gt;&lt;/beans&gt; 解析外部属性能够将值的处理推迟到运行时，但是它的关注点在于根据名称解析来自于Spring Environment和属性源的属性。而Spring表达式语言提供了一种更为通用的方式在运行时计算所要注入的值。 3.5.2 使用Spring表达式语言进行装配Spring3 引入了 Spring 表达式语言（Spring Expression Language，SpEL），它能够以一种强大和简介的方式将值装配到 bean 属性和构造器参数中。SpEL 拥有很多特性，包括： *使用 bean 的 ID 来引用 bean； *调用方法和访问对象的属性； *对值进行算数、关系和逻辑运算； *正则表达式匹配； *集合操作。 SpEL 不仅能够用在依赖注入中，在其他的一些方面也有很大用处。如 Spring Security 支持使用 SpEL 表达式定义安全限制工作。在 Spring MVC 应用中使用 Thymeleaf 模板作为视图的话，那么这些模板可以使用 SpEL 表达式引用模型数据。SpEL 表达式要放到”#{…}” 之中，这与属性占位符有些类似，属性占位符需要放到”${…}” 之中。下面是几个简单的 SpEL 样例，这些例子可以我们帮助编写自己的表达式。 SpEL样例需要了解的第一件事情就是SpEL表达式要放到“#{ … }”之中，这与属性占位符有些类 似，属性占位符需要放到“${ … }”之中。下面所展现的可能是最简单的SpEL表达式了： 1#&#123;1&#125; 表达式中只有字面量 1，当然它的计算结果就是 1 1#&#123;T(System).currentTimeMillis()&#125; ：它的最终结果是计算表达式的那一刻当前时间的毫秒数。T() 表达式会将 java.lang.System 视为 Java 中对应的类，因此可以调用其 static 修饰的 currentTimeMillis() 方法。 1#&#123;sgtPeppers.artist&#125; ：引用 ID 为 sgtPeppers 的 bean 的 artist 属性。 1#&#123;systemProperties[‘disc.title’]&#125; ：通过 systemProperties 对象引用系统属性。 在 bean 装配时使用 SpEL 表达式 如果通过组件扫描创建 bean 的话，在注入属性和构造器参数时，我们可以使用 @Value 注解，这与之前看到的属性占位符非常类似。不过，我们将用 SpEL 表达式替代属性占位符。例如，下面的样例展现了 BlankDisc，它会从系统属性中获取专辑名称和艺术家的名字： 12345public BlankDisc(@Value("#&#123;systemProperties['disc.title']&#125;") String title, @Value("#&#123;systemProperties['disc.artist']&#125;") String artist)&#123; this.title=title; this.artist=artist;&#125; 在 XML 配置中，你可以将 SpEL 表达式传入或的 value 属性中，或者将其作为 p - 命名空间或 c - 命名空间条目的值。例如，在如下 BlankDisc bean 的 XML 声明中，构造器参数就是通过 SpEL 表达式设置的： 1234&lt;bean id=&quot;sgtPeppers&quot; class=&quot;soundsystem.BlankDisc&quot; c:_title=&quot;#&#123;systemProperties[&apos;disc.title&apos;]&#125;&quot; c:_artist=&quot;#&#123;systemProperties[&apos;disc.artist&apos;]&#125;&quot; /&gt; 上面已经看过了几个简单的样例，也学习了如何将 SpEL 解析得到的值注入到 bean 中，下面将是 SpEL 所支持的基础表达式学习。 表示字面值SpEL 表达式可以用来表示各种类型的字面量，如：正数：#{1}、浮点数：#{3.14159}、String：#{‘Hello’}、布尔型：#{true}，用 SpEL 表示字面量并没有太大用处，但是要记住一点，更有意思的 SpEL 表达式是由更简单的表达式组成的，因此了解在 SpEL 中如何使用字面量还是很有用处的。但组合更为复杂的表达式时，你迟早会用到它们。 引用 bean、属性和方法SpEL 能做的另一件基础的侍寝就是通过 ID 引用其他的 bean。例如，你可以使用 SpEL 将一个 bean 装配到另一个 bean 的属性中，此时要使用 bean ID 作为 SpEL 表达式（在本例中，也就是 sgtPeppers）： 1#&#123;sgtPeppers&#125; 现在，假设我们想在一个表达式中引用 sgtPeppers 的 artist 属性： 1#&#123;sgtPeppers.artist&#125; 表达式主体的第一部分引用了一个 ID 为 sgtPeppers 的 bean，分隔符之后是对 artist 属性的引用。除了引用属性之外，我们还可以调用 bean 上的方法。例如，假设有另外一个 bean，它的 ID 为 artistSelector，我们可以在 SpEL 表达式中按照如下的方式来调用 bean 的 selectArtist() 方法： 1#&#123;artistSelector.selectArtist()&#125; 对于被调用方法的返回值来说，我们同样可以调用它的方法。如果 selectArtist() 方法返回的是一个 String，那么可以调用 toUpperCase() 将整个艺术家的名字改为大写字母形式： 1#&#123;artistSelector.selectArtist().toUpperCase()&#125; 如果 selectArtist() 的返回值不是 null 的话，这没有什么问题。为了避免出现 NullPointerException，我们可以使用类型安全的运算符： 1#&#123;artistSelector.selectArtist()?.toUpperCase()&#125; 与之前只是使用点号（.）来访问 toUpperCase()方法不同，现在我们使用了 “？.” 运算符。这个运算符能够在访问它右边的内容之前，确保它对应的元素不是 null。所以，如果 selectArtist()的返回值是 null 的话，那么 SpEL 将不会调用 toUpperCase()方法。表达式的返回值会是 null。 在表达式中使用类型如果要在 SpEL 中访问类作用域的方法和常量的话，要依赖 T() 这个关键的运算符。例如，为了在 SpEL 中表达 Java 的 Math 类，需要按照如下的方式使用 T() 运算符： 12#&#123;T(java.lang.Math).random&#125; //引用Math类的随机数方法#&#123;T(java.lang.Math).PI&#125; //引用Math类的常量 这里所示的T()运算符的结果会是一个Class对象，代表了java.lang.Math。如果需要 的话，我们甚至可以将其装配到一个Class类型的bean属性中。但是T()运算符的真正价值 在于它能够访问目标类型的静态方法和常量。 SpEL 运算符SpEL 提供了多个运算符，这些运算符可以用在 SpEL 表达式的值上。下表为用来操作表达式值的 SpEL 运算符： 下面这个例子作为使用上述运算符的一个简单样例： 1#&#123;2*T(java.lang.Math).PI*circle.radius&#125; 在这里 PI 的值乘以 2，然后再乘以 radius 属性的值，这个属性来源于 ID 为 circle 的 bean。实际上它计算了圆的周长。当使用 String 类型的值时，“+” 运算符执行的是连接操作，与在 Java 中是一样的： 1#&#123;disc.title+&apos;by&apos;+disc.artist&#125; SpEL 同时还提供了比较运算符，用来在表达式中对值进行比较。注意在上表中，比较运算符有两种形式：符号形式和文本形式。例如： 123#&#123;counter.total==100&#125;//等同于下面的表达式#&#123;counter.total eq 100&#125; SpEL 还提供了三元运算符（ternary），它与 Java 中的三元运算符非常类似。例如，如下的表达式会判断如果 scoreboard.score&gt;1000 的话，计算结果为 String 类型的 “Winner！”，否则，结果为 “Loser”： 1#&#123;scoreboard.score&gt;1000 ? &quot;Winner!&quot;:&quot;Loser&quot;&#125; 三元运算符的一个常见场景就是检查 null 值，并用一个默认值来代替 null。例如，如下的表达式会判断 disc.title 的值是不是 null，如果是 null 的话，那么表达式的计算结果就会是 “The Value Is Null”: 1#&#123;disc.title ?: &apos;The Value Is Null&apos;&#125; 这种表达式通常称为 Elvis 运算符。这个奇怪名称的来历是，当使用符号来表示表情时，问号看起来很像是猫王（Elvis Presley）的头发。 计算正则表达式当处理文本时，又是检查文本是否匹配某种模式是非常有用的。SpEL 通过 matches 运算符支持表达式中的模式匹配。matches 运算符对 String 类型的文本（作为左边参数）应用正则表达式（作为右边参数）。matches 的运算结果会返回一个 Boolean 类型的值：如果与正则表达式相匹配，则返回 true，否则返回 false。加入我们想判断一个字符是否包含有效的邮件地址。在这个场景下，我们可以使用 matches 运算符，如下所示： 1#&#123;admin.email matches &apos;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-+\\.com]&apos;&#125; 计算集合SpEL 中最令人旌旗的一些技巧是与集合和数组有关的。最简单的事情可能就是引用列表中的一个元素了。 1#&#123;jukebox.songs[4].title&#125; 这个表达式会计算 songs 集合汇总第五个元素的 title 属性，这个集合来源于 ID 为 jukebox bean。SpEL 还提供了查询运算符（.?[])，它会用来对集合进行过滤，得到集合的一个子集。作为阐述的样例，假设你希望得到 jukebox 中 artist 属性为 Aerosmith 的所有歌曲。如下的表单时就使用查询运算符得到了结果： 1#&#123;jukebox.songs.?[artist eq &apos;Aeronsmith&apos;]&#125; 可以看到，选择运算符在它的方括号中接收另一个表达式。SpEL 还提供了另外两个查询运算符：”.^[]“和”.$[]“，它们分别用来在集合中查询第一个匹配项和最后一个匹配项。例如，下面的表达式会查找列表中第一个 artist 属性为 Aerosmith 的歌曲： 1#&#123;jukebox.songs.^[artist eq &apos;Aerosmith&apos;]&#125; 最后 SpEL 还提供了投影运算符（.![]），它会从集合的每个成员中选择特定的属性放到另外一个集合中。作为样例，假设我们不想要歌曲对象的集合，而是所有歌曲名称的集合。如下的表达式会将 title 属性投影到一个新的 String 类型的集合中： 1#&#123;jukebox.songs.![title]&#125; 实际上，投影操作可以与其他任意的 SpEL 运算符一起使用。比如，我们可以使用如下的表达式获得 Aerosmith 所有歌曲的名称列表： 1#&#123;jukebox.songs.?[artist eq &apos;Aerosmith&apos;].![title]&#125; 我们所介绍的只是 SpEL 功能的一个皮毛，但已经能够让我们对 SpEL 有一个大致的了解了，当需要用到的时候再去深入学习。在动态注入值到 Spring Bean 时，SpEL 是一种很便利和强大的方式。我们又时会忍不住编写很复杂的表达式。但需要注意的是，不要让你的表达式太智能了。你的表达式越智能，对它的测试就越重要。SpEL 毕竟只是 String 类型的值，可能测试起来很困难。鉴于这一点，我建议尽可能让表达式保持简洁，这样测试不会是什么大问题。 3.6 小节1、学习了Spring profile，解决了Spring bean 要跨各种部署环境的通用问题。Profile bean 是在运行时条件化创建bean的一种方式，但在Spring4中提供了@Conditional注解和SpringCondition接口的实现。 2、解决两种自动装配歧义的方法，首选bean以及限定符。 3、Spring嫩那个狗让bean以单例，原型、会话、请求作用域的方式来创建。 4、简单的学习了SpEl，它能够在运行时计算要注入的bean属性的值。 依赖注入能够将组件以及协作的其他组件解耦，AOP有利于将应用组件与跨多个组件的任务进行解耦。 参考：https://github.com/guoxiaoxu/SpringInActionPracticehttps://www.jianshu.com/p/850c2a2a7a6b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记二]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-2%2F</url>
    <content type="text"><![CDATA[Spring 之旅第 2 章 Spring之旅装配Bean本章内容： 声明bean 构造器注入和Setter方法注入 装配bean 控制bean的创建和销毁 在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。创建应用对象之间的协作关系的行为通常称为装配(wiring),这就是依赖注入的本质。 2.1 Spring配置的可选方案Spring容器负责创建应用程序中的bean，并通过DI来协调这些对象之间的关系。你只需要告诉Spring要创建那些bean，并且如何组织在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制： XML中进行显示配置 在Java中进行显示配置 隐式的bean发现机制自动装配 建议使用：自动装配机制，显示配置越少越好。当你必须显示配置时，推荐使用类型安全并且比XML更加强大的JavaConfig。最后只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应用使用XML 2.2 自动化装配BeanSpring从两个角度来实现自动化装配： 组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的bean 自动装配(autowiring):Spirng自动满足bean之间的依赖 组件扫描和自动装配组合在一起就能发挥出强大的威力，他们能够将你的显示配置降低到最少。 2.2.1 创建被发现的beanCD为我们阐述了DI是如何运行提供了一个很好的样例，如果你不讲CD插入(注入)到CD播放器中，那么CD播放器其实没有太大的用处。CD播放器依赖于CD才能完成他的使命 程序2.1 123public interface CompactDisc &#123; void play();&#125; CompactDisc的具体内容不重要，重要的是你将其定义为一个接口，作为接口，它定义了CD播放器对一盘CD所能进行的操作。它将CD播放器的任意实现与CD本身耦合降低到了最小的程度 程序2.2 123456789101112/** * Created by guo on 21/2/2018. */@Component //表明该类会作为组件类public class SgtPeppers implements CompactDisc &#123; private String title = "sgt. pepper lonely Hearts Club Band"; private String artist = "The Beatles"; @Override public void play() &#123; System.out.println("Playing" + title + "by" + artist); &#125;&#125; SgtPeppers类上使用了@Component注解，这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。没有必要显示配置他。不过组件扫描默认是不开启的，需要显示配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean。 程序2.3 1234@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125; 类CDPlayConfig通过Java代码定义了Spring的装配规则。@ComPonentScan注解可以能够在Spring中启动组件扫描。如果没有其他配置，@ComponentScan默认会扫描与配置类相同的包。Spring将会扫描这个包以及这个包下所有的子包。查找带有@Component注解的类。这样就能发现CompactDisc，并且会在Spring中自动创建一个bean。 使用XMl来启用组件扫描的话，可以使用Spring context命名空间的context:component-scan元素， 程序2.4 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"..... &lt;context:component-scan base-package="com.guo.soundsystem" /&gt;&lt;/beans&gt; 尽管我们可以通过XMl的方案来启用组件扫描，但是在后面的讨论中，更多的还是会使用基于Java的配置。 为了测试组件扫描功能 创建一个简单的JUnit测试，它会创建Spring上下文，并判断CompactDisc是不是真的创建出来了。 程序2.5 123456789101112131415161718192021222324package com.guo.soundsystem;import com.guo.soundsystem.CDPlayerConfig;import com.guo.soundsystem.CompactDisc;import static org.junit.Assert.*; //这里使用了静态导入import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayConfig.class)public class CDPlayTest &#123; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull() &#123; assertNotNull(cd); &#125;&#125; CDPlayerTest使用了Spring的SpringJUnitClassRunner，以便在测试开始的时候自动创建Spring的上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置.带有@Autowired注解，以便将CompactDisc bean注入到测试代码中，最后断言cd属性不为null，就意味着Spirng能够发现CompactDisc类，自动在Spring应用上下文中将其创建为bean并将其注入到测试代码中。 2.2.2 为组件扫描的bean命名Spring应用上下文中所有bean都会给定一个ID。尽管没有明确为SgtPeppers bean 设置ID，但Spring会根据类名为其指定一个ID，这个ID所给定的ID为sgtPeppers，也就是将类名的第一个字母变为小写。 如果想设置不同的ID，所需要做的就是将期望的ID作为值传递给@Component注解 1234@COmponent("lonelyHeartsClub")public class SgtPeppers implements CompactDisc &#123; ...&#125; 还有另外一种为bean命名的方式，这种方式不使用@Component注解，而是使用Java依赖注入规范(Java Dependency Injection) 中所提供的@Named注解为bean设置ID： 12345import javax.inject.Named@Named("lonelyHeartsClub")public class SgtPeppers implements CompactDisc &#123; ...&#125; Spring支持将@named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，他们是可以互相替换的。 《Spring 实战》作者更喜欢@Component注解，而对于@Named。。。感觉名字起的很不好 2.2.3 设置组件扫描的基础包到目前为止，我们没有为@ComponentScan设置任何属性，这意味着，按照默认规则，它会以配置类所在的包作为基础包(base package) 来 扫描组件，有一个原因会促使我们明确的设置基础包，那就是我们要将配置类放在单独的包中，使其与其他应用代码区分开来。 为了指定不同的基础包，你所需要做的就是在@ComponentScan的Value属性中指明包的名称123@Configuration@Componentscan("com.guo.soundsystem")public class CDPlayerConfig&#123;&#125; 如果你想更加清晰的表明你所设置的是基础包，那么你可以通过basePackages属性来进行设置123@Configuration@Componentscan(basePackages="com.guo.soundsystem")public class CDPlayerConfig&#123;&#125; @basePackages属性使用的是复数形式，以为这可以设置多个基础包，只需要将basePackages属性设置为要扫描包的一个数组就可以123@Configuration@Componentscan(basePackages=&#123;"com.guo.soundsystem","com.guo.video"&#125;)public class CDPlayerConfig&#123;&#125; 在上面所有的例子中，所设置的基础包都是以String类型表示的，作者认为这是可以的，但是这种方式是类型不安全的，如果你要重构代码的话，那么你所指定的基础包可能就会出现错误。 除了将包设置为简单的String类型之外，@ComponentScan还提供了另外一种方式，那就是将其设置为包中所包含的类或接口 123@Configuration@Componentscan(basePackageClasses=&#123;CDPlayer.class,DVDPlayer.class&#125;)public class CDPlayerConfig&#123;&#125; 尽管在样例中，为basePackageClasses设置的是组件类，但是可以考虑在包中创建一个用来扫描的空标记接口。通过标记接口的方式，你依然能够保持对重构友好的接口的引用，但是可以避免引用任何实际的应用程序代码。 在你的应用程序中，如果所有的对象都是独立的，彼此之间没有任何依赖，就像SgtPeppers bean 这样，那么你需要的可能就是组件扫描而已。但是很多对象会依赖其他的对象才能完成任务。这样的话我们就需要有一种方式能够将组件扫描到的bean和他们的依赖装配在一起：自动装配 2.2.4 通过为bean添加注解实现自动装配自动装配就是让Spring自动满足bean依赖的一种方法，在满足的依赖的过程中，会在Spring应用上下文寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以将可以借助于Spring提供的@Autowired注解。 123456789101112@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; @Override public void play() &#123; cd.play(); &#125;&#125; 在构造器上添加了@Autowired注解，这表明当Spring创建CDPlayer bean时，会通过这个构造器来实例化并且传入一个可设置给CompactDisc类型的bean @Autowired注解不仅可以用于构造器上，还能用在属性Setter方法上， 1234@Autowiredpublic void setCompactDisc(CompactDisc cd)｛ this.cd = cd;｝ 在Spring初始化bean之后，它会尽可能去满足bean的依赖，依赖是通过带有@Autowired注解的方法进行生命的， 实际上，Setter方法并没有什么特殊之处。@Autowired可以用在类的任何方法上，1234@Autowiredpublic void insertDisc(CompactDisc cd)｛ this.cd = cd;｝ 不管是构造器、Setter方法还是其他方法，Spring购汇尝试满足方法参数上所申明的依赖。假如有且只有一个满足需求依赖的话，那么这个bean将会被装配进来， 如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常，为了避免异常的出现，你可以将@Autowired的required属性设置为false 1234@Autowired(required=false)public CDPlayer(CompactDisc cd) &#123; this.cd = cd;&#125; 将required设置为false时，Spring会尝试执行自动装配，但如果没有匹配的bean，Spring将会让这个bean处于未装配的状态，需要谨慎对待，如果你的代码中没有进行null检查的话，这个处于未装配的属性可能会出现NullPointerException。 如果有多个bean满足依赖关系时，Spirng将会抛出异常，表明没有明确指定要选择安格bean进行装配。 @ Autowired是Spring特有的注解，如果你不喜欢在代码中使用@Autowired，那么你可以考虑使用@Inject 123456789101112@Namedpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Inject public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; @Override public void play() &#123; cd.play(); &#125;&#125; @Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解，在Spring自动装配中，Spirng同时支持@Inject和@Autowired，作者没有特别的偏向性。根据自己的情况，选择合适自己的，推荐使用@Autowired。 2.2.5 验证自动装配1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest &#123; @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Autowired private MediaPlayer player; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull() &#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals( "Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n", log.getLog()); &#125;&#125; 在测试代码中使用System.out.println()是稍微有些棘手的是，该样例中使用了StandardOutputStreamLog，这是来源于System Rules 库的一个JUnit规则，该规则能够基于控制台的输出编写断言。 2.3通过Java代码装配bean尽管在很多常见喜爱通过组件扫描和自动装配实现了Spring的自动装配是更为推荐的方式，但有时候自动化配置的方案是行不通的，因此需要明确配置Spring.比如你将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的。 在这种情况下，你必须使用显示装配方式，在进行显示装配的时候，有两种方案可以选择。Java和XML。 作者认为:在进行显示配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好 因为它是Java代码，就像应用程序中的其他代码一样。 同时，JavaConfig与其他的Java代码由有所区别，在概念上，他与应用程序中的业务逻辑和领域代码是不同的。JavaConfig是配置代码。这意着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码中。通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。 2.3.1 创建配置类。12345678import org.springframework.context.annotation.Configuration;/** * Created by guo on 21/2/2018. */@Configurationpublic class CDPlayerConfig &#123;&#125; 创建JavaConfig类的关键点在于为其添加@Configuration注解，表明该类是一个配置类。该类应该包含在Spring应用上下文中如何创建bean的细节 尽管我们可以同时使用组件扫描和显示配置，但在本节中更关注显示配置，因此将CDPlayerConfig中的@ComponentScan注解移除了。此时在运行会抛出org.springframework.beans.factory.BeanCreationException: Error creating bean with name异常。测试希望被注入的CDPlayer和CompactDisc，但这些bean根本没有创建，因为组件扫描不会发现它们。 2.3.2 声明简单的bean要在JavaConfig中声明bean，需要编写一个方法，这个方法会创建锁需要类型的实例，然后给这个方法添加@Bean注解。 1234567@Configurationpublic class CDPlayerConfig &#123; @Bean public CompactDisc sgtPeppers() &#123; return new SgtPeppers(); &#125;&#125; @Bean注解会告诉Spirng这个方法将返回一个对象，该对象要注册为Spring应用上下文中的bean，方法中最终产生了bean实例的逻辑。 默认情况下，bean的ID与带有@Bean注解的方法名是一样的，如果你想重命名该方面，也可以通过name属性指定一个不同的名字 1234567@Configurationpublic class CDPlayerConfig &#123; @Bean(name="lonelyHeartsClub") public CompactDisc sgtPeppers() &#123; return new SgtPeppers(); &#125;&#125; 在一组CD中随机选择一个CompactDisc来播放 12345678910111213@Beanpublic CompactDisc randomBeatlesCD() &#123; int choice = (int)Math.foloor(Math.random() * 4); if (choice == 0) &#123; return new SgtPeppers(); &#125;else if (choice == 1) &#123; return new WhiteAlbum(); &#125;else if (choice == 2) &#123; new HardDaysNight(); &#125;else &#123; return new Revolver(); &#125;&#125; 2.3.3 借助JavaConfig实现注入在JavaConfig中最简单方式就是引用创建bean的方法，1234@Beanpublic CDPlayer cdPlayer() &#123; return new CDPlayer(sgtPeppers);&#125; cdPlayer()方法相sgtPepper()方法一样，同样使用了@Bean注解，表明这个方法会创建一个bean实例并嫁将其注入到Spring应用上下文中。所创建的bean ID为cdPlayer，与方法名字相同。 通过调用方法来引用bean的方式有点令人困惑，其实还有一种理解起来更为简单的方式 1234@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc);&#125; 在这里cdPlayer方法请求一个compactDisc作为参数，当Spring调用cdPlayer创建的CDPlayer bean 时，它会自动装配一个CompactDisc到配置方法中，然后，方法体就可以按照合适的方式来使用它。借助于这种技术，cdPlayer也可以将CompactDisc注入到CDPlayer的构造器中，而不用明确引用CompactDisc的@Bean方法。 通过这种方式引用其他的bean是最佳的选择。因为它不会要求将CompactDisc申明到同一个配置类中。实际上它可以通过组件扫描能够自动发现或者通过XML来进行配置。你可以将配置分散到多个配置类、XML文件以及自动扫描和装配的bean中，只要功能完整即可。 另外需要提醒的是，我们在这里使用CDPlayer的构造器实现了DI功能，但是我们完全可以采用其他风格的DI配置，比如你想通过Setter方法来注入CompactDisc的话，可以这样做 123456@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) &#123; CDPlayer cdPlayer new CDPlayer(compactDisc); cdPlayer.setCompactDisc(compactDisc); return cdPlayer;&#125; 再次强调一遍，带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例，构造器和Setter方法只是@Bean方法的两个简单样例。这里存在的可能性仅仅受到了Java语言的限制。 2.4 通过XML装配bean（不推荐使用）在Spring刚刚出现的时候，XMl是描述配置的主要方式。在Spring的名义下，我们创建了无数行XML代码。在一定程度上，Spring成为了XMl配置的同义词。现在需要明确的是XML不再是配置Spring的唯一可选方案。Spring现在有了强大的自动配置和基于Java的配置，Xml不应该在是你的第一选择了。 本节的内容只是用来帮助你维护已有的XML配置，在完成新的Spring工作时，希望你会使用自动化配置和Java配置 2.4.1 创建XML配置规范在使用XMl为Spring装配bean之前你需要创建一个新的配置规范。在使用JavaConfig的时候，你需要创建一个带有@Configuration注解的类，而在XML配置中，需要创建一个XMl文件，并且要以元素为根 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- configuration details go here --&gt;&lt;/beans&gt; 已经有一个合法的Spring XMl配置文件。不过它是一个没有任何用处的配置，因为它没有申明任何bean。为了给予它生命，重新创建一下CD样例，只不过这次选择XML配置，而不是使用JavaConfig和自动化装配。 2.4.2 声明一个简单的bean要在基于XML的Spring中声明一个bean，需要使用Spring-beans模式中的另一个元素 类似于JavaConfig中的@Bean注解。 1&lt;bean class="com.guo.soundsystem.SgtPeppers"/&gt; 这里声明了一个简单的bean，创建这个bean的类通过class属性来指定的并且要使用全限定类名。 因为没有明确给Id，所以这个bean将要根据全限定名来进行命名。 尽管自动化的bean命名方式非常方便，但如果你稍后需要引用它的话，那么自动产生的名字就没有多大用处了。因此，通常来讲更好的办法就是借助于id属性。为每个bean设置一个你自己选择的名字 1&lt;bean id="compactDisc" class="com.guo.soundsystem.SgtPeppers"/&gt; 第一件需要注意的事情就是你不在需要直接负责创建SgtPeppers的实例，在基于JavaConfig的配置中，我们需要这样做。当Spring发现这个元素时，它会调用SgtPeppers的默认构造器来创建bean。在Xml配置中，bean的创建显得更加被动，不过，它它没有javaConfig那样强大，在JavaConfig中，你可以通过任何可以想象到的方法来创建bean实例。 另一个需要注意的是，在这个简单的声明中，我们将bean的类型以字符串的形式设置在了 class属性中。谁能确保设置给Class属性的值是真正的类呢？Spring的XMl配置并不能从编译器的类型检查张宏收益，即便它所引用的是实际的类型，如果你重命名了会发生什么呢？ 以上介绍的只是JavaConfig要优于XML配置的部分原因。在你的应用选择配置风格时，要记住XMl配置的这些缺点。 2.4.3 借助于构造器注入 初始化 bean在Spring XMl配置中，只有一种声明bean的方式，使用元素并制定calss属性，Sprng会从这里获取必要的信息来创建bean。 在XMl中声明DI时，会有多种可选的配置风格和方案。具体到构造器注入，有两种基本的配置方案可供选择 元素 使用Spring3.0所引入的c-命名空间 两者的区别在很大程度就是是否冗余长烦琐。元素比使用c-命名空间会更加冗长。从而导致XMl更加难以读懂。另外有些事情可以做到，但是使用c-命名空间却无法实现。 构造器注入Bean引用123&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer"&gt; &lt;constructor-arg ref="compactDisc"/&gt;&lt;/bean&gt; 当Spring遇到这个bean元素时，它会创建一个CDPlayer实例 。元素会告知Spring要将一个ID为compactDisc的bean引用传递到CDPlayer的构造器中 作为替代方案，你也可以使用Spring的c-命名空间。c-命名空间实在Spring3.0中引入的，它是在XMl中更为简单的描述构造器参数的方式，要使用他的话，必须在XMl的顶部声明其模式 ， 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 在c-命名空间和模式声明之后，就可以使用它来声明构造器参数了 12&lt;bean id="compactDisc" class="com.guo.soundsystem.cdPlayer" c:cd-ref="compactDisc" /&gt; 将字面量注入到构造器中迄今为止，我们所作的DI通常指的都是类型的装配—也就是将对象的引用装配到依赖于他的其他对象之中。而有些时候我们需要做的只是将一个字面量值来配置对象，为了阐述这一点，假设你要创建CompactDisc的一个新实现 。 1234567891011121314151617/** * Created by guo on 21/2/2018. */public class BlankDisc implements CompactDisc &#123; private String title; private String artist; public BlankDisc(String title, String artist) &#123; this.title = title; this.artist = artist; &#125; @Override public void play() &#123; System.out.println("Playing " + title + " by " + artist); &#125;&#125; 在SgtPeppers中，唱片名称和艺术家的名字都是硬编码的。但是这个CompactDisc实现与之不同，它更加灵活。像现实中的空磁盘一样，它可以设置成你想要的艺术家和唱片名。 1234&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;constructor-arg value="The Beatles"/&gt;&lt;/bean&gt; 使用value属性，通过该属性表明给定的值要以字面量的形式注入到构造器中。 装配集合如果使用CompactDisc为真正的CD建模，那么它也应该有磁道列表的概念。 123456789101112&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;constructor-arg value="The Beatles"/&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;11&lt;/value&gt; &lt;value&gt;22&lt;/value&gt; &lt;value&gt;33&lt;/value&gt; &lt;value&gt;44&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 其中，元素是的子元素。这表明一个包含值的列表将会传递给构造器中，其中元素用来指定列表中的每一个元素。 与之类似的，我们也可以使用元素替代,实现bean引用列表的装配 和元素区别不大，其中重要的不同在于当Spring创建要装配集合的时候，所创建的是java.util.Set还是java.util.List。如果是Set的话，所有重复元素会被忽略掉，存放顺序也不会得到保证。不过无论在哪中情况下，和都可以用来装配List、Set甚至数组。 在装配集合方面，比c-命名空间的属性更有优势。使用c-命名空间的属性却无法实现装配集合的功能 与其不厌其烦的花时间讲述如何使用XML进行 构造器注入，还不如看一下如何使用XML来装配属性 2.4.4 设置属性到目前为止，CDPlayer和BlanckDisc类完全是通过构造器注入的，没有使用属性的Setter方法，接下来，我们就看看如何使用Sprng XML配置实现属性注入， 该选择构造器注入还是熟悉注入呢？作为一个通用的规则，我倾向于对强依赖使用构造器注入，而对可选性的依赖使用属性注入。 对于CDPlayer来讲，它对CompactDisc是强依赖还是可选依赖可能会有些争议。 Spring在创建bean的时候不会有任何问题，但是CDPlayTest会因为出现NullPointException而导致测试失败，因为我们并没有出入CDPlayer的compactDisc属性。不过按照下面的方式修改XML，就能解决该问题 123&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer"&gt; &lt;propert name="compactDisc" ref="compactDisc"/&gt;&lt;/bean&gt; 元素为属性的Setter方法所提供的功能与元素为构造器所提供的功能是一样的。在本例中，它它引用了ID为compactDisc的bean，(通过ref属性)，并将其注入到compactDisc属性中(通过setCompactDisc()方法)。 Spring为元素通过了c-命名空间作为替代方案，与之类似的，Spring提供了更加简洁的p-命名空间，作为元素的替代方案。为了启用p-，必须在XML文件织哦你与其他命名空间一起对其进行声明。 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 我们可以使用p-命名空间，按照以下的方式装配compactDisc属性 12&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" p:compactDisc-ref="compactDisc"/&gt; 首先属性的名字使用了”p：”前缀，表明我们设置的是一个属性。接下来就要注入属性名。 将字面量注入到属性中123456789101112&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;propert value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;propert value="The Beatles"/&gt; &lt;propert&gt; &lt;list&gt; &lt;value&gt;11&lt;/value&gt; &lt;value&gt;22&lt;/value&gt; &lt;value&gt;33&lt;/value&gt; &lt;value&gt;44&lt;/value&gt; &lt;/list&gt; &lt;/propert&gt;&lt;/bean&gt; 需要注意的是**我们不能使用p-命名空间来装配集合，没有遍历的方式使用p-命名空间 util-命名空间所提供的功能之一就是util:list元素它会创建一个列表的bean，借助util:list，我们可以将磁道列表转移到BlackDisc bean之外。并将其声明到单独的bean之中。 123456789101112131415&lt;util:list id="trackList"&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She's Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I'm Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt;&lt;/util:list&gt; 在需要的时候，你可能会用到util-命名空间中的部分成员。 Spring util-命名空间中的元素 util:constant :引用某个类型的public static 域，并将其暴露为bean util:list:创建一个java.util.List类型的bean，其中包含值和引用 util:map :创建一个java.util.Map类型的bean，其中包含值或引用。 util:properties :创建一个java.util.properteis类型的bean。 util：set： 创建一个java.util.Set类型的bean，其中包含值或引用。 2.5导入和混合配置在典型的Spring应用中，我们可能同时使用自动化和显示配置。即便你更喜欢通过JavaConfig实现显示配置，但有时候XML确实最佳的方案。 幸好在Spring中，这些配置方案不是互斥的，你尽可以将JavaConfig的组件扫描和自动装配或XMl配置混合在一起。 关于混合配置，第一件事需要了解的就是在自动装配时，它并不在意要装配的bean来自哪里。自动装配的时候会考虑Spring容器中所有的bean，不管他在JavaConfig中还是在XMl中声明的还是通过组件扫描获取到的。 2.5.1 在JavaConfig中引用XML配置将设bean很多，所能实现的一种方案就是将BlankIDisc从CDPlayerConfig中拆分出来，定义到它自己的CDConfig中。 1234567@Configurationpublic class CDConfig &#123; @Bean public CompactDisc compactDisc () &#123; return new SgtPeppers(); &#125;&#125; compactDisc方法已经从CDPlayerConfig中移除了，我们需要有一种方式将这两个类组合在一起。一种方式就是在CDPlayerConfig中使用@Import注解导入CDConfig。 1234567891011/** * Created by guo on 21/2/2018. */@Configuration@Import(CDConfig.class)public class CDPlayerConfig &#123; @Bean public CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc); &#125;&#125; 或者采用一个更好的办法，也就是不再CDPlayerConfig中使用@Import，而是创建一个更高级别的SoundSystemConfig，在这个类中使用@Import将两个配置组合在一起： 本人：内心还在想什么好方法，确实是更好的办法。 1234@Configuration@Import(&#123;CDPlayerConfig.class,CDConfig.class&#125;)public class SoundSystemConfig &#123;&#125; 不管采用哪种方式，我们都将CDplayer的配置与BlankDisk的配置分开了。现在，我们假设(基于某种原因)希望通过XML来配置BlackDisc， 123456789101112131415&lt;bean id="compactDisc" class="com.guo.soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;!-- ...other tracks omitted for brevity... --&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 现在BlankDisc配置在了XML中，我们该如何让Spring同时加载它和其他基于Java的配置呢？ 答案是@ImportResource注解。假设BlankDisc定义在名为cd-config.xml的文件中，该文件位于根路径下，那么可以修改SoundSystemConfig让他使用@ImportResource注解 12345@Configuration@Import(CDPlayerConfig.class)@ImportResource("classpath:cd-config.xml")public class SoundSystemConfig &#123;&#125; 两个bean–配置在JavaConfig中的CDPlayer以及配置在XMl中BlankDisc — 都会被加载到Spring容器中，因为CDPlayere中带有@Bean注解的方法接受一个CompactDisc作为参数。因此BlankDisc将会被装配进来，此时与他是通过XML配置的没有任何关系。 让我们继续这个练习，但是这一次，我们需要在XMl中引用JavaConfig声明的bean 2.5.2 在XML配置中引用JavaConfig假设你正在使用Spring基于XML的配置，并且你已经意识到XML逐渐变得无法控制。 在JavaConfig配置中，我们已经展现了如何使用@Import和@ImportResource来拆分JavaConfig类，在XML中，我们可以使用import元素来拆分XML配置。 比如假设你希望将BlankDiscbean拆分到自己的配置文件中，该文件名为cd-config.xml. 1234&lt;import resource="cd-config.xml"/&gt;&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" c:cd-ref="compactDisc" /&gt; 现在假设不再将BlankDisc配置在XXMl中，而是将其配置到JavaConfig中，CDPlay继续配置在XML中， 为了将JavaConfig类导入到XMl配置中，我们可以这样声明bean： 1234&lt;bean class="com.guo.soundsystem.CDConfig"/&gt;&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" c:cd-ref="compactDisc" /&gt; 采用这样的方式，两种配置–其中一种使用XML描述，另一个使用Java描述—被组合在一起了。类似的，你还希望声明一个更高级被的层次的配置文件，这个文件不声明任何bean，只是负责将两个或 多个配置文件组合在一起。 123&lt;bean class="com.guo.soundsystem.CDConfig"/&gt;&lt;import resource="cdplayer-config.xml"/&gt; 不管使用XMl还是JavaConfig进行装配，我通常都会创建一个根配置，也就是这里展现的这样，这个配置文件会将两个或更多的装配类和/或XML文件组合起来。我也会在根配置中启用组件扫描(通过context:component-scan或@ComponentScan)，你会在本书中很多的例子中看到这种技术。 2.6 小节Spring的核心是Spring容器。容器负责管理应用中组件的生命周期，它会创建这些组件并保证他们的依赖能够得到满足，这样的话，组件才能完成预定的任务。 在本章中，我们看到了Spring中装配bean的三种方式：自动化装配、基于Java的显示配置、以及基于XML的显示配置。不管你采用什么方式，这些技术都描述了Spring应用中的组件以及这些组件之间的关系**。 我同时建议你尽可能使用自动化配置，以避免显示配置所带来的维护成本。但是，如果你确实需要显示的配置Spring的话，应该优先选择基于Java的配置，它比基于XML的配置更加强大、类型安全、并且易于重构。 在本书中的栗子中，当决定如何装配组件时，我都会遵循这样的指导意见。 因为依赖注入是Spring中非常重要的组成部分，所以本章中介绍的技术在本书中所有的地方都会用到。基于这些基础知识，下一章将会介绍一些更为高级的bean装配技术，这些技术能够让你更加充分地发挥Spring容器的威力 参考：https://github.com/guoxiaoxu/SpringInActionPractice]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记一]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15%2F</url>
    <content type="text"><![CDATA[Spring 之旅第 1 章 Spring之旅本章内容： Spring 的 bean 容器 介绍 Spring 的核心模块 更为强大的 Spring 生态系统 Spring 的新功能 1.1 简化 Java 开发为了降低 Java 开发的复杂性，Spring 采取了以下 4 种关键策略： 基于 POJO 的轻量级和最小入侵性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程： 通过切面和模板减少样板代码； 1.1.1 激发 POJO 的潜力尽管简单，但 POJO 一样可以拥有魔力，Spring 赋予 POJO 魔力的方式之一就是通过 DI 来装配它们。 1.1.2 依赖注入(DI,Dependenc Injection)依赖注入现在已经演变成一项复杂的编程技巧或设计模式的理念 按照传统的做法，每个对象负责管理与自己相互协作的对象的引用 (即它所依赖的对象)，这就会导致高度耦合和难以测试的代码。 程序1.2 1234567891011121314/** * damsel表示：少女 */public class DamselRescuingKnight implements Knight &#123; private RescueDamselQuest quest; public DamselRescuingKnight ( RescueDamselQuest quest) &#123; //与RescueDamselQuest紧耦合 this.quest = new RescueDamselQuest(); &#125; @Override public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; DamselRescueingKnight 在它的构造函数中自行创建了 RescueDamselQuest。这使得两者紧紧的耦合在一起。因此极大的限制了骑士执行探险的能力。在这样一个测试中 ，你必须保证当骑士 embarkOnQuest 方法被调用的时候，探险 embark 方法也要被调用。但是没有一个简单明了的方式能够测试。 通过 DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候设定，对象无需自行创建或管理他们的依赖关系，依赖关系将被自动注入到需要它们的对象中。 依赖注入会将所依赖的关系自动交给目标对象，而不是让对象自己去获取依赖 BraveKnight 足够灵活可以接受任何赋予他的探险任务。 程序1.3 1234567891011121314public class BraveKnight implements Knight &#123; public Quest quest; public BraveKnight(Quest quest&#123; //Quest被注入进来 this.quest = quest; &#125; @Override public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; 不同于之前的 DamselRescuingKnight，BraveKnight 没有自行创建探险任务，而是在构造的时候把探险任务作为构造参数传入。这是依赖注入的方式之一，即构造注入 (constructor injection). 需要注意的是，传入的探险类型是一个 Quest，也就是所有的探险任务都必须实现的一个接口。所以 BraveKnight 能够响应 RescueDamselQuest、SlayDragonQuest、MakeRoundTableRounderQuesst 等任意的 Quest 实现。 这里的要点是 BraveKnight 没有有特定的 Quest 实现发生耦合。对他来说，被要求挑战的探险任务只要实现了 Quest 接口，那么具体的是那种类型就无关紧要了。这就是 DI 带来最大的收益——松耦合。如果一个对象只通过接口 (而不是具体的实现或初始化过程) 来表明依赖关系，那么这种依赖就能够在对象本身毫不情况的情况下，用不同的具体实例进行替换。 对依赖进行替换的一个最常用方法就是在测试的时候使用 mock 实现。 程序1.4 123456789101112import static org.mockito.Mockito.*;public class BraveKnightTest &#123; @Test public void knightShouldEmbarkQuest() &#123; Quest mockQuest = mock(Quest.class); //创建mock Quest BraveKnight knight = new BraveKnight(mockQuest); //注入mock Quest； knight.embarkOnQuest(); verify(mockQuest,times(1)).embark(); &#125;&#125; 可以通过 mock 框架 Mockito 去创建一个 Quest 接口的 mock 实现。通过这个 mock 对象，就可以创建一个新的 BraveKnight 实例，并通过构造器注入到这个 mock Quest。当调用 embarkOnQUest 方法时，你可以要求 Mockito 框架验证 Quest 的 mock 实现的 embark 方法仅仅被调用了一次。 将 Quest 注入到 Knight 中 希望 BraveKnight 所进行的探险任务是杀死一只怪龙， 程序1.5 123456789public class SlayDragonQuest implements Quest &#123; private PrintStream stream; public SlayDragonQuest(PrintStream stream) &#123; this.stream = stream; &#125; @Override public void embark() &#123; stream.println("Embarking on quest to slay the dragon!!,顺便还可以学英语，一举两得。"); &#125; SlayDragonQuest 实现类 Quest 接口，这样它就适合注入到 BraveKnight 中了，与其他样例不同的是，SlayDragonQuest 没有使用 System.out.println();, 而是在构造方法中请求一个更为通用的 PrintStream。 创建应用组件之间协作的行为成为装配。Spring 有多种装配 Bean 的方式，采用 XML 是一种常用的方式。 knights.xml，该文件将 BraveKnight，SlayDragonQuest 和 PrintStream 装配到一起。 程序1.6 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="knight" class="guo.knights.BraveKnight"&gt; &lt;!--注入Quest bean--&gt; &lt;constructor-arg ref="quest"/&gt; &lt;/bean&gt; &lt;!--创建SlayDragonQuest--&gt; &lt;bean id="quest" class="guo.knights.SlayDragonQuest"&gt; &lt;constructor-arg value="#&#123;T(System).out&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在这里，BraveKnight 和 SlayDragonQuest 被声明为 Spring 中的 bean。就 BraveKnight bean 来讲，他在构造时传入对 SlayDragonQuest bean 的引用，将其作为构造器参数。同时，SlayDragonQuest bean 的声明使用了 Spring 表达式语言 (Spring Expression Language)，将 System.out(一个 PrintStream) 传入到了 SlayDragonQuest 的构造器中， 在 SpEL 中, 使用 T() 运算符会调用类作用域的方法和常量. 例如, 在 SpEL 中使用 Java 的 Math 类, 我们可以像下面的示例这样使用 T() 运算符： T(java.lang.Math) T() 运算符的结果会返回一个 java.lang.Math 类对象. Spring 提供了基于 Java 的配置可作为 XML 的替代方案。 程序1.7 12345678910111213141516171819202122import guo.knights.BraveKnight;import guo.knights.Knight;import guo.knights.Quest;import guo.knights.SlayDragonQuest;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Created by guo on 20/2/2018. */@Configurationpublic class KnightConfig &#123; @Bean public Knight knight() &#123; return new BraveKnight(quest()); &#125; @Bean public Quest quest() &#123; return new SlayDragonQuest(System.out); &#125;&#125; 不管使用的是基于 XML 的配置还是基于 Java 的配置，DI 所带来的收益都是相同的。尽管 BraveKnight 依赖于 Quest，但是它并不知道传递给它的是什么类型的 Quest，与之类似，SlayDragonQuest 依赖于 PrintStream，但是编译时，并不知道 PrintStream 长啥样子。只有 Spring 通过他的配置，能够了解这些组成部分是如何装配起来的。这样就可以在不改变 所依赖的类的情况下，修改依赖关系。 接下来，我们只需要装载 XML 配置文件，并把应用启动起来。 Spring 通过应用上下文 (Application context) 装载 bean 的定义，并把它们组装起来。Spring 应用上下文全权负责对象的创建个组装，Spring 自带了多种应用上下文的实现，他们之间的主要区别仅仅在于如何加载配置。 因为 knights.xml 中的 bean 是使用 XML 文件进行配置的，所以选择 ClassPathXmlApplicationContext 作为应用上下文相对是比较合适的。该类加载位于应用程序类路径下的一个或多个 Xml 配置文件。 程序1.8 12345678910111213public class KnightMain &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring/knights.xml"); //加载Sprinig应用上下文 Knight knight = context.getBean(Knight.class); //获取knight bean knight.embarkOnQuest(); //使用knight调用方法 context.close(); //关闭应用上下文 &#125;&#125; 这里的 main() 方法基于 knight.xml 文件创建了 spring 应用上下文。随后他调用该应用上下文获取一个 ID 为 knighht 的 bean。得到 Knighht 对象的引用后，只需要简单调用 embarkOnQuest 方法就可以执行所赋予的探险任务了。只有 knights.xml 知道哪个骑士执行力那种任务。 1.1.3 应用切面DI 能够让相互协作的软件组件保持松耦合，而面向切面编程 (aspect-oriented programming AOP) 允许你把遍布应用各处的功能分离出来形成可重用的组件。 面向切面编程往往被定义为促使软件系统实现关注点的分离一项技术, 系统由许多不同的组件组成，每个组件各负责一特定的功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理、和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中。这些系统通常被称为横切关注点。，因此他们会跨越系统多个组件。 AOP 能使这些服务模块化，并以声明的方式将它们应用到它们要影响的组件中去。所造成的结果就是这些组件会更加关注自身的业务，总之 AOP 能确保 POJO 的简单性。 我们可以把切面想象为覆盖在很多组件之上的一个外壳。应用是由哪些实现各自业务功能模块组成的，借助 AOP， 可以使用各种功能层去包裹核心业务层，, 这些层以声明的方式灵活的应用到系统中，你的核心应用甚至根本不知道他们的存在。这是一个非常强大的理念，可以将安全，事务，日志关注点与核心业务相分离。** 程序1.9 12345678910111213141516171819/** * Created by guo on 20/2/2018. * 咏游诗人，作为骑士的一个切面 */public class Minstrel &#123; private PrintStream stream; public Minstrel(PrintStream stream) &#123; this.stream = stream; &#125; public void singBeforeQuest() &#123; stream.println("Fa la la ,the Knight is so brabe"); //探险之前调用 &#125; public void singAfterQuest() &#123; stream.println("Tee hee hhe,the brave knight " + "did embark on a quest"); //探险之后调用 &#125;&#125; Minstrel 只有两个简单的方法的类，在骑士执行每一个探险任务之前，singBeforeQuest() 被调用；在骑士完成探险任务之后，singAfterQuest() 方法被调用。在这两种情况下，Minstrel 都会通过一个 PrintStream 类来歌颂骑士的事迹，这个类通过构造器注入进来。 但利用 AOP，你可以声明咏游诗人西部歌颂骑士的 探险事迹，而骑士本身不直接访问 Minstrel 的方法 要将 Minstrel 抽象为一个切面，你所需要做的事情就是在一个 Spring 配置文件中声明它，， 程序1.11 123456789101112131415&lt;bean id="minstrel" class="guo.knights.Minstrel"&gt; &lt;constructor-arg value="#&#123;T(System).out&#125;"/&gt; &lt;!--声明Minstrel bean--&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect ref="minstrel"&gt; &lt;aop:pointcut id="embark" expression="execution(* * .embarkOnQuest(..))"/&gt; &lt;!--定义切点--&gt; &lt;aop:before pointcut-ref="embark" method="singBeforeQuest"/&gt; &lt;!-- 声明前置通知--&gt; &lt;aop:after pointcut-ref="embark" method="singAfterQuest"/&gt; &lt;!-- 声明后置通知--&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 这里使用了 Spring 的 aop 配置命名空间把 Minstrel 声明为一个切面。 在这两种方式中，pointcut-ref 属性都引用列名为为 “embark” 的切入点，该切入点实在前面的元素中定义的，并配置 expression 属性来选择所应用的通知。表达式的语法采用的是 aspectJ 的切点表达式语言。 Minstrel 仍然是一个 POJO，没有任何代码表明它要被作为一个切面使用，其次最重要的是 Minstrel 可以被应用到 BraveKnight 中，而 BraveKnight 不需要显示的调用它，实际上，BraveKnight 完全不知道 MInstrel 的存在 1.1.4 小节作者已经为我们展示了 Spring 通过面向 POJO 编程、DI、切面、模板技术来简化 Java 开发中的复杂性。在这个工程中，展示了基于 XML 的配置文件中如何配置 bean 和切面，但这些文件是如何加载的呢？他们被加载到哪里呢？接下来让我们了解下 Spring 容器，这是应用中的所有 bean 所驻留的地方。 1.2 容纳你的Bean在基于Spring的应用中，你的应用对象存在于Spring容器(container)中.Spring负责创建对象，装配它，并管理它们的整个生命周期，从生存到死亡(new 到finalize())。 首先重要的是了解容纳对象的容器。理解容器将有助于理解对象是如何创建的。 容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件爱你之间的联系。这些对象更简单干净、更容易理解，更易于重用并且易于进行单元测试。 Spring容器并不只是只有一个，Spring自带了多个容器实现，可以归纳为两种不同的类型： Bean工厂。由org.springframework.beans.factory.BeanFactory接口定义的。是最简单的容器。 应用上下文 由org.springframework.context.applicationContext接口定义的。基于BeanFactory构建，并提供应用框架级别的服务，例如：从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听器。 应用上下文比Bean工厂更受欢迎。bean工厂对于大多数应用来说太低级了。 1.2.1使用应用上下文Spring自带了多种应用上下文： AnonotationConfigApplicationContext：从一个或多个基于Java的配置文件类中加载Spring应用上下文 AnnotationConfigWebApplicationContext：从一个或多个基于Java配置类加载SpringWeb应用上下文 ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源 FileSystemXmlapplicationContext：从文件系统下的一个或多个XMl配置文件中加载上下文定义 XmlWebapplicationContext：从web应用下的一个或多个XML配置文件中加载上下文定义 无论是从文件系统中装配应用上下文还是从类路径下装配应用上下文，将bean加载到bean工厂的过程都是相似的。 加载一个FileSystemXmlApplicationContext: 在文件系统的路径下查找knight.xml 12ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml"); 也可以使用ClassPathXmlApplicationContext: 所有的类路径下查找knight.xml12ApplicationContext context = new ClassPathXmlApplicationCOntext("knight.xml"); 也可以从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext 12ApplicationContext context = new AnonotationConfigApplicationContext( com.guo.knights.config.KnightConfig.class); 应用上下文准备就绪之后，我们就可以调用上下文的getBean()方法从Spring容器中获取bean。 1.2.2 bean的生命周期在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后bean就可以使用了。一旦bean不再使用，则由JCM自动进行垃圾回收。 相比之下，Spring容器中的bean声明周期就显得复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。 在bean工厂执行力若干启动步骤； 1、Spring对bean进行实例化 2、Spring将值和 bean的引用注入到bean对应的属性中。 3、如果bean实现类beanNameAware接口，Spring将bean的ID传给setBean-Name()方法 4、如果bean实现类BeanFactoryAware接口，Spirng将调用setBeanFatory()方法，将BeanFactory容器实例传入。 5、如果bean实现类applicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传递进来。 6、如果bean实现类BeanPostProcessor接口，Spring将调用它们的postProcessBeforInitialization()方法 7、如果bean实现类InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法，如果类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用。 8、如果bean实现类BeanPostProcessor接口，Spring将调用它们的PostProcessAfterInitialization()方法 9、此时，bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁。 10、如果bean实现类DisPosableBean接口，Spring将调用他的destroy()接口方法。同样，如果bean使用destroy-mothod声明销毁方法，该方法也会被调用。 1.3俯瞰Spring风景线Spring实际上的功能超乎你的想象 1.3.1 Spring模块这些模块依据其所属的功能划分为6类不同的功能，总而言之，这些模块为开发企业及应用提供了所需的一切 。但是你也不必将应用建立在整个Spring框架上，你可以自由的选择合适自身应用需求的Spring模块：当Spring不能满足需求时，完全可以考虑其他选择，事实上，Spring甚至提供了与其他的第三方框架和类库的集成点,这样你就不需要自己编写代码了。 Spring核心容器 容器是Spring最核心的部分，它管理者Spring应用中bean的创建、配置、管理。在该模块中，包括了Spring bean工厂，它为Spring提供了DI的功能，甚至bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。 所有的Spring模块都构建于核心容器之上。当你配置应用时，其实你隐式的使用率这些类。 SpringAOP模块在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦，借助于AOP，可以将遍布系统的应用的关注点(例如：事务，安全，日志)从它们所应用的对象中解耦出来。 数据访问与集成 使用JDBC编写代码通常会导致大量的样式代码，Spring的JDBC和DAO模块抽象类这些样板代码，是我们的数据库代码变得简单明了。还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，以后我们再也不需要解释那些隐晦专有的SQL信息了。 Spring提供了ORM模块，Spring的ORM模块建立在DAO的支持之上，并为多个ORM框架提供了一种构建DAO的简便方式 。Spring没有尝试去创建自己的ORM解决方，而是对许多流行的ORM框架进行了集成。包括Hibernater、Java Persisternce API、Java Data Object 和mybatis。Spring的事务管理支持所有的ORM框架以及JDBC。 Web与远程调用MVC(Model-View-Controller)模块是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离，Java从来不缺少MVC框架，Apache的struts2、JSF、WebWorks都是可选的最流行的MVC框架。Spring远程调用功能集成了RMI(Remote mehtod Invocation)、Hessian、CXF。Spring还提供了暴露和使用RESTAPI的良好支持。 InstrumentationSpring的Instrumentation模块提供了为JVM添加代理(agent)的功能.具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件时被类加载器加载的一样。 Testing通过该模块，你会发现Spring为JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象事项，对于继承测试，该模块为加载Spring应用上下文中的bean集合以及与Spirng上下文中的bean进行交互提供了支持。 1.3.2 Spring Portfolio如果仅仅停留在和性的Spring框架层面，我们将错过Spring Portlio所提供的巨额财富。整个Spirng Portlio包括多个构建与核心Spring框架之上的框架和类库。概括的来讲，整个Spring Portlio几乎为每一个领域的Java开发都提供了Spring编程模型 Spring Web Flow:是建立与Spring MVC框架之上，它为基于流程的会话式Web应用(购物车、向导功能)提供了支持。 Spirng Security:安全度与许多应用都是一个非常关键的切面。利用SpringAOP，SpringSecurity为Spring应用提供了声明式的安全机制。 Spring Data：使得在Spring中使用任何数据库都变得非常容易。一种新的数据库种类，通常被称为NoSQL数据库，提供了使用数据的新方法，为所中数据库提供了一种自动化的Repository机制，它负责为你创建Repository的实现 Spring Boot： Spring极大的简化了众多编程的任务，减少甚至消除了很多样板式代码。Spring Boot大量依赖于自动配置技术，它能够消除大部分Spring配置。还提供了多个Starter项目，不管你是用Maven还是Gradle，这都能减少Spring的工程构建文件的大小。 1.4 Spring的新功能1.4.1 Spring3.1新特性Spring 3.1带来了多项有用的新特性 和增强，其中有很多都是关于如何简化个改善配置的。除此之外，Spring3.1还提供了声明式缓存的支持以及众多针对SpringMVC的的功能增强。 借助于profile，就能根据应用布置在什么环境之中选择不同的数据源 基于Java配置，Spring3.1增加了多个enable注解，启用Spring特定功能 对声明式缓存的支持，能够 使用简单的注解声明缓存的边界和规则， 开始支持Servlet3.0，包括在基于Java的配置中 申明Servlet和Filter，而不再借助于web.xml 1.4.2 Spring 3.2新特性Spring 3.2主要关注Spring MVC的一个发布版本。 Spring MVC 3.2带来如下的功能提升 控制器(Controller)可以使Servlet3.0异步请求，允许在一个独立的线程中处理请求，从而就爱那个Servlet线程解放出来处理更多的请求 @Autowired、@Value、@Bean注解能够作为元注解。用于创建自定义的注解和bean的申明注解 Spring的声明式缓存提供了对JCache0.5的支持。 1.4.3 Spring 4.0新特性 Spring提供了对WebSocket编程的支持， 新的消息模块， 支持Java8的新特性，比如：Lambda，函数式， 为 Groovy开发的应用程序提供了更加顺畅的编程体验 添加了条件化创建bean的功能 Spring4.0包含了Spring RestTemplate的一个新的异步实现。它会立即返回并且允许在操作完成后执行回调 添加了对多项JEE规范的支持，包括JMS 2.0 、JTA1.2 JPA 2.1 1.4.4 Spring 5.0新特性 在Spring Framework代码中使用JDK 8特性 响应式编程是Spring Framework 5.0最重要的功能之一 除了响应式特性之外，Spring 5还提供了一个函数式Web框架。 Spring Framework 5.0 引入了对 JetBrains Kotlin 语言的支持。 1.5 小节Spring致力于简化企业级开发Java开发、促进代码的松耦合。成功的关键在于依赖注入和AOP。 DI是组装应用对象的一种方式，借助于这种方式对象无需知道依赖来自于何处或者依赖的具体实现方式。不同于自己获取依赖对象，对象会在运行期赋予它们所依赖的对象。依赖对象通常会通过接口了解所注入的对象，这样的话就能确保低耦合。 除了DI，还简单介绍了Spring对AOP的支持，AOP可以帮助应用将散落在各处的逻辑汇集于一处——切面。当Spring装配bean的时候，这些切面能够运行期编织起来，这样就能呢个非常有效的赋予bean新功能。 依赖注入和AOP是Spring框架最核心的部分，只有理解了如何应用Spring是最关键的功能。你才有能力使用Spring框架的其他功能。 参考：https://juejin.im/post/5a8bef5c6fb9a06350151fa3]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《重构》阅读笔记 - 代码的坏味道]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-1%2F</url>
    <content type="text"><![CDATA[重复代码（Duplicated Code）如果你在一个以上的地方看到相同的程序结构，那么可以肯定：设法将它们合而为一，程序会变得更美好！你需要决定这个重复的代码放在哪里比较合适，并确保它被安置之后就不会在别的地方再次出现。 过长函数（Long Method）程序越长越难以理解。现代 OO 语言几乎完全免去了进程内的函数调用开销，因此，你应该积极地分解函数。我们应该遵循原则：每当需要以注释来说明点什么的时候，我们就需要把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。如何确定需要提炼哪一段代码：寻找注释、条件表达式、循环。 过大的类（Large Class）如果你发现一个类试图做太多事情，其内部就会出现很多不相关的实例变量，此时这个类的职责就不明确了。 过长参数列（Long Parameter List）太长的参数队列难以理解，太多参数的接口对于使用者来说十分不友好，而且容易出错。如果可以使用一个对象代替参数列表，那么就应该这么做。 发散式变化（Divergent Change） VS 霰弹式修改（Shotgun Surgery）一旦需要修改，我们希望只在系统的一个地方进行修改，否则，就属于两种非常相似的坏味道的一种：如果某个类经常因为不同的原因在不同的地方发生变化，那么 Divergent Change 就出现了；如果系统每遇到一个小变化，就需要在多个不同的类内进行许多小修改，这属于 Shotgun Surgery。Divergent Change 是指 “一个类受多种变化的影响”，Shotgun Surgery 则指的是 “一种变化引发多个类的修改”。 平行继承体系（Parallel Inheritance Hierarchies）这其实是 Shotgun Surgery 的特殊情况——每当你为某个类添加一个子类，你也必须为它的兄弟类加一个子类。如果你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，就属于这种情况。 依恋情结（Feature Envy）面向对象的精髓在于：“将数据和对数据的操作行为包装在一起”。有一种气味是：函数对某个类的兴趣高过自己所处的类的兴趣。有很多时候，我们看到一个函数为了计算某个值，从另一个对象那儿调用了几乎半打的取值函数。最根本的原则是：将总是一起变化的东西放在一起。 数据泥团（Data Clumps）你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些绑在一起出现的数据真应该拥有属于它们自己的对象。减少字段和参数的个数，当然可以去除一些坏味道，但更重要的是：一旦拥有新对象，你就有机会寻找 Feature Envy，这可以帮你指出能够移至新类中的种种方法。 基本类型偏执（Primitive Obsession）对象技术的新手通常不愿意在小任务上运用对象——例如结合数值和币种的 Money 类、由一个起始值和一个结束值构成的 Range 类、电话号码或邮政号码等的特殊字符串。 switch 语句（Switch Statements）从本质上讲，switch 语句的问题在于重复，面向对象的多态特性可以优雅地解决这个问题。如果你只是在单一函数内有些选择事例，那么用多态就属于杀鸡用牛刀了，这种情况下 Replace Parameter with Explicit Methods 是个不错的选择，如果你的选择之一是 null，记得使用 Introduce Null Object。 多余的类（Lazy Class）你所创建的每一个类，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个类的所得不值得其身价，就应该消除这个类。 过度设计（Speculative Generality）当有人说 “噢，我想我们有一天需要做这个事情”，并因此而企图以各种各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。软件设计不可过度设计，否则会使得系统难以理解和维护。 令人迷惑的暂时字段（Temporary Field）有时你会看到这样的现象：类内的某个实例变量仅为某种特定情况而设。这样的代码不易理解，因为通常认为对象在所有时候都需要它的所有变量。 过度耦合的消息链（Message Chains）如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象…… 这就是消息链。实际代码中你看到的可能是一长串 getXXX() 调用，意味着客户代码将与查找目标对象过程中的导航结构紧密耦合，一旦对象间的关系发生任何变化，客户端就会受到影响。 中间人（Middle Man）对象的基本特征之一是封装——对外部世界隐藏其内部细节。封装往往伴随着委托，比如你问主管是否有时间参加一个会议，他就把这个消息 “委托” 给他的记事簿，然后才能回答你——你没有必要这位主管到底是使用传统记事簿或电子记事簿或秘书来记录自己的约会。但是，不要过度使用委托——你也许会看到某个类有一半接口都委托给其他类。 狎昵关系（Inappropriate Intimacy）类与类之间过分紧密的关系必须拆散——可以引入第三方类或者利用委托。 异曲同工的类（Alternative Classes with Different Interfaces）如果两个函数做同一件事，却有着不同的签名，请运用 Rename Method 根据它们的用途重新命名。但这往往不够，请反复运用 Move Method 将某些行为移入类，知道这两个函数的协议一致为止。如果你必须移动大量代码才可以完成这个工作，那还不如直接构建一个父类。 不完美的库类（Incomplete Library Class）复用常常被认为是面向对象技术的终极目标。很多第三方库提供的接口经常不能恰如其分得满足我们的需求，这时候就需要对第三方接口做一层转换，或者给它添加一定的行为。 数据类（Data Class）所谓 Data Class，指的是：这种类拥有一些字段，以及用于访问（读、写）的函数，除此之外啥都没有。这样的类只是一种不会说话的数据容器，它们一定被其他类过分细碎得控制着。Data Class 就像小孩子，作为一个起点很好，但若要让它们像成熟的对象那样参与整个系统的工作，它们就必须承担一定责任。但是，在 Spring 框架开发中，我们经常需要定义很多 domain 对象。 被拒绝的遗嘱（Refused Request）子类应该继承超类的函数和数据，但如果它们不想或者不需要继承，又该怎么办呢？按照传统说法，这就意味着继承体系的设计错误。你需要为这个子类新建一个兄弟类，然后让父类只包括两个子类共享的部分。一般而言，这就足够了，但是如果子类不愿意支持超类提供的接口，则说明不能使用继承处理，应该使用委托。 过多的注释（Comments）常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。当你需要些注释时，要先尝试重构下代码，争取让代码拥有自说明性。 参考：https://www.jianshu.com/p/41e889181536?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[instanceof 运算符用法]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-1%2F</url>
    <content type="text"><![CDATA[运算符是双目运算符, 左面的操作元是一个对象, 右面是一个类. 当 左面的对象是右面的类创建的对象时, 该运算符运算的结果是 true, 否则是 false 例如 a instanceof A如果 a 是类 A 的实例，就返回 true，否则的话，就返回 false。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455interface A&#123; &#125; class B implements A&#123; &#125; class C extends B&#123; &#125; public class Iinstanceof &#123; public static void main(String[] args) &#123; A ab=new B(); A ac=new C(); B bc=new C(); B bb=new B(); C cc=new C(); //对象实现一个接口，用这个对象和这个接口进行instanceof判断，都为true。 System.out.println(&quot;ab instanceof A=&quot;+(ab instanceof A)); System.out.println(&quot;ac instanceof A=&quot;+(ac instanceof A)); System.out.println(&quot;bc instanceof A=&quot;+(bc instanceof A)); System.out.println(&quot;bb instanceof A=&quot;+(bb instanceof A)); System.out.println(&quot;cc instanceof A=&quot;+(cc instanceof A)); //对象和父类进行instanceof判断，都为true System.out.println(&quot;ab instanceof B=&quot;+(ab instanceof B)); System.out.println(&quot;ac instanceof B=&quot;+(ac instanceof B)); System.out.println(&quot;bc instanceof B=&quot;+(bc instanceof B)); System.out.println(&quot;bb instanceof B=&quot;+(bb instanceof B)); System.out.println(&quot;cc instanceof B=&quot;+(cc instanceof B)); //对象和他的子类进行instanceof判断为false System.out.println(&quot;ab instanceof C=&quot;+(ab instanceof C)); System.out.println(&quot;ac instanceof C=&quot;+(ac instanceof C)); System.out.println(&quot;bc instanceof C=&quot;+(bc instanceof C)); System.out.println(&quot;bb instanceof C=&quot;+(bb instanceof C)); System.out.println(&quot;cc instanceof C=&quot;+(cc instanceof C)); &#125; &#125; [java] view plain copy//程序输出： ab instanceof A=true ac instanceof A=true bc instanceof A=true bb instanceof A=true cc instanceof A=true ab instanceof B=true ac instanceof B=true bc instanceof B=true bb instanceof B=true cc instanceof B=true ab instanceof C=false ac instanceof C=true bc instanceof C=true bb instanceof C=false cc instanceof C=true 参考：http://blog.csdn.net/cnmilan/article/details/41696093http://blog.csdn.net/cntanghai/article/details/6096976https://zhidao.baidu.com/question/1175062948955268939.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析Java对象的hashCode和hashCode在HashMap的底层数据结构的应用]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14%2F</url>
    <content type="text"><![CDATA[一、java对象的比较 等号(==)： 对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等； equals()： 对比两个对象实例是否相等。 当对象所属的类没有重写根类Object的equals()方法时，equals()判断的是对象实例的ID（内存地址），是否是同一对象实例；该方法就是使用的等号(==)的判断结果，如Object类的源代码所示： Java代码 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 当对象所属的类重写equals()方法（可能因为需要自己特有的“逻辑相等”概念)时，equals()判断的根据就因具体实现而异，有些类是需要比较对象的某些值或内容，如String类重写equals()来判断字符串的值是否相等。判断逻辑相等。 hashCode(): 计算出对象实例的哈希码，并返回哈希码，又称为散列函数。根类Object的hashCode()方法的计算依赖于对象实例的D（内存地址），故每个Object对象的hashCode都是唯一的；当然，当对象所对应的类重写了hashCode()方法时，结果就截然不同了。 二、Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。哈希算法也称为散列算法，当集合要添加新的元素时，将对象通过哈希算法计算得到哈希值（正整数），然后**将哈希值和集合（数组）长度进行&amp;运算**，得到该对象在该数组存放的位置索引。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就表示发生冲突了，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。 这样一来，实际调用equals方法比较的次数就大大降低了，几乎只需要一两次。 简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！ 三、Java 对象的equal方法和hashCode方法的关系 首先，Java对象相同指的是两个对象通过eqauls方法判断的结果为true Java对象的eqauls方法和hashCode方法是这样规定的： 1、相等**（相同）**的对象必须具有相等的哈希码（或者散列码）。 2、如果两个对象的hashCode相同，它们并不一定相同。 以下是Object对象API关于equal方法和hashCode方法的说明： If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.（如果两个对象根据equals（object）方法相等，则对这两个对象中的每个对象调用hashcode方法必须产生相同的整数结果。） It is not required that if two objects are unequal according to the equals(java.lang.Object)) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.（如果两个对象根据equals（java.lang.object）方法不相等，则不要求在两个对象中的每一个上调用hashcode方法都必须产生不同的整数结果。但是，程序员应该意识到，为不等对象生成不同的整数结果可能会提高散列表的性能。） 以上API说明是对之前2点的官方详细说明 关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？ 想象一下，假如两个Java对象A和B，A和B相等（eqauls结果为true），但A和B的哈希码不同，则A和B存入HashMap时的哈希码计算得到的HashMap内部数组位置索引可能不同，那么A和B很有可能允许同时存入HashMap，显然相等/相同的元素是不允许同时存入HashMap，HashMap不允许存放重复元素。 关于第二点，两个对象的hashCode相同，它们并不一定相同 也就是说，不同对象的hashCode可能相同；假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。 四、深入解析HashMap类的底层数据结构 Map接口 Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。 Hashtable类 Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。 Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”： Hashtable numbers = new Hashtable(); numbers.put(“one”, new Integer(1)); numbers.put(“two”, new Integer(2)); numbers.put(“three”, new Integer(3)); 要取出一个数，比如2，用相应的key： Integer n = (Integer)numbers.get(“two”); System.out.println(“two = ” + n); 1. HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 2. HashMap的数据结构：HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。首先，HashMap类的属性中定义了Entry类型的数组。Entry类实现java.ultil.Map.Entry接口，同时每一对key和value是作为Entry类的属性被包装在Entry的类中。 如图所示，HashMap的数据结构： HashMap的部分源码如下： Java代码 123456789101112131415/** * The table, resized as necessary. Length MUST Always be a power of two. * 长度必须是2的n次方 */transient Entry[] table; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; ……&#125; 可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。table数组的元素是Entry类型的。每个 Entry元素其实就是一个key-value对，并且它持有一个指向下一个 Entry元素的引用，这就说明table数组的每个Entry元素同时也作为某个Entry链表的首节点，指向了该链表的下一个Entry元素，这就是所谓的“链表散列”数据结构，即数组和链表的结合体。 3. HashMap的存取实现： 1) 添加元素： 当我们往HashMap中put元素的时候，先根据key的重新计算元素的hashCode，根据hashCode得到这个元素在table数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 HashMap的部分源码如下： Java代码 123456789101112131415161718192021222324252627 public V put(K key, V value) &#123; // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 如果发现 i 索引处的链表的某个Entry的hash和新Entry的hash相等且两者的key相同，则新Entry覆盖旧Entry，返回。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null;&#125; 2) 读取元素： 有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 HashMap的部分源码如下： 12345678910111213public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; 3) 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。 五、**实现**相等的对象必须具有相等的哈希码 如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。 同时复写equals方法和hashCode方法,必须保证“相等的对象必须具有相等的哈希码”，也就是当两个对象通过equals()比较的结果为true时，这两个对象调用hashCode（）方法生成的哈希码必须相等。 如何保证相等，可以参考下面的方法： 复写equals方法和hashCode方法时，equals方法的判断根据和计算hashCode的依据相同。如String的equals方法是比较字符串每个字符，String的hashCode也是通过对该字符串每个字符的ASC码简单的算术运算所得，这样就可以保证相同的字符串的hashCode相同且equals()为真。 String类的equals方法的源代码： Java代码 123456789101112131415161718192021222324252627282930313233343536/** * Compares this string to the specified object. The result is &#123;@code * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code * String&#125; object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the given object represents a &#123;@code String&#125; * equivalent to this string, &#123;@code false&#125; otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125;return false;&#125; Sring类的hashCode方法计算hashCode的源代码： 123456789101112131415161718192021222324252627 /** * Returns a hash code for this string. The hash code for a * &lt;code&gt;String&lt;/code&gt; object is computed as * &lt;blockquote&gt;&lt;pre&gt; * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * &lt;/pre&gt;&lt;/blockquote&gt; * using &lt;code&gt;int&lt;/code&gt; arithmetic, where &lt;code&gt;s[i]&lt;/code&gt; is the * &lt;i&gt;i&lt;/i&gt;th character of the string, &lt;code&gt;n&lt;/code&gt; is the length of * the string, and &lt;code&gt;^&lt;/code&gt; indicates exponentiation. * (The hash value of the empty string is zero.) * * @return a hash code value for this object. */ public int hashCode() &#123;int h = hash; int len = count;if (h == 0 &amp;&amp; len &gt; 0) &#123; int off = offset; char val[] = value; for (int i = 0; i &lt; len; i++) &#123; h = 31*h + val[off++]; &#125; hash = h; &#125; return h; &#125; 参考：http://kakajw.iteye.com/blog/935226]]></content>
      <tags>
        <tag>hashCode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机 知识点总结&面试题]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-1%2F</url>
    <content type="text"><![CDATA[1. 内存模型以及分区，需要详细到每个区放什么。 运行时数据区域：虚拟机栈，本地方法栈，程序计数器，堆，方法区，具体如图所示： 2.2.1 程序计数器（Program Counter Register） 概述：当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有2.无内存溢出：此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 概述：每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆的唯一目的就是存储对象的实例。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。 Eden 区的对象都是朝生夕死，发生 minor gc 的时候会清除 eden 区和 survival 区的，把存活的对象移到另一个 Survival 区，该 survial 区由老年代保证。当在年轻代中对象经过多次 minor gc 以后还存活，达到老年代的年纪，就会移动到老年代，还有就是大对象在年轻代无法存储，直接转到老年代，还有可能因为担保而进入老年代的 3. 对象创建方法，对象的内存分配，对象的访问定位 1 对象的创建包括三步骤： ①当遇到 new 命令的时候，会在常量池中检查该对象的符号引用是否存在，不存在则进行类的加载，否则执行下一步 ②分配内存，将将要分配的内存都清零。 ③虚拟机进行必要的设置，如设置 hashcode，gc 的分代年龄等，此时会执行命令在执行之前所有的字段都为 0，执行指令以后，按照程序顺序进行初始化字段。 2：对象的内存分配：包括对象头，实例数据，对齐填充 ①对象头: 包括对象的 hascode，gc 分代年龄，锁状态标等。 ②实例数据: 也就是初始化以后的对象的字段的内容，包括父类中的字段等 ③对齐填充：对象的地址是 8 字节，虚拟机要求对象的大小是对象的整数倍 (1 倍或者两倍)。因此就会有空白区。 3：对象的访问： hotspot 中 是采用对象直接指向对象地址的方式（这样的方式访问比较快）（还有一种方式就是句柄，也就是建一张表维护各个指向各个地址的指针，然后给指针设置一个句柄 （别名），然后引用直接指向这个别名，就可以获得该对象，这种的优势就是，实例对象地址改变了，只要修改句柄池中的指针就可以了，而不用引用本身不会发生改变）。 4.GC 的两种判别方法：引用计数与引用链 引用计数 给一个对象设置一个计数器，当被引用一次就加 1，当引用失效的时候就减 1，如果该对象长时间保持为 0 值，则该对象将被标记为回收。优点：算法简单，效率高，缺点：很难解决对象之间的相互循环引用问题。 引用链： 现在主流的 gc 都采用可达性分析算法来判断对象是否已经死亡。可达性分析：通过一系列成为 GC Roots 的对象作为起点，从这些起点向下搜索，搜索所走过的路径成为引用链，当一个对象到引用链没有相连时，则判断该对象已经死亡。 可作为 gc roots 的对象： 虚拟机栈（本地方法表）中引用的对象（因为在栈内，被线程引用），方法区中类静态属性引用的对象，方法区中常量引用的（常量存放在常量池中，常量池是方法区的一部分）对象，native 方法引用的对象 引用计数和引用链是只是用来标记，判断一个对象是否失效，而不是用来清除 5.GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？3.3.1 标记 - 清除算法 (Mark-Sweep) 最基础的收集算法。其它算法都是基于这种思路并对其不足进行改进而得到的。 标记 - 清除算法将垃圾回收分为两个阶段： ①. 标记阶段：首先标记出所有需要回收的对象。 如何标记，在上面的 “判断对象是否存活” 里有讲过 ②. 清除阶段：标记完成后，统一回收被标记的对象缺点： ①. 效率问题：标记清除过程效率都不高。 ②. 空间问题：标记清除之后会产生大量的不连续的内存碎片 (空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。） 3.3.2 复制算法 (Copying)为了解决 mark-sweep 算法的效率问题 算法思想： 1). 将现有的内存空间分为两块，每次只使用其中一块. 2). 当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。 3). 再把已使用过的内存空间一次清理掉。 优点： 1). 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 2). 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 2.3 缺点： 1). 内存减少为原来的一半，太浪费了。 2). 对象存活率较高的时候就要执行较多的复制操作，效率变低。 3). 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。2.4. 演进 并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 EdenSpace 和两块较小的 SurvivorSpace JavaHeap 内存回收模型（当前商业虚拟机大多使用此算法回收新生代） jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 3.3.3 标记 - 整理算法 (Mark-Compact) 由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 算法思想 1). 标记阶段：首先标记出所有需要回收的对象。与 “标记 - 清除” 一样 2). 让存活的对象向内存的一段移动。 3). 直接清理掉边界以外的内存。 由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记 - 清理算法或标记 - 清除算法。 3.3.4 代收集算法 (Generational Collecting) 当前的商业虚拟机的垃圾收集都采用，把 Java 堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。 优化收集方法： 优化收集方法：对复制算法的优化：并不是将两块内存分配同等大小，可以将存活率低的区域大一些，而让回收后存活的对象所占的区域小一些，不够的内存由老年代的内存来保证，这样复制算法的空闲的空间减少了。两个 survival 区域目的是为了减少风险，有一个 survivor 区要参与回收，也要参与存储，只要只有 10% 的空间浪费，同时也减少对老年代的依赖。 6.GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。 （见书上3.5） 串行的，也就是采用单线程（比较老了），分类：serial new（收集年轻代，复制算法）和 serial old（收集老年代，标记整理），缺点：单线程，进行垃圾回收时暂时所有的用户线程。优点：实现简单。 并行的，采用多线程，对于年轻代有两个： parallel new（简称 ParNew）（参考 serial new 的多线程版本）和 parallel scavenge；parallel scavenge 是一个针对年轻代的垃圾回收器，采用复制算法，主要的优点是进行垃圾回收时不会停止用户线程（不会发生 stop all world）老年代回收器也有两种：Parallel old 是 parallel scavenge 的老年代设计的。CMS（并发标记清除）采用标记清除算法，采用这种的优点就是快咯，因此会尽快的进行回收，减少停顿时间。 高级杀手：G1 收集器，年轻代和老年代通吃，最新一代的技术。面向服务器端的垃圾收集器（并行 + 并发的垃圾收集器）。 7.Minor GC 与 Full GC 分别在什么时候发生? Minor GC 发生：当 jvm 无法为新的对象分配空间的时候就会发生 minor gc，所以分配对象的频率越高，也就越容易发生 minor gc。 Full GC：发生 GC 有两种情况，①当老年代无法分配内存的时候，会导致 MinorGC,②当发生 Minor GC 的时候可能触发 Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不能清除自己要担保多少空间，因此采取采用动态估算的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次 Minor GC 以后，存活的对象剧增（假设小对象），此时老年代并没有满，但是此时平均值增加了，会造成发生 Full GC 8. 类加载的五个过程：加载、验证、准备、解析、初始化。 加载： 加载有两种情况，①当遇到 new 关键字，或者 static 关键字的时候就会发生（他们对应着对应的指令）如果在常量池中找不到对应符号引用时，就会发生加载 ，②动态加载，当用反射方法（如 class.forName(“类名”)），如果发现没有初始化，则要进行初始化。（注：加载的时候发现父类没有被加载，则要先加载父类） 验证： 这一阶段的目的是确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全（虽然编译器会严格的检查 java 代码并生成 class 文件，但是 class 文件不一定都是通过编译器编译，然后加载进来的，因为虚拟机获取 class 文件字节流的方式有可能是从网络上来的，者难免不会存在有人恶意修改而造成系统崩溃的问题，class 文件其实也可以手写 16 进制，因此这是必要的） 准备： 该阶段就是为对象分派内存空间，然后初始化类中的属性变量，但是该初始化只是按照系统的意愿进行初始化，也就是初始化时都为 0 或者为 null。因此该阶段的初始化和我们常说初始化阶段的初始化时不一样的 解析： 解析就是虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用其实就是 class 文件常量池中的各种引用，他们按照一定规律指向了对应的类名，或者字段，但是并没有在内存中分配空间，因此符号因此就理解为一个标示，而在直接引用直接指向内存中的地址 初始化： 简单讲就是执行对象的构造函数，给类的静态字段按照程序的意愿进行初始化，注意初始化的顺序。（此处的初始化由两个函数完成，一个是, 初始化所有的类变量（静态变量），该函数不会初始化父类变量，还有一个是实例初始化函数, 对类中实例对象进行初始化，此时要如果有需要，是要初始化父类的） 9. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。 类 加载器的工作过程：如果一个类加载器收到类类加载的请求，他首先不会自己去加载这个类，而是把类委派个父类加载器去完成，因此所有的请求最终都会传达到顶 层的启动类加载器中，只有父类反馈无法加载该类的请求（在自己的搜索范围类没有找到要加载的类）时候，子类才会试图去加载该类。 10. 分派：静态分派与动态分派: 静态分派和动态分派都是多态的内容，多态的实现依赖于编译阶段和运行时阶段：在编译阶段主要表现在静态分派， 静态分派就是通过静态类型和方法参数个数来选择哪一个方法版本，这就是主要体现了方法的重载；因为他在编译的时候就能确定调用哪一个函数，所以叫静态分派。 在运行时阶段体现在动态分派（动态绑定），也就是当一个父类引用指向子类对象，通过该父类引用去调用一个该方法，由于在编译阶段生产的调用函数代码的字节码指向的是父类（静态类型）被调用方法，并不知道具体要去调用哪一个实际类型的方法，因 此会发生这样一个过程，虚拟机找到操作数栈中位于栈顶获取该操作数所指向的类，然后到常量池中去搜索与被调用的方法匹配的方法名和描述符，如果找到， 就进行权限校验（校验失败就抛出异常），如果可以访问，则返回该方法的符号引用，并转换成直接引用，调用该执行，如果找不到就到父类中去找，然后重复上面 动作，最后找不到就抛出异常。 对动态绑定的优化：由于要去常量池中搜索每一类的方法名和描述符，因此效率比较低，所以最后进行了优化，就是在方法区为每一类维护一张虚方法表或者接口方法表（虚表中存放了该方法的实际入口地址），让该类的所有方法都维护进去（包括父类的方法），因此要查找方法名的时候，直接去该虚表中去搜索到该方法名对应的直接地址然后执行。对于没有被重写的方法，直接存放父类的入口地址，如果该方法被重写，在存放子类的方法入口地址。 参考:http://blog.csdn.net/qq_30000411/article/details/60334051 JDK 是什么 JRE 是什么 Java 历史版本的特性 Java Version SE 50 Java Version SE 6 Java Version SE 7 Java 8 运行时数据区域包括哪些 程序计数器线程私有 Java 虚拟机栈线程私有 本地方法栈线程私有 Java 堆线程共享 方法区线程共享 运行时常量池 Java 中对象访问是如何进行的 如何判断对象是否死去 什么是引用计数法 引用计数法的缺点 什么是根搜索算法 Java 的 4 种引用方式 强引用 软引用 弱引用 虚引用 有哪些垃圾收集算法 标记 - 清除算法 Mark-Sweep 什么是标记 - 清除算法 有什么缺点 复制算法 Copying- 新生代 优点 缺点 应用 标记 - 整理算法 Mark-Compact - 老年代 分代收集算法 Minor GC 和 Full GC 有什么区别 Java 内存 为什么要将堆内存分区 堆内存分为哪几块 分代收集算法 内存分配有哪些原则 Young Generation Space 采用复制算法 Tenure Generation Space 采用标记 - 整理算法 Permanent Space Class 文件 Java 虚拟机的平台无关性 Class 文件的组成 魔数与 Class 文件的版本 类加载器 类加载器的作用是什么 类加载器有哪些 类加载机制 什么是双亲委派模型 为什么要使用双亲委派模型组织类加载器之间的关系 什么是类加载机制 虚拟机和物理机的区别是什么 运行时栈帧结构 Java 方法调用 什么是方法调用 Java 的方法调用有什么特殊之处 Java 虚拟机调用字节码指令有哪些 虚拟机是如何执行方法里面的字节码指令的 解释执行 基于栈的指令集和基于寄存器的指令集 什么是基于栈的指令集 什么是基于寄存器的指令集 基于栈的指令集的优缺点 Javac 编译过程分为哪些步骤 什么是即时编译器 解释器和编译器 为什么要采用分层编译 分层编译器有哪些层次 编译对象与触发条件 热点代码有哪些 如何判断一段代码是不是热点代码 HotSpot 虚拟机使用第二种有两个计数器 方法调用计数器统计方法 有哪些经典的优化技术即时编译器 公共子表达式消除 数组边界检查消除 方法内联 逃逸分析 如果对象不会逃逸到方法或线程外可以做什么优化 Java 与 CC 的编译器对比 物理机如何处理并发问题 Java 内存模型 什么是 Java 内存模型 Java 内存模型的目标 主内存与工作内存 内存间的交互操作 原子性可见性有序性 volatile 什么是 volatile 为什么基于 volatile 变量的运算在并发下不一定是安全的 为什么使用 volatile 并发与线程 并发与线程的关系 什么是线程 实现线程有哪些方式 Java 线程的实现 Java 线程调度 什么是线程调度 线程调度有哪些方法 线程安全的定义 Java 语言操作的共享数据包括哪些 不可变 如何实现线程安全 阻塞同步互斥同步 非阻塞同步 锁优化是在 JDK 的那个版本 为什么要提出自旋锁 自旋锁的原理 自旋的缺点 什么是自适应自旋 锁消除 锁粗化 轻量级锁 偏向锁 JDK 是什么？JDK 是用于支持 Java 程序开发的最小环境。 Java 程序设计语言 Java 虚拟机 Java API 类库 JRE 是什么？JRE 是支持 Java 程序运行的标准环境。 Java SE API 子集 Java 虚拟机 Java 历史版本的特性？Java Version SE 5.0 引入泛型； 增强循环，可以使用迭代方式； 自动装箱与自动拆箱； 类型安全的枚举； 可变参数； 静态引入； 元数据（注解）； 引入 Instrumentation。 Java Version SE 6 支持脚本语言； 引入 JDBC 4.0 API； 引入 Java Compiler API； 可插拔注解； 增加对 Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos 和 LDAP(Lightweight Directory Access Protocol) 的支持； 继承 Web Services； 做了很多优化。 Java Version SE 7 switch 语句块中允许以字符串作为分支条件； 在创建泛型对象时应用类型推断； 在一个语句块中捕获多种异常； 支持动态语言； 支持 try-with-resources； 引入 Java NIO.2 开发包； 数值类型可以用 2 进制字符串表示，并且可以在字符串表示中添加下划线； 钻石型语法； null 值的自动处理。 Java 8 函数式接口 Lambda 表达式 接口的增强 运行时数据区域包括哪些？ 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 运行时常量池 直接内存 Java 中对象访问是如何进行的？1Object obj = new Object(); 对于上述最简单的访问，也会涉及到 Java 栈、Java 堆、方法区这三个最重要内存区域。 1Object obj 如果出现在方法体中，则上述代码会反映到 Java 栈的本地变量表中，作为 reference 类型数据出现。 1new Object() 反映到 Java 堆中，形成一块存储了 Object 类型所有对象实例数据值的内存。Java 堆中还包含对象类型数据的地址信息，这些类型数据存储在方法区中。 如何判断对象是否 “死去”？ 引用计数法 根搜索算法 什么是引用计数法？给对象添加一个引用计数器，每当有一个地方引用它，计数器就 + 1,；当引用失效时，计数器就 - 1；任何时刻计数器都为 0 的对象就是不能再被使用的。 引用计数法的缺点？很难解决对象之间的循环引用问题。 什么是根搜索算法？通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。 Java 的 4 种引用方式？在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为 强引用 Strong Reference 软引用 Soft Reference 弱引用 Weak Reference 虚引用 Phantom Reference 强引用1Object obj = new Object(); 代码中普遍存在的，像上述的引用。只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。 软引用用来描述一些还有用，但并非必须的对象。软引用所关联的对象，有在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围，并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存异常。提供了 SoftReference 类实现软引用。 弱引用描述非必须的对象，强度比软引用更弱一些，被弱引用关联的对象，只能生存到下一次垃圾收集发生前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。提供了 WeakReference 类来实现弱引用。 虚引用一个对象是否有虚引用，完全不会对其生存时间够成影响，也无法通过虚引用来取得一个对象实例。为一个对象关联虚引用的唯一目的，就是希望在这个对象被收集器回收时，收到一个系统通知。提供了 PhantomReference 类来实现虚引用。 有哪些垃圾收集算法？ 标记 - 清除算法 复制算法 标记 - 整理算法 分代收集算法 标记 - 清除算法（Mark-Sweep）什么是标记 - 清除算法？分为标记和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。 有什么缺点？1. 效率问题。标记和清除过程的效率都不高。2. 空间问题。标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致，程序分配较大对象时无法找到足够的连续内存，不得不提前出发另一次垃圾收集动作。 复制算法（Copying）- 新生代将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。 优点？复制算法使得每次都是针对其中的一块进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点？将内存缩小为原来的一半。在对象存活率较高时，需要执行较多的复制操作，效率会变低。 应用？商业的虚拟机都采用复制算法来回收新生代。因为新生代中的对象容易死亡，所以并不需要按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。每次使用 Eden 和其中的一块 Survivor。 当回收时，将 Eden 和 Survivor 中还存活的对象一次性拷贝到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。Hotspot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80% + 10%），只有 10% 的内存是会被 “浪费” 的。 标记 - 整理算法（Mark-Compact）- 老年代标记过程仍然与 “标记 - 清除” 算法一样，但不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。 分代收集算法根据对象的存活周期，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点，采用最适当的收集算法。 新生代：每次垃圾收集时会有大批对象死去，只有少量存活，所以选择复制算法，只需要少量存活对象的复制成本就可以完成收集。 老年代：对象存活率高、没有额外空间对它进行分配担保，必须使用 “标记 - 清理” 或 “标记 - 整理” 算法进行回收。 Minor GC 和 Full GC 有什么区别？Minor GC：新生代 GC，指发生在新生代的垃圾收集动作，因为 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般回收速度较快。Full GC：老年代 GC，也叫 Major GC，速度一般比 Minor GC 慢 10 倍以上。 Java 内存为什么要将堆内存分区？对于一个大型的系统，当创建的对象及方法变量比较多时，即堆内存中的对象比较多，如果逐一分析对象是否该回收，效率很低。分区是为了进行模块化管理，管理不同的对象及变量，以提高 JVM 的执行效率。 堆内存分为哪几块？ Young Generation Space 新生区（也称新生代） Tenure Generation Space 养老区（也称旧生代） Permanent Space 永久存储区 分代收集算法内存分配有哪些原则？ 对象优先分配在 Eden 大对象直接进入老年代 长期存活的对象将进入老年代 动态对象年龄判定 空间分配担保 Young Generation Space （采用复制算法）主要用来存储新创建的对象，内存较小，垃圾回收频繁。这个区又分为三个区域：一个 Eden Space 和两个 Survivor Space。 当对象在堆创建时，将进入年轻代的 Eden Space。 垃圾回收器进行垃圾回收时，扫描 Eden Space 和 A Suvivor Space，如果对象仍然存活，则复制到 B Suvivor Space，如果 B Suvivor Space 已经满，则复制 Old Gen 扫描 A Suvivor Space 时，如果对象已经经过了几次的扫描仍然存活，JVM 认为其为一个 Old 对象，则将其移到 Old Gen。 扫描完毕后，JVM 将 Eden Space 和 A Suvivor Space 清空，然后交换 A 和 B 的角色（即下次垃圾回收时会扫描 Eden Space 和 B Suvivor Space。 Tenure Generation Space（采用标记 - 整理算法）主要用来存储长时间被引用的对象。它里面存放的是经过几次在 Young Generation Space 进行扫描判断过仍存活的对象，内存较大，垃圾回收频率较小。 Permanent Space存储不变的类定义、字节码和常量等。 Class 文件Java 虚拟机的平台无关性 Class 文件的组成？Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目间没有任何分隔符。当遇到 8 位字节以上空间的数据项时，则会按照高位在前的方式分隔成若干个 8 位字节进行存储。 魔数与 Class 文件的版本每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的 Class 文件。OxCAFEBABE。 接下来是 Class 文件的版本号：第 5,6 字节是次版本号（Minor Version），第 7,8 字节是主版本号（Major Version）。 使用 JDK 1.7 编译输出 Class 文件，格式代码为： 前四个字节为魔数，次版本号是 0x0000，主版本号是 0x0033，说明本文件是可以被 1.7 及以上版本的虚拟机执行的文件。 33：JDK1.7 32：JDK1.6 31：JDK1.5 30：JDK1.4 2F：JDK1.3 类加载器类加载器的作用是什么？类加载器实现类的加载动作，同时用于确定一个类。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。即使两个类来源于同一个 Class 文件，只要加载它们的类加载器不同，这两个类就不相等。 类加载器有哪些？ 启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现（仅限于 HotSpot），是虚拟机自身的一部分。负责将存放在 \lib 目录中的类库加载到虚拟机中。其无法被 Java 程序直接引用。 扩展类加载器（Extention ClassLoader）由 ExtClassLoader 实现，负责加载 \lib\ext 目录中的所有类库，开发者可以直接使用。 应用程序类加载器（Application ClassLoader）：由 APPClassLoader 实现。负责加载用户类路径（ClassPath）上所指定的类库。 类加载机制什么是双亲委派模型？双亲委派模型（Parents Delegation Model）要求除了顶层的启动类加载器外，其余加载器都应当有自己的父类加载器。类加载器之间的父子关系，通过组合关系复用。工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有到父加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，子加载器才会尝试自己去加载。 为什么要使用双亲委派模型，组织类加载器之间的关系？Java 类随着它的类加载器一起具备了一种带优先级的层次关系。比如 java.lang.Object，它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此 Object 类在程序的各个类加载器环境中，都是同一个类。 如果没有使用双亲委派模型，让各个类加载器自己去加载，那么 Java 类型体系中最基础的行为也得不到保障，应用程序会变得一片混乱。 什么是类加载机制？Class 文件描述的各种信息，都需要加载到虚拟机后才能运行。虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 虚拟机和物理机的区别是什么？这两种机器都有代码执行的能力，但是： 物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面的。 虚拟机的执行引擎是自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。 运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构， 存储了方法的 局部变量表 操作数栈 动态连接 方法返回地址 每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 Java 方法调用什么是方法调用？方法调用唯一的任务是确定被调用方法的版本（调用哪个方法），暂时还不涉及方法内部的具体运行过程。 Java 的方法调用，有什么特殊之处？Class 文件的编译过程不包含传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这使得 Java 有强大的动态扩展能力，但使 Java 方法的调用过程变得相对复杂，需要在类加载期间甚至到运行时才能确定目标方法的直接引用。 Java 虚拟机调用字节码指令有哪些？ invokestatic：调用静态方法 invokespecial：调用实例构造器方法、私有方法和父类方法 invokevirtual：调用所有的虚方法 invokeinterface：调用接口方法 虚拟机是如何执行方法里面的字节码指令的？解释执行（通过解释器执行）编译执行（通过即时编译器产生本地代码） 解释执行当主流的虚拟机中都包含了即时编译器后，Class 文件中的代码到底会被解释执行还是编译执行，只有虚拟机自己才能准确判断。 Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译是半独立的实现。 基于栈的指令集和基于寄存器的指令集什么是基于栈的指令集？Java 编译器输出的指令流，里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。 计算 “1+1=2”，基于栈的指令集是这样的： 1234iconst_1iconst_1iaddistore_0 两条 iconst_1 指令连续地把两个常量 1 压入栈中，iadd 指令把栈顶的两个值出栈相加，把结果放回栈顶，最后 istore_0 把栈顶的值放到局部变量表的第 0 个 Slot 中。 什么是基于寄存器的指令集？最典型的是 x86 的地址指令集，依赖寄存器工作。计算 “1+1=2”，基于寄存器的指令集是这样的： 12mov eax, 1add eax, 1 mov 指令把 EAX 寄存器的值设为 1，然后 add 指令再把这个值加 1，结果就保存在 EAX 寄存器里。 基于栈的指令集的优缺点？优点： 可移植性好：用户程序不会直接用到这些寄存器，由虚拟机自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存）放到寄存器以获取更好的性能。 代码相对紧凑：字节码中每个字节就对应一条指令 编译器实现简单：不需要考虑空间分配问题，所需空间都在栈上操作 缺点： 执行速度稍慢 完成相同功能所需的指令数多 频繁的访问栈，意味着频繁的访问内存，相对于处理器，内存才是执行速度的瓶颈。 Javac 编译过程分为哪些步骤？ 解析与填充符号表 插入式注解处理器的注解处理 分析与字节码生成 什么是即时编译器？Java 程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为 “热点代码”（Hot Spot Code）。 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器成为即时编译器（Just In Time Compiler，JIT 编译器）。 解释器和编译器许多主流的商用虚拟机，都同时包含解释器和编译器。 当程序需要快速启动和执行时，解释器首先发挥作用，省去编译的时间，立即执行。 当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，可以提高执行效率。 如果内存资源限制较大（部分嵌入式系统），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时编译器的代码还能退回成解释器的代码。 为什么要采用分层编译？因为即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间越长。 分层编译器有哪些层次？分层编译根据编译器编译、优化的规模和耗时，划分不同的编译层次，包括： 第 0 层：程序解释执行，解释器不开启性能监控功能，可出发第 1 层编译。 第 1 层：也成为 C1 编译，将字节码编译为本地代码，进行简单可靠的优化，如有必要加入性能监控的逻辑。 第 2 层：也成为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 用 Client Compiler 和 Server Compiler 将会同时工作。用 Client Compiler 获取更高的编译速度，用 Server Compiler 获取更好的编译质量。 编译对象与触发条件热点代码有哪些？ 被多次调用的方法 被多次执行的循环体 如何判断一段代码是不是热点代码？要知道一段代码是不是热点代码，是不是需要触发即时编译，这个行为称为热点探测。主要有两种方法： 基于采样的热点探测，虚拟机周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是 “热点方法”。实现简单高效，但是很难精确确认一个方法的热度。 基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认为它是热点方法。 HotSpot 虚拟机使用第二种，有两个计数器： 方法调用计数器 回边计数器（判断循环代码） 方法调用计数器统计方法统计的是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器的热度衰减，这个时间就被称为半衰周期。 有哪些经典的优化技术（即时编译器）？ 语言无关的经典优化技术之一：公共子表达式消除 语言相关的经典优化技术之一：数组范围检查消除 最重要的优化技术之一：方法内联 最前沿的优化技术之一：逃逸分析 公共子表达式消除普遍应用于各种编译器的经典优化技术，它的含义是： 如果一个表达式E已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。没有必要重新计算，直接用结果代替E就可以了。 数组边界检查消除因为 Java 会自动检查数组越界，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑是一种性能负担。 如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组区间内，那么整个循环中就可以把数组的上下界检查消除掉，可以节省很多次的条件判断操作。 方法内联内联消除了方法调用的成本，还为其他优化手段建立良好的基础。 编译器在进行内联时，如果是非虚方法，那么直接内联。如果遇到虚方法，则会查询当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那么也可以内联，不过这种内联属于激进优化，需要预留一个逃生门（Guard 条件不成立时的 Slow Path），称为守护内联。 如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者的继承关系发现变化的类，那么内联优化的代码可以一直使用。否则需要抛弃掉已经编译的代码，退回到解释状态执行，或者重新进行编译。 逃逸分析逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法里面被定义后，它可能被外部方法所引用，这种行为被称为方法逃逸。被外部线程访问到，被称为线程逃逸。 如果对象不会逃逸到方法或线程外，可以做什么优化？ 栈上分配：一般对象都是分配在 Java 堆中的，对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。但是垃圾回收和整理都会耗时，如果一个对象不会逃逸出方法，可以让这个对象在栈上分配内存，对象所占用的内存空间就可以随着栈帧出栈而销毁。如果能使用栈上分配，那大量的对象会随着方法的结束而自动销毁，垃圾回收的压力会小很多。 同步消除：线程同步本身就是很耗时的过程。如果逃逸分析能确定一个变量不会逃逸出线程，那这个变量的读写肯定就不会有竞争，同步措施就可以消除掉。 标量替换：不创建这个对象，直接创建它的若干个被这个方法使用到的成员变量来替换。 Java 与 C/C++ 的编译器对比 即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力。 Java 语言虽然没有 virtual 关键字，但是使用虚方法的频率远大于 C++，所以即时编译器进行优化时难度要远远大于 C++ 的静态优化编译器。 Java 语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，使得全局的优化难以进行，因为编译器无法看见程序的全貌，编译器不得不时刻注意并随着类型的变化，而在运行时撤销或重新进行一些优化。 Java 语言对象的内存分配是在堆上，只有方法的局部变量才能在栈上分配。C++ 的对象有多种内存分配方式。 参考：http://blog.csdn.net/yano_nankai/article/details/50957578#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95mark-compact-%E8%80%81%E5%B9%B4%E4%BB%A3 待阅读：http://blog.csdn.net/maydaysar/article/details/56839617https://my.oschina.net/lock0818/blog/1502746https://www.jianshu.com/p/54eb60cfa7bdhttp://www.bijishequ.com/detail/397600?p=https://juejin.im/post/5a72d8136fb9a01cb9133c39https://github.com/devnan/java-studyhttp://www.importnew.com/23792.htmlhttp://blog.csdn.net/hipilee/article/details/78487848http://blog.csdn.net/hsk256/article/details/49104955 GC(垃圾处理机制)面试题: http://blog.csdn.net/nysyxxg/article/details/8789358http://blog.csdn.net/alwaystiys/article/details/22279181http://blog.csdn.net/nysyxxg/article/details/8789358 印象笔记中关于jvm的总结：待整理]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据分析准备：专题/竞赛/教学]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12%2F</url>
    <content type="text"><![CDATA[「需输入密码」 Decrypt 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]]></content>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之十二&十三]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-7%2F</url>
    <content type="text"><![CDATA[第五部分 高效并发第十二章 Java 内存模型与线程并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类 “压榨” 计算机运算能力的最有力武器。 12.1 概述 多任务处理在现代计算机操作系统中几乎已是一项必备的功能了； 除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景； 服务端是 Java 语言最擅长的领域之一，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持，幸好 Java 语言和虚拟机提供了许多工具，把并发编码的门槛降低了不少； 12.2 硬件的效率与一致性 绝大多数的运算任务不可能只靠处理器计算就能完成，处理器至少要与内存交互，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了； 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性；为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI、MOSI、Synapse、Firefly 及 Dragon Protocol 等； 本章将会多次提到内存模型一词，可以理解在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；不同架构的物理机器可以拥有不一样的内存模型，而 Java 虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问具有很高的可比性； 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的； 12.3 Java 内存模型Java 虚拟机规范中视图定义一种 Java 内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 12.3.1 主内存与工作内存 Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节；此处的变量与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享； Java 内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量； 这里所讲的主内存、工作内存与第二章所讲的 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的；线程、主内存和工作内存的关系如下所示： 12.3.2 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下八种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量的某些操作在某些平台允许有例外）： lock unlock read load use assign store write 基于理解难度和严谨性考虑，最新的 JSR-133 文档中，已经放弃采用这八种操作去定义 Java 内存模型的访问协议了，后面将会介绍一个等效判断原则 – 先行发生原则，用来确定一个访问在并发环境下是否安全； 12.3.3 对于 volatile 型变量的特殊规则 关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制； 当一个变量定义为 volatile 之后，它将具备两种特性：第一是保证此变量对所有线程的可见性，这里的可见性是指当一个线程修改了这个变量的值，新的值对于其他线程来说是可以立即得知的，而普通的变量的值在线程间传递均需要通过主内存来完成；另外一个是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致； volatile 变量在各个线程的工作内存中不存在一致性问题，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的； 在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：运算结果并不依赖变量的当前值或者能够确保只有单一的线程修改变量的值、变量不需要与其他的状态变量共同参与不变约束； volatile 变量读操作的性能消耗与普通变量几乎没有任何差别，但是写操作则可能会慢一些；不过大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求； 12.3.4 对于 long 和 double 型变量的特殊规则 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定； 但允许虚拟机选择把这些操作实现为具有原子性的操作，目前各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待； 12.3.5 原子性、可见性与有序性 原子性（Atomicity）：由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write；在 synchronized 块之间的操作也具备原子性； 可见性（Visibility）：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了 volatile 之外，Java 还有 synchronized 和 final 关键字能实现可见性； 有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性； 12.3.6 先行发生原则 先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等； 下面是 Java 内存模型下一些天然的先行发生关系：程序次序规则、管程锁定规则、volatile 变量规则、线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性； 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准； 12.4 Java 与线程12.4.1 线程的实现 线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度； Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的； 实现线程主要有三种方式：使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）、使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）和使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险）； 对于 Sun JDK 来说，它的 Windows 版与 Linux 版都是使用一对一的线程模型实现的，一条 Java 线程就映射到一条轻量级进程之中，因为 Windows 和 Linux 系统提供的线程模式就是一对一的； 12.4.2 Java 线程调度 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（线程的执行时间由线程本身来控制）和抢占式线程调度（线程由系统来分配执行时间，线程的切换不由线程本身来决定）； Java 语言一共设置了 10 个级别的线程优先级，不过线程优先级并不是太靠谱，原因就是操作系统的线程优先级不见得总是与 Java 线程的优先级一一对应，另外优先级还可能被系统自行改变； 12.4.3 状态转换 Java 语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。它们之间相互的转换关系如下所示： 12.5 本章小结本章我们首先了解了虚拟机 Java 内存模型的结构及操作，然后讲解了原子性、可见性、有序性在 Java 内存模型中的体现，最后介绍了先行发生原则的规则及使用。另外，我们还了解了线程在 Java 语言之中是如何实现的。 在本章主要介绍了虚拟机如何实现并发，而在下一章我们主要关注点将是虚拟机如何实现高效，以及虚拟机对我们编写的并发代码提供了什么样的优化手段。 第十三章 线程安全与锁优化13.1 概述 首先需要保证并发的正确性，然后在此基础上实现高效； 13.2 线程安全Brian Goetz 对线程安全有一个比较恰当的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 13.2.1 Java 语言中的线程安全 我们可以将 Java 语言中各个操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立； 不可变：不可变带来的安全性是最简单和最纯粹的，如 final 的基本数据类型；如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如 String 类的 substring、replace 方法；Number 类型的大部分子类都符合不可变要求的类型，但是 AtomicInteger 和 AtomicLong 则并非不可变的； 线程绝对安全：Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全；比如 java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了； 线程相对安全：是我们通常意义上所讲的线程安全，在 Java 语言中，大部分的线程安全类都属于这种类型； 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况； 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java 语言中很少出现； 13.2.2 线程安全的实现方法 互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用，而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式；Java 中最基本的互斥同步手段就是 synchronized 关键字，它对同一个线程来说是可重入的且会阻塞后面其他线程的进入；另外还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步，相比 synchronized 关键字 ReentrantLock 增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件； 非阻塞同步：互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略；随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步；Java 并发包的整数原子类，其中的 compareAndSet 和 getAndIncrement 等方法都使用了 Unsafe 类的 CAS 操作； 无同步方案：要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码； 13.3 锁优化13.3.1 自旋锁与自适应自旋 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力；另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁；为了让线程等待，我们只需让线程执行一个忙循环，这些技术就是所谓的自旋锁； 在 JDK 1.6 已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源； 在 JDK 1.6 中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定； 13.3.2 锁消除 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除； 锁消除的主要判断依据来源于逃逸分析的数据支持； 13.3.3 锁粗化 原则上总是推荐将同步块的作用范围限制得尽量小 – 只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁； 但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗； 13.3.4 轻量级锁 轻量级锁是 JDK 1.6 之中加入的新型锁机制，它是相对于使用操作系统互斥量来实现的传统锁而言的；它并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗； 要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从 HotSpot 虚拟机的对象的内存布局开始介绍；HotSpot 虚拟机的对象头分为两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄等，这部分官方称之为 Mark Word，是实现轻量级锁和偏向锁的关键，另外一部分用于存储指向方法区对象类型数据的指针； Mark Word 被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，在 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0；在其他状态（轻量级锁定、重量级锁定、GC 标志、可偏向）下对象的存储内容如下： 在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的 Mark Word 的拷贝（官方称之为 Displaced Mark Word）；然后虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果更新成功了那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位将转变为 “00”，即表示此对象处于轻量级锁定状态；如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了；如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为 “10”，Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进行阻塞状态； 轻量级锁能提升程序同步性能的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据； 13.3.5 偏向锁 偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能；如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了； 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 假设当前虚拟机启动了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为 “01”，即偏向模式；同时使用 CAS 操作把获取到这个锁的线程 ID 记录在对象的 Mark Word 之中；如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如上面介绍的轻量级锁那样执行；偏向锁、轻量级锁的状态转化以及对象 Mark Work 的关系如下图所示： 偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化； 本章小结本章介绍了线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运行原理，并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part7/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之十&十一]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-6%2F</url>
    <content type="text"><![CDATA[第四部分 程序编译与代码优化第十章 早期（编译器）优化10.1 概述 前端编译器（或叫编译器前端）：把.java 文件转变为.class 文件的过程，比如 Sun 的 javac、Eclipse JDT 中的 ECJ； 后端运行编译器（JIT 编译器）：把字节码转变为机器码的过程，比如 HotSpot VM 的 C1、C2 编译器； 静态提前编译器（AOT 编译器）：直接把 *.java 文件编译成本地机器代码的过程，比如 GNU Compiler for the Java； 本章主要针对第一类，把第二类的编译过程留到下一章讨论； javac 这类编译器对代码运行效率几乎没有任何优化措施，虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样那些不是由 javac 产生的 Class 文件也同样能享受到编译器优化所带来的好处； javac 做了许多针对 Java 语言编码过程的优化措施来改善程序员的编码风格和提高编码效率；可以说，Java 中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译器的优化过程对于程序编码来说关系更加密切； 10.2 javac 编译器javac 编译器本身就是一个由 Java 语言编写的程序，这为纯 Java 的程序员了解它的编译过程带来了很大的便利。 10.2.1 javac 的源码与调试 javac 的源码存放在 JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac，除了 JDK 自身的 API 外，就只引用了 JDK_SRC_HOME/langtools/src/share/classes/com/sun/* 里面的代码； 导入 javac 的源码后就可以运行 com.sun.tools.javac.Main 的 main 方法来执行编译了； javac 编译过程大概可以分为 3 个过程：解析与填充符号表过程、插入式注解处理器的注解处理过程、分析与字节码生成过程； 10.2.2 解析与填充符号表 解析步骤由 parseFiles 方法完成； 词法分析将源代码的字符流转变为标记（Token）集合，由 com.sun.tools.javac.parser.Scanner 类完成； 语法分析是根据 Token 序列构造抽象语法树（AST，一种用来描述程序代码语法结构的树形表示方式）的过程，由 com.sun.tools.javac.parser.Parser 类实现，AST 由 com.sun.tools.javac.tree.JCTree 类表示； 填充符号表：由 enterTrees 方法完成；符号表是由一组符号地址和符号信息构成的表格，所登记的信息在编译的不同阶段都要用到，在语义分析中用于语义检查，在目标代码生成时用于地址分配；由 com.sun.tools.javac.comp.Enter 类实现； 10.2.3 注解处理器 在 JDK 1.6 中实现了 JSR-269 规范，提供了一组插入式注解处理器的标准 API 在编译期间对注解进行处理，可以读取、修改、添加抽象语法树中的任意元素； 通过插入式注解处理器实现的插件在功能上有很大的发挥空间，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情； javac 中，在 initProcessAnnotations 初始化，在 processAnnotations 执行，如果有新的注解处理器，通过 com.sun.tools.javac.processing.JavacProcessingEnviroment 类的 doProcessing 方法生成一个新的 JavaCompiler 对象对编译的后续步骤进行处理； 10.2.4 语义分析与字节码生成 语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，主要包括标注检查、数据及控制流分析两个步骤； 解语法糖（Syntactic Sugar，添加的某种对语言功能没有影响但方便程序员使用的语法）：Java 中最常用的语法糖主要是泛型、变长参数、自动装箱等，他们在编译阶段还原回简单的基础语法结构；在 com.sun.tools.javac.comp.TransTypes 类和 com.sun.tools.javac.comp.Lower 类中完成； 字节码生成：javac 编译的最后一个阶段，不仅仅是把前面各个步骤所生成的信息转化为字节码写入到磁盘中，编译器还进行了少量的代码添加和转换工作（如实例构造器方法和类构造器方法）；由 com.sun.tools.javac.jvm.ClassWriter 类的 writeClass 方法输出字节码，生成最终的 Class 文件； 10.3 Java 语法糖的味道10.3.1 泛型与类型擦除 Java 语言的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型了，并且在相应的地方插入了强制转换，这种基于类型擦除的泛型实现是一种伪泛型； JCP 组织引入了 Signature 属性，它的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，这样我们就可以通过反射手段获取参数化类型； 10.3.2 自动装箱、拆箱与遍历循环 它们的实现比较简单，但却是 Java 语言里使用最多的语法糖； 10.3.3 条件编译 Java 语言之中并没有使用预处理器，因为 Java 编译器并非一个个地编译 Java 文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译； Java 语言可以使用条件为常量的 if 语句进行条件编译；编译器将会把分支中不成立的代码块消除掉； 10.4 实战：插入式注解处理器 实战目标：使用注解处理器 API 来编写一款拥有自己编码风格的校验工具； 代码实现：继承 javax.annotation.processing.AbstractProcessor，实现 process 方法，从第一个参数 annotations 获取此注解处理器所要处理的注解集合，从第二个参数 roundEnv 中访问到当前这个 Round 中的语法树节点；另外还有一个很常用的实例变量 processingEnv，它代表了注解处理器框架提供的一个上下文环境；可以配合使用的 @SupportedAnnotationTypes 和 @SupportedSourceVersion 注解； 10.5 本章小结本章我们从编译器源码实现的层次上了解了 javac 源代码编译为字节码的过程，分析了 Java 语言中多种语法糖的前因后果，并实战实习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。下一章我们将会介绍即时编译器的运作和优化过程。 第十一章 晚期（运行期）优化11.1 概述 为了提高热点代码的执行效率，在运行时虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（JIT）； JIT 不是虚拟机必需的，但是其编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分； 11.2 HotSpot 虚拟机内的即时编译器11.2.1 解释器与编译器 当程序需要迅速启动和执行的时候，解释器可以先发挥作用，省去编译的时间立即执行；在程序运行后，随着时间的推移，编译器把越来越多的代码编译成本地代码提升执行效率； HotSpot 虚拟机中内置了两个即时编译器，分别为 Client Compiler 和 Server Compiler，或简称为 C1 编译器和 C2 编译器；虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，也可以使用 “-client” 或“-server”参数去强制指定运行模式； 想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机还会逐渐启动分层编译的策略：第 0 层，程序解释运行；第 1 层，C1 编译；第 2 层，C2 编译； 实施分层编译后，Client Compiler 和 Server Compiler 将会同时工作，许多代码都可能会被多次编译，用 Client Compiler 获取更高的编译速度，用 Server Compiler 来获取更好的编译质量，在解释执行的时候也无须再承担性能收集监控信息的任务； 11.2.2 编译对象与触发条件 被 JIT 编译的热点代码有两类：被多次调用的方法、被多次执行的循环体；对于前者编译器会以整个方法作为编译对象，属于标准的 JIT 编译方式；对于后者尽管编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译对象，这种编译方式称之为栈上替换（OSR 编译）； 热点探测：基于采样的热点探测和基于计数器的热点探测，在 HotSpot 虚拟机中使用的是第二种，通过方法计数器和回边计数器进行热点探测。方法调用计数器触发的即时编译交互过程如下图所示： 11.2.3 编译过程 对于 Client Compiler 来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了很多耗时较长的全局优化手段；第一阶段一个平台独立的前端将字节码构造成一个高级中间代码表示（HIR），第二阶段一个平台相关的后端从 HIR 中产生低级中间代码表示（LIR），最后阶段是在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。其大致过程如下所示： Server Compiler 是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到 GNU C++ 编译器使用 - 02 参数时的优化强大，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实现如范围检查消除、空值检查消除等 Java 语言特性密切相关的优化技术； 11.2.4 查看及分析即时编译结果 本节的运行参数有一部分需要 Debug 或 FastDebug 版虚拟机的支持； 要知道某个方法是否被编译过，可以使用参数 - XX:+PrintCompilation 要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来； 还可以加上参数 - XX:+PrintInlining 要求虚拟机输出方法内联信息，输出内容如下： 除了查看那些方法被编译之外，还可以进一步查看即时编译器生成的机器码内容，这个需要结合虚拟机提供的反汇编接口来阅读； 11.3 编译优化技术11.3.1 优化技术概览 11.3.2 公共子表达式消除 如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成为了公共子表达式，只需要直接用前面计算过的表达式结果代替 E 就可以了； 11.3.3 数组边界检查消除 对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判断，对于拥有大量数组访问的程序代码无疑是一种性能负担； 11.3.4 方法内联 除了消除方法调用的成本外更重要的意义是为其他优化手段建立良好的基础； 为了解决虚方法的内联问题，引入了类型继承关系分析（CHA）技术和内联缓存（Inline Cache）来完成方法内联； 11.3.5 逃逸分析 逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用（方法逃逸），甚至还可能被外部线程所访问到（线程逃逸）；如果能证明一个对象不会逃逸到方法或线程之外，则可能为这个变量进行一些高效的优化，比如栈上分配（减轻垃圾收集的压力）、同步消除（读写不会有竞争）、标量替换； 11.4 Java 与 C/C++ 的编译器对比 Java 虚拟机的即时编译器与 C/C++ 的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些劣势：即时编译器运行占用用户程序运行时间、动态类型安全语言导致的频繁检查、运行时对方法接收者进行多态选择的频率大、可以动态扩展导致很多全局的优化难以运行、大部分对象在堆上分配导致垃圾收集机制的效率低； Java 语言的特性换取了开发效率的提升、还有许多优化是静态优化编译器不好做的，比如别名分析、还有一些以运行期性能监控为基础的优化措施如调用频率预测等； 11.5 本章小结本章我们着重了解了虚拟机的热点探测方法、HotSpot 的即时编译器、编译触发条件以及如何从虚拟机外部观察和分析 JIT 编译的数据和结果，还选择了集中场景的编译期优化技术进行讲解。对 Java 编译器的深入了解，有助于在工作中分辨哪些代码是编译器可以帮我们处理的，哪些代码需要自己调节以便更适合编译器的优化。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part6/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之九]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-5%2F</url>
    <content type="text"><![CDATA[第九章 类加载及执行子系统的案例与实战9.1 概述 在 Class 文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不多； 能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路； 9.2 案例分析9.2.1 Tomcat：正统的类加载器架构 Java Web 服务器：部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离又要可以互相共享；尽可能保证自身的安全不受部署的 Web 应用程序影响；要支持 JSP 生成类的热替换； 上图中，灰色背景的三个类加载器是 JDK 默认提供的类加载器，而 CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和 WebappClassLoader 是 Tomcat 自己定义的类加载器，分别加载 / common/（可被 Tomcat 和 Web 应用共用）、/server/（可被 Tomcat 使用）、/shared/（可被 Web 应用使用）和 / WebApp/WEB-INF/（可被当前 Web 应用使用）中的 Java 类库，Tomcat 6.x 把前面三个目录默认合并到一起变成一个 / lib 目录（作用同原先的 common 目录）； 9.2.2 OSGI：灵活的类加载架构 OSGI 的每个模块称为 Bundle，可以声明它所依赖的 Java Package（通过 Import-Package 描述），也可以声明它允许导出发布的 Java Package（通过 Export-Package 描述）； 除了更精确的模块划分和可见性控制外，引入 OSGI 的另外一个重要理由是基于 OSGI 的程序很可能可以实现模块级的热插拔功能； OSGI 的类加载器之间只有规则，没有固定的委派关系；加载器之间的关系更为复杂、运行时才能确定的网状结构，提供灵活性的同时，可能会产生许多的隐患； 9.2.3 字节码生成技术与动态代理的实现 在 Java 里面除了 javac 和字节码类库外，使用字节码生成的例子还有 Web 服务器中的 JSP 编译器、编译时植入的 AOP 框架和很常用的动态代理技术等，这里选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的； 动态代理的优势在于实现了在原始类和接口还未知的时候就确定类的代理行为，可以很灵活地重用于不同的应用场景之中； 以下的例子中生成的代理类 “$Proxy0.class” 文件可以看到代理为传入接口的每一个方法统一调用了 InvocationHandler 对象的 invoke 方法；其生成代理类的字节码大致过程其实就是根据 Class 文件的格式规范去拼接字节码； 9.2.4 Retrotranslator：跨越 JDK 版本 Retrotranslator 的作用是将 JDK 1.5 编译出来的 Class 文件转变为可以在 JDK 1.4 或 JDK 1.3 部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持 JDK 1.5 中新增的集合改进、并发包以及对泛型、注解等的反射操作； JDK 升级通常包括四种类型：编译器层面的做的改进、Java API 的代码增强、需要再字节码中进行支持的活动以及虚拟机内部的改进，Retrotranslator 只能模拟前两类，第二类通过独立类库实现，第一类则通过 ASM 框架直接对字节码进行处理； 9.3 实战：自己动手实现远程执行功能 目标：不依赖 JDK 版本、不改变原有服务端程序的部署，不依赖任何第三方类库、不侵入原有程序、临时代码的执行结果能返回到客户端； 思路：如何编译提交到服务器的 Java 代码（客户端编译好上传 Class 文件而不是 Java 代码）、如何执行编译之后的 Java 代码（要能访问其他类库，要能卸载）、如何收集 Java 代码的执行结果（在执行的类中把 System.out 的符号引用替换为我们准备的 PrintStream 的符号引用）； 具体实现：HotSwapClassLoader 用于实现同一个类的代码可以被多次加载，通过公开父类 ClassLoader 的 defineClass 实现；HackSystem 是为了替换 java.lang.System，它直接修改 Class 文件格式的 byte[] 数组中的常量池部分，将常量池中指定内容的 CONSTANT_Utf8_info 常量替换为新的字符串；ClassModifier 涉及对 byte[] 数组操作的部分，主要是将 byte[] 与 int 和 String 互相转换，以及把对 byte[] 数据的替换操作封装在 ByteUtils 类中；经过 ClassModifier 处理过的 byte[] 数组才会传给 HotSwapClassLoader.loadByte 方法进行类加载；而 JavaClassExecutor 是提供给外部调用的入口； 9.4 本章小结只有了解虚拟机如何执行程序，才能更好地理解怎样写出优秀的代码。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之八]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-4%2F</url>
    <content type="text"><![CDATA[第八章 虚拟机字节码执行引擎8.1 概述 执行引擎是 Java 虚拟机最核心的组成部分之一，区别于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行哪些不被硬件直接支持的指令集格式； 在虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，该模型成为各种虚拟机执行引擎的统一外观； 在不同的虚拟机实现里面，执行引擎在执行 Java 代码时可能会有解释执行和编译执行两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观来说是一致的：输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。 8.2 运行时栈帧结构 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素； 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程； 栈帧需要分配多少内存在编译时就完全确定并写入到方法表的 Code 属性之中了，不会受到程序运行期变量数据的影响； 对于执行引擎来说，在活动线程中只有位于栈顶的栈帧才算有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。 8.2.1 局部变量表 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，Code 属性的 max_locals 确定了该方法所需要分配的局部变量表的最大容量； 其容量以变量槽（Variable Slot）为最小单位，虚拟机规范允许 Slot 的长度随处理器、操作系统或虚拟机的不同而发生变化； 一个 Slot 可以存放一个 32 位以内的数据类型，包括 boolean、byte、char。short、int、float、reference 和 returnAddress 这八种类型；对于 64 位的数据类型（long 和 double），虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间； 8.2.2 操作数栈 也常称为操作栈，它是一个后入先出栈；Code 属性的 max_stacks 确定了其最大深度； 比如整数加法的字节码指令 iadd 在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个 int 型的数值，当执行这个指令时，会将这两个 int 值出栈并相加，然后将相加的结果入栈； 操作数栈中元素的类型必须与字节码指令的序列严格匹配； Java 虚拟机的解释执行引擎称为 “基于栈的执行引擎”，其中所指的栈就是操作数栈； 8.2.3 动态连接 每个栈帧都包含一个执行运行时常量池中该栈帧所属方法引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）； Class 文件的常量池的符号引用，有一部分在类加载阶段或者第一次使用时就转换为直接引用，这种称为静态解析，而另外一部分在每一次运行期间转换为直接引用，这部分称为动态连接； 8.2.4 方法返回地址 退出方法的方式：正常完成出口和异常完成出口； 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能只需的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数中，调整 PC 计数器的值以只需方法调用指令后面的一套指令等； 8.2.5 附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分完成取决于具体的虚拟机实现； 8.3 方法调用 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本即调用哪一个方法，暂时还不涉及方法内部的具体运行过程； Class 文件的编译过程中不报警传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂； 8.3.1 解析 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用称为解析； 在 Java 语言中符合编译器可知、运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类； 五条方法调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic； 解析调用是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用；而分派调用则可能是静态的也可能是动态的； 8.3.2 分派 静态分派：“Human man = new Man();” 语句中 Human 称为变量的静态类型，后面的 Man 称为变量的实际类型；静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译器可知的；而实际类型的变化在运行期才确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么；编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的；所有根据静态类型来定位方法执行版本的分派动作称为静态分派，其典型应用是方法重载； 动态分派：invokevirtual 指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质；我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派； 单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派分为单分派（根据一个宗量对目标方法进行选择）与多分派（根据多于一个宗量对目标方法进行选择）两种；今天的 Java 语言是一门静态多分派、动态单分派的语言； 虚拟机动态分派的实现：在方法区中建立一个虚方法表（Virtual Method Table），使用虚方法表索引来代替元数据查找以提高性能；方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化值后，虚拟机会把该类的方法表也初始化完毕； 8.3.3 动态类型语言支持 JDK 1.7 发布增加的 invokedynamic 指令实现了 “动态类型语言” 支持，也是为 JDK 1.8 顺利实现 Lambda 表达式做技术准备； 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器，比如 JavaScript、Python 等； Java 语言在编译期间就将方法完整的符号引用生成出来，作为方法调用指令的参数存储到 Class 文件中；这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息；而在 ECMAScript 等动态语言中，变量本身是没有类型的，变量的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型；变量无类型而变量值才有类型，这个特点也是动态类型语言的一个重要特征； JDK 1.7 实现了 JSR-292，新加入的 java.lang.invoke 包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法外，提供一种新的动态确定目标方法的机制，称为 MethodHandle； 从本质上讲，Reflection（反射）和 MethodHandle 机制都是在模拟方法调用，但 Reflection 是在模拟 Java 代码层次的方法调用，而 MethodHandle 是在模拟字节码层次的方法调用，前者是重量级，而后者是轻量级；另外前者只为 Java 语言服务，后者可服务于所有 Java 虚拟机之上的语言； 每一处含有 invokedynamic 指令的位置都称为 “动态调用点 (Dynamic Call Site)”，这条指令的第一个参数不再是代表符号引用的 CONSTANT_Methodref_info 常量，而是 CONSTANT_InvokeDynamic_info 常量（可以得到引导方法、方法类型和名称）； invokedynamic 指令与其他 invoke 指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定的； 8.4 基于栈的字节码解释执行引擎上节主要讲虚拟机是如何调用方法的，这节探讨虚拟机是如何执行方法中的字节码指令的。 8.4.1 解释执行 只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才比较确切； Java 语言中，javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程；因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现； 8.4.2 基于栈的指令集与基于寄存器的指令集 Java 编译器输出的指令集，基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，它们依赖操作数栈进行工作； 基于栈的指令集主要的优点是可移植性，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；主要缺点是执行速度相对来说会稍慢一点； 8.4.3 基于栈的解释器执行过程一段简单的算法代码 上述代码的字节码表示 123456789101112131415public int calc();Code:Stack=2, Locals=4, Args_size=10:bipush 1002:istore_13:sipush 2006:istore_27:sipush 30010:istore_311:iload_112:iload_213:iadd14:iload_315:imul16:ireturn javap 提示这段代码需要深度为 2 的操作数栈和 4 个 Slot 的局部变量空间，作者根据这些信息画了示意图来说明执行过程中的变化情况： 执行偏移地址为 0 的指令 执行偏移地址为 2 的指令 执行偏移地址为 11 的指令 执行偏移地址为 12 的指令 执行偏移地址为 13 的指令 执行偏移地址为 14 的指令 执行偏移地址为 16 的指令 注：上面的执行过程仅仅是一种概念模型，虚拟机中解析器和即时编译器会对输入的字节码进行优化。 8.5 本章小结本章分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码以及执行代码时涉及的内存结构。这第六、七、八三章中，我们针对 Java 程序是如何存储的、如何载入的以及如何执行的问题进行了讲解，下一章一起看看这些理论知识在具体开发中的经典应用。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记七：虚拟机类加载机制（重点）]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-3%2F</url>
    <content type="text"><![CDATA[第七章 虚拟机类加载机制（重点）7.1 概述 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成，这虽然增量一些性能开销，但是会为 Java 应用程序提供高度的灵活性。 7.2 类加载的时机 类的整个生命周期：加载、验证、准备、解析、初始化、使用和卸载；其中验证、准备和解析统称为连接； 虚拟机规范没有强制约束类加载的时机，但严格规定了有且只有 5 种情况必须立即对类进行初始化：遇到 new、getstatic、putstatic 和 invokestatic 指令；对类进行反射调用时如果类没有进行过初始化；初始化时发现父类还没有进行初始化；虚拟机启动指定的主类；动态语言中 MethodHandle 实例最后解析结果 REF_getStatic 等的方法句柄对应的类没有初始化时； 7.3 类加载的过程7.3.1 加载 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口； 7.3.2 验证 验证是连接阶段的第一步，其目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全； 验证阶段是非常重要的，这个阶段是否严谨决定了 Java 虚拟机是否能承受恶意代码的攻击； 校验动作：文件格式验证（基于二进制字节流）、元数据验证（对类的元数据语义分析）、字节码验证（对方法体语义分析）、符号引用验证（对类自身以外的信息进行匹配性校验）； 7.3.3 准备 正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在这个方法区中进行分配； 需要强调两点：这时候内存分配的仅包括类变量，而不包括类实例变量；这里所说的初始化通常情况下是数据类型的零值，真正的赋值是在初始化阶段，如果是 static final 的则是直接赋值； 7.3.4 解析 解析阶段是虚拟机将常量池内的符号引用（如 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等 7 种）替换为直接引用的过程； 符号引用可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中；而直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，它和虚拟机实现的内存布局相关，引用的目标必定以及在内存中存在； 对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可以对第一次解析的结果进行缓存； 7.3.5 初始化 是类加载过程的最后一步，真正开始执行类中定义的 Java 程序代码（或者说是字节码）； 初始化阶段是执行类构造器方法的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的； 方法与类的构造函数（或者说是实例构造器方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的方法执行之前，父类的方法已执行完毕； 执行接口的方法不需要先执行父接口的方法，只有当父接口中定义的变量使用时父接口才会初始化，接口的实现类在初始化时也一样不会执行接口的方法； 方法初始化是加锁阻塞等待的，应当避免在方法中有耗时很长的操作； 7.4 类加载器 虚拟机设计团队把类加载阶段的 “通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到虚拟机外部去实现，实现这个动作的代码模块称为类加载器； 这时 Java 语言的一项创新，也是 Java 语言流行的重要原因，在类层次划分、OSGI、热部署、代码加密等领域大放异彩； 7.4.1 类与类加载器 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每一个类加载器都拥有一个独立的类名称空间； 比较两个类是否相等（如 Class 对象的 equals 方法、isAssignableFrom 方法、isInstance 方法），只有在这两个类是由同一个类加载器加载的前提下才有意义； 7.4.2 双亲委派模型 三种系统提供的类加载器：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）； 双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器，这里一般不会以继承的关系来实现，而是使用组合的关系来复用父加载器的代码； 其工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载； 这样的好处是 Java 类随着它的类加载器具备了一种带有优先级的层次关系，对保证 Java 程序的稳定运作很重要； 实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass 方法中，逻辑清晰易懂； 7.4.3 破坏双亲委派模型 上一小节的双亲委派模型是 Java 设计者推荐给开发者的类加载器实现方法，但不是一个强制性的约束模型； 典型的两种情况：为了解决 JNI 接口提供者（SPI）引入的线程上下文类加载器；为了程序动态性加强的 OSGI 的 Bundle 类加载器； 7.5 本章小结本章介绍了类加载过程的加载、验证、准备、解析和初始化五个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。下一章将一起看看虚拟机如果执行定义在 Class 文件里的字节码。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/推荐扩展阅读：http://blog.csdn.net/javazejian/article/details/73413292]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记六：类文件结构（了解）]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-2%2F</url>
    <content type="text"><![CDATA[第三部分 虚拟机执行子系统第六章 类文件结构（了解）代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 6.1 概述由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。 6.2 无关性的基石 Java 刚诞生的宣传口号：一次编写，到处运行（Write Once, Run Anywhere）。其最终实现在操作系统的应用层：Sun 公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码。 字节码（ByteCode）是构成平台无关的基石； 另外虚拟机的语言无关性也越来越被开发者所重视，JVM 设计者在最初就考虑过实现让其他语言运行在 Java 虚拟机之上的可能性，如今已发展出一大批在 JVM 上运行的语言，比如 Clojure、Groovy、JRuby、Jython、Scala； 实现语言无关性的基础仍是虚拟机和字节码存储格式，Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与 Class 文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成 Class 文件，从而在虚拟机上运行。 6.3 Class 类文件的结构 Class 文件是一组以 8 个字节为基础单位的二进制流（可能是磁盘文件，也可能是类加载器直接生成的），各个数据项目严格按照顺序紧凑地排列，中间没有任何分隔符； Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，其中只有两种数据类型：无符号数和表； 无符号数属于基本的数据类型，以 u1、u2、u4 和 u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值； 表是由多个无符号数获取其他表作为数据项构成的复合数据类型，习惯以 “_info” 结尾； 无论是无符号数还是表，当需要描述同一个类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据未某一类型的集合。 下面我以自己本机写的一个简单的 Java 文件来学习其中各个部分的含义： 使用 javac 编译成 TestClass.class 文件，使用 16 进制打开： 使用 javap 命令输出 Class 文件信息： 6.3.1 魔数和版本 Class 文件的头 4 个字节，唯一作用是确定文件是否为一个可被虚拟机接受的 Class 文件，固定为 “0xCAFEBABE”。 第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号（0x0034 为 52，对应 JDK 版本 1.8）；能向下兼容之前的版本，无法运行后续的版本； 6.3.2 常量池 常量池可以理解为 Class 文件之中的资源仓库，是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项之一； 由于常量池中的常量数量不固定，因此需要在常量池前放置一项 u2 类型的数据来表示容量，该值是从 1 开始的，上图的 0x0013 为十进制的 19，代表常量池中有 18 项常量，索引值范围为 1~18； 常量池主要存放两大类常量：字面量（Literal，笔记接近 Java 的常量概念，比如文本字符串和 final 常量等）和符号引用（Symbolic References，主要包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）； Java 代码在 javac 编译时不会有 “连接” 这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接；所以在 Class 文件不会保存各个方法、字段和最终内存布局信息；当虚拟机运行时需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中； JDK 1.7 中常量池共有 14 种不同的表结构数据，这些表结构开始的第一位是一个 u1 类型的标志位，代表当前常量的类型，具体如下图所示： 之所以说常量池是最繁琐的数据就是因为这 14 种常量类型都有自己的结结构。可以结合下图中各个表结构的说明和之前使用 javap 解析的文件内容一起看。 第 1 项：0x0A（15 标志为方法句柄），0x0004（指向第 4 项的类描述符），0x000F（指向第 15 项的名称及类型描述符）； 第 2 项：0x09（9 标志为字段符号引用），0x0003（指向第 3 项类描述符），0x0010（指向第 16 项的名称及类型描述符）； 第 3 项：0x07（7 标志为类符号引用），0x0011（指向第 17 项全限定名常量项）； 第 4 项：0x07（7 标志为类符号引用），0x0012（指向第 18 项全限定名常量项）； 第 5 项：0x01（1 标志为 UTF - 字符串常量），0x0001（字符串占用 1 个字节），6D（字符 “m”）； 第 6 项：0x01（1 标志为 UTF - 字符串常量），0x0001（字符串占用 1 个字节），49（字符 “I”）； 第 7 项：0x01（1 标志为 UTF - 字符串常量），0x0006（字符串占用 6 个字节），3C 69 6E 69 74 3E（字符 “”）； 第 8 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），28 29 56（字符 “()V”）； 第 9 项：0x01（1 标志为 UTF - 字符串常量），0x0004（字符串占用 4 个字节），43 6F 64 65（字符 “Code”）； 第 10 项：0x01（1 标志为 UTF - 字符串常量），0x000F（字符串占用 15 个字节），4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65（字符 “LineNumberTable”）； 第 11 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），69 6E 63（字符 “inc”）； 第 12 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），28 29 49（字符 “()I”）； 第 13 项：0x01（1 标志为 UTF - 字符串常量），0x000A（字符串占用 10 个字节），53 6F 75 72 63 65 46 69 6C 65（字符 “SourceFile”）； 第 14 项：0x01（1 标志为 UTF - 字符串常量），0x000E（字符串占用 14 个字节），54 65 73 74 43 6C 61 73 73 2E 6A 61 76 61（字符 “TestClass.java”）； 第 15 项：0x0C（12 标志为名称和类型符号引用），0x0007（指向第 7 项名称常量项）， 0x0008（指向第 8 项描述符常量项）； 第 16 项：0x0C（12 标志为名称和类型符号引用），0x0005（指向第 5 项名称常量项）， 0x0006（指向第 6 项描述符常量项）； 第 17 项：0x01（1 标志为 UTF - 字符串常量），0x001F（字符串占用 31 个字节），63 6F 6D 2F 67 69 6E 6F 62 65 66 75 6E 6E 79 2F 63 6C 61 7A 7A 2F 54 65 73 74 43 6C 61 73 73（字符 “com/ginobefunny/clazz/TestClas”）； 第 18 项：0x01（1 标志为 UTF - 字符串常量），0x0010（字符串占用 16 个字节），6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74（字符 “java/lang/Object”）； 6.3.3 访问标志 紧接在常量池后面的是两个字节的访问标志，用于标识类或接口的访问信息； 访问标志一个有 16 个标志位，但目前只采用了其中 8 位，本例子中的 0x0021 标识为一个 public 的普通类； 6.3.4 类索引、父类索引与接口索引集合 类索引：u2 类型的数据，用于确定类的全限定名。本例子中为 0x0003，指向常量池中第 3 项； 父类索引：u2 类型的数据，用于确定父类的全限定名。本例子中为 0x0004，指向常量池中第 4 项； 接口索引计算器：u2 类型的数据，用于表示索引集合的容量。本例子中为 0x0000，说明没有实现接口； 接口索引集合：一组 u2 类型的数据的集合，用于确定实现的接口（对于接口来说就是 extend 的接口）。本例子不存在。 6.3.5 字段表集合 用于描述接口或者类中声明的变量，包括类级变量和实例级变量，但不包括方法内部声明的局部变量；它不会列出从父类和超类继承而来的字段； 0x0001 表示这个类只有一个字段表数据； 字段修饰符放在 access_flag 中，是一个 u2 的数据类型，0x0002 表示为 private 的属性； 字段名称 name_index，是一个 u2 的数据类型，0x0005 表示该属性的名称为常量池的第 5 项； 字段描述符 descriptor_index，是一个 u2 的数据类型，0x0006 表示该属性的描述符为常量池的第 6 项，其值 “I” 表示类型为整形； 字段属性计算器和属性集合：0x0000 表示该例子中不存在； 6.3.6 方法表集合 和字段表集合的方式几乎一样； 方法里面的代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 Code 的属性里面； 0x0002 表示这个类有两个方法表数据，分别是编译器添加的实例构造器和源码中的方式 inc()； 第一个方法的访问标志是 0x0001（public 方法），名称索引值为 0x0007（常量池第 7 项，“”），描述符索引值为 0x0008（常量池第 8 项，“()V”），属性表计算器为 0x0001（有一项属性），属性名称索引为 0x0009（常量池第 9 项，“Code”）； 根据 “6.3.7.1 Code 属性” 说明，属性值的长度为 23（0x0000001D 表示 29，但需要减去属性名称索引和属性长度固定的 6 个字节长度），操作数栈深度的最大值为 1（0x0001，虚拟机运行时根据这个值来分配栈帧中操作栈深度），局部变量表所需要的存储空间为 1 个 Slot（0x0001，Slot 是内存分配的最小单位），字节码长度为 5（0x00000005），分别为 2A（aload_0，将第 0 个 Slot 中为 reference 类型的本地变量推送到操作数栈顶）、B7（invokespecial，以栈顶的 reference 类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private 方法或者它父类的方法，后面接着一个 u2 的参数指向常量池的方法引用）、0x0001（表示常量池的第 1 项，即 Object 类的方法）、B1（对应的指令为 return，返回值为 void）；显式异常表为空（0x0000，计数器为 0）；该 Code 属性还内嵌 1 个属性（0x0001），属性的名称索引为 0x000A（即 “LineNumberTable” 属性，用于记录对应的代码行数），该内嵌属性的长度为 6（0x00000006），对应的行数信息为源码的第 3 行（0x000100000003）； 第二个方法的访问标志是 0x0001（public 方法），名称索引值为 0x000B（常量池第 11 项，“inc”），描述符索引值为 0x000C（常量池第 12 项，“()I”），属性表计算器为 0x0001（有一项属性），属性名称索引为 0x0009（常量池第 9 项，“Code”）； 根据 “6.3.7.1 Code 属性” 说明，属性值的长度为 25（0x0000001F 表示 31，但需要减去属性名称索引和属性长度固定的 6 个字节长度），操作数栈深度的最大值为 2（0x0002），局部变量表所需要的存储空间为 1 个 Slot（0x0001），字节码长度为 7（0x00000007），分别为 2A（aload_0）、B4（getfield，后面接着一个 u2 的参数指向常量池的属性引用）、0x0002（表示常量池的第 2 项，即 TestClass 类的 m 属性）、04（对应的指令为 iconst_1）、60（对应的指令为 iadd，整形求和）、AC（对应的指令为 ireturn，返回值为整形）；显式异常表为空（0x0000，计数器为 0）；该 Code 属性还内嵌 1 个属性（0x0001），属性的名称索引为 0x000A（即 “LineNumberTable” 属性，用于记录对应的代码行数），该内嵌属性的长度为 6（0x00000006），对应的行数信息为源码的第 8 行（0x000100000008）； 6.3.7 属性表集合 在 Class 文件、字段表、方法表都可以携带自己的属性表集合； 属性表集合的限制较为宽松，不再要求严格的顺序，只要属性名不重复即可； 以下是 Java 虚拟机规范里预定义的虚拟机实现应当能识别的属性： 接着我们的例子的 Class 文件还有最后一段：0x0001 表示该 Class 有一个属性，0x000D 表示属性名索引为第 13 项（对应 “SourceFile”），0x00000002 表示该属性长度为 2，0x000E 表示该类的 SourceFile 名称为第 14 项（对应 “TestClass.java”）。 6.3.7.1 Code 属性Java 程序方法体中的代码经过 javac 编译后，字节码指令存放在 Code 属性，其属性表结构如下： 6.3.7.2 Exceptions 属性方法描述时 throws 关键字后面列举的异常，和 Code 属性里的异常表不同。其属性表结构如下： 6.3.7.3 LineNumberTable 属性用于描述 Java 源码行号与字节码行号之间的对应关系，它不是必须的，可以通过 javac -g:none 取消该信息。没有该信息的影响是运行时抛异常不会显示出错的行号，在代码调试时无法按照源码行来设置断点。 6.3.7.4 LocalVariableTable 属性用于描述栈帧中局部变量与 Java 源码中定义的变量之间的关系，它不是运行时必须的，可以通过 javac -g:none 取消该信息。如果没有这个属性，所有的参数名称都会丢失，取之以 arg0、arg1 这样的占位符来替代。 其中 local_variable_info 项代表了一个栈帧与源码中局部变量的关联，如下所示： 6.3.7.5 SourceFile 属性用于记录生成这个 Class 的源码文件名称，这个属性也是可选的。 6.3.7.6 ConstantValue 属性作用是通知虚拟机自动为静态变量赋值，只有被 static 关键字修饰的变量才可以用这个属性。对于非 static 类型的变量的赋值是在实例构造器方法中进行的；而对于类变量有两种方式：在类构造器方法中或者使用 ConstantValue 属性。目前 Sun javac 编译器的选择是：同时使用 final 和 static 修饰的变量且为基本数据类型或 String 类型使用 ConstantValue 属性初始化，否则使用初始化。 6.3.7.7 InnerClass 属性用于记录内部类与宿主类之间的关联。 其中 number_of_class 代表需要记录多少个内部类信息，每个内部类的信息都由一个 inner_class_info 表进行描述。 6.3.7.8 Deprecated 及 Synthetic 属性Deprecated（不推荐使用）和 Synthetic（不是由 Java 源码直接产生编译器自行添加的，有两个例外是实例构造器和类构造器）这两个属性都属于布尔属性，只存在有和没有的区别，没有属性值的概念。在属性结构中 attribute_length 的数据值必须为 0x00000000。 6.3.7.9 StackMapTable 属性这是一个复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 6.3.7.10 Signature 属性一个可选的定长属性，在 JDK 1.5 发布后增加的，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，则 Signature 属性会为它记录泛型签名信息。这主要是因为 Java 的泛型采用的是擦除法实现的伪泛型，在字节码中泛型信息编译之后统统被擦除，在运行期无法将泛型类型与用户定义的普通类型同等对待。通过 Signature 属性，Java 的反射 API 能够获取泛型类型。 6.3.7.11 BootstrapMethods 属性一个复杂的变长属性，位于类文件的属性表中，用于保存 invokedynamic 指令引用的引导方法限定符。 6.4 字节码指令简介Java 虚拟机的指令由一个字节长度的、代表着特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。 在指令集中大多数的指令都包含了其操作所对应的数据类型信息，如 iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中。 加载和存储指令：iload/iload 等（加载局部变量到操作栈）、istore/istore 等（从操作数栈存储到局部变量表）、bipush/sipush/ldc/iconst_（加载常量到操作数栈）、wide（扩充局部变量表访问索引）； 运算指令：没有直接支持 byte、short、char 和 boolean 类型的算术指令而采用 int 代替；iadd/isub/imul/idiv 加减乘除、irem 求余、ineg 取反、ishl/ishr 位移、ior 按位或、iand 按位与、ixor 按位异或、iinc 局部变量自增、dcmpg/dcmpl 比较； 类型转换指令：i2b/i2c/i2s/l2i/f2i/f2l/d2i/d2l/d2f； 对象创建与访问指令：new 创建类实例、newarray/anewarray/multianewarray 创建数组、getfield/putfield/getstatic/putstatic 访问类字段或实例字段、baload/iaload/aaload 把一个数组元素加载到操作数栈、bastore/iastore/aastore 将一个操作数栈的值存储到数组元素中、arraylength 取数组长度、instanceof/checkcast 检查类实例类型； 操作数栈管理指令：pop/pop2 一个或两个元素出栈、dup/dup2 复制栈顶一个或两个数组并将复制值或双份复制值重新压力栈顶、swap 交互栈顶两个数值； 控制转移指令：ifeq/iflt/ifnull 条件分支、tableswitch/lookupswitch 复合条件分支、goto/jsr/ret 无条件分支； 方法调用和返回指令：invokevirtual/invokeinterface/invokespecial/invokestatic/invokedynamic 方法调用、ireturn/lreturn/areturn/return 方法返回； 异常处理指令：athrow 同步指令：monitorenter/monitorexit 6.5 公有设计和私有实现 Java 虚拟机的实现必须能够读取 Class 文件并精确实现包含在其中的 Java 虚拟机代码的含义； 但一个优秀的虚拟机实现，通常会在满足虚拟机规范的约束下具体实现做出修改和优化； 虚拟机实现的方式主要有两种：将输入的 Java 虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集或宿主主机 CPU 的本地指令集。 6.6 Class 文件结构的发展 Class 文件结构一直比较稳定，主要的改进集中向访问标志、属性表这些可扩展的数据结构中添加内容； Class 文件格式所具备的平台中立、紧凑、稳定和可扩展的特点，是 Java 技术体系实现平台无关、语言无关两项特性的重要支柱； 6.7 本章小结本章详细讲解了 Class 文件结构的各个部分，通过一个实例演示了 Class 的数据是如何存储和访问的，后面的章节将以动态的、运行时的角度去看看字节码在虚拟机执行引擎是怎样被解析执行的。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part4/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记五：案例分析]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-1%2F</url>
    <content type="text"><![CDATA[5.2 案例分析5.2.1 高性能硬件上的程序部署策略 背景：一个15万pv、天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个cpu,16GB物理内存，操作系统为 64位的 CentOS 5.4 ，Resin作为服务器。管理员选用了 64位的 jdk 1.5,通过-Xmx,-Xms 将堆固定在12GB，使用一段时间后，出现了卡B现象，长时间无响应。监控发现卡B是由于GC停顿导致的。虚拟机运行在Server模式，默认使用吞吐量优先收集器，一次回收12GB的堆，一次 Full Gc的时间高达 14秒，再加上程序设计的关系，访问文档中需要一次性把文档从磁盘中读取到内存，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有在Minor GC中清理掉。在这种情况下，即使有12GB的堆，内存也很快会被消耗殆尽，有次导致每隔十几分钟出现十几秒的卡B，令网站开发人员和管理人员感到郁闷。 分析：在高性能硬件上部署程序，目前主要有两种方式：1 通过 64位 JDK 来使用大内存。2 使用若干个32位虚拟机简历逻辑集群来利用硬件资源。 如果读者计划使用64位的JDK来管理大内存，还需要考虑下面可能面临的问题：1 内存回收导致的长时间停顿。2 现阶段，64位JDK的性能测试普遍地域32位JDK。3 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照(因为要产生十几GB乃至更大的dump文件)，即使产生了快照也几乎无法进行分析。4 相同的程序在64位JDK中消耗的内存一般比32位的JDK大，这是由指针膨胀以及数据类型对其补白等因素导致的。 考虑到以上几点因素，你可能会选择使用若干个虚拟机集群来利用硬件资源，具体做法是子啊一台物理机器上启动多个应用服务器进程，给每个服务器进程分配不同的端口，然后在前端大减一个负载均衡器，以反向代理的方式来分配访问请求。 这种部署方式可能会遇到下面的问题： 1 尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同事访问某个磁盘文件的话，很容易导致IO异常。 2 很难高效率的利用某些资源池，譬如连接池，一般都是在各个节点上简历自己的独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余，尽管可以使用集中式的JNDI，但这有一定的复杂性并且可能带来额外的性能代价。 3 各个节点仍然不可避免的收到32位的内存限制，在32位window平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些linux unix 系统(Solaris)可以提升到3GB乃至接近4Gb的内存，但32位中仍然接受最高4GB内存的限制。 4 大量使用本地缓存的应用，在逻辑集群中会造成大量的内存浪费，因为每个逻辑节点上都有一份缓存，这时可以考虑把本地缓存改为集中式缓存。 最终解决方案最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算(其中堆固定为1.5GB)，占用了10GB的内存。另外建立一个Apache服务作为前端均衡器代理访问门户。考虑到用户对响应较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较多提升。 5.2.2 集群间同步导致的内存溢出由于集群同步大量数据，导致数据过多，而超过内存限制。 心得： 发生 OOM 的时候自动生成堆 dump 文件可以加参数： -XX:+HeapDumpOnOutOfMemoryError 由于信息有传输失败需要重发的可能性，在确认所有注册的GMS(GroupMembership Service)的节点都收到正确的信息前，发送的信息必须在内存中保留。此MIS的服务端中有一个负责安全校验的全局Filter，每当接收请求时，均会更新 一次最后的操作时间，并且将这个时间同步到所有节点中，使得一个用户在一段时间内不能在多台机器上登录。在服务器使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间的网络交互非常频繁。 当网络情况不能满足传输要求时，重发数据在内存中不断地积累，很快就产生了内存溢出。 这个案例中的问题，既有JBossCache的缺陷，也有MIS系统实现方式上的缺陷。JBossCache官方的mailist中讨论过很多次类似的内存溢出异常问题，据说后续版本有了改进。而更重要的缺陷是这一类被集群共享的数据如果要使用类似JBossCache 这种集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动作不会耗费多少资源，但不应当有过于频繁的写操作，这会带来很大的网络同步的开销。 5.2.3 堆外内存导致的溢出错误当出现 OOM 的时候不得不考虑下堆外内存导致的错误。第 2 章的时候也提到过，出现堆外内存导致的 OOM 时，heap dump 是无效的。异常栈里面可以明显看到 DirectByteBuffer、NIO 等字样的时候就可以考虑是堆外内存溢出导致的问题了。 最佳实践：因此总内存在分配给 JAVA 堆的时候，也确保预留了足够的堆外内存。 重点知识： 堆外内存不足的时候不会执行主动触发 GC，只会抛一些 OOM 的错误。 堆外内存导致的 OOM，heap dump 是无效的 只能等老年代 full GC 的时候顺便回收下堆外空间 其他心得：如果内存不足时抛出 StackOverflowError（纵向上，无法分配栈帧）或者 OutOfMemoryError:unable to create native thread（横向上，无法建立新的线程），考虑增加 - Xss 5.2.4 外部命令导致系统缓慢避免在 Java 中使用 Runtime.getRuntime().exec() 方法来执行外部的 shell 脚本。这样的实现方式开销较大。如果频繁调用会给 CPU 和内存带来极大压力。 JVM 执行这个命令的过程： 克隆一个和当前虚拟机拥有一样环境变量的进程 勇这个心得进程去执行外部命令，最后再退出这个进程。 5.2.5 服务器 JVM 进程崩溃使用异步调用，但是被调用方和调用发速度不匹配导致大量等待的线程和 socket 连接。最后积压太多超过 JVM 承受能力使得虚拟机进程崩溃。 解决办法： 采用生产者、消费者模式的消息队列来实现 5.2.6 不恰当数据结构导致内存占用过大例如： HashMap &lt;long,long&gt;这个种类型，各种头部开销比内容 (两个 Long 类型) 开销都要大得多，导致空间利用率低。&lt;/long,long&gt; 5.2.7 由 Windows 虚拟内存导致的长时间停顿GUI 程序最小化的时候，他的工作内存被自动交换到磁盘的页面文件之中，这样发生 GC 时就又可能因为恢复页面文件的操作而导致不正常的 GC 停顿。 解决办法：加入参数 “-Dsum.awt.keepWorkingSetOnMinimize=true” 5.3 实战：IDEA 运行速度调优这个整个过程较长，可以看书 P142 页开始。 我这里仅仅记录下一些值得注意的点： hostSpot 虚拟机名字由来： 如果一段 JAVA 方法被调用次数达到一定程度，就会判断为热带码交给 JIT 编译器（Just in time compiler）编译为本地代码，提高运行速度。 visualVM 里面的 visualGC 插件还是很有用的 参考： http://ningg.top/tool-personal-intellij-idea-for-mac-optimize/ http://blog.csdn.net/zhouping118/article/details/78185362 http://blog.csdn.net/u013295276/article/details/78543190 参考：https://kaimingwan.com/post/books/shen-ru-li-jie-javaxu-ni-ji/di-wu-zhang-diao-you-an-li-fen-xi-yu-shi-zhan]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记四：JVM 小工具]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11%2F</url>
    <content type="text"><![CDATA[JVM 小工具在 ${JAVA_HOME}/bin / 目录下 Sun/Oracle 给我们提供了一些处理应用程序性能问题、定位故障的工具, 包含 bin 描述 功能 jps 打印 Hotspot VM 进程 VMID、JVM 参数、main()函数参数、主类名 / Jar 路径 jstat 查看 Hotspot VM 运行时信息 类加载、内存、GC[可分代查看]、JIT 编译 jinfo 查看和修改虚拟机各项配置 -flag name=value jmap heapdump: 生成 VM 堆转储快照、查询 finalize 执行队列、Java 堆和永久代详细信息 jmap -dump:live,format=b,file=heap.bin [VMID] jstack 查看 VM 当前时刻的线程快照: 当前 VM 内每一条线程正在执行的方法堆栈集合 Thread.getAllStackTraces()提供了类似的功能 javap 查看经 javac 之后产生的 JVM 字节码代码 自动解析.class文件, 避免了去理解 class 文件格式以及手动解析 class 文件内容 jcmd 一个多功能工具, 可以用来导出堆, 查看 Java 进程、导出线程信息、 执行 GC、查看性能相关数据等 几乎集合了 jps、jstat、jinfo、jmap、jstack 所有功能 jconsole 基于 JMX 的可视化监视、管理工具 可以查看内存、线程、类、CPU 信息, 以及对 JMX MBean 进行管理 jvisualvm JDK 中最强大运行监视和故障处理工具 可以监控内存泄露、跟踪垃圾回收、执行时内存分析、CPU 分析、线程分析… 4.2 JDK 命令行工具 名称 主要作用 jps JVM Process Status Tool，显示指定系统内所有 HotSpot 虚拟机进程 jstat JVM Statistics Monitoring Tool，用于手机 HotSpot 虚拟机各方面运行数据 jinfo Configuration Info For Java，显示虚拟机配置信息 jmap Memory Map For Java，生成虚拟机内存转储快照（heapdumap 文件） jhat JVM Heap Dump Brower，用于分析 heapdump 文件 jstack Stack Trace For Java，显示虚拟机线程快照 4.2.1 jps：虚拟机进程状况工具1jps [options] [hostid] 参数 功能 -q 只输出 LVMID，省略主类名称 -m 输出虚拟机进程启动时传递给主类 main() 函数的参数 -l 输出主类全名，如果进程执行的是 jar 包，输出 jar 路径 -v 输出虚拟机启动时的 JVM 参数 4.2.2 jstat：虚拟机统计信息监视工具主要查询 3 类信息： 类装载 垃圾收集 运行期编译 1jstat [ option vmid [interval [s|ms] [count]] ] 参数 功能 -class 监视类装载、卸载数量、总空间及类装载所耗费的时间 -gc 监视 Java 堆状况，包括 Eden 区，2 个 survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息 -gccapacity 与 - gc 基本相同，主要关注 Java 堆各个区域使用到的最大和最小空间 -gcutil 与 - gc 基本相同，主要关注已使用空间占总空间百分比 -gccause 与 - gcutil 基本相同，但是会额外输出导致上一次 gc 产生的原因 -gcnew 监视新生代 GC 状况 -gcnewcapacity 监视内容与 - gcnew 一样，主要关注使用到的最大和最小空间 -gcold 监视老年代 GC 情况 -gcoldcapacity -compiler 输出 JIT 编译器编译过的方法、耗时等信息 -printcompilation 输出已经被 JIT 编译的方法 4.2.3 jinfo：Java 配置信息工具1jinfo [option] pid 4.2.4 jmap：Java 内存映像工具1jmap [option] vmid 参数 功能 -dump 生成 Java 堆转储快照。格式：-dump:[live,]format=b,file=，其中 live 子参数说明是否只 dump 出存活的对象 -finalizerinfo 在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只在 Linux/Solaris 下有效 -heap 显示 Java 堆详细信息，如使用哪种回收期、参数配置、分代状况等。只在 Linux/Solaris 下有效 -histo 显示堆中对象统计信息，包括类、实例数量和合计总量 4.2.5 jhat：虚拟机堆转储快照分析工具4.2.6 jstack：Java 堆栈跟踪工具1jstack [option] vmid 参数 功能 -F 强制输出 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用了本地方法的话，可以显示 C/C++ 的堆栈 4.3 JDK 可视化工具4.3.1 JConsole：Java 监视与管理控制台4.3.2 VisualVm：多合一故障处理工具 下载地址：http://visualvm.github.io/download.html 插件中心：https://visualvm.github.io/pluginscenters.html 参考：https://www.jianshu.com/p/c56884715567?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记三（垃圾收集器与内存分配策略，重点）]]></title>
    <url>%2F2018%2F03%2F10%2F2018-03-10%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略（重点）3.2 判断对象是否存活3.2.1 引用计数算法 (Reference Counting) 非主流 3.2.2 可达性分析算法 (GC Roots Analysis) 主流用这个判断 在主流的商用程序语言中 (Java 和 C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，下图对象 object5, object6, object7 虽然有互相判断，但它们到 GC Roots 是不可达的，所以它们将会判定为是可回收对象。 在 Java 语言里，可作为 GC Roots 对象的包括如下几种： a. 虚拟机栈 (栈桢中的本地变量表) 中的引用的对象 b. 方法区中的类静态属性引用的对象 c. 方法区中的常量引用的对象 d. 本地方法栈中 JNI 的引用的对象 3.2.3 引用在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用：就是指在程序代码之中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。 3.2.4 finalize() 方法最终判定对象是否存活 即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑” 阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 标记的前提是对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链。1). 第一次标记并进行一次筛选。 筛选的条件是此对象是否有必要执行 finalize() 方法。 当对象没有覆盖 finalize 方法，或者 finzlize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”，对象被回收。 2). 第二次标记 如果这个对象被判定为有必要执行 finalize（）方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的 “执行” 是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象 finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。 Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模标记，如果对象要在 finalize（）中成功拯救自己—- 只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出 “即将回收” 的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。不过大家尽量避免使用这个方法流程图如下： 注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，因此第二段代码的自救行动失败了。 并且建议大家尽量避免使用它 GC 日志说明： GC 打印时间: [垃圾回收类型回收时间: [收集器名称: 年轻代回收前占用大小 -&gt;年轻代回收后占用大小 (年轻代当前容量), 年轻代局部 GC 时 JVM 暂停处理的时间] 堆空间 GC 前占用的空间 -&gt; 堆空间 GC 后占用的空间(堆空间当前容量),GC 过程中 JVM 暂停处理的时间]。 垃圾回收类型：分为 GC 和 Full GC. GC 一般为堆空间某个区发生了垃圾回收， Full GC 基本都是整个堆空间及持久代发生了垃圾回收，通常优化的目标之一是尽量减少 GC 和 Full GC 的频率。 收集器名称：一般都为收集器的简称或别名，通过收集器名称基本都能判断出那个区发生了 GC。 DefNew：年轻代（新生代）发生了 GC （若为 DefNew 可知当前 JVM 年轻代使用的串行收集器） ParNew：年轻代（新生代）发生了 GC （若为 ParNew 可知当前 JVM 年轻代使用了并行收集器） Tenured：老年代发生了 GC Perm：持久代发生了 GC 3.2.5回收方法区 Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价表” 一般比较低。 方法区中的垃圾回收主要是：废弃常量及无用类。判断常量是否废弃与判断堆中对象十分相似。例如，若常量池中存在字符串 “abc”，而系统中并没有任何 String 对象的值为“abc” 的，也就是没有任何对象引用它，那么它就可以被回收了。无用类的判定稍微复杂点，需要满足： 1). 该类的所有对象实例已经被回收，也就是 Java 堆中不存在该类的任何实例； 2). 加载该类的 ClassLoader 已经被回收； 3). 该类的类对象 Class 没有在任何地方被引用，无法使用反射来访问该类的方法。 当方法区中的类满足以上条件时，就可以对无用类进行回收了，这里说的仅仅是 “可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了各种配置，这里不多讲。 在大量使用反射、动态代理、CGLIB 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保存永久代不会溢出。 3.3 垃圾收集算法（本书重点中的重点）3.3.1 标记 - 清除算法 (Mark-Sweep) 最基础的收集算法。其它算法都是基于这种思路并对其不足进行改进而得到的。 标记 - 清除算法将垃圾回收分为两个阶段： ①. 标记阶段：首先标记出所有需要回收的对象。 如何标记，在上面的 “判断对象是否存活” 里有讲过 ②. 清除阶段：标记完成后，统一回收被标记的对象缺点： ①. 效率问题：标记清除过程效率都不高。 ②. 空间问题：标记清除之后会产生大量的不连续的内存碎片 (空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。） 3.3.2 复制算法 (Copying)为了解决 mark-sweep 算法的效率问题 算法思想： 1). 将现有的内存空间分为两块，每次只使用其中一块. 2). 当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。 3). 再把已使用过的内存空间一次清理掉。 优点： 1). 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 2). 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 2.3 缺点： 1). 内存减少为原来的一半，太浪费了。 2). 对象存活率较高的时候就要执行较多的复制操作，效率变低。 3). 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。2.4. 演进 并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 EdenSpace 和两块较小的 SurvivorSpace JavaHeap 内存回收模型（当前商业虚拟机大多使用此算法回收新生代） jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 3.3.3 标记 - 整理算法 (Mark-Compact) 由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 算法思想 1). 标记阶段：首先标记出所有需要回收的对象。与 “标记 - 清除” 一样 2). 让存活的对象向内存的一段移动。 3). 直接清理掉边界以外的内存。 由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记 - 清理算法或者标记整理算法。 3.3.4 代收集算法 (Generational Collecting) 当前的商业虚拟机的垃圾收集都采用，把 Java 堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。 3.4 HotSpot的算法实现3.4.1 枚举根节点可达性分析在执行 GC 的时候会停顿一下，如果引用关系不断变换的时候很难进行准确的可达性分析。目前虚拟机主要采用的是准确性 GC，虚拟机应该有办法知道哪些地方存着对象引用，在 HotSpot 的实现中，用一组叫做 OopMap 的数据结构来实现这个目的，在类加载完成后记录下对象内的数据类型与偏移量，在 JIT 编译 过程中记录下栈和寄存器中哪些位置是引⽤。 3.4.2 安全点导致 OopMap 变化的指令非常多，我们只在特定的地点做记录，我们把这些点叫做安全点，也就是说让所以线程（不包括 JNI 调用的线程）跑到最近的安全点再停顿下来，所以安全点不能让 GC 等待时间过长，也不能太频繁。这里我们分为两种方式 抢占式中断，在 GC 的时候停下所以线程，再让没有到安全点的跑到安全点，目前几乎没有虚拟机采用这种方式进行 GC 主动式中断，当 GC 需要中断线程的时候，在安全点上设置中断标 志，线程执⾏时主动轮询中断标志，发现标志为真时则主动中断挂 起线程。轮训标志的地方和安全点重合。 3.4.3 安全区域指线程在某⼀段代码⽚段中，引⽤关系不会发⽣变化，在这个区域中的任意点开始 GC 都是安全的。GC 的时候不用考虑处于安全区域的，当线程出安全区域的时候要检查是否 GC 完成了，在线程处于 blocked 或 sleep 状态⽆法跑到安全点时，采⽤安全区域可以避免 GC ⻓时间等待。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 3.5 垃圾收集器 如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。 GC实现目标: 准确、高效、低停顿、空闲内存规整. ————————–新生代收集器———————— 3.5.1 Serial 收集器Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在 JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。 特性：这个收集器是一个单线程的收集器，但它的 “单线程” 的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Stop The World 应用场景：Serial 收集器是虚拟机运行在 Client 模式下的默认新生代收集器。 优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 3.5.2 ParNew 收集器 特性：ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。 应用场景：ParNew 收集器是许多运行在 Server 模式下的虚拟机中首选的新生代收集器。 很重要的原因是：除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS 收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。 Serial 收集器 VS ParNew 收集器：ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。然而，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的有效利用还是很有好处的。 3.5.3 Parallel Scavenge 收集器 1. 特性： Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 应用场景：停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 对比分析： Parallel Scavenge 收集器 VS CMS 等收集器：Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为 “吞吐量优先” 收集器。 Parallel Scavenge 收集器 VS ParNew 收集器：Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别是它具有自适应调节策略。 GC 自适应的调节策略：Parallel Scavenge 收集器有一个参数 -XX:+UseAdaptiveSizePolicy。当这个参数打开之后，就不需要手工指定新生代的大小、Eden 与 Survivor 区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。 ————————- 老年代收集器—————————- 3.5.4 Serial Old 收集器 特性：Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记－整理算法。 应用场景： Client 模式Serial Old 收集器的主要意义也是在于给 Client 模式下的虚拟机使用。 Server 模式如果在 Server 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 3.5.5 Parallel Old 收集器 特性：Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记－整理” 算法。 应用场景：在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作）。由于老年代 Serial Old 收集器在服务端应用性能上的 “拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。直到 Parallel Old 收集器出现后，“吞吐量优先” 收集器终于有了比较名副其实的应用组合。 3.5.6 CMS(Concurrent Mark Sweep) 收集器 1. 特性： CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。 CMS 收集器是基于 “标记—清除” 算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤： 初始标记（CMS initial mark）初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要 “Stop The World”。 并发标记（CMS concurrent mark）并发标记阶段就是进行 GC Roots Tracing 的过程。 重新标记（CMS remark）重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要 “Stop The World”。 并发清除（CMS concurrent sweep）并发清除阶段会清除对象。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。 优点：CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。 缺点： CMS 收集器对 CPU 资源非常敏感其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU 数量 + 3）/ 4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大。 CMS 收集器无法处理浮动垃圾CMS 收集器无法处理浮动垃圾，可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为 “浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS 收集器会产生大量空间碎片CMS 是一款基于 “标记—清除” 算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。—————————新生代和老年代均适用——————— 3.5.7 G1 收集器 特性：G1（Garbage-First）是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。 并行与并发G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。 分代收集与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合与 CMS 的 “标记—清理” 算法不同，G1 从整体来看是基于 “标记—整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。 可预测的停顿这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。 在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。 G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 执行过程：G1 收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking）初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 3.5.8、GC 相关参数总结VM 常用参数整理 参数 描述 -Xms 最小堆大小 -Xmx 最大堆大小 -Xmn 新生代大小 -XX:PermSize 永久代大小 -XX:MaxPermSize 永久代最大大小 -XX:+PrintGC 输出 GC 日志 -verbose:gc - -XX:+PrintGCDetails 输出 GC 的详细日志 -XX:+PrintGCTimeStamps 输出 GC 时间戳 (以基准时间的形式) -XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息 -Xloggc:/path/gc.log 日志文件的输出路径 -XX:+PrintGCApplicationStoppedTime 打印由 GC 产生的停顿时间 垃圾收集器参数总结 参数 描述 -XX:+UseSerialGC Jvm 运行在 Client 模式下的默认值，打开此开关后，使用 Serial + Serial Old 的收集器组合进行内存回收 -XX:+UseParNewGC 打开此开关后，使用 ParNew + Serial Old 的收集器进行垃圾回收 -XX:+UseConcMarkSweepGC 使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收，Serial Old 作为 CMS 出现 “Concurrent Mode Failure” 失败后的后备收集器使用。 -XX:+UseParallelGC Jvm 运行在 Server 模式下的默认值，打开此开关后，使用 Parallel Scavenge + Serial Old 的收集器组合进行回收 -XX:+UseParallelOldGC 使用 Parallel Scavenge + Parallel Old 的收集器组合进行回收 -XX:SurvivorRatio 新生代中 Eden 区域与 Survivor 区域的容量比值，默认为 8，代表 Eden:Subrvivor = 8:1 -XX:PretenureSizeThreshold 直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 -XX:MaxTenuringThreshold 晋升到老年代的对象年龄，每次 Minor GC 之后，年龄就加 1，当超过这个参数的值时进入老年代 -XX:UseAdaptiveSizePolicy 动态调整 java 堆中各个区域的大小以及进入老年代的年龄 -XX:+HandlePromotionFailure 是否允许新生代收集担保，进行一次 minor gc 后, 另一块 Survivor 空间不足时，将直接会在老年代中保留 -XX:ParallelGCThreads 设置并行 GC 进行内存回收的线程数 -XX:GCTimeRatio GC 时间占总时间的比列，默认值为 99，即允许 1% 的 GC 时间，仅在使用 Parallel Scavenge 收集器时有效 -XX:MaxGCPauseMillis 设置 GC 的最大停顿时间，在 Parallel Scavenge 收集器下有效 -XX:CMSInitiatingOccupancyFraction 设置 CMS 收集器在老年代空间被使用多少后出发垃圾收集，默认值为 68%，仅在 CMS 收集器时有效，-XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSCompactAtFullCollection 由于 CMS 收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在 CMS 收集器时有效 -XX:+CMSFullGCBeforeCompaction 设置 CMS 收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与 UseCMSCompactAtFullCollection 参数一起使用 -XX:+UseFastAccessorMethods 原始类型优化 -XX:+DisableExplicitGC 是否关闭手动 System.gc -XX:+CMSParallelRemarkEnabled 降低标记停顿 -XX:LargePageSizeInBytes 内存页的大小不可设置过大，会影响 Perm 的大小，-XX:LargePageSizeInBytes=128m Client、Server 模式默认 GC 服务端 or 客户端 新生代 GC 方式 老年代和持久代 GC 方式 Client Serial 串行 GC Serial Old 串行 GC Server Parallel Scavenge 并行回收 GC Parallel Old 并行 GC Sun/oracle JDK GC 组合方式 参数 新生代 GC 方式 老年代和持久代 GC 方式 -XX:+UseSerialGC Serial 串行 GC Serial Old 串行 GC -XX:+UseParallelGC Parallel Scavenge 并行回收 GC Serial Old 并行 GC -XX:+UseConcMarkSweepGC ParNew 并行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时，采用 Serial Old 串行 GC -XX:+UseParNewGC ParNew 并行 GC Serial Old 串行 GC -XX:+UseParallelOldGC Parallel Scavenge 并行回收 GC Parallel Old 并行 GC -XX:+UseConcMarkSweepGC -XX:+UseParNewGC Serial 串行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时采用 Serial Old 串行 GC 常用的收集器组合 服务器 31 新生代 GC 策略 老年老代 GC 策略 说明 组合 1 Serial Serial Old Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。 组合 2 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。 组合 3 ParNew CMS 使用-XX:+UseParNewGC选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用 - XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用 ParNew GC 策略。 组合 4 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。 组合 5 Parallel Scavenge Serial Old Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 组合 6 Parallel Scavenge Parallel Old Parallel Old 是 Serial Old 的并行版本 组合 7 G1GC G1GC -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启；-XX:MaxGCPauseMillis =50 #暂停时间目标；-XX:GCPauseIntervalMillis =200 #暂停间隔目标；-XX:+G1YoungGenSize=512m #年轻代大小；-XX:SurvivorRatio=6 #幸存区比例 1. 与串行回收器相关的参数 -XX:+UseSerialGC: 在新生代和老年代使用串行回收器。 -XX:+SuivivorRatio: 设置 eden 区大小和 survivor 区大小的比例。 -XX:+PretenureSizeThreshold: 设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。 -XX:MaxTenuringThreshold: 设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。 2. 与并行 GC 相关的参数 -XX:+UseParNewGC: 在新生代使用并行收集器。 -XX:+UseParallelOldGC: 老年代使用并行回收收集器。 -XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。 -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。 -XX:GCTimeRatio: 设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 -XX:+UseAdaptiveSizePolicy: 打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 3. 与 CMS 回收器相关的参数 -XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS + 串行收集器。 -XX:+ParallelCMSThreads: 设定 CMS 的线程数量。 -XX:+CMSInitiatingOccupancyFraction: 设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。 -XX:+UseFullGCsBeforeCompaction: 设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 -XX:+CMSClassUnloadingEnabled: 允许对类元数据进行回收。 -XX:+CMSParallelRemarkEndable: 启用并行重标记。 -XX:CMSInitatingPermOccupancyFraction: 当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是 - XX:+CMSClassUnloadingEnabled 激活了)。 -XX:UseCMSInitatingOccupancyOnly: 表示只在到达阈值的时候，才进行 CMS 回收。 -XX:+CMSIncrementalMode: 使用增量模式，比较适合单 CPU。 4. 与 G1 回收器相关的参数 -XX:+UseG1GC：使用 G1 回收器。 -XX:+UnlockExperimentalVMOptions: 允许使用实验性参数。 -XX:+MaxGCPauseMills: 设置最大垃圾收集停顿时间。 -XX:+GCPauseIntervalMills: 设置停顿间隔时间。 5. 其他参数 -XX:+DisableExplicitGC: 禁用显示 GC。 3.6 内存分配与回收策略（重点） Java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题： 1). 给对象分配内存; 2). 回收分配给对象的内存。关于回收内存这一点请参考如下文章 内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为 “对象游离”。 Jvm 怎么判断对象可以回收了？ 1). 对象没有引用，被判定为 “死亡”（并不是这个对象被赋值为 null 之后就一定被标记为可回收） 2). 作用域发生未捕获异常 3). 程序在作用域正常执行完毕 4). 程序执行了 System.exit() 5). 程序发生意外终止（被杀进程等） 对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 分配前请先了解下新年代和老年代： 3.6.1 对象优先在 Eden 分配 前面的文章介绍过 Hotspot 虚拟机新生代内存布局及算法： a. 将新生代内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。b. 每次使用 Enden 和其中一块 Survivor。c. 当回收时，将 Eden 和使用中的 Sruvivor 中还存的对象一次性复制到另一块 Survivor；d. 然后清理掉 Eden 和使用过的 Survivor 空间；e. 后面就使用 Eden 和另一块 Survivior 空间，重复步骤 3。 默认 Eden：Survivor=8：1，即每次可以使用 90% 的空间，只有一块 Survivor 空间被浪费。 大多数情况下，对象在 Eden 区中分配；当 Eden 区没有足够空间进行分配时，JVM 将会发起一次 MinorGC(新生代 GC)。MinorGC 时，如果发现存活的对象无法全部放入 Servivor 空间，只好通过分配机制提前转入熬年老代中。 3.6.2 大对象直接进入老年代 所谓的大对象是指：需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。 大对象对虚拟机的内存分配来说就是一个坏消息，比遇到一个大对象更加坏的消息就是：遇到一群 “朝生夕灭” 的 “短命大对象”。 经常出现大对象容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。 所以我们应该避免创建大对象； “-XX:PretenureSizeThreshold”： 可以设置这个阀值，大于这个参数值的对象直接在年老代中分配。 默认为 0(无效)，且只对 Serail 和 ParNew 两款收集器有效。 如果需要使用该参数，可以考虑 ParNew+CMS 组合 长期存活的对象将进入年老代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.3 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.4 动态对象年龄判定JVM 为了更好适应不同程序，不是永远要求等到 MaxTenuringThreshold 参数设置的年龄。 如果在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，大于或等于该年龄的对象就可以直接进入年老代。 3.6.5 空间分配担保 当 Survivor 空间不够用时，需要依赖其他内存 (年老代) 进行分配担保(Hanle Promotion) 分配担保流程如下： a. 在发生 Minor GC 之前，JVM 首先检查年老代最大可用的连续空间是否大于新生所有对象的空间。 b. 如果大于，那么可以确保 Minor GC 是安全的。 c. 如果不大于，则 JVM 查看 HandlePromotionFailure 值是否允许担保失败。 d. 如果允许，将尝试进行一次 Minor GC，但这是有风险对的； e. 如果小于或 HandlePromotionFailure 值不允许冒险，那这时，要改为进行一次 Full GC； 尝试 Minor GC 的风险 – 担保失败： 因为尝试 Minor GC 前，无法知道存货的对象大小，所以使用历次晋升到年老代对象的平均大小作为经验值。 加入尝试的 Minor GC 最终存活的对象远远高于经验值的话，会导致担保失败 (Handle Promotion Failure)。 失败后只有重新发起一次 Full GC，这绕了一个大圈，代价较高。 但一般还是要开启 HandlePromotionFailure，避免 Full GC 过于频繁，而且担保失败概率还是比较低的。 JDK1.6 之后，JVM 代码中已经不再使用 HandlePromotionFailure 参数了… 规则变为： 只要年老代最大可用的连续空间大于新生所有对象的空间或历次晋升到年老代对象的平均大小，就会进行 MinorGC，否则进行 Full GC。 即年老代最大可用的连续空间小于新生所有对象空间时，不在检查 HandlePromotionFailure，而是直接检查历次晋升熬年老代对象的平均大小。 参考：http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/https://www.jianshu.com/p/50d5c88b272dhttp://blog.csdn.net/simba_cheng/article/details/78223010]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM参数调优]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09%2F</url>
    <content type="text"><![CDATA[常见配置汇总堆设置-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值.如:为3,表示年轻代与年老代比值为1:3,年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:3,表示Eden:Survivor=3:2,一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数.并行收集线程数.-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式.适用于单CPU情况.-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数. 参考：http://blog.csdn.net/xiajian2010/article/details/17376157]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理数据可视化]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[根据现有数据集进行数据表查询集构建： galleryproduction 左外联结 production: 1234SELECT scratch_api_production.id,scratch_api_galleryproduction.production_id,scratch_api_production.nameFROM scratch_api_galleryproduction LEFT JOIN scratch_api_productionON scratch_api_production.id=scratch_api_galleryproduction.production_id production 左外联结 user: 1234SELECT scratch_api_production.author_id,scratch_api_user.baseuser_ptr_id,scratch_api_user.sex,scratch_api_user.gradeFROM scratch_api_production LEFT JOIN scratch_api_user ON scratch_api_production.author_id=scratch_api_user.baseuser_ptr_id 再构建三联表： galleryproduction左外联结production左外联结user 三表联结查询模版： 123select username,psw,gname,tel from (t1 left join t2 on t1.t1_id=t2.t1_id) left join t3 on t1.t1_id=t3.t1_id 我根据业务流程实现的sql查询： 查询某专题活动中的所有信息 1234SELECT *FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 然后使用阿里云的DataV进行数据可视化: 需要对接接口： 查询点赞数最多作品排行： 12345SELECT scratch_api_production.like,scratch_api_production.name FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' AND sex='男'ORDER BY scratch_api_production.like DESC 查询结果集中的男女人数 123456789SELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='男'UNIONSELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='女' 查询某专题活动学校参与度排名 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询某专题活动中的参与性别 1234SELECT scratch_api_user.sexFROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' 查询年级占比 123456SELECT scratch_api_user.grade ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.grade is not NULLGROUP BY scratch_api_user.gradeorder by count(*) desc 查询学校占比 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询作品提交时间 12345SELECT DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") as '日期',count(*) as '当日投票数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1GROUP BY DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") 把地址转换成经纬度不要方，利用高德地图经纬度快速查询工具可以轻松地把任何地址转换成经纬度，可具体到门牌号喔，工具地址： 控制台 | 高德开放平台 | 高德地图API galleryproduction左外联结production左外联结user左外联结antlrscore 1234SELECT *FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idLEFT JOIN scratch_api_antlrscore ON scratch_api_production.id = scratch_api_antlrscore.production_id_id 查询某活动中CT评分整体情况 12 义乌市首届Scratch编程周实时数据状态网址(动态页面):http://datav.aliyun.com/share/07ef37b235d9763bd364f344912d1a05大数据可视化说明:大数据屏幕：1920*1080（可修改）最高实时更新频率：1min/次正常显示的预览效果参考（静态截图）：http://p4lmrb1gp.bkt.clouddn.com/15205615855957.jpg本机上如果不是上述参考效果请检查自己的浏览器如下:推荐电脑上预览：首选谷歌 Chrome 浏览器版本56以上，其他浏览器则需更新至最新版并开启极速（chrome内核）模式，不要使用IE浏览器，否则无法正常显示。不推荐手机上预览：无法按默认长宽比例展示 预览效果：]]></content>
      <tags>
        <tag>数据可视化</tag>
        <tag>DataV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记二：Java内存区域与内存溢出异常&实战（重点）]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-05-2%2F</url>
    <content type="text"><![CDATA[第二章 Java内存区域与内存溢出异常&amp;实战第二章结构： Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。参考：https://www.jianshu.com/p/989c90f339b9 2.2 运行时数据区域具体见下图： 2.2.1 程序计数器（Program Counter Register） 概述：该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有：因为 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。2.无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法（本地方法，一个调用非Java代码的接口），这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。（个人理解：参考C++理解是：当线程中调用native方法的时候，当前线程应当会被阻塞，重新启动一个新的线程，那么计数器为空则不会影响新线程的计数器，相互独立。当前线程应当会被阻塞，直到另外一个线程执行结束。当然参数也会被保留） 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 我们经常将 Java 内存分为堆内存（Heap）和栈内存（Stack），这种分法中所指的栈就是 Java 虚拟机栈，或者说是虚拟机栈中 局部变量表 部分。 概述：描述 Java 方法执行的内存模型，每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆是所有线程共享的一块内存区域，由虚拟机启动时创建，堆的唯一目的就是存储对象的实例。几乎所有的对象实例都在改内存区域分配，但是随着JIT编译器（即时编译）的发展及逃逸分析技术（分析指针的动态范围）的发展，栈上分配、标量替换导致堆分配不那么“绝对”了。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开。 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 内存：Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。 相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对 常量池的回收 和 类型的卸载。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。Class 文件中除了有类的（版本、字段、方法、接口）等描述信息外，还有一项信息就是常量池。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2.3 HotSpot 虚拟机对象探秘 这一部分内容将以 HotSpot 虚拟机和常用的内存区域 Java 堆为例，阐述对象分配、布局和访问的全过程。 2.3.1 对象的创建 概述：Java 是一门面向对象的编程语言，在 Java 程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个 new 关键字而已，而在虚拟机中对象的创建则分为以下几个步骤。 虚拟机遇到New指令 首先检查指令的参数能否在常量池中定位到一个类的符号引用 检查这个符号引用对应的类是否已被加载、解析、初始化过 没有加载，则需要先加载 为新生对象分配内存区域（指针碰撞&amp;空闲列表） 线程安全（方案1：对分配内存空间的动作同步；方案2：本地线程分配缓冲 TLAB） 对对象进行必要的设置 调用init方法 类加载概述：虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存概述：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。 分配方式：1.指针碰撞（Bump the Pointer）：假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。2.空闲列表（Free List）：如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。 同步控制概述：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。 方案一：对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。 初始化概述：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。作用：保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。 对象头（Object Header）概述：接下来，虚拟机要为对象头数据进行设置。（e.g. 对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄） init概述：在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，&lt;init&gt; 方法还没有被执行，所有的字段还为零值。 一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，将对象按照我们的意愿进行初始化，这样一个真正的对象才算完全产生。 2.3.2对象的内存布局 在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域。 对象头（存放对象自身的运行时数据&amp;类型指针） 实例数据 对齐填充 2.3.2.1 对象头（Header） HotSpot 虚拟机的对象头包括两部分信息，存储自身的运行时数据的（Mark Word） 和 类型指针。 第一部分：Mark Word 概述：用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。 内存：对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 HotSpot 虚拟机对象头 Mark Word 表如下 第二部分：类型指针 概述：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 Reminder并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。(见2.2.3节) 数组对象：如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。 2.3.2.2 实例数据（Instance Data） 概述：这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 存储顺序：这部分的存储顺序会受到虚拟机 分配策略参数（FieldsAllocationStyle） 和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles =&gt; ints =&gt; shorts/chars =&gt; bytes/booleans =&gt; oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 2.3.2.3 对齐填充（Padding） 概述：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 原理：由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 2.3.3 对象的访问定位 概述：建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以 对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有两种。 句柄访问：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。 直接指针：Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示。 比较：1.句柄访问：使用句柄访问的最大好处就是 reference 中存储的是 稳定的 句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。2.指针访问：使用直接访问最大的好处就是 速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 Sun HotSpot 使用的是第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 2.4 实战：OutOfMemoryError 异常 在 Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemory（OOM）异常的可能。 目的：1. 通过代码验证 Java 虚拟机规范中描述的各个运行时区域的存储内容。2. 遇到实际的内存溢出异常时，能根据异常的信息快速判断哪个区域的内存溢出。3. 了解什么样的代码可能会导致这些区域内存溢出，并了解如何处理。 VM Args 设置 Eclipse IDE：Debug Configurations =&gt; Java Application =&gt; YoungGenGC =&gt; Arguments 中的 VM arguments 中进行书写（书写参数以 - 开头，以空格分隔）。 控制台：直接跟在 Java 命令之后书写。 本人运行在 Mac 系统下，使用 IDEA 进行配置，步骤如下所示👇。 1\. 打开 Run Configurations（⌃ + ⌥ + R 选择 0 ）或者（⌘ + ⇧ + A 输入 run 选择 run…）。 2\. 点击并打开 VM options。 3\. 写入虚拟机启动参数。 4.Apply 并 Run。 2.4.1 - Java 堆溢出 概述：Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 测试环境： 12345-verbose:gc-Xms20M // 最小 GC 启动-Xmx20M // 最大 GC 启动-XX:+PrintGCDetails // 打印设置-XX:SurvivorRatio=8 // 存活对象比率 测试代码：HeapOOM 123456789101112131415import java.util.*;public class Main &#123; private static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 运行结果： 1java.lang.OutOfMemoryError: Java heap space 分析：Java 堆内存的 OOM 异常是时机应用中常见的内存溢出异常情况。当出现 Java 堆内存溢出时，异常堆栈信息 java.lang.OutOfMemoryError 会跟着进一步提示 Java heap space。 解决方式 堆转储快照：要解决这个区域的异常，一般的手段是先通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。 内存泄露：进一步通过工具查看泄露对象到 CG Roots 的引用链，于是就能找到内存泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄露代码的位置。 内存溢出：如果不存在泄露，换句话说，就是内存中的对象确实都必须还活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对象看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗。 2.4.2 - 虚拟机栈和本地方法栈溢出 概述：由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoos 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 -Xss 参数设定。关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常。 异常类型 发生条件 StackOverflowError 线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。 OutOfMemoryError 无法申请到足够的内存时抛出该异常。 这里把异常分为两种情况，看似更加严谨，但却存在一些相互重叠的地方：方栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事的两种描述而已。 2.4.2.1 - StackOverflowError 测试环境：在此测试中，将测试范围限制于单线程中操作。1. 使用 -Xss 参数减少栈内存容量，结果抛出 SOF 异常，异常出现时输出的堆栈深度相应缩小。2. 定义了大量的本地变量，增大此方法栈中本地变量表长度。结果抛出 SOF 异常时输出的堆栈深度相应缩小。 JavaVMStackSOF: 1234567891011121314151617181920212223242526//JavaVMStackSOF//VM Args: -Xss160k // 栈内存容量public class Main &#123; public static class JavaVMStackSOF&#123; private int stackLength = 1; public void stackLeak() &#123; stackLength++; stackLeak(); &#125; &#125; public static void main(String[] args) throws Throwable &#123; JavaVMStackSOF oom = new JavaVMStackSOF(); try &#123; oom.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println("Stack length: " + oom.stackLength); throw e; &#125; &#125;&#125; 运行结果 123Exception in thread &quot;main&quot; Stack length: 771java.lang.StackOverflowError at Main$JavaVMStackSOF.stackLeak(Main.java:8) 分析：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者确切地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 理解：操作系统分配给每个进程的内存是有限的，虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存 -Xms（最大堆容量） -MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略不计。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈瓜分了。每个线程分配到的栈容量越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。 探索：出现 SOF 异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的）达到 1000 - 2000 完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果建立过多线程导致内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过 减少最大堆 和 减少栈容量 来换更多的线程。 2.4.2.2 - OutOfMemoryError 测试环境注意：下面这块代码运行有风险，书上说在windows上会造成系统假死，我在mac上的IDEA上运行，也死机了，测了两次，都导致了系统假死。 JavaVMStackOOM 12345678910111213141516171819202122232425262728293031323334public class Main &#123; //VM Args: -Xss2M // 栈内存容量 //测试代码：创建线程导致内存溢出异常 private void dontStop() &#123; while (true) &#123; &#125; &#125; // 循环开启线程 public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; Main oom = new Main(); oom.stackLeakByThread(); &#125;&#125; 运行结果（参考别人的结果） 1Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread 这是mac死机时用手机照的(；′⌒`)cpu已爆表 2.4.3 - 方法区和运行时常量池溢出 概述：由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。 脑补：String.intern() 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。在 JDK1.6 以及之前的版本中，由于常量池分配在永久代内，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小名，从而间接限制其中常量池的容量。 2.4.3.1 - OutOfMemoryError 测试环境 12-XX:PermSize=10M // 方法区最小值-XX:MaxPermSize=10M // 方法区最大值 测试代码RuntimeConstantPoolOOM 12345678910111213package com.company.bupt;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); long i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 在JDK1.6上运行结果如下： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at com.company.bupt.Main.main(Main.java:10) 分析：从运行结果中可以看到，运行时常量池溢出，在 OutOfMemoryError 后面跟随的提示信息是 PermGen space，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分。 在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为JVM实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。 在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。 在JDK8之前的HotSpot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域。永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过‑XX:MaxPermSize 设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误(OOM)。 参考：Java永久代去哪儿了 http://www.infoq.com/cn/articles/Java-PERMGEN-Removed 总结：java jdk1.7中的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域，如果想了解更多可以参考：http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.htmlhttp://blog.csdn.net/zhyhang/article/details/17246223/ 在JDK1.7上测试 模拟了一下常量池的oom，突然发现设置的参数-XX:PermSize=10M -XX:MaxPermSize=10M不管用了，同时发现内存一直在上升，当上升到一个极值就会趋于平稳，然后再过一段时间会报：Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded这个异常是当GC的时间超过总运行时间的98%才会报的，是为了防止GC占用的时间过长。 运行结果 2.4.3.2 - String 常量池测试 使用 JDK1.7 运行这段程序就不会得到相同的结果，while 循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响。 测试代码RuntimeConstantPoolOOM1 12345678910111213package com.company.bupt;public class Main &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); &#125;&#125; 分析： JDK1.6：会得到两个 false，而在 JDK1.7 中运行，会得到一个 true 和一个 false。产生差异的原因是：是 JDK1.6 中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由 StringBuilder 创建的字符串实例在 Java 堆上，所以必然不是同一个引用，将返回 false JDK1.7：intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此 intern() 返回的引用和由 StringBuilder 创建的那个字符串实例是同一个。对 str2 比较返回 false 是因为 java 这个字符串在执行 StringBuilder.toString() 之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而 计算机软件 这个字符串是首次出现的，因此返回 true。 JVM启动的时候已经写到常量池里了，类似的还有’main’、’int’、’float’。参考：https://www.jianshu.com/p/b98851899f37 JDK1.7上测试结果: 12345678String str1 = new StringBuilder("jc").append( "vc" ).toString();//JVM不会自动加载jcvc，所以这个jcvc是首次出现的，返回true System.out.println(str1.intern()==str1); String str2=new StringBuilder("mai").append( "n" ).toString(); //main已经被自动加载了，不是首次出现，所以返回false System.out.println(str2.intern()==str2); String str3=new StringBuilder("in").append( "t" ).toString(); //flase System.out.println(str3.intern()==str3); String str4=new StringBuilder("flo").append( "at" ).toString(); //flase System.out.println(str4.intern()==str4); JDK1.6上测试上述代码则全返回是false 2.4.3.3 - 方法区溢出 方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本思路就是运行时产生大量的类去填满方法区，直到溢出。另外的，直接使用 Java SE API 也可以动态产生类（如反射时的 GeneratedConstorAccessor 和动态代理等）。 但在本次试验使用CGLIB直接操作字节码运行时，生成大量的动态类。 值得注意的是，当前主流的很多框架 如：Spring,Hibernate对类进行增强时，都会使用到类似CGLIB这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载如内存。 注意：项目必须引入asm-6.0.jar和cglib-3.2.6.jar，需要手动寻找引入 测试代码JavaMethodAreaOOM： 1234567891011121314151617181920212223242526272829303132333435package com.company.bupt;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 测试方法区内存溢出 * 方法区保存的是Class的相关信息，如类名，字段描述符等等，在这里使用cglib来创建大量的类信息来使方法区内存溢出 * * 异常信息为：java.lang.OutOfMemoryError: PermGen space * VM args:-XX:PermSize=10m -XX:MaxPermSize=10m * @author Tim * */public class Main &#123; public static void main(String[] args) &#123; while(true)&#123; Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125; static class OOMObject&#123; &#125;&#125; 以下是我的实测情况： 下列是在JDK1.6上测试得到的： 下列是在JDK1.7上测试得到的： 2.4.3.4 - 总结 方法区溢出是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量的 Class 的应用中，需要特别注意类的回收情况。这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 2.4.4 - 本机直接内存溢出 概述：DirectMemory 容量可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（-Xmx指定）一样，下面的测试代码越过了 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）。因为，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 unfase.allocateMemory()。 测试代码DirectMemoryOOM 12345678910111213141516171819202122package com.company.bupt;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M * @author zzm */public class Main &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 运行结果参考： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryErrorat sun.misc.Unsafe.allocateMemory(Native Method)at org.fenixsoft.oom.DMOOM.main(DMOOM.java:20) 以下是JDK1.6上实测：程序并没有报错 分析：由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看到明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，那就可以考虑检查一下是不是这方面的原因。 参考:https://www.jianshu.com/p/989c90f339b9]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记一：（实战）自己编译JDK]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-06%2F</url>
    <content type="text"><![CDATA[全书核心分布： 第一章 走近JAVA1.6 实战：自己编译JDK(已成功编译) 疑问： 将JDK源码进行编译是做了点什么？是将JDK中的.java文件编译成.class文件吗？ JDK中包含开发工具包和JVM，作者编译完JDK以后，用的还是原来包中的JVM吗？ 我们平常使用的JDK，例如JDK1.7中，里面的文件是以.java形式存在的还是以.class形式存在的，或者是以.java形式存在，要用的时候再用JVM去编译的?答： JDK是c/c++写的, 编译就是把JDK编译成可以运行的状态, 可运行的意思是指可以编译运行.java文件. 而一般情况下官方下载的JDK都是已经帮你编译好而已. 作者可以用自己编译的, 也可以用官方编译好的. 这个要看书中的说明了 JDK是c/c++写的, 里面和其他c++程序没什么区别, windows下面是一堆dll和一堆exe. 你说的.java文件是JDK的功能之一, 帮你编译java文件成class, JVM是运行class文件的容器 一 环境： 操作系统：CentOS6.8计划编译的jdk: openjdk7现成的jdk: java version “1.6.0_25”(Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode))jdk6下载链接如果你当前的系统版本不是这个，没关系，只要下载上述版本安装rpm（默认安装到/usr/java路径下）(不必配置环境变量)即可 二 编译前准备工作如下123456yum install -y mercurialyum install -y ant ant-nodepsyum install -y libX11* libX*yum install -y libXi-devel libXtst-devel libXt-devel freetype* yum install -y alsa-lib-devel cups-develyum install -y gcc gcc-c++ 三 下载计划编译的openjdk7(jdk源码网站：http://hg.openjdk.java.net/jdk7u/ ， 你值得收藏) 1234hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-devcd jdk7u-devchmod 755 get_source.sh ./get_source.sh 四 编译4.1准备好编译环境相关参数解释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export LANG=C#Bootstrap JDK的安装路径，必须设置export ALT_BOOTDIR=/export/servers/jdk1.6.0_25/#允许自动下载依赖export ALLOW_DOWNLOADS=true#并行编译的线数，设置和cpu的数量一致即可export HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2#比较本次build出来的映像与先前版本的差异，这对我们来说没有意义，export SKIP_COMPARE_IMAGES=true#使用预编译头文件，不加这个编译会更慢一些export USE_PRECOMPILED_HEADER=true#指定要编译的内容export BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=falseexport BUILD_JAXWS=falseexport BUILD_CORBA=false#要编译的版本#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueexport DEBUG_NAME=debug#可以避开javaws和浏览器Java插件之类的部分buildBUILD_DEPLOY=false#设置成false就不会build出包装包，因为包装包里有些奇怪的依赖#但是即使不build出它也已经能得到完整的JDK映像，所以还是别build它好了BUILD_INSTALL=false#编译结果存放的路径export ALT_OUTPUTDIR=/root/temp/jdk7u WARNINGS_ARE_ERRORS=#卸载环境变量，避免诡异的事情发生unset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS#make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 好了，我们将上面一系列的环境变量，创建环境文件VAR来统一管理吧vi VAR 12345678910111213141516171819202122232425262728293031323334353637383940export LANG=Cexport ALT_BOOTDIR=/usr/java/jdk1.6.0_25export ALLOW_DOWNLOADS=trueexport HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2export SKIP_COMPARE_IMAGES=trueexport USE_PRECOMPILED_HEADER=trueexport BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=trueexport BUILD_JAXWS=trueexport BUILD_CORBA=true#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueBUILD_DEPLOY=falseBUILD_INSTALL=falseexport ALT_OUTPUTDIR=/home/cloudpai/app/jdk7u #export CORBA_DIST=$ALT_OUTPUTDIR/corba/dist#export JAXP_DIST=$ALT_OUTPUTDIR/jaxp/dist#export JAXWS_DIST=$ALT_OUTPUTDIR/jaxws/distunset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS 使之生效. VAR 4.2检测设置是否全部正确make sanity当看到如下输出时则表示成功 123456789101112131415161718192021Build Machine Information: build machine = workstation.centos.vbirdBuild Directory Structure: CWD = /root/temp/jdk7u-dev TOPDIR = . LANGTOOLS_TOPDIR = ./langtools JAXP_TOPDIR = ./jaxp JAXWS_TOPDIR = ./jaxws CORBA_TOPDIR = ./corba HOTSPOT_TOPDIR = ./hotspot JDK_TOPDIR = ./jdk ……Sanity check passed. 4.3真正开始编译make (命令等同于make all) 成功的标志 12345678910111213#-- Build times ----------Target all_product_buildStart 2018-03-06 21:03:26End 2018-03-06 21:20:0900:02:02 corba00:05:08 hotspot00:00:16 jaxp00:00:19 jaxws00:08:34 jdk00:00:23 langtools00:16:43 TOTAL-------------------------make[1]: Leaving directory `/home/cloudpai/Downloads/jdk7u-dev' 4.4测试自己编译出来的jdk吧正确编译后，可以执行如下命令验证 1234[cloudpai@hadoop000 bin]$ /home/cloudpai/app/jdk7u/j2sdk-image/bin/java -versionopenjdk version "1.7.0-internal"OpenJDK Runtime Environment (build 1.7.0-internal-cloudpai_2018_03_06_21_03-b00)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) OK，到些就大功告成了。 五 可能出现的错误/usr/bin/ld: cannot find -lX11 collect2: ld returned 1 exit status解决办法yum install -y libX11* /bin/sh: line 0: cd: /NOT-SET/re/jdk/1.7.0/promoted/latest/binaries/linux-amd64: No such file or directory make[4]: *** [/root/temp/jdk7u/tmp/java/components_imported] Error 1解决办法VAR文件确认执行过了，正确的姿势. VAR 参考博客：http://blog.csdn.net/hl_java/article/details/76691321 由1.6.4得我们得到了自己的虚拟机1.7.0-internal-cloudpai_2018_03_06_21_03-b00 现在我们要将JVM运行起来： 在大多数时候，如果我们并不关心JDK中HotSpot虚拟机以外的内容，只想单独编译 HotSpot虚拟机的话（例如调试虚拟机时，每次改动程序都执行整个OpenJDK的Makefile，速 度肯定受不了），那么使用hotspot/make目录下的Makefile进行替换即可，其他参数设置与前 面是一致的，这时候虚拟机的输出结果存放在build/hotspot/outputdir/bsd_amd64_compiler2目录(在不同机器上，最后一个目录名称会有所差别，bsd表示Mac OS系统（内核为 FreeBSD），amd64表示是64位JDK（32位是x86），compiler2表示是Server VM（Client VM表 示是compiler1）。) 中，进入后可以见到以下几个目录。 在路径：/home/cloudpai/app/jdk7u/hotspot/outputdir/linux_amd64_compiler2 12345678910[cloudpai@hadoop000 linux_amd64_compiler2]$ lltotal 48drwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 debugdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 fastdebugdrwxrwxr-x. 7 cloudpai cloudpai 4096 Mar 6 21:06 generateddrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 jvmgdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 optimizeddrwxrwxr-x. 3 cloudpai cloudpai 20480 Mar 6 21:11 productdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 profiled-rw-rw-r--. 1 cloudpai cloudpai 1778 Mar 6 21:06 shared_dirs.lst 这些目录对应了不同的优化级别，优化级别越高，性能自然就越好，但是输出代码与源 码的差距就越大，难于调试，具体哪个目录有内容，取决于make命令后面的参数。 在编译结束之后、运行虚拟机之前，还要手工编辑目录下的env.sh文件，这个文件由编 译脚本自动产生，用于设置虚拟机的环境变量，里面已经发布了“JAVA_HOME、 CLASSPATH、HOTSPOT_BUILD_USER”3个环境变量， 还要在在product下边（看网上都是在jvmg下边，可我的jvmg下边没有gamma，不知道什么情况）的env.sh下加入： 123456export JAVA_HOME=/usr/java/jdk1.6.0_25export PATH=$JAVA_HOME/bin:$PATHLD_LIBRARY_PATH=.:$&#123;JAVA_HOME&#125;/jre/lib/amd64/native_threads:$&#123;JAVA_HOME&#125;/jre/lib/amd64:export LD_LIBRARY_PATH 然后执行以下命令启动虚拟机（这时的启动器名为gamma），输出版本号。 12source ./env.sh ./gamma -version 最后运行虚拟机成功！！ 12345[cloudpai@hadoop000 product]$ ./gamma -versionUsing java runtime at: /usr/java/jdk1.6.0_25/jrejava version &quot;1.6.0_25&quot;Java(TM) SE Runtime Environment (build 1.6.0_25-b06)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) 1.6.5 JVM 在IDE工具中进行源码调试注意这里是源码调试，是对1.6.4中计划编译的jdk源码进行操作: openjdk7（centos上的存储路径是/home/cloudpai/Downloads/jdk7u-dev） centos下安装NetBeans集成开发环境 官网下载地址：http://download.netbeans.org/netbeans/7.0.1/final/bundles/netbeans-7.0.1-ml-cpp-linux.sh 以netbeans-7.0.1-ml-cpp-linux.sh为例 首先，到NetBeans网站（http://netbeans.org/）上下载最新版的NetBeans（网上说7.0.1版本没问题，我就直接用这个版本了），下载时选择支持 C/C++开发的那个版本。 注意：不要在本地远程用SecureCRT输入命令啊，要在Linux下用终端输入命令： 1sh netbeans-7.0.1-ml-cpp-linux.sh 这样就会在centos中弹出安装界面： 配置好安装路径和IDE使用的java环境（注意与编译时的环境一致） 安装好以后，桌面上就有了NetBeans： 后续操作可以参考这个博客：使用Netbeans开发调试OpenJDK中的HotSpothttp://blog.csdn.net/pange1991/article/details/51580969 CentOS下安装NetBeans集成开发环境http://www.itboth.com/d/QriYZj/centos-java-windows-linux-netbeans]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java1.8 帮助文档]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05-1%2F</url>
    <content type="text"><![CDATA[java 1.6 帮助文档中文链接：http://download.csdn.net/detail/qw599186875/9608735英文Java1.8 帮助文档英文中文 – 谷歌版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-google/下载链接：http://download.csdn.net/detail/qw599186875/9802192]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站架构技能图谱（Java版）]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05%2F</url>
    <content type="text"><![CDATA[每天都要有进步！]]></content>
      <tags>
        <tag>Java</tag>
        <tag>图谱</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[workflow工作流]]></title>
    <url>%2F2018%2F03%2F04%2F2018-03-04%2F</url>
    <content type="text"><![CDATA[工作流脚本测试：测试成功~晚安~~]]></content>
      <tags>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scratch编程探究]]></title>
    <url>%2F2018%2F03%2F02%2F2018-03-02%2F</url>
    <content type="text"><![CDATA[转载自：儿童使用Scratch编程时，与程序员在工作中的编程有什么区别？ - Milo Yip的回答 - 知乎https://www.zhihu.com/question/42012520/answer/310430799]]></content>
      <tags>
        <tag>scratch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018拜年祭单品]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01-1%2F</url>
    <content type="text"><![CDATA[2018拜年祭单品传送门： 1.【逆浪千秋】av20204904 2.【如果我的一生只需要做一件事 — Bilibili Zeitgeist 2017】av20203478 3.【梦想小剧场-遗失的宝物】av20203610 4.【口袋竞技场ー冰与铁之歌】av20203938 5.【相遇day by day】av20203945 6.【上海一夜】av20204014 7.【神鬼恋曲】av20204051 8.【UP主的奇妙冒险之勇者传说】av20204517 9.【我的破烂之掀起波澜】av20204332 10.【palette】av20204403 11.【广告高手】av20204701 12.【滑稽君大冒险】av20204534 13.【journey】av20204614 14.【全靠我勤劳的手】av20204705 15.【演奏区的偷心计划】av20204824 16.【乒乓帝国】av20205319 17.【鬼畜大战之真相黎明】av20205316 18.【如何翻拍一个CG短片】av20205314 19.【坦克大战】av20205375 20.【星空花火】av20203411 彩蛋【举头三尺有神明】av16201808]]></content>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blogs 上的标签tag参数]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01%2F</url>
    <content type="text"><![CDATA[12345678910---title: Mac终端翻墙tags: Linux&amp;Unixcategories: Linux&amp;Unixcomments: trueabbrlink: 745a6d7date: 2016-11-24 18:26:33updated: 2016-11-24 18:26:33copyright: true---]]></content>
      <tags>
        <tag>mac</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要进行的改进]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[TODO： 测试git的备份功能 学习 Alfred workflow实现打开重启任意应用 脚本实现清理浏览器缓存]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog通过git备份与恢复的最优操作]]></title>
    <url>%2F2018%2F02%2F28%2Fblog%E9%80%9A%E8%BF%87git%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%9A%84%E6%9C%80%E4%BC%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引言：Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。特别简洁。 关于搭建的流程 创建仓库，http://CrazyMilk.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库； 在本地http://CrazyMilk.github.io 仓库新建一个文件后，进入文件中。在该文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 关于日常的改动流程 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的http://CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 其实只要把hexo和需要每个插件都写入到package.json中（平常安装时加–save参数会自动写入），那么git clone下来之后，只要一句npm install就能装好hexo和所有的依赖，开箱即用 ^_^ 迁移源码库一开始用了该方法，后来意识到备份到github分支的博客源码也是public的，后来改为备份到开源中国git私有库了 参考1：GitHub Pages + Hexo搭建博客参考2：使用hexo，如果换了电脑怎么更新博客？ - CrazyMilk的回答 - 知乎]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac使用]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28%2F</url>
    <content type="text"><![CDATA[Mac系统如何显示隐藏文件？以”.”开头的隐藏文件如何在MAC系统下显示？ 答：Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 显示 隐藏文件 1234567#显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool trueosascript -e 'tell application "Finder" to quit'#不显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool falseosascript -e 'tell application "Finder" to quit']]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28-1%2F</url>
    <content type="text"><![CDATA[创建的仓库：默认master克隆的仓库：默认origin（源） git add 开始跟踪一个新文件git status显示git状态 git commit提交更新 git diff：比较工作区和缓存区的不同。git diff --cached：比较缓存区和仓库的不同。 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 git push [remote-name] [branch-name] 如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：git push origin master git log显示从最近到最远的提交日志。包含每个提交的SHA1校验和、作者的名字和邮箱、提交时间以及提交说明等。gitk使用图形化工具查阅提交历史 git commit --amend修改最后一次提交 git reset HEAD &lt;file&gt;...取消已经暂存的文件 Git 分支git branch创建一个新的分支 git commit -a -m &#39;made other changes&#39; 提交分支git mergetool调用一个可视化的合并工具并引导你解决所有冲突 git学习链接]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客样式改进杂记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8D%9A%E5%AE%A2%E6%A0%B7%E5%BC%8F%E6%94%B9%E8%BF%9B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[评论区样式修改：文件位置：themes/next/source/css/_common/components/comments.styl 修改内容： 1234.comments &#123; background white; opacity:0.8;&#125; 移动端不加载背景图一点优化，移动端不加载背景图。在_layout.swig底部L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});标签前，加上移动端浏览器内核判断语句，当为PC端浏览器时，加载背景js 123456789101112131415161718192021222324252627&lt;!--移动端判断，是否引入背景--&gt;&lt;script&gt;var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123;//移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase() &#125; if(browser.versions.mobile || browser.versions.ios || browser.versions.android || browser.versions.iPhone || browser.versions.iPad)&#123; &#125;else&#123; document.write("&lt;script type=\'text/javascript\' src=\'/js/src/particle.js\'&gt;&lt;\/script&gt;"); &#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🎵记录点滴生活]]></title>
    <url>%2F2018%2F02%2F24%2F%F0%9F%8E%B5%E8%AE%B0%E5%BD%95%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[记录点滴生活《BINGBIAN病变》歌曲不错，曲调有些忧伤 [00:00.21]罗之豪 - BINGBIAN病变 [00:01.87]词：Cubi/Fi9 [00:02.76]曲：Jurrivh [00:03.72]混音：Fi9 [00:19.36][02:01.33][03:09.30]有天我睡醒看到我的身边没有你 [00:23.52][02:05.53][03:13.50]在我的右边是你曾经喜欢的玩具 [00:27.75][02:09.76][03:17.66]可当我站起身来在房间里寻找你 [00:32.04][02:14.00][03:21.93]留下的只有带着你味道的一封信 [00:36.50][02:18.48][03:26.35]就在昨天还一起看我们的照片 [00:40.47][02:22.48][03:30.46]可现在让我感觉像烂剧里的主演 [00:44.74][02:26.71][03:34.69]为什么这种事情会发生在我身边 [00:48.97][02:31.00][03:38.92]是不是老天没能看到对你的疯癫 [00:54.46]还想着 创造你的宇宙 [00:56.53]但现在 已经被我清空 [00:58.57]你让我 整个人都冰冻 [01:00.68]还怎么 再次为你心动 [01:02.88]Wake me 不是你的意愿 [01:04.97]离开我 开始新的起点 [01:07.12]可能我 还会对你贪恋 [01:09.30]谁让你 曾经让我疯癫 [01:11.18]疯癫 那也是过去的画面 [01:14.54]看往后的几天 [01:16.72]我猜你也不会出现 [01:18.78]我回想这几年 [01:20.93]就像是要命的病变 [01:23.16]你可能听不见 [01:25.16]来自我对你的挂念 [01:27.53]可能有点累 [01:28.85]觉得对不对这是第几次在为你宿醉 [01:31.98]没了我肩膀 [01:33.08]你在谁身旁买的礼物变成了灰 [01:35.99]曾经我多想 [01:37.25]把你变漂亮看着别人羡慕你的模样 [01:40.50]没关系有小熊陪着你看月亮 [01:44.40]我已经看到跟你断电的过程 [01:46.96]但我假装看不见 [01:48.76]是不是要我变得像个厉鬼 [01:50.96]才能进入你的世界 [01:52.95]为什么不说再见 [01:54.31]我猜你应该是不小心的忘记 [01:57.04]都无所谓也有点累 [01:59.09]也可以开始新的记忆 [02:35.19]我不能够停止啊 [02:37.43]这些年我对你的疯癫 [02:39.49]戴上那条围巾吧 [02:41.59]在每个寒风刺骨的冬天 [02:43.92]每次送你回家你抱着我 [02:45.63]不经意间又触碰到你的手 [02:48.10]你穿裙子眨眼睛 望着我 [02:50.52]让我每次心动的瞬间 [02:52.49]那条十字路口 [02:54.39]始终有你身上的气味 [02:57.00]车水马龙过后的路灯下的身影 [03:00.10]又会是谁 [03:00.83]他想说我真的 [03:02.01]喜欢你但是每次欲言又闭嘴 [03:05.57]那时荒唐的男孩 [03:07.64]又浑浊了几岁 var ap = new APlayer({ element: document.getElementById("aplayer1"), narrow: false, autoplay: false, showlrc: 2, music: { title: "BINGBIAN病变", author: "Cubi / Fi9江澈", url: "http://p4lmrb1gp.bkt.clouddn.com/Cubi,Aydo$,BRGang%20-%20BINGBIAN%E7%97%85%E5%8F%98.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/BINGBIAN%E7%97%85%E5%8F%98.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的blog自动发布脚本]]></title>
    <url>%2F2018%2F02%2F23%2Fmac%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[遇到的坑： -bash: ./install.sh: /bin/bash: bad interpreter: Operation not permitted出现这个问题的主要原因是：-rwxrwxrwx@ 文件的属性最后带个@，这个@代表的是更多的一些属性，具体含义不太清楚，但有它就是执行不了解决：可以用这个命令来去除这个属性：xattr -d com.apple.quarantine ./*后来进入目录发现目录下面的文件还是带有@属性，我们到根目录加一个-r就好了：xattr -d -r com.apple.quarantine ./* 我的blog自动发布脚本:blog_publish.sh 123456789#!/bin/bashsay "blogs updating"cd /Users/pailiu/Library/Mobile\ Documents/iCloud~com~coderforart~iOS~MWeb/Documents/mweb_documents_library/Bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo dsay "blogs published"rm -rf /Users/pailiu/Library/Caches/Google/Chrome/Profile\ 1/*open -a "/Applications/Google Chrome.app" 'http://cloudpai.site/'# hexo server]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客插入音频、视频]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为了避免后期外链失效，可以将视频、音频图片等资源传至七牛云等cdn服务器上，从中获取外链。 常用排版：居中： 1&lt;center&gt; &lt;/center&gt; 插入图片：有尺寸要求时： 1&lt;img src="http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg" width="80%" height="80%"&gt; 无尺寸要求时快速插入（md格式）： 1![](http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg) 插入音乐网易云音乐外链获取：见官网修改博客音乐播放器歌曲路径：/Blog/themes/hexo-theme-next-master/layout/_macro/sidebar.swig qq音乐外链获取： http://www.qqmusic.cc/插入音频播放器代码： 1&lt;audio src="http://mp3.qqmusic.cc/yq/211758246.mp3" controls="controls"&gt;&lt;/audio&gt; hexo-tag-aplayer：博客中插入自定义音乐 安装成功后，在 Markdown 文档中添加比如添加如下代码使用hexo-tag-aplayer 参数12345678title ：音乐标题author：音乐作者url：音乐文件网址picture_url：可选，音乐图片网址narrow：可选，窄款式autoplay：可选，自动播放音乐，不支持移动浏览器width:xxx：可选，前缀width:，播放器宽度（默认值：100％）lrc:xxx：可选，前缀lrc:，LRC文件url 示例: 1&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125; [ti:春意红包 (Vocaloid Ver.)] [ar:乐正绫/心华/洛天依] [al:春意红包] [by:] [offset:0] [00:00.29]春意红包 (Vocaloid Ver.) - 乐正绫/心华/洛天依 [00:00.89]词：泠鸢YOUSA [00:01.05]曲：Wing翼 [00:01.18]编曲：Wing翼 [00:01.95]小麦面包饺 喜色上眉梢 [00:05.78]点柳翠 画春晓 [00:08.85] [00:10.08]找旧样铜板穿一串吉兆 [00:14.20]把春意装满红包 [00:17.86] [00:37.11]廊下的小阿妹摇头晃脑 [00:41.25]望着瓦上的碎嘴家雀 [00:44.76] [00:45.56]问它们春日的鸟儿 何时才能到 [00:49.81] [00:50.35]穿街搜巷沿路找 [00:53.26] [00:53.76]看邻家的老人摘下毡帽 [00:57.88]虽是脱去冬衣还尚早 [01:01.89]宰鸡鸭 起炉灶 揭开自家陈酿 [01:07.91]偷偷尝一瓢 [01:09.81] [01:13.01]大鬼叫 小鬼叫 邪祟吓得跌倒 [01:16.73]该用什么清扫 锣鼓鞭炮 [01:20.58] [01:21.30]小孩儿 快来瞧 别再人堆胡闹 [01:24.85] [01:25.43]只有听话乖巧 来年才能长高 [01:29.08] [01:30.21]和纸浆 采朱砂 攒一摞春联叠好 [01:34.25]剪金花 染红料 [01:36.24]再糊一个四方小包 [01:37.98] [01:38.56]对花调 抄童谣 写一串吉祥安好 [01:42.51]扶正了封面 画上春来到 [01:46.14]一片翠色葱葱明快又跳跃 [01:50.13]几瓣海棠山茶花儿相映笑 [01:54.29]再蘸浓墨潦草添只燕子闹 [01:58.48]红绳绕 来封一个大红包 [02:02.83] [02:19.34]找一张晒烫的板凳歇脚 [02:22.80] [02:23.58]看你眼下又布满操劳 [02:27.59]编织橙黄蓝绿把烦恼全部忘掉 [02:32.00] [02:32.65]抬手捧一把红枣 [02:34.70] [02:35.97]骗怕生的小妹点灯睡觉 [02:40.05]会有鬼祟在夜晚来到 [02:43.55] [02:44.13]她慌张 我偷笑 连说不怕不怕 [02:50.16]让我去赶跑 [02:52.62] [02:55.34]左搭肩 右帮腔 [02:57.19]挤兑迟来的大忙人 [02:59.59]礼物未到 人怎能到 [03:03.02] [03:03.62]表嫂吵 大舅闹 连天地喳喳叫 [03:07.03] [03:07.71]我装作听不到 盘坐把碗沿敲 [03:11.35] [03:12.37]踩高跷 抓花包 撩一挂红衣鞭炮 [03:16.52]打年糕 串辣椒 [03:18.59]抹花我的胭脂粉膏 [03:20.67]侃八卦 讲小道 等杯中茶酒减少 [03:24.79]将手上红包 塞进你棉袄 [03:28.05] [03:28.60]你送吉祥如意 幸福快来到 [03:32.57]我送百年顺遂 不怕被火烧 [03:36.57]再求来年生辰 添一分美貌 [03:40.74]拱手摇 同鞠一躬对眼笑 [03:44.55] [03:47.29]小麦面包饺 喜色上眉梢 [03:51.29]点柳翠 画春晓 [03:55.45]找旧样铜板穿一串吉兆 [03:59.58]把春意赠与明朝 [04:03.12] [04:04.16]左搭肩 右帮腔 热闹话不见少 [04:08.24]你来蒸 我来挑 塞满嘴的玉米包 [04:12.41]干柴烧 火焰高 烦心事已寥寥 [04:16.05] [04:16.66]眯眼瞧 把红包塞进你棉袄 [04:20.59]一片翠色葱葱 明快又跳跃 [04:24.66]几瓣海棠山茶 花儿相映笑 [04:28.80]封着吉祥如意 幸福快来到 [04:32.97]红绳绕 拆开春意大红包 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 2, music: { title: "春意红包", author: "三无MarBlue,祖娅纳惜,泠鸢yousa", url: "http://p4lmrb1gp.bkt.clouddn.com/%E4%B8%89%E6%97%A0MarBlue,%E7%A5%96%E5%A8%85%E7%BA%B3%E6%83%9C,%E6%B3%A0%E9%B8%A2yousa%20-%20%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 播放列表123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; "narrow": false, // Optional, narrow style "autoplay": true, // Optional, autoplay song(s), not supported by mobile browsers "mode": "random", // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` "showlrc": 3, // Optional, show lrc, can be 1, 2, 3 "mutex": true, // Optional, pause other players when this player playing "theme": "#e6d0b2", // Optional, theme color, default: #b7daff "preload": "metadata", // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' "listmaxheight": "513px", // Optional, max height of play list "music": [ &#123; "title": "CoCo", "author": "Jeff Williams", "url": "caffeine.mp3", "pic": "caffeine.jpeg", "lrc": "caffeine.txt" &#125;, &#123; "title": "アイロニ", "author": "鹿乃", "url": "irony.mp3", "pic": "irony.jpg" &#125; ]&#125;&#123;% endaplayerlist %&#125; 插入视频：video 标签： 123&lt;video src="http://lxqncdn.miaopai.com/stream/BvmaXK2X49guVi4ehlOjjQ__.mp4" width="100%" height="100%" controls="controls"&gt;Your browser does not support the video tag.&lt;/video&gt; embed标签： 1&lt;embed src="http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA==/v.swf" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" allowFullScreen="true" mode="transparent" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; iframe标签： 1&lt;iframe height=498 width=510 src="http://player.youku.com/embed/XMTY1MTI3NjMyNA==" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
