<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础知识总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-1%2F</url>
    <content type="text"><![CDATA[111]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-3%2F</url>
    <content type="text"><![CDATA[111]]></content>
      <tags>
        <tag>java基础</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（6~9章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-4%2F</url>
    <content type="text"><![CDATA[第七章：异常、断言和日志7.1 处理错误需要关注的问题 用户输入错误 设备错误 物理限制 代码错误 7.1.1 异常分类 派生于 RuntimeException 的异常包含下面几种情况: 错误的类型转换 数组访问越界 访问 null 指针 不是派生于 RuntimeException 的异常包括 试图在文件尾部后面读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在 7.1.2 声明受检查异常 使用 throws 关键字，在方法的首部同所有的异常类。每个异常类之间用逗号隔开。 7.1.3 使用 throws new Exception();7.1.4 创建异常类派生于 Exception 类或派生于 Exception 的子类 7.2 捕获异常7.2.1 捕获异常123try&#123;&#125; catch (Exception e)&#123;&#125; 7.2.2 捕获多个异常 Java 7 以后，在 catch 子句中可以捕获多个异常. 使用 | 7.2.3 再次抛出异常与异常链 在 catch 子句中，可以改变异常的类型，进行再次抛出 7.2.4 finally 子句 不管异常是否被捕获，finally 子句中的代码都被执行。 12345678InputStream in = new FileInputStream("c:\\a.txt");try&#123; try&#123; &#125; finally &#123; &#125;&#125; catch(IOException e) &#123; //异常处理的语句&#125; 7.2.5 带资源的 try 语句前提：资源属于实现了 AutoCloseable 接口的类 12try(Resourse res = ...) &#123;&#125; 7.2.6 分析堆栈轨迹元素 getStackTrace 方法，可以得到 stackTraceelElement 对象的一个数组，可以在你的程序中分析这个对象数组。 7.3 使用异常机制的技巧 异常处理不能代替简单的测试 不要过分的细化异常 利用异常层次结构 不要压制异常 在检测时，“苛刻” 比放任要好 不要羞于传递异常 7.4 使用断言 (JDK 自带的，基本不使用)7.4.1 断言的概念断言机制允许在测试期间向代码中插入一些检查语句，使用关键字 assert. 7.4.2 启用和禁用断言 在默认情况下，断言被禁用。使用 java -ea: 选项启用 7.4.3 使用断言完成参数检查7.4.4 为文档假设使用断言7.5 记录日志7.5.1 基本日志 使用全局日志记录器 (global logger) Logger.getGlobal().info(、、、); 7.5.2 高级日志 日志级别: 七种 SEVRE WARNING INFO CONFIG FINE FINER FINEST 7.5.3 修改日志管理器配置7.5.4 本地化7.5.5 处理器7.5.6 过滤器7.5.7 格式化器7.5.8 日志记录说明总结 总结： 所有的异常类都是由 Throwable 继承而来，下层分为 Error 和 Exception，Exception 又分为 IOException 和 RuntimeException。只有 IOException 是受查异常 (代码提示的异常)，其余都是非受查异常 (平时的崩溃，自己无法控制)。 Error 是 Java 形式内部错误和资源耗尽错误，我们无能为力；而程序中如果出现了 RuntimeException，那一定是程序员自己的问题。对于异常要么 throws 抛出去给别人处理，要么try catch自己处理。一个方法必须声明所有可能抛出的受查异常，而非受查异常是不可控的，应该避免。 子类覆盖超类的方法时，子类声明的受查异常不能比超类中声明的更通用；若超类中没有抛出任何受查异常，子类也不能抛出。 异常可以捕获也可以继续抛出，应该捕获那些知道应该如何处理的异常，而将那些不知道怎样处理的继续抛出 (如工具类中的异常抛出，由调用者自己来分别处理)。 catch 语句中可以继续抛出异常，并将原始异常设置为新异常的原因initCause()，可以让用户抛出子系统中的高级异常，而不会丢失原异常的细节。 try 语句中可以只有 finally 而没有 catch 块，不管异常是否被捕获，finally 语句块都会被执行，finally 语句在方法返回前被执行，所以不要在 finally 中写 return 语句，它会覆盖掉原方法中的 return。 堆栈轨迹 (stack trace) 是一个方法调用过程的列表，它包含了程序执行过程中方法的调用位置。t.getStackTrace()可以获取到一个 StackTraceElementp[] 数组，它包含了方法的 name、className 和调用行 lineNumber 等信息。 一般我们给Thread.setDefaultUnchaughtExceptionHandler()后，在程序非受查崩溃时会回调到 Handler 的uncaughtException(thread,throwable)，在这里可以将throwable.printStackTrace(writer)输出到文件里，然后将文件上传服务器帮助我们分析程序崩溃。 断言：• 定义：断言机制允许在程序测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检查语句会自动被移除。• 表现形式：assert 条件 / assert 条件: 表达式。• 开启断言：默认下断言是被禁用的，启用或禁用断言是类加载器 (ClassLoader) 的功能。启用或禁用使用java -ea/-da，可针对整个项目或某个特定 class 或 package 作用域。• 作用：断言相当于自己做了一层判断，如果符合预期则没什么，如果不符合预期会自动抛出一个 AssertionError 的非受查异常，不用在方法上自己去写 throw 了。重点：264 异常分类、捕获异常 第八章：泛型程序设计（了解） 泛型程序设计指编写的代码可以被许多不同类型的对象所重用，使程序具有更好的可读性和安全性。 泛型变量指域和局部变量及方法的返回类型。泛型可以用于类中也可用于方法中，泛型方法中的类型变量放在修饰符后面，返回类型的前面。 泛型可以用extends关键字指定子类型来做限制，可以 extends 多个类型，用&amp;符间隔。 类型擦除：虚拟机中没有泛型类型对象，把泛型类加载到虚拟机中后，所有定义的泛型 T 都会被擦除成原始类型。有限定类型的话擦除类型变量替换为限定类型 (extends 多继承时取第一个类型 因此标签接口尽量往后放)，无限定类型的话为 Object。 类型擦除与多态的冲突：由于泛型擦除，一个泛型类指向其子类的引用，子类中如果对父类的方法重载 (其实重载不了，父类参数是擦除后的 Object，子类是具体的类型)，在调用方法时，其实先调了父类的方法 (Object 类型)，然后参数强转桥接到了子类的重载方法 (具体类型)。严格上说不能重载，因此子类里是有两个方法的 (可查看子类. class 文件)。 Java 泛型转换总结：• 虚拟机中无泛型，只有普通类和方法；• 所有的参数类型都要用它们的限定类型替换；• 桥方法被合成用来保持多态；为保持类型安全性，必要时插入强制类型转换。 泛型约束：• 不能用类型参数代替基本类型；• 类型检测只会检测原始类型；• 不能实例化参数化类型数组 (不安全)；• 不能实例化类型变量；• 不能在静态域或方法中引用类型变量；• 不能抛出和捕获泛型异常。 泛型之间无联系，不论S与T有什么联系，Pair&lt;S&gt;与Pair&lt;T&gt;无任何联系。Class 类本身是泛型，如String.class是一个Class&lt;String&gt;的实例。 通配符类型中，允许类型参数变化。有&lt;? super X&gt;与&lt;? extends X&gt;，带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。 泛型 与通配符 &lt;?&gt; 的区别：泛型 T 指定一种类型参数的表示，实例化时是什么就是什么；通配符? 代表一种限制，只要符合条件类型是什么都行，可以有多种。重点：P316 泛型擦除 P330 通配符 第九章：集合（重点掌握源码）概述Java 集合框架由 Java 类库的一系列接口、抽象类以及具体实现类组成。我们这里所说的集合就是把一组对象组织到一起，然后再根据不同的需求操纵这些数据。集合类型就是容纳这些对象的一个容器。也就是说，最基本的集合特性就是把一组对象放一起集中管理。根据集合中是否允许有重复的对象、对象组织在一起是否按某种顺序等标准来划分的话，集合类型又可以细分为许多种不同的子类型。 Java 集合框架为我们提供了一组基本机制以及这些机制的参考实现，其中基本的集合接口是 Collection 接口，其他相关的接口还有 Iterator 接口、RandomAccess 接口等。这些集合框架中的接口定义了一个集合类型应该实现的基本机制，Java 类库为我们提供了一些具体集合类型的参考实现，根据对数据组织及使用的不同需求，只需要实现不同的接口即可。Java 类库还为我们提供了一些抽象类，提供了集合类型功能的部分实现，我们也可以在这个基础上去进一步实现自己的集合类型。 Collection 接口迭代器我们先来看下这个接口的定义： 1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; 首先，它使用了一个类型参数；其次，它实现了 Iterable 接口，我们再来看下 Iterable 接口的定义： 123public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; 我们可以看到这个接口只定义了一个方法，这个方法要求我们返回一个实现了 Iterator 类型的对象，所以我们看下 Iterator 的定义： 12345public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125; 说到这里，我们简单地说一下迭代器（Iterator）这个东西。上面我们一共提到了两个和迭代器相关的接口：Iterable 接口和 Iterator 接口，从字面意义上来看，前者的意思是 “可迭代的”，后者的意思是 “迭代器。所以我们可以这么理解这两个接口：实现了 Iterable 接口的类是可迭代的；实现了 Iterator 接口的类是一个迭代器。 迭代器就是一个我们用来遍历集合中的对象的东西。也就是说，对于集合，我们不是像对原始类型数组那样通过数组索引来直接访问相应位置的元素，而是通过迭代器来遍历。这么做的好处是将对于集合类型的遍历行为与被遍历的集合对象分离，这样一来我们无需关心该集合类型的具体实现是怎样的。只要获取这个集合对象的迭代器, 便可以遍历这个集合中的对象了。而像遍历对象的顺序这些细节，全部由它的迭代器来处理。现在我们来梳理一下前面提到的这些东西：首先，Collection 接口实现了 Iterable 接口，这意味着所有实现了 Collection 接口的具体集合类都是可迭代的。那么既然要迭代，我们就需要一个迭代器来遍历相应集合中的对象，所以 Iterable 接口要求我们实现 iterator 方法，这个方法要返回一个迭代器对象。一个迭代器对象也就是实现了 Iterator 接口的对象，这个接口要求我们实现 hasNext()、next()、remove() 这三个方法。其中 hasNext 方法判断是否还有下一个元素（即是否遍历完对象了），next 方法会返回下一个元素（若没有下一个元素了调用它会引起抛出一个 NoSuchElementException 异常），remove 方法用于移除最近一次调用 next 方法返回的元素（若没有调用 next 方法而直接调用 remove 方法会报错）。我们可以想象在开始对集合进行迭代前，有个指针指向集合第一个元素的前面，第一次调用 next 方法后，这个指针会” 扫过” 第一个元素并返回它，调用 hasNext 方法就是看这个指针后面还有没有元素了。也就是说这个指针始终指向刚遍历过的元素和下一个待遍历的元素之间。通常，迭代一个集合对象的代码是这个样子的： 123456Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; iter = c.iterator();while (iter.hasNext()) &#123; String element = iter.next(); //do something with element&#125; 从 Java SE 5.0 开始，我们可以使用与以上代码段等价但是更加简洁的版本： 123for (String element : c) &#123; //do something with element&#125; 上面我们提到过 Iterator 接口的 remove 方法必须在 next 方法返回一个元素后才能调用，这对 Java 类库中为我们提供的实现了 Collection 接口的类来说是这样的。当然我们可以通过自己定义一个实现 Collection 接口的集合类来改变这一默认行为（除非有充足的理由，否则最好不要这样做）。 Collection 接口我们先来看一下它的官方定义： The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Setand List. 大概的意思就是：Collection 接口是集合层级结构的根接口。一个集合代表了一组对象，这组对象被称为集合的元素。一些集合允许重复的元素而其他不允许；一些是有序的而一些是无序的。Java 类库中并未提供任何对这个接口的直接实现，而是提供了对于它的更具体的子接口的实现（比如 Set 接口和 List 接口）。 我们知道，接口是一组对需求的描述，那么让我们看看 Collection 接口提出了哪些需求。Collection 接口中定义了以下方法： 123456789101112131415boolean add(E e) //向集合中添加一个元素，若添加元素后集合发生了变化就返回true，若没有发生变化，就返回false。(optional operation).boolean addAll(Collection&lt;? extends E&gt; c) //添加给定集合c中的所有元素到该集合中(optional operation).void clear() //(optional operation).boolean contains(Object o) //判断该集合中是否包含指定对象boolean containsAll(Collection&lt;?&gt; c)boolean equals(Object o)int hashCode()boolean isEmpty()Iterator&lt;E&gt; iterator()boolean remove(Object o) //移除给定对象的一个实例（有的具体集合类型允许重复元素） (optional operation).boolean removeAll(Collection&lt;?&gt; c) //(optional operation).boolean retainAll(Collection&lt;?&gt; c) //仅保留给定集合c中的元素(optional operation).int size()Object[] toArray()&lt;T&gt; T[] toArray(T[] a) 我们注意到有些方法后面注释中标注了 “optional operation”，意思是 Collection 接口的实现类究竟需不需要实现这个方法视具体情况而定。比如有些具体的集合类型不允许向其中添加对象，那么它就无需实现 add 方法。我们可以看到，Collection 对象必须实现的方法有：contains 方法、containsAll 方法、isEmpty 方法、iterator 方法、size 方法、两个 toArray 方法以及 equals 方法、hashCode 方法，其中最后两个方法继承自 Object 类。 我们来说一下两个 toArray 方法，它们的功能都是都是返回这个集合的对象数组。第二个方法接收一个 arrayToFill 参数，当这个参数数组足够大时，就把集合中的元素都填入这个数组（多余空间填 null）；当 arrayToFill 不够大时，就会创建一个大小与集合相同，类型与 arrayToFill 相同的数组，并填入集合元素。 Collection 接口的直接子接口主要有三个：List 接口、Set 接口和 Queue 接口。下面我们对它们进行逐一介绍。 List 接口我们同样先看下它的官方定义： An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list.Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. 大概意思是：List 是一个有序的集合类型（也被称作序列）。使用 List 接口可以精确控制每个元素被插入的位置，并且可以通过元素在列表中的索引来访问它。列表允许重复的元素，并且在允许 null 元素的情况下也允许多个 null 元素。 我们再来看下它定义了哪些方法： 123456ListIterator&lt;E&gt; listIterator();void add(int i, E element);E remove(int i);E get(int i);E set(int i, E element);int indexOf(Object element); 我们可以看到，列表支持对指定位置元素的读写与移除。我们注意到，上面有一个 listIterator 方法，它返回一个列表迭代器。我们来看一看 ListIterator 接口都定义了哪些方法： 12345678void add(E e) //在当前位置添加一个元素boolean hasNext() //返回ture如果还有下个元素（在正向遍历列表时使用）boolean hasPrevious() //反向遍历列表时使用E next() //返回下一个元素并将cursor（也就是我们上文提到的”指针“）前移一个位置int nextIndex() //返回下一次调用next方法将返回的元素的索引E previous() //返回前一个元素并将cursor向前移动一个位置int previousIndex() //返回下一次调用previous方法将返回的元素的索引void remove() //从列表中移除最近一次调用next方法或previous方法返回的元素void set(E e) //用e替换最近依次调用next或previous方法返回的元素 ListIterator 是 Iterator 的子接口，它支持像双向迭代这样更加特殊化的操作。综合以上，我们可以看到，List 接口支持两种访问元素的方式：使用列表迭代器顺序访问或者使用 get/set 方法随机访问。 Java 类库中常见的实现了 List 接口的类有：ArrayList， LinkedList，Stack，Vector，AbstractList，AbstractSequentialList 等等。 ArrayListArrayList 是一个可动态调整大小的数组，允许 null 类型的元素。我们知道，Java 中的数组大小在初始化时就必须确定下来，而且一旦确定就不能改变，这会使得在很多场景下不够灵活。ArrayList 很好地帮我们解决了这个问题，当我们需要一个能根据包含元素的多少来动态调整大小的数组时，那么 ArrayList 正是我们所需要的。 我们先来看看这个类的常用方法： 1234567891011121314boolean add(E e) //添加一个元素到数组末尾void add(int index, E element) //添加一个元素到指定位置void clear()boolean contains(Object o)void ensureCapacity(int minCapacity) //确保ArrayList至少能容纳参数指定数目的对象，若有需要会增加ArrayList实例的容量。E get(int index) //返回指定位置的元素int indexOf(Object o)boolean isEmpty()Iterator&lt;E&gt; iterator()ListIterator&lt;E&gt; listIterator()E remove(int index)boolean remove(Object o)E set(int index, E element)int size() 当我们插入了比较多的元素，导致 ArrayList 快要装满时，它会自动增长容量。ArrayList 内部使用一个 Object 数组来存储元素，自动增长容量是通过创建一个新的容量更大的 Object 数组，并将元素从原 Object 数组复制到新 Object 数组来实现的。若要想避免这种开销，在知道大概会容纳多少数据时，我们可以在构造时指定好它的大小以尽量避免它自动增长的发生；我们也可以调用 ensureCapacity 方法来增加 ArrayList 对象的容量到我们指定的大小。ArrayList 有以下三个构造器： 123ArrayList()ArrayList(Collection&lt;? extends E&gt; c)ArrayList(int initialCapacity) //指定初始capacity，即内部Object数组的初始大小 LinkedList 类LinkedList 类代表了一个双向链表，允许 null 元素。这个类同 ArrayList 一样，不是线程安全的。这个类中主要有以下的方法： 123456void addFirst(E element);void addLast(E element);E getFirst();E getLast();E removeFirst();E removeLast(); 这些方法的含义正如它们的名字所示。LinkedList 作为 List 接口的实现类，自然包含了 List 接口中定义的 add 等方法。LinkedList 的 add 方法实现有以下两种： 12boolean add(E e) //把元素e添加到链表末尾void add(int index, E element) //在指定索引处添加元素 LinkedList 的一个缺陷在于它不支持对元素的高效随机访问，要想随机访问其中的元素，需要逐个扫描直到遇到符合条件的元素。只有当我们需要减少在列表中间添加或删除元素操作的代价时，可以考虑使用 LinkedList。 Set 接口Set 接口与 List 接口的重要区别就是它不支持重复的元素，至多可以包含一个 null 类型元素。Set 接口定义的是数学意义上的 “集合” 概念。Set 接口主要定义了以下方法： 1234567891011boolean add(E e)void clear()boolean contains(Object o)boolean isEmpty()boolean equals(Object obj)Iterator&lt;E&gt; iterator()boolean remove(Object o)boolean removeAll(Collection&lt;?&gt; c)int size()Object[] toArray()&lt;T&gt; T[] toArray(T[] a) Set 接口并没有显式要求其中的元素是有序或是无序的，它有一个叫做 SortedSet 的子接口，这个接口可以用来实现对 Set 元素的排序，SortedSet 还有叫做 NavigableSet 的子接口，这个接口定义的方法可以在有序 Set 中进行查找和遍历。Java 类库中实现了 Set 接口的类主要有：AbstractSet，HashSet，TreeSet，EnumSet，LinkedHashSet 等等。其中，HashSet 与 TreeSet 都是 AbstractSet 的子类。那么，为什么 Java 类库要提供 AbstractSet 这个抽象类呢？答案是为了让我们在自定义实现 Set 接口的类时不必 “从零开始”，AbstractSet 这个抽象类已经为我们实现了 Set 接口中的一些常规方法，而一些灵活性比较强的方法可以由我们自己来定义，我们只需要继承 AbstractSet 这个抽象类即可。类似的抽象类还有很多，比如我们上面提到的实现了 List 接口的 AbstractList 抽象类就是 LinkedList 和 ArrayList 的父类。Java 官方文档中提到，HashSet 和 TreeSet 分别基于 HashMap 和 TreeMap 实现（我们在后面会简单介绍 HashMap 和 TreeMap），他们的区别在于 Set 接口是一个对象的集（数学意义上的” 集合“），Map&lt;K, V &gt; 是一个键值对的集合。而且由于它们分别是对 Set 和 Map&lt;K, V &gt; 接口的实现，相应添加与删除元素的方法也取决于具体接口的定义。 Queue 接口Queue 接口是对队列这种数据结构的抽象。一般的队列实现允许我们高效的在队尾添加元素，在队列头部删除元素（First in, First out)。Queue 接口还有一个名为 Deque 的子接口，它允许我们高效的在队头或队尾添加 / 删除元素，实现了 Deque 的接口的集合类即为双端队列的一种实现（比如 LinkedList 就实现了 Deque 接口）。Queue 接口定义了以下方法： 123456boolean add(E e) //添加一个元素到队列中，若队列已满会抛出一个IllegalStateException异常E element() //获取队头元素boolean offer(E e) //添加一个元素到队列中，若队列已满返回falseE peek() //获取队头元素，若队列为空返回nullE poll() //返回并移除队头元素，若队列为空返回nullE remove() //返回并移除队头元素 我们注意观察下上面的方法：add 与 offer，element 与 peek，remove 与 poll 看似是三对儿功能相同的方法。它们之间的重要区别在于前者若操作失败会抛出一个异常，后者若操作失败会从返回值体现出来（比如返回 false 或 null），我们可以根据具体需求调用它们中的前者或后者。 实现 Queue 接口的类主要有：AbstractQueue， ArrayDeque， LinkedList，PriorityQueue，DelayQueue 等等。关于它们具体的介绍可参考官方文档或相关的文章。 Map 接口我们先来看下它的定义： An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.The Mapinterface provides three collection views, which allow a map’s contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map’s collection views return their elements. Some map implementations, like the TreeMapclass, make specific guarantees as to their order; others, like the HashMapclass, do not. 大概意思是这样的：一个把键映射到值的对象被称作一个 Map 对象。映射表不能包含重复的键，每个键至多可以与一个值关联。Map 接口提供了三个集合视图（关于集合视图的概念我们下面会提到）：键的集合视图、值的集合视图以及键值对的集合视图。一个映射表的顺序取决于它的集合视图的迭代器返回元素的顺序。一些 Map 接口的具体实现（比如 TreeMap）保证元素有一定的顺序，其它一些实现（比如 HashMap）则不保证元素在其内部有序。 也就是说，Map 接口定义了一个类似于 “字典” 的规范，让我们能够根据键快速检索到它所关联的值。我们先来看看 Map 接口定义了哪些方法： 1234567891011void clear()boolean containsKey(Object key) //判断是否包含指定键boolean containsValue(Object value) //判断是否包含指定值boolean isEmpty()V get(Object key) //返回指定键映射的值V put(K key, V value) //放入指定的键值对V remove(Object key)int size()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Set&lt;K&gt; keySet()Collection&lt;V&gt; values() 后三个方法在我们下面介绍集合视图时会具体讲解。 Map 接口的具体实现类主要有：AbstractMap，EnumMap，HashMap，LinkedHashMap，TreeMap。HashTable。 HashMap我们看一下 HashMap 的官方定义： HashMap&lt;K, V&gt; 是基于哈希表这个数据结构的 Map 接口具体实现，允许 null 键和 null 值。这个类与 HashTable 近似等价，区别在于 HashMap 不是线程安全的并且允许 null 键和 null 值。由于基于哈希表实现，所以 HashMap 内部的元素是无序的。HashMap 对与 get 与 put 操作的时间复杂度是常数级别的（在散列均匀的前提下）。对 HashMap 的集合视图进行迭代所需时间与 HashMap 的 capacity（bucket 的数量）加上 HashMap 的尺寸（键值对的数量）成正比。因此，若迭代操作的性能很重要，不要把初始 capacity 设的过高（不要把 load factor 设的过低）。 有两个因素会影响一个 HashMap 对象的性能：intial capacity（初始容量）和 load factor（负载因子）。intial capacity 就是 HashMap 对象刚创建时其内部的哈希表的 “桶” 的数量（请参考哈希表的定义）。load factor 等于 maxSize / capacity，也就是 HashMap 所允许的最大键值对数与桶数的比值。增大 load factor 可以节省空间但查找一个元素的时间会增加，减小 load factor 会占用更多的存储空间，但是 get 与 put 的操作会更快。当 HashMap 中的键值对数量超过了 maxSize（即 load factor 与 capacity 的乘积），它会再散列，再散列会重建内部数据结构，桶数（capacity）大约会增加到原来的两倍。 HashMap 默认的 load factor 大小为 0.75，这个数值在时间与空间上做了很好的权衡。当我们清楚自己将要大概存放多少数据时，也可以自定义 load factor 的大小。 HashMap 的构造器如下： 1234HashMap()HashMap(int initialCapacity)HashMap(int initialCapacity, float loadFactor)HashMap(Map&lt;? extends K,? extends V&gt; m) //创建一个新的HashMap，用m的数据填充 常用方法如下： 1234567891011void clear()boolean containsKey(Object key)boolean containsValue(Object value)V get(Object key)V put(K key, V value)boolean isEmpty()V remove(Object key)int size()Collection&lt;V&gt; values()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()Set&lt;K&gt; keySet() 它们的功能都很直观，更多的使用细节可以参考 Java 官方文档，这里就不贴上来了。这里简单地提一下 WeakHashMap，它与 HashMap 的区别在于，存储在其中的 key 是 “弱引用” 的，也就是说，当不再存在对 WeakHashMap 中的键的外部引用时，相应的键值对就会被回收。关于 WeakHashMap 和其他类的具体使用方法及注意事项，大家可以参考官方文档。下面我们来简单地介绍下另一个 Map 接口的具体实现——TreeMap。 TreeMap它的官方定义是这样的： TreeMap&lt;K, V&gt; 一个基于红黑树的 Map 接口实现。TreeMap 中的元素的有序的，排序的依据是存储在其中的键的 natural ordering（自然序，也就是数字从小到大，字母的话按照字典序）或者根据在创建 TreeMap 时提供的 Comparator 对象，这取决于使用了哪个构造器。TreeMap 的 containsKey, get, put 和 remove 操作的时间复杂度均为 log(n)。 TreeMap 有以下构造器： 1234TreeMap() //使用自然序对其元素进行排序TreeMap(Comparator&lt;? super K&gt; comparator) //使用一个比较器对其元素进行排序TreeMap(Map&lt;? extends K,? extends V&gt; m) //构造一个与映射表m含有相同元素的TreeMap，用自然序进行排列TreeMap(SortedMap&lt;K,? extends V&gt; m) //构造一个与有序映射表m含有相同元素及元素顺序的TreeMap 它的常见方法如下： 12345678910111213141516Map.Entry&lt;K,V&gt; ceilingEntry(K key) //返回一个最接近且大于等于指定key的键值对。K ceilingKey(K key)void clear()Comparator&lt;? super K&gt; comparator() //返回使用的比较器，若按自然序则返回nullboolean containsKey(Object key)boolean containsValue(Object value)NavigableSet&lt;K&gt; descendingKeySet() //返回一个包含在TreeMap中的键的逆序的NavigableSet视图NavigableMap&lt;K,V&gt; descendingMap()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()Map.Entry&lt;K,V&gt; firstEntry() //返回键最小的键值对Map.Entry&lt;K,V&gt; floorEntry(K key) //返回一个最接近指定key且小于等于它的键对应的键值对K floorKey(K key)V get(Object key)Set&lt;K&gt; keySet()Map.Entry&lt;K,V&gt; lastEntry() //返回与最大的键相关联的键值对K lastKey() 建议大家先了解下红黑树这个数据结构的原理及实现（可参考算法（第 4 版） (豆瓣)），然后再去看官方文档中关于这个类的介绍，这样学起来会事半功倍。 最后再简单地介绍下 NavigableMap&lt;K, V&gt; 这个接口： 实现了这个接口的类支持一些 navigation methods，比如 lowerEntry（返回小于指定键的最大键所关联的键值对），floorEntry（返回小于等于指定键的最大键所关联的键值对），ceilingEntry（返回大于等于指定键的最小键所关联的键值对）和 higerEntry（返回大于指定键的最小键所关联的键值对）。一个 NavigableMap 支持对其中存储的键按键的递增顺序或递减顺序的遍历或访问。NavigableMap&lt;K, V&gt; 接口还定义了 firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 等方法，以准确获取指定位置的键值对。 总的来说，NavigableMap&lt;K, V&gt; 接口正如它的名字所示，支持我们在映射表中” 自由的航行 “，正向或者反向迭代其中的元素并获取我们需要的指定位置的元素。TreeMap 实现了这个接口。 视图（View）与包装器下面我们来解决一个上面遗留的问题，也就是介绍一下集合视图的概念。Java 中的集合视图是用来查看集合中全部或部分数据的一个”窗口 “，只不过通过视图我们不仅能查看相应集合中的元素，对视图的操作还可能会影响到相应的集合。通过使用视图可以获得其他的实现了 Map 接口或 Collection 接口的对象。比如我们上面提到的 TreeMap 和 HashMap 的 keySet() 方法就会返回一个相应映射表对象的视图。也就是说，keySet 方法返回的视图是一个实现了 Set 接口的对象，这个对象中又包含了一系列键对象。 轻量级包装器Arrays.asList 会发挥一个包装了 Java 数组的集合视图（实现了 List 接口）。请看以下代码： 1234567public static void main(String[] args) &#123; String[] strings = &#123;"first", "second", "third"&#125;; List&lt;String&gt; stringList = Arrays.asList(strings); String s1 = stringList.get(0); System.out.println(s1); stringList.add(0, "new first");&#125; 以上代码会编译成功，但是在运行时会抛出一个 UnsupportedOperationException 异常，原因是调用了改变列表大小的 add 方法。Arrays.asList 方法返回的封装了底层数组的集合视图不支持对改变数组大小的方法（如 add 方法和 remove 方法）的调用（但是可以改变数组中的元素）。实际上，这个方法调用了以下方法： 1Collections.nCopies(n, anObject); 这个方法会返回一个实现了 List 接口的不可修改的对象。这个对象包含了 n 个元素（anObject）。 子范围我们可以为很多集合类型建立一个称为子范围（subrange）的集合视图。例如以下代码抽出 group 中的第 10 到 19 个元素（从 0 开始计数）组成一个子范围： 1List subgroup = group.subList(10, 20); //group为一个实现了List接口的列表类型 List 接口所定义的操作都可以应用于子范围，包括那些会改变列表大小的方法，比如以下方法会把 subgroup 列表清空，同时 group 中相应的元素也会从列表中移除： 1subgroup.clear(); 对于实现了 SortedSet 接口的有序集或是实现了 SortedMap&lt;K, V &gt; 接口的有序映射表，我们也可以为他们创建子范围。SortedSet 接口定义了以下三个方法： 123SortedSet&lt;E&gt; subSet(E from, E to); SortedSet&lt;E&gt; headSet(E to);SortedSet&lt;E&gt; tailSet(E from); SortedMap 也定义了类似的方法： 123SortedMap&lt;K, V&gt; subMap(K from, K to);SortedMap&lt;K, V&gt; headMap(K to);SortedMap&lt;K, V&gt; tailMap(K from); 不可修改的视图Collections 类中的一些方法可以返回不可修改视图（unmodifiable views)： 123456Collections.unmodifiableCollectionCollections.unmodifiableListCollections.unmodifiableSetCollections.unmodifiableSortedSetCollections.unmodifiableMapCollections.unmodifiableSortedMap 同步视图若集合可能被多个线程并发访问，那么我们就需要确保集合中的数据不会被破坏。Java 类库的设计者使用视图机制来确保常规集合的线程安全。比如，我们可以调用以下方法将任意一个实现了 Map 接口的集合变为线程安全的： 1Map&lt;String, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;()); 被检验视图我们先看一下这段代码： 123ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;();ArrayList rawList = strings;rawList.add(new Date()); 在以上代码的第二行，我们把泛型数组赋值给了一个原始类型数组，这通常只会产生一个警告。而第三行我们往 rawList 中添加一个 Date 对象时，并不会产生任何错误。因为 rawList 内部存储的实际上是 Object 对象，而任何对象都可以转换为 Object 对象。那么我们怎么避免这一问题呢，请看以下代码： 1234ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;();List&lt;String&gt; safeStrings = Collections.checkedList(strings, String.class);ArrayList rawList = safeStrings;rawList.add(new Date()); //Checked list throws a ClassCastException 在上面，我们通过包装 strings 得到一个被检验视图 safeStrings。这样在尝试添加非 String 对象时，便会抛出一个 ClassCastException 异常。 集合视图的本质集合视图本身不包含任何数据，它只是对相应接口的包装。集合视图所支持的所有操作都是通过访问它所关联的集合类实例来实现的。我们来看看 HashMap 的 keySet 方法的源码： 12345678910111213141516171819202122232425262728293031323334353637public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks; return (ks = keySet) == null ? (keySet = new KeySet()) : ks;&#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125;&#125; 我们可以看到，实际上 keySet() 方法返回一个内部 final 类 KeySet 的实例。我们可以看到 KeySet 类本身没有任何实例变量。我们再看 KeySet 类定义的 size() 实例方法，它的实现就是通过直接返回 HashMap 的实例变量 size。还有 clear 方法，实际上调用的就是 HashMap 对象的 clear 方法。 keySet 方法能够让你直接访问到 Map 的键集，而不需要复制数据或者创建一个新的数据结构，这样做往往比复制数据到一个新的数据结构更加高效。考虑这样一个场景：你需要把一个之前创建的数组传递给一个接收 List 参数的方法，那么你可以使用 Arrays.asList 方法返回一个包装了数组的视图（这需要的空间复杂度是常数级别的），而不用创建一个新的 ArrayList 再把原数组中的数据复制过去。 Collections 类我们要注意到 Collections 类与 Collection 接口的区别：Collection 是一个接口，而 Collections 是一个类（可以看做一个静态方法库）。下面我们看一下官方文档对 Collections 的描述： Collections 类包含了大量用于操作或返回集合的静态方法。它包含操作集合的多态算法，还有包装集合的包装器方法等等。这个类中的所有方法在集合或类对象为空时均会抛出一个 NullPointerException。 关于 Collections 类中的常用方法，我们上面已经做了一些介绍，更加详细的介绍大家可以参考 Java 官方文档。 总结关于 Java 集合框架，我们首先应该把握住几个核心的接口，请看下图（下图中 LinkList 拼写有误，应为 LinkedList）： 我们还要了解到这些接口描述了一组什么样的机制，然后以此作为出发点，去了解具体哪些类实现了哪些机制。像这样自顶向下的学习，我们很快就能掌握常见集合类的用法。对于一些我们平常经常使用的类，我们还可以阅读一下它的源码，了解它的实现细节，这样我们以后使用起来会更加得心应手。不过阅读一些集合类（比如 TreeMap、HashMap）的源码需要我们具备一定的数据结构与算法的基础知识，这方面推荐阅读 算法（第 4 版） (豆瓣)。 参考资料 《Java 核心技术（卷一）》 What is a view of a collection? Java SE 7 Docs 总结： 概念：• Java 集合类库将接口与实现分离，接口定义增删改查等方法，具体分为集合和映射两种基本接口 (Collection 和 Map)。Collection 接口实现了 Iterable 接口，往下又分为 List、Set 和 Queue，Set 往下有 SortSet 等；Map 下有 SortedMap 等 (都是接口)。RandomAccess 接口用于判断该集合是否支持高效的随机访问。• 集合没有 key 值，映射有 key 和 value。集合的实现可以使用具体的数据结构来存储数据，每种数据结构的特点不同。注意 Tree、优先级队列等是随机插入，按指定顺序输入；而 Linked 是按插入顺序输出。• 常用的几种具体集合和映射：ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet、LinkedBlockingDeque 等 (Collection 集合)；HashMap、LinkedHashMap、WeadHashMap 等 (Map 映射)。• Java 集合接口可以定义不同的实现，不同实现使用不同的数据结构，各种数据结构有自己的特点，另外结合泛型、迭代器，因此可以定义各种不同的数据存储方式。接口从Collection-&gt;List等有不同等级，每层接口定义的方法不同，逐步完善。中间也提供了一些抽象父类完成了一些基本实现，如元素默认判等使用equals()方法，因此 Set 也要求我们自定义equals()方法。 接口 List 可以添加重复元素，是有序的；Set 不能添加重复元素，是无序的。所以元素被访问的顺序取决于集合类型。 迭代器：• Java 的迭代器位于两个元素之间，调用next()时，迭代器越过下一个元素，并返回刚刚越过的元素。调用remove()时将删除上次调用next()越过的那个元素。调用remove()之前没有调用next()是不合法的 (不能连续两次调用 remove())。• add()方法插入元素到光标之前。add()方法依赖于迭代器位置，remove()方法依赖于迭代器状态。迭代器可以并发读，要控制并发写。listIterator 的set()方法用一个新元素的值取代越过返回的那个元素，可返回局部迭代器。 集 set 中要适当的定义集的equals()方法，如只要两个集包含数据相同的元素 (不要求顺序相同，不要求是同一个对象)，就认为是相等的。相等的两个集合要求要有相同的散列码 hashCode(注意是子元素这一层定义 equals()、hashCode() 等方法，集合这一层的 equals()里根据子元素再自定义判等)。 List 是有序集合，访问可以通过迭代器顺序访问或通过下标随机访问，但是不同数据结构随机访问性能差别很大，如随机插入、删除使用 LinkedList(双向链表结构，数据保存在节点中，每个节点保存着前驱和后继的节点，便于插入删除；但是随机访问要挨个移动指针，因此不支持快速随机访问)；随机查询使用 ArrayList，可以通过索引来访问 (动态数组结构，支持二分查找随机访问，中间增删要移动和赋值数据，效率低，需要把插入位置后所有元素往后移动)。因此 ArrayList 使索引访问更快，LinkedList 最好使用迭代器遍历。数组动态查询之所以快是因为开辟连续的内存地址存储数据，找到一个位置就能知道其他位置，也因此是有界的，且动态插入效率低；而链表是将数据放在节点中，真正的数据内存地址不需连续，因此随机查询效率低，每次都要找出内存地址，但是随机插入高效，只需要改节点的指针即可，也满足了无界。 LinkedList 列表的get()方法实际上做了微小的优化，如果索引大于size()/2的话就从列表尾端开始搜索元素。但是 for 循环中的list.get(i)是效率很低的，每次都要从头遍历，因此随机查询不建议使用 LinkedList。插入时add()方法默认插入到尾部，插入中间可以用add(i)或迭代器listIterable.add()插入 (依赖光标位置)，listIterable 迭代器也能返回局部迭代列表。 Vector 类和 HashTable 类的方法都是同步的，可以线程安全的访问对象，但是因此效率比较低。不考虑线程安全的话建议使用 ArrayList 和 HashMap。 散列表：提供快速查找的数据结构，为每一个对象计算一个整数，称为散列码，散列码是由对象的实例域产生的一个整数。Java 中散列表用链表数组实现，每个列表被称为桶。查找表中对象的位置，先计算散列码，与桶的总数取余，结果就是保存这个元素的桶的索引，因此只需要在这个桶中找数据即可。 桶中已有一个元素的情况称为 “散列冲突” 或“哈希冲突”，这时默认策略是按列表继续往后放元素 (也有策略是寻找下一个桶)，桶满时(有个默认桶满值如 8) 会从列表变为平衡二叉树(树结构查询更快)。如果散列表太满(不论元素在哪个桶中，总的 size / 总桶数大于填充因子就算满了)，就需要再散列(以 2 的倍数扩桶)。创建一个桶更多的表将所有元素插入到这个新表中，丢弃原来的表。装填因子决定何时对散列表再散列，默认为 0.75。 所谓 Set 是无序的，因为算出的桶索引是无序的，add 的元素不一定在哪个索引下；另外 Set 无重复元素因为hashCode()算出的桶索引基本不会一样，如果一样了，还会继续判equals()是否一致，一致则覆盖，否则往后链表里加。 queals()方法和hashCode()的定义必须兼容，如果x.equals(y)为 true，x.hashCode()也必须等于y.hashCode()。 树集 TreeSet 是一个有序集合，按任意顺序插入，迭代器遍历时会顺序输出，排序使用红黑树实现。使用树集必须能够比较元素，因此元素必须实现 Comparator 接口或构造方法中传入一个 Comparator。将一个元素插入到树中比插入到散列集要稍微慢一点点，但是检查数组或链表中的重复元素，树稍微快一点，所以单个桶满会将链表变二叉树。 队列接口可以在尾部添加元素，在头部删除元素，不可在中间插入，并且可以查找队列中元素的个数。队列接口的实现方式通常有循环数组 (有界) 和列表 (无界) 两种方式。 优先级队列的元素可以按任意方式插入，却总是按排序的顺序进行检索。内部使用堆 (可自我调整的二叉树，每次插入完就已经是有序的了) 来存储数据，迭代并不是按照元素顺序访问，而删除却总是删除掉优先级最小的那个元素，也需要提供 Comparator。多用于任务调度中任务队列的实现。 映射：不同于集合直接存放精确数据副本，而是用来存放键值对。通用分为 HashMap 和 TreeMap，散列映射对键进行散列，树映射用键的整体顺序来排序。get()时没有对应键的信息，则返回null；键可以为 null，值不能为 null；重复调用put()方法会覆盖掉上一次的值，put()方法返回上一次的旧值 (没有返回 null)。 视图：集合框架认为映射本身不是一个集合，但它的视图是实现了 Collection 接口或某个子接口的对象。有三种：键集 (Set)、值集合 (Collection)、键 / 值对集 (Set)。KeySet 并不是 HashSet 或 TreeSet，只是实现了 Set 接口的某个类对象。既然是集合，就有迭代器，但是仅对原映射集可删除不能增加。 WeakedHashMap 弱散列映射解决映射强引用问题，当元素只被散列条目引用时，会将其加入到弱引用队列，等待垃圾回收机制将其回收。LinkedHashMap/Set 可以记录插入顺序，但是使用访问顺序进行迭代 (同一个桶中元素被访问后会从当前节点删除加入到链表尾部)，且重写removeEldestEntry()方法可以实现类似 LRU 算法的 Map，不过这种迭代顺序的影响只有发生散列冲突时才能看出来。 Collections 的静态方法synchronizedMap()方法可以将任意一个映射表转成线程安全的 Map。不管是集合还是映射，是有并发问题的，不可一个迭代器正在修改，另一个迭代器在读，会抛出异常。 Collections 的sort()方法可以进行排序，shuffle()方法可以进行乱序，binarySearch()方法进行二分查找等，类似 Arrays 的一些方法。 属性映射 Property 是一种特殊的映射结构，键值都是字符串，可以load(InputStream is)加载，也可store(OutputStream out,String str)写出。 栈 Stack 后进先出，有push()、pop()、peek()等方法，注意pop()和peek()如果站内无元素是会抛异常。 位集 BitSet 可高效存储位序列，元素包装在字节里，比 ArrayList 存 Boolean 效率高。 几种数据结构比较：• 数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)。• 链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)。• 二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。• 哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。 HashMap 的实现原理：内部采用散列表进行存储，散列表数据结构为数组 + 链表，数组保证快速定位，链表保证哈希冲突 (策略有开放地址法、再散列函数法和链地址法)。JDK1.7 中默认容量 16，链表变树临界值 8，填充因子 0.75，size表示当前 Entry 总数 (不管是单桶还是多桶中)，threshold表示临界扩容桶值。在第一次put()中才给table赋值，hash()对 key 值取 hashCode 进行一系列异或位移操作保证均匀分布，indexFor()这里要求桶数每次都是 2 的幂，这样桶数 - 1 后二进制一定是全 1，不管是直接计算索引值还是再散列时对之前的所有元素重新计算 index 时，需要尽可能快，而 hashCode 不论多大与全 1 进行&amp;运算时，前面全部是非，裁掉了，后面得出的结果就是余数大小，小小算法有点叼 (位运算性能更高吧)。一般来说，对单桶，大于链表变树临界值则将链表变为树结构 (树的查询更快)，对多桶，总数大于threshold临界值则需扩容，但是桶总数 64 之前，该链表变树时优先扩容，桶数大于 64 之后再该变树变树该扩容扩容，可能是优先尽量避免哈希冲突吧。重点：都很重要 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射由浅入深 | 进阶必备]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-2%2F</url>
    <content type="text"><![CDATA[一、Java 反射机制 Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 反射机制很重要的一点就是 “运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。 不知道上面的理论你能否明白，反正刚接触反射时我一脸懵比，后来写了几个例子之后：哦~~ 原来是这个意思！ 若暂时不明白理论没关系，先往下看例子，之后再回来看相信你就能明白了。 二、使用反射获取类的信息为使得测试结果更加明显，我首先定义了一个 FatherClass 类（默认继承自 Object 类），然后定义一个继承自 FatherClass 类的 SonClass 类，如下所示。可以看到测试类中变量以及方法的访问权限不是很规范，是为了更明显得查看测试结果而故意设置的，实际项目中不提倡这么写。 FatherClass.java 123456public class FatherClass &#123; public String mFatherName; public int mFatherAge; public void printFatherMsg()&#123;&#125;&#125; SonClass.java 123456789101112131415161718192021222324252627public class SonClass extends FatherClass&#123; private String mSonName; protected int mSonAge; public String mSonBirthday; public void printSonMsg()&#123; System.out.println("Son Msg - name : " + mSonName + "; age : " + mSonAge); &#125; private void setSonName(String name)&#123; mSonName = name; &#125; private void setSonAge(int age)&#123; mSonAge = age; &#125; private int getSonAge()&#123; return mSonAge; &#125; private String getSonName()&#123; return mSonName; &#125;&#125; 1. 获取类的所有变量信息12345678910111213141516171819202122232425/** * 通过反射获取类的所有变量 */private static void printFields()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的变量 // 包括本类声明的和从父类继承的 Field[] fields = mClass.getFields(); //2.2 获取所有本类声明的变量（不问访问权限） //Field[] fields = mClass.getDeclaredFields(); //3\. 遍历变量并输出变量信息 for (Field field :fields) &#123; //获取访问权限并输出 int modifiers = field.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //输出变量的类型及变量名 System.out.println(field.getType().getName() + " " + field.getName()); &#125;&#125; 以上代码注释很详细，就不再解释了。需要注意的是注释中 2.1 的 getFields() 与 2.2 的 getDeclaredFields() 之间的区别，下面分别看一下两种情况下的输出。看之前强调一下：SonClass extends FatherClass extends Object ： 调用 getFields() 方法，输出 SonClass 类以及其所继承的父类 ( 包括 FatherClass 和 Object ) 的 public 方法。注：Object 类中没有成员变量，所以没有输出。 1234类的名称：obj.SonClasspublic java.lang.String mSonBirthdaypublic java.lang.String mFatherNamepublic int mFatherAge 调用 getDeclaredFields() ， 输出 SonClass 类的所有成员变量，不问访问权限。 1234类的名称：obj.SonClassprivate java.lang.String mSonNameprotected int mSonAgepublic java.lang.String mSonBirthday 2. 获取类的所有方法信息123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 通过反射获取类的所有方法 */private static void printMethods()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的方法 //包括自己声明和从父类继承的 Method[] mMethods = mClass.getMethods(); //2.2 获取所有本类的的方法（不问访问权限） //Method[] mMethods = mClass.getDeclaredMethods(); //3.遍历所有方法 for (Method method : mMethods) &#123; //获取并输出方法的访问权限（Modifiers：修饰符） int modifiers = method.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //获取并输出方法的返回值类型 Class returnType = method.getReturnType(); System.out.print(returnType.getName() + " " + method.getName() + "( "); //获取并输出方法的所有参数 Parameter[] parameters = method.getParameters(); for (Parameter parameter: parameters) &#123; System.out.print(parameter.getType().getName() + " " + parameter.getName() + ","); &#125; //获取并输出方法抛出的异常 Class[] exceptionTypes = method.getExceptionTypes(); if (exceptionTypes.length == 0)&#123; System.out.println(" )"); &#125; else &#123; for (Class c : exceptionTypes) &#123; System.out.println(" ) throws " + c.getName()); &#125; &#125; &#125;&#125; 同获取变量信息一样，需要注意注释中 2.1 与 2.2 的区别，下面看一下打印输出： 调用 getMethods() 方法获取 SonClass 类所有 public 访问权限的方法，包括从父类继承的。打印信息中，printSonMsg() 方法来自 SonClass 类， printFatherMsg() 来自 FatherClass 类，其余方法来自 Object 类。 123456789101112类的名称：obj.SonClasspublic void printSonMsg( )public void printFatherMsg( )public final void wait( ) throws java.lang.InterruptedExceptionpublic final void wait( long arg0,int arg1, ) throws java.lang.InterruptedExceptionpublic final native void wait( long arg0, ) throws java.lang.InterruptedExceptionpublic boolean equals( java.lang.Object arg0, )public java.lang.String toString( )public native int hashCode( )public final native java.lang.Class getClass( )public final native void notify( )public final native void notifyAll( ) 调用 getDeclaredMethods() 方法 打印信息中，输出的都是 SonClass 类的方法，不问访问权限。 123456类的名称：obj.SonClassprivate int getSonAge( )private void setSonAge( int arg0, )public void printSonMsg( )private void setSonName( java.lang.String arg0, )private java.lang.String getSonName( ) 三、访问或操作类的私有变量和方法在上面，我们成功获取了类的变量和方法信息，验证了在运行时 动态的获取信息 的观点。那么，仅仅是获取信息吗？我们接着往后看。 都知道，对象是无法访问或操作类的私有变量和方法的，但是，通过反射，我们就可以做到。没错，反射可以做到！下面，让我们一起探讨如何利用反射访问 类对象的私有方法 以及修改 私有变量或常量。 老规矩，先上测试类。 注： 请注意看测试类中变量和方法的修饰符（访问权限）； 测试类仅供测试，不提倡实际开发时这么写 : ) TestClass.java 123456789101112public class TestClass &#123; private String MSG = "Original"; private void privateMethod(String head , int tail)&#123; System.out.print(head + tail); &#125; public String getMsg()&#123; return MSG; &#125;&#125; 3.1 访问私有方法以访问 TestClass 类中的私有方法 privateMethod(...) 为例，方法加参数是为了考虑最全的情况，很贴心有木有？先贴代码，看注释，最后我会重点解释部分代码。 1234567891011121314151617181920212223242526272829/** * 访问对象的私有方法 * 为简洁代码，在方法上抛出总的异常，实际开发别这样 */private static void getPrivateMethod() throws Exception&#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有方法 //第一个参数为要获取的私有方法的名称 //第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null //方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125; Method privateMethod = mClass.getDeclaredMethod("privateMethod", String.class, int.class); //3\. 开始操作方法 if (privateMethod != null) &#123; //获取私有方法的访问权 //只是获取访问权，并不是修改实际权限 privateMethod.setAccessible(true); //使用invoke反射调用私有方法 //privateMethod是获取到的私有方法 //testClass要操作的对象 //后面两个参数传实参 privateMethod.invoke(testClass, "Java Reflect ", 666); &#125;&#125; 需要注意的是，第 3 步中的 setAccessible(true) 方法，是获取私有方法的访问权限，如果不加会报异常 IllegalAccessException，因为当前方法访问权限是 “private” 的，如下： 1java.lang.IllegalAccessException: Class MainClass can not access a member of class obj.TestClass with modifiers "private" 正常运行后，打印如下，调用私有方法成功： 1Java Reflect 666 3.2 修改私有变量以修改 TestClass 类中的私有变量 MSG 为例，其初始值为 “Original” ，我们要修改为 “Modified”。老规矩，先上代码看注释。 12345678910111213141516171819202122232425262728/** * 修改对象私有变量的值 * 为简洁代码，在方法上抛出总的异常 */private static void modifyPrivateFiled() throws Exception &#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3\. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 此处代码和访问私有方法的逻辑差不多，就不再赘述，从输出信息看出 修改私有变量 成功： 12Before Modify：MSG = OriginalAfter Modify：MSG = Modified 3.3 修改私有常量在 3.2 中，我们介绍了如何修改私有 变量，现在来说说如何修改私有 常量， 01. 真的能修改吗？常量是指使用 final 修饰符修饰的成员属性，与变量的区别就在于有无 final 关键字修饰。在说之前，先补充一个知识点。 Java 虚拟机（JVM）在编译 .java 文件得到 .class 文件时，会优化我们的代码以提升效率。其中一个优化就是：JVM 在编译阶段会把引用常量的代码替换成具体的常量值，如下所示（部分代码）。 编译前的 .java 文件： 123456//注意是 String 类型的值private final String FINAL_VALUE = "hello";if(FINAL_VALUE.equals("world"))&#123; //do something&#125; 编译后得到的 .class 文件（当然，编译后是没有注释的）： 12345private final String FINAL_VALUE = "hello";//替换为"hello"if("hello".equals("world"))&#123; //do something&#125; 但是，并不是所有常量都会优化。经测试对于 int 、long 、boolean 这些基本类型 JVM 会优化，而对于 Integer 、Long 、Boolean 这种包装类型，或者其他诸如 Date 、Object 类型则不会被优化。 总结来说：对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值。 这么说来，在实际开发中，如果我们想修改某个类的常量值，恰好那个常量是基本类型的，岂不是无能为力了？反正我个人认为除非修改源码，否则真没办法！ 这里所谓的无能为力是指：我们在程序运行时刻依然可以使用反射修改常量的值（后面会代码验证），但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了。 下面我们验证这一点，在测试类 TestClass 类中添加如下代码： 1234567//String 会被 JVM 优化private final String FINAL_VALUE = "FINAL";public String getFinalValue()&#123; //剧透，会被优化为: return "FINAL" ,拭目以待吧 return FINAL_VALUE;&#125; 接下来，是修改常量的值，先上代码，请仔细看注释： 12345678910111213141516171819202122232425262728293031323334353637/** * 修改对象私有常量的值 * 为简洁代码，在方法上抛出总的异常，实际开发别这样 */private static void modifyFinalFiled() throws Exception &#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有常量 Field finalField = mClass.getDeclaredField("FINAL_VALUE"); //3\. 修改常量的值 if (finalField != null) &#123; //获取私有常量的访问权 finalField.setAccessible(true); //调用 finalField 的 getter 方法 //输出 FINAL_VALUE 修改前的值 System.out.println("Before Modify：FINAL_VALUE = " + finalField.get(testClass)); //修改私有常量 finalField.set(testClass, "Modified"); //调用 finalField 的 getter 方法 //输出 FINAL_VALUE 修改后的值 System.out.println("After Modify：FINAL_VALUE = " + finalField.get(testClass)); //使用对象调用类的 getter 方法 //获取值并输出 System.out.println("Actually ：FINAL_VALUE = " + testClass.getFinalValue()); &#125;&#125; 上面的代码不解释了，注释巨详细有木有！特别注意一下第 3 步的注释，然后来看看输出，已经迫不及待了，擦亮双眼： 123Before Modify：FINAL_VALUE = FINALAfter Modify：FINAL_VALUE = ModifiedActually ：FINAL_VALUE = FINAL 结果出来了: 第一句打印修改前 FINAL_VALUE 的值，没有异议； 第二句打印修改后常量的值，说明FINAL_VALUE确实通过反射修改了； 第三句打印通过 getFinalValue() 方法获取的 FINAL_VALUE 的值，但还是初始值，导致修改无效！ 这结果你觉得可信吗？什么，你还不信？问我怎么知道 JVM 编译后会优化代码？那要不这样吧，一起来看看 TestClass.java 文件编译后得到的 TestClass.class 文件。为避免说代码是我自己手写的，我决定不粘贴代码，直接截图： TestClass.class 文件 看到了吧，有图有真相，getFinalValue() 方法直接 return &quot;FINAL&quot;！同时也说明了，程序运行时是根据编译后的 .class 来执行的。 顺便提一下，如果你有时间，可以换几个数据类型试试，正如上面说的，有些数据类型是不会优化的。你可以修改数据类型后，根据我的思路试试，看输出觉得不靠谱就直接看 .classs 文件，一眼就能看出来哪些数据类型优化了 ，哪些没有优化。下面说下一个知识点。 02. 想办法也要修改！不能修改，这你能忍？别着急，不知你发现没，刚才的常量都是在声明时就直接赋值了。你可能会疑惑，常量不都是在声明时赋值吗？不赋值不报错？当然不是啦。 方法一 事实上，Java 允许我们声明常量时不赋值，但必须在构造函数中赋值。你可能会问我为什么要说这个，这就解释： 我们修改一下 TestClass 类，在声明常量时不赋值，然后添加构造函数并为其赋值，大概看一下修改后的代码（部分代码 ）： 1234567891011public class TestClass &#123; //...... private final String FINAL_VALUE; //构造函数内为常量赋值 public TestClass()&#123; this.FINAL_VALUE = "FINAL"; &#125; //......&#125; 现在，我们再调用上面贴出的修改常量的方法，发现输出是这样的： 123Before Modify：FINAL_VALUE = FINALAfter Modify：FINAL_VALUE = ModifiedActually ：FINAL_VALUE = Modified 纳尼，最后一句输出修改后的值了？对，修改成功了！想知道为啥，还得看编译后的 TestClass.class 文件的贴图，图中有标注。 解释一下：我们将赋值放在构造函数中，构造函数是我们运行时 new 对象才会调用的，所以就不会像之前直接为常量赋值那样，在编译阶段将 getFinalValue() 方法优化为返回常量值，而是指向 FINAL_VALUE ，这样我们在运行阶段通过反射修改敞亮的值就有意义啦。但是，看得出来，程序还是有优化的，将构造函数中的赋值语句优化了。再想想那句 程序运行时是根据编译后的 .class 来执行的 ，相信你一定明白为什么这么输出了！ 方法二 请你务必将上面捋清楚了再往下看。接下来再说一种改法，不使用构造函数，也可以成功修改常量的值，但原理上都一样。去掉构造函数，将声明常量的语句改为使用三目表达式赋值： 12private final String FINAL_VALUE = null == null ? "FINAL" : null; 其实，上述代码等价于直接为 FINAL_VALUE 赋值 “FINAL”，但是他就是可以！至于为什么，你这么想：null == null ? &quot;FINAL&quot; : null 是在运行时刻计算的，在编译时刻不会计算，也就不会被优化，所以你懂得。 总结来说，不管使用构造函数还是三目表达式，根本上都是避免在编译时刻被优化，这样我们通过反射修改常量之后才有意义！好了，这一小部分到此结束！ 最后的强调： 必须提醒你的是，无论直接为常量赋值 、 通过构造函数为常量赋值 还是 使用三目运算符，实际上我们都能通过反射成功修改常量的值。而我在上面说的修改 “成功” 与否是指：我们在程序运行阶段通过反射肯定能修改常量值，但是实际执行优化后的 .class 文件时，修改的后值真的起到作用了吗？换句话说，就是编译时是否将常量替换为具体的值了？如果替换了，再怎么修改常量的值都不会影响最终的结果了，不是吗？。 其实，你可以直接这么想：反射肯定能修改常量的值，但修改后的值是否有意义？ 03. 到底能不能改？到底能不能改？也就是说反射修改后到底有没有意义？ 如果你上面看明白了，答案就简单了。俗话说 “一千句话不如一张图”，下面允许我用不太规范的流程图直接表达答案哈。 注：图中 “没法修改” 可以理解为 “能修改值但没有意义”；”可以修改” 是指 “能修改值且有意义”。 判断能不能改 四、总结好了，本次记录就到这儿了，突然不知不觉发现写了好多，感谢耐心听我叨逼完。我想这篇博客如果你认真的看完，肯定会有收获的！最后，因为内容较多，知识点较多，如果文中有任何错误或欠妥的地方，还望指正。欢迎留言交流！ 原文：https://juejin.im/post/598ea9116fb9a03c335a99a4]]></content>
      <tags>
        <tag>java基础</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第5章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-2%2F</url>
    <content type="text"><![CDATA[第五章：继承（inheritance）利用继承，我们可以基于已存在的类构造一个新类。本章还会介绍反射 (reflection) 的概念，反射是指在程序运行期间发现更多的类及其属性的能力。 5.1 类、超类和子类继承主要是为了重用代码，也表明了 is-a 的关系。 5.1.1 定义子类关键字 extends 表示继承。 1234public class Manager extends Employee&#123;&#125; 可以用下面几个单词来表示父类和子类 父类：superclass、base class、parent class 子类：subclass、derived class、childclass在 Java 中，子类的功能往往比父类的功能强大。应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。 5.1.2 覆盖方法当子类从父类继承得到的方法，并不适用于子类的时候，就需要使用覆盖 (override)。super 关键字可以帮助我们在子类中调用父类的方法 (因为父类的方法会被继承，而我们将继承的方法重写了，这时候方法名是相同，但执行的代码不同，所以需要用到 super)，如 super.doSomething()。在覆盖一个方法的时候，子类方法不能低于父类方法的可见性。 5.1.3 子类构造器当调用子类构造器时，如果没有显式地使用 super(name,salary,year,month) 来执行父类的构造器，那么就会隐式地调用父类无参的构造器。使用 super 调用构造器的语句必须是子类构造器的第一条语句。一个对象变量可以指示多种实际类型的现象被称为多态 (polymorphism)。在运行时能够自动地选择调用哪个方法的现象称为 动态绑定 (dynamic binding)。 5.1.4 继承层次一个父类可以有多个子类，但一个子类只能继承一个父类。 5.1.5 多态多态的特性表明程序中出现父类对象的任何地方都可以用子类对象置换。但反过来是不行的。 5.1.7 阻止继承：final 类和方法有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。类中特定的方法也可以被声明为 final。如果这样做，子类就不能 override 这个方法。(final 类中的所有方法自动地成为 final 方法，不过全局变量是不会变成 final 的)。将方法或类声明为 final 的主要目的是：确保它们不会在子类中改变语义，例如一个变量是 String 对象的引用，那么它一定是一个 String 对象，而不可能是其他类的对象。 5.1.8 强制类型转换将一个类型强制转换成另外一个类型的过程被称为类型转换。将一个子类的引用赋值给一个父类的变量，编译器是允许的。但将一个父类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。我们可以通过 instanceof 来检查。 5.1.9 抽象类为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的，除了抽象方法之外，抽象类还可以包含具体数据和具体方法。例如 Person 类还保存着姓名和一个返回姓名的具体方法。 1234567891011121314public abstract class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; //抽象方法 public abstract String getDescription(); //普通方法 public String getName() &#123; return name; &#125;&#125; extends 抽象类有两种方法： 在抽象类中定义部分抽象方法或不定义抽象方法，这样必须将子类也标记为抽象类 定义全部的抽象方法，这样一来，子类就不是抽象的了。抽象类不能被实例化。但是可以创建一个具体子类的对象。Person p = new Student(&quot;Bob&quot;,&quot;CS&quot;); 5.1.10 受保护访问大家都指定，最好将类中的全局变量标记为 private，而方法标记为 public。然而，有些时候，人们希望父类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为 protected。下面归纳一下 Java 用于控制可见性的 4 个访问修饰符： 仅对本类可见：private 对所有类可见：public 对本包和所有子类可见：protected 对本包可见：default 不需要修饰符 5.2 Object 所有类的超类在 Java 中，每个类都是由它扩展而来的，但是并不需要这样写：public class Employee extends Object如果没有明确地指出超类，Object 就被认为是这个类的超类。在 Java 中，只有基本类型 (primitive types) 不是对象。例如数值、字符和布尔类型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都 extends Object。 1234int a = 1; int[] staff = new int[10]; Object obj2 = a;//其实是将 int 先自动转换为 Integer，然后才成功赋值的。 Object obj = staff; 5.2.1 equals 方法Object 中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用，如果具有，则相等，然而对于大多数类来说，这样的比较不是很有意义，比如两个 Person 类，当我们进行 equlas 的时候，我们希望比较它们的状态，比如姓名，薪水等。我们可以 override 从 Object 继承得到的 equals 方法。 12345678public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return name.equals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.equals(other.hireDay); &#125; //这样写是有漏洞的，因为 name 和 hireDay 是String 类型，可能为null，如果为null，调用equals方法的话就会崩溃，我们可以利用 Object.equals 方法改写。 Object.equals 的另一个 overload 形式是：Object.equals(Object a,Object b) 如果两个参数都为 null，方法将返回 true。如果其中一个参数为 null，则返回 false；否则，如果两个参数都不为 null，则调用 a.equals(b)。利用这个方法，我们可以进行改写。 1return Object.equlas(name,other.name)&amp;&amp;salary==other.salary&amp;&amp;Object.equlas(hireDay,other.hireDay); 5.2.2 相等测试与继承如果隐式和显式的参数不属于同一个类，那么 euqals 方法将如何处理呢？在前面的例子中，如果发现 类不匹配，equals 方法就返回 false。但是许多程序员喜欢使用 instanceof 检测：if(!(otherObject instanceof Employee)) return false;，这是不推荐的写法。Java 要求 equal 方法具有下面的特性： 自反性：对于任何非空引用 x，x.equals(x) 应该返回 true。 对称性：对于任何引用 x 和 y，当且仅当 y.equals(x) 返回 true，x.equals(y) 也应该返回 true 传递性：对于任何引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，x.equals(z) 也应该返回 true。 一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。 对于任意非空引用 x，x.equals(null) 应该返回 false。如果子类能够拥有自己的相等概念，则对称性需要将强制采用 getClass 进行检测。如果由父类决定相等概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。 下面给出编写一个完美的 equals 方法的建议： 显式参数命名为 otherObject，稍后需要将它转换成另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象 if(this == otherObject) return true 检测 otherObject 是否为 null，如果为 null，返回 false。这项检测是很必要的。if (otherObject ==nul )return false; 可选 getClass 或 instanceof 将 otherObject 转换为相应的类类型变量：ClassName other = (ClassName) otherObject 开始比较全局变量。对于数组类型的域，可以使用静态的 Arrays.equals 方法检测相应的数组元素是否相等。 5.2.3 hashCode 方法散列码 (hash code) 是由对象导出的一个整型值。散列码没有规律。如果 x 和 y 是两个不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。如果重新定义 equals 方法，就必须重新定义 hashCode 方法，以便用户可以将对象插入到散列表中。hashCode 方法应该返回一个 int 值 (也可以是附属)，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。 12345public class Employee&#123; public int hashCode()&#123; return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode() &#125;&#125; 下面我们还可以优化一下，使用 Objects.hashCode 方法为对象计算 hash 值，避免空指针。使用基本数据类型对象的静态方法来避免创建多余的对象。 123456public int hashCode()&#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);&#125; 还有更好的写法return Objects.hash(name,salary,hireDay)Equals 和 hashCode 的定义必须一致，如果 x.equals(y) 返回 true，那么 x.hashCode() 就必须与 y.hashCode() 具有相同的值。如果存在数组类型的变量，可以使用静态的 Arrays.hashCode 方法计算一个 hashCode 值，这个散列码由数组元素的散列码组成。Objects API： int hashCode() static int hash(Object… objects) static int hashCode(Object a)，如果为 null 返回 0基本数据类型的对象，Integer|Double… static int hashCode()Arrays API static int hashCode(type[] a) 5.2.4 toString 方法Object 中还有一个重要的方法，就是 toString 方法，它用于返回表示对象值的字符串。一般的格式是：类的名字，随后是一对方括号括起来的域值。下面是 Employee 类中的 toString 方法的实现，我们可以调用 getClass().getName() 获得类名的字符串，而不是将类名硬加到 toString 方法中。 12345678public String toString()&#123; return getClass().getName() + &quot;[name=&quot; + name + &quot;,salary=&quot; + salary + &quot;,hireDay=&quot;+ hireDay + &quot;]&quot;;&#125; Object 类的 toString 方法则是打印类名 + hashCode 值。数组就是继承了 Object.toString 方法，所以如果想获取数组的元素，则可以使用 Arrays.toString；多维数组使用 Arrays.deepToString。 Object &amp;&amp; Class API Object: Class getClass() 返回包含对象信息的类对象 boolean equals(Object otherObject) String toString() Class String getName() 返回这个类的名字 Class getSuperclass() 以 Class 对象的形式返回这个类的超类信息 5.3 泛型数组列表ArrayList 是一个典型的数组列表，如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用 ensureCapacity 方法：staff.ensureCapacity(100)，另外，还可以把初始容量传递给 ArrayList 构造器 ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100)，size 方法将返回数组列表中包含的实际元素数目。例如：staff.size()，一旦能够确认数组列表的大小不再发生变化，就可以调用 trimToSize 方法，这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数量。垃圾回收器将回收多余的存储空间。 5.3.1 访问数组列表元素使用 get 和 set 方法实现访问或改变数组元素的操作，而不使用人们喜欢 [] 语法格式。staff.set(i,harry)使用 add 方法为数组添加新元素，而不要使用 set 方法，它只能替换数组中已经存在的元素内容。下面这个技巧可以一举二得，既可以灵活地扩展数组，又可以方便地访问数组元素。首先，创建一个数组，并添加所有的元素。 123456ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;();while(...)&#123; x = ...; list.add(x);&#125; 执行完上述操作之后，使用 toArray 方法将数组元素拷贝到一个数组中。 12X[] a = new X[list.size()];list.toArray(a); 除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素，使用带索引参数的 add 方法。同样地，也可以从数组列表中间删除一个元素。 123456//addint n = staff.size()/ 2staff.add(n,e);//removeEmployee e = staff.remove(n); 为了插入一个新元素，位于 n 之后的所有元素都要向后移动一个位置。如果删除，位于这个位置之后的所有元素都要向前移动一个位置，并且数组大小减 1。所以对于数组实施插入和删除元素的操作其效率比较低。如果元素数过多，且经常需要在中间位置插入、删除元素，就应该考虑使用链表了。可以使用 for each 循环遍历数组列表。 5.3.2 类型化与原始数组列表的兼容性在确保安全的情况下，可以使用 @SuppressWarnings(&quot;unchecked&quot;) 标记这个变量能够接收类型转换。 5.4 对象包装器与自动装箱有时，需要将 int 这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。这些类称为 包装器 (wrapper) (如 Integer - int)。wrapper 是不可变的，一旦构造了 wrapper，就不允许更改包装在其中的值。同时 wrapper 是 final 修饰的，不能定义它们的子类。int 是无法作为泛型参数的，所以我们可以使用 ArrayList&lt;Integer&gt;。幸运的是，有一个很有用的特性，例如 123456list.add(3)//这行代码将会自动变换成list.add(Integer.valueOf(3)); //这种变化被称为 autoboxing//相对的，也有一种情况叫自动拆箱int n = list.get(i);//这行代码将会自动变换成int n = list.get(i).intValue() 一般我们要比较 wrapper 对象的时候，习惯用 equals ，不过 autoboxing 规范要求：boolean、byte、char &lt;=127，介于 -128 ~ 127 之间的 shore 和 int 被包装到固定的对象中，所以下面代码： 1234567Integer a= 100;Integer b = 100;System.out.println(a==b) //trueInteger a= 200;Integer b = 200;System.out.println(a==b) //false Integer API int intValue() static String toString(int i) static String toString(int i, int radix) static int parseInt(String s) static int parseInt(String s,int radix) static Integer valueOf(String s) static Integer valueOf(String s,int radix) NumberFormat Number parse(String s) 5.5 参数可变的方法现在的 Java 版本提供了可以用可变的参数数量调用的方法 (有时称为 “变参” 方法)。具体的形式如下 12345678public static double max(double.. values)&#123; double largest = Double.NEGATIVE_INFINITY; for (double v : values) if (v &gt; largest) largest = v; return largest;&#125;//其过程就向给 max 方法传入了一个数组， 5.6 枚举类public enum Size {SMALL, MEDIUM,LARGE,EXTRA_LARGE};实际上，这个声明定义的类型是一个类，它刚好有 4 个实例，在此尽量不要构造新对象。因此，在比较两个枚举类型的值时，永远不需要调用 equals，而直接使用 “==” 就可以了。如果需要的话，可以在枚举类型中添加一些构造器，方法和域。当然，构造器只是在构造枚举常量的时候被调用。下面是一个实例： 12345678910111213public enum Size &#123; SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;), EXTRA_LARGE(&quot;XL&quot;); private String abbreviation; Size(String abbreviation) &#123; this.abbreviation = abbreviation; &#125; public String getAbbreviation() &#123; return abbreviation; &#125;&#125; 所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。其中最有用的一个是 toString，这个方法能够返回枚举常量名。例如，Size.SMALL.toString() 将返回字符串 SMALL。toString 的逆方法是静态方法 valueOf。例如，语句：Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;);。每个枚举类型都有一个静态的 values 方法，它将返回一个包含全部枚举值的数组。例如：Size[] values = Size.values();，ordinal 方法返回 enum 声明中枚举常量的位置，位置从 0 开始计数。例如：Size.MEDIUM.ordinal() 返回 1。 static Enum valueOf(Class enumClass,String name) String toString() int ordinal() int compareTo(E other) // 如果枚举常量出现在 other 之前，则返回一个负值；如果 this==other，则返回 0；否则，返回正值。枚举常量的出现次序在 enum 声明中给出。 5.7 反射反射库 (reflection library) 提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。能够分析类能力的程序称为反射 (reflection)。反射机制可以用来： 在运行时分析类的能力。 在运行时查看对象，例如，编写一个 toString 方法供所有类使用。 实现通用的数组操作代码 利用 Method 对象。 5.7.1 Class 类在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。然而，可以通过专门的 Java 类访问这些信息。保存这些信息的类被称为 Class，Object 类中的 getClass() 方法将会返回一个 Class 类型的实例。获取到 Class 类型的实例后，可以使用 getName，这个方法将返回类的名字。如果类在一个包里，包的名字也作为类名的一部分： 123Person p = new Person(); Class clazz = p.getClass(); System.out.println(clazz.getName());//com.example.Person 还可以调用静态方法 forName 获得类名对应的 Class 对象 12Class clazz = Class.forName(&quot;com.example.Person&quot;);//这个方法会产生异常，需要除了 System.out.println(clazz.getName()); 获得 Class 类对象的第三种方法非常简单。如果 T 是任意的 Java 类型 (或 void 关键字),T.class 将代表匹配的类对象。例如： 1Class clazz = Person.class; 一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int 不是类，但 int.class 是一个 Class 类型的对象。虚拟机为每个类型管理一个 Class 对象。因此，可以使用 == 运算符实现两个类对象比较的操作。例如： 1234Person p = new Person(); if(Person.class==p.getClass())&#123; System.out.println(&quot;HelloWorld&quot;); &#125; 还有一个很有用的方法 newInstance()，可以用来动态地创建一个类的实例。例如： 12Person p = new Person();Person b = p.getClass().newInstance(); newInstance 方法调用默认的构造器 (空参的构造器) 初始化新创建的对象。如果这个类没有默认的构造器，就会抛出一个异常。如果需要创建的类提供参数，必须使用 Constructor 类中的 newInstance 方法。 123Constructor c =Person.class.getDeclaredConstructor(String.class,int.class); Person b = (Person)c.newInstance(&quot;张子浩&quot;,123); System.out.println(b.name); 5.7.2 捕获异常异常有两种类型：未检查异常和已检查异常。对于已检查异常，编译器将会检查是否提供了处理器。然而，有很多常见的异常，例如，访问 null 引用，都属于未检查异常。 5.7.3 利用反射分析类的能力下面介绍反射机制最重要的内容 - 检查类的结构在 java.lang.reflect 包中有三个类 Field、Method 和 Constructor 分别描述类的域、方法和构造器。这三个类都有一个叫做 getName 的方法，用来返回项目的名称。Field 类有一个 getType 方法，用来返回描述域所属类型的 Class 对象。Method 和 Constructor 类有能够报告参数类型的方法，Method 类还有一个可以报告返回类型的方法。这三个类还有一个叫 getModifiers 的方法，它将返回一个整型数值，用不同的位开关描述 public 和 static 这样的修饰符使用情况。另外，还可以利用 java.lang.reflect 包中的 Modifier 类的静态方法分析 getModifiers 返回的整型数值。例如，可以使用 Modifier 类中的 isPublic、isPrivate 或 isFinal 判断方法或构造器是否是 public、private 或 final。我们需要做的全部工作就是调用 Modifier 类的相应方法，并对返回的整型数值进行分析，另外，还可以利用 Modifier.toString 方法将修饰符打印出来。Class 类中的 getFields、getMethods 和 getConstructor 方法将分别返回类提供的 public 域、方法和构造器数组，其中包括父类的公有成员。Class 类的 getDeclaredFields、getDeclaredMethods 和 getDeclaredConstructors 分别返回类中声明的所有全局变量、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。下面的代码可以完整打印出一个类的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; Scanner in = new Scanner(System.in); System.out.println(&quot;Enter class name (e.g. java.util.Date):&quot;); name = in.next(); try &#123; Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.println(&quot;class &quot; + name); if (supercl != null &amp;&amp; supercl != Object.class) &#123; System.out.print(&quot; extends &quot; + supercl.getName()); &#125; System.out.print(&quot;\n&#123;\n&quot;); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println(&quot;&#125;&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c : constructors) &#123; String name = c.getName(); System.out.print(&quot; &quot;); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.print(name + &quot;(&quot;); Class[] parameterTypes = c.getParameterTypes(); for (int j = 0; j &lt; parameterTypes.length; j++) &#123; if (j &gt; 0) System.out.print(&quot;,&quot;); System.out.print(parameterTypes[j].getName()); &#125; System.out.println(&quot;);&quot;); &#125; &#125; public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); for (Method m : methods) &#123; Class retType = m.getReturnType(); String name = m.getName(); System.out.print(&quot; &quot;); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;); Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(&quot; ,&quot;); System.out.print(paramTypes[j].getName()); &#125; System.out.println(&quot;);&quot;); &#125; &#125; public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); for (Field f : fields) &#123; System.out.print(&quot; &quot;); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.println(f.getName() + &quot; ;&quot;); &#125; &#125;&#125; Class&amp;Field&amp;Method&amp;Constructor&amp;Modifier API Class Field[] getFields() Field[] getDeclaredFields() Method[] getMethods() Method[] getDeclaredMethods() Constructor[] getConstructor() Constructor[] getDeclaredConstructor() Field &amp; Method &amp; Constructor Class getDeclaringClass() Class[] getExceptionTypes() Field 无这个方法 int getModifiers() String getName() Class[] getParameterTypes() Field 无这个方法 Class getReturnType() 只有在 Method 类中 Modifier static String toString(int modifiers) static boolean isAbstract(int modifiers) static boolean isFinal(int modifiers) static boolean isInterface(int modifiers) static boolean isNative(int modifiers) static boolean isPrivate(int modifiers) static boolean isProtected(int modifiers) static boolean isPublic(int modifiers) static boolean isStatic(int modifiers) static boolean isStrict(int modifiers) static boolean isSynchronized(int modifiers) static boolean isVolatile(int modifiers) 5.7.4 在运行时使用反射分析对象在编写程序时，如果知道想要查看的域名和类型，查看指定的域是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的对象域。 1234567Person p = new Person(&quot;bob&quot;); Class cl = p.getClass(); Field f = cl.getDeclaredField(&quot;name&quot;); f.setAccessible(true);//设置访问权限 f.set(p,&quot;zzzz&quot;);//可以将 p 的值进行替换 Object v = f.get(p);//可以获取 p 的值 System.out.println(v+&quot;&quot;); setAccessible 是 AccessibleObject 类中的一个方法，它是 Field、Method 和 Constructor 类的公共父类。 AccessibleObject &amp; Class &amp; Field API AccessibleObject void setAccessible(boolean flag) boolean isAccessible static void setAccessible(AccessibleObject[] array,boolean flag); Class Field getField(String name) Field[] getField() Field getDeclaredField(String name) Field[] getDeclaredFields() Field Object get(Object obj) void set(Object ob,Object newValue) 5.7.5 使用反射编写泛型数组代码java.lang.reflect 包中的 Array 类允许动态地创建数组。例如，将这个特性应用到 Array 类中的 copyOf 方法实现中。关于 Java 数组类型的转换：Java 数组会记住每个元素的类型，将一个 Employee[] 临时地转换成 Object[] 数组，然后再把它转换回来是可以的，但一个从开始就是 Object[] 数组却永远也不能转换成 Employee[] 数组。为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。 12345678910111213Employee[] a = new Employee[100]...//array is fulla = Arrays.copyOf(a,2*a.length);//正确的转换Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; 5.7.6 调用任意方法反射机制允许你调用任意方法。Method 类中有一个 invoke 方法，它允许调用包装在当前 Method 对象中的方法。invoke 方法的形式是 Object invoke(Object obj,Object.. args)第一个参数是隐式参数，其余的对象提供了显式参数，对于静态方法，第一个参数可以被忽略，即可以将它设置为 null。获得 Method 对象的方法是 Method getMethod(String name, Class... parameterTypes)，下面是代码演示： 123456789101112131415161718192021222324252627public class CopyOfTest &#123; public static void main(String[] args) throws Exception &#123; Method square = CopyOfTest.class.getMethod("square", double.class); Method sqrt = Math.class.getMethod("sqrt", double.class); printTable(1,10,10,square); printTable(1,10,10,sqrt); &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from, double to, int n, Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for (double x = from; x &lt;= to; x += dx) &#123; try &#123; double y = (Double) f.invoke(null, x); System.out.printf("%10.4f | %10.4f%n", x, y); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 5.8 继承的设计技巧 将公共操作和域放在父类 不要使用受保护的域 使用继承实现 is-a 的关系 除非所有继承的方法都有意义，否则不要使用继承 在 override 方法时，不要改变预期的行为 使用多态，而非类型信息 不要过多地使用反射 总结： 总结： 反射：指在程序运行期间发现更多的类及其属性的能力。 super 不是一个对象的引用，不能将其赋给另一个对象变量，它只是一个指示编译器调用超类方法的关键字。构造方法中 super 语句必须放到第一行。 若子类构造器没有显示调用父类的构造器，则系统自动调用父类的无参构造器；若父类没有无参构造器 (有其他构造器)，子类也没显示调用父类其他构造器，则编译报错。 系统在运行时能自动选择调用哪个方法的现象称为动态绑定 (重写的调用 系统知道引用类型是谁就行)；编译时就能知道该调用那个方法称为静态绑定 (如 privite/static/final 方法)。 Java 中只能单继承，但是继承链可以是有多层。 可以将一个子类实例赋值给超类变量 (向下转型)；不能将一个超类实例直接赋值给子类变量 (需要强制类型转换)。 子类重写 (覆盖) 方法中，可见性不能低于超类，若是 final 方法将不能被重写(覆盖)，不想它们在子类中改变语义。 包含一个或多个 abstract 方法的类必须被声明为抽象类；抽象类可以有自己的实例域和方法，子类必须重写父类的所有抽象方法，否则自己还是个抽象类；抽象类不能被实例化，只能实例化为具体的自类。 Object 类是所有类的超类，可以用它引用任何类型的变量，Java 中只有基本数据类型不是对象。 equals()方法默认判断的是内存地址，在子类定义 equals 方法时，首先调用超类的 equals，如果失败直接返回 false，然后再逐一对比子类自己的每个实例域。如果重新定义equals()方法就必须重新定义hashCode()方法，保证 hashCode 相同则对象就相等，为了插入到散列表中的验证。 Objects.equals(a,b)方法可避免两个变量都为 null 引起的问题；Arrays.equals()方法可以检测两个数组是否相等 (已重写判断每位是否相等的逻辑，类似 String.equals())。 散列码 (hash code) 是由对象导出的一个整型值，是无规律的，每个对象的默认散列码是对象的存储地址。两个相等的对象要求返回相等的散列码(内存地址都一样了，指向同一个堆对象，所以可以用来判断对象相等)。 ArrayList 是一个泛型类，动态数组实现，动态查询时效率高，但是在中间插入和删除效率就不行了 (后面的所有元素都要做位移)，动态插入删除链表 LinkedList 效率高一些，只修改那个元素前后的指针即可。 Java 中所有基本数据类型都有一个与之对应的类称为包装器，一旦构造是不许更改的，在许多场景下可以自动装箱与拆箱。== 判断的是地址。装箱和拆箱是编译器认可的，而不是虚拟机。 反射：能够在运行时动态分析类的能力，构造类，调用类的方法的行为。可使用 Class 类的newInstance()方法来动态构造类，Method 的invoke()来动态调用方法。 Class 类：• 定义：在程序运行期间，Java 运行时系统始终为所有对象维护着一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类，虚拟机利用运行时类型信息来选择相应的方法执行。独立于对象，存储着类的各种信息 (构造器 / 域 / 方法)。• 获取方式：①Object.class(只能获取到该类的 class 不区分父类子类引用)②obj.getClass()(当前 obj 的 class 区分父类子类)③Class.forName(pkgClassName)(动态获取 class 可能不存在 反射一般用的多)• 使用方法：Class 的newInstance()方法调用默认的构造器 (无参构造器) 动态创建一个类的实例，如果这个类没有默认构造器，则必须使用 Constructor 类中的newInstance()中带参数的构造方法。• 特点：一个 Class 对象实际上表示的是一个类型，而这个类型未必是一种类。例如，int 不是类，int.class 是一个 Class 类型的对象。Class 类实际上是一个泛型类。虚拟机为每个类型管理一个 Class 对象，可用obj.getClass()==Object.class来比较。 反射相关类：• 在 java.lang.reflect 包中有三个常用类：Field、Method 和 Constructor 分别用于描述类的域、方法和构造器。它们包含了一系列方法来分析类的各种属性和能力。外加一个 Modifier 类判断修饰符用，AccessibleObject 三者公有的超类。• 以上三个类有着公有的超类，以及各自的一些方法。getFields()方法返回类及其父类的公有域；getDeclaredFields()方法返回类的全部域，不包括父类。• 如果 f 是一个 Field 类型的对象，obj 是某个包含 f 域的类的对象，f.get(obj) 将返回一个对象 (Object 类型 基本类型则返回包装器)，其值为 obj 域的当前值 (就类似拷贝一个域的对象而已)。• f.set(obj,value) 可以将 obj 对象的 f 域设置成新值。基本数据类型的域获取域使用如getDouble()方法返回包装器。 反射机制默认行为受限于 Java 的访问控制，可以调用setAccessible()方法来为反射对象设置可访问标志。setAccessible()其实是 AccessibleObject 中的方法，它是 Field、Method 和 Constructor 的公有超类。 ObjectAnalyzer 将记录已经被访问过的对象。如：new ObjectAnalyzer().toString(this)。 反射常用方法：• Class 的getMethod(String name,Class&lt;?&gt;... parameterTypes)方法返回一个 method 类 (可以传入 class… 也可传入 new Class[]{} 数组)；• Method 类中的invoke(Object o,Object... args)方法调用包装在当前 Method 对象中的方法 (可以传入 obj… 也可传入 new Object[]{} 数组)，如果返回类型是基本类型，invoke 方法返回其包装器类型；对于静态方法，可以把null作为隐式参数传入；显示参数没有的话也传 null。 程序中不要过多的使用反射，反射会影响性能，并且编译器很难发现程序错误，只有在运行时才会发现并导致异常。 反射创建数组：• java.lang.reflect 包中的 Array 类允许动态构建数组，Java 数组会记住每个元素的类型 (创建时指定)，可以将一个特定数组临时转为 Object[]，然后可以强转回来，如果一开始就是个 Object[]，则不能强转。• Array.newInstance(componentType,newLength) 方法动态创建数组，getComponentType()是 Class 的方法，getLength()是 Array 的方法。创建得到的是 Object 数组，可以强转回来。Arrays.copyOf()底层就是这么做的。 注意：int[] 可以转为 Object，而不能转为 Object[]。 重写、重载、覆盖、多态的区别：• 重写 (覆盖)：方法级别的概念；@Override，出现在子类中，方法名和参数类型完全相同，子类重新实现父类定义的函数；但是访问权限不能小于父类的，抛出的的异常也不能大于父类；静态方法不能被重写为非静态方法。• 重载：方法级别的概念；@Overload，出现在父类中，方法名相同，参数不同，类似多态的不同实现。不能通过访问权限、返回类型和抛出异常不同来重载。• 多态：类级别的概念；父类的引用 -&gt; 子类的实例，使得父类可以调用子类中更多的方法。继承是子类使用父类的方法，而多态是父类调用子类的方法。重点：P166 Object、equals 方法 P190 反射]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第4章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-1%2F</url>
    <content type="text"><![CDATA[第四章：对象与类4.1 面向对象程序设计概述面向对象程序设计，简称 OOP。Java 是完全面向对象的，必须熟悉 OOP 才能够编写 Java 程序。 4.1.1 类class 是构造对象的模板或蓝图，由类构造 (construct) 对象的过程称为创建类的实例 (instance)。封装 (encapsulation，有时称为数据隐藏)，对象中的数据称为实例域 (instance field)，操作数据的过程称为方法 (method)。对于每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态 (state)。实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。OOP 的另一个原则就是可以通过扩展一个类来建立另外一个新的类，在 Java 中，所有的类都源自于 Object。通过扩展一个类来建立另外一个类的过程称为继承 (inheritance)。 4.1.2 对象对象的三个主要特性 对象的行为 (behavior)：可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态 (state)：当施加那些方法时，对象如何响应？ 对象标识 (identity)：如何辨别具有相同行为与状态的不同对象？ 4.1.3 识别类识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。 4.1.4 类之间的关系 依赖：uses-a 一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合：has-a 一个类的对象包含另一个类的对象 继承：is-a 一个类是另一个类的子类或者父类，类之间进行了扩展。 4.2 使用预定义类Java 中没有类就不能做任何事情，然而，并不是所有的类都具有面向对象特征。例如 Math 类，在程序中，可以使用 Math 类的方法，只需要知道方法名和参数，而不必了解它的具体实现过程，这正是封装的关键所在，但是 Math 类只封装了功能，它不需要也不必隐藏数据，由于没有数据，因此也不必担心生成对象以及初始化实例域。 4.2.1 对象与对象变量要想使用对象，必须首先构造对象，并指定其初始状态。然后，对对象应用方法。在 Java 中，使用构造器 (constructor) 构造新实例，构造器是一种特殊的方法，用来构造并初始化对象。构造器的名字应该与类名相同，要想构造一个类的对象，需要在构造器前面加上 new 操作符。new Date()`System.out.println(new Date());String s = new Date().toString();在上述例子种，构造的对象仅使用了一次，如果希望多次使用，需要将对象存放在一个变量中。Date birthday = new Date();`一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 4.2.2 Java 类库中的 LocalDate 类Date 类用来表示时间点，LocalDate 用来表示大家熟悉的日历表达法。LocalDate.now()// 2017-07-08还可以调用 LocalDate.of(1999,12,6) 方法来构造对应一个特定日期的对象。一旦有了一个 LocalDate 对象，可以使用方法 geetYear 、getMonthValue、getDayOfMonth得到年、月、日。下列的方法可以得到未来的日期或者过去的日期。 123LocalDate c = LocalDate.now();//c 是当前时间System.out.println(c.plusDays(1));//明天System.out.println(c.plusDays(-1));//昨天 4.2.2 更改器方法与访问器方法Java 库的一个较早版本曾经有另一个类来处理日历，名为 GregorianCalendar 与 c.plusDays(1) 不同，GregorianCalendar.add 方法与 plusDays 方法功能差不多，但是是一个更改器方法 (mutator method)。调用这个方法后，GregorianCalendar 对象的状态会改变。 1234GregorianCalendar c = new GregorianCalendar(1999,1,10);c.add(Calendar.YEAR, 1);int year = c.get(Calendar.YEAR);System.out.println(year); 相反，只访问对象而不修改对象的方法有时称为访问器方法 (accessor method)。例如 LocalDate.get 和 GregorianCalendar.get 。 下面的代码可以构建一个当月的日历。 1234567891011121314151617181920212223242526272829303132333435//带 * 号表示今天Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8* 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ------------------------------------LocalDate date = LocalDate.now(); int month = date.getMonthValue();// 7 int today = date.getDayOfMonth();// 8 date = date.minusDays(today - 1);// 返回到月初 DayOfWeek weekday = date.getDayOfWeek();// 得到星期几 int value = weekday.getValue();//得到月初的星期 System.out.println(&quot;Mon Tue Wed Thu Fri Sat Sun&quot;);//先打印好星期行 for (int i = 1; i &lt; value; i++) &#123;//控制 1 出现的位置 System.out.print(&quot; &quot;); &#125; while (date.getMonthValue() == month) &#123;// System.out.printf(&quot;%3d&quot;, date.getDayOfMonth());//打印1 if (date.getDayOfMonth() == today) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; System.out.print(&quot; &quot;); &#125; date = date.plusDays(1); if (date.getDayOfWeek().getValue() == 1) &#123; System.out.println(); &#125; &#125; LocalDate API LocalTime now() LocalTime of(int year, int month, int day) int getYear() int getMonthValue() int getDayOfMonth() DayOfWeek getDayOfWeek LocalDate plusDays(int n) LocalDate minusDays(int n) 4.3 用户自定义类要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有 main 方法。 4.3.1 Employee 类123456789101112class ClassName&#123; field; field; ... constructor1 constructor2 ... method1 method2 ...&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Demo01 &#123; public static void main(String[] args) throws Exception &#123; Employee[] staff = new Employee[3]; staff[0] = new Employee(&quot;Carl Cracker&quot;, 75000, 1987, 12, 15); staff[1] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1); staff[2] = new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15); for (Employee e : staff) &#123; e.raiseSalary(5); &#125; for(Employee e :staff)&#123; System.out.println(&quot;+e.getHireDay()); &#125; &#125;&#125;class Employee &#123; private String name; private double salary; private LocalDate hireDay; //constructor public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; // a method public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125;&#125; 当我们的 .java 文件包含 2 个类的时候，我们编译时可以采用这两种方法 12javac Employee*.java //可以使用通配符，所有与通配符匹配的源文件都将被编译成类文件javac Demo01.java //Java编译器会自动搜索使用的Employee类，并编译 4.3.4 从构造器开始1234567public Employee(String n, double s, int year, int month, int day)&#123; name = n ; salary = s; LocalDate hireDay = LocalDate.of(year,month,day);&#125;构造器与类同名，构造器与其他的方法有一个重要的不同。构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用 constructor 来达到重新设置实例域的目的，例如`james.Employee(&quot;James Bond&quot;,250000,1950,1,1)`//ERROR,会产生编译错误。 构造器的基本特点： 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有 0 个、1 个或多个参数 构造器没有返回值 构造器总是伴随着 new 操作一起调用 4.3.5 隐式参数与显式参数12345678public void raiseSalary(double byPercent)&#123; double raise = salary * byPercent / 100 salary +=raise; //salary的前面省略了参数， //完整的写法是 double raise = number007.salary * byPercent / 100 number007.salary +=raise;&#125; raiseSalary 有两个参数，第一个参数称为隐式参数 (implicit) 参数，是出现在方法名前的 Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式 (explicit) 参数。隐式参数也被称为方法调用的目标或接收者。在每个方法中，关键字 this 表示隐式参数。如果需要的话，可以用下列方式编写 raiseSalary 方法： 1234public void raiseSalary(double Percent)&#123; double raise = this.salary * byPercent / 100; salary +=raise;&#125; 4.3.6 封装的优点使用 public get 方法来代替 public name，将全局变量设置为 private 可以防止受到外界的破坏。注意：不要编写返回引用可变对象的 get 方法，因为它本身是可变的话，会破坏封装性，我们应该只能通过 set 方法来改变对象的状态，如果必须要这样做，那么我们可以使用 clone。 123456class Employee&#123; public Date getHireDay() &#123; return (Date) hireDay.clone(); &#125;&#125; 4.3.7 基于类的访问权限123public boolean equals(Employee other) &#123; return name.equals(other.name); &#125; 这段代码中 Employee 类的 name 变量是 private 修饰的，other.name 意味着我们访问了另一个对象的 private 属性，这与我们之前说的是对不起来的，其原因是： other 是 Employee 类对象，而 Employee 类的方法可以访问 Employee 类的任何一个对象的私有域。 4.3.8 私有方法有时，可能希望将一个计算代码划分为若干个独立的赋值方法。通常，这些辅助方法不应该成为公有接口的一部分，最好将这样的方法设计为 private。 4.3.9 final实例域构造对象时必须初始化这样的域，也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。如果将 final 用在一个可变对象上，那么 final 只表示该变量的对象引用不会更改，对象本身是可以更改的。 4.4 静态域与静态方法 static4.4.1 静态域如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。static 修饰的属性属于类，而不属于任何独立的对象。 4.4.2 静态常量静态变量用得比较少，但静态常量却使用得比较多。例如 Math.PI 123public class Math&#123; public static final double PI = 3.14159265358979323846;&#125; 这样做的好处就是，我们可以不需要构建 Math 的对象，直接通过 Math.PI 来进行访问，同时，设置为 fanal，避免了被修改的问题。 4.4.3 静态方法静态方法是一种不能向对象实施操作的方法，例如，Math 类的 pow 方法就是一个静态方法。Math.pow(x,a)，在运算时，不使用任何 Math 对象。换句话说，没有隐式的参数。可以认为静态方法是没有 this 参数的方法，这也说明了为什么静态方法无法调用非静态变量。在下面两种情况下使用静态方法： 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供，例如：Math.pow 一个方法只需要访问类的静态域，例如：Employee.getNextId 4.4.4 工厂方法静态方法还有另外一种常见的用途。类似 LocalDate 和 NumberFormat 的类使用静态工程方法 (factory method) 来构造对象。 12345NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(); NumberFormat percentFormatter = NumberFormat.getPercentInstance(); double x = 0.1; System.out.println(currencyFormatter.format(x)); // ￥0.10 System.out.println(percentFormatter.format(x)); // 10% 为什么 NumberFormat 不利用 构造器 来完成这些操作呢？ 无法命名构造器，构造器的名字必须要和类名一样，但是，这里希望将得到的货币实例和百分比实例采用不同的名字。 当使用构造器时，无法改变所构造的对象类型，而 Factory 方法将返回一个 DecimalFormat 类对象，这是 NumberFormat 的子类。 4.4.5 main 方法需要注意，不需要使用对象调用静态方法。例如，不需要构造 Math 类对象就可以调用 Math.pow。每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。例如，可以在 Employee 类中添加一个 main 方法，如果想要独立地测试 Employee 类，只需要执行 java Employee，如果 Employee 类是一个更大型应用程序的一部分，就可以使用下面这条语句运行程序 java Application，Employee 类的 main 方法永远不会执行。 4.5 方法参数按值调用 (call by value) 表示方法接收的是调用者提供的值。而按引用调用 (call by reference) 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。call by 是一个标准的计算机科学术语。Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。 1234567//假定一个方法：试图将参数值增加至3倍public static void tripleValue(double x)&#123; x = 3 * x ;&#125;double percent = 10;tripleValue(percent) 不过，并没有实现把参数增加到 3 倍。让我们一步步来细化： x 被初始化为 percent 值的一个拷贝 (也就是 10) x 被乘以 3 后等于 30，但是 percent 还是 10 这个方法结束之后，参数变量 x 不再使用然后，方法参数共有两种类型： 基本数据类型 (数字、布尔值) 对象引用下面这段代码实现了当对象引用作为参数的时候，方法修改了参数。 12345public static void tripleDSalary(Employee x)&#123; x.raiseSalary(200);&#125;harry = new Employee(...);tripleSalary(harry) 具体的执行过程是： x 被初始化为 harry 值的拷贝，这是一个对象的引用 raiseSalary 方法应用于这个对象引用。x 和 harry 同时引用的那个 Employee 对象的 salary 提高了 200% 方法结束后，参数变量 x 不再使用，当然，对象变量 harry 继续引用那个薪金增至 3 倍的雇员对象。下面总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型) 一个方法可以改变一个对象参数的状态 一个方法不能让对象参数引用一个新的对象 4.6 对象构造由于对象构造非常重要，所以 Java 提供了多种编写构造器的机制。 4.6.1 重载有些类有多个 constructor，例如，可以如下构造一个空的 StringBuilder 对象。StringBuilder messages = new StringBuilder();或者，可以指定一个初始字符串：StringBuilder todoList = new StringBuilder(&quot;To do:\n&quot;);这种特征叫做重载 (overloading)。如果多个方法有相同的名字、不同的参数，便产生了 overload。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。要注意的是，重载与返回值无关，也就是说，不能有方法名相同，参数相同，返回值类型不相同的两个方法。 4.6.2 默认域初始化如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值；数值为 0、布尔值为 false、对象引用为 null。 1这是全局变量与局部变量的主要不同点。必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的全局变量，将会被自动初始化为默认值 (0、false或null)。 4.6.3 无参数的构造器只有当类没有提供任何构造器时，系统才会提供一个默认的无参构造器。 4.6.4 显式域初始化123class Employee&#123; private String name =&quot;&quot;;&#125; 在执行构造器之前，会先执行显式赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方法特别有用。 4.6.5 参数名在编写很小的构造器时，常常在参数命名上出现错误。通常，参数用单个字符命名，但是我们推荐这样做： 123456789public Employee(String aName, double aSalary)&#123; name = aName; salary = aSalary;&#125;public Employee(String name, double salary)&#123; this.name = name; this.salary = salary;&#125; 4.6.6 调用另一个构造器关键字 this 引用方法的隐式参数。然而，这个关键字还有另外一个含义。如果构造器的第一个语句形如 this(...)，这个构造器将调用同一个类的另一个构造器。下面是个典型的例子： 12345public Employee(double s)&#123; //call Employee(String, double) this(&quot;Employee #&quot;+nextId,s); nextId++:&#125; 4.6.7 初始化块前面已经讲过两种初始化数据域的方法： 在构造器中设置值 在声明中赋值实际上，Java 还有第三种机制，称为初始化块 (initialization block)。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如， 12345678910111213141516171819202122232425class Employee&#123; private static int nextId; private int id; private String name; private double salary; &#123; d = nextId; nextId++: &#125; public Employee(String n, double s) &#123; name = n ; salary = s; &#125; public Employee() &#123; name = &quot;&quot;; salary = 0; &#125;&#125; 通常会直接将初始化代码放在构造器中。由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱，下面是具体处理步骤： 所有数据域被初始化为默认值 (0、false 或 null)。 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。 执行这个构造器的主体。还可以使用静态代码块，在类第一次加载的时候，将会进行静态域的初始化。 Random API Random() // 构造一个新的随机数生成器 int nextInt(int n)// 返回一个 0~ n-1 之间的随机数 4.6.8 对象析构域 finalize 方法由于 Java 有自动的垃圾回收器，不需要人工回收内存，所以 Java 不支持析构器。 4.7 包Java 允许使用 包 (package) 将类组织起来，借助于包可以方便地组织自己的代码。使用包的主要原因是确保类名的唯一性。 4.7.1 类的导入一个类可以使用所属包中的所有类，以及其他包中的公有类 (public class)，我们可以采用两种方式访问另一个包中的共有类。第一种方式是在每个类名之前添加完整的包名。 1java.time.LocalDate today = java.time.LocalDate.now(); 这样比较麻烦，我们推荐使用 import 导包，import 语句应该位于源文件的顶部 (但位于 package 语句的后面)。例如，可以使用下面这条语句导入 java.util 包种所有的类。import java.util.*;，也可以导入特定的类 import java.time.LocalDate; 4.7.2 静态导入import 不仅可以导入类，还增加导入静态方法和静态域的功能。例如：import static java.lang.System.*;我们就可以使用 System 类的静态方法和静态域，而不必加类名前缀： 123out.println(&quot;Goodbye,World!&quot;);//还可以导入特定的方法或域import static java.lang.System.out; 4.7.3 将类放入包中要想将一个类放入包中，必须将包的名字放在源文件的开头，包中定义类的代码之前。 1234package com.horstmann.corejava;public class Employee&#123;&#125; 4.7.4 包作用域标记为 public 的部分可以被任意的类使用；标记为 private 的部分只能被定义它们的类使用。如果没有指定，则为 default，表示可以被同一个包中的所有方法访问。 4.9 文档注释JDK 包含一个很有用的工具，叫做 javadoc。它可以由源文件生成一个 HTML 文档。如果在源代码种 添加以专用的 /** 开始注释，那么可以很容易地生成一个看上去具有专业水准的文档。 4.9.1 注释的插入javadoc 从下面几个特性种抽取信息： 包 公有类与接口 公有的和受保护的构造器及方法 公有的和受保护的域每个 /** */文档注释在标记之后紧跟着自由格式文档。标记由 @ 开始，如 @author 或 @param。在自由格式文本中，可以使用 HTML 修饰符，例如：&lt;em&gt; &lt;/em&gt;，&lt;strong&gt; &lt;/strong&gt;。 4.9.2 类注释类注释必须放在 import 语句之后，类定义之前。 12345678package com.example;/** * Afdfsdfsdfsdf * sdfsdfsdfsdfs * fsdfdssfsdfsf */public class PackageTest &#123; 4.9.3 方法注释每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记： @param 变量描述 @return 描述 @throws 类描述下面是一个方法注释的实例： 123456789/** * 我用来说明方法的概要 * @param s 我用来说明参数的作用 * @param g 我用来说明参数的作用 * @return 我用来说明返回值的作用 */ public int gogogo(String s , int g )&#123; return 4; &#125; 4.9.4 域注释只需要对公有域 (通常指的是静态常量) 建立文档。例如 1234/** * 我用来说明常量作用 */public static final int YEAR = 5; 4.9.5 通用注释下面的标记可以用在类文档的注释中。 @author 姓名，将产生一个 “author” 条目，可以使用多个。 @version 版本，这个标记将产生一个 “version” 条目 @since 这个标记将产生一个 “since” 条目，这里的 text 可以是对引入特性的版本描述。 @deprecated 这个标记将对类、方法或变量添加一个不再使用的注释。 @see 引用，它可以用于类中，也可以用于方法中。它有三种情况 package.class#feature label &lt;a href=&quot;...&quot;&gt;label&lt;/a&gt; “text”@see 的第一种情况最常见。只要提供类、方法或变量的名字，javadoc 就在文档中插入一个超链接。例如：@see com.horstmann.corejava.Employee#raiseSalary(double)@see com.example.GoGoGo#fuck(String)@see GoGoGo#fuck(String) 也可以省略包名。如果 @see 标记后面有一个 &lt; 字符，许久需要指定一个超链接，可以超链接到任何 URL。 12see &lt;a href =&quot;wwww.baidu.com&quot;&gt;百度&lt;/a&gt;@see &quot;百度&quot; 如果愿意的话，还可以在注释中的任何位置放置指向其他类或方法的超级链接，以及插入一个专用的标记，例如：{@link GoGoGo#fuck(String) label} 4.9.6 包与概述注解类、方法、变量的注释都可以放置在 Java 源文件中，但是要想产生包注释，就需要在每一个包目录中添加一个单独的文件。可以有如下两个选择： 提供一个以 package.html 命名的 HTML 文件。在标记 &lt;body&gt;..&lt;/body&gt; 之间的所有文本都会被抽取出来。 提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 /** */界定的 Javadoc 注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。还可以为所有的源文件提供一个概述性的注释，这个注释将被放置在一个名为 overview.html 的文件中，这个文件位于包含所有源文件的父目录中。标记 &lt;body&gt;..&lt;/body&gt; 之间的所有文件将被抽取出来。当用户从导航栏中选择 “Overview” 时，就会显示出这些注释内容。 4.10 类设计技巧 一定要保证数据私有：将全局变量设置为 private。 一定要对数据初始化 不要在类中使用过多的基本类型 不是所有的变量都需要 get、set 方法 将职责过多的类进行分解 类名和方法名要能够体现它们的职责 优先使用不可变的类 总结： OOP 对象的三个主要特征：行为 (方法)、状态 (方法的执行结果)、标识 (多态)。 类之间常见的关系：依赖 (uses-a)、聚合 (has-a)、继承 (is-a)。 一个对象变量并没有实际包含一个对象，而是引用一个对象。任何对象变量的值都是对存储在另一个地方的一个对象的引用，实际的对象在堆内存中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。 有时候多态的实现可以使用工厂方法来实现。 所有的 Java 对象都是在堆中构造的，构造器伴随着 new 操作符一起使用，不能在构造器中定义与实例域重名的局部变量。 方法中的显示参数指传参，隐式参数指方法的主体类，即调用对象本身 (this)，如data.getTime()中的 data。 对一个对象进行数据域的拷贝可以用 Object 的clone()方法，不要直接返回一个类的引用本身。 final 实例域在构造器执行之后一定是赋上值的且不可改变；static 域属于类，不属于任何独立的对象。 类的成员方法可以访问静态变量，静态方法不能访问成员变量 (肯定了)。 方法参数分为按值传递和按引用传递：值传递不可改变原值，因为先拷贝再处理；引用传递虽然也拷贝了一份，但是是浅拷贝，指向同一个内存地址，因此可以改变引用的状态。 方法总结 (两种传递)：• 方法不能改变基本数据类型的参数 (值传递，会拷贝)。• 方法可以改变一个对象的状态 (值传递，浅拷贝，改变了实际的堆里对象状态)。• 方法不能让对象参数引用一个新的对象 (会拷贝，只要不改变对象状态，只修改引用没用，因为方法结束时变量拷贝被丢弃，原引用还是不会变)。 当且仅当类没有任何构造方法时，系统会为之创建一个无参构造方法；否则必须使用自己定义的构造方法。 初始化块会在构造类对象时被执行，先运行初始化块，然后才运行构造器主体部分。 类的加载顺序：静态变量、静态初始化块 (先父后子) -&gt; 实例变量、实例初始化块 (先父后子) -&gt; 构造器 (先父后子)。 finalize()方法会在垃圾回收器清除对象之前被调用；import 导入包时，可以导入包、类和静态方法和静态变量。 几个概念区别：• 重写 (覆盖)(override) 指方法名和参数完全相同；• 重载 (overload) 指方法名相同参数不同；• 多态 (polymorphlism) 是针对类来说的指父类的多种实现。 包权限优先级：public(任何地方) &gt; protected(本包和其他包自类) &gt; default(本包) &gt; private(本类)。 只有 public 级别的方法可以在 new 出来的对象中去显式调用，否则都不行 (只能在类中和子类中自己使用)。重点：P112 静态域、静态方法 P123 对象构造 注意：instanceof 关键字 运行时指出对象是否是一个特定类的实例 (它是判断不出来接口、继承等关系中的子类和父类的，都会返回 true)；需要判断具体类时使用. class 进行比较。]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第3章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19%2F</url>
    <content type="text"><![CDATA[第三章：Java 基本程序设计结构3.1 一个简单的 Java 应用程序12345public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &apos;Hello, World!&apos;&quot;); &#125;&#125; Java 区分大小写，如果出现了大小写拼写错误 (例如，将 main 拼写为 Main)，程序将无法运行。public 被称为访问修饰符，用于控制程序的其他部分对这段代码的访问级别。class 表明 Java 程序中的全部内容都包含在类中，Java 应用程序中的全部内容都必须放置在类中。FirstSample 就是类名，定义类名的规则是：必须以字母开头，后面可以跟字母与数字的任意组合，长度基本没有限制，但是不能与 Java 保留字重名 (比如取个类名叫 public)，类名不强制大写，但是标准的命名规范中规定需要大写，即约定俗成。骆驼命名法 (驼峰命名法)：如果名字中包含了多个单词，则每个单词的第一个字母应该大写。源文件的文件名必须与 public 类的名字相同，并用 .java 作为扩展名。当我们执行编译命令的时候，Java 虚拟机会找到类中的 main 方法，并开始执行，所以在 .java 文件中必须要又一个 main 方法。如何执行这段 Java 代码：编写 .java 文件 —-&gt; 利用 Java 编译器 —-&gt; 生成 .class 字节码文件 —-&gt; 启动 Java 虚拟机 —-&gt;Java 虚拟机找到 main() 方法，开始执行。 123&#123; System.out.println(&quot;We will not use &apos;Hello, World!&apos;&quot;);&#125; { }一对大括号代表了方法体的开始与结束，在 Java 中，每个语句必须要用分号结束，回车不代表结束。 3.2 注释Java 的注释不会出现在可执行程序中，因此，可以在源程序中添加任意多的注释，在 Java 中，有 3 种标记注释的方式。 / / ：适用于一段较长的注释，需要注意，无法嵌套使用 /* /：可以用来自动地生成文档 3.3 数据类型Java 是一种强类型语言，必须为每个变量声明一种类型。在 Java 中有 8 种基本类型：4 种整型，2 种浮点型，1 种用于表示 Unicode 编码的字符单元的字符类型 char，和一种用于表示真值的 boolean 类型 (String 和 数组都是对象)。 3.3.1整型：用于表示没有小数部分的数值，它允许是负数取值范围 -2^(位 - 1) —–2^(位 - 1)-1 一个字节代表 8 位 类型 存储需求 取值范围 具体值 int 4 字节 -2 的 32 次方~ 2 的 32 次方 - 1 -2147483646-2147483647(正好超过 20 亿) short 2 字节 -2 的 16 次方~ 2 的 16 次方 - 1 -32768~32767 long 8 字节 -2 的 64 次方~ 2 的 64 次方 - 1 -9223372036854775808~9223372036854775807 byte 1 字节 -2 的 8 次方~ 2 的 8 次方 - 1 -128~127 在 Java 中，整型的范围与运行 Java 代码的机器无关。长整型数值后面有一个 L 后缀，从 Java7 开始，加上前缀 0b 或 0B 就可以写二进制数。如 0b1001 就代表 9，还可以为数字字面量加下划线，如用 1_000_000 表示一百万，更加可读，编译器会去掉这些下划线。 12System.out.println(0b1001); // result : 9System.out.println(1_000_000); // result :1000000 3.3.2 浮点类型用于表示有小数部分的数值。Java 中有两种浮点类型。 类型 存储需求 取值范围 float 4 字节 -1.7 乘以 10 的 38 次方~ 1.7 乘以 10 的 38 次方 double 8 字节 -3.4 乘以 10 的 308 次方~ 3.4 乘以 10 的 308 次方 double 表示这种类型的数值精度是 float 类型的两倍 (也有人称之为双精度数值)，float 类型的数值后有一个后缀 F 或 f，没有后缀的默认为 double 类型，double 类型也可以加后缀 D 或 d 。注意浮点类型计算存在误差，是因为浮点数值采用二进制系统表示，在二进制系统中无法精确地表示分数 1/10 ，可以使用 BigDecimal 类代替实现。 12System.out.println(2.0-1.1);result : 0.8999999999999999 3.3.3 char 类型char 类型用于表示单个字符，不过现在有些变化，有些 Unicode 字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值。&#39;A&#39; 与 &quot;A&quot; 不同，前者是编码值为 65 所对应的字符常量，后者是包含一个字符 A 的字符串。char 类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff 。下面这行代码是符合语法标准的，\u005B 表示 [ ，\u005D 表示 ]。Unicode 转义序列会在解析代码之前得到处理。 1public static void main(String\u005B\u005D args) &#123;&#125; Java 中可以使用 \u + Unicode编码来进行转义，如 \u0022，除了这个以外，还有一些特殊的转义序列 转义序列 名称 Unicode 值 \b 退格 \u0008 \t 制表 \u0009 \n 换行 \u000a \r 回车 \u000d \” 双引号 \u0022 \’ 单引号 \u0027 \ 反斜杠 \u005c 3.3.5 boolean 类型boolean(布尔) 类型有两个值：false 和 true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。 3.4 变量在 Java 中，每个变量都一个类型 (type)。在声明变量时，变量的类型位于变量名之前，例如： 123double salary;int vacationDays;boolean done; 变量名必须要以字母开头，并由字母或数字组成的序列，不过这里的 “字母” 的概念不单指英文字母，字母包括 A~Z，a~z，_，$，或在某种语言中表示字母的任何 Unicode 字符，比如德国人就可以在变量名中使用字母 ä。 3.4.2 常量在 Java 中，利用关键字 final 指示常量，例如final int cout = 3 ;关键字 final 表示这个变量只能被赋值一次，一旦被赋值之后，就不能够再修改了，习惯上，常量名使用全大写。声明在类中，用 static final 声明的变量，也被称为类常量 3.5 运算符在 Java 中，使用算术运算符 +，-，*，/，表示加减乘除运算，当参与 / 运算的两个操作数都是整数时，表示整数触发；否则表示浮点除法。整数的求余操作 (有时称为取模)，用 % 表示。 1234a = 15 , b = 2 a/b=7a%b = 1;a=15.0a/b = 7.5 3.5.1 数学函数与常量在 Math 类中包含了各种各样的数学函数，比如这里有一个计算数值平方根的方法 123double x = 4;double y = Math.sqrt(x);// sqrt 接受一个 double 值System.out.println(y); 幂运算的方法 12// y 的值为 x 的 a 次幂，同样接受 double 值。double y = Math.pow(x,a); 3.5.2 数值类型之间的转换如果两个操作数中有一个是 double 类型，另一个操作数就会转换为 double 类型。否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。否则，如果其中一个操作数是 long 类型，另一个操作数将会转换为 long 类型。否则，两个操作数都将被转换为 int 类型。 3.5.4 结合赋值和运算符“+=”，“-=”，“*=”，“%=”，这些都是在赋值中使用二元运算符，但是不会改变数据的类型，例如： 123int x =2 ;x+=3.5;此时等价于： x = (int)(x+3.5)//先变成 double ，再被转换为 int 3.5.5 自增与自减运算符++n，n++，是两种不同的含义，如果把加号放在前缀，那么则会先自增，再运算表达式的值；如果放在后缀，那么则会先运算表达式的值，再自增。另外，++4，是错误的，自增与自减运算符只能用于变量，不能是数值。 1234567int a = 2;int c = 3;System.out.println(a++);System.out.println(++c);--------------------------24 3.5.6 关系和 boolean 运算符 == ：检测相等性 !=：检测不相等 &lt;，&gt;，&lt;=，&gt;=：小于，大于，小于等于，大于等于 &amp;&amp;：采用短路的做法，如果前者为 false ，则不计算后者 ||：采用短路的做法，如果前者为 true ，则不计算后者 ？： ：三元运算符，condition? expression1：expression2，如果 condition 为 true，就为第一个表达式的值，反之则为第二个表达式的值。 3.5.7 位运算符 &amp;：&amp; 在运算的时候，将 2 个数字的二进制做比较，当 2 个数字的值都为 1 时，才为 1，否则就是 0 |：数值运算符的时候 同样是比较 2 进制，当有一个数为 1，那么就取 1 ^：数值运算符的时候 同样是比较 2 进制， 只能有 1 个 1，那就取 1 ~：取反值 ：补最左边的数位时，会根据符号位， 符号是 1 就填充 1，符号是 0，就填充 0; &lt;&lt;：左移 &gt;&gt;&gt;：无符号右移: 对于正数 有符号与无符号的右移没有区别。 对于负数 来说，不管你是 0 还是 1，都会用 0 去补位 不管是正数还是负数，在底层，都是以补码的性质来存的1 1 1 1 1 1 1 1第一位是符号位，符号位是 0，就是正数，符号位是 1，就是负数00001010从最后一位开始计算 2 的 0 次方，2 的 1 次方，2 的 2 次方，2 的三次方 —-对于正数来说。原码，反码，补码 三码合一。负数的原码， 把最高位的 0 改为 1原码变为反码：各个位除符号位外取反，即 0 变成 1，1 变成 0反码变成补码 在反码的基础上 +1 3.5.8 括号与运算符级别如果不使用括号，就按照给出的运算符优先级次序进行计算，同一个级别的运算符按照从左到右的次序进行是计算 (除了右结合运算符)， 运算符 结合性 [] .()(方法调用) 从左向右 ! ~ ++ – +(一元运算) -(一元运算) ()(强制类型转换) new 从右向左 * / % 从左向右 +(正) -(负) 从左向右 &lt;&lt;&gt;&gt; &gt;&gt;&gt; 从左向右 &lt;&lt;=&gt; &gt;= instanceof 从左向右 == != 从左向右 &amp; 从左向右 ^ 从左向右 从左向右 &amp;&amp; 从左向右 逻辑或 从左向右 ?: 从右向左 = += -= *= /= %= &amp;= ^= &lt;&lt;=&gt;&gt;= &gt;&gt;&gt;= 从右向左 3.6 字符串Java 字符串就是 Unicode 字符序列，同时在标准 Java 类库中提供了一个预定义类 String substring()方法：可以从一个较大的字符串提取出一个字串 1234String greeting = &quot;Hello&quot;;String s = greeting.substring(0,3); result : Hel substring(a,b);//一般子串的长度就是 b-a 拼接：当将一个字符串与一个非字符串的值进行拼接时，后者会被转换为字符串。如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态 join 方法： 1234String all = String.join(&quot;-&quot;,&quot;name&quot;,&quot;age&quot;,&quot;school&quot; );System.out.println(all);result:name-age-school 不可变字符串在 Java 中，如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是：不能改变对象内的成员变量，其中基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。同时要区分对象和对象的引用 123456String abc = &quot;Hello&quot;;abc = &quot;GoGoGo&quot;;System.out.println(abc);------------GoGoGo//这里要说明的是，abc 只是一个 String 对象的引用，并不是对象本身，引用里面存放了它所指向的对象的地址，通过这个地址可以访问对象，这里其实是创建了一个新的 String 对象 &quot;GoGoGo&quot;，然后 abc 重新指向了这个对象。 3.6.4 检测字符串是否相等使用 equals 方法检测两个字符串是否相等，s.equals(t)，如果字符串 s 与字符串 t 相等，则返回 true，否则，返回 false。s 和 t 可以是字符串变量，也可以是字符串字面量： 123String abc = &quot;Hello&quot;;abc.equals(&quot;Hello&quot;);&quot;Hello&quot;.equals(abc); 如果你希望检测两个字符串是否相等，而不区分大小写，可以使用 equalsIgnoreCase 方法。不能使用== 来比较字符串是否相同，因为 == 比较的是变量的内存地址，而不是变量的值。 3.6.5 空串与 Null 串空串 “” 是长度为 0 的字符串，可以调用以下代码检查一个字符串是否为空。 12if(str.length()==0)if(str.equals(&quot;&quot;)) 空串是一个 Java 对象，有自己的串长度 (0) 和内容 (空) ，不过 String 变量还可以存放一个特殊值：null，表示目前没有任何对象与该变量关联，要检查一个字符串是否为 null，可以使用以下条件：if (str == null)有时要检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：if (str !=null &amp;&amp; str.length() != 0) 3.6.7 String API boolean equals(Object other) boolean equalsIgnoreCase(String other) boolean startWith(String prefix) 如果字符串以 prefix 开头，则返回 true boolean endsWith(String suffix) 如果字符串以 suffix 结尾，则返回 true int indexOf(String str) int indexOf(String str，int fromIndex) int indexOf(int cp) int indexOf(int cp，int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str，int fromIndex) int lastIndexOf(int cp) int lastIndexOf(int cp，int fromIndex) length() String replace(CharSequence oldString，CharSequence newString)，可以用 String 或 StringBuilder 对象作为 CharSequence 参数。 String substring(int beginIndex) String substring(int beginIndex，int endIndex) String toLowerCase() 转换为小写 String toUpperCase() 转换为大写 String trim() 这个字符串将删除原始字符串头部和尾部的空格 String join(CharSequence delimiter，CharSequence… elements) 3.6.9 构建字符串如果单纯用 String 来拼接字符串，每次连接字符串都会构建一个新的 String 对象，既耗时，又浪费空间，使用 StringBuilder 就可以避免这个问题的发生。 12345//构建一个空的字符串构建器 StringBuilder builder = new StringBuilder(); builder.append("Hello"); builder.append("World"); String completedString = builder.toString(); StringBuilder 的前身是 StringBuffer，StringBuffer 的效率略低，但是允许采用多线程的方式执行添加或删除字符的操作，如果所有字符串都再一个单线程中编辑，则应该使用 StringBuilder，这两个类的 API 是相同的。 StringBuilder() int length() StringBuilder append(String str) StringBuilder append(char c) StringBuilder insert(int offset,String str) StringBuilder insert(int offset,Char c) StringBuilder delete(int startIndex,int endIndex) String toString() 3.7 输入输出java.lang 不需要 import 加载。System.out 是标准输出流，System.in 是标准输入流，要想通过控制台输入，首先要构造一个 Scanner 对象，并与 System.in 关联。 1Scanner scanner = new Scanner(System.in); 1234scanner.nextLine()//读取输入的整行信息。scanner.next()//读取一个单词scanner.nextInt()//读取一个整数scanner.nextDouble()//读取一个浮点数 因为 Scanner 输入是可见的，所以不适用于从控制台读取密码。Java SE 6 引入了 Console 类来实现这个目的，想要读取一个密码，可以采用下列代码： 1234//在使用 Eclipse 或其他 IDE 的情况下，是无法获取 Console实例的Console cons =System.console();String userName = cons.readLine(&quot;User name:&quot;);char[] passWord = cons.readPassword(&quot;PassWord:&quot;); ScannerAPI Scanner(InputStream in) 用给定的输入流创建一个 Scanner 对象 String nextLine() String next() int nextInt() double nextDouble() boolean hesNext() boolean hasNextInt() boolean hasNextDouble() 3.7.2 格式化输出System.out.printf 沿用了 C 语言库函数中的 printf 方法，可以设置多个参数，例如： 123String name = &quot;Pudge&quot;; int age = 15; System.out.printf(&quot;Hello,%s. Next year,you&apos;ll be %d&quot;, name, age); 每一个以 % 字符开始的格式说明符都用相应的参数替换。个数说明符尾部的转换符将指示被格式化的数值类型： d 十进制整数 g 通用浮点数 s 字符串 c 字符 b 布尔用于 printf 的标志 $ 给定被格式化的参数索引，例如：%1$d printf 用于输出，可以使用 String.format 方法来创建一个格式化的字符串，而不打印输出。 3.7.3 文件输入与输出PrintWriter 3.8 控制流程Java 使用条件语句和循环结构确定控制流程。 3.8.1 块作用域块 (block，又复合语句)：由一对大括号括起来的若干条简单的 Java 语句。block 确定了变量的作用域。一个 block 可以嵌套在另一个 block 中， 12345678//在 main 方法块中嵌套另一个语句块的实例public static void main(String[] args) throws Exception &#123; int n; &#123; int k; &#125; &#125; 但是，不能在嵌套的两个块中声明同名的变量，例如下面的代码就又错误。 1234567public static void main(String[] args) throws Exception &#123; int n; &#123; int k; int n;//不能声明同名变量 &#125; &#125; 3.8.2 条件语句格式为 if(condition) statement，条件用括号括起来。else 子句与最邻近的 if 构成一组，例如：if (x&lt;=0) { if (x==0) sign = 0; else sign = -1;} 3.8.3 循环while (condition) statement，while 循环语句会首先检测循环条件，因此，循环体中的代码有可能不被执行。do/while 可以保证循环体至少执行一次，则应该将检测条件放在最后，语法格式为 do statement while (condition)，这种循环语句先执行语句 (通常是一个语句块)，再检测循环条件；然后重复语句，再检测循环条件，以此类推。for 循环是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或类似的变量来控制迭代次数。 123for (int i = 1; i&lt;=10; i++)&#123;System.out.println(i);&#125; 3.8.5 switch 语句switch 语句将从与选项值相匹配的 case 标签处开始执行，直到遇到 break 语句，或者执行到 switch 语句的结束处为止。如果没有相匹配的 case 标签，而有 default 子句，就执行这个子句。case 标签可以是： 类型为 char、byte、short、int 的常量表达式 枚举常量 从 Java 7 开始，case 标签还可以是字符串字面量 1234567//如果想让几个 case 执行相同的语句switch(name)&#123;case &quot;yes&quot;:case &quot;no&quot;: //sthbreak;&#125; 3.8.6 中断控制流程语句break 也可以中断循环或者条件语句，Java 还提供了一种带标签的 break 语句，用于跳出多重嵌套的循环语句。break 会跳出一个循环体，但假设这个循环体被外层循环嵌套，那么 break 是无法跳出外层循环的。continue 将控制转移到最内层循环的首部 (跳过本次循环)，同样的，continue 也可以使用标签机制。 3.9 大数值如果基本的整数和浮点数精度不能够满足需求，那么可以使用 java.math 包中的两个很有用的类：BigInteger 和 BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger 实现了任意精度的整数运算，BigDecimal 实现了任意精度的浮点数运算。 12345//使用静态的 valueOf 方法可以将普通的数值转换为大数值//不能使用+、-、*等运算符，需要使用add、multiply方法BigInteger a = BigInteger.valueOf(100);BigInteger c = a.add(b) // c = a + b BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); d = c *(b + 2); BigInteger API BigInteger add(BigInteger other)// 加法 BigInteger subtract(BigInteger other)// 减法 BigInteger multiply(BigInteger other)// 乘法 BigInteger divide(BigInteger other)// 除法 BigInteger mod(BigInteger other)// 取余 int compareTo(BigInteger other)// 比较，相等则返回 0，大于则返回 1，小于则返回 -1 BigDecimal API BigDecimal add(BigDecimal other) BigDecimal subtract(BigDecimal other) BigDecimal multiply(BigDecimal other) BigDecimal divide(BigDecimal other , RoundingMode mode)// 需要给出舍入方式，如 RoundingMode.HALF_UP 是在学校中学习的四舍五入方式 int compareTo(BigDecimal other) static BigDecimal valueOf(long x) static BigDecimal valueOf(long x, int scale)// x / 10^scale 3.10 数组是一种数据结构，用来存储同一类型值的集合。可以使用这两种形式来声明数组： 12int[] a ; int a[] ; 创建数组时，数字数组的初始值为 0，boolean 数组的初始值为 false。对象数组的初始值为 null。一旦创建了数组，那么数组的大小就不能再改变了。 3.10.1 for each 循环用来依次处理数组中的每个元素 (其他类型的元素集合亦可) 而不必为指定下标值而分心。for(variable : collection) statementcollection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象 (如 ArrayList)。如果想要快速打印一个数组的话，可以使用 Arrays.toString 方法。 3.10.2 数组初始化以及匿名数组int[] smallPrimes = {2,3,5,7,11,13} 这是一种简化书写形式，甚至可以初始化一个匿名的数组 new int[] {17, 19, 23, 29, 31, 37} 3.10.3 数组拷贝在 Java 中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组。这里要区别直接赋值与 copyOf 方法的区别。 12345678910111213141516171819public static void main(String[] args) throws Exception &#123; //声明三个数组 int[] a = &#123; 1, 2, 3, 4 &#125;; int[] b; int[] c; //直接赋值,a和b引用同一个数组,那么修改b,a也会受影响 b=a; b[0]=5; //此时把a再拷贝给c,如果a受影响,那么c[0]==5,反之c[0]==1 c =Arrays.copyOf(a, a.length); System.out.println(Arrays.toString(c)); //那么改变c的值,会影响a吗? c[0]=6; System.out.println(Arrays.toString(a)); &#125;------------------result:[5, 2, 3, 4][5, 2, 3, 4] 3.10.4 命令行参数main 方法中接收一个参数 String[] args，如果我们不使用任何 IDE，那么我们可以这样传递参数： 1234567891011121314151617181920212223//调用虚拟机运行 Java 程序//java 类名 参数1 参数2 参数3... //java FirstSample -g cruel worldpublic class FirstSample &#123; public static void main(String[] args) throws Exception &#123; if (args.length == 0 || args[0].equals(&quot;-h&quot;)) System.out.print(&quot;Hello,&quot;); else if (args[0].equals(&quot;-g&quot;)) ; System.out.print(&quot;Goodbye,&quot;); for (int i = 1; i &lt; args.length; i++) &#123; System.out.print(&quot; &quot; + args[i]); &#125; System.out.println(&quot;!&quot;); &#125;&#125;result ---------------------Goodbye, cruel world! 3.10.5 数组排序要想对数值型数组进行排序，可以使用 Arrays 类中的 sort 方法，这个方法使用了优化的快速排序算法。Math.random 方法将返回一个 0 到 1 之间 (包含 0，不包含 1) 的随机浮点数。 12345678910111213141516171819//小型抽奖。public static void main(String[] args) throws Exception &#123; int[] numbers = new int[20]; int[] result = new int[5]; for(int i =0;i&lt;numbers.length;i++)&#123; numbers[i] = i+1; &#125; int n = numbers.length; for(int i = 0;i&lt;result.length;i++)&#123; int r = (int)(Math.random() * n);//0&lt;=n&lt;19 result[i] = numbers[r];//19 numbers[r] = numbers[n-1];//把最后一位数字赋值给抽到过的数字。 n--;//18 &#125; Arrays.sort(result); for(int r:result)&#123; System.out.println(r); &#125; &#125; Arrays API String toString(type[] a) 返回包含数组数值的字符串 type copyOf(type[] a , int length) type copyRange(type[] a, int start, int end) end 终止下标 (不包含) void sort(type[] a ) int binarySearch(type[] a , type v) int binarySearch(type[] a, int start, int end, type v) 采用二分搜索算法查找值 v vod fill(type[] a, type v) 将数组的所有数据元素值设置为 v boolean equals(type[] a, type[] b) 如果两个数组大小相同，并且下标相同的元素都对应相等，返回 true。 String Arrays.deepToString(a) 打印一个二维数组列表 3.10.6 多维数组适用于表示表格或更加复杂的排列形式。多维数组又被称为叫二维数组，与一般数组的初始化方式相同 12345678double[][] balances;int[][] magicSquare = &#123; &#123;16,3,2,16&#125;, &#123;5,10,11,8&#125;, &#123;9,6,7,12&#125;, &#123;4,15,14,1&#125;&#125;//可以通过 magicSquare[][]的方式来访问。 要想循环遍历其中的数据，我们有这种嵌套循环的方法： 123456for(double[] row : a)&#123; for(double value : row) do something with value&#125;//如果要打印列表Arrays.deepToString(a) 3.10.7 不规则数组由于二维数组可以看成是数组的每个元素是数组，所以可以进行数组换行。 123double[] temp = balances[i]balances[i] = balances[i + 1]//把balances[i] 和 balances[i + 1]数据进行交换balances[i + 1] = temp 总结 总结： Java 是强类型语言，有 8 种基本数据类型：4 种整型、2 种浮点型、1 种字符型、1 种布尔型。分别为：byte、short、int、long、float、double、char、boolean。 占用字节数：byte:1 字节、short：2 字节、int：4 字节、long：8 字节、float：4 字节、double：8 字节。Java 中所有数值类型所占字节数量与平台无关。 byte 与 char 区别：• byte 是有符号型，char 是无符号型；byte 占 1 字节，8 位，表示 - 127 到 128，char 占 2 字节，16 位，表示 0~65536。• byte 可以初始化为数字或字符，最终表示的是数值，char 可以初始化为数字或字符，最终表示的是字符。• char 可以表示中文，byte 不可以；对于英文可以相互转化，byte 代表的是 ASCII 码，char 代表对应的字符。 注意不要用浮点型来进行金融计算，如（2.0-1.1=0.89999…），因为二进制无法精确表示 1/10；尽量不要在程序中使用 char 类型。 码点是指一个编码表中某个字符对应的代码值，在 Unicode 标准中采用 16 进制书写，并加上前缀 U+。UTF-16 编码采用不同长度表示码点，每个字符用 16 位表示，通常被称为代码单元，辅助字符一般采用一对连续的代码单元进行编码。因此最好别用 char 类型。 一个字符串与非字符串的值拼接时，后者会被转为字符串。 格式化输出：(&quot;%1$d,%2$s&quot;,99,&quot;abc&quot;)-&gt; 输出(99，abc)；% 是格式化关键字，$ 表示参数索引。索引必须在 % 后面，以 $ 结尾，以 1 开头。 &amp;&amp; 的优先级高于 ||，+= 是右结合运算符。a+=b+=c，会先进行 b+=c，然后在 +=a。 C++ 中可以在嵌套语句块中定义重名变量，内层会覆盖外层变量，但是 Java 不可以。 else 语句与相邻最近的一个 if 语句为一对。 case 标签可以是 char、byte、short、int、枚举常量和 String(Java SE7 后支持)。 break：跳出循环体；签名定义好标签 break label 可以跳出多层嵌套循环；continue：不执行后面的逻辑，直接进行下一次循环。 数组是一种数据结构，用来存储同一类型值的集合。创建数组时，数值型初始化为 0、布尔型初始化为 false、对象型初始化为 null。一旦创建后就不能改变它的大小了。 创建数组三种方法：• int[] a = new int[10];• int[] a = {1,2,3};• int[] a = new int[]{1,2,3}。 打印数组：Arrays.toString(a)；打印多维数组：Arrays.deepToString(a)。 数组的Arrays.copyOf()方法拷贝一个新的引用；Arrays.sort()方法使用了优化的快速排序算法来排序数组；Arrays.binarySearch()采取二分查找算法查询指定值。还有fill()、qeuals()等方法。 Arrays 具有封装好的许多静态方法提供给我们对数组进行使用。如toString()、copyOf()、copyOfRange()、sort()、binarySearch()、fill()、equals()等，更多 api 见 P85。 参考：https://www.jianshu.com/p/559d35944079chap3~6：https://www.kancloud.cn/zhangzihao/read-java-core/352483]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（1~2章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18%2F</url>
    <content type="text"><![CDATA[第一章：Java 程序设计概述1.2 Java语言的设计特性 简单性 Java语法剔除了C++中很少或难以理解的特性，没有头文件，指针运算，结构等，语法相对纯净。 另一个简单是小，Java支持嵌入式，可在小型机器上运行，基本解释器和类仅40KB，再加上类库和对线程的支持也不过175KB。当然现在用于类库的扩大，有了独立专用的较小类库Java微型版(Java Micro Edition)用于嵌入式设备。 面向对象 简单说，面向对象设计是一种程序设计技术，重点关注数据(即对象)和对象的接口。本质上Java的面向对象能力与 C++一样，主要不同点在于多继承，Java取而代之的是简单的接口概念，并提供了更丰富的运行时自省功能。 网络功能(分布式) Java拥有扩展的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java程序可通过URL打开和访问网络对象，十分便捷。 健壮性 Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性，Java编译器能够检测许多其他语言仅在运行时刻才能检测出来的问题 安全性 Java在设计时就注意防范诸如运行时堆栈溢出，破坏自己的进程空间之外的内存，未经授权读写文件等问题。不可信代码将在沙箱中运行。 体系结构中立 体现了一处编译，到处运行的思想。编译器编译的字节码，可以在不同处理器上运行，而与计算机体系结构无关，只要有Java运行时系统就可以运行，可以通过Java虚拟机翻译成机器码，即即时编译。 可移植性 Java 中的 int 永远是 32 位，int 的大小不低于 short int，不高于 long int。C/C++ 中 int 可能是 16 位也可能是 32 位，或是编译器提供商指定的其他大小。 与C/C++不同，Java没有“可依赖具体实现”的地方，其基本数据类型的大小以及有关运算都做了明确说明。在Java中，数据类型具有固定大小，二进制数据以固定格式进行存储和传输(消除了字节顺序的困扰)，字符串用标准Unicode格式存储，这消除移植代码问题。 解释性 Java解释器可以在任何移植了解释器的机器上执行Java字节码。 高性能 字节码可以(在运行时刻)动态地翻译成对应运行此应用特定CPU的机器码。依赖虚拟机的即时编译或即时编译器。 多线程 多线程可以带来更好的交互响应和实时行为。在底层，主流平台的线程实现机制各不相同，但Java在不同机器上，调用多线程的代码完全相同，把多线程的实现交给底层的操作系统或线程库来完成。 动态性 相对C/C++，Java库中自由地添加新方法和实例变量，对客户端不会有影响，尤其是正在运行的程序时。 1.5 关于Java的常见误解 Java是HTML的扩展 Java是一种程序设计语言，HTML是一种描述网页结构的方式。二者没有共同之处。 使用XML，所以不需要Java XML是一种描述数据的方式，可以使用任何程序设计语言来处理XML数据，Java API对XML处理提供了很好的支持，也有很多XML第三方工具采用Java编写。 Java将成为适用于所有平台的通用性编程语言 理论上可能，实际上难度很大，Java在服务器端变成和跨平台客户端应用领域比较有优势 Java只不过一种程序设计语言 程序设计语言的成功取决于其支撑系统的能力或者解决问题的能力，而非语法，Java减少指针错误，编程效率更高，这并非Java成功的全部原因。 Java是解释型的，对关键应用程序速度太慢了 早期Java是解释型的，现在Java虚拟机采用即时编译器，运行速度和C++差不多。PS:现在随着计算机性能提升，解释性语言或者编译型语言对运行效率的影响已经很小了。 JavaScript是Java的简易版 JavaScript是一种网页中使用的脚本语言，其语法类似Java，除此之外再无关系。 第二章：Java 程序设计环境Java 程序执行流程下面这幅图简单说明了 Java 程序的执行过程。 Java 工具简介下面简单介绍一下 Java 的一些工具。 JVM JVM（Java Virtual Machine），Java 虚拟机 JVM 是 Java 平台无关性实现的关键 JDK JDK（Java Development Kit），Java 语言的软件开发工具包。 两个主要的组件1 javac – 编译器，将源程序转成字节码2 java – 运行编译后的 java 程序（.class 后缀的） JRE JRE（Java Runtime Environment），Java 运行环境 包括 Java 虚拟机（JVM），Java 核心类库和支持文件 如果只需要运行 Java 程序，下载并安装 JRE 即可 JDK、JRE、JVM 三者关系用下面一幅图表示 概括一下就是 JRE = JVM + JavaSE 标准类库 JDK = JRE + 开发工具集（例如 javac 编译工具等） Java 平台分类最后再补充的就是 Java 平台分类，Java 平台可以分成下面三类 JavaSE主要用于开发桌面程序，也称为 Java 标准版。 JavaEE主要用于 Web 程序开发，也称为 Java 企业版。 JavaME主要用于移动设备的开发，也称为 Java 微型版。不过自从 Android 和 iOS 兴起后它就用的很少了。 参考：https://www.jianshu.com/p/559d35944079第1章：http://xuer80.com/2017/11/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/第2章：https://www.jianshu.com/p/3dd960faf7ff]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“大话架构”阿里架构师分享的Java程序员需要突破的技术要点]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-4%2F</url>
    <content type="text"><![CDATA[一、源码分析源码分析是一种临界知识，掌握了这种临界知识，能不变应万变，源码分析对于很多人来说很枯燥，生涩难懂。 源码阅读，我觉得最核心有三点：技术基础 + 强烈的求知欲 + 耐心。 我认为是阅读源码的最核心驱动力。我见到绝大多数程序员，对学习的态度，基本上就是这几个层次 (很偏激哦)： 1、只关注项目本身，不懂就 baidu 一下。 2、除了做好项目，还会阅读和项目有关的技术书籍，看 wikipedia。 3、除了阅读和项目相关的书外，还会阅读 IT 行业的书，比如学 Java 时，还会去了解函数语言，如 LISP。 4、找一些开源项目看看，大量试用第三方框架，还会写写 demo。 5、阅读基础框架、J2EE 规范、Debug 服务器内核。 大多数程序都是第 1 种，到第 5 种不光需要浓厚的兴趣，还需要勇气：我能读懂吗？其实，你能够读懂的 耐心，真的很重要。因为你极少看到阅读源码的指导性文章或书籍，也没有人要求或建议你读。你读的过程中经常会卡住，而一卡主可能就陷进了迷宫。这时，你需要做的，可能是暂时中断一下，再从外围看看它：如 API 结构、框架的设计图。 下图是我总结出目前最应该学习的源码知识点： 二、分布式架构分布式系统是一个古老而宽泛的话题，而近几年因为 “大数据” 概念的兴起，又焕发出了新的青春与活力。除此之外，分布式系统也是一门理论模型与工程技法并重的学科内容。相比于机器学习这样的研究方向，学习分布式系统的同学往往会感觉：“入门容易，深入难”。的确，学习分布式系统几乎不需要太多数学知识。 分布式系统是一个复杂且宽泛的研究领域，学习一两门在线课程，看一两本书可能都是不能完全覆盖其所有内容的。 总的来说，分布式系统要做的任务就是把多台机器有机的组合、连接起来，让其协同完成一件任务，可以是计算任务，也可以是存储任务。如果一定要给近些年的分布式系统研究做一个分类的话，我个人认为大概可以包括三大部分： 分布式存储系统 分布式计算系统 分布式管理系统 下图是我总结近几年目前分布式最主流的技术： 三、微服务当前微服务很热，大家都号称在使用微服务架构，但究竟什么是微服务架构？微服务架构是不是发展趋势？对于这些问题，我们都缺乏清楚的认识。 为解决单体架构下的各种问题，微服务架构应运而生。与其构建一个臃肿庞大、难以驯服的怪兽，还不如及早将服务拆分。微服务的核心思想便是服务拆分与解耦，降低复杂性。微服务强调将功能合理拆解，尽可能保证每个服务的功能单一，按照单一责任原则（Single Responsibility Principle）明确角色。 将各个服务做轻，从而做到灵活、可复用，亦可根据各个服务自身资源需求，单独布署，单独作横向扩展。 下图是我总结出微服务需要学习的知识点： 四、性能优化不管是应付前端面试还是改进产品体验，性能优化都是躲不开的话题。 优化的目的是让用户有 “快” 的感受，那如何让用户感受到快呢？ 加载速度真的很快，用户打开输入网址按下回车立即看到了页面加载速度并没有变快，但用户感觉你的网站很快性能优化取决于多个因素，包括垃圾收集、虚拟机和底层操作系统（OS）设置。有多个工具可供开发人员进行分析和优化时使用，你可以通过阅读 Java Tools for Source Code Optimization and Analysis 来学习和使用它们。 必须要明白的是，没有两个应用程序可以使用相同的优化方式，也没有完美的优化 java 应用程序的参考路径。使用最佳实践并且坚持采用适当的方式处理性能优化。想要达到真正最高的性能优化，你作为一个 Java 开发人员，需要对 Java 虚拟机（JVM）和底层操作系统有正确的理解。 以上五大知识体系是我从业多年总结出来的经验，都是当前最主流的技术。想学习这些技术的朋友可以加群：478030634。群里会分享这些技术知识点供大家学习免费下载 下图是我总结性能优化应该学习理解的几大知识体系： 五、Java 工程化工欲善其事，必先利其器，不管是小白，还是资深开发，都需要先选择好的工具。提升开发效率何团队协作效率。让自己有更多时间来思考。 “大话架构” 阿里架构师分享的 Java 程序员需要突破的技术要点 原文：https://segmentfault.com/a/1190000013561054]]></content>
      <tags>
        <tag>待阅</tag>
        <tag>架构</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试中并发类问题的准备和学习]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-3%2F</url>
    <content type="text"><![CDATA[声明：本文主要讨论的是后端Java开发职位的面试 主题 又到面试季了，从课程的群里，看到许多同学分享了自己的面试题目，我也抽空在网上搜索了一些许多公司使用的面试题，目前校招和社招的面试题基本都集中在几个大方向上，主要是：Java基础、并发、JVM、算法、数据库、一些框架、分布式集群 等。这里呢，单独就面试中的【并发】问题的准备和学习发表一下个人的见解。 现状 关于对并发的学习和理解，通过和许多学员沟通及大家在课程群里的反馈，总结一下，主要包含以下几种： 完全不知道并发的存在 知道并发要学，但是不知道该学习什么 知道并发重要，自己买相关书籍学，但是看完了还是懵懵懂懂 知道并发重要，自己查资料学了一些，许多都学会了，但总能发现不会的，不知道并发到底都要学什么 已经完成进阶，并发的问题了然于胸，这样的学员目前很少 首先说一下，为什么Java面试要考并发，而且并发相关的题目占比又是那么的高。对并发有一定了解的同学，应该都知道，大家平时 只要做Java项目就会涉及到并发 ，个别同学说自己从没接触过并发，这只是个人还没意识到而已。当你定义好一个可以调用的接口时，这时其实就已经和并发有关系了，因为任何一个接口都可能同时被请求多次。当你在项目中已经可以熟练的使用synchronized、volatile、static、final这些基本的Java关键字时，其实你对并发已经有一些基础了。大家总说的：面试造火箭、入职拧螺丝，其实有一部分原因也是因为你还没意识到面试考的这些东西其实一直就伴随着你的日常开发。 我不自量力的去列一下并发涉及到的关键字、类及可以考察的知识点：CPU缓存、Java内存模型JMM、atomic、AtomicInteger、AtomicLong、LongAdder、AtomicReference、AtomicBoolean、CAS原理、Unsafe、synchronized、volatile、final、static、ThreadLocal、AQS、J.U.C、CountDownLatch、Semaphore、CyclicBarrier、ReentrantLock、ReentrantReadWriteLock、StampLock、Condition、FutureTask、Fork/Join、BlockingQueue、ThreadPoolExecutor、ExecutorService、Thread、Runnable、Future、Callable、HashMap、 HashTable、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、RateLimiter、SimpleDateFormat、StringBuffer、StringBuilder、ArrayList、Vector、HashSet、ConcurrentSkipListSet、Collections.synchronizedXXX、Guava Cache、Redis … 我尝试去写出脑海里与并发有关的类和名词，我发现根本写！不！完！是的，并发的知识太多了，以致于很难给出一个完整的囊括。 因此呢，如果你盲目的一个知识点一个知识的去学，你就会发现你怎么都学不完，也很难在脑海里形成一个完整的知识体系，带来的最直接结果就是，你每次去面试时都要去把并发相关的再过一下，生怕自己被问到还没接触的。这时候，你要做的就是，先要在脑海里有一个完整的并发知识体系，然后根据这个体系去不断完善这个体系里每个模块的细节。 并发 关于并发的学习，可以从JDK提供的并发包为核心开始，许多其他的类和封装都是对其进行扩展或者补充，我们来看一下Java并发包(java.util.concurrent包，简称J.U.C)的构成： J.U.C核心由5大块组成：atomic包、locks包、collections包、tools包（AQS）、executor包（线程池）。大家平时遇到许多并发相关的类都可以从这里找到。但是呢，要想系统的掌握并发，不能是打开J.U.C这个包，挨个类去看，这里只是提供了五大块，代表核心的五个方向。要想系统的学习并发，还需要从并发的角度学习，过程中覆盖J.U.C的这些知识。这里我直接给出并发的学习步骤图（包含对当前面试常见考点的覆盖，比如对HashMap和ConcurrentHashMap的源码分析）： 这个之前呢，还需要对Java并发的基础进行细致的学习，比如CPU缓存和Java内存模型（JMM），许多关键字比如volatile、synchronized等的特性都是在JMM里规定好的。 高并发 我们这篇手记题目里提到的并发其实包含两部分：并发和高并发。手记讲到现在，其实我们讲的都是两部分里的第一部分：并发。那么并发和高并发到底有什么区别呢？许多学员对这两个概念都是模糊的，我简单做一下区分。 当我们说多线程并发时，其实我们更多的是讨论多个线程操作了相同的资源，这时我们讨论点更多的是落在保证线程安全以及合理分配和使用资源上。而高并发主要指系统运行过程中遇到“短时间内遇到大量操作请求”的情况，主要发生在系统集中收到大量请求（例如：12306的抢票情况；天猫双十一活动）。当我们说高并发时，我们谈的是是如何提高现有程序的性能，更多的是对高并发场景的一些解决方案，思路啦、手段等等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等。这里呢，我直接给出高并发场景通常都会考虑的一些解决思路和手段： 结尾 如何有效的准备面试中并发类问题，我已经给出我的理解。希望这些能帮大家在脑海里建立起大致的并发知识体系，然后根据这个知识体系有针对性的的去准备面试。预祝大家能高分通过面试，拿到高薪！ 当然，光提概念光看图是没用的，还需要大家根据这些提纲去实际学习相关的知识点和类才行。我已经准备好了这些实际知识点学习的流程，相信聪明的你已经知道该怎么办了~ 原文地址 https://www.imooc.com/article/23969]]></content>
      <tags>
        <tag>面试</tag>
        <tag>java并发</tag>
        <tag>待阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典Java面试题95道]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-2%2F</url>
    <content type="text"><![CDATA[1、面向对象的特征有哪些方面？ 答：面向对象的特征主要有以下几个方面： 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中关于桥梁模式的部分）。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 2、访问修饰符 public,private,protected, 以及不写（默认）时的区别？ 类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。 3、String 是最基本的数据类型吗？ 答：不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。 4、float f=3.4; 是否正确？ 答: 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float)3.4; 或者写成 float f =3.4F; 5、short s1 = 1; s1 = s1 + 1; 有错吗? short s1 = 1; s1 += 1; 有错吗？ 答：对于 short s1 = 1; s1 = s1 + 1; 由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1; 可以正确编译，因为 s1+= 1; 相当于 s1 = (short)(s1 + 1); 其中有隐含的强制类型转换。 6、Java 有没有 goto？ 答：goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 7、int 和 Integer 有什么区别？ 答：Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱 / 拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 12345678910class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示： 123456789public class Test03 &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，所以下面的 == 运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf，如果看看 valueOf 的源代码就知道发生了什么。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache 是 Integer 的内部类，其代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 简单的说，如果整型字面量的值在 - 128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1==f2 的结果是 true，而 f3==f4 的结果是 false。 提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。 8、&amp; 和 &amp;&amp; 的区别？ 答：&amp; 运算符有两种用法：(1) 按位与；(2) 逻辑与。&amp;&amp; 运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;&amp; 之所以称为短路运算是因为，如果 &amp;&amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用 &amp;&amp; 而不是 &amp;，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用 &amp; 运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 补充：如果你熟悉 JavaScript，那你可能更能感受到短路运算的强大，想成为 JavaScript 的高手就先从玩转短路运算开始吧。 9、解释内存中的栈 (stack)、堆(heap) 和方法区 (method area) 的用法。 答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”hello” 和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。 String str = new String(“hello”);上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而 “hello” 这个字面量是放在方法区的。 补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发展和 “逃逸分析” 技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。 补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的。 看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否一致。 123456String s1 = new StringBuilder(&quot;go&quot;) .append(&quot;od&quot;).toString();System.out.println(s1.intern() == s1);String s2 = new StringBuilder(&quot;ja&quot;) .append(&quot;va&quot;).toString();System.out.println(s2.intern() == s2); 10、Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少？ 答：Math.round(11.5) 的返回值是 12，Math.round(-11.5) 的返回值是 - 11。四舍五入的原理是在参数上加 0.5 然后进行下取整。 11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？ 答：在 Java 5 以前，switch(expr) 中，expr 只能是 byte、short、char、int。从 Java 5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 12、用最有效率的方法计算 2 乘以 8？ 答： 2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。 补充：我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答案你可以自己百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于 (num &lt;&lt; 5) - num，左移 5 位相当于乘以 2 的 5 次方再减去自身就相当于乘以 31，现在的 VM 都能自动完成这个优化。 1234567891011121314151617181920212223242526272829303132333435363738394041public class PhoneNumber &#123; private int areaCode; private String prefix; private String lineNumber; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + areaCode; result = prime * result + ((lineNumber == null) ? 0 : lineNumber.hashCode()); result = prime * result + ((prefix == null) ? 0 : prefix.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PhoneNumber other = (PhoneNumber) obj; if (areaCode != other.areaCode) return false; if (lineNumber == null) &#123; if (other.lineNumber != null) return false; &#125; else if (!lineNumber.equals(other.lineNumber)) return false; if (prefix == null) &#123; if (other.prefix != null) return false; &#125; else if (!prefix.equals(other.prefix)) return false; return true; &#125;&#125; 13、数组有没有 length() 方法？String 有没有 length() 方法？ 答：数组没有 length() 方法，有 length 的属性。String 有 length() 方法。JavaScript 中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。 14、在 Java 中，如何跳出当前的多重嵌套循环？ 答：在最外层循环前加一个标记如 A，然后用 break A; 可以跳出多重循环。（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++ 中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好） 15、构造器（constructor）是否可被重写（override）？ 答：构造器不能被继承，因此不能被重写，但可以被重载。 16、两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对？ 答：不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1) 如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；(2) 如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 补充：关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人也就是仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java 程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍 equals 方法的：首先 equals 方法必须满足自反性（x.equals(x) 必须返回 true）、对称性（x.equals(y) 返回 true 时，y.equals(x) 也必须返回 true）、传递性（x.equals(y) 和 y.equals(z) 都返回 true 时，x.equals(z) 也必须返回 true）和一致性（当 x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y) 应该得到同样的返回值），而且对于任何非 null 值的引用 x，x.equals(null) 必须返回 false。实现高质量的 equals 方法的诀窍包括：1. 使用 == 操作符检查 “参数是否为这个对象的引用”；2. 使用 instanceof 操作符检查 “参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性；5. 重写 equals 时总是要重写 hashCode；6. 不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉 @Override 注解。 17、是否可以继承 String 类？ 答：String 类是 final 类，不可以被继承。 补充：继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是按值传递还是按引用传递？ 答：是按值传递。Java 语言的方法调用只支持参数的按值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但在方法内部对对象引用的改变是不会影响到被调用者的。C++ 和 C# 中可以通过传引用或传输出参数来改变传入的参数的值。在 C# 中可以编写如下所示的代码，但是在 Java 中却做不到。 12345678910111213141516171819using System;namespace CS01 &#123; class Program &#123; public static void swap(ref int x, ref int y) &#123; int temp = x; x = y; y = temp; &#125; public static void Main (string[] args) &#123; int a = 5, b = 10; swap (ref a, ref b); // a = 10, b = 5; Console.WriteLine (&quot;a = &#123;0&#125;, b = &#123;1&#125;&quot;, a, b); &#125; &#125;&#125; 说明：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++ 转型为 Java 程序员的开发者无法容忍。 19、String 和 StringBuilder、StringBuffer 的区别？ 答：Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。 面试题 1 - 什么情况下用 + 运算符进行字符串连接比调用 StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？ 面试题 2 - 请说出下面程序的输出。 12345678910111213141516class StringEqualTest &#123; public static void main(String[] args) &#123; String s1 = &quot;Programming&quot;; String s2 = new String(&quot;Programming&quot;); String s3 = &quot;Program&quot;; String s4 = &quot;ming&quot;; String s5 = &quot;Program&quot; + &quot;ming&quot;; String s6 = s3 + s4; System.out.println(s1 == s2); System.out.println(s1 == s5); System.out.println(s1 == s6); System.out.println(s1 == s6.intern()); System.out.println(s2 == s2.intern()); &#125;&#125; 补充：解答上面的面试题需要清除两点：1. String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2. 字符串的 + 操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class 命令获得 class 文件对应的 JVM 字节码指令就可以看出来。 20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 面试题：华为的面试题中曾经问过这样一个问题 - “为什么不能根据返回类型来区分重载”，快说出你的答案吧！ 因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。 例如： 12float max(int a, int b);int max(int a, int b); 当调用 max(1, 2); 时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。 21、描述一下 JVM 加载 class 文件的原理机制？ 答：JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的. class 文件中的数据读入到内存中，通常是创建一个字节数组读入. class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2) 如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）； Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap； System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中加载类，是用户自定义加载器的默认父加载器。 22、char 型变量中能不能存贮一个中文汉字，为什么？ 答：char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。 补充：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体 / 共用体）共享内存的特征来实现了。 23、抽象类（abstract class）和接口（interface）有什么异同？ 答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 24、静态嵌套类 (Static Nested Class) 和内部类（Inner Class）的不同？ 答：Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 扑克类（一副扑克） * */public class Poker &#123; private static String[] suites = &#123;&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;&#125;; private static int[] faces = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13&#125;; private Card[] cards; /** * 构造器 * */ public Poker() &#123; cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) &#123; for(int j = 0; j &lt; faces.length; j++) &#123; cards[i * 13 + j] = new Card(suites[i], faces[j]); &#125; &#125; &#125; /** * 洗牌 （随机乱序） * */ public void shuffle() &#123; for(int i = 0, len = cards.length; i &lt; len; i++) &#123; int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; &#125; &#125; /** * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) &#123; return cards[index]; &#125; /** * 卡片类（一张扑克） * [内部类] * */ public class Card &#123; private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) &#123; this.suite = suite; this.face = face; &#125; @Override public String toString() &#123; String faceStr = &quot;&quot;; switch(face) &#123; case 1: faceStr = &quot;A&quot;; break; case 11: faceStr = &quot;J&quot;; break; case 12: faceStr = &quot;Q&quot;; break; case 13: faceStr = &quot;K&quot;; break; default: faceStr = String.valueOf(face); &#125; return suite + faceStr; &#125; &#125;&#125; 测试代码： 1234567891011121314class PokerTest &#123; public static void main(String[] args) &#123; Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A &#125;&#125; 面试题 - 下面的代码哪些地方会产生编译错误？ 123456789101112class Outer &#123; class Inner &#123;&#125; public static void foo() &#123; new Inner(); &#125; public void bar() &#123; new Inner(); &#125; public static void main(String[] args) &#123; new Inner(); &#125;&#125; 注意：Java 中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中 foo 和 main 方法都是静态方法，静态方法中没有 this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： 1new Outer().new Inner(); 25、Java 中会存在内存泄漏吗，请简单描述。 答：理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。例如 Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。 123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.EmptyStackException;public class MyStack&lt;T&#123; private T[] elements; private int size = 0; private static final int INIT_CAPACITY = 16; public MyStack() &#123; elements = (T[]) new Object[INIT_CAPACITY]; &#125; public void push(T elem) &#123; ensureCapacity(); elements[size++] = elem; &#125; public T pop() &#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) &#123; elements = Arrays.copyOf(elements, 2 * size + 1); &#125; &#125;&#125; 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发 Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成 OutOfMemoryError。 26、抽象的（abstract）方法是否可同时是静态的（static）, 是否可同时是本地方法（native），是否可同时被 synchronized 修饰？ 答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 27、阐述静态变量和实例变量的区别。 答：静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。 28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？ 答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。 29、如何实现对象克隆？ 答：有两种方式： 1). 实现 Cloneable 接口并重写 Object 类中的 clone() 方法； 2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下： 1234567891011121314151617181920212223242526import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T extends SerializableT clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 &#125;&#125; 下面是测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.io.Serializable;/** * 人类 * @author nnngu * */class Person implements Serializable &#123; private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) &#123; this.name = name; this.age = age; this.car = car; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return &quot;Person []&quot;; &#125;&#125;/** * 小汽车类 * @author nnngu * */class Car implements Serializable &#123; private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) &#123; this.brand = brand; this.maxSpeed = maxSpeed; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, maxSpeed=&quot; + maxSpeed + &quot;]&quot;; &#125;&#125;class CloneTest &#123; public static void main(String[] args) &#123; try &#123; Person p1 = new Person(&quot;郭靖&quot;, 33, new Car(&quot;Benz&quot;, 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand(&quot;BYD&quot;); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 30、GC 是什么？为什么要有 GC？ 答：GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显式操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显式的垃圾回收调用。 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的 Java 进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和清除，但是 Java 对其进行了改进，采用 “分代式垃圾收集”。这种方法会根据 Java 对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 与垃圾回收相关的 JVM 参数： -Xms / -Xmx — 堆的初始大小 / 堆的最大大小 -Xmn — 堆中年轻代的大小 -XX:-DisableExplicitGC — 让 System.gc() 不产生任何作用 -XX:+PrintGCDetails — 打印 GC 的细节 -XX:+PrintGCDateStamps — 打印 GC 操作的时间戳 -XX:NewSize / XX:MaxNewSize — 设置新生代大小 / 新生代最大大小 -XX:NewRatio — 可以设置老生代和新生代的比例 -XX:PrintTenuringDistribution — 设置每次新生代 GC 后输出幸存者乐园中对象年龄的分布 -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值 -XX:TargetSurvivorRatio：设置幸存区的目标使用率 31、String s = new String(“xyz”); 创建了几个字符串对象？ 答：两个对象，一个是静态区的 “xyz”，一个是用 new 创建在堆上的对象。 32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 答：接口可以继承接口，而且支持多重继承。抽象类可以实现 (implements) 接口，抽象类可继承具体类也可以继承抽象类。 举一个多继承的例子，我们定义一个动物（类）既是狗（父类 1）也是猫（父类 2），两个父类都有 “叫” 这个方法。那么当我们调用 “叫” 这个方法时，它就不知道是狗叫还是猫叫了，这就是多重继承的冲突。而接口没有具体的方法实现，所以多继承接口也不会出现这种冲突。 33、一个 “.java” 源文件中是否可以包含多个类（不是内部类）？有什么限制？ 答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。 34、Anonymous Inner Class(匿名内部类) 是否可以继承其它类？是否可以实现接口？ 答：可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来实现事件监听和回调。 35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。 36、Java 中的 final 关键字有哪些用法？ 答：(1) 修饰类：表示该类不能被继承；(2) 修饰方法：表示方法不能被重写；(3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 37、指出下面程序的运行结果。 123456789101112131415161718192021222324252627282930class A &#123; static &#123; System.out.print(&quot;1&quot;); &#125; public A() &#123; System.out.print(&quot;2&quot;); &#125;&#125;class B extends A&#123; static &#123; System.out.print(&quot;a&quot;); &#125; public B() &#123; System.out.print(&quot;b&quot;); &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; A ab = new B(); ab = new B(); &#125;&#125; 答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。 提示：如果不能给出此题的正确答案，说明之前第 21 题 Java 类加载机制还没有完全理解，赶紧再看看吧。 38、数据类型之间的转换： 如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？ 答： 调用基本数据类型对应的包装类中的方法 parseXXX(String) 或 valueOf(String) 即可返回相应基本类型； 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用 String 类中的 valueOf() 方法返回相应字符串 39、如何实现字符串的反转及替换？ 答：方法很多，可以自己写实现也可以使用 String 或 StringBuffer/StringBuilder 中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示： 12345public static String reverse(String originStr) &#123; if(originStr == null || originStr.length() &lt;= 1) return originStr; return reverse(originStr.substring(1)) + originStr.charAt(0);&#125; 40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？ 答：代码如下所示： 12String s1 = &quot;你好&quot;;String s2 = new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); 41、日期和时间： 如何取得年月日、小时分钟秒？如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？如何取得某月的最后一天？如何格式化日期？ 答： 问题 1：创建 java.util.Calendar 实例，调用其 get() 方法传入不同的参数即可获得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTimel 来获取，代码如下所示。 1234567891011121314151617181920public class DateTimeTest &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.println(cal.get(Calendar.YEAR)); System.out.println(cal.get(Calendar.MONTH)); // 0 - 11 System.out.println(cal.get(Calendar.DATE)); System.out.println(cal.get(Calendar.HOUR_OF_DAY)); System.out.println(cal.get(Calendar.MINUTE)); System.out.println(cal.get(Calendar.SECOND)); // Java 8 LocalDateTime dt = LocalDateTime.now(); System.out.println(dt.getYear()); System.out.println(dt.getMonthValue()); // 1 - 12 System.out.println(dt.getDayOfMonth()); System.out.println(dt.getHour()); System.out.println(dt.getMinute()); System.out.println(dt.getSecond()); &#125;&#125; 问题 2：以下方法均可获得该毫秒数。 123Calendar.getInstance().getTimeInMillis();System.currentTimeMillis();Clock.systemDefaultZone().millis(); // Java 8 问题 3：代码如下所示。 12Calendar time = Calendar.getInstance();time.getActualMaximum(Calendar.DAY_OF_MONTH); 问题 4：利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的 format(Date) 方法可将日期格式化。Java 8 中可以用 java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。 123456789101112131415161718import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.format.DateTimeFormatter;import java.util.Date;class DateFormatTest &#123; public static void main(String[] args) &#123; SimpleDateFormat oldFormatter = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); Date date1 = new Date(); System.out.println(oldFormatter.format(date1)); // Java 8 DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;); LocalDate date2 = LocalDate.now(); System.out.println(date2.format(newFormatter)); &#125;&#125; 补充：Java 的时间日期 API 一直以来都是被诟病的东西，为了解决这一问题，Java 8 中引入了新的时间日期 API，其中包括 LocalDate、LocalTime、LocalDateTime、Clock、Instant 等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。 42、打印昨天的当前时刻。 123456789import java.util.Calendar;class YesterdayCurrent &#123; public static void main(String[] args)&#123; Calendar cal = Calendar.getInstance(); cal.add(Calendar.DATE, -1); System.out.println(cal.getTime()); &#125;&#125; 在 Java 8 中，可以用下面的代码实现相同的功能。 1234567891011import java.time.LocalDateTime;class YesterdayCurrent &#123; public static void main(String[] args) &#123; LocalDateTime today = LocalDateTime.now(); LocalDateTime yesterday = today.minusDays(1); System.out.println(yesterday); &#125;&#125; 43、比较一下 Java 和 JavaSciprt。 答：JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。 下面对两种语言间的异同作如下比较： 基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率） 强类型变量和弱类型变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行时检查推断其数据类型。 代码格式不一样。补充：上面列出的四点是网上流传的所谓的标准答案。其实 Java 和 JavaScript 最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在 Java 中类（class）是一等公民，而 JavaScript 中函数（function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda 函数和闭包（closure），当然 Java 8 也开始支持函数式编程，提供了对 Lambda 表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。 44、什么时候用断言（assert）？ 答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表达式的值为 false，那么系统会报告一个 AssertionError。断言的使用如下面的代码所示： 1assert(a 0); // throws an AssertionError if a &lt;= 0 断言可以有两种形式： 1234assert Expression1;assert Expression1 : Expression2 ;Expression1 应该总是产生一个布尔值。Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。 要在运行时启用断言，可以在启动 JVM 时使用 - enableassertions 或者 - ea 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 - da 或者 - disableassertions 标记。要在系统类中启用或禁用断言，可使用 - esa 或 - dsa 标记。还可以在包的基础上启用或者禁用断言。 注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。 45、Error 和 Exception 有什么区别 #？ 答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 面试题：2005 年摩托罗拉的面试中曾经问过这么一个问题 “If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项 a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java 程序在运行时也可能会遭遇 StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是 c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示： 123456class StackOverflowErrorTest &#123; public static void main(String[] args) &#123; main(null); &#125;&#125; 提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。 46、try{} 里有一个 return 语句，那么紧跟在这个 try 后的 finally{} 里的代码会不会被执行，什么时候被执行，在 return 前还是后? 答：会执行，在方法返回前执行。 注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C# 中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse 中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。 47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？ 答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的 try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者最终将异常抛给 JVM。 48、运行时异常与受检异常有何异同？ 答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用给出了以下指导原则： 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常） 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 优先使用标准的异常 每个方法抛出的异常都要有文档 保持异常的原子性 不要在 catch 中忽略掉捕获到的异常 49、列出一些你常见的运行时异常？ 答： ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 50、阐述 final、finally、finalize 的区别。 答： final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方法也同样只能使用，不能在子类中被重写。 finally：通常放在 try…catch… 的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。 finalize：Object 类中定义的方法，Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。 51、类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。 有如下代码片断： 1234567try &#123; throw new ExampleB(&quot;b&quot;)&#125; catch（ExampleA e）&#123; System.out.println(&quot;ExampleA&quot;);&#125; catch（Exception e）&#123; System.out.println(&quot;Exception&quot;);&#125; 请问执行此段代码的输出是什么？ 答：输出：ExampleA。（根据里氏代换原则 [能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常） 面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书） 12345678910111213141516171819202122232425class Annoyance extends Exception &#123;&#125;class Sneeze extends Annoyance &#123;&#125;class Human &#123; public static void main(String[] args) throws Exception &#123; try &#123; try &#123; throw new Sneeze(); &#125; catch ( Annoyance a ) &#123; System.out.println(&quot;Caught Annoyance&quot;); throw a; &#125; &#125; catch ( Sneeze s ) &#123; System.out.println(&quot;Caught Sneeze&quot;); return ; &#125; finally &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;&#125; 52、List、Set、Map 是否继承自 Collection 接口？ 答：List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。 53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。 答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 补充：遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，Properties 是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个 Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中的 Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或 Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun 公司的工程师们也会犯这种低级错误，让人唏嘘不已。 54、Collection 和 Collections 的区别？ 答：Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 55、List、Map、Set 三个接口存取元素时，各有什么特点？ 答：List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals() 方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort() 方法如何比较元素？ 答：TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo() 方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象必须实现 Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。例子 1： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Student implements Comparable&lt;Student&#123; private String name; // 姓名 private int age; // 年龄 public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student []&quot;; &#125; @Override public int compareTo(Student o) &#123; return this.age - o.age; // 比较年龄(年龄的升序) &#125;&#125;import java.util.Set;import java.util.TreeSet;class Test01 &#123; public static void main(String[] args) &#123; Set&lt;Studentset = new TreeSet&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) set.add(new Student(&quot;Hao LUO&quot;, 33)); set.add(new Student(&quot;XJ WANG&quot;, 32)); set.add(new Student(&quot;Bruce LEE&quot;, 60)); set.add(new Student(&quot;Bob YANG&quot;, 22)); for(Student stu : set) &#123; System.out.println(stu); &#125;// 输出结果: // Student [name=Bob YANG, age=22]// Student [name=XJ WANG, age=32]// Student [name=Hao LUO, age=33]// Student [name=Bruce LEE, age=60] &#125;&#125; 例子 2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Student &#123; private String name; // 姓名 private int age; // 年龄 public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; /** * 获取学生姓名 */ public String getName() &#123; return name; &#125; /** * 获取学生年龄 */ public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Student []&quot;; &#125;&#125;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;class Test02 &#123; public static void main(String[] args) &#123; List&lt;Studentlist = new ArrayList&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) list.add(new Student(&quot;Hao LUO&quot;, 33)); list.add(new Student(&quot;XJ WANG&quot;, 32)); list.add(new Student(&quot;Bruce LEE&quot;, 60)); list.add(new Student(&quot;Bob YANG&quot;, 22)); // 通过sort方法的第二个参数传入一个Comparator接口对象 // 相当于是传入一个比较对象大小的算法到sort方法中 // 由于Java中没有函数指针、仿函数、委托这样的概念 // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调 Collections.sort(list, new Comparator&lt;Student() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getName().compareTo(o2.getName()); // 比较学生姓名 &#125; &#125;); for(Student stu : list) &#123; System.out.println(stu); &#125;// 输出结果: // Student [name=Bob YANG, age=22]// Student [name=Bruce LEE, age=60]// Student [name=Hao LUO, age=33]// Student [name=XJ WANG, age=32] &#125;&#125; 57、Thread 类的 sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别? 答：sleep() 方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第 66 题中的线程状态转换图）。wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。时下很时髦的 Node.js 就采用了单线程异步 I/O 的工作模式。 58、线程的 sleep() 方法和 yield() 方法有什么区别？ 答： ① sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（ready）状态； ③ sleep() 方法声明抛出 InterruptedException，而 yield() 方法没有声明任何异常； ④ sleep() 方法比 yield() 方法（跟操作系统 CPU 调度相关）具有更好的可移植性。 59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？ 答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。 60、请说出与线程同步以及线程调度相关的方法。 答： wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition() 方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire() 方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release() 方法）。 下面的例子演示了 100 个线程同时向一个银行账户中存入 1 元钱，在没有使用同步机制和使用同步机制情况下的执行情况。 银行账户类： 123456789101112131415161718192021222324252627282930/** * 银行账户 * @author nnngu * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 存钱线程类： 1234567891011121314151617181920/** * 存钱线程 * @author nnngu * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; account.deposit(money); &#125;&#125; 测试类： 1234567891011121314151617181920import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test01 &#123; public static void main(String[] args) &#123; Account account = new Account(); ExecutorService service = Executors.newFixedThreadPool(100); for(int i = 1; i &lt;= 100; i++) &#123; service.execute(new AddMoneyThread(account, 1)); &#125; service.shutdown(); while(!service.isTerminated()) &#123;&#125; System.out.println(&quot;账户余额: &quot; + account.getBalance()); &#125;&#125; 在没有同步的情况下，执行结果通常是显示账户余额在 10 元以下，出现这种状况的原因是，当一个线程 A 试图存入 1 元的时候，另外一个线程 B 也能够进入存款的方法中，线程 B 读取到的账户余额仍然是线程 A 存入 1 元钱之前的账户余额，因此也是在原来的余额 0 上面做了加 1 元的操作，同理线程 C 也会做类似的事情，所以最后 100 个线程执行结束时，本来期望账户余额为 100 元，但实际得到的通常在 10 元以下（很可能是 1 元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案： 在银行账户的存款（deposit）方法上加同步（synchronized）关键字 123456789101112131415161718192021222324252627282930/** * 银行账户 * @author nnngu * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public synchronized void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 在线程调用存款方法时对银行账户进行同步 12345678910111213141516171819202122/** * 存钱线程 * @author nnngu * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; synchronized (account) &#123; account.deposit(money); &#125; &#125;&#125; 通过 Java 5 显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 银行账户 * * @author nnngu * */public class Account &#123; private Lock accountLock = new ReentrantLock(); private double balance; // 账户余额 /** * 存款 * * @param money * 存入金额 */ public void deposit(double money) &#123; accountLock.lock(); try &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; finally &#123; accountLock.unlock(); &#125; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 按照上述三种方式对代码进行修改后，重写执行测试代码 Test01，将看到最终的账户余额为 100 元。当然也可以使用 Semaphore 或 CountdownLatch 来实现同步。 61、编写多线程程序有几种实现方式？ 答：Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一种是实现 Runnable 接口。两种方式都要通过重写 run() 方法来定义线程的行为，推荐使用后者，因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其他类了，显然使用 Runnable 接口更为灵活。 补充：Java 5 以后创建线程还有第三种方式：实现 Callable 接口，该接口中的 call 方法可以在线程执行结束时产生一个返回值，代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;class MyTask implements Callable&lt;Integer&#123; private int upperBounds; public MyTask(int upperBounds) &#123; this.upperBounds = upperBounds; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) &#123; sum += i; &#125; return sum; &#125;&#125;class Test &#123; public static void main(String[] args) throws Exception &#123; List&lt;Future&lt;Integer&gt;list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) &#123; list.add(service.submit(new MyTask((int) (Math.random() * 100)))); &#125; int sum = 0; for(Future&lt;Integerfuture : list) &#123; // while(!future.isDone()) ; sum += future.get(); &#125; System.out.println(sum); &#125;&#125; 62、synchronized 关键字的用法？ 答：synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用 synchronized(对象) { … } 定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。在第 60 题的例子中已经展示了 synchronized 关键字的用法。 63、举例说明同步和异步。 答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 64、启动一个线程是调用 run() 还是 start() 方法？ 答：启动一个线程是调用 start() 方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run() 方法是线程启动后要进行回调（callback）的方法。 65、什么是线程池（thread pool）？ 答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是” 池化资源” 技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 Java 5 + 中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 里面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。第 60 题的例子中演示了通过 Executors 工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用 newFixedThreadPool 方法来创建线程池，这样能获得更好的性能。 66、线程的基本状态以及状态之间的关系？ 答： 说明：其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait() 方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了 sleep() 方法或 join() 方法等待休眠或其他线程结束，或是因为发生了 I/O 中断。 67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？ 答：Lock 是 Java 5 以后引入的新的 API，和关键字 synchronized 相比主要相同点：Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。 68、Java 中如何实现序列化，有什么意义？ 答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object) 方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第 29 题）。 69、Java 中有几种类型的流？ 答：字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承于 Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于 Java 的 I/O 需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外 Java 中的流不同于 C# 的是它只有一个维度一个方向。 面试题 - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案） 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public final class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; public static void fileCopy(String source, String target) throws IOException &#123; try (InputStream in = new FileInputStream(source)) &#123; try (OutputStream out = new FileOutputStream(target)) &#123; byte[] buffer = new byte[4096]; int bytesToRead; while((bytesToRead = in.read(buffer)) != -1) &#123; out.write(buffer, 0, bytesToRead); &#125; &#125; &#125; &#125; public static void fileCopyNIO(String source, String target) throws IOException &#123; try (FileInputStream in = new FileInputStream(source)) &#123; try (FileOutputStream out = new FileOutputStream(target)) &#123; FileChannel inChannel = in.getChannel(); FileChannel outChannel = out.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(4096); while(inChannel.read(buffer) != -1) &#123; buffer.flip(); outChannel.write(buffer); buffer.clear(); &#125; &#125; &#125; &#125;&#125; 注意：上面用到 Java 7 的 TWR，使用 TWR 后可以不用在 finally 中释放外部资源 ，从而让代码更加优雅。 70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。 答：代码如下： 12345678910111213141516171819202122232425262728293031323334353637import java.io.BufferedReader;import java.io.FileReader;public final class MyUtil &#123; // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯) private MyUtil() &#123; throw new AssertionError(); &#125; /** * 统计给定文件中给定字符串的出现次数 * * @param filename 文件名 * @param word 字符串 * @return 字符串在文件中出现的次数 */ public static int countWordInFile(String filename, String word) &#123; int counter = 0; try (FileReader fr = new FileReader(filename)) &#123; try (BufferedReader br = new BufferedReader(fr)) &#123; String line = null; while ((line = br.readLine()) != null) &#123; int index = -1; while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) &#123; counter++; line = line.substring(index + word.length()); &#125; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return counter; &#125;&#125; 71、如何用 Java 代码列出一个目录下所有的文件？ 答： 如果只要求列出当前文件夹下的文件，代码如下所示： 12345678910111213import java.io.File;class Test12 &#123; public static void main(String[] args) &#123; File f = new File(&quot;/Users/nnngu/Downloads&quot;); for(File temp : f.listFiles()) &#123; if(temp.isFile()) &#123; System.out.println(temp.getName()); &#125; &#125; &#125;&#125; 如果需要对文件夹继续展开，代码如下所示： 1234567891011121314151617181920212223242526import java.io.File;class Test12 &#123; public static void main(String[] args) &#123; showDirectory(new File(&quot;/Users/nnngu/Downloads&quot;)); &#125; public static void showDirectory(File f) &#123; _walkDirectory(f, 0); &#125; private static void _walkDirectory(File f, int level) &#123; if(f.isDirectory()) &#123; for(File temp : f.listFiles()) &#123; _walkDirectory(temp, level + 1); &#125; &#125; else &#123; for(int i = 0; i &lt; level - 1; i++) &#123; System.out.print(&quot;\t&quot;); &#125; System.out.println(f.getName()); &#125; &#125;&#125; 在 Java 7 中可以使用 NIO.2 的 API 来做同样的事情，代码如下所示： 12345678910111213141516class ShowFileTest &#123; public static void main(String[] args) throws IOException &#123; Path initPath = Paths.get(&quot;/Users/nnngu/Downloads&quot;); Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println(file.getFileName().toString()); return FileVisitResult.CONTINUE; &#125; &#125;); &#125;&#125; 72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。 答： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class EchoServer &#123; private static final int ECHO_SERVER_PORT = 6789; public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) &#123; System.out.println(&quot;服务器已经启动...&quot;); while(true) &#123; Socket client = server.accept(); new Thread(new ClientHandler(client)).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private static class ClientHandler implements Runnable &#123; private Socket client; public ClientHandler(Socket client) &#123; this.client = client; &#125; @Override public void run() &#123; try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter pw = new PrintWriter(client.getOutputStream())) &#123; String msg = br.readLine(); System.out.println(&quot;收到&quot; + client.getInetAddress() + &quot;发送的: &quot; + msg); pw.println(msg); pw.flush(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意：上面的代码使用了 Java 7 的 TWR 语法，由于很多外部资源类都间接的实现了 AutoCloseable 接口（单方法回调接口），因此可以利用 TWR 语法在 try 结束的时候通过回调的方式自动调用外部资源类的 close() 方法，避免书写冗长的 finally 代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户 I/O 操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。 下面是一段回显客户端测试代码： 12345678910111213141516171819202122import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class EchoClient &#123; public static void main(String[] args) throws Exception &#123; Socket client = new Socket(&quot;localhost&quot;, 6789); Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入内容: &quot;); String msg = sc.nextLine(); sc.close(); PrintWriter pw = new PrintWriter(client.getOutputStream()); pw.println(msg); pw.flush(); BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println(br.readLine()); client.close(); &#125;&#125; 如果希望用 NIO 的多路复用套接字实现服务器，代码如下所示。NIO 的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;public class EchoServerNIO &#123; private static final int ECHO_SERVER_PORT = 6789; private static final int ECHO_SERVER_TIMEOUT = 5000; private static final int BUFFER_SIZE = 1024; private static ServerSocketChannel serverChannel = null; private static Selector selector = null; // 多路复用选择器 private static ByteBuffer buffer = null; // 缓冲区 public static void main(String[] args) &#123; init(); listen(); &#125; private static void init() &#123; try &#123; serverChannel = ServerSocketChannel.open(); buffer = ByteBuffer.allocate(BUFFER_SIZE); serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT)); serverChannel.configureBlocking(false); selector = Selector.open(); serverChannel.register(selector, SelectionKey.OP_ACCEPT); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private static void listen() &#123; while (true) &#123; try &#123; if (selector.select(ECHO_SERVER_TIMEOUT) != 0) &#123; Iterator&lt;SelectionKeyit = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); it.remove(); handleKey(key); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void handleKey(SelectionKey key) throws IOException &#123; SocketChannel channel = null; try &#123; if (key.isAcceptable()) &#123; ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel(); channel = serverChannel.accept(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; channel = (SocketChannel) key.channel(); buffer.clear(); if (channel.read(buffer) 0) &#123; buffer.flip(); CharBuffer charBuffer = CharsetHelper.decode(buffer); String msg = charBuffer.toString(); System.out.println(&quot;收到&quot; + channel.getRemoteAddress() + &quot;的消息：&quot; + msg); channel.write(CharsetHelper.encode(CharBuffer.wrap(msg))); &#125; else &#123; channel.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if (channel != null) &#123; channel.close(); &#125; &#125; &#125;&#125;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.charset.CharacterCodingException;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.charset.CharsetEncoder;public final class CharsetHelper &#123; private static final String UTF_8 = &quot;UTF-8&quot;; private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder(); private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder(); private CharsetHelper() &#123; &#125; public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException&#123; return encoder.encode(in); &#125; public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException&#123; return decoder.decode(in); &#125;&#125; 73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？ 答：XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束，其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。对 XML 的解析主要有 DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和 StAX（Java 6 中引入的新的解析 XML 的方式，Streaming API for XML），其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构占用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）；SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问；顾名思义，StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程序能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新颖（SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 74、你在项目中哪些地方用到了 XML？ 答：XML 的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML 将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从 XML 文件中还原相关信息进行处理，XML 曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被 JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用 XML 来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在 XML 文件中，Java 的很多框架也是这么做的，而且这些框架都选择了 dom4j 作为处理 XML 的工具，因为 Sun 公司的官方 API 实在不怎么好用。 补充：现在有很多时髦的软件（如 Sublime）已经开始将配置文件书写成 JSON 格式，我们已经强烈的感受到 XML 的另一项功能也将逐渐被业界抛弃。 75、阐述 JDBC 操作数据库的步骤。 答：下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。 123456789101112131415161718192021222324252627282930加载驱动。Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);创建连接。Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;, &quot;scott&quot;, &quot;tiger&quot;);创建语句。PreparedStatement ps = con.prepareStatement(&quot;select * from emp where sal between ? and ?&quot;);ps.setInt(1, 1000);ps.setInt(2, 3000);执行语句。ResultSet rs = ps.executeQuery();处理结果。while(rs.next()) &#123; System.out.println(rs.getInt(&quot;empno&quot;) + &quot; - &quot; + rs.getString(&quot;ename&quot;));&#125;关闭资源。 finally &#123; if(con != null) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。 76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？ 答：与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；③当批量处理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的 SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。 补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。 77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ 答：要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize() 方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。 78、在进行数据库编程时，连接池有什么作用？ 答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在 Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。 补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。 79、什么是 DAO 模式？ 答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 Data Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。 80、事务的 ACID 是指什么？ 答： 原子性 (Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； 一致性 (Consistent)：事务结束后系统状态是一致的； 隔离性 (Isolated)：并发执行的事务彼此无法看到对方的中间状态； 持久性 (Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类丢失更新）。 脏读（Dirty Read）：A 事务读取 B 事务尚未提交的数据并在此基础上操作，而 B 事务执行回滚，那么 A 读取到的数据就是脏数据。 不可重复读（Unrepeatable Read）：事务 A 重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务 B 修改过了。 幻读（Phantom Read）：事务 A 重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务 B 提交的行。 第 1 类丢失更新：事务 A 撤销时，把已经提交的事务 B 的更新数据覆盖了。 第 2 类丢失更新：事务 A 覆盖事务 B 已经提交的数据，造成事务 B 所做的操作丢失。 数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。 直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析 SQL 语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示： 隔离级别 脏读 不可重复读 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED 允许 允许 允许 不允许 允许 READCOMMITTED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZABLE 不允许 不允许 不允许 不允许 不允许 需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。 81、JDBC 中如何进行事务处理？ 答：Connection 提供了事务处理的方法，通过调用 setAutoCommit(false) 可以设置手动提交事务；当事务完成后用 commit() 显式提交事务；如果在事务处理过程中发生异常则通过 rollback() 进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。 82、JDBC 能否处理 Blob 和 Clob？ 答： Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Objec），因此其中 Blob 是为存储大的二进制数据而设计的，而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和 ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。下面的代码展示了如何使用 JDBC 操作 LOB： 下面以 MySQL 数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下： 123456create table tb_user(id int primary key auto_increment,name varchar(20) unique not null,photo longblob); 下面的 Java 代码向数据库中插入一条记录： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;class JdbcLobTest &#123; public static void main(String[] args) &#123; Connection con = null; try &#123; // 1\. 加载驱动（Java6以上版本可以省略） Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2\. 建立连接 con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;); // 3\. 创建语句对象 PreparedStatement ps = con.prepareStatement(&quot;insert into tb_user values (default, ?, ?)&quot;); ps.setString(1, &quot;郭靖&quot;); // 将SQL语句中第一个占位符换成字符串 try (InputStream in = new FileInputStream(&quot;test.jpg&quot;)) &#123; // Java 7的TWR ps.setBinaryStream(2, in); // 将SQL语句中第二个占位符换成二进制流 // 4\. 发出SQL语句获得受影响行数 System.out.println(ps.executeUpdate() == 1 ? &quot;插入成功&quot; : &quot;插入失败&quot;); &#125; catch(IOException e) &#123; System.out.println(&quot;读取照片失败!&quot;); &#125; &#125; catch (ClassNotFoundException | SQLException e) &#123; // Java 7的多异常捕获 e.printStackTrace(); &#125; finally &#123; // 释放外部资源的代码都应当放在finally中保证其能够得到执行 try &#123; if(con != null &amp;&amp; !con.isClosed()) &#123; con.close(); // 5\. 释放数据库连接 con = null; // 指示垃圾回收器可以回收该对象 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 83、简述正则表达式及其用途。 答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。 84、Java 中是如何支持正则表达式操作的？ 答：Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作，请参考下面面试题的代码。 面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市 (朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？ 1234567891011121314import java.util.regex.Matcher;import java.util.regex.Pattern;class RegExpTest &#123; public static void main(String[] args) &#123; String str = &quot;北京市(朝阳区)(西城区)(海淀区)&quot;; Pattern p = Pattern.compile(&quot;.*?(?=\\()&quot;); Matcher m = p.matcher(str); if(m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125; 说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式 30 分钟入门教程》。 85、获得一个类的类对象有哪些方式？ 答： 方法 1：类型. class，例如：String.class 方法 2：对象. getClass()，例如：”hello”.getClass() 方法 3：Class.forName()，例如：Class.forName(“java.lang.String”) 86、如何通过反射创建对象？ 答： 方法 1：通过类对象调用 newInstance() 方法，例如：String.class.newInstance() 方法 2：通过类对象的 getConstructor() 或 getDeclaredConstructor() 方法获得构造器（Constructor）对象并调用其 newInstance() 方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 87、如何通过反射获取和设置对象私有字段的值？ 答：可以通过类对象的 getDeclaredField() 方法获得字段（Field）对象，然后再通过字段对象的 setAccessible(true) 将其设置为可以访问，接下来就可以通过 get/set 方法来获取 / 设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如 ReflectionUtil.get(dog, “owner.car.engine.id”); 可以获得 dog 对象的主人的汽车的引擎的 ID 号。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.List;/** * 反射工具类 * @author nnngu * */public class ReflectionUtil &#123; private ReflectionUtil() &#123; throw new AssertionError(); &#125; /** * 通过反射取对象指定字段(属性)的值 * @param target 目标对象 * @param fieldName 字段的名字 * @throws 如果取不到对象指定字段的值则抛出异常 * @return 字段的值 */ public static Object getValue(Object target, String fieldName) &#123; Class&lt;?clazz = target.getClass(); String[] fs = fieldName.split(&quot;\\.&quot;); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); target = f.get(target); clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); return f.get(target); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 通过反射给对象的指定字段赋值 * @param target 目标对象 * @param fieldName 字段的名称 * @param value 值 */ public static void setValue(Object target, String fieldName, Object value) &#123; Class&lt;?clazz = target.getClass(); String[] fs = fieldName.split(&quot;\\.&quot;); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); Object val = f.get(target); if(val == null) &#123; Constructor&lt;?c = f.getType().getDeclaredConstructor(); c.setAccessible(true); val = c.newInstance(); f.set(target, val); &#125; target = val; clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); f.set(target, value); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 88、如何通过反射调用对象的方法？ 答：请看下面的代码： 12345678910import java.lang.reflect.Method;class MethodInvokeTest &#123; public static void main(String[] args) throws Exception &#123; String str = &quot;hello&quot;; Method m = str.getClass().getMethod(&quot;toUpperCase&quot;); System.out.println(m.invoke(str)); // HELLO &#125;&#125; 89、简述一下面向对象的 “六原则一法则”。 答： 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是 “高内聚”，写代码最终极的原则只有六个字 “高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字 “欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫 “因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而混乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。） 里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到 “低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。） 90、简述一下你了解的设计模式。 答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 在 GoF 的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型 [对类的实例化过程的抽象化]、结构型 [描述如何将类或对象结合在一起形成更大的结构]、行为型 [对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。 面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。 除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections 工具类和 I/O 系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 91、用 Java 写一个单例类。 答： 饿汉式单例 1234567public class Singleton &#123; private Singleton()&#123;&#125; private static Singleton instance = new Singleton(); public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉式单例 12345678public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123;&#125; public static synchronized Singleton getInstance()&#123; if (instance == null) instance ＝ new Singleton(); return instance; &#125;&#125; 注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring 的 IoC 容器可以为普通的类创建单例，它是怎么做到的呢？ 92、什么是 UML？ 答：UML 是统一建模语言（Unified Modeling Language）的缩写，它发表于 1997 年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用 UML 可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。 93、UML 中有哪些常用的图？ 答：UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。 用例图： 类图： 时序图： 94、用 Java 写一个冒泡排序。 答：冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Comparator;/** * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换) * @author nnngu * */public interface Sorter &#123; /** * 排序 * @param list 待排序的数组 */ public &lt;T extends Comparable&lt;T&gt;void sort(T[] list); /** * 排序 * @param list 待排序的数组 * @param comp 比较两个对象的比较器 */ public &lt;Tvoid sort(T[] list, Comparator&lt;Tcomp);&#125;import java.util.Comparator;/** * 冒泡排序 * * @author nnngu * */public class BubbleSorter implements Sorter &#123; @Override public &lt;T extends Comparable&lt;T&gt;void sort(T[] list) &#123; boolean swapped = true; for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123; swapped = false; for (int j = 0; j &lt; len - i; ++j) &#123; if (list[j].compareTo(list[j + 1]) 0) &#123; T temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; swapped = true; &#125; &#125; &#125; &#125; @Override public &lt;Tvoid sort(T[] list, Comparator&lt;Tcomp) &#123; boolean swapped = true; for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123; swapped = false; for (int j = 0; j &lt; len - i; ++j) &#123; if (comp.compare(list[j], list[j + 1]) 0) &#123; T temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; swapped = true; &#125; &#125; &#125; &#125;&#125; 95、用 Java 写一个折半查找。 答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是 O(logN)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Comparator;public class MyUtil &#123; public static &lt;T extends Comparable&lt;T&gt;int binarySearch(T[] x, T key) &#123; return binarySearch(x, 0, x.length- 1, key); &#125; // 使用循环实现的二分查找 public static &lt;Tint binarySearch(T[] x, T key, Comparator&lt;Tcomp) &#123; int low = 0; int high = x.length - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;1; int cmp = comp.compare(x[mid], key); if (cmp &lt; 0) &#123; low= mid + 1; &#125; else if (cmp 0) &#123; high= mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1; &#125; // 使用递归实现的二分查找 private static&lt;T extends Comparable&lt;T&gt;int binarySearch(T[] x, int low, int high, T key) &#123; if(low &lt;= high) &#123; int mid = low + ((high - low) &gt;1); if(key.compareTo(x[mid])== 0) &#123; return mid; &#125; else if(key.compareTo(x[mid])&lt; 0) &#123; return binarySearch(x,low, mid - 1, key); &#125; else &#123; return binarySearch(x,mid + 1, high, key); &#125; &#125; return -1; &#125;&#125; 说明：上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用 (high+ low) / 2 的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high - low) / 2 或 low + (high – low) &gt;1 或(low + high) &gt;&gt;1（&gt;&gt;&gt; 是逻辑右移，是不带符号位的右移） 转载自：https://www.imooc.com/u/6457959/articles 本文永久更新地址：github.com/nnngu/Learn… 感谢整理者：nnngu]]></content>
      <tags>
        <tag>面试</tag>
        <tag>待阅</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 知识点总结69题+25题]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-1%2F</url>
    <content type="text"><![CDATA[Spring 知识点总结69题1. 什么是 Spring？ Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。 2.Spring 有哪些优点？ 轻量级：Spring 在大小和透明性方面绝对属于轻量级的，基础版本的 Spring 框架大约只有 2MB。 控制反转 (IOC)：Spring 使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。 面向切面编程 (AOP)： Spring 支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。 容器：Spring 包含并管理应用程序对象的配置及生命周期。 MVC 框架：Spring 的 web 框架是一个设计优良的 web MVC 框架，很好的取代了一些 web 框架。 事务管理：Spring 对下至本地业务上至全局业务 (JAT) 提供了统一的事务管理接口。 异常处理：Spring 提供一个方便的 API 将特定技术的异常 (由 JDBC, Hibernate, 或 JDO 抛出) 转化为一致的、Unchecked 异常。 3.Spring 框架有哪些模块？ Spring 框架的基本模块如下所示： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaction module Web module Web-Servlet module Web-Struts module Web-Portlet module 4. 解释核心容器 (应用上下文) 模块 这是 Spring 的基本模块，它提供了 Spring 框架的基本功能。BeanFactory 是所有 Spring 应用的核心。Spring 框架是建立在这个模块之上的，这也使得 Spring 成为一个容器。 5.BeanFactory – BeanFactory 实例 BeanFactory 是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。 最常用的 BeanFactory 实现是 XmlBeanFactory 类。 6.XmlBeanFactory 最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory，它根据 XML 文件中定义的内容加载 beans。该容器从 XML 文件中读取配置元数据，并用它来创建一个完备的系统或应用。 7. 解释 AOP 模块 AOP 模块用来开发 Spring 应用程序中具有切面性质的部分。该模块的大部分服务由 AOP Aliance 提供，这就保证了 Spring 框架和其他 AOP 框架之间的互操作性。另外，该模块将元数据编程引入到了 Spring。 8. 解释抽象 JDBC 和 DAO 模块 通过使用抽象 JDBC 和 DAO 模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用 Spring 的 AOP 模块为 Spring 应用程序中的对象提供事务管理服务。 9. 解释对象 / 关系映射集成模块 Spring 通过提供 ORM 模块在 JDBC 的基础上支持对象关系映射工具。这样的支持使得 Spring 可以集成主流的 ORM 框架，包括 Hibernate, JDO, 及 iBATIS SQL Maps。Spring 的事务管理可以同时支持以上某种框架和 JDBC。 10. 解释 web 模块 Spring 的 web 模块建立在应用上下文 (application context) 模块之上，提供了一个适合基于 web 应用程序的上下文环境。该模块还支持了几个面向 web 的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。 11. 解释 Spring MVC 模块 Spring 提供 MVC 框架构建 web 应用程序。Spring 可以很轻松的同其他 MVC 框架结合，但 Spring 的 MVC 是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。 12.Spring 的配置文件 Spring 的配置文件是一个 XML 文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。 13.Spring IoC 容器是什么？ Spring IOC 负责创建对象、管理对象 (通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。 14.IOC 有什么优点？ IOC 或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或 JNDI 查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC 容器支持勤性单例及延迟加载服务。 15. 应用上下文是如何实现的？ FileSystemXmlApplicationContext 容器加载 XML 文件中 beans 的定义。XML Bean 配置文件的完整路径必须传递给构造器。 FileSystemXmlApplicationContext 容器也加载 XML 文件中 beans 的定义。注意，你需要正确的设置 CLASSPATH，因为该容器会在 CLASSPATH 中查看 bean 的 XML 配置文件。 WebXmlApplicationContext：该容器加载 xml 文件，这些文件定义了 web 应用中所有的 beans。 16.Bean Factory 和 ApplicationContext 有什么区别？ ApplicationContext 提供了一种解决文档信息的方法，一种加载文件资源的方式 (如图片)，他们可以向监听他们的 beans 发送消息。另外，容器或者容器中 beans 的操作，这些必须以 bean 工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了 MessageSource，该接口用于获取本地消息，实际的实现是可选的。 17.Spring 应用程序看起来像什么？ 一个定义功能的接口 实现包括属性，setter 和 getter 方法，功能等 Spring AOP Spring 的 XML 配置文件 使用该功能的客户端编程 依赖注入 18.Spring 中的依赖注入是什么？ 依赖注入作为控制反转 (IOC) 的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后 IOC 容器负责衔接。 19. 有哪些不同类型的 IOC(依赖注入)？ 构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。 Setter 方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用 bean 中的 setter 方法完成 Setter 方法依赖注入。 20. 你推荐哪种依赖注入？构造器依赖注入还是 Setter 方法依赖注入？ 你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用 setter 方法实现可选的依赖关系。 Spring Beans 21. 什么是 Spring Beans？ Spring Beans 是构成 Spring 应用核心的 Java 对象。这些对象由 Spring IOC 容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用 XML 文件中定义的 创建。 在 Spring 中创建的 beans 都是单例的 beans。在 bean 标签中有一个属性为”singleton”, 如果设为 true，该 bean 是单例的，如果设为 false，该 bean 是原型 bean。Singleton 属性默认设置为 true。因此，spring 框架中所有的 bean 都默认为单例 bean。 22.Spring Bean 中定义了什么内容？ Spring Bean 中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。 23. 如何向 Spring 容器提供配置元数据？ 有三种方式向 Spring 容器提供元数据: XML 配置文件 基于注解配置 基于 Java 的配置 24. 你如何定义 bean 的作用域？ 在 Spring 中创建一个 bean 的时候，我们可以声明它的作用域。只需要在 bean 定义的时候通过’scope’属性定义即可。例如，当 Spring 需要产生每次一个新的 bean 实例时，应该声明 bean 的 scope 属性为 prototype。如果每次你希望 Spring 返回一个实例，应该声明 bean 的 scope 属性为 singleton。 25. 说一下 Spring 中支持的 bean 作用域 Spring 框架支持如下五种不同的作用域： singleton：在 Spring IOC 容器中仅存在一个 Bean 实例，Bean 以单实例的方式存在。 prototype：一个 bean 可以定义多个实例。 request：每次 HTTP 请求都会创建一个新的 Bean。该作用域仅适用于 WebApplicationContext 环境。 session：一个 HTTP Session 定义一个 Bean。该作用域仅适用于 WebApplicationContext 环境. globalSession：同一个全局 HTTP Session 定义一个 Bean。该作用域同样仅适用于 WebApplicationContext 环境. bean 默认的 scope 属性是’singleton‘。 26.Spring 框架中单例 beans 是线程安全的吗？ 不是，Spring 框架中的单例 beans 不是线程安全的。 27. 解释 Spring 框架中 bean 的生命周期 Spring 容器读取 XML 文件中 bean 的定义并实例化 bean。 Spring 根据 bean 的定义设置属性值。 如果该 Bean 实现了 BeanNameAware 接口，Spring 将 bean 的 id 传递给 setBeanName() 方法。 如果该 Bean 实现了 BeanFactoryAware 接口，Spring 将 beanfactory 传递给 setBeanFactory() 方法。 如果任何 bean BeanPostProcessors 和该 bean 相关，Spring 调用 postProcessBeforeInitialization() 方法。 如果该 Bean 实现了 InitializingBean 接口，调用 Bean 中的 afterPropertiesSet 方法。如果 bean 有初始化函数声明，调用相应的初始化方法。 如果任何 bean BeanPostProcessors 和该 bean 相关，调用 postProcessAfterInitialization() 方法。 如果该 bean 实现了 DisposableBean，调用 destroy() 方法。 28. 哪些是最重要的 bean 生命周期方法？能重写它们吗？ 有两个重要的 bean 生命周期方法。第一个是 setup 方法，该方法在容器加载 bean 的时候被调用。第二个是 teardown 方法，该方法在 bean 从容器中移除的时候调用。 bean 标签有两个重要的属性 (init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring 也有相应的注解：@PostConstruct 和 @PreDestroy。 29. 什么是 Spring 的内部 bean？ 当一个 bean 被用作另一个 bean 的属性时，这个 bean 可以被声明为内部 bean。在基于 XML 的配置元数据中，可以通过把 元素定义在 或 &lt; constrtucor-arg &gt; 元素内部实现定义内部 bean。内部 bean 总是匿名的并且它们的 scope 总是 prototype。 30. 如何在 Spring 中注入 Java 集合类？ Spring 提供如下几种类型的集合配置元素： list 元素用来注入一系列的值，允许有相同的值。 set 元素用来注入一些列的值，不允许有相同的值。 map 用来注入一组” 键 - 值” 对，键、值可以是任何类型的。 props 也可以用来注入一组” 键 - 值” 对，这里的键、值都字符串类型。 31. 什么是 bean wiring？ Wiring，或者说 bean Wiring 是指 beans 在 Spring 容器中结合在一起的情况。当装配 bean 的时候，Spring 容器需要知道需要哪些 beans 以及如何使用依赖注入将它们结合起来。 32. 什么是 bean 自动装配？ Spring 容器可以自动配置相互协作 beans 之间的关联关系。这意味着 Spring 可以自动配置一个 bean 和其他协作 bean 之间的关系，通过检查 BeanFactory 的内容里没有使用 和 &lt; property &gt; 元素。 33. 解释自动装配的各种模式？ 自动装配提供五种不同的模式供 Spring 容器用来自动装配 beans 之间的依赖注入: no：默认的方式是不进行自动装配，通过手工设置 ref 属性来进行装配 bean。 byName：通过参数名自动装配，Spring 容器查找 beans 的属性，这些 beans 在 XML 配置文件中被设置为 byName。之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。 byType：通过参数的数据类型自动自动装配，Spring 容器查找 beans 的属性，这些 beans 在 XML 配置文件中被设置为 byType。之后容器试图匹配和装配和该 bean 的属性类型一样的 bean。如果有多个 bean 符合条件，则抛出错误。 constructor：这个同 byType 类似，不过是应用于构造函数的参数。如果在 BeanFactory 中不是恰好有一个 bean 与构造函数参数相同类型，则抛出一个严重的错误。 autodetect：如果有默认的构造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。 34. 自动装配有哪些局限性？ 自动装配有如下局限性： 重写：你仍然需要使用 和 &lt; property &gt; 设置指明依赖，这意味着总要重写自动装配。 原生数据类型: 你不能自动装配简单的属性，如原生类型、字符串和类。 模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。 35. 你可以在 Spring 中注入 null 或空字符串吗？ 完全可以。 Spring 注解 36. 什么是 Spring 基于 Java 的配置？给出一些注解的例子 基于 Java 的配置允许你使用 Java 的注解进行 Spring 的大部分配置而非通过传统的 XML 文件配置。 以注解 @Configuration 为例，它用来标记类，说明作为 beans 的定义，可以被 Spring IOC 容器使用。另一个例子是 @Bean 注解，它表示该方法定义的 Bean 要被注册进 Spring 应用上下文中。 37. 什么是基于注解的容器配置? 另外一种替代 XML 配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用 XML 描述 bean 之间的连线关系。 38. 如何开启注解装配？ 注解装配默认情况下在 Spring 容器中是不开启的。如果想要开启基于注解的装配只需在 Spring 配置文件中配置 context:annotation-config 元素即可。&lt;/context:annotation-config&gt; 39.@Required 注解 @Required 表明 bean 的属性必须在配置时设置，可以在 bean 的定义中明确指定也可通过自动装配设置。如果 bean 的属性未设置，则抛出 BeanInitializationException 异常。 40.@Autowired 注解 @Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像 @Required 一样自动装配 setter 方法、构造器、属性或者具有任意名称和 / 或多个参数的 PN 方法。 41. @Qualifier 注解 当有多个相同类型的 bean 而只有其中的一个需要自动装配时，将 @Qualifier 注解和 @Autowire 注解结合使用消除这种混淆，指明需要装配的 bean。 Spring 数据访问 42. 在 Spring 框架中如何更有效的使用 JDBC？ 使用 Spring JDBC 框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过 statements 和 queries 语句从数据库中存取数据。Spring 框架中通过使用模板类能更有效的使用 JDBC，也就是所谓的 JdbcTemplate(例子)。 43.JdbcTemplate JdbcTemplate 类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。 44.Spring 对 DAO 的支持 Spring 对数据访问对象 (DAO) 的支持旨在使它可以与数据访问技术 (如 JDBC, Hibernate 及 JDO) 方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。 45. 使用 Spring 可以通过什么方式访问 Hibernate？ 使用 Spring 有两种方式访问 Hibernate： 使用 Hibernate Template 的反转控制以及回调方法 继承 HibernateDAOSupport，并申请一个 AOP 拦截器节点 46.Spring 支持的 ORM Spring 支持一下 ORM： Hibernate iBatis JPA (Java -Persistence API) TopLink JDO (Java Data Objects) OJB 47. 如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？ 使用 Spring 的 SessionFactory 调用 LocalSessionFactory。结合过程分为以下三步： 配置 Hibernate SessionFactory 继承 HibernateDaoSupport 实现一个 DAO 使用 AOP 装载事务支持 48.Spring 支持的事务管理类型 Spring 支持如下两种方式的事务管理： 编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。 声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者 XML 配置管理事务。 49.Spring 框架的事务管理有哪些优点？ 它为不同的事务 API(如 JTA, JDBC, Hibernate, JPA, 和 JDO) 提供了统一的编程模型。 它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API(如 JTA). 它支持声明式事务管理。 它可以和 Spring 的多种数据访问技术很好的融合。 50. 你更推荐那种类型的事务管理？ 许多 Spring 框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理 (这种方式允许你通过代码控制业务)。 Spring 面向切面编程 (AOP) 51. 解释 AOP 面向切面编程, 或 AOP 允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。 52. 切面 (Aspect) AOP 的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组 API 提供 cross-cutting 功能。例如, 日志模块称为日志的 AOP 切面。根据需求的不同，一个应用程序可以有若干切面。在 Spring AOP 中，切面通过带有 @Aspect 注解的类实现。 53. 在 Spring AOP 中 concern 和 cross-cutting concern 的区别是什么？ Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern 可以定义为我们想要实现的功能。 Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于 Cross-cutting concern。 54. 连接点 (Join point) 连接点代表应用程序中插入 AOP 切面的地点。它实际上是 Spring AOP 框架在应用程序中执行动作的地点。 55. 通知 (Advice) 通知表示在方法执行前后需要执行的动作。实际上它是 Spring AOP 框架在程序执行过程中触发的一些代码。 Spring 切面可以执行一下五种类型的通知: before(前置通知)：在一个方法之前执行的通知。 after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 after-returning(后置通知)：在某连接点正常完成后执行的通知。 after-throwing(异常通知)：在方法抛出异常退出时执行的通知。 around(环绕通知)：在方法调用前后触发的通知。 56. 切入点 (Pointcut) 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。 57. 什么是引入？ 引入允许我们在已有的类上添加新的方法或属性。 58. 什么是目标对象？ 被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。 59. 什么是代理？ 代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 60. 有几种不同类型的自动代理？ BeanNameAutoProxyCreator：bean 名称自动代理创建器 DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器 Metadata autoproxying：元数据自动代理 61. 什么是织入？什么是织入应用的不同点？ 织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。 62. 解释基于 XML Schema 方式的切面实现 在这种情况下，切面由使用 XML 文件配置的类实现。 63. 解释基于注解方式 (基于 @AspectJ) 的切面实现 在这种情况下 (基于 @AspectJ 的实现)，指的是切面的对应的类使用 Java 5 注解的声明方式。 Spring 的 MVC 框架 64. 什么是 Spring 的 MVC 框架？ Spring 提供了一个功能齐全的 MVC 框架用于构建 Web 应用程序。Spring 框架可以很容易的和其他的 MVC 框架融合 (如 Struts)，该框架使用控制反转(IOC) 将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。 65.DispatcherServlet Spring 的 MVC 框架围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。 66.WebApplicationContext WebApplicationContext 继承了 ApplicationContext，并添加了一些 web 应用程序需要的功能。和普通的 ApplicationContext 不同，WebApplicationContext 可以用来处理主题样式，它也知道如何找到相应的 servlet。 67. 什么是 Spring MVC 框架的控制器？ 控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。 68.@Controller annotation @Controller 注解表示该类扮演控制器的角色。Spring 不需要继承任何控制器基类或应用 Servlet API。 69.@RequestMapping annotation @RequestMapping 注解用于将 URL 映射到任何一个类或者一个特定的处理方法上。 原文链接： javacodegeeks 翻译： ImportNew.com - 人晓译文链接： http://www.importnew.com/11657.html spring面试总结25题1、什么是 spring 框架？Spring 框架有哪些主要模块？ Spring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。Spring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。 Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成,、Web、 AOP（面向切面编程）、工具、消息和测试模块。 2、使用 Spring 框架能带来哪些好处？下面列举了一些使用 Spring 框架带来的主要好处： Dependency Injection(DI) 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。 与 EJB 容器相比较，IoC 容器更加趋向于轻量级。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下进行应用程序的开发和发布就变得十分有利。 Spring 并没有闭门造车, Spring 利用了已有的技术如 ORM 框架 logging 框架、J2EE、Quartz 和 JDK Timer, 以及其他视图技术. Spring 框架是按照模块的形式来组织的. 由包和类的编号就可以看出其所属的模块, 开发者仅仅需要选用他们需要的模块即可。 要测试一项用 Spring 开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。 Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 web 框架的选择上提供了一个除了主流框架 比如 Struts、过度设计的、不流行 web 框架的以外的有力选项。 Spring 提供了一个便捷的事务管理接口，适用于小型的本地事物处理 (比如在单 DB 的环境下) 和复杂的共同事物处理 (比如利用 JTA 的复杂 DB 环境)。 3、什么是控制反转 (IOC)? 什么是依赖注入?控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常 是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的 情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联 关系的定义抽象化。而绑定的过程是通过 “依赖注入” 实现的。 控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。 这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的 情况下，框架又怎么知道要创建哪个组件？ 在 Java 中依然注入有以下三种实现方式： 构造器注入 Setter 方法注入 接口注入 4、请解释下 Spring 框架中的 IoC?Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了 Spring 框架 IoC 容器的基础。 BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对 BeanFactory(是一个子接口) 进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成， 也提供了处理 message resource 的机制 (用于国际化)、事件传播以及应用层的特别配置， 比如针对 Web 应用的 WebApplicationContext。 org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。 BeanFactory 接口是 Spring IoC 容器的核心接口。 5、BeanFactory 和 ApplicationContext 有什么区别?BeanFactory 可以理解为含有 bean 集合的工厂类. BeanFactory 包含了种 bean 的定义, 以便在接收到客户端请求时将对应的 bean 实例化. BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。 BeanFactory 还包含了 bean 生命周期的控制, 调用客户端的初始化方法 (initialization methods) 和销毁方法(destruction methods)。 从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。 但 application context 在此基础上还提供了其他的功能。 1、提供了支持国际化的文本消息 2、统一的资源文件读取方式 3、已在监听器中注册的 bean 的事件 以下是三种较常见的 ApplicationContext 实现方式： 1、ClassPathXmlApplicationContext: 从 classpath 的 XML 配置文件中读取上下文, 并生成上下文定义. 应用程序上下文从程序环境变量中取得. 1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); 2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。 1ApplicationContext context = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;); 3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。 6、Spring 有几种配置方式?将 Spring 配置到应用开发中有以下三种方式： 1、基于 XML 的配置 2、基于注解的配置 3、基于 Java 的配置 7、如何用基于 XML 配置的方式配置 Spring?在 Spring 框架中，依赖和服务需要在专门的配置文件来实现，我常用的 XML 格式的配置文件。 这些配置文件的格式通常用开头，然后一系列的 bean 定义和专门的应用配置选项组成。 SpringXML 配置的主要目的时候是使所有的 Spring 组件都可以用 xml 文件的形式来进行配置。 这意味着不会出现其他的 Spring 配置类型 (比如声明的方式或基于 Java Class 的配置方式) Spring 的 XML 配置方式是使用被 Spring 命名空间的所支持的一系列的 XML 标签来实现的。 Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。 1234567&lt;beans&gt; &lt;!-- JSON Support --&gt; &lt;bean /&gt; &lt;bean /&gt; &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;&lt;/beans&gt; 下面这个 web.xml 仅仅配置了 DispatcherServlet, 这件最简单的配置便能满足应用程序配置运行时组件的需求。 123456789101112131415&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 8、如何用基于 Java 配置的方式配置 Spring?Spring 对 Java 配置的支持是由 @Configuration 注解和 @Bean 注解来实现的。由 @Bean 注解的方法将会实例化、 配置和初始化一个新对象，这个对象将由 Spring 的 IoC 容器来管理。@Bean 声明所起到的作用与 元素类似。 被 @Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被 @Configuration 声明的类可以 通过在同一个类的内部调用 @bean 方法来设置嵌入 bean 的依赖关系。 最简单的 @Configuration 声明类请参考下面的代码： 1234567@Configurationpublic class AppConfig&#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 对于上面的 @Beans 配置文件相同的 XML 配置文件如下： 123&lt;beans&gt; &lt;bean id=&quot;myService&quot; class=&quot;com.howtodoinjava.services.MyServiceImpl&quot;/&gt;&lt;/beans&gt; 上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化 12345public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff();&#125; 要使用组件组建扫描，仅需用 @Configuration 进行注解即可: 12345@Configuration@ComponentScan(basePackages = &quot;com.howtodoinjava&quot;)public class AppConfig &#123; ...&#125; 在上面的例子中，com.acme 包首先会被扫到，然后再容器内查找被 @Component 声明的类， 找到后将这些类按照 Sring bean 定义进行注册。 如果你要在你的 web 应用开发中选用上述的配置的方式的话, 需要用 AnnotationConfigWebApplicationContext 类来读取配置文件， 可以用来配置 Spring 的 Servlet 监听器 ContrextLoaderListener 或者 Spring MVC 的 DispatcherServlet。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;web-app&gt; &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext instead of the default XmlWebApplicationContext --&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Configuration locations must consist of one or more comma- or space-delimited fully-qualified @Configuration classes. Fully-qualified packages may also be specified for component-scanning --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.howtodoinjava.AppConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext instead of the default XmlWebApplicationContext --&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- Again, config locations must consist of one or more comma- or space-delimited and fully-qualified @Configuration classes --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.howtodoinjava.web.MvcConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 9、怎样用注解的方式配置 Spring？Spring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML 方式的 bean 描述， 可以将 bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。 注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。 注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。 如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 123456&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- bean definitions go here --&gt;&lt;/beans&gt; 在 context:annotation-config/ 标签配置完成以后, 就可以用注解的方式在 Spring 中向属性、方法和构造方法中自动装配变量。 下面是几种比较重要的注解类型： 1、@Required：该注解应用于设值方法。 2、@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 3、@Qualifier：该注解和 @Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。 4、JSR-250 Annotations：Spring 支持基于 JSR-250 注解的以下注解,@Resource、@PostConstruct 和 @PreDestroy。 10、请解释 Spring Bean 的生命周期?Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。 同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。 Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调 (call back) 方法组成。 1、初始化之后调用的回调方法。 2、销毁之前调用的回调方法。 Spring 框架提供了以下四种方式来管理 bean 的生命周期事件： InitializingBean 和 DisposableBean 回调接口 针对特殊行为的其他 Aware 接口 Bean 配置文件中的 Custom init() 方法和 destroy() 方法 @PostConstruct 和 @PreDestroy 注解方式 使用 customInit() 和 customDestroy() 方法管理 bean 生命周期的代码样例如下： 1234&lt;beans&gt; &lt;bean id=&quot;demoBean&quot; class=&quot;com.howtodoinjava.task.DemoBean&quot; init-method=&quot;customInit&quot; destroy-method=&quot;customDestroy&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 11、Spring Bean 的作用域之间有什么区别？Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的, 但是为了避免混淆, 还是让我们来解释一下： 1、singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例， 单例的模式由 bean factory 自身来维护。 2、prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。 3、request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例, 在请求完成以后, bean 会失效并被垃圾回收器回收. 4、Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。 5、global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。 如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。 全局作用域与 Servlet 中的 session 作用域效果相同。 12、什么是 Spring inner beans?在 Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean 声明为内部 bean。 内部 bean 可以用 setter 注入 “属性” 和构造方法注入 “构造参数” 的方式来实现。 比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个 Person 的实例， 然后在 Customer 内部使用。 123456789101112131415public class Customer&#123; private Person person; //Setters and Getters&#125;public class Person&#123; private String name; private String address; private int age; //Setters and Getters&#125; 内部 bean 的声明方式如下： 12345678910&lt;bean id=&quot;CustomerBean&quot; class=&quot;com.howtodoinjava.common.Customer&quot;&gt; &lt;property &gt; &lt;!-- This is inner bean --&gt; &lt;bean class=&quot;com.howtodoinjava.common.Person&quot;&gt; &lt;property /&gt; &lt;property /&gt; &lt;property /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 13、Spring 框架中的单例 Beans 是线程安全的么?Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。 但实际上，大部分的 Spring bean 并没有可变的状态 (比如 Serview 类和 DAO 类), 所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状态的话 (比如 View Model 对象)，就需要自行保证线程安全。 最浅显的解决办法就是将多态 bean 的作用域由 “singleton” 变更为 “prototype”。 14、请举例说明如何在 Spring 中注入一个 Java Collection?Spring 提供了以下四种集合类的配置元素： &lt;list&gt;:该标签用来装配可重复的 list 值。 &lt;set&gt;:该标签用来装配没有重复的 set 值。 &lt;map&gt;:该标签可用来注入键和值可以为任何类型的键值对。 &lt;props&gt;:该标签支持注入键和值都是字符串类型的键值对。 下面看一下具体的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;beans&gt; &lt;!-- Definition for javaCollection --&gt; &lt;bean id=&quot;javaCollection&quot; class=&quot;com.howtodoinjava.JavaCollection&quot;&gt; &lt;!-- java.util.List --&gt; &lt;property &gt; &lt;list&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- java.util.Set --&gt; &lt;property &gt; &lt;set&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- java.util.Map --&gt; &lt;property &gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt; &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt; &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt; &lt;entry key=&quot;4&quot; value=&quot;UK&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- java.util.Properties --&gt; &lt;property &gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 15、如何向 Spring Bean 中注入一个 Java.util.Properties?第一种方法是使用如下面代码所示的&lt;props&gt; 标签： 1234567891011&lt;bean id=&quot;adminUser&quot; class=&quot;com.howtodoinjava.common.Customer&quot;&gt; &lt;!-- java.util.Properties --&gt; &lt;property &gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 也可用 “util:” 命名空间来从 properties 文件中创建出一个 propertiesbean，然后利用 setter 方法注入 bean 的引用。 16、请解释 Spring Bean 的自动装配?在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的 关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。 自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。 下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配： 1&lt;bean id=&quot;employeeDAO&quot; class=&quot;com.howtodoinjava.EmployeeDAOImpl&quot; autowire=&quot;byName&quot; /&gt; 除了 bean 配置文件中提供的自动装配模式，还可以使用 @Autowired 注解来自动装配指定的 bean。 在使用 @Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。 1&lt;context:annotation-config /&gt; 也可以通过在配置文件中配置 AutowiredAnnotationBeanPostProcessor 达到相同的效果。 1&lt;bean class =&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt; 配置好以后就可以使用 @Autowired 来标注了。 1234@Autowiredpublic EmployeeDAOImpl ( EmployeeManager manager ) &#123; this.manager = manager;&#125; 17、请解释自动装配模式的区别?在 Spring 框架中共有 5 种自动装配，让我们逐一分析。 1、no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean 定义中用标签明确的设置依赖关系。 2、byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时， 容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 3、byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时， 容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 4、constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的 bean， 如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。 5、autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器， 如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byType 的自动装配方式。 18、如何开启基于注解的自动装配？要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现： 1、引入配置文件中的下引入 context:annotation-config 123&lt;beans&gt; &lt;context:annotation-config /&gt;&lt;/beans&gt; 2、在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor 123&lt;beans&gt; &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;&lt;/beans&gt; 19、请举例解释 @Required 注解?在产品级别的应用中，IoC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一 就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置 “dependency-check” 来解决这个问题。 在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正确配置。或者你宁可验证某个 bean 的特定属性是否被正确的设置。即使是用 “dependency-check” 属性也不能很好的解决这个问题, 在这种情况下, 你需要使用 @Required 注解。 需要用如下的方式使用来标明 bean 的设值方法。 123456789101112131415public class EmployeeFactoryBean extends AbstractFactoryBean&lt;Object&gt;&#123; private String designation; public String getDesignation() &#123; return designation; &#125; @Required public void setDesignation(String designation) &#123; this.designation = designation; &#125; //more code here&#125; RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被 @Required 注解的 bean 属性是否被正确的设置了。 在使用 RequiredAnnotationBeanPostProcesso 来验证 bean 属性之前，首先要在 IoC 容器中对其进行注册： 1&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot; /&gt; 但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个 BeanInitializationException 异常。 20、请举例解释 @Autowired 注解?@Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像 @Required 注解、 构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。 比如，可以在设值方法上使用 @Autowired 注解来替代配置文件中的 元素。 当 Spring 容器在 setter 方法上找到 @Autowired 注解时，会尝试用 byType 自动装配。 当然我们也可以在构造方法上使用 @Autowired 注解。带有 @Autowired 注解的构造方法意味着 在创建一个 bean 时将会被自动装配，即便在配置文件中使用 元素。 12345678910111213public class TextEditor &#123; private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker)&#123; System.out.println(&quot;Inside TextEditor constructor.&quot; ); this.spellChecker = spellChecker; &#125; public void spellCheck()&#123; spellChecker.checkSpelling(); &#125;&#125; 下面是没有构造参数的配置方式： 12345678910111213&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- Definition for textEditor bean without constructor-arg --&gt; &lt;bean id=&quot;textEditor&quot; class=&quot;com.howtodoinjava.TextEditor&quot;&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=&quot;spellChecker&quot; class=&quot;com.howtodoinjava.SpellChecker&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 21、请举例说明 @Qualifier 注解?@Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。 下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。 12345public class Customer&#123; @Autowired private Person person;&#125; 下面我们要在配置文件中来配置 Person 类。 123456789&lt;bean id=&quot;customer&quot; class=&quot;com.howtodoinjava.common.Customer&quot; /&gt;&lt;bean id=&quot;personA&quot; class=&quot;com.howtodoinjava.common.Person&quot; &gt; &lt;property /&gt;&lt;/bean&gt;&lt;bean id=&quot;personB&quot; class=&quot;com.howtodoinjava.common.Person&quot; &gt; &lt;property /&gt;&lt;/bean&gt; Spring 会知道要自动装配哪个 person bean 么? 不会的，但是运行上面的示例时，会抛出下面的异常： 123Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.howtodoinjava.common.Person] is defined: expected single matching bean but found 2: [personA, personB] 要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean： 123456public class Customer&#123; @Autowired @Qualifier(&quot;personA&quot;) private Person person;&#125; 22、构造方法注入和设值注入有什么区别?请注意以下明显的区别： 1、在设值注入方法支持大部分的依赖注入，如果我们仅需要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。 对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入， 因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 2、设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话， 那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。 3、在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。 而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 4、在设值注入时如果对象 A 和对象 B 互相依赖，在创建对象 A 时 Spring 会抛出 sObjectCurrentlyInCreationException 异常， 因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题， 因对象的设值方法是在对象被创建之前被调用的。 23、Spring 框架中有哪些不同类型的事件?Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。 我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件, 如果一个 bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。 12345678public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt;&#123; @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; //process event &#125;&#125; Spring 提供了以下 5 中标准的事件： 1、上下文更新事件 (ContextRefreshedEvent)：该事件会在 ApplicationContext 被初始化或者更新时发布。 也可以在调用 ConfigurableApplicationContext 接口中的 refresh() 方法时被触发。 2、上下文开始事件 (ContextStartedEvent)：当容器调用 ConfigurableApplicationContext 的 Start() 方法开始 / 重新开始容器时触发该事件。 3、上下文停止事件 (ContextStoppedEvent)：当容器调用 ConfigurableApplicationContext 的 Stop() 方法停止容器时触发该事件。 4、上下文关闭事件 (ContextClosedEvent)：当 ApplicationContext 被关闭时触发该事件。 容器被关闭时，其管理的所有单例 Bean 都被销毁。 5、请求处理事件 (RequestHandledEvent)：在 Web 应用中，当一个 http 请求（request）结束触发该事件。 除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。 12345678public class CustomApplicationEvent extends ApplicationEvent&#123; public CustomApplicationEvent ( Object source, final String msg ) &#123; super(source); System.out.println(&quot;Created a Custom event&quot;); &#125;&#125; 为了监听这个事件，还需要创建一个监听器： 1234567public class CustomEventListener implements ApplicationListener &lt; CustomApplicationEvent &gt;&#123; @Override public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123; //handle event &#125;&#125; 之后通过 applicationContext 接口的 publishEvent() 方法来发布自定义事件。 12CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext, &quot;Test message&quot;);applicationContext.publishEvent(customEvent); 24、FileSystemResource 和 ClassPathResource 有何区别?在 FileSystemResource 中需要给出 spring-config.xml 文件在你项目中的相对路径或者绝对路径。 在 ClassPathResource 中 spring 会在 ClassPath 中自动搜寻配置文件，所以要把 ClassPathResource 文件放在 ClassPath 下。 如果将 spring-config.xml 保存在了 src 文件夹下的话，只需给出配置文件的名称即可，因为 src 文件夹是默认。 简而言之，ClassPathResource 在环境变量中读取配置文件，FileSystemResource 在配置文件中读取配置文件。 25、Spring 框架中都用到了哪些设计模式？Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的： 1、代理模式—在 AOP 和 remoting 中被用的比较多。 2、单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。 3、模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 4、前端控制器—Spring 提供了 DispatcherServlet 来对请求进行分发。 5、视图帮助 (View Helper)—Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。 6、依赖注入—贯穿于 BeanFactory / ApplicationContext 接口的核心理念。 7、工厂模式—BeanFactory 用来创建对象的实例。 原文:http://blog.csdn.net/a724888/article/details/68925151]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记五]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17%2F</url>
    <content type="text"><![CDATA[第5章 构建Spring Web应用本章内容： 映射请求到Spring控制器 透明的绑定表单数据 校验表单提交 系统面临的挑战：状态管理、工作流、以及验证都是需要解决的重要特性。HTTP协议的无状态决定了这些问题都不是那么容易解决。 Spring的Web框架就是为了帮你解决这些关注点而设计的。Spring MVC基于模型-视图-控制器(Model-View-Controller MVC)模式实现的，他能够帮你构建向Spring框架那样灵活和松耦合的Web应用程序。 在本章中，将会介绍Spring MVC Web框架，并使用新的Spring MVC注解来构建处理各种Web请求、参数、和表单输入的控制器。 5.1 Spring MVC起步Spring将请求在调度Servlet、处理器映射(Handler Mappering)、控制器以及视图解析器(View resolver)之间移动，每一个Spring MVC中的组件都有特定的目的，并且也没那么复杂。 让我们看一下，请求是如何从客户端发起，经过Spring MVC中的组件，最终返回到客户端 5.1.1 跟踪Spring MVC每当用户在Web浏览器中点击链接或提交表单的时候，请求就开始工作了。请求是一个十分繁忙的家伙，从离开浏览器开始到获取响应返回，它会经历很多站，在每站都会留下一些信息，同时也会带上一些信息。 Spring工作流程描述原文在这里 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获； DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法） 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； ViewResolver 结合Model和View，来渲染视图 将渲染结果返回给客户端。 图片参考这里 Spring工作流程描述 为什么Spring只使用一个Servlet(DispatcherServlet)来处理所有请求？ 详细见J2EE设计模式-前端控制模式 Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler? 符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。 1、请求旅程的第一站是Spring的DispatcherServlet。与大多数基于Java的Web框架一样，Spring MVC所有的请求都会通过一个前端控制器(front contrller)Servlet.前端控制器是常用Web应用程序模式。在这里一个单实例的Servlet将请求委托给应用的其他组件来执行实际的处理。在Spring MVC中，DisPatcherServlet就是前端控制器。 2、DisPactcher的任务是将请求发送Spring MVC控制器(controller).控制器是一个用于处理请求的Spring组件。在典型的应用中可能会有多个控制器，DispatcherServlet需要知道应该将请求发送给那个哪个控制器。所以Dispactcher以会查询一个或 多个处理器映射(Handler mapping),来确定请求的下一站在哪里。处理映射器根据请求携带的 URL信息来进行决策。 3、一旦选择了合适的控制器，DispatcherServlet会将请求发送给选中的控制器。到了控制器，请求会卸下其负载(用户提交的信息)并耐心等待控制器处理这些信息。(实际上，设计良好的控制器 本身只是处理很少，甚至不处理工作，而是将业务逻辑委托给一个或多个服务器对象进行处理) 4、控制器在完成处理逻辑后，通常会产生一些信息。这些 信息需要返回给 用户，并在浏览器上显示。这些信息被称为模型(Model),不过仅仅给用户返回原始的信息是不够的—-这些信息需要以用户友好的方式进行格式化，一般会是HTML。所以，信息需要发送一个视图(View),通常会是JSP。 5、 控制器做的最后一件事就是将模型打包，并且表示出用于渲染输出的视图名。它接下来会将请求连同模型和视图发送回DispatcherServlet。 6、这样，*控制器就不会与特定的视图相耦合**传递给控制器的视图名并不直接表示某个特定的jsp。实际上，它甚至并不能确定视图就是JSP。相反，它仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。DispatcherServlet将会使用视图解析器(View resolver),来将逻辑视图名称匹配为一个特定的视图实现，他可能也可能不是JSP 7、虽然DispatcherServlet已经知道了哪个驶入渲染结果、那请求的任务基本上也就完成了，它的最后一站是试图的实现。在这里它交付给模型数据。请求的任务就结束了。视图将使用模型数据渲染输出。这个输出通过响应对象传递给客户端(不会像听上去那样硬编码) 可以看到，请求要经过很多步骤，最终才能形成返回给客户端的响应，大多数的 步骤都是在Spirng框架内部完成的。 5.1.2 搭建Spring MVC借助于最近几个Spring新特性的功能增强，开始使用SpringMVC变得非常简单了。使用最简单的方式配置Spring MVC；所要实现的功能仅限于运行我们所创建的控制器。 配置DisPatcherServlet DispatcherServlet是Spirng MVC的核心，在这里请求会第一次接触到框架，它要负责将请求路由到其他组件之中。 按照传统的方式，像DispatcherServlet这样的Servlet会配置在web.xml中。这个文件会放到应用的war包中。当然这是配置DispatcherServlet方法之一。借助于Servlet 3规范和Spring 3.1 的功能增强，这种方式已经不是唯一的方案来。 我们会使用Java将DispatcherServlet配置在Servlet容器中。而不会在使用web.xml文件 12345678910111213141516public class SpitterWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected String[] getServletMappings() &#123; //将DispatcherServlet映射到“/” return new String[]&#123;"/"&#125;; &#125; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt; [] &#123;RootConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt; [] &#123; WebConfig.class&#125;; &#125;&#125; 我们只需要知道扩展AbstractAnnotationConfigDispatcherServletInitializer的任意类都会自动的配置Dispatcherservlet和Spring应用上下文，Spirng的应用上下文会位于应用程序的Servlet上下文之中 在Servlet3.0环境中，容器会在类路径中 查找实现javax.servlet.ServletContainerInitialzer接口的类，如果能发现的话，就会用它来配置Servlet容器。 Spring提供了这个接口的实现名为SpringServletContainnerInitialzer,这个类反过来又会查找实现WebApplicationInitialzer的类，并将配置的任务交给他们来完成。Spring 3.2引入了一个遍历的WebApplicationInitialzer基础实现也就是AbstractAnnotationConfigDispatcherServletInitializer因为我们的Spittr-WebApplicationInitialzer扩展了AbstractAnnotationConfigDispatcherServletInitializer,(同时也就实现了WebApplicationInitialzer),因此当部署Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文 第一个方法getServletMappings(),它会将一个或多个路径映射到DispatcherServlet上，在本示例中，它映射的是“/”，表示它是应用默认的Servlet，它会处理应用的所有请求。 为了理解其他两个方法，我们首先需要理解DispatcherServlet和一个Servlet监听器(也就是ContextLoaderListener)的关系。 当DispatcherServlet启动的时候，它会创建应用上下文，并加载配置文件或配置类中声明的bean。在上面那个程序中的getServletConfigClasses()方法中，我们要求DispatcherServlet加载应用上下文时，使用定义在WebConfig配置类(使用Java配置)中的bean 但在Spring Web应用中，通常还会有另外一个应用上下文。另外这个就是由ContextLoaderListener创建. 我们希望DispatcherServlet加载包含Web组件的bean，如控制器，视图解析器，以及处理器映射，而ContextLoaderListener要加载应用中的其他bean。这些bean通常 是驱动应用后端的中间层和数据层组件。 实际上AbstractAnnotationConfigDispatcherServletInitializer会同时创建DispatcherServlet和ContextLoaderListener。getServletConfigClasses()方法会返回带有@Configuration注解的类将会用来定义DispatcherSerle应用上下文中的bean，getRootConfigClasses()会返回带有@Configuration注解的类将会用来配置ContextLoaderListener创建的应用上下文。 如果有必要两个可以同时存在，wex.xml和 AbstractAnnotationConfigDispatcherServletInitializer,但其实没有必要。 如果按照这种方式配置DispatcherServlet，而不是使用Web.xml的话，那么唯一的问题在于它能部署到支持Servlet3.0的服务器上才可以正常工作，如Tomcat7或更高版本，Servlet3.0规范在2009年12月份就发布了， 如果没有支持Servlet3.0，那别无选择了，只能使用web.xml配置类。 启用Spring MVC 我们有多种方式来启动DispatcherServlet，与之类似，启用Spring MVC组件的方式也不止一种，以前Spring是XMl进行配置的，你可以选择mvc:annotation-driver启用注解驱动的Spring MVC。 在第七章的时候会介绍mvc:annotaion-driver,现在会让Spring MVC搭建的过程尽可能简单，并基于Java进行配置。 我们所能创建最简单的Spring MVC配置就是一个带有@EnableWebMvc注解的类1234567import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@EnableWebMvcpublic class WebConfig &#123;&#125; 这可以运行起来，它的确能够启用Spring MVC，但还有不少问题要解决。 1、没有配置视图解析器，如果这样的话，Spring默认会使用BeanNameView-Resolver，这个视图解析器会查找ID与视图名称匹配的bean，并且查找的bean要实现View接口，它以这样的方式来解析视图。 2、没有启用组件扫描。这样的结果就是，Spirng只能找到显示声明在配置类中的控制器。 3、这样配置的话，DispatcherServlet会映射为默认的Servlet，所以他会处理所有的请求，包括对静态资源的请求，如图片 和样式表(在大多数情况下，这可能并不是你想要的结果)。 因此我们需要在WebConfig这个最小的Spring MVC配置上再加一些内容，从而让他变得真正实用。 12345678910111213141516171819202122@Configuration@EnableWebMvc //启用Spring MVC@ComponentScan("com.guo.spittr.web") //启用组件扫描public class WebConfig extends WebMvcConfigurerAdapter &#123; @Bean public ViewResolver viewResolver () &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); //配置JSP视图解析器 resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; @Override //我们要求DispatcherServlet将静态资源的请求转发到Servlet容器中默认的Servlet上， //而不是使用DispatcherServlet本来来处理此类请求。 public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; //配置静态资源的处理 configurer.enable(); &#125;&#125; 第一件需要注意的是WebConfig现在添加了@ComponentScan注解，此时将会扫描com.guo.spittr.web包来查找组件。稍后你会看到，我们编写的控制器将会带有@Controller注解，这会使其成为组件扫描时的候选bean。因此，我们不需要在配置类中显示声明任何的控制器。 接下来，我们添加了一个ViewResolver bean，更具体的将是InternalResourceViewResolver。将会在第6章更为详细的讨论视图解析器。我们只需要知道他会去查找jsp文件，在查找的时候，它会在视图名称上加一个特定的前缀和后缀。(例如：名为home的视图会被解析为/WEB-INF/views/home.jsp) 最后新的WebConfig类还扩展里WebMvcConfigurerAdapter并重写了其configureDefaultServletHandling()方法,通过调用DefaultServletHandlerConfigurer的enable()方法，我们要求DispatcherServlet将静态资源的请求转发到Servlet容器中默认的Servlet上，而不是使用DispatcherServlet本来来处理此类请求。 WebConfig已经就绪，那么RootConfig呢？因为本章聚焦于Web开发，而Web相关的配置通过DisPatcherServlet创建的应用上下文都已经配好了，因此现在的RootConfig相对很简单： 123456789101112131415import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.web.servlet.config.annotation.EnableWebMvc;/** * Created by guo on 23/2/2018. */@Configuration@ComponentScan(basePackages = &#123;"com.guo.spittr"&#125;, excludeFilters = &#123; @Filter(type = FilterType.ANNOTATION,value = EnableWebMvc.class)&#125;)public class RootConfig &#123;&#125; 唯一需要注意的是RootConfig使用了@ComponentScan注解，这样的话，我们就有很多机会用非Web的组件来完善RootConfig。 5.1.3 Spittr应用简介为了实现在线社交的功能，我们将要构造一个简单的微博(microblogging)应用，在很多方面，我们所构建的应用于最早的微博应用Twitter很类似，在这个过程中，我们会添加一些小的变化。当然我们使用Spirng技术来构建这个应用。 因为从Twitter借鉴了灵感并通过Spring来进行实现，所以它就有了一个名字：Spitter。 Spittr应用有两个基本的领域概念：Spitter(应用的用户)和Spittle(用户发布的简短状态更新)。当我们在书中完善Spittr应用的功能时，将会介绍这两个概念。在本章中，我们会构建应用的Web层，创建展现Spittle的控制器以及处理用户注册为Spitter的表单。 舞台已经搭建完成了，我们已经配置了DispatcherServlet，启用了基本的Spring MVC组件，并确定了目标应用。让我们进入本章的核心内容：使用Spring MVC 控制器处理Web请求。 5.2 编写 基本的控制器在SpringMVC中，控制器只是在方法上添加了@RequestMapping注解的类，这个注解声明了他们所要处理的请求。 开始的时候，我们尽可能简单，假设控制器类要处理对/的请求，并对渲染应用的首页。 123456789101112131415import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;/** * Created by guo on 24/2/2018. * 首页控制器 */@Controllerpublic class HomeController &#123; @RequestMapping(value = "/",method = RequestMethod.GET) //处理对“/”的Get请求 public String home() &#123; return "home"; //视图名为home &#125;&#125; 写完测试了下，好使， 你可能注意到第一件事就是HomeController带有@Controller注解，很显然这个注解是用来声明控制器的，但实际上这个注解对Spirng MVC 本身影响不大。 @Controller是一个构造型(stereotype)的注解。它基于@Component注解。在这里，它的目的就是辅助实现组件扫描。因为homeController带有@Controller注解，因此组件扫描器会自动去找到HomeController，并将其声明为Spring应用上下文中的bean。1234567Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller &#123; String value() default "";&#125; 其实你可以让HomeController带有@Component注解，它所实现的效果是一样的。但是在表意性上可能差一些，无法确定HomeController是什么组件类型。 HomeController唯一的一个方法，也就是Home方法，带有@RequestMapping注解，他的Value属性指定了这个方法所要处理的请求路径，method属性细化了它所能处理的HTTP方法，在本例中，当收到对‘/’的HTTP GET请求时，就会调用home方法。 home()方法其实并没有做太多的事情，它返回一个String类型的“home”，这个String将会被Spring MVC 解读为要渲染的视图名称。DispatcherServlet会要求视图解析器将这个逻辑名称解析为实际的视图。 鉴于我们配置InternalResourceViewResolver的方式，视图名“home”将会被解析为“/WEB-INF/views/home.jsp” Spittr应用的首页，定义为一个简单的JSP123456789101112131415&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ page session="false" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Spitter&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="&lt;c:url value="/resources/style.css" /&gt;" &gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to Spitter&lt;/h1&gt; &lt;a href="&lt;c:url value="/spittles" /&gt;"&gt;Spittles&lt;/a&gt; | &lt;a href="&lt;c:url value="/spitter/register" /&gt;"&gt;Register&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 测试控制器最直接的办法可能是构建并部署应用，然后通过浏览器对其进行访问，但是自动化测试可能会给你更快的反馈和更一致的独立结果，所以，让我们编写一个针对HomeController的测试 5.2.1 测试控制器编写一个简单的类来测试HomoController。12345678910import static org.junit.Assert.*;import org.junit.Test;public class HomeControllerTest &#123; @Test public void testHomePage() throws Exception &#123; HomeController controller = new HomeController(); assertEquals("home",controller.home()); &#125;&#125; 在测试中会直接调用home()方法，并断言返回包含 “home”值的String类型。它完全没有站在Spring MVC控制器的视角进行测试。这个测试没有断言当接收到针对“/”的GET请求时会调用home()方法。因为它返回的值就是“home”，所以没有真正判断home是试图的名称。 不过从Spring 3.2开始，我们可以按照控制器的方式进行测试Spring MVC中的控制器了。而不仅仅是POJO进行测试。Spring现在包含了一种mock Spirng MVC 并针对控制器执行 HTTP请求的机制。这样的话，在测试控制器的时候，就没有必要在启动Web服务器和Web浏览器了。 为了阐述如何测试Spirng MVC 容器，我们重写了HomeControllerTest并使用Spring MVC 中新的测试特性。 123456789101112131415161718import org.junit.Test;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.setup.MockMvcBuilders.*;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;/** * Created by guo on 24/2/2018. */public class HomeControllerTest1 &#123; @Test //大家在测试的时候注意静态导入的方法 public void testHomePage() throws Exception &#123; HomeController controller = new HomeController(); MockMvc mockMvc = standaloneSetup(controller).build(); //搭建MockMvc mockMvc.perform(get("/")) //对“/”执行GET请求， .andExpect(view().name("home")); //预期得到home视图 &#125;&#125; 这次我们不是直接调用home方法并测试它的返回值，而是发起了对”/“的请求，并断言结果视图的名称为home，它首先传递一个HomeController实例到MockMvcBuilders.strandaloneSetup()并调用build()来构建MockMvc实例，然后它使用MockMvc实例执行针对“/”的GET请求，并设置 期望得到的视图名称。 5.2.2 定义类级别的请求处理。现在，已经为HomeController编写了测试，那么我们可以做一些重构。并通过测试来保证不会对功能造成什么破坏。我们可以做的就是拆分@RequestMapping，并将其路径映射部分放到类级别上 12345678@Controller@RequestMapping("/")public class HomeController &#123; @RequestMapping(method = RequestMethod.GET) //处理对“/”的Get请求 public String home() &#123; return "home"; //视图名为home &#125;&#125; 在这个新版本的HomeController中，路径被转移到类级别的@RequestMapping上，而HTTP方法依然映射在方法级别上。当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上，处理器方法上的@RequestMapping注解会对类级别上的@RequestMapping的声明进行补充。 就HomeController而言，这里只有一个控制器方法，与类级别的@RequestMapping合并之后，这个方法的@RequestMapping表明home()将会处理对 “/”路径的GET请求。 有了测试，所以可以确保在这个过程中，没有对原有的功能造成破坏。 当我们修改@RequestMapping时，还可以对HomeController做另一个变更。@RequestMapping的value接受一个String类型的数组。到目前为止，我们给它设置的都是一个String类型的‘/’。但是，我们还可以将它映射到对“/Homepage”的请求，只需要将类级别的@RequestMapping改动下 12345@Controller@RequestMapping(&#123;"/","/Homepage"&#125;)public class HomeController &#123; ...&#125; 现在，HomeController的home()方法可以被映射到对“/”和“/homepage”的GET请求上。 5.2.3 传递模型数据到视图中到目前为止，就编写超级简单的控制器来说，HomeController已经是一个不错的样例了，但是大多数的控制器并不是那么简单。在Spring应用中，我们需要有一个页面展示最近提交的Spittle列表。因此，我们需要有一个新的方法来处理这个页面。 首先需要定义一个数据访问的Repository，为了实现解耦以及避免陷入数据库访问的细节中，我们将Repository定义为一个接口，并在稍后实现它(第十章)，此时，我们只需要一个能够获取Spittle列表的Repository，123456789package com.guo.spittr.data;import com.guo.spittr.Spittle;import java.util.List;/** * Created by guo on 24/2/2018. */public interface SpittleRepository &#123; List&lt;Spittle&gt; finfSpittles(long max, int count);&#125; findSpittles()方法接受两个参数，其中max参数代表所返回的Spittle中，Spittle ID属性的最大值，而count参数表明要返回多少个Spittle对象，为了获得最新的20个Spittle对象，我们可以这样调用方法。 1List&lt;Spittle&gt; recent = SpittleRepository.findSpittles(long.MAX_VALUE(),20) 它的属性包括消息内容，时间戳，以及Spittle发布时对应的经纬度。 12345678910111213141516171819202122232425262728293031public class Spittle &#123; private final Long id; private final String message; private final Date time; private Double latitude; private Double longitude; public Spittle(String message, Date time) &#123; this(null, message, time, null, null); &#125; public Spittle(Long id, String message, Date time, Double longitude, Double latitude) &#123; this.id = id; this.message = message; this.time = time; this.longitude = longitude; this.latitude = latitude; &#125; //Getter和Setter略 @Overridepublic boolean equals(Object that) &#123; return EqualsBuilder.reflectionEquals(this, that, "id", "time");&#125;@Overridepublic int hashCode() &#123; return HashCodeBuilder.reflectionHashCode(this, "id", "time");&#125; 需要注意的是，我们使用Apache Common Lang包来实现equals()和hashCode()方法，这些方法除了常规的作用以外，当我们为控制器的处理器方法编写测试时，它们也是有用的。 既然我们说到了测试，那么我们继续讨论这个话题，并为新的控制器方法编写测试， 123456789101112131415161718192021222324252627@Test public void houldShowRecentSpittles() throws Exception &#123; List&lt;Spittle&gt; expectedSpittles = createSpittleList(20); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findSpittles(Long.MAX_VALUE, 20)) .thenReturn(expectedSpittles); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller) .setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")) .build(); mockMvc.perform(get("/spittles")) .andExpect(view().name("spittles")) .andExpect(model().attributeExists("spittleList")) .andExpect(model().attribute("spittleList", hasItems(expectedSpittles.toArray()))); &#125;/.................佩服老外，测试代码一大堆，省略了好多，好好研究下，..................../ private List&lt;Spittle&gt; createSpittleList(int count) &#123; List&lt;Spittle&gt; spittles = new ArrayList&lt;Spittle&gt;(); for (int i=0; i &lt; count; i++) &#123; spittles.add(new Spittle("Spittle " + i, new Date())); &#125; return spittles; &#125;&#125; 测试首先会创建SpittleRepository接口的mock实现，这个实现会从他的findSpittles()方法中返回20个Spittle对象，然后将这个Repository注入到一个新的SpittleController实例中，然后创建MockMvc并使用这个控制器。 需要注意的是这个测试在MockMvc构造器上调用了setSingleView().这样的话，mock框架就不用解析控制器中的视图名了。在很多场景中，其实没必要这么做，但是对于这个控制器方法，视图和请求路径非常相似，这样按照默认的驶入解析规则，MockMvc就会发生失败，因为无法区分视图路径和控制器的路径，在这个测试中，构建InternalResourceViewResolver时所设置的路径是无关紧要的，但我们将其设置为InternalResourceViewResolver一致。 这个测试对“/spittles”发起Get请求，然后断言视图的名称为spittles并且模型中包含名为spittleList的属性，在spittleList中包含预期的内容。 当然如果此时运行测试的话，它将会失败。他不是运行失败，而是编译的时候就失败，这是因为我们还没编写SpittleController。 123456789101112131415@Controller@RequestMapping("/spittles")public class SpittleController &#123; private SpittleRepository spittleRepository; @Autowired public SpittleController(SpittleRepository spittleRepository) &#123; //注入SpittleRepository this.spittleRepository = spittleRepository; &#125; @RequestMapping(method = RequestMethod.GET) public String spittles(Model model) &#123; model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名 &#125;&#125; 我们可以看到SpittleController有一个构造器，这个构造器使用@Autowired注解，用来注入SpittleRepository。这个SpittleRepository随后又在spittls()方法中，用来获取最新的spittle列表。 需要注意的是我们在spittles()方法中给定了一个Model作为参数。这样，spittles()方法就可以将Repository中获取到的Spittle列表填充到模型中，Model实际上就是一个Map(也就是key-value的集合)它会传递给视图，这样数据就能渲染到客户端了。当调用addAttribute()方法并且指定key的时候，那么key会根据值的对象类型来推断确定。 sittles()方法最后一件事是返回spittles作为视图的名字，这个视图会渲染模型。 如果你希望显示模型的key的话，也可以指定，123456@RequestMapping(method = RequestMethod.GET)public String spittles(Model model) &#123; model.addAttribute("spittleList", spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名&#125; 如果你希望使用非Spring类型的话，那么可以使用java.util.Map来代替Model123456@RequestMapping(method = RequestMethod.GET)public String spittles(Map model) &#123; model.addAttribute("spittleList", spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名&#125; 既然我们现在提到了各种可替代方案，那下面还有另外一种方式来编写spittles()方法 1234@RequestMapping(method = RequestMethod.GET)public List&lt;String&gt; spittles() &#123; return spittleRepository.findSpittles(Long.MAX_VALUE,20));&#125; 这个并没有返回值，也没有显示的设定模型，这个方法返回的是Spittle列表。。当处理器方法像这样返回对象或集合时，这个值会放到模型中，模型的key会根据其类型推断得出。在本示例中也就是(spittleList) 逻辑视图的名称也会根据请求的路径推断得出。因为这个方法处理针对“/spittles”的GET请求，因此视图的名称将会是spittles，（去掉开头的线。） 不管使用哪种方式来编写spittles()方法，所达成的结果都是相同的。模型会存储一个Spittle列表，ket为spittleList，然后这个列表会发送到名为spittles的视图中。视图的jsp会是“/WEB-INF/views/spittles.jsp” 现在数据已经放到了模型中，在JSP中该如何访问它呢？实际上，当视图是JSP的时候，模型数据会作为请求属性放入到请求之中(Request) ,因此在spittles.jsp文件中可以使用JSTL(JavaServer Pages Standard Tag Library) 的&lt;c:forEach&gt;标签渲染spittle列表。 123456789&lt;c:forEach items="$&#123;spittleList&#125;" var="spittle" &gt; &lt;li id="spittle_&lt;c:out value="spittle.id"/&gt;"&gt; &lt;div class="spittleMessage"&gt;&lt;c:out value="$&#123;spittle.message&#125;" /&gt;&lt;/div&gt; &lt;div&gt; &lt;span class="spittleTime"&gt;&lt;c:out value="$&#123;spittle.time&#125;" /&gt;&lt;/span&gt; &lt;span class="spittleLocation"&gt;(&lt;c:out value="$&#123;spittle.latitude&#125;" /&gt;, &lt;c:out value="$&#123;spittle.longitude&#125;" /&gt;)&lt;/span&gt; &lt;/div&gt; &lt;/li&gt;&lt;/c:forEach&gt; 尽管SpittleController很简单，但是它依然比homeController更进一步，不过，SpittleController和HomeController都没有处理任何形式的输入。现在，让我们扩展SpittleContorller，让它从客户端接受一些输入。 5.3 接受请求的输入Spring MVC 允许以多种方法将客户端中的数据传送到控制器的处理器方法中 查询数据(Query Parameter) 表单参数(Form Parameter) 路径变量(Path Variable) 作为开始，先来看下如何处理带有查询参数的请求，这也是客户端往服务器发送数据时，最简单和最直接的方法。 5.3.1 处理查询参数在Spittr应用中，可能需要处理的一件事就是展现分页的Spittle列表，如果你想让用户每次查看某一页的Spittle历史，那么就需要提供一种方式让用户传递参数进来，进而确定展现那些Spittle列表。 为了实现这个分页功能，我们编写的处理方法要接受两个参数 before参数 (表明结果中所有的SPittle的ID均在这个值之前) count参数(彪悍在结果中要包含的Spittle数量) 为了实现这个功能，我们将程序修改为spittles()方法替换为使用before参数和count参数的新spittles()方法。 首先添加一个测试，这个测试反映了xinspittles()方法的功能 123456789101112131415161718@Testpublic void shouldShowPagedSpittles() throws Exception &#123; List&lt;Spittle&gt; expectedSpittles = createSpittleList(50); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findSpittles(238900, 50)) .thenReturn(expectedSpittles); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller) .setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")) .build(); mockMvc.perform(get("/spittles?max=238900&amp;count=50")) .andExpect(view().name("spittles")) .andExpect(model().attributeExists("spittleList")) .andExpect(model().attribute("spittleList", hasItems(expectedSpittles.toArray())));&#125; 这个测试方法关键点在于同时传入了max和count参数，它测试了这些参数存在时的处理方法，而另一个则测试了没有这些参数的情景。 在这个测试之后，我们就能确保不管控制器发生了什么样的变化，它都能够处理这两种类型的请求。 123456@RequestMapping(method = RequestMethod.GET)public List&lt;Spittle&gt; spittles( @RequestParam(value = "max") long max, @RequestParam(value = "count") int count) &#123; return spittleRepository.findSpittles(max, count);&#125; SittleController中的处理器方法同时要处理有参数和没参数的场景，那我们需要对其进行修改，让它能接受参数。同时如果这些参数在请求中不存在的话，就是用默认值Long.MAX_VALUE和20.@RequestParam注解的defaultValue属性可以完成这个任务。 123456@RequestMapping(method=RequestMethod.GET)public List&lt;Spittle&gt; spittles( @RequestParam(value="max", defaultValue=MAX_LONG_AS_STRING) long max, @RequestParam(value="count", defaultValue="20") int count) &#123; return spittleRepository.findSpittles(max, count);&#125; 现在如果max如果没有参数指定的话，它将会是Long的最大值。 因为查询参数都是String 类型 ，因此defaultValue属性需要String类型， 1private static final String MAX_LONG_AS_STRING = long.toString(Long.MAX.VALUE) 请求中的查询参数是往控制器中传递信息的常用手段。另外一种方式就是将传递的参数作为请求路径的一部分。 5.3.2 通过路径参数接受输入假设我们的应用程序需要根据给定的ID来展现某一个Spittle记录。其中一种方案就是编写处理器方法，通过使用@RequestParam注解，让它接受ID作为查询参数。 123456@RequestMapping(value="/show",method = RequestMethod.GET)public String showSpittle( @RequestParam("spittle_id") long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; 在理想情况下，要识别资源应用应该通过URL路径来标识，而不是通过查询参数。对“/spittles/12345”发起请求要优于对“/spittles/show?spittle_id=12345”发起的请求。前者能识别出要查询的资源，而后者描述的是带有参数的一个操作——本质上是通过HTTP发起的RPC。 既然已经以面向资源的控制器作为目标，那我们将这个需求转化为一个测试。 1234567891011121314@Testpublic void testSpittle() throws Exception &#123; Spittle expectedSpittle = new Spittle("Hello", new Date()); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findOne(12345)).thenReturn(expectedSpittle); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(get("/spittles/12345")) .andExpect(view().name("spittle")) //断言图片的名称为spittle .andExpect(model().attributeExists("spittle")) //预期Spittle放到了模型之中 .andExpect(model().attribute("spittle", expectedSpittle));&#125; 这个测试构建了一个mockRepository，一个控制器和MockMvc 到目前为止，我们所编写的控制器，所有的方法都映射到了静态定义好的路径上，还需要包含变量部分 为了实现这种路径变量，Spring MVC允许我们在@RequestMapping路径中添加占位符，占位符的名称需要({..}),路径中的其他部分要与所处理的请求完全匹配，但是占位符可是是任意的值。 12345@RequestMapping(value="/&#123;spittleId&#125;",method = RequestMethod.GET)public String showSpittle(@PathVariable("spittleId") long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; @PathVariable(“spittleId”) 表明在请求路径中，不管占位符部分的值是什么都会传递给处理器方法的showSpittle参数中。 也可以去掉这个value的值，因为方法的参数碰巧与占位符的名称相同。12345@RequestMapping(value="/&#123;spittleId&#125;",method = RequestMethod.GET)public String showSpittle(@PathVariable long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; 如果传递请求中少量的数据，那查询参数和路径变量是合适的，但通常我们还需要传递很多的数据，(表单数据)，那么查询显得有些笨拙和受限制了。 5.4 处理表单Web应用的功能不局限于为用户推送内容，大多数的应用允许用户填充表单，并将数据提交回应用中，通过这种方式实现与用户的交互。 使用表单分为两个方面：展现表单以及处理用户通过表单提交的数据。在Spittr应用中，我们需要有个表单让用户进行注册，SitterController是一个新的控制器，目前只有一个请求处理的方法来展现注册表单。 123456789@Controller@RequestMapping("/spitter")public class SpitterController &#123; //处理对“/spitter/register” @RequestMapping(value = "/register",method = RequestMethod.GET) public String showRegistrationForm() &#123; return "registerForm"; &#125;&#125; 测试展现表单的控制器方法(老外每次都测试) 12345678@Testpublic void shouldShowRegistration() throws Exception &#123; SpitterController controller = new SpitterController(); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(get("/spitter/register")) .andExpect(view().name("registerForm"));&#125;&#125; 这个JSP必须包含一个HTML标签，123456&lt;form method="POST" name="spittleForm"&gt; &lt;input type="hidden" name="latitude"&gt; &lt;input type="hidden" name="longitude"&gt; &lt;textarea name="message" cols="80" rows="5"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type="submit" value="Add" /&gt;&lt;/form&gt; 需要注意的是这里的标签中并没有设置action属性。在这种情况下，当表单体提交的时，它会提交到与展现时相同的URL路径上，它会提交到“/spitter/reqister”上。 这意味着需要在服务器端编写该HTTP POST请求。 5.4.1 编写处理表单的处理器当处理注册表单的POST请求时，控制器需要接受表单数据，并将表单数据保存为Spitter对象。最后为了防止重复提交(用户刷新页面)，应该将浏览器重定向到新创建用户的基本信息页面。 1234567891011121314151617181920@Testpublic void shouldProcessRegistration() throws Exception &#123; SpitterRepository mockRepository = mock(SpitterRepository.class); Spitter unsaved = new Spitter("jbauer", "24hours", "Jack", "Bauer", "jbauer@ctu.gov"); Spitter saved = new Spitter(24L, "jbauer", "24hours", "Jack", "Bauer", "jbauer@ctu.gov"); when(mockRepository.save(unsaved)).thenReturn(saved); SpitterController controller = new SpitterController(mockRepository); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(post("/spitter/register") .param("firstName", "Jack") .param("lastName", "Bauer") .param("username", "jbauer") .param("password", "24hours") .param("email", "jbauer@ctu.gov")) .andExpect(redirectedUrl("/spitter/jbauer")); verify(mockRepository, atLeastOnce()).save(unsaved);&#125; 希望大家也可以学会这样方式 在构建完SpitterRepository的mock实现以及所要执行的控制器和MockNvc之后，shouldProcessRegistration()对“/spitter/register”发起了一个POST请求，作为请求的一部分，用户信息以参数的形式放到request中，从而模拟提交的表单。 12345678910111213141516171819202122232425/** * Created by guo on 24/2/2018. */@Controller@RequestMapping("/spitter")public class SpitterController &#123; private SpitterRepository spitterRepository; @Autowired public SpitterController(SpitterRepository spitterRepository) &#123; //注入SpiterRepository this.spitterRepository = spitterRepository; &#125; @RequestMapping(value = "/register", method = RequestMethod.GET) public String showRegistrationForm() &#123; return "registerForm"; &#125; @RequestMapping(value = "/register",method = RequestMethod.POST) public String procesRegistration(Spitter spitter) &#123; spitterRepository.save(spitter); //保存Spitter return "redirect:/spitter/" + spitter.getUsername(); //重定向到基本信息页面 &#125;&#125; 返回一个String类型，用来指定视图。但是这个视图格式和以前有所不同。这里不仅返回了视图的名称供视图解析器查找目标视图，而且返回的值还带有重定向的格式return &quot;redirect:/spitter/&quot; 当看到视图格式中有“redirect：”前缀时，它就知道要将其解析为重定向的规则，而不是试图的名称。在本例中，它将会重定向到基本信息的页面。 需要注意的是除了可以“redirect”还可以识别“forward：”前缀，请求将会前(forward)往指定的URL路径，而不再是重定向。 在SpitterController中添加一个处理器方法，用来处理对基本信息页面的请求。 123456@RequestMapping(value = "/&#123;username&#125;",method = RequestMethod.GET)public String showSpitterProfile(@PathVariable String username, Model model) &#123; Spitter spitter = spitterRepository.findByUsername(username); model.addAttribute(spitter); return "profile";&#125; spitterRepository通过用户获取一个Spitter对象，showSpitterProfile()方法得到这个对象并将其添加到模型中，然后返回profile。也就是基本信息页面的逻辑视图。 123456&lt;body&gt; &lt;h1&gt;Your Profile&lt;/h1&gt; &lt;c:out value="$&#123;spitter.username&#125;" /&gt;&lt;br/&gt; &lt;c:out value="$&#123;spitter.firstName&#125;" /&gt; &lt;c:out value="$&#123;spitter.lastName&#125;" /&gt;&lt;br/&gt; &lt;c:out value="$&#123;spitter.email&#125;" /&gt;&lt;/body&gt; 注意：这里使用H2数据库，太有用了。123456789101112131415@Configurationpublic class DataConfig &#123; @Bean public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("schema.sql") .build(); &#125; @Bean public JdbcOperations jdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 如果表单中没有发送username或password，会发生什么情况呢？或者名字太长，由会怎么样？，接下来，让我们看一下为表单添加校验，而从避免数据呈现不一致性。 5.4.2 校验表单如果用户在提交表单的时候，username和password为空的话，那么将会导致在新建Spitter对象中，username和password是空的String。如果不处理，将会出项安全问题。 同时我们应该阻止用户提交空的名字。限制这些输入的长度。 从Spring 3.0 开始，在Spring MVC中提供了java校验的API的支持。只需要在类路径下包含这个JavaAPI的实现即可。比如Hibernate validator. Java校验API定义了多个注解，这些注解可以用在属性上，从而限制这些属性的值。 @Size :所注解的元素必须是String、集合、或数组，并且长度要符合要求 @Null ：所注解的值必须为Null @NotNull ：所注解的元素不能为Null。 @Max ：所注解的必须是数字，并且值要小于等于给定制。 @Min @Past ：所注解的元素必须是一个已过期的日期 @Future ：必须是一个将来的日期 @Pattern：必须匹配给定的正则表达式 1234567891011121314151617181920212223242526public class Spitter &#123; private Long id; @NotNull @Size(min=5, max=16) private String username; @NotNull @Size(min=5, max=25) private String password; @NotNull @Size(min=2, max=30) private String firstName; @NotNull @Size(min=2, max=30) private String lastName; @NotNull @Email private String email; 忽略其他方法。&#125; 1234567891011@RequestMapping(value="/register", method=POST) //老外喜欢静态导入特性public String processRegistration( @Valid Spitter spitter, //校验Spitter输入 Errors errors) &#123; if (errors.hasErrors()) &#123; return "registerForm"; //如果校验出现错误，则重新返回表单 &#125; spitterRepository.save(spitter); return "redirect:/spitter/" + spitter.getUsername();&#125; Spitter参数添加了@Valid注解，这会告诉Spring，需要确保这个对象满足校验限制。 如果表单出错的话，那么这些错误可以通过Errors进行反问。 很重要一点需要注意的是：Errors参数要紧跟在带有Valid注解参数的后面。@Valid注解所标注的就是要校验的参数。 如果没有错误的话，Spitter对象将会通过Repository进行保存，控制器会像之前那样重定向到基本信息页面。 5.5 小节在本章中，我们为编写应用程序的Web部分开来一个好头，可以看到Spring有一个强大而灵活的Web框架。借助于注解，Spring MVC 提供了近似于POJO的开发模式，这使得开发处理请求的控制器变得简单，同时也易于测试。 当编写控制器的处理方法时，Spring MVC及其灵活。概括来讲，如果你的处理器方法需要内容的话，只需将对应的对象作为参数，而他不需要的内容，则没有必要出现在参数列表中。这样，就为请求带来了无限的可能性，同时还能保持一种简单的编程模型。 尽管本章中很多内容都是关于控制器的请求处理的，但是渲染响应也同样重要，我们通过使用JSP的方式，简单了解了如何为控制器编写视图，但是，就Spring MVC视图来说，它并不是本章所看到的简单JSP。 在接下来的第6章，我们将会更深入的学习Spring视图，包括如何在JSP中使用Spring标签库，还会学习如何借助于Apache Tiles为视图添加一致的结构。同时，还会了解Thymeleaf，这是一个很有意思的JSP替代方法，Spring为其提供了内置的支持。 参考：https://github.com/guoxiaoxu/SpringInActionPractice]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记四]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16-1%2F</url>
    <content type="text"><![CDATA[第四章 面向切面的Spring本章主要内容： 面向切面编程的基本原理 通过POJO创建切面 使用@Aspect注解 为AspectJ切面注入依赖。 在软件开发中，散布于应用中多出功能被称为横切关注点(crosscutting concern)。通常来讲横切关注点从概念上是与应用的业务逻辑分离的。但往往是耦合在一起的，把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。 依赖注入(DI)管理我们的应用对象，DI有助于应用对象之间解耦。而AOP可以实现横切关注点与它们所影响的对象之间的耦合。 4.1 什么是面向切面编程切面能够帮我们模块化横切关注点。简而言之，横切关注点可以被描述为影响应用多处的功能。例如 安全，事务、日志等功能。 如果要重用对象的话，最常见的面向对象技术是继承、委托、组合。但是，如果整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系。而使用委托可能需要委托对象进行复杂的调用。 切面提供了取代继承和委托的另一种可选方案。在使用面向切面编程时，我们仍然在一个地方定义通知功能，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面(aspect). 这样做带来两个好处：每个关注点都集中到一个地方，而不是分散到多处代码中：其次，服务模块更简洁，因为它只包含了主要关注点(核心功能)的代码。而次要关注的代码被移到切面中了。 4.1.1 定义AOP术语描述切面的常用术语有：通知(advice)、切点(pointcut)、连接点。 通知(advice)通知定义了切面是什么以及何时使用。除了描述切面要完成的工作外，通知还解决了何时执行这个工作问题。它应该在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？ Spring切面可以应用5中类型的通知： 前置通知(Before):在目标方法被调用之前调用通知功能。 后置通知(After):在目标方法完成之后调用通知 返回通知(After-returning):在目标方法成功执行之后调用通知 异常通知(After-throwing):在目标方法抛出异常后调用通知 环绕通知(Around):在被通知方法调用之前和调用之后执行自定义的行为 连接点我们的应用可能有数以千计的时机应用通知，这些时机被称为连接点。连接点是在应用执行过程中能够插入的一个点。这个点可以是调用方法时，抛出异常时，甚至修改一个字段时。切面可以利用这些点插入到应用的正常流程之中，并添加新的行为。 切点如果说通知定义了切面的的“什么”和“何时”，那么切点定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。 切面切面是通知和切点的结合。通知和切点通过定义了切面的全部 内容——他是什么，在什么时候和在哪里完成其功能。 引入引入允许我们向现有的类添加新的方法或者属性。 织入织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象。在目标对象的生命周期里有多个点可以进行织入： 编译期：切面在目标类编译时被织入。Aspect的织入编译器就是以这种方式织入切面的。 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载(Classloader)，它可以在目标类被引入之前增强该目标类的字节码(CGlib) 运行期：切面在应用运行时的某个时刻被织入。AOP会为目标对象创建一个代理对象。Spring AOP就是以这种方式织入切面的。 通知包含了需要用于多个应用对象的横切关注点。连接点是程序执行过程中能够应用通知的所有点。切点定义了通知被应用的具体位置(在哪些连接点)，其中关键是切点定义了哪些连接点会得到通知。 4.1.2 Spring对AOP的支持并不是所有的AOP框架都是相同的，他们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别的通知，而另一些只支持与方法调用相关的连接点。它们织入切面的方式和时机也有所不同。但是，无论如何，创建切点来定义切面所织入的连接点是AOP的基本功能。 **Spring提供了4种类型的AOP支持： 基于代理的经典Spring AOP（不推荐） 纯POJO切面 @AspectJ注解驱动的切面 注入式AspectJ切面** 前三种都是Spirng AOP实现的变体，Spring AOP构建在动态代理基础上。因此，Spring对AOP的支持局限于方法拦截。 引入了简单的声明式AOP与基于注解的AOP之后，Spring经典的看起来就显得非常笨拙和过于复杂话，直接使用ProxyFactory bean 会让人感觉厌烦。 借助于Spring的aop命名空间，我们可以将纯POJO转为切面。 Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP，但是编程模型几乎与编写成熟的AspectJ注解切面完全一致。这种AOP风格的好处在于能够不使用XML来完成功能。 Spring通知是Java编写的Spring所创建的通知都是用标准的Java类编写的，定义通知所应用的切点通常会使用注解或在Spring配置文件里采用XML来编写 Spring在运行时通知对象 通知带代理类中包裹切面，Spring在运行时把切面织入到Spring所管理的bean中。代理类封装了目标类，并拦截被通知方法的调用。再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。直到应用需要被代理bean时，Spring才会创建代理对象。如果使用ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有的bean的时候，Spring才会创建被代理的对象。因为Spirng运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。 Spring只支持方法级别的连接点Spring基于动态代理，所以Spring只支持方法连接点。方便拦截可以满足大部分的需求。 4.2 通过切点来选择连接点切点用于准确定位应该在什么地方应用切面的通知。通知和切点是切面最基本的元素。 Spring仅支持AspectJ切点指示器的一个子集。Spring是基于代理的，而某些切点表达式是基于代理的AOP无关的。 Spring支持的指示器，只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要的指示器。 4.2.1编写切点为了阐述Spring中的切面， 我们需要有个主题来定义切面的切点。 1234package com.guo.cocert;public interface Performance &#123; public void perform();&#125; 1execution(* concert.Performance.perform(..)) 我们使用execution()指示器选择Performance的perform()方法，方法表达式以”*”号开始，表明了我们不关心方法返回值的类型。然后指明了全限定类名和方法名，对于方法参数列表，我们使用了两个点号(..)表明切点要选择任意的perform()方法，无论该方法的入参是什么。 现在假设我们需要配置的切点仅匹配concert包，可以使用within()指示器 1execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*) 因为“&amp;”在XMl中有特殊的含义，所以在Spring和XML配置中，描述切点时，可以使用and代替“&amp;&amp;”。 4.2.2 在切点中选择beanSpring引入了一个新的bean()指示器，它允许我们在切点表达式中使用bean的ID来标识bean。bean()使用bean ID 或 bean 名称作为参数来限制切点只匹配特定的bean。 1execution(* concert.Performance.perform(..)) and bean("woodsotck") 也可以这样 1execution(* concert.Performance.perform(..)) and ！bean("woodsotck") 切面的通知会被编织到所有ID不为woodsotck的bean中。 4.3.1 定义切面如果一场演出没有观众的话，那不能称之为演出。对不对？从演出的角度来看，观众是非常 重要的，但是对演出本身的功能来讲，它并不是核心，这是一个单独的关注点。因此，将观 众定义为一个切面，并将其应用到演出上就是较为明智的做法。 下面展现了Audience类，它定义了我们所需的一个切面 1234567891011121314151617181920212223242526272829package com.spring.sample.concert;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class Audience &#123; @Before("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void silenceCellPhones() &#123; System.out.println("Silencing cell phones"); &#125; @Before("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void takeSeats() &#123; System.out.println("Taking seats"); &#125; @AfterReturning("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void applause() &#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; @AfterThrowing("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void demandRefund() &#123; System.out.println("Demand a refund"); &#125;&#125; Audience类使用@AspectJ注解进行了标注。该注解表明Audience不仅仅是一个POJO， 还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。 Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众 要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出 很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的 话，观众会要求退款（demandRefund()）。 可以看到，这些方法都使用了通知注解来表明它们应该在什么时候调用。AspectJ提供了五个 注解来定义通知，如表4.2所示。 你可能已经注意到了，所有的这些注解都给定了一个切点表达式作为它的值，同时，这四个 方法的切点表达式都是相同的。其实，它们可以设置成不同的切点表达式，但是在这里，这 个切点表达式就能满足所有通知方法的需求。让我们近距离看一下这个设置给通知注解的切 点表达式，我们发现它会在Performance的perform()方法执行时触发。 相同的切点表达式我们重复了四遍，这可真不是什么光彩的事情。这样的重复让人感觉有些 不对劲。如果我们只定义这个切点一次，然后每次需要的时候引用它，那么这会是一个很好 的方案。 幸好，我们完全可以这样做：@Pointcut注解能够在一个@AspectJ切面内定义可重用的 切点。接下来的程序清单4.2展现了新的Audience，现在它使用了@Pointcut。 1234567891011121314151617181920212223242526272829package com.spring.sample.concert;import org.aspectj.lang.annotation.*;@Aspectpublic class Audience &#123; @Pointcut("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void performance() &#123;&#125; @Before("performance()") public void silenceCellPhones() &#123; System.out.println("Silencing cell phones"); &#125; @Before("performance()") public void takeSeats() &#123; System.out.println("Taking seats"); &#125; @AfterReturning("performance()") public void applause() &#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; @AfterThrowing("performance()") public void demandRefund() &#123; System.out.println("Demand a refund"); &#125;&#125; 除了作为标记的 performance() 方法，Audience 类完全是一个 POJO，因此它也可以像普通 Java 类一样使用： 1234@Beanpublic Audience audience() &#123; return new Audience();&#125; 到此为止，Audience 仅仅是位于 Spring 容器中的一个 bean，即使它被 AspectJ 注解修饰，如果没有别的配置解释这个注解，并创建能够将它转换成切面的代理，则它不会被当做切面使用。 如果你使用 JavaConfig，则可以通过类级别的 @EnableAspectJAutoProxy 注解开启自动代理机制，例子代码如下所示： 12345678910111213141516package com.spring.sample.concert;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@EnableAspectJAutoProxy //开启AspectJ的自动代理机制@ComponentScanpublic class ConcertConfig &#123; @Bean public Audience audience() &#123; //定义Audience的bean return new Audience(); &#125;&#125; 如果你使用 XML 配置，则可以使用 &lt;aop: aspectj-autoproxy /&gt; 元素开启 AspectJ 的自动代理机制，对应的配置代码如下： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.spring.sample.concert&quot; /&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;bean class=&quot;com.spring.sample.concert.Audience&quot; /&gt;&lt;/beans&gt; 无论使用 JavaConfig 还是 XML 配置文件，AspectJ 的自动代理机制使用由 @Aspect 注解修饰的 bean 为那些被切点指定的 beans 创建代理。在这个例子中，将会为 Performance 接口创建代理，并在 perform() 方法调用前或者调用后应用切面中的通知方法。 特别要记住：Spring 中的 AspectJ 自动代理机制本质上还是 Spring 中基于代理的切面，因此，虽然你使用了 @Aspect 注解，但是仍然仅能支持函数调用级别的拦截。如果你希望使用 AspectJ 的功能，那么你得使用 AspectJ 的运行时并且不要使用 Spring 创建基于代理的切面。 环绕通知（around advice）与其他通知类型不同，因此值得用一小节单独论述。 4.3.2 创建环绕通知环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起 来。实际上就像在一个通知方法中同时编写前置通知和后置通知。 为了阐述环绕通知，我们重写Audience切面。这次，我们使用一个环绕通知来代替之前多 个不同的前置通知和后置通知。 12345678910111213141516171819202122package com.spring.sample.concert;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;@Aspectpublic class Audience &#123; @Pointcut(&quot;execution(* com.spring.sample.concert.Performance.perform( .. ))&quot;) public void performance() &#123;&#125; @Around(&quot;performance()&quot;) public void watchPerformance(ProceedingJoinPoint joinPoint) &#123; try &#123; System.out.println(&quot;Silencing cell phones&quot;); System.out.println(&quot;Taking seats&quot;); joinPoint.proceed(); System.out.println(&quot;CLAP CLAP CLAP!!!&quot;); &#125; catch (Throwable e) &#123; System.out.println(&quot;Demanding a refund&quot;); &#125; &#125;&#125; @Around 注解表示 watchPerformance() 方法将作为环绕通知应用在与切点——performance() 匹配的方法上。这个方法实现的效果跟之前的四个函数完全相同，但是有一点不同，即该函数有一个参数——ProceedingJoinPoint 实例，这里需要通过这个参数主动调用业务函数——joinPoint.proceed();。在环绕通知中必须调用 proceed() 方法，如果没有，则应用的执行会阻塞在通知方法中。 你还可以在一个通知中多次调用 proceed() 方法，从而可以实现重试逻辑——业务逻辑可能失败，可以限定失败重试的次数。 4.3.3 处理通知中的参数截止目前为止，我们编写的切面都非常简单——没有接收输入参数。仅有的例外是环绕通知中需要使用 ProceedingJoinPoint 参数，除此之外其他通知都没有携带任何参数传入被通知的方法中，那是因为 perform() 方法本身不需要任何参数。 如果你的切面要通知的是一个带参数的函数？切面是否能访问传入函数的参数并使用它们？举个例子说明，BlankDisc 类中有一个 play() 方法，该方法的功能是遍历所有的 tracks 并利用每个 track 对象调用 playTrack() 方法。 1234567891011121314151617181920212223242526272829303132package com.spring.sample.soundsystem;import org.springframework.stereotype.Component;import java.util.List;@Componentpublic class BlankDisc implements CompactDisc &#123; private String title; private String artist; private List&lt;String&gt; tracks; public BlankDisc() &#123; &#125; public BlankDisc(String artist, String title, List&lt;String&gt; tracks) &#123; this.artist = artist; this.title = title; this.tracks = tracks; &#125; public void play() &#123; System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist); for (String track: tracks) &#123; System.out.println(&quot;-Track: &quot; + track); &#125; &#125; public void playTrack(int num) &#123; System.out.println(&quot;-Track: &quot; + tracks.get(num)); &#125; //setter和getter在此处省略&#125; 现在你希望记录每个 track 被调用的次数，一种方法是直接修改 playTrack() 方法，通过一个全局变量（例如 Map 数据结构）记录每个 track 被调用的次数。但是，track-counting 这个逻辑跟 play track 实际上是两个不同的关注点，因此应该考虑通过 AOP 实现。 首先定义一个切面，即 TrackCounter 类，并在 playTrack() 方法出进行通知，代码可列举如下： 1234567891011121314151617181920212223242526package com.spring.sample.soundsystem;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import java.util.HashMap;import java.util.Map;@Aspectpublic class TrackCounter &#123; private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;Integer, Integer&gt;(); @Pointcut( &quot;execution(* com.spring.sample.soundsystem.CompactDisc.playTrack( .. )) &quot; + &quot;&amp;&amp; args(trackNumber)&quot;) public void trackPlayed(int trackNumber) &#123;&#125; @Before(&quot;trackPlayed(trackNumber)&quot;) public void countTrack(int trackNumber) &#123; int currentCount = getPlayCount(trackNumber); trackCounts.put(trackNumber, currentCount + 1); &#125; public int getPlayCount(int trackNumber) &#123; return trackCounts.containsKey(trackNumber) ？ trackCounts.get(trackNumber) : 0; &#125;&#125; 跟上一小节创建的切面类似，首先利用 @Pointcut 注解定义一个切点，然后利用 @Before 注解定义前置通知。不同的地方在于切点的定义，除了指定被通知的方法，还指定了被通知方法需要的参数 trackNumber。下图展示如何理解切点的定义。 关键在于 args(trackNumber) 标识符，这表示每个传入业务函数 playTrack() 的 int 参数也将被传入通知，而且，args() 中参数的名称必须跟切点方法的签名中的参数名称相同，例如： 1234@Pointcut( &quot;execution(* com.spring.sample.soundsystem.CompactDisc.playTrack( .. )) &quot; + &quot;&amp;&amp; args(ex)&quot;)public void trackPlayed(int ex) &#123;&#125; 同样，@Before 注解中利用切点函数定义的参数名称，也必须与通知方法签名中的参数完全相同，例如： 12345@Before(&quot;trackPlayed(duqi)&quot;)public void countTrack(int duqi) &#123; int currentCount = getPlayCount(duqi); trackCounts.put(duqi, currentCount + 1);&#125; 然后在 Spring 的配置文件中配置 BlankDisc 和 TrackCounter，并开启 AspectJ 自动代理机制，配置文件代码如下： 1234567891011121314151617181920212223242526272829303132package com.spring.sample.soundsystem;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;import java.util.ArrayList;import java.util.List;@Configuration@EnableAspectJAutoProxypublic class TrackCounterConfig &#123; @Bean public CompactDisc sgtPeppers() &#123; BlankDisc cd = new BlankDisc(); cd.setTitle(&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;); cd.setArtist(&quot;The Beatles&quot;); List&lt;String&gt; tracks = new ArrayList&lt;String&gt;(); tracks.add(&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;); tracks.add(&quot;With a Little Help from My Friends&quot;); tracks.add(&quot;Lucky in the Sky with Diamonds&quot;); tracks.add(&quot;Getting Better&quot;); tracks.add(&quot;Fixing a Hole&quot;); tracks.add(&quot;testtest&quot;); tracks.add(&quot;hhhhhhhhhh&quot;); cd.setTracks(tracks); return cd; &#125; @Bean public TrackCounter trackCounter() &#123; return new TrackCounter(); &#125;&#125; 最后，为了验证我们的想法，需要写个单元测试用例进行验证，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738package com.spring.sample.soundsystem;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.*;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = TrackCounterConfig.class)public class TrackCounterTest &#123; @Autowired private CompactDisc cd; @Autowired private TrackCounter counter; @Test public void testTrackCounter() &#123; cd.playTrack(0); cd.playTrack(1); cd.playTrack(2); cd.playTrack(2); cd.playTrack(2); cd.playTrack(2); cd.playTrack(6); cd.playTrack(6); assertEquals(1, counter.getPlayCount(0)); assertEquals(1, counter.getPlayCount(1)); assertEquals(4, counter.getPlayCount(2)); assertEquals(0, counter.getPlayCount(3)); assertEquals(0, counter.getPlayCount(4)); assertEquals(0, counter.getPlayCount(5)); assertEquals(2, counter.getPlayCount(6)); &#125;&#125; TrackCounter 这个切面可以在显存函数的基础上进行进一步封装，不过除了函数封装，还可以利用切面给被通知的对象引入新的功能。 4.3.4 使用基于注解的切面引入新功能在一些动态语言（Ruby、Groovy）中，存在开放类的特性，这种特性支持在不修改原来类或者对象的基础上为该类添加新方法。不过，Java 不是动态语言，一旦一个类被编译，你几乎不能再对它进行修改。 不过，仔细思考下，上述说的这个需求：在不修改原有类的基础上为该类添加新方法，这不正是切面可以完成的工作么？在上个小节的例子中我们是为原有类的方法添加了新的功能，同样，也可以为原来的类添加新的方法。这里通过 AOP 引出一个新的概念引入（introductions），即通过切面为 Spring 的 beans 增加新方法。 Spring 中切面的本质就是一个代理对象，这个代理对象与目前对象实现同一个接口。既然如此，那么可以扩展一下，如果代理对象实现新的接口呢？这样被这个切面通知的 bean 就好像又实现了一个新的接口——增加了新的功能，即使底层并没有修改原来的类。下图展示了这个思路： 当 introduced 接口的某个方法被调用时，代理对象会把这个调用委托给一个实现了该 introduced 接口的对象。对于外部而言，就好像一个 bean 实现了多个接口。 举个例子，假设你要把下面这个 Encoreable 接口引入给 Performance 接口的任何实现。 123public interface Encoreable &#123; void performEncore();&#125; 你当然可以让原来 Performance 接口的实现也同时实现这个接口，但是关键是并不是所有的 Performance 实现都需要引入 Encoreable；而且，从应用维护的角度看，全部修改 Performance 的实现容易引入新的 bug；另外，如果 Performance 接口来自第三方库，你也没有办法接触到源码。 那么利用 Spring AOP 如何操作呢？首先准备一个 introduced 接口的默认实现类，代码如下： 1234567package com.spring.sample.concert;public class DefaultEncoreable implements Encoreable &#123; public void performEncore() &#123; System.out.println(&quot;perform the encore!&quot;); &#125;&#125; 然后新建一个切面，即 EncoreableIntroducer 类，代码列举如下： 1234567891011package com.spring.sample.concert;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.DeclareParents;@Aspectpublic class EncoreableIntroducer &#123; @DeclareParents(value = &quot;com.spring.sample.concert.Performance+&quot;, defaultImpl = DefaultEncoreable.class) public static Encoreable encoreable;&#125; EncoreableIntroducer 是一个切面，但和之前学过的切面不同在于它没有定义各种通知，它通过 @DeclareParents 注解将 Encoreable 接口引入到 Performance 接口的实现中。 @DeclareParents注解由三部分组成： value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现 Performance的类型。（标记符后面的加号表示是Performance的所有子类型，而 不是Performance本身。） defaultImpl属性指定了为引入功能提供实现的类。在这里，我们指定的 是DefaultEncoreable提供实现。 @DeclareParents注解所标注的静态属性指明了要引入了接口。在这里，我们所引入 的是Encoreable接口。 跟其他切面的用法类似，需要在 Spring 应用上下文中定义 EncoreableIntroducer bean，如果使用 JavaConfig，则代码如下： 1234@Beanpublic EncoreableIntroducer encoreableIntroducer() &#123; return new EncoreableIntroducer();&#125; Spring 的自动代理机制从这里获取这个 bean。当 Spring 发现一个被 @Aspect 注解修饰的 bean，就会自动为它创建一个代理对象，负责将外部的函数调用委托给目标 bean 或者新引入接口的实现，至于由哪个实现负责执行，取决于这个函数属于原接口还是新引入的接口。 书中没有的如果这个小节只说到这，你可能会有疑惑，那你说的这个引入新接口这么牛，什么场景下怎么使用呢？针对这个疑惑，我写了一个单元测试，代码如下： 12345678910111213141516171819202122package com.spring.sample.soundsystem;import com.spring.sample.concert.ConcertConfig;import com.spring.sample.concert.Encoreable;import com.spring.sample.concert.Performance;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = ConcertConfig.class)public class EncoreIntroducerTest &#123; @Autowired private Performance musicPerformance; @Test public void testEncore() &#123; Encoreable encoreable = (Encoreable)musicPerformance; //使用方法 encoreable.encore(); &#125;&#125; 可以看到，本来 musicPerformance 是 Performance 的实现，通过强转，我可以调用新接口中的方法了，而且没有修改原来的类和接口；而中间负责将函数调用委托给不同的实现对象的任务就是由切面自动完成。 4.4 在XML中声明切面之前，有这样一条原则：那就是基于注解的配置要优于Java的配置，基于Java的配置要优于XMl的配置，但是，如果你需要声明切面，但是又不能为通知类添加注解的时候 ，那么就必须转向XML配置了。 在Spring的aop命名空间中，提供了多个元素用来在XML中声明切面， 4.4.1 声明前置通知和后置通知我们会使用Spring aop命名空间中的一些元素，将没有注解的Aurience类转为切面 12345678910111213&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:before pointcut="execution(* * concert.Performance.perform(..))" method="silenceCellIphones"/&gt; &lt;aop:before pointcut="execution(* * concert.Performance.perform(..))" method="takeSeats"/&gt; &lt;aop:after-returning pointcut="execution(* * concert.Performance.perform(..))" method="applause"/&gt; &lt;aop:after-throwing pointcut="execution(* * concert.Performance.perform(..))" method="demandRefund"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 第一需要注意的就是大多数AOP配置元素必须在aop:config元素的上下文中使用。 在所有的通知元素中，pointcut属性定义了通知所应用的切点，它的值是使用AspectJ切点表达式语法所定义的切点。 在基于Aspectj注解的通知中，当发现在这些类型的重复时，使用@Pointcut注解来消除这些重复的内容。 如下的XMl配置展示了如何将通用的切点表达式抽取到一个切点声明中，这样，这个声明就能在所有的通知元素中使用了 1234567891011121314&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:pointcut id="performance" expression="execution(* * concert.Performance.perform(..))" /&gt; &lt;aop:before pointcut="" method="silenceCellIphones"/&gt; &lt;aop:before pointcut-ref="performance" method="takeSeats"/&gt; &lt;aop:after-returning pointcut-ref="performance" method="applause"/&gt; &lt;aop:after-throwing pointcut-ref="performance" method="demandRefund"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 现在的切点是一个地方定义的，并且被多个通知元素所引用，aop:pointcut元素定义了一个id为performance的切点，同时修改所有的通知元素，用pointcut0ref来引用这个命名切点。 4.4.2 声明环绕通知例如，假设除了进场关闭手机和表演结束后鼓掌，我们还希望观众确保一直关注演出，并报 告每个参赛者表演了多长时间。使用前置通知和后置通知实现该功能的唯一方式是在前置通 知中记录开始时间并在某个后置通知中报告表演耗费的时间。但这样的话我们必须在一个成 员变量中保存开始时间。因为Audience是单例的，如果像这样保存状态的话，将会存在线 程安全问题。 相比于前置通知和后置通知，环绕通知在这点上有明显的优势。使用环绕通知，我们可以完成前置通知和后置通知所实现的相同功能，而且只需要在一个方法中实现。因为整个通知逻辑都是在一个方法中实现的。 12345678&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:pointcut id="performance" expression="execution(* * concert.Performance.perform(..))" /&gt; &lt;aop:around pointcut-ref="performance" method="watchPerformance"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 像其他通知的XML元素一样，aop:around指定了一个切点和一个通知方法的名字。 4.4.3 为通知传递参数12 区别在于切点表达式中包含了一个参数，这个参数传递到通知方法中。还有区别就是这里使用了and关键字 4.4.4 通过切面引入新的功能借助于AspectJ的@DeclareParents注解为被通知的方法引入新的方法。但是AOP引入并不是Aspectj特有的。使用Spring aop命名空间中的aop:declare-parents元素，我们可以实现相同的功能 12345678&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:declare-parents types-matching="concert.Performance" implement-interface="concert.Encoreable" default-impl="concert.DefaoultEncoreable" &lt;/aop:aspect&gt; &lt;/aop:config&gt; 4.5 注入AspectJ切面虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP是一个功能比较弱的AOP解决方案，ASpect提供了Spring AOP 所不能支持的许多类型的切点。 Spring不能像之前那样使用声明来创建一个实例—-它已经在运行时由AspectJ创建完成了，Spring需要通过工厂方法获取切面的引用。然后像元素规定的那样在该对象上执行依赖注入 4.6 小节(重点中的重点)AOP是面向对象编程的一个强大补充，通过AspectJ，我们现在可以把之前分散在应用各处的行为放入可重用的模块中。我们显示地声明在何处如何应用该行为。这样有效减少了代码冗余，并让我们的类关注自身的主要功能。 Spring提供了一个AOP框架，让我们把切面插入到方法执行的周围。现在我们已经学会了如何把通知织入前置，后置和环绕方法的调用中，以及为处理异常增加自定义行为。 关于在Spirng应用中如何使用切面 ，我们可以有多种选择。通过使用@AspectJ注解和简化的配置命名空间，在Spring中装配通知和切点变得非常简单 最后，当Spring不能满足需求时，我们必须转向更为强大的AspectJ。对于这些场景，我们了解了如何使用Spring为AspectJ切面注入依赖。 此时此刻，我们已经覆盖了Spring框架的基础知识，了解到如何配置Spring容器以及如何为Spring管理的对象应用切面，这些技术为创建高内聚，低耦合的应用奠定了坚实的基础。 从下一章开始，首先看到的是如何使用Spring构建Web应用。。 参考：https://github.com/guoxiaoxu/SpringInActionPracticehttps://www.jianshu.com/p/8b95db8d7a1f]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记三]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16%2F</url>
    <content type="text"><![CDATA[第三章 高级装配本章内容： Spring profile 条件化的bean声明 自动装配与歧义性 bean的作用域 Spring表达式语言 本章中所介绍的技术也许你不会天天用到，但这并不意味着它们的价值会因此降低 3.1环境与profile在软件开发的时候，有一个很大的挑战就是将应用从一个环境迁移到另外一个环境。开发阶段中，某些环境相关的做法可能并不适合迁移到生产环境中，甚至即便迁移过去也无法工作。数据库配置、加密算法以及外部系统的集成是跨环境部署 在开发环境中，我们可能会使用切入式数据库，并预先加载测试数据。在Spring配置类中，可能会在一个带有@Bean注解的方法上使用EmbededDataBaseBuilder: 12345678@Bean(destroyMethod="shutdown")public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build();&#125; 这会创建一个类型为javax.sql.dataSource的bean，使用EmbededDatabaseBuilder会搭建一个切入式的Hypersonic数据库，它的模式(schema)定义izaischema.sql中，测试数据则是通过test-data.sql。 当你在开发环境中集成测试或者启动应用进行手动测试的时候非常有用。每次启动它的时候，都能让数据库处于一个给定的状态 尽管创建的DataSource非常适合于开发环境中，但是对于生产环境来说，这是一个糟糕的选择。在生产环境中你可能希望使用JNDI从容器中获取一个DataSource。 12345678@Beanpublic DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject();&#125; 通过JNDI获取的DataSource能够让容器决定如何创建这个DataSource，甚至包括切换为容器管理的连接池，即便如此，JNDI管理的Datasource更加适合与生产环境，对于简单的集成和开发测试来说，这会带来不必要的复杂性。 同时，在QA环境中，你可以选择完全不同的DataSource配置，可以配置为Commons DBCP连接池。 1234567891011@Bean(destroyMethod = "close")public DataSource dataSourceAO() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl("jdbc:h2:tcp://dbserver/～/test"); dataSource.setDriverClassName("org.h2.Driver"); dataSource.setUsername("guo"); dataSource.setPassword("guo"); dataSource.setInitialSize(20); dataSource.setMaxActive(30); return dataSource;&#125; 看起来简单的DataSource实际上并不是那么简单。它表现了在不同环境中某个bean会有所不同。我们必须有一种方式来配置DataSource，使其在每种环境下都会选择最为合适的配置。 其中一种方式就是在单独的配置类(或XML)中配置每个bean，然后在构造阶段确定要使用哪一个配置编译到可部署的环境中。这种方式的问题在于要为每种环境重新构建应用，当从开发阶段迁移到QA阶段时，重新构造也算不上什么大问题。但是，从QA阶段迁移到生产环境阶段时，重新构建可能引入BUG并且会在QA团队的成员中带来不安的情绪 3.1.1 配置profile beanSpring并不是在构造的时候做出这样的决策，而是到运行时再来确定，这样的结果就是在同一个部署单元能够适应所有的环境，没有必要重新构建. Spring引入了bean profile的功能，要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署到每个环境时，要确保对应的profile处于激活状态。 在Java配置中，可以使用@profile注解指定某个bean属于哪一个profile。 123456789101112@Configuration@Profile("dev")public class DataSourceConfig &#123; @Bean(destroyMethod="shutdown") public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build(); &#125;&#125; 需要注意的是@Profile注解应用到了类级别啥概念，它会告诉Spring这个配置来中的bean只有在dev profile激活时才创建。如果dev profile没有激活的话，那么带有@Bean注解的方法都会被忽略。 同时你可能需要一个适用于生产环境的配置 12345678910111213@Configuration@Profile("prod")public class DataSourceConfig &#123; @Bean public DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125;&#125; 在Spring3.1，只能在类级别上使用@Profile注解，不过在Spring3.2开始，你也可以在方法级别上使用@Profile注解，与@Bean注解一同使用，这样的话，就能将两个bean的声明放在同一个配置类中。 123456789101112131415161718192021222324252627282930313233343536/** * Created by guo on 22/2/2018. */@Configurationpublic class DataSourceConfig &#123; @Bean(destroyMethod="shutdown") @Profile("dev") public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build(); &#125; @Bean @Profile("prod") public DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125; @Bean(destroyMethod = "close") public DataSource dataSourceAO() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl("jdbc:h2:tcp://dbserver/～/test"); dataSource.setDriverClassName("org.h2.Driver"); dataSource.setUsername("guo"); dataSource.setPassword("guo"); dataSource.setInitialSize(20); dataSource.setMaxActive(30); return dataSource; &#125;&#125; 尽管每个DataSource bean 都被声明在一个profile中，并且只能当规定的profile激活时，相应的bean才会被创建，但是可能会有其他的bean并没有声明到一个给定的profile范围内。没有指定的profile的bean都会创建，与激活哪个profile没有关系 在XMl中配置profile我们也可以通过元素的profil属性，在XML中配置profile bean。 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ................................................................ &lt;beans profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; &lt;jdbc:script location="classpath:schema.sql" /&gt; &lt;jdbc:script location="classpath:test-data.sql" /&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile="qa"&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:url="jdbc:h2:tcp://dbserver/～/test" p:driverClassName="org.h2.Driver" p:username="guo" p:password="guo" p:initialSize="20" p:maxActive="39"/&gt; &lt;/beans&gt; &lt;beans profile="prod"&gt; &lt;jee:jndi-lookup id="dataSource" lazy-init="true" jndi-name="jdbc/myDatabase" resource-ref="true" proxy-interface="javax.sql.DataSource" /&gt; &lt;/beans&gt;&lt;/beans&gt; 除了所有的bean定义到同一个XML文件中，这种配置方式与定义单独的XML文件中实际效果是一样的。在运行时，只会创建一个bean，这取决于处于激活状态的是哪一个profile 3.1.2激活profileSpring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：sring.profiles.active和spring.profiles.default。如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active的话，那么Spring将会查找spring.profiles.default的值。如果两者都没有的话，那就没有激活的profile。 有多种方式来设置这两个属性 作为DispatcherServlet的初始化参数 作为Web的应用上下文参数 作为JNDI条目 作为环境变量 作为JVM的系统属性 在集成测试类上 作者喜欢的一种方式是使用DisPatcherServlet的参数将spring.profiles.default设置为开发环境，会在Servlet上下文中进行设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;taotao-rest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--为上下文设置默认的profile--&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- springmvc的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;taotao-rest&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+"-servlet.xml" --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--为Servlet设置默认的profile--&gt; &lt;init-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;taotao-rest&lt;/servlet-name&gt; &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 按照这种方式设置spring.profiles.default,所有开发人员能从版本控制软件中获得应用的程序源码，并使用开发环境的设置(如切入式数据库)运行代码而不需要任何额外的设置。 当应用程序部署到QA、生产、或其他环境中时，负责部署的人根据情况使用系统属性、环境变量、或JNDI设置spring.profiles.active即可。当设置spring.profiles.avtive后，至于spring.profiles.default设置成什么已经无所谓了：系统会优先使用spring.profiles.active中设置的profile 使用profi进行测试当运行集成测试时，通常会希望采用与生产环境相同的配置进行测试。但是，如果配置中的bean定义在了profile中，那么在测试运行时，我们就需要有一种方式来启动profile Spring提供了@ActiveProfiles注解，可以用它来指定运行测试时要激活哪个profile。在集成测试时，通常想要激活的是开发环境的profile。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import static org.junit.Assert.*;public class DataSourceConfigTest &#123; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = DataSourceConfig.class) @ActiveProfiles("dev") public static class DevDataSource&#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbededDatasourcr() &#123; JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query("select id, name from Things", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong("id") + ":" + rs.getString("name"); &#125; &#125;); assertEquals(1,results.size()); assertEquals("1:A",results.get(0)); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes=DataSourceConfig.class) @ActiveProfiles("prod") public static class ProductionDataSourceTest &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; // 应该是Null ，因为在JNDI中没有配置数据源 assertNull(dataSource); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:datasource-config.xml") @ActiveProfiles("dev") public static class DevDataSourceTest_XMLConfig &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; assertNotNull(dataSource); JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query("select id, name from Things", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong("id") + ":" + rs.getString("name"); &#125; &#125;); assertEquals(1, results.size()); assertEquals("1:A", results.get(0)); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:datasource-config.xml") @ActiveProfiles("prod") public static class ProductionDataSourceTest_XMLConfig &#123; @Autowired(required=false) private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; // 应该是Null ，因为在JNDI中没有配置数据源 assertNull(dataSource); &#125; &#125;&#125; 在条件化创建bean，Spring的profil机制是一种很好的方法，这里的条件要基于哪个profile处于激活状态来判断。Spring 4.0中提供了一种更为通用的机制来实现条件化的bean定义，这这种机制之中，条件化 完全由你来取定，Spring 4 和@Conditional注解定义条件化的bean。 3.2 条件化的bean假设你希望一个或所个bean只有在类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才创建，我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。 在Spring 4之前，很难实现这种级别的条件化配置，但是Spring 4.0 引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。 下面我们就根据环境变量中有没有magic变量来决定是否创建MagicBean: 1234567891011121314151617package com.cache.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;import com.cache.conditional.MagicExistsConditional;import com.cache.service.MagicBean;@Configurationpublic class ConditionalConfig &#123; @Bean @Conditional(MagicExistsConditional.class) //条件化的创建bean public MagicBean magicBean() &#123; return new MagicBean(); &#125;&#125; 可以看到MagicBean是否创建取决于@Conditional(MagicExistsConditional.class)中的情况，那么给@Conditional中的参数又是什么类型的呢，请看： 12345678910111213141516package com.cache.conditional;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class MagicExistsConditional implements Condition&#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment evn = context.getEnvironment(); return evn.containsProperty("magic"); &#125;&#125; 如你所见，设置给@Conditional的类可以是任意实现了Condition接口的的类型。而实现这个接口只需要实现matches方法，如果matches方法返回 true 就创建该 bean，如果返回 false 则不创建 bean，上例中我们就是根据环境变量中是否存在magic变量，来决定matches的返回值，进而决定是否创建MagicBean的。上例中我们只是使用到了ConditionContext的到Environment, 但Condition实现的考量因素可能会比这多的多。maches()方法会得到ConditionContext和AnnotatedTypeMetadata对象用来做决策。其实ConditionContext是一个接口： 1234567891011121314151617181920package org.springframework.context.annotation;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.core.env.Environment;import org.springframework.core.io.ResourceLoader;public interface ConditionContext &#123; BeanDefinitionRegistry getRegistry(); ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); ClassLoader getClassLoader();&#125; 通过 ConditionContext，我们可以做到如下几点： 方法 作用 getRegistry() 借助返回的 BeanDefinitionRegistry 检查 bean 的定义 getBeanFactory() 借助返回的 ConfigrableListableBeanFactory 检查是否存在，甚至检查 bean 的属性 getEnvironment() 借助返回 Environment 检查环境变量是否存在以及读取它的值是什么 getResourceLoader() 读取并检查它返回的 ResourceLoader 所加载的资源 getClassLoader() 借助它的返回的 ClassLoader 加载并检查类是否存在 AnnotatedTypeMetadata则能够让我们检查带有 @Bean 注解的方法上是否有其他注解： 1234567891011121314151617181920package org.springframework.core.type;import java.util.Map;import org.springframework.util.MultiValueMap;public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String annotationType); Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType); Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType, boolean classValuesAsString); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType, boolean classValuesAsString);&#125; 借助 isAnnotated() 方法，我们能够判断带有 @Bean 注解的方法是不是还有其他特定的注解。借助其他的方法，我们能够检查 @Bean 注解的方法上其他注解的属性。下面我们来看一下 Spring 4 使用 @Conditional 对 @Profile 的重构： 123456789101112131415161718192021package org.springframework.context.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.env.AbstractEnvironment;import org.springframework.core.env.ConfigurableEnvironment;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123; String[] value();&#125; @Profile的实现定义使用了，@Conditional注解和Condition接口，如下，ProfileCondition实现了Condition，并在matches方法中做出了是否创建@Profile的决策： 1234567891011121314151617181920212223242526package org.springframework.context.annotation;import org.springframework.core.type.AnnotatedTypeMetadata;import org.springframework.util.MultiValueMap;class ProfileCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if (context.getEnvironment() != null) &#123; MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) &#123; for (Object value : attrs.get("value")) &#123; if (context.getEnvironment().acceptsProfiles(((String[]) value))) &#123; return true; &#125; &#125; return false; &#125; &#125; return true; &#125;&#125; 我们可以看到，ProfileCondition通过AnnotatedTypeMetadata得到了用于 @Profile 注解的所有属性。借助该信息，他会明确地检查 value 属性，该属性包含了 bean 的 profile 名称。然后根据ConditionContext得到的Environment 来检查【借助acceptsProfiles()方法】该profile是否处于激活状态。 3.3 处理自动装配的歧义性之前，我们已经看到了如何使用自动装配让Spirng完全负责将bean引用注入到构造函数和属性中，自动装配能够提供很大的帮助，因为它会减少装配应用程序组件时所需的显示配置的数量。 不过仅有一个bean匹配所需的结果时，自动装配才是有效的。如果不仅一个bean能够匹配结果的话，这种歧义性会阻碍Spring自动装配属性、构造器或方法参数 为了阐述自动装配的歧义性，假设我们提供@Autowired注解标注了setDessert方法 1234@Autowiredpublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; Dessert是一个接口，并且有三个类实现了这个接口 12345678@Componentpublic class Cake implements Dessert &#123;...&#125;@Componentpublic class Cookies implements Dessert &#123; ...&#125;@Componentpublic class IceCream implements Dessert &#123;...&#125; 因为这三个实现均使用@Component注解，在组件进行扫描的时候，能够发现他们并将其创建为Spring应用上下文里面的bean，然后，当Spring试图自动装配的setDessert()中的Dessert参数时，它们并没有唯一、无歧义的可选值。 Spring此时别无选择，只好宣告失败并抛出异常，更准确的将。Spring会抛出：NoUniqueBeanDefinitionException 当Spring发生歧义时，Spring提供了多种可选方案来解决这样的问题。你可以将可选bean的某一个设为首选(primary)的bean，或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。 3.3.1 表示首选的bean在声明bean的时候，通过将一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。当遇到歧义性的时候，Spring将会使用首选的bean，而不是其它可选的bean。 假设冰激凌就是你最喜欢的甜点，在Spring中，可以通过@Primary来表达最喜欢的方案。@Primary能够与@Componnet组合用在组件扫描的bean上，也可以与@Bean组合用在Java配置的声明中。123@Component@Primarypublic class IceCream implements Dessert &#123;...&#125; 或者你通过JavaConfig显示配置地声明IceCream， 12345@Bean@Primarypublic Dessert IceCream() &#123; return new IceCream();&#125; 如果你喜欢使用XML配置bean的话，同样可以实现这样的功能。 123&lt;bean id="ceCream" class="com.guo.IceCream" primary="true"/&gt; 如果你标注了两个或者多个首选bean，那么就无法工作了。 123@Component@Primarypublic class Cake implements Dessert &#123; ...&#125; 就解决歧义性问题而言，限定符是一种更为强大的机制 3.2.2 限定自动装配的bean设置首选bean的局限性在于@Primary无法将可选方案的范围限定到唯一一个无歧义的选项中。它只能表示一个优先的可选方案。 Spring的限定符能够在所有可选的bean上进行缩小范围的操作，最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小范围。 @Qualifier注解是使用限定符的主要方式。它可以与@Autowired和Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。例如,我们确保要将IceCream注入到setDessert()之中。 12345@Autowired@Qualifier("iceCream")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; @Qualifier(“iceCream”)指向的是组件扫描时所创建的bean，并且这个bean是IceCream的实例。更具体一点：@Qualifier(“iceCream”)所引用的bean要具有String类型的“iceCream”作为限定符。没有没有则和ID一样。 基于默认的bean ID作为限定符是非常简单的，但这有可能会引入一些问题。如果你重构了IceCrean类，将其重名为“Gelato”的话，那此时会发生什么情况？如果是这样的话，bean的默认ID和默认的限定符会变为gelato，这就无法匹配setDessert()方法中的限定符，自动装配会失败。 这里的问题在于setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会导致限定符失败。 创建自定义的限定符我们可以为bean设置自己的限定符，而不是依赖于将ID作为限定符。在这里所需要做的就是在bean声明上加@Qualifier注解。 123@Component@Qualifier("cold")public class IceCream implements Dessert &#123;...&#125; 在这种情况下，cold限定符分配了IceCream bean。因为它没耦合类名，因此你可以随意重构IceCream，而不必担心会破坏自动装配。 在注入的地方，只要引用cold限定符就可以了 12345@Autowired@Qualifier("cold")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; 值得一提的是，当通过Java配置显式定义bean的时候i@Qualifier也可以与@Bean注解一起。 12345@Bean@Qualifierpublic Dessert dessert () &#123; return new IceCream();&#125; 当使用自定义的@Qualifier值时，最佳实践是为bean选择特征性或描述性的术语，而不是使用随意的名字。 使用自定义的限定符注释面向特性的限定符要比基于bean ID的限定符更好一些。但是如果多个bean都具备这个相同的特性的话，这种做法也会出现问题。 这里只有一个小问题：Java不允许在同一个条目上重复出现相同类型的多个注解。如果你试图这样做的话，编译器将会出错。 但是我们可以创建 自定义的注解，借助这样的注解来表达bean所希望限定的特性。这里需要做的就是创建一个注解，它本身要使用@Qualifier注解来标注。 1234@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface cold &#123;&#125; 当你不想用 @Qualifier注解的时候，可以类似的创建@Sort、@Crispy和@Fruity。通过在定义时添加@Qualifier注解。它就具有了@Qualifier注解的特性。 现在我们重新看一下IceCream，并为其添加@Cold和@Creamy注解 1234@Component@Clod@Creamypublic class IceCream implements Dessert &#123;...&#125; 类似的，Popsicle类可以添加@Cold和@Fruity注解 1234@Component@cold@Fruitypublic class Popsicle implements Dessert &#123;...&#125; 最终，在注入点，我们使用必要的限定符注解进行任意组合，从而将可选的范围缩小到只有一个bean满足需求。 为了得到IceCream bean 和 setDessert()方法可以这样使用注解： 123456@Autowired@Cold@Creamypublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; 通过声明自定义的限定符注解，我们可以同时使用多个限定符，不会再有Java编译器的限制或错误，与此同时，相对于原始的@Qualifier并借助于String类型来指定限定符，自定义的注解也是类型安全的。 在本节和前节中，我们讨论了几种通过自定义注解扩展Spring的方式，为了创建自定义的条件化注解，我们建议一个新的注解并在这个注解上添加了Conditional，为了创建自定义的限定符注解，我们创建一个新的注解并在这个注解上添加了@Qualifer。这种技术可以用到很多Spring注解中，从而能够将他们组合在一起形成特定目标的自定义注解。 3.4 bean的作用域默认情况下，Spring应用上下文中所有的bean都是作为以单例(singleton)的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多次，每次所注入的都是同一个bean。 在大多数情况下，单例bean是很理想的方案，初始化和垃圾回收对象实例所带来的成本只有一些小规模任务。在这些任务中，让对象保持无状态并且在应用中反复使用这些对象可能并不合理。 有时候可能发现，你所使用的类是异变的(mutable)，它们会保持一些状态，因此重复使用时不安全的。在这种情况下将class声明为单例的bean就不是什么好主意了。因为会污染对象，稍后重用的时候会出现意想不到的问题。 Spring定义了多种作用域可以基于这些作用域创建bean，包括： 单例(singleton):在整个应用中，只创建bean的一个实例 原型(prototype):每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例 会话(Session):在Web应用中，每个会话创建一个bean实例 请求(Request):在Web应用中，为每个请求创建一个bean实例。 单例是默认的作用域，但是正如之前所述，对于异变的类型，这并不适合。如果要选择其他作用域，要使用@Scope注解，它可以与@Component或@Bean一起使用。 如果你使用组件扫描来发现bean和生命bean，那么你可以在bean的类上使用@Scope注解，并将其声明为原型bean 1234@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class NotePad &#123;&#125; 在这里，使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常量设置了原型作用域。你当然可以使用@Scope(“prototype”),但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。 如果你想在JavaConfig中将NotePad声明为原型bean，那么可以组合使用@Scope和@Bean来指定所需的作用域 12345@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public NotePad notepad &#123; return new NotePad();&#125; 如果你想使用XMl来配置bean的话，你可以使用bean元素的scope属性来设置作用域123&lt;bean id="notepad" class="com.guo.myapp.NotePad" scope="prototype" 不管你使用哪种方式来声明作用域，每次注入或从Spirng应用上下文中检索该bean的时候，都会创建新的实例。这样导致的结果就是每次操作都能得到自己的NotePad实例。 3.4.1 使用会话和请求作用域在Web应用中，如果能够实例化在会话和请求范围内共享的bean，那将是非常有价值的事。例如：在典型的电子商务中，可能会有一个bean代表用户的购物车，如果这个购物车是单例的话，那么 将导致所有的用户都会像同一个购物车中添加商品。另一方面，如果购物车是原型作用域，那么在应用中某一个地方往购物车添加商品，在应用的另外一个地方可能就不可用了。因为这里注入的是另外一个原型作用域的购物车。就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大，要指定会话作用域，我们可以使用@Scope注解，它的使用方式和原型作用域是相同的。 1234@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public ShoppingCart cart() &#123;...&#125; 这里我们将value设置成WebapplicationConext.SCOPE.SESSION。这会告诉Spring为Web应用中的每个会话创建一个ShoppingCart。 需要注意跌是，@Scope同时还有另外一个ProxyMode属性，它被设置成了ScopeProxyMode.INTERFACES。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。在描述ProxyMode属性之前，我们先来看下proxyMode所解决问题的场景。 假设我们要将ShoppingCart bean 注入到单例StoreService bean的Setter方法中 1234567@Componentpublic class StoreService &#123;@Autowiredpublic void setShoppingCart(ShoppingCart shoppingCart) &#123; this.shoppingCart = shoppingCart;&#125;&#125; 因为StoreService是一个单例bean，会在Spring应用上下文加载的时候创建，当它创建的时候，Spring会试图将ShoppingCart注入到SetShoppingCart方法中，但是ShoppingCart是会话作用域的，此时并不存在。直到用户进入系统，创建了会话之后，才会出现ShoppingCart实例。 另外系统中将会有多个实例：每个用户一个。我们并不想让Spirng注入到某个固定的ShoppingCart实例到StoreService中，我们希望的是当StoreService处理购物车的时候，他所用使用的ShoppingCart实例恰好是当前会话所对应的一个。 Spring并不会将实例的ShoppingCart bean注入到StoreService，Spring会注入一个到ShoppingCart的代理。这个代理会暴露于ShoppingCart相同的方法。所以StoreService就会认为他是一个购物车。 但是当StoreService调用ShoppingCart的方法方法时，代理会对其进行解析，并将调用委托给会话作用域内真正的ShoppingCart。 现在我们带着这个 作用域的理解，讨论一下ProxyMode属性，如配置所示，proxyMode属性被设置成了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean 如果ShoppingCart是接口，而不是类的话，这是可以的，但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了，此时，它必须使用CGLIB来生成基于类的代理。所以，如果bean类型是具体的类的话，我们必须要将ProxyMode属性设置为ScopedProxyMOde.TARGET_CLASS.以此来表明要以生成目标类 扩展的方法创建代理。 尽管，我主要关注量会话作用域，但是请求作用域的bean会面临相同的装配问题，因此，请求作用域的bean应该也以作用域代理的方式进行注入 3.4.2 在XML中声明作用域代理如果你需要使用XML来声明会话或请求作用域的bean，那么就不能使用@Scope注解及其ProxyMode属性了元素能够设置bean的作用域，但是该怎样设置代理模式呢？ 要使用代理模式，我们需要使用Spring aop命名空间的一个新元素： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bean id="cart" class="com.guo.myapp.ShoppingCart" scope="session"&gt; &lt;aop:scoped-proxy/&gt;&lt;/bean&gt; aop:scoped-proxy是与@Scope注解的proxyMode属性功能相同的SpringXML配置元素，它会告诉Spring为bean创建一个作用域代理。默认情况下，它会使用CGLIB创建目标的代理。但是我们可以将proxy-target-class的属性设置为false，进而要求它生成基于接口的代理。 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bean id="cart" class="com.guo.myapp.ShoppingCart" scope="session"&gt; &lt;aop:scoped-proxy proxy-target-class = "false"/&gt;&lt;/bean&gt; 为了使用aop:scoped-proxy元素，必须在XML配置中声明Spring的aop命名空间： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; Spring高级配置的另一个可选方案：Spring表达式语言(Spring Expression Language) 3.5 运行时注入当讨论依赖注入的时候，我们通常讨论的是将一个bean引入到另一个bean的属性或构造器参数中。它通常来讲指的是将一个对象与另一个对象关联起来 但bean装配的另一个方面指的是将一个值注入到bean的属性或构造器参数中。 有时候硬编码是可行的，但有时候我们可能会希望避免硬编码。而是让这些值在运行时在确定，为了实现这些功能，Spring提供了运行时求值的方式： 属性占位符(Property placeholder) Spring表达式语言(SpEL) 这两种技术的用法是类似的，不过他们的目的和行为是有所差别的。 3.5.1 注入外部的值在Spring中，处理外部值的最简单方式就是声明属性源，并通过Spring的Enviroment来检索属性。 一个基本的Spring配置类，他使用外部的属性来装配BlankDisc bean。 12345678910111213@Configuration@PropertySource("classpath:/com/guo/soundsystem/app.properties")public class EnvironmentConfig &#123; @Autowired private Environment env; @Bean public BlankDisc blankDisc() &#123; return new BlankDisc( env.getProperty("disc.title"), env.getProperty("disc.artist")); &#125;&#125; @PropertySource 引用了类路径中一个名为app.properties的文件 这个属性文件加载到Spring的Environment中，同时blackDisc()方法中，会创建一个新的BlankDisc，它的构造参数是从属性文件中获取的，而这是通过getProperty()实现的。 深入学习Spirng的EnvironmentgetProperty() 方法并不是获取属性值的唯一方法，getProperty()方法有四个重载的变种形式 1234567891011121314151617181920package org.springframework.core.env;/** * Interface for resolving properties against any underlying source. * * @author Chris Beams * @since 3.1 * @see Environment * @see PropertySourcesPropertyResolver */public interface PropertyResolver &#123; String getProperty(String key); String getProperty(String key, String defaultValue); &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType); &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue); 前两种形式的getProperty()方法会返回String类型的值，但是你可以稍微对@Bean方法修改一些，这样在指定属性不存在的时候，会使用一个默认值。 123456@Beanpublic BlankDisc blankDisc() &#123; return new BlankDisc( env.getProperty("disc.title","guo go go"), env.getProperty("disc.artist","UU"));&#125; 剩下的两种getProperty()方法与前面的两种非常类似，但是他们不会将所有的值都视为String类型。假设你要获取的值所代表的连接池中所维持的连接数量，如果我们从属性文件中得到的是一个String类型的值，那么在使用之前还需要将其转化为Interge类型，但是如果使用重载的形式，就能非常便利的解决这个问题。 12int connectionCount = env.getProperty("db.connection.count",Interge.class,30); Environment还提供了几个与属性相关的方法，如果你在使用getProperty()方法的时候没有默认值，并且这个属性没有定义的话，获取到的值是null，如果你希望这个属性必须定义，那么可以使用getRequiredProperty()， 123456@Beanpublic BlankDisc blankDisc() &#123; return new BlankDisc( env.getRequiredProperty("disc.title"), env.getRequiredProperty("disc.artist"));&#125; 在这里，如果disc.title或者disc属性没有定义的话，将会抛出lllegalStateException异常 如果想要检查一个元素是否存在的话，可以调用Envrionment的contaiinsProperty()方法 1boolean titleeExists = env.containsProperty("disc.title"); 如果想将属性解析为类的话，可以使用getPropertyAsClass()方法 1Class&lt;CompactDisc&gt; cdClass = env.getPropertyAsClass("disc.class",CompactDisc.class); 除了属性的功能外，Environment还提供 一些方法来检查哪些Profile处于激活状态 12345678public interface Environment extends PropertyResolver &#123; String[] getActiveProfiles(); //返回激活profile名称的数组 String[] getDefaultProfiles(); //返回默认profile名称的数组 boolean acceptsProfiles(String... profiles); //如果environment支持给定的profile，则返回true&#125; 直接从Environment中检索属性是非常方便的，尤其是在Java配置中装配bean的时候，但是Spring也提供了通过占位符装配属性的方式，这些占位符的值会来源于一个属性源。 解析属性占位符Spring一直支持将属性定义到外部的属性配置文件中，并使用占位符值将其插入到Spring bean中， 123&lt;bean class="com.guo.soundsystem.BlankDisc" c:_0 = "$&#123;disc.title&#125;" c:_1 = "$&#123;disc.artist&#125;"/&gt; 按照这种方式，XML配置没有使用任何硬编码的值，它的值是从配置文件以外的一个源中解析得到的。 如果我们依赖于组件扫描和自动装配来创建和初始化应用组件的话，那么就没有占位符的配置文件了，在这种情况下，我们可以使用@Value注解，它的使用方式与@Autowired注解非常类似。 在BlankDisc类中，构造器可以改成如下显示： 123456public BlankDisc( @Value("$&#123;disc.title&#125;")String title, @Value("$&#123;disc.artist&#125;") String artist) &#123; this.title = title; this.artist = artist;&#125; 为了使用占位符，我们必须要配置一个PropertyPlaceholderConfigurer bean， 从Spring3.1开始，推荐使用propertySourcesPlaceholderConfigurer，因为它能够基于Spirnig Environment 及其属性源来加载占位符。 1234@Beanpublic static propertyplaceholderConfigurer placeholderConfigurer() &#123; return new propertyplaceholderConfigurer();&#125; 如果你想使用XML配置的话，Spring Context命名空间中的context:propertyplaceholder元素会为你生成 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;context:property-placeholder location="com/soundsystem/app.properties" /&gt;&lt;/beans&gt; 解析外部属性能够将值的处理推迟到运行时，但是它的关注点在于根据名称解析来自于Spring Environment和属性源的属性。而Spring表达式语言提供了一种更为通用的方式在运行时计算所要注入的值。 3.5.2 使用Spring表达式语言进行装配Spring3 引入了 Spring 表达式语言（Spring Expression Language，SpEL），它能够以一种强大和简介的方式将值装配到 bean 属性和构造器参数中。SpEL 拥有很多特性，包括： *使用 bean 的 ID 来引用 bean； *调用方法和访问对象的属性； *对值进行算数、关系和逻辑运算； *正则表达式匹配； *集合操作。 SpEL 不仅能够用在依赖注入中，在其他的一些方面也有很大用处。如 Spring Security 支持使用 SpEL 表达式定义安全限制工作。在 Spring MVC 应用中使用 Thymeleaf 模板作为视图的话，那么这些模板可以使用 SpEL 表达式引用模型数据。SpEL 表达式要放到”#{…}” 之中，这与属性占位符有些类似，属性占位符需要放到”${…}” 之中。下面是几个简单的 SpEL 样例，这些例子可以我们帮助编写自己的表达式。 SpEL样例需要了解的第一件事情就是SpEL表达式要放到“#{ … }”之中，这与属性占位符有些类 似，属性占位符需要放到“${ … }”之中。下面所展现的可能是最简单的SpEL表达式了： 1#&#123;1&#125; 表达式中只有字面量 1，当然它的计算结果就是 1 1#&#123;T(System).currentTimeMillis()&#125; ：它的最终结果是计算表达式的那一刻当前时间的毫秒数。T() 表达式会将 java.lang.System 视为 Java 中对应的类，因此可以调用其 static 修饰的 currentTimeMillis() 方法。 1#&#123;sgtPeppers.artist&#125; ：引用 ID 为 sgtPeppers 的 bean 的 artist 属性。 1#&#123;systemProperties[‘disc.title’]&#125; ：通过 systemProperties 对象引用系统属性。 在 bean 装配时使用 SpEL 表达式 如果通过组件扫描创建 bean 的话，在注入属性和构造器参数时，我们可以使用 @Value 注解，这与之前看到的属性占位符非常类似。不过，我们将用 SpEL 表达式替代属性占位符。例如，下面的样例展现了 BlankDisc，它会从系统属性中获取专辑名称和艺术家的名字： 12345public BlankDisc(@Value("#&#123;systemProperties['disc.title']&#125;") String title, @Value("#&#123;systemProperties['disc.artist']&#125;") String artist)&#123; this.title=title; this.artist=artist;&#125; 在 XML 配置中，你可以将 SpEL 表达式传入或的 value 属性中，或者将其作为 p - 命名空间或 c - 命名空间条目的值。例如，在如下 BlankDisc bean 的 XML 声明中，构造器参数就是通过 SpEL 表达式设置的： 1234&lt;bean id=&quot;sgtPeppers&quot; class=&quot;soundsystem.BlankDisc&quot; c:_title=&quot;#&#123;systemProperties[&apos;disc.title&apos;]&#125;&quot; c:_artist=&quot;#&#123;systemProperties[&apos;disc.artist&apos;]&#125;&quot; /&gt; 上面已经看过了几个简单的样例，也学习了如何将 SpEL 解析得到的值注入到 bean 中，下面将是 SpEL 所支持的基础表达式学习。 表示字面值SpEL 表达式可以用来表示各种类型的字面量，如：正数：#{1}、浮点数：#{3.14159}、String：#{‘Hello’}、布尔型：#{true}，用 SpEL 表示字面量并没有太大用处，但是要记住一点，更有意思的 SpEL 表达式是由更简单的表达式组成的，因此了解在 SpEL 中如何使用字面量还是很有用处的。但组合更为复杂的表达式时，你迟早会用到它们。 引用 bean、属性和方法SpEL 能做的另一件基础的侍寝就是通过 ID 引用其他的 bean。例如，你可以使用 SpEL 将一个 bean 装配到另一个 bean 的属性中，此时要使用 bean ID 作为 SpEL 表达式（在本例中，也就是 sgtPeppers）： 1#&#123;sgtPeppers&#125; 现在，假设我们想在一个表达式中引用 sgtPeppers 的 artist 属性： 1#&#123;sgtPeppers.artist&#125; 表达式主体的第一部分引用了一个 ID 为 sgtPeppers 的 bean，分隔符之后是对 artist 属性的引用。除了引用属性之外，我们还可以调用 bean 上的方法。例如，假设有另外一个 bean，它的 ID 为 artistSelector，我们可以在 SpEL 表达式中按照如下的方式来调用 bean 的 selectArtist() 方法： 1#&#123;artistSelector.selectArtist()&#125; 对于被调用方法的返回值来说，我们同样可以调用它的方法。如果 selectArtist() 方法返回的是一个 String，那么可以调用 toUpperCase() 将整个艺术家的名字改为大写字母形式： 1#&#123;artistSelector.selectArtist().toUpperCase()&#125; 如果 selectArtist() 的返回值不是 null 的话，这没有什么问题。为了避免出现 NullPointerException，我们可以使用类型安全的运算符： 1#&#123;artistSelector.selectArtist()?.toUpperCase()&#125; 与之前只是使用点号（.）来访问 toUpperCase()方法不同，现在我们使用了 “？.” 运算符。这个运算符能够在访问它右边的内容之前，确保它对应的元素不是 null。所以，如果 selectArtist()的返回值是 null 的话，那么 SpEL 将不会调用 toUpperCase()方法。表达式的返回值会是 null。 在表达式中使用类型如果要在 SpEL 中访问类作用域的方法和常量的话，要依赖 T() 这个关键的运算符。例如，为了在 SpEL 中表达 Java 的 Math 类，需要按照如下的方式使用 T() 运算符： 12#&#123;T(java.lang.Math).random&#125; //引用Math类的随机数方法#&#123;T(java.lang.Math).PI&#125; //引用Math类的常量 这里所示的T()运算符的结果会是一个Class对象，代表了java.lang.Math。如果需要 的话，我们甚至可以将其装配到一个Class类型的bean属性中。但是T()运算符的真正价值 在于它能够访问目标类型的静态方法和常量。 SpEL 运算符SpEL 提供了多个运算符，这些运算符可以用在 SpEL 表达式的值上。下表为用来操作表达式值的 SpEL 运算符： 下面这个例子作为使用上述运算符的一个简单样例： 1#&#123;2*T(java.lang.Math).PI*circle.radius&#125; 在这里 PI 的值乘以 2，然后再乘以 radius 属性的值，这个属性来源于 ID 为 circle 的 bean。实际上它计算了圆的周长。当使用 String 类型的值时，“+” 运算符执行的是连接操作，与在 Java 中是一样的： 1#&#123;disc.title+&apos;by&apos;+disc.artist&#125; SpEL 同时还提供了比较运算符，用来在表达式中对值进行比较。注意在上表中，比较运算符有两种形式：符号形式和文本形式。例如： 123#&#123;counter.total==100&#125;//等同于下面的表达式#&#123;counter.total eq 100&#125; SpEL 还提供了三元运算符（ternary），它与 Java 中的三元运算符非常类似。例如，如下的表达式会判断如果 scoreboard.score&gt;1000 的话，计算结果为 String 类型的 “Winner！”，否则，结果为 “Loser”： 1#&#123;scoreboard.score&gt;1000 ? &quot;Winner!&quot;:&quot;Loser&quot;&#125; 三元运算符的一个常见场景就是检查 null 值，并用一个默认值来代替 null。例如，如下的表达式会判断 disc.title 的值是不是 null，如果是 null 的话，那么表达式的计算结果就会是 “The Value Is Null”: 1#&#123;disc.title ?: &apos;The Value Is Null&apos;&#125; 这种表达式通常称为 Elvis 运算符。这个奇怪名称的来历是，当使用符号来表示表情时，问号看起来很像是猫王（Elvis Presley）的头发。 计算正则表达式当处理文本时，又是检查文本是否匹配某种模式是非常有用的。SpEL 通过 matches 运算符支持表达式中的模式匹配。matches 运算符对 String 类型的文本（作为左边参数）应用正则表达式（作为右边参数）。matches 的运算结果会返回一个 Boolean 类型的值：如果与正则表达式相匹配，则返回 true，否则返回 false。加入我们想判断一个字符是否包含有效的邮件地址。在这个场景下，我们可以使用 matches 运算符，如下所示： 1#&#123;admin.email matches &apos;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-+\\.com]&apos;&#125; 计算集合SpEL 中最令人旌旗的一些技巧是与集合和数组有关的。最简单的事情可能就是引用列表中的一个元素了。 1#&#123;jukebox.songs[4].title&#125; 这个表达式会计算 songs 集合汇总第五个元素的 title 属性，这个集合来源于 ID 为 jukebox bean。SpEL 还提供了查询运算符（.?[])，它会用来对集合进行过滤，得到集合的一个子集。作为阐述的样例，假设你希望得到 jukebox 中 artist 属性为 Aerosmith 的所有歌曲。如下的表单时就使用查询运算符得到了结果： 1#&#123;jukebox.songs.?[artist eq &apos;Aeronsmith&apos;]&#125; 可以看到，选择运算符在它的方括号中接收另一个表达式。SpEL 还提供了另外两个查询运算符：”.^[]“和”.$[]“，它们分别用来在集合中查询第一个匹配项和最后一个匹配项。例如，下面的表达式会查找列表中第一个 artist 属性为 Aerosmith 的歌曲： 1#&#123;jukebox.songs.^[artist eq &apos;Aerosmith&apos;]&#125; 最后 SpEL 还提供了投影运算符（.![]），它会从集合的每个成员中选择特定的属性放到另外一个集合中。作为样例，假设我们不想要歌曲对象的集合，而是所有歌曲名称的集合。如下的表达式会将 title 属性投影到一个新的 String 类型的集合中： 1#&#123;jukebox.songs.![title]&#125; 实际上，投影操作可以与其他任意的 SpEL 运算符一起使用。比如，我们可以使用如下的表达式获得 Aerosmith 所有歌曲的名称列表： 1#&#123;jukebox.songs.?[artist eq &apos;Aerosmith&apos;].![title]&#125; 我们所介绍的只是 SpEL 功能的一个皮毛，但已经能够让我们对 SpEL 有一个大致的了解了，当需要用到的时候再去深入学习。在动态注入值到 Spring Bean 时，SpEL 是一种很便利和强大的方式。我们又时会忍不住编写很复杂的表达式。但需要注意的是，不要让你的表达式太智能了。你的表达式越智能，对它的测试就越重要。SpEL 毕竟只是 String 类型的值，可能测试起来很困难。鉴于这一点，我建议尽可能让表达式保持简洁，这样测试不会是什么大问题。 3.6 小节1、学习了Spring profile，解决了Spring bean 要跨各种部署环境的通用问题。Profile bean 是在运行时条件化创建bean的一种方式，但在Spring4中提供了@Conditional注解和SpringCondition接口的实现。 2、解决两种自动装配歧义的方法，首选bean以及限定符。 3、Spring嫩那个狗让bean以单例，原型、会话、请求作用域的方式来创建。 4、简单的学习了SpEl，它能够在运行时计算要注入的bean属性的值。 依赖注入能够将组件以及协作的其他组件解耦，AOP有利于将应用组件与跨多个组件的任务进行解耦。 参考：https://github.com/guoxiaoxu/SpringInActionPracticehttps://www.jianshu.com/p/850c2a2a7a6b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记二]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-2%2F</url>
    <content type="text"><![CDATA[Spring 之旅第 2 章 Spring之旅装配Bean本章内容： 声明bean 构造器注入和Setter方法注入 装配bean 控制bean的创建和销毁 在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。创建应用对象之间的协作关系的行为通常称为装配(wiring),这就是依赖注入的本质。 2.1 Spring配置的可选方案Spring容器负责创建应用程序中的bean，并通过DI来协调这些对象之间的关系。你只需要告诉Spring要创建那些bean，并且如何组织在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制： XML中进行显示配置 在Java中进行显示配置 隐式的bean发现机制自动装配 建议使用：自动装配机制，显示配置越少越好。当你必须显示配置时，推荐使用类型安全并且比XML更加强大的JavaConfig。最后只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应用使用XML 2.2 自动化装配BeanSpring从两个角度来实现自动化装配： 组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的bean 自动装配(autowiring):Spirng自动满足bean之间的依赖 组件扫描和自动装配组合在一起就能发挥出强大的威力，他们能够将你的显示配置降低到最少。 2.2.1 创建被发现的beanCD为我们阐述了DI是如何运行提供了一个很好的样例，如果你不讲CD插入(注入)到CD播放器中，那么CD播放器其实没有太大的用处。CD播放器依赖于CD才能完成他的使命 程序2.1 123public interface CompactDisc &#123; void play();&#125; CompactDisc的具体内容不重要，重要的是你将其定义为一个接口，作为接口，它定义了CD播放器对一盘CD所能进行的操作。它将CD播放器的任意实现与CD本身耦合降低到了最小的程度 程序2.2 123456789101112/** * Created by guo on 21/2/2018. */@Component //表明该类会作为组件类public class SgtPeppers implements CompactDisc &#123; private String title = "sgt. pepper lonely Hearts Club Band"; private String artist = "The Beatles"; @Override public void play() &#123; System.out.println("Playing" + title + "by" + artist); &#125;&#125; SgtPeppers类上使用了@Component注解，这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。没有必要显示配置他。不过组件扫描默认是不开启的，需要显示配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean。 程序2.3 1234@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125; 类CDPlayConfig通过Java代码定义了Spring的装配规则。@ComPonentScan注解可以能够在Spring中启动组件扫描。如果没有其他配置，@ComponentScan默认会扫描与配置类相同的包。Spring将会扫描这个包以及这个包下所有的子包。查找带有@Component注解的类。这样就能发现CompactDisc，并且会在Spring中自动创建一个bean。 使用XMl来启用组件扫描的话，可以使用Spring context命名空间的context:component-scan元素， 程序2.4 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"..... &lt;context:component-scan base-package="com.guo.soundsystem" /&gt;&lt;/beans&gt; 尽管我们可以通过XMl的方案来启用组件扫描，但是在后面的讨论中，更多的还是会使用基于Java的配置。 为了测试组件扫描功能 创建一个简单的JUnit测试，它会创建Spring上下文，并判断CompactDisc是不是真的创建出来了。 程序2.5 123456789101112131415161718192021222324package com.guo.soundsystem;import com.guo.soundsystem.CDPlayerConfig;import com.guo.soundsystem.CompactDisc;import static org.junit.Assert.*; //这里使用了静态导入import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayConfig.class)public class CDPlayTest &#123; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull() &#123; assertNotNull(cd); &#125;&#125; CDPlayerTest使用了Spring的SpringJUnitClassRunner，以便在测试开始的时候自动创建Spring的上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置.带有@Autowired注解，以便将CompactDisc bean注入到测试代码中，最后断言cd属性不为null，就意味着Spirng能够发现CompactDisc类，自动在Spring应用上下文中将其创建为bean并将其注入到测试代码中。 2.2.2 为组件扫描的bean命名Spring应用上下文中所有bean都会给定一个ID。尽管没有明确为SgtPeppers bean 设置ID，但Spring会根据类名为其指定一个ID，这个ID所给定的ID为sgtPeppers，也就是将类名的第一个字母变为小写。 如果想设置不同的ID，所需要做的就是将期望的ID作为值传递给@Component注解 1234@COmponent("lonelyHeartsClub")public class SgtPeppers implements CompactDisc &#123; ...&#125; 还有另外一种为bean命名的方式，这种方式不使用@Component注解，而是使用Java依赖注入规范(Java Dependency Injection) 中所提供的@Named注解为bean设置ID： 12345import javax.inject.Named@Named("lonelyHeartsClub")public class SgtPeppers implements CompactDisc &#123; ...&#125; Spring支持将@named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，他们是可以互相替换的。 《Spring 实战》作者更喜欢@Component注解，而对于@Named。。。感觉名字起的很不好 2.2.3 设置组件扫描的基础包到目前为止，我们没有为@ComponentScan设置任何属性，这意味着，按照默认规则，它会以配置类所在的包作为基础包(base package) 来 扫描组件，有一个原因会促使我们明确的设置基础包，那就是我们要将配置类放在单独的包中，使其与其他应用代码区分开来。 为了指定不同的基础包，你所需要做的就是在@ComponentScan的Value属性中指明包的名称123@Configuration@Componentscan("com.guo.soundsystem")public class CDPlayerConfig&#123;&#125; 如果你想更加清晰的表明你所设置的是基础包，那么你可以通过basePackages属性来进行设置123@Configuration@Componentscan(basePackages="com.guo.soundsystem")public class CDPlayerConfig&#123;&#125; @basePackages属性使用的是复数形式，以为这可以设置多个基础包，只需要将basePackages属性设置为要扫描包的一个数组就可以123@Configuration@Componentscan(basePackages=&#123;"com.guo.soundsystem","com.guo.video"&#125;)public class CDPlayerConfig&#123;&#125; 在上面所有的例子中，所设置的基础包都是以String类型表示的，作者认为这是可以的，但是这种方式是类型不安全的，如果你要重构代码的话，那么你所指定的基础包可能就会出现错误。 除了将包设置为简单的String类型之外，@ComponentScan还提供了另外一种方式，那就是将其设置为包中所包含的类或接口 123@Configuration@Componentscan(basePackageClasses=&#123;CDPlayer.class,DVDPlayer.class&#125;)public class CDPlayerConfig&#123;&#125; 尽管在样例中，为basePackageClasses设置的是组件类，但是可以考虑在包中创建一个用来扫描的空标记接口。通过标记接口的方式，你依然能够保持对重构友好的接口的引用，但是可以避免引用任何实际的应用程序代码。 在你的应用程序中，如果所有的对象都是独立的，彼此之间没有任何依赖，就像SgtPeppers bean 这样，那么你需要的可能就是组件扫描而已。但是很多对象会依赖其他的对象才能完成任务。这样的话我们就需要有一种方式能够将组件扫描到的bean和他们的依赖装配在一起：自动装配 2.2.4 通过为bean添加注解实现自动装配自动装配就是让Spring自动满足bean依赖的一种方法，在满足的依赖的过程中，会在Spring应用上下文寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以将可以借助于Spring提供的@Autowired注解。 123456789101112@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; @Override public void play() &#123; cd.play(); &#125;&#125; 在构造器上添加了@Autowired注解，这表明当Spring创建CDPlayer bean时，会通过这个构造器来实例化并且传入一个可设置给CompactDisc类型的bean @Autowired注解不仅可以用于构造器上，还能用在属性Setter方法上， 1234@Autowiredpublic void setCompactDisc(CompactDisc cd)｛ this.cd = cd;｝ 在Spring初始化bean之后，它会尽可能去满足bean的依赖，依赖是通过带有@Autowired注解的方法进行生命的， 实际上，Setter方法并没有什么特殊之处。@Autowired可以用在类的任何方法上，1234@Autowiredpublic void insertDisc(CompactDisc cd)｛ this.cd = cd;｝ 不管是构造器、Setter方法还是其他方法，Spring购汇尝试满足方法参数上所申明的依赖。假如有且只有一个满足需求依赖的话，那么这个bean将会被装配进来， 如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常，为了避免异常的出现，你可以将@Autowired的required属性设置为false 1234@Autowired(required=false)public CDPlayer(CompactDisc cd) &#123; this.cd = cd;&#125; 将required设置为false时，Spring会尝试执行自动装配，但如果没有匹配的bean，Spring将会让这个bean处于未装配的状态，需要谨慎对待，如果你的代码中没有进行null检查的话，这个处于未装配的属性可能会出现NullPointerException。 如果有多个bean满足依赖关系时，Spirng将会抛出异常，表明没有明确指定要选择安格bean进行装配。 @ Autowired是Spring特有的注解，如果你不喜欢在代码中使用@Autowired，那么你可以考虑使用@Inject 123456789101112@Namedpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Inject public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; @Override public void play() &#123; cd.play(); &#125;&#125; @Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解，在Spring自动装配中，Spirng同时支持@Inject和@Autowired，作者没有特别的偏向性。根据自己的情况，选择合适自己的，推荐使用@Autowired。 2.2.5 验证自动装配1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest &#123; @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Autowired private MediaPlayer player; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull() &#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals( "Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n", log.getLog()); &#125;&#125; 在测试代码中使用System.out.println()是稍微有些棘手的是，该样例中使用了StandardOutputStreamLog，这是来源于System Rules 库的一个JUnit规则，该规则能够基于控制台的输出编写断言。 2.3通过Java代码装配bean尽管在很多常见喜爱通过组件扫描和自动装配实现了Spring的自动装配是更为推荐的方式，但有时候自动化配置的方案是行不通的，因此需要明确配置Spring.比如你将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的。 在这种情况下，你必须使用显示装配方式，在进行显示装配的时候，有两种方案可以选择。Java和XML。 作者认为:在进行显示配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好 因为它是Java代码，就像应用程序中的其他代码一样。 同时，JavaConfig与其他的Java代码由有所区别，在概念上，他与应用程序中的业务逻辑和领域代码是不同的。JavaConfig是配置代码。这意着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码中。通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。 2.3.1 创建配置类。12345678import org.springframework.context.annotation.Configuration;/** * Created by guo on 21/2/2018. */@Configurationpublic class CDPlayerConfig &#123;&#125; 创建JavaConfig类的关键点在于为其添加@Configuration注解，表明该类是一个配置类。该类应该包含在Spring应用上下文中如何创建bean的细节 尽管我们可以同时使用组件扫描和显示配置，但在本节中更关注显示配置，因此将CDPlayerConfig中的@ComponentScan注解移除了。此时在运行会抛出org.springframework.beans.factory.BeanCreationException: Error creating bean with name异常。测试希望被注入的CDPlayer和CompactDisc，但这些bean根本没有创建，因为组件扫描不会发现它们。 2.3.2 声明简单的bean要在JavaConfig中声明bean，需要编写一个方法，这个方法会创建锁需要类型的实例，然后给这个方法添加@Bean注解。 1234567@Configurationpublic class CDPlayerConfig &#123; @Bean public CompactDisc sgtPeppers() &#123; return new SgtPeppers(); &#125;&#125; @Bean注解会告诉Spirng这个方法将返回一个对象，该对象要注册为Spring应用上下文中的bean，方法中最终产生了bean实例的逻辑。 默认情况下，bean的ID与带有@Bean注解的方法名是一样的，如果你想重命名该方面，也可以通过name属性指定一个不同的名字 1234567@Configurationpublic class CDPlayerConfig &#123; @Bean(name="lonelyHeartsClub") public CompactDisc sgtPeppers() &#123; return new SgtPeppers(); &#125;&#125; 在一组CD中随机选择一个CompactDisc来播放 12345678910111213@Beanpublic CompactDisc randomBeatlesCD() &#123; int choice = (int)Math.foloor(Math.random() * 4); if (choice == 0) &#123; return new SgtPeppers(); &#125;else if (choice == 1) &#123; return new WhiteAlbum(); &#125;else if (choice == 2) &#123; new HardDaysNight(); &#125;else &#123; return new Revolver(); &#125;&#125; 2.3.3 借助JavaConfig实现注入在JavaConfig中最简单方式就是引用创建bean的方法，1234@Beanpublic CDPlayer cdPlayer() &#123; return new CDPlayer(sgtPeppers);&#125; cdPlayer()方法相sgtPepper()方法一样，同样使用了@Bean注解，表明这个方法会创建一个bean实例并嫁将其注入到Spring应用上下文中。所创建的bean ID为cdPlayer，与方法名字相同。 通过调用方法来引用bean的方式有点令人困惑，其实还有一种理解起来更为简单的方式 1234@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc);&#125; 在这里cdPlayer方法请求一个compactDisc作为参数，当Spring调用cdPlayer创建的CDPlayer bean 时，它会自动装配一个CompactDisc到配置方法中，然后，方法体就可以按照合适的方式来使用它。借助于这种技术，cdPlayer也可以将CompactDisc注入到CDPlayer的构造器中，而不用明确引用CompactDisc的@Bean方法。 通过这种方式引用其他的bean是最佳的选择。因为它不会要求将CompactDisc申明到同一个配置类中。实际上它可以通过组件扫描能够自动发现或者通过XML来进行配置。你可以将配置分散到多个配置类、XML文件以及自动扫描和装配的bean中，只要功能完整即可。 另外需要提醒的是，我们在这里使用CDPlayer的构造器实现了DI功能，但是我们完全可以采用其他风格的DI配置，比如你想通过Setter方法来注入CompactDisc的话，可以这样做 123456@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) &#123; CDPlayer cdPlayer new CDPlayer(compactDisc); cdPlayer.setCompactDisc(compactDisc); return cdPlayer;&#125; 再次强调一遍，带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例，构造器和Setter方法只是@Bean方法的两个简单样例。这里存在的可能性仅仅受到了Java语言的限制。 2.4 通过XML装配bean（不推荐使用）在Spring刚刚出现的时候，XMl是描述配置的主要方式。在Spring的名义下，我们创建了无数行XML代码。在一定程度上，Spring成为了XMl配置的同义词。现在需要明确的是XML不再是配置Spring的唯一可选方案。Spring现在有了强大的自动配置和基于Java的配置，Xml不应该在是你的第一选择了。 本节的内容只是用来帮助你维护已有的XML配置，在完成新的Spring工作时，希望你会使用自动化配置和Java配置 2.4.1 创建XML配置规范在使用XMl为Spring装配bean之前你需要创建一个新的配置规范。在使用JavaConfig的时候，你需要创建一个带有@Configuration注解的类，而在XML配置中，需要创建一个XMl文件，并且要以元素为根 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- configuration details go here --&gt;&lt;/beans&gt; 已经有一个合法的Spring XMl配置文件。不过它是一个没有任何用处的配置，因为它没有申明任何bean。为了给予它生命，重新创建一下CD样例，只不过这次选择XML配置，而不是使用JavaConfig和自动化装配。 2.4.2 声明一个简单的bean要在基于XML的Spring中声明一个bean，需要使用Spring-beans模式中的另一个元素 类似于JavaConfig中的@Bean注解。 1&lt;bean class="com.guo.soundsystem.SgtPeppers"/&gt; 这里声明了一个简单的bean，创建这个bean的类通过class属性来指定的并且要使用全限定类名。 因为没有明确给Id，所以这个bean将要根据全限定名来进行命名。 尽管自动化的bean命名方式非常方便，但如果你稍后需要引用它的话，那么自动产生的名字就没有多大用处了。因此，通常来讲更好的办法就是借助于id属性。为每个bean设置一个你自己选择的名字 1&lt;bean id="compactDisc" class="com.guo.soundsystem.SgtPeppers"/&gt; 第一件需要注意的事情就是你不在需要直接负责创建SgtPeppers的实例，在基于JavaConfig的配置中，我们需要这样做。当Spring发现这个元素时，它会调用SgtPeppers的默认构造器来创建bean。在Xml配置中，bean的创建显得更加被动，不过，它它没有javaConfig那样强大，在JavaConfig中，你可以通过任何可以想象到的方法来创建bean实例。 另一个需要注意的是，在这个简单的声明中，我们将bean的类型以字符串的形式设置在了 class属性中。谁能确保设置给Class属性的值是真正的类呢？Spring的XMl配置并不能从编译器的类型检查张宏收益，即便它所引用的是实际的类型，如果你重命名了会发生什么呢？ 以上介绍的只是JavaConfig要优于XML配置的部分原因。在你的应用选择配置风格时，要记住XMl配置的这些缺点。 2.4.3 借助于构造器注入 初始化 bean在Spring XMl配置中，只有一种声明bean的方式，使用元素并制定calss属性，Sprng会从这里获取必要的信息来创建bean。 在XMl中声明DI时，会有多种可选的配置风格和方案。具体到构造器注入，有两种基本的配置方案可供选择 元素 使用Spring3.0所引入的c-命名空间 两者的区别在很大程度就是是否冗余长烦琐。元素比使用c-命名空间会更加冗长。从而导致XMl更加难以读懂。另外有些事情可以做到，但是使用c-命名空间却无法实现。 构造器注入Bean引用123&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer"&gt; &lt;constructor-arg ref="compactDisc"/&gt;&lt;/bean&gt; 当Spring遇到这个bean元素时，它会创建一个CDPlayer实例 。元素会告知Spring要将一个ID为compactDisc的bean引用传递到CDPlayer的构造器中 作为替代方案，你也可以使用Spring的c-命名空间。c-命名空间实在Spring3.0中引入的，它是在XMl中更为简单的描述构造器参数的方式，要使用他的话，必须在XMl的顶部声明其模式 ， 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 在c-命名空间和模式声明之后，就可以使用它来声明构造器参数了 12&lt;bean id="compactDisc" class="com.guo.soundsystem.cdPlayer" c:cd-ref="compactDisc" /&gt; 将字面量注入到构造器中迄今为止，我们所作的DI通常指的都是类型的装配—也就是将对象的引用装配到依赖于他的其他对象之中。而有些时候我们需要做的只是将一个字面量值来配置对象，为了阐述这一点，假设你要创建CompactDisc的一个新实现 。 1234567891011121314151617/** * Created by guo on 21/2/2018. */public class BlankDisc implements CompactDisc &#123; private String title; private String artist; public BlankDisc(String title, String artist) &#123; this.title = title; this.artist = artist; &#125; @Override public void play() &#123; System.out.println("Playing " + title + " by " + artist); &#125;&#125; 在SgtPeppers中，唱片名称和艺术家的名字都是硬编码的。但是这个CompactDisc实现与之不同，它更加灵活。像现实中的空磁盘一样，它可以设置成你想要的艺术家和唱片名。 1234&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;constructor-arg value="The Beatles"/&gt;&lt;/bean&gt; 使用value属性，通过该属性表明给定的值要以字面量的形式注入到构造器中。 装配集合如果使用CompactDisc为真正的CD建模，那么它也应该有磁道列表的概念。 123456789101112&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;constructor-arg value="The Beatles"/&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;11&lt;/value&gt; &lt;value&gt;22&lt;/value&gt; &lt;value&gt;33&lt;/value&gt; &lt;value&gt;44&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 其中，元素是的子元素。这表明一个包含值的列表将会传递给构造器中，其中元素用来指定列表中的每一个元素。 与之类似的，我们也可以使用元素替代,实现bean引用列表的装配 和元素区别不大，其中重要的不同在于当Spring创建要装配集合的时候，所创建的是java.util.Set还是java.util.List。如果是Set的话，所有重复元素会被忽略掉，存放顺序也不会得到保证。不过无论在哪中情况下，和都可以用来装配List、Set甚至数组。 在装配集合方面，比c-命名空间的属性更有优势。使用c-命名空间的属性却无法实现装配集合的功能 与其不厌其烦的花时间讲述如何使用XML进行 构造器注入，还不如看一下如何使用XML来装配属性 2.4.4 设置属性到目前为止，CDPlayer和BlanckDisc类完全是通过构造器注入的，没有使用属性的Setter方法，接下来，我们就看看如何使用Sprng XML配置实现属性注入， 该选择构造器注入还是熟悉注入呢？作为一个通用的规则，我倾向于对强依赖使用构造器注入，而对可选性的依赖使用属性注入。 对于CDPlayer来讲，它对CompactDisc是强依赖还是可选依赖可能会有些争议。 Spring在创建bean的时候不会有任何问题，但是CDPlayTest会因为出现NullPointException而导致测试失败，因为我们并没有出入CDPlayer的compactDisc属性。不过按照下面的方式修改XML，就能解决该问题 123&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer"&gt; &lt;propert name="compactDisc" ref="compactDisc"/&gt;&lt;/bean&gt; 元素为属性的Setter方法所提供的功能与元素为构造器所提供的功能是一样的。在本例中，它它引用了ID为compactDisc的bean，(通过ref属性)，并将其注入到compactDisc属性中(通过setCompactDisc()方法)。 Spring为元素通过了c-命名空间作为替代方案，与之类似的，Spring提供了更加简洁的p-命名空间，作为元素的替代方案。为了启用p-，必须在XML文件织哦你与其他命名空间一起对其进行声明。 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 我们可以使用p-命名空间，按照以下的方式装配compactDisc属性 12&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" p:compactDisc-ref="compactDisc"/&gt; 首先属性的名字使用了”p：”前缀，表明我们设置的是一个属性。接下来就要注入属性名。 将字面量注入到属性中123456789101112&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;propert value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;propert value="The Beatles"/&gt; &lt;propert&gt; &lt;list&gt; &lt;value&gt;11&lt;/value&gt; &lt;value&gt;22&lt;/value&gt; &lt;value&gt;33&lt;/value&gt; &lt;value&gt;44&lt;/value&gt; &lt;/list&gt; &lt;/propert&gt;&lt;/bean&gt; 需要注意的是**我们不能使用p-命名空间来装配集合，没有遍历的方式使用p-命名空间 util-命名空间所提供的功能之一就是util:list元素它会创建一个列表的bean，借助util:list，我们可以将磁道列表转移到BlackDisc bean之外。并将其声明到单独的bean之中。 123456789101112131415&lt;util:list id="trackList"&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She's Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I'm Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt;&lt;/util:list&gt; 在需要的时候，你可能会用到util-命名空间中的部分成员。 Spring util-命名空间中的元素 util:constant :引用某个类型的public static 域，并将其暴露为bean util:list:创建一个java.util.List类型的bean，其中包含值和引用 util:map :创建一个java.util.Map类型的bean，其中包含值或引用。 util:properties :创建一个java.util.properteis类型的bean。 util：set： 创建一个java.util.Set类型的bean，其中包含值或引用。 2.5导入和混合配置在典型的Spring应用中，我们可能同时使用自动化和显示配置。即便你更喜欢通过JavaConfig实现显示配置，但有时候XML确实最佳的方案。 幸好在Spring中，这些配置方案不是互斥的，你尽可以将JavaConfig的组件扫描和自动装配或XMl配置混合在一起。 关于混合配置，第一件事需要了解的就是在自动装配时，它并不在意要装配的bean来自哪里。自动装配的时候会考虑Spring容器中所有的bean，不管他在JavaConfig中还是在XMl中声明的还是通过组件扫描获取到的。 2.5.1 在JavaConfig中引用XML配置将设bean很多，所能实现的一种方案就是将BlankIDisc从CDPlayerConfig中拆分出来，定义到它自己的CDConfig中。 1234567@Configurationpublic class CDConfig &#123; @Bean public CompactDisc compactDisc () &#123; return new SgtPeppers(); &#125;&#125; compactDisc方法已经从CDPlayerConfig中移除了，我们需要有一种方式将这两个类组合在一起。一种方式就是在CDPlayerConfig中使用@Import注解导入CDConfig。 1234567891011/** * Created by guo on 21/2/2018. */@Configuration@Import(CDConfig.class)public class CDPlayerConfig &#123; @Bean public CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc); &#125;&#125; 或者采用一个更好的办法，也就是不再CDPlayerConfig中使用@Import，而是创建一个更高级别的SoundSystemConfig，在这个类中使用@Import将两个配置组合在一起： 本人：内心还在想什么好方法，确实是更好的办法。 1234@Configuration@Import(&#123;CDPlayerConfig.class,CDConfig.class&#125;)public class SoundSystemConfig &#123;&#125; 不管采用哪种方式，我们都将CDplayer的配置与BlankDisk的配置分开了。现在，我们假设(基于某种原因)希望通过XML来配置BlackDisc， 123456789101112131415&lt;bean id="compactDisc" class="com.guo.soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;!-- ...other tracks omitted for brevity... --&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 现在BlankDisc配置在了XML中，我们该如何让Spring同时加载它和其他基于Java的配置呢？ 答案是@ImportResource注解。假设BlankDisc定义在名为cd-config.xml的文件中，该文件位于根路径下，那么可以修改SoundSystemConfig让他使用@ImportResource注解 12345@Configuration@Import(CDPlayerConfig.class)@ImportResource("classpath:cd-config.xml")public class SoundSystemConfig &#123;&#125; 两个bean–配置在JavaConfig中的CDPlayer以及配置在XMl中BlankDisc — 都会被加载到Spring容器中，因为CDPlayere中带有@Bean注解的方法接受一个CompactDisc作为参数。因此BlankDisc将会被装配进来，此时与他是通过XML配置的没有任何关系。 让我们继续这个练习，但是这一次，我们需要在XMl中引用JavaConfig声明的bean 2.5.2 在XML配置中引用JavaConfig假设你正在使用Spring基于XML的配置，并且你已经意识到XML逐渐变得无法控制。 在JavaConfig配置中，我们已经展现了如何使用@Import和@ImportResource来拆分JavaConfig类，在XML中，我们可以使用import元素来拆分XML配置。 比如假设你希望将BlankDiscbean拆分到自己的配置文件中，该文件名为cd-config.xml. 1234&lt;import resource="cd-config.xml"/&gt;&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" c:cd-ref="compactDisc" /&gt; 现在假设不再将BlankDisc配置在XXMl中，而是将其配置到JavaConfig中，CDPlay继续配置在XML中， 为了将JavaConfig类导入到XMl配置中，我们可以这样声明bean： 1234&lt;bean class="com.guo.soundsystem.CDConfig"/&gt;&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" c:cd-ref="compactDisc" /&gt; 采用这样的方式，两种配置–其中一种使用XML描述，另一个使用Java描述—被组合在一起了。类似的，你还希望声明一个更高级被的层次的配置文件，这个文件不声明任何bean，只是负责将两个或 多个配置文件组合在一起。 123&lt;bean class="com.guo.soundsystem.CDConfig"/&gt;&lt;import resource="cdplayer-config.xml"/&gt; 不管使用XMl还是JavaConfig进行装配，我通常都会创建一个根配置，也就是这里展现的这样，这个配置文件会将两个或更多的装配类和/或XML文件组合起来。我也会在根配置中启用组件扫描(通过context:component-scan或@ComponentScan)，你会在本书中很多的例子中看到这种技术。 2.6 小节Spring的核心是Spring容器。容器负责管理应用中组件的生命周期，它会创建这些组件并保证他们的依赖能够得到满足，这样的话，组件才能完成预定的任务。 在本章中，我们看到了Spring中装配bean的三种方式：自动化装配、基于Java的显示配置、以及基于XML的显示配置。不管你采用什么方式，这些技术都描述了Spring应用中的组件以及这些组件之间的关系**。 我同时建议你尽可能使用自动化配置，以避免显示配置所带来的维护成本。但是，如果你确实需要显示的配置Spring的话，应该优先选择基于Java的配置，它比基于XML的配置更加强大、类型安全、并且易于重构。 在本书中的栗子中，当决定如何装配组件时，我都会遵循这样的指导意见。 因为依赖注入是Spring中非常重要的组成部分，所以本章中介绍的技术在本书中所有的地方都会用到。基于这些基础知识，下一章将会介绍一些更为高级的bean装配技术，这些技术能够让你更加充分地发挥Spring容器的威力 参考：https://github.com/guoxiaoxu/SpringInActionPractice]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记一]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15%2F</url>
    <content type="text"><![CDATA[Spring 之旅第 1 章 Spring之旅本章内容： Spring 的 bean 容器 介绍 Spring 的核心模块 更为强大的 Spring 生态系统 Spring 的新功能 1.1 简化 Java 开发为了降低 Java 开发的复杂性，Spring 采取了以下 4 种关键策略： 基于 POJO 的轻量级和最小入侵性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程： 通过切面和模板减少样板代码； 1.1.1 激发 POJO 的潜力尽管简单，但 POJO 一样可以拥有魔力，Spring 赋予 POJO 魔力的方式之一就是通过 DI 来装配它们。 1.1.2 依赖注入(DI,Dependenc Injection)依赖注入现在已经演变成一项复杂的编程技巧或设计模式的理念 按照传统的做法，每个对象负责管理与自己相互协作的对象的引用 (即它所依赖的对象)，这就会导致高度耦合和难以测试的代码。 程序1.2 1234567891011121314/** * damsel表示：少女 */public class DamselRescuingKnight implements Knight &#123; private RescueDamselQuest quest; public DamselRescuingKnight ( RescueDamselQuest quest) &#123; //与RescueDamselQuest紧耦合 this.quest = new RescueDamselQuest(); &#125; @Override public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; DamselRescueingKnight 在它的构造函数中自行创建了 RescueDamselQuest。这使得两者紧紧的耦合在一起。因此极大的限制了骑士执行探险的能力。在这样一个测试中 ，你必须保证当骑士 embarkOnQuest 方法被调用的时候，探险 embark 方法也要被调用。但是没有一个简单明了的方式能够测试。 通过 DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候设定，对象无需自行创建或管理他们的依赖关系，依赖关系将被自动注入到需要它们的对象中。 依赖注入会将所依赖的关系自动交给目标对象，而不是让对象自己去获取依赖 BraveKnight 足够灵活可以接受任何赋予他的探险任务。 程序1.3 1234567891011121314public class BraveKnight implements Knight &#123; public Quest quest; public BraveKnight(Quest quest&#123; //Quest被注入进来 this.quest = quest; &#125; @Override public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; 不同于之前的 DamselRescuingKnight，BraveKnight 没有自行创建探险任务，而是在构造的时候把探险任务作为构造参数传入。这是依赖注入的方式之一，即构造注入 (constructor injection). 需要注意的是，传入的探险类型是一个 Quest，也就是所有的探险任务都必须实现的一个接口。所以 BraveKnight 能够响应 RescueDamselQuest、SlayDragonQuest、MakeRoundTableRounderQuesst 等任意的 Quest 实现。 这里的要点是 BraveKnight 没有有特定的 Quest 实现发生耦合。对他来说，被要求挑战的探险任务只要实现了 Quest 接口，那么具体的是那种类型就无关紧要了。这就是 DI 带来最大的收益——松耦合。如果一个对象只通过接口 (而不是具体的实现或初始化过程) 来表明依赖关系，那么这种依赖就能够在对象本身毫不情况的情况下，用不同的具体实例进行替换。 对依赖进行替换的一个最常用方法就是在测试的时候使用 mock 实现。 程序1.4 123456789101112import static org.mockito.Mockito.*;public class BraveKnightTest &#123; @Test public void knightShouldEmbarkQuest() &#123; Quest mockQuest = mock(Quest.class); //创建mock Quest BraveKnight knight = new BraveKnight(mockQuest); //注入mock Quest； knight.embarkOnQuest(); verify(mockQuest,times(1)).embark(); &#125;&#125; 可以通过 mock 框架 Mockito 去创建一个 Quest 接口的 mock 实现。通过这个 mock 对象，就可以创建一个新的 BraveKnight 实例，并通过构造器注入到这个 mock Quest。当调用 embarkOnQUest 方法时，你可以要求 Mockito 框架验证 Quest 的 mock 实现的 embark 方法仅仅被调用了一次。 将 Quest 注入到 Knight 中 希望 BraveKnight 所进行的探险任务是杀死一只怪龙， 程序1.5 123456789public class SlayDragonQuest implements Quest &#123; private PrintStream stream; public SlayDragonQuest(PrintStream stream) &#123; this.stream = stream; &#125; @Override public void embark() &#123; stream.println("Embarking on quest to slay the dragon!!,顺便还可以学英语，一举两得。"); &#125; SlayDragonQuest 实现类 Quest 接口，这样它就适合注入到 BraveKnight 中了，与其他样例不同的是，SlayDragonQuest 没有使用 System.out.println();, 而是在构造方法中请求一个更为通用的 PrintStream。 创建应用组件之间协作的行为成为装配。Spring 有多种装配 Bean 的方式，采用 XML 是一种常用的方式。 knights.xml，该文件将 BraveKnight，SlayDragonQuest 和 PrintStream 装配到一起。 程序1.6 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="knight" class="guo.knights.BraveKnight"&gt; &lt;!--注入Quest bean--&gt; &lt;constructor-arg ref="quest"/&gt; &lt;/bean&gt; &lt;!--创建SlayDragonQuest--&gt; &lt;bean id="quest" class="guo.knights.SlayDragonQuest"&gt; &lt;constructor-arg value="#&#123;T(System).out&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在这里，BraveKnight 和 SlayDragonQuest 被声明为 Spring 中的 bean。就 BraveKnight bean 来讲，他在构造时传入对 SlayDragonQuest bean 的引用，将其作为构造器参数。同时，SlayDragonQuest bean 的声明使用了 Spring 表达式语言 (Spring Expression Language)，将 System.out(一个 PrintStream) 传入到了 SlayDragonQuest 的构造器中， 在 SpEL 中, 使用 T() 运算符会调用类作用域的方法和常量. 例如, 在 SpEL 中使用 Java 的 Math 类, 我们可以像下面的示例这样使用 T() 运算符： T(java.lang.Math) T() 运算符的结果会返回一个 java.lang.Math 类对象. Spring 提供了基于 Java 的配置可作为 XML 的替代方案。 程序1.7 12345678910111213141516171819202122import guo.knights.BraveKnight;import guo.knights.Knight;import guo.knights.Quest;import guo.knights.SlayDragonQuest;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Created by guo on 20/2/2018. */@Configurationpublic class KnightConfig &#123; @Bean public Knight knight() &#123; return new BraveKnight(quest()); &#125; @Bean public Quest quest() &#123; return new SlayDragonQuest(System.out); &#125;&#125; 不管使用的是基于 XML 的配置还是基于 Java 的配置，DI 所带来的收益都是相同的。尽管 BraveKnight 依赖于 Quest，但是它并不知道传递给它的是什么类型的 Quest，与之类似，SlayDragonQuest 依赖于 PrintStream，但是编译时，并不知道 PrintStream 长啥样子。只有 Spring 通过他的配置，能够了解这些组成部分是如何装配起来的。这样就可以在不改变 所依赖的类的情况下，修改依赖关系。 接下来，我们只需要装载 XML 配置文件，并把应用启动起来。 Spring 通过应用上下文 (Application context) 装载 bean 的定义，并把它们组装起来。Spring 应用上下文全权负责对象的创建个组装，Spring 自带了多种应用上下文的实现，他们之间的主要区别仅仅在于如何加载配置。 因为 knights.xml 中的 bean 是使用 XML 文件进行配置的，所以选择 ClassPathXmlApplicationContext 作为应用上下文相对是比较合适的。该类加载位于应用程序类路径下的一个或多个 Xml 配置文件。 程序1.8 12345678910111213public class KnightMain &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring/knights.xml"); //加载Sprinig应用上下文 Knight knight = context.getBean(Knight.class); //获取knight bean knight.embarkOnQuest(); //使用knight调用方法 context.close(); //关闭应用上下文 &#125;&#125; 这里的 main() 方法基于 knight.xml 文件创建了 spring 应用上下文。随后他调用该应用上下文获取一个 ID 为 knighht 的 bean。得到 Knighht 对象的引用后，只需要简单调用 embarkOnQuest 方法就可以执行所赋予的探险任务了。只有 knights.xml 知道哪个骑士执行力那种任务。 1.1.3 应用切面DI 能够让相互协作的软件组件保持松耦合，而面向切面编程 (aspect-oriented programming AOP) 允许你把遍布应用各处的功能分离出来形成可重用的组件。 面向切面编程往往被定义为促使软件系统实现关注点的分离一项技术, 系统由许多不同的组件组成，每个组件各负责一特定的功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理、和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中。这些系统通常被称为横切关注点。，因此他们会跨越系统多个组件。 AOP 能使这些服务模块化，并以声明的方式将它们应用到它们要影响的组件中去。所造成的结果就是这些组件会更加关注自身的业务，总之 AOP 能确保 POJO 的简单性。 我们可以把切面想象为覆盖在很多组件之上的一个外壳。应用是由哪些实现各自业务功能模块组成的，借助 AOP， 可以使用各种功能层去包裹核心业务层，, 这些层以声明的方式灵活的应用到系统中，你的核心应用甚至根本不知道他们的存在。这是一个非常强大的理念，可以将安全，事务，日志关注点与核心业务相分离。** 程序1.9 12345678910111213141516171819/** * Created by guo on 20/2/2018. * 咏游诗人，作为骑士的一个切面 */public class Minstrel &#123; private PrintStream stream; public Minstrel(PrintStream stream) &#123; this.stream = stream; &#125; public void singBeforeQuest() &#123; stream.println("Fa la la ,the Knight is so brabe"); //探险之前调用 &#125; public void singAfterQuest() &#123; stream.println("Tee hee hhe,the brave knight " + "did embark on a quest"); //探险之后调用 &#125;&#125; Minstrel 只有两个简单的方法的类，在骑士执行每一个探险任务之前，singBeforeQuest() 被调用；在骑士完成探险任务之后，singAfterQuest() 方法被调用。在这两种情况下，Minstrel 都会通过一个 PrintStream 类来歌颂骑士的事迹，这个类通过构造器注入进来。 但利用 AOP，你可以声明咏游诗人西部歌颂骑士的 探险事迹，而骑士本身不直接访问 Minstrel 的方法 要将 Minstrel 抽象为一个切面，你所需要做的事情就是在一个 Spring 配置文件中声明它，， 程序1.11 123456789101112131415&lt;bean id="minstrel" class="guo.knights.Minstrel"&gt; &lt;constructor-arg value="#&#123;T(System).out&#125;"/&gt; &lt;!--声明Minstrel bean--&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect ref="minstrel"&gt; &lt;aop:pointcut id="embark" expression="execution(* * .embarkOnQuest(..))"/&gt; &lt;!--定义切点--&gt; &lt;aop:before pointcut-ref="embark" method="singBeforeQuest"/&gt; &lt;!-- 声明前置通知--&gt; &lt;aop:after pointcut-ref="embark" method="singAfterQuest"/&gt; &lt;!-- 声明后置通知--&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 这里使用了 Spring 的 aop 配置命名空间把 Minstrel 声明为一个切面。 在这两种方式中，pointcut-ref 属性都引用列名为为 “embark” 的切入点，该切入点实在前面的元素中定义的，并配置 expression 属性来选择所应用的通知。表达式的语法采用的是 aspectJ 的切点表达式语言。 Minstrel 仍然是一个 POJO，没有任何代码表明它要被作为一个切面使用，其次最重要的是 Minstrel 可以被应用到 BraveKnight 中，而 BraveKnight 不需要显示的调用它，实际上，BraveKnight 完全不知道 MInstrel 的存在 1.1.4 小节作者已经为我们展示了 Spring 通过面向 POJO 编程、DI、切面、模板技术来简化 Java 开发中的复杂性。在这个工程中，展示了基于 XML 的配置文件中如何配置 bean 和切面，但这些文件是如何加载的呢？他们被加载到哪里呢？接下来让我们了解下 Spring 容器，这是应用中的所有 bean 所驻留的地方。 1.2 容纳你的Bean在基于Spring的应用中，你的应用对象存在于Spring容器(container)中.Spring负责创建对象，装配它，并管理它们的整个生命周期，从生存到死亡(new 到finalize())。 首先重要的是了解容纳对象的容器。理解容器将有助于理解对象是如何创建的。 容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件爱你之间的联系。这些对象更简单干净、更容易理解，更易于重用并且易于进行单元测试。 Spring容器并不只是只有一个，Spring自带了多个容器实现，可以归纳为两种不同的类型： Bean工厂。由org.springframework.beans.factory.BeanFactory接口定义的。是最简单的容器。 应用上下文 由org.springframework.context.applicationContext接口定义的。基于BeanFactory构建，并提供应用框架级别的服务，例如：从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听器。 应用上下文比Bean工厂更受欢迎。bean工厂对于大多数应用来说太低级了。 1.2.1使用应用上下文Spring自带了多种应用上下文： AnonotationConfigApplicationContext：从一个或多个基于Java的配置文件类中加载Spring应用上下文 AnnotationConfigWebApplicationContext：从一个或多个基于Java配置类加载SpringWeb应用上下文 ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源 FileSystemXmlapplicationContext：从文件系统下的一个或多个XMl配置文件中加载上下文定义 XmlWebapplicationContext：从web应用下的一个或多个XML配置文件中加载上下文定义 无论是从文件系统中装配应用上下文还是从类路径下装配应用上下文，将bean加载到bean工厂的过程都是相似的。 加载一个FileSystemXmlApplicationContext: 在文件系统的路径下查找knight.xml 12ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml"); 也可以使用ClassPathXmlApplicationContext: 所有的类路径下查找knight.xml12ApplicationContext context = new ClassPathXmlApplicationCOntext("knight.xml"); 也可以从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext 12ApplicationContext context = new AnonotationConfigApplicationContext( com.guo.knights.config.KnightConfig.class); 应用上下文准备就绪之后，我们就可以调用上下文的getBean()方法从Spring容器中获取bean。 1.2.2 bean的生命周期在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后bean就可以使用了。一旦bean不再使用，则由JCM自动进行垃圾回收。 相比之下，Spring容器中的bean声明周期就显得复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。 在bean工厂执行力若干启动步骤； 1、Spring对bean进行实例化 2、Spring将值和 bean的引用注入到bean对应的属性中。 3、如果bean实现类beanNameAware接口，Spring将bean的ID传给setBean-Name()方法 4、如果bean实现类BeanFactoryAware接口，Spirng将调用setBeanFatory()方法，将BeanFactory容器实例传入。 5、如果bean实现类applicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传递进来。 6、如果bean实现类BeanPostProcessor接口，Spring将调用它们的postProcessBeforInitialization()方法 7、如果bean实现类InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法，如果类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用。 8、如果bean实现类BeanPostProcessor接口，Spring将调用它们的PostProcessAfterInitialization()方法 9、此时，bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁。 10、如果bean实现类DisPosableBean接口，Spring将调用他的destroy()接口方法。同样，如果bean使用destroy-mothod声明销毁方法，该方法也会被调用。 1.3俯瞰Spring风景线Spring实际上的功能超乎你的想象 1.3.1 Spring模块这些模块依据其所属的功能划分为6类不同的功能，总而言之，这些模块为开发企业及应用提供了所需的一切 。但是你也不必将应用建立在整个Spring框架上，你可以自由的选择合适自身应用需求的Spring模块：当Spring不能满足需求时，完全可以考虑其他选择，事实上，Spring甚至提供了与其他的第三方框架和类库的集成点,这样你就不需要自己编写代码了。 Spring核心容器 容器是Spring最核心的部分，它管理者Spring应用中bean的创建、配置、管理。在该模块中，包括了Spring bean工厂，它为Spring提供了DI的功能，甚至bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。 所有的Spring模块都构建于核心容器之上。当你配置应用时，其实你隐式的使用率这些类。 SpringAOP模块在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦，借助于AOP，可以将遍布系统的应用的关注点(例如：事务，安全，日志)从它们所应用的对象中解耦出来。 数据访问与集成 使用JDBC编写代码通常会导致大量的样式代码，Spring的JDBC和DAO模块抽象类这些样板代码，是我们的数据库代码变得简单明了。还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，以后我们再也不需要解释那些隐晦专有的SQL信息了。 Spring提供了ORM模块，Spring的ORM模块建立在DAO的支持之上，并为多个ORM框架提供了一种构建DAO的简便方式 。Spring没有尝试去创建自己的ORM解决方，而是对许多流行的ORM框架进行了集成。包括Hibernater、Java Persisternce API、Java Data Object 和mybatis。Spring的事务管理支持所有的ORM框架以及JDBC。 Web与远程调用MVC(Model-View-Controller)模块是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离，Java从来不缺少MVC框架，Apache的struts2、JSF、WebWorks都是可选的最流行的MVC框架。Spring远程调用功能集成了RMI(Remote mehtod Invocation)、Hessian、CXF。Spring还提供了暴露和使用RESTAPI的良好支持。 InstrumentationSpring的Instrumentation模块提供了为JVM添加代理(agent)的功能.具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件时被类加载器加载的一样。 Testing通过该模块，你会发现Spring为JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象事项，对于继承测试，该模块为加载Spring应用上下文中的bean集合以及与Spirng上下文中的bean进行交互提供了支持。 1.3.2 Spring Portfolio如果仅仅停留在和性的Spring框架层面，我们将错过Spring Portlio所提供的巨额财富。整个Spirng Portlio包括多个构建与核心Spring框架之上的框架和类库。概括的来讲，整个Spring Portlio几乎为每一个领域的Java开发都提供了Spring编程模型 Spring Web Flow:是建立与Spring MVC框架之上，它为基于流程的会话式Web应用(购物车、向导功能)提供了支持。 Spirng Security:安全度与许多应用都是一个非常关键的切面。利用SpringAOP，SpringSecurity为Spring应用提供了声明式的安全机制。 Spring Data：使得在Spring中使用任何数据库都变得非常容易。一种新的数据库种类，通常被称为NoSQL数据库，提供了使用数据的新方法，为所中数据库提供了一种自动化的Repository机制，它负责为你创建Repository的实现 Spring Boot： Spring极大的简化了众多编程的任务，减少甚至消除了很多样板式代码。Spring Boot大量依赖于自动配置技术，它能够消除大部分Spring配置。还提供了多个Starter项目，不管你是用Maven还是Gradle，这都能减少Spring的工程构建文件的大小。 1.4 Spring的新功能1.4.1 Spring3.1新特性Spring 3.1带来了多项有用的新特性 和增强，其中有很多都是关于如何简化个改善配置的。除此之外，Spring3.1还提供了声明式缓存的支持以及众多针对SpringMVC的的功能增强。 借助于profile，就能根据应用布置在什么环境之中选择不同的数据源 基于Java配置，Spring3.1增加了多个enable注解，启用Spring特定功能 对声明式缓存的支持，能够 使用简单的注解声明缓存的边界和规则， 开始支持Servlet3.0，包括在基于Java的配置中 申明Servlet和Filter，而不再借助于web.xml 1.4.2 Spring 3.2新特性Spring 3.2主要关注Spring MVC的一个发布版本。 Spring MVC 3.2带来如下的功能提升 控制器(Controller)可以使Servlet3.0异步请求，允许在一个独立的线程中处理请求，从而就爱那个Servlet线程解放出来处理更多的请求 @Autowired、@Value、@Bean注解能够作为元注解。用于创建自定义的注解和bean的申明注解 Spring的声明式缓存提供了对JCache0.5的支持。 1.4.3 Spring 4.0新特性 Spring提供了对WebSocket编程的支持， 新的消息模块， 支持Java8的新特性，比如：Lambda，函数式， 为 Groovy开发的应用程序提供了更加顺畅的编程体验 添加了条件化创建bean的功能 Spring4.0包含了Spring RestTemplate的一个新的异步实现。它会立即返回并且允许在操作完成后执行回调 添加了对多项JEE规范的支持，包括JMS 2.0 、JTA1.2 JPA 2.1 1.4.4 Spring 5.0新特性 在Spring Framework代码中使用JDK 8特性 响应式编程是Spring Framework 5.0最重要的功能之一 除了响应式特性之外，Spring 5还提供了一个函数式Web框架。 Spring Framework 5.0 引入了对 JetBrains Kotlin 语言的支持。 1.5 小节Spring致力于简化企业级开发Java开发、促进代码的松耦合。成功的关键在于依赖注入和AOP。 DI是组装应用对象的一种方式，借助于这种方式对象无需知道依赖来自于何处或者依赖的具体实现方式。不同于自己获取依赖对象，对象会在运行期赋予它们所依赖的对象。依赖对象通常会通过接口了解所注入的对象，这样的话就能确保低耦合。 除了DI，还简单介绍了Spring对AOP的支持，AOP可以帮助应用将散落在各处的逻辑汇集于一处——切面。当Spring装配bean的时候，这些切面能够运行期编织起来，这样就能呢个非常有效的赋予bean新功能。 依赖注入和AOP是Spring框架最核心的部分，只有理解了如何应用Spring是最关键的功能。你才有能力使用Spring框架的其他功能。 参考：https://juejin.im/post/5a8bef5c6fb9a06350151fa3]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《重构》阅读笔记 - 代码的坏味道]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-1%2F</url>
    <content type="text"><![CDATA[重复代码（Duplicated Code）如果你在一个以上的地方看到相同的程序结构，那么可以肯定：设法将它们合而为一，程序会变得更美好！你需要决定这个重复的代码放在哪里比较合适，并确保它被安置之后就不会在别的地方再次出现。 过长函数（Long Method）程序越长越难以理解。现代 OO 语言几乎完全免去了进程内的函数调用开销，因此，你应该积极地分解函数。我们应该遵循原则：每当需要以注释来说明点什么的时候，我们就需要把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。如何确定需要提炼哪一段代码：寻找注释、条件表达式、循环。 过大的类（Large Class）如果你发现一个类试图做太多事情，其内部就会出现很多不相关的实例变量，此时这个类的职责就不明确了。 过长参数列（Long Parameter List）太长的参数队列难以理解，太多参数的接口对于使用者来说十分不友好，而且容易出错。如果可以使用一个对象代替参数列表，那么就应该这么做。 发散式变化（Divergent Change） VS 霰弹式修改（Shotgun Surgery）一旦需要修改，我们希望只在系统的一个地方进行修改，否则，就属于两种非常相似的坏味道的一种：如果某个类经常因为不同的原因在不同的地方发生变化，那么 Divergent Change 就出现了；如果系统每遇到一个小变化，就需要在多个不同的类内进行许多小修改，这属于 Shotgun Surgery。Divergent Change 是指 “一个类受多种变化的影响”，Shotgun Surgery 则指的是 “一种变化引发多个类的修改”。 平行继承体系（Parallel Inheritance Hierarchies）这其实是 Shotgun Surgery 的特殊情况——每当你为某个类添加一个子类，你也必须为它的兄弟类加一个子类。如果你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，就属于这种情况。 依恋情结（Feature Envy）面向对象的精髓在于：“将数据和对数据的操作行为包装在一起”。有一种气味是：函数对某个类的兴趣高过自己所处的类的兴趣。有很多时候，我们看到一个函数为了计算某个值，从另一个对象那儿调用了几乎半打的取值函数。最根本的原则是：将总是一起变化的东西放在一起。 数据泥团（Data Clumps）你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些绑在一起出现的数据真应该拥有属于它们自己的对象。减少字段和参数的个数，当然可以去除一些坏味道，但更重要的是：一旦拥有新对象，你就有机会寻找 Feature Envy，这可以帮你指出能够移至新类中的种种方法。 基本类型偏执（Primitive Obsession）对象技术的新手通常不愿意在小任务上运用对象——例如结合数值和币种的 Money 类、由一个起始值和一个结束值构成的 Range 类、电话号码或邮政号码等的特殊字符串。 switch 语句（Switch Statements）从本质上讲，switch 语句的问题在于重复，面向对象的多态特性可以优雅地解决这个问题。如果你只是在单一函数内有些选择事例，那么用多态就属于杀鸡用牛刀了，这种情况下 Replace Parameter with Explicit Methods 是个不错的选择，如果你的选择之一是 null，记得使用 Introduce Null Object。 多余的类（Lazy Class）你所创建的每一个类，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个类的所得不值得其身价，就应该消除这个类。 过度设计（Speculative Generality）当有人说 “噢，我想我们有一天需要做这个事情”，并因此而企图以各种各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。软件设计不可过度设计，否则会使得系统难以理解和维护。 令人迷惑的暂时字段（Temporary Field）有时你会看到这样的现象：类内的某个实例变量仅为某种特定情况而设。这样的代码不易理解，因为通常认为对象在所有时候都需要它的所有变量。 过度耦合的消息链（Message Chains）如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象…… 这就是消息链。实际代码中你看到的可能是一长串 getXXX() 调用，意味着客户代码将与查找目标对象过程中的导航结构紧密耦合，一旦对象间的关系发生任何变化，客户端就会受到影响。 中间人（Middle Man）对象的基本特征之一是封装——对外部世界隐藏其内部细节。封装往往伴随着委托，比如你问主管是否有时间参加一个会议，他就把这个消息 “委托” 给他的记事簿，然后才能回答你——你没有必要这位主管到底是使用传统记事簿或电子记事簿或秘书来记录自己的约会。但是，不要过度使用委托——你也许会看到某个类有一半接口都委托给其他类。 狎昵关系（Inappropriate Intimacy）类与类之间过分紧密的关系必须拆散——可以引入第三方类或者利用委托。 异曲同工的类（Alternative Classes with Different Interfaces）如果两个函数做同一件事，却有着不同的签名，请运用 Rename Method 根据它们的用途重新命名。但这往往不够，请反复运用 Move Method 将某些行为移入类，知道这两个函数的协议一致为止。如果你必须移动大量代码才可以完成这个工作，那还不如直接构建一个父类。 不完美的库类（Incomplete Library Class）复用常常被认为是面向对象技术的终极目标。很多第三方库提供的接口经常不能恰如其分得满足我们的需求，这时候就需要对第三方接口做一层转换，或者给它添加一定的行为。 数据类（Data Class）所谓 Data Class，指的是：这种类拥有一些字段，以及用于访问（读、写）的函数，除此之外啥都没有。这样的类只是一种不会说话的数据容器，它们一定被其他类过分细碎得控制着。Data Class 就像小孩子，作为一个起点很好，但若要让它们像成熟的对象那样参与整个系统的工作，它们就必须承担一定责任。但是，在 Spring 框架开发中，我们经常需要定义很多 domain 对象。 被拒绝的遗嘱（Refused Request）子类应该继承超类的函数和数据，但如果它们不想或者不需要继承，又该怎么办呢？按照传统说法，这就意味着继承体系的设计错误。你需要为这个子类新建一个兄弟类，然后让父类只包括两个子类共享的部分。一般而言，这就足够了，但是如果子类不愿意支持超类提供的接口，则说明不能使用继承处理，应该使用委托。 过多的注释（Comments）常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。当你需要些注释时，要先尝试重构下代码，争取让代码拥有自说明性。 参考：https://www.jianshu.com/p/41e889181536?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-2%2F</url>
    <content type="text"><![CDATA[以下内容来自《深入了解java虚拟机》的后几章 物理机如何处理并发问题？运算任务，除了需要处理器计算之外，还需要与内存交互，如读取运算数据、存储运算结果等（不能仅靠寄存器来解决）。计算机的存储设备和处理器的运算速度差了几个数量级，所以不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache），作为内存与处理器之间的缓冲：将运算需要的数据复制到缓存中，让运算快速运行。当运算结束后再从缓存同步回内存，这样处理器就无需等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓存，它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存时，可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时遵循缓存一致性协议。同时为了使得处理器充分被利用，处理器可能会对输出代码进行乱序执行优化。Java 虚拟机的即时编译器也有类似的指令重排序优化。 Java 内存模型什么是 Java 内存模型？Java 虚拟机的规范，用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各个平台下都能达到一致的并发效果。 Java 内存模型的目标？定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。此处的变量包括实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是线程私有的，不会被共享，所以不存在竞争问题。 主内存与工作内存所以的变量都存储在主内存，每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存。 内存间的交互操作一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存，Java 内存模型定义了 8 种操作： 原子性、可见性、有序性 原子性：对基本数据类型的访问和读写是具备原子性的。对于更大范围的原子性保证，可以使用字节码指令 monitorenter 和 monitorexit 来隐式使用 lock 和 unlock 操作。这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字。因此 synchronized 块之间的操作也具有原子性。 可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取之前从主内存刷新变量值来实现可见性的。volatile 的特殊规则保证了新值能够立即同步到主内存，每次使用前立即从主内存刷新。synchronized 和 final 也能实现可见性。final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么其他线程中就能看见 final 字段的值。 有序性：Java 程序的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）；如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序和工作内存与主内存同步延迟线性）。 volatile什么是 volatile？关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。当一个变量被定义成 volatile 之后，具备两种特性： 保证此变量对所有线程的可见性。当一条线程修改了这个变量的值，新值对于其他线程是可以立即得知的。而普通变量做不到这一点。 禁止指令重排序优化。普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。 为什么基于 volatile 变量的运算在并发下不一定是安全的？volatile 变量在各个线程的工作内存，不存在一致性问题（各个线程的工作内存中 volatile 变量，每次使用前都要刷新到主内存）。但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。 为什么使用 volatile？在某些情况下，volatile 同步机制的性能要优于锁（synchronized 关键字），但是由于虚拟机对锁实行的许多消除和优化，所以并不是很快。 volatile 变量读操作的性能消耗与普通变量几乎没有差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 并发与线程并发与线程的关系？并发不一定要依赖多线程，PHP 中有多进程并发。但是 Java 里面的并发是多线程的。 什么是线程？线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O），又可以独立调度（线程是 CPU 调度的最基本单位）。 实现线程有哪些方式？ 使用内核线程实现 使用用户线程实现 使用用户线程 + 轻量级进程混合实现 Java 线程的实现操作系统支持怎样的线程模型，在很大程度上就决定了 Java 虚拟机的线程是怎样映射的。 Java 线程调度什么是线程调度？线程调度是系统为线程分配处理器使用权的过程。 线程调度有哪些方法？ 协同式线程调度：实现简单，没有线程同步的问题。但是线程执行时间不可控，容易系统崩溃。 抢占式线程调度：每个线程由系统来分配执行时间，不会有线程导致整个进程阻塞的问题。 虽然 Java 线程调度是系统自动完成的，但是我们可以建议系统给某些线程多分配点时间——设置线程优先级。Java 语言有 10 个级别的线程优先级，优先级越高的线程，越容易被系统选择执行。 但是并不能完全依靠线程优先级。因为 Java 的线程是被映射到系统的原生线程上，所以线程调度最终还是由操作系统说了算。如 Windows 中只有 7 种优先级，所以 Java 不得不出现几个优先级相同的情况。同时优先级可能会被系统自行改变。Windows 系统中存在一个 “优先级推进器”，当系统发现一个线程执行特别勤奋，可能会越过线程优先级为它分配执行时间。 线程安全的定义？当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。 Java 语言操作的共享数据，包括哪些？ 不可变 绝对线程安全 相对线程安全 线程兼容 线程对立 不可变在 Java 语言里，不可变的对象一定是线程安全的，只要一个不可变的对象被正确构建出来，那其外部的可见状态永远也不会改变，永远也不会在多个线程中处于不一致的状态。 如何实现线程安全？虚拟机提供了同步和锁机制。 阻塞同步（互斥同步） 非阻塞同步 阻塞同步（互斥同步）互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。Java 中最基本的同步手段就是 synchronized 关键字，其编译后会在同步块的前后分别形成 monitorenter 和 monitorexit 两个字节码指令。这两个字节码都需要一个 Reference 类型的参数指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那么这个对象就是 Reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去获取对应的对象实例或 Class 对象作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。 如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器 + 1；当执行 monitorexit 指令时将锁计数器 - 1。当计数器为 0 时，锁就被释放了。 如果获取对象失败了，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。 除了 synchronized 之外，还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步。ReentrantLock 比 synchronized 增加了高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，对处理执行时间非常长的同步块很有用。 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的。 非阻塞同步互斥同步最大的问题，就是进行线程阻塞和唤醒所带来的性能问题，是一种悲观的并发策略。总是认为只要不去做正确的同步措施（加锁），那就肯定会出问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。 锁优化是在 JDK 的那个版本？JDK1.6 的一个重要主题，就是高效并发。HotSpot 虚拟机开发团队在这个版本上，实现了各种锁优化： 适应性自旋 锁消除 锁粗化 轻量级锁 偏向锁 为什么要提出自旋锁？互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来很大压力。同时很多应用共享数据的锁定状态，只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。先不挂起线程，等一会儿。 自旋锁的原理？如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，让后面请求锁的线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放。为了让线程等待，我们只需让线程执行一个忙循环（自旋）。 自旋的缺点？自旋等待本身虽然避免了线程切换的开销，但它要占用处理器时间。所以如果锁被占用的时间很短，自旋等待的效果就非常好；如果时间很长，那么自旋的线程只会白白消耗处理器的资源。所以自旋等待的时间要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，那就应该使用传统的方式挂起线程了。 什么是自适应自旋？自旋的时间不固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果一个锁对象，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行，那么虚拟机认为这次自旋仍然可能成功，进而运行自旋等待更长的时间。 如果对于某个锁，自旋很少成功，那在以后要获取这个锁，可能省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机也会越来越聪明。 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。 程序员怎么会在明知道不存在数据竞争的情况下使用同步呢？很多不是程序员自己加入的。 锁粗化原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。 锁粗化就是增大锁的作用域。 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 偏向锁消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。即在无竞争的情况下，把整个同步都消除掉。这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。 以下内容来自《java核心技术 卷一 第14章》 第十四章：并发Thread：static Thread currentThread() 获取当前线程static void sleep(long millis) 休眠指定的毫秒数 (当前线程)static void yield() 导致当前线程处于让步状态 (当前线程)static boolean interrupted() 检测线程中断状态并置位为 false(当前线程)boolean isInterrupted() 只检测线程中断状态void interrupt() 向线程发送请求，请求中断线程void join() 等待终止指定的线程 (其他线程调用)Thread.State getState() 得到线程状态 (6 种)void setPriority(int newPriority) 设置线程优先级 MIN_PRIORITY=1/NORM_PRIORITY=5/MAX_PRIORITY=10void setDaemon(boolean isDaemon) 设置线程为守护线程，必须在线程启动之前调用 Object：void wait() 导致线程进入等待状态直到它被通知void nitify() 随机选择一个在该对象上调用 wait 方法的线程，解除其阻塞状态vodi notifyAll() 解除那些在该对象上调用 wait 方法的线程的阻塞状态 多线程： 几个概念：• 多任务系统：操作系统将 CPU 时间片分配给每一个进程，给人以并行处理的感觉。但是并发进程数并不是由 CPU 数目制约的。• 多线程程序：一个程序 (进程) 可以同时执行多个任务，同时运行一个以上的线程。• 进程与线程：每个进程拥有自己的一套变量，而每个线程共享数据。一个进程相当于一个应用程序，一个进程中可以包含多个线程，其中有一个主线程，其余都是工作线程，线程更轻量级。 不要直接调用 Thread 或 Runnable 的run()方法，它只会执行一个线程中的任务 (当前线程)，而不会启动一个新线程，要使用thread.start()来开启 (Runnable 就是包装业务逻辑的类，在指定的时间和线程中执行某段代码)。 没有什么强制终止线程的方法，interrupt()用来请求终止线程；如果线程被阻塞 (调用 sleep 或 wait 方法)，interrupt()将抛出异常；如果在中断状态被置位时调用sleep()不会引起休眠且会清除中断状态并抛异常，因此中断置位后就别进行其他操作了；中断请求只是先标记一个状态，被中断的线程可以决定如何响应中断。 静态方法interrupted()检测当前线程是否中断且清除中断状态；实例方法isInterrupt()检测是否被中断且不改变中断状态；实例方法interrupt()请求中断。 线程的 6 种状态：New(新创建)、Runnable(可运行)、Blocked(被阻塞)、Waiting(等待)、Timed waiting(计时等待)、Terminated(被终止)。 调用start()后线程进入可执行状态，不一定是立即执行，取决于操作系统给线程提供运行的时间。这里安卓的Handler.post()是等本方法体执行完，才有可能执行 runnable 里的逻辑，而线程的start()方法后 runnable 里的执行逻辑和本方法体里的下一行不一定谁先执行呢。 两种操作系统调度方式：• 抢占式调度：系统给每一个可运行线程分配时间片来执行任务，当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。• 协作式调度：一个线程只有在调用 yield 方法、被阻塞或等待时，线程才会失去控制权。 几种状态的区别：• 阻塞状态：一个线程试图获取一个对象的内部对象锁，而该锁被其他线程所持有，则该线程进入阻塞状态，当其他线程释放该锁，且线程调度器允许本线程持有它的时候，该线程变为非阻塞状态 (正常竞争对象锁)，相当于自动解锁。• 等待状态：可理解为阻塞的一种，当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。如调用 Object.wait()、thread.join()、Lock 或 Condition 时出现 (手动阻塞，必须被其他线程主动唤醒，可能出现死锁)。• 计时等待：等待状态一直保持到超时期满或者接收到适当的通知。如调用 Thread.sleep()、Object.wait()、thread.join()、Lock.tryLock() 或 Condition.await() 时出现。 每个线程有一个优先级，默认继承父线程优先级，范围为 MIN_PRIORITY(1)~MAX_PRIORITY(10) 之间，NORM_PRIORITY 为 5。当线程调度器有机会选择新线程时，它会优先选择优先级较高的线程，但是这个过程是高度依赖于操作系统的。 守护线程：调用thread.setDaemon(true)将线程转换为守护线程，唯一用途是为其他线程服务，当只剩下守护线程时，虚拟机就退出了。守护线程应该永远不去访问固有资源、文件等，因为它会在任何时候发生中断。 线程的run()方法不能抛出任何受查异常，但是，非受查异常会导致线程终止。这时候可以用setUncaughtExceptionHandler(实例方法) 来为任何一个线程安装一个处理器。也可以用Thread.setDefaultUncaughtExceptionHandler(静态方法) 来为所有线程安装一个默认的处理器。默认处理器默认为 null，实例处理器默认为线程的 ThreadGroup 对象。ThreadGruop 内部其实还是优先使用父处理器 -&gt; 默认处理器等来处理的，如果都没就 System.err 输出日志并崩溃退出。 同步： 同步的作用就是要保证一组操作的原子性。如线程安全队列保证了对该队列操作的线程安全 (队列的内部锁)，但是外部调用时如果有判断逻辑，就要保证判断逻辑上下的原子性 (外部调用者的对象锁)，最好每次使用都判下空，其实也没有绝对的线程安全。 锁对象 Lock： Java 提供了synchronized关键字和 Java SE5 中引入的ReentrantLock类来解决线程同步问题，将某一段代码控制为原子性操作。 一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句，但其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。把解锁操作放在finally语句中很重要，如果代码抛出异常，锁必须被释放 (注意异常退出的话要回滚避免对象损坏)。如果使用锁，就不能使用带资源的 try 语句。 注意例子中每个对象有自己的ReentrantLock锁对象，如果两个线程试图访问同一个对象，那么锁以串行的方式提供服务。访问不同的对象，则不会发生阻塞。 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数器来跟踪 lock 方法的嵌套调用。线程在每一次调用lock()后都要调用unlock()来释放锁。被一个锁保护的代码可以调用另一个使用相同的锁的方法。注意异常时要先回滚，否则对象可能处于一种受损状态。 条件对象 Condition： 数据结构本身是安全的话 (如例子中的 Bank 类的 transfer 方法)，在外部调用如果有判断逻辑还是可能会不安全 (如上面所讲锁对象已经不是一个层级的了)，这时要么在外部使用加锁控制判断逻辑，要么在内部 transfer 方法添加条件锁判断逻辑。 条件对象：一个锁可以有一个或多个相关的条件对象。等待获得锁的线程和调用了 await 方法的线程本质上不同。一旦一个线程调用await()，它进入该条件的等待集，当锁可用时，该线程不是马上解除阻塞，而是等待直到另一线程调用同一条件上的signalAll()方法为止 (阻塞是得到锁自己就唤醒，等待是必须由其他线程来唤醒 (相互 await 死锁现象，死锁发生的原因是有超出条件限制的操作导致可能同时双方都不满足条件而相互等待))。 signalAll()不会立即激活一个等待线程，它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对象的访问。signal()注意是 “随机” 解除一个线程的阻塞。仅可在该条件上调用await()、singal()或singalAll()。被激活的线程从之前await()的方法出继续执行。 Synchronized 关键字： Java 中的每一个对象都有一个内部锁，如果方法用synchronized声明，那么对象锁将保护整个方法。内部对象锁只有一个相关条件，wait()方法添加一个线程到等待集中，notify()/nitifyAll()方法解除等待线程的阻塞状态。这三个方法必须在synchronized代码块中，也就是必须先拿到锁才能等待 (condition 也是先 lock() 后才能 await()等)。缺陷：不能中断一个正在获得锁的线程、锁不能设置超时、条件是单一的。 实例方法上加synchronized关键字锁的是该实例的这个和所有同步实例方法，通过获取该对象的内部锁来实现；静态方法上加synchronized关键字锁的是同一个类的这个或任何其它的同步静态方法，通过获取该类对象的内部锁实现。 实现同步的两种方式：①在方法上添加synchronized关键字来实现同步 (使用自己的内部对象锁)。②通过synchronized(obj)进入一个同步阻塞。(使用一个其他 Obj 的对象锁，道理其实是一样的，都是拿到对象的内部锁来 lock) 注意条件对象有await()、singal()、singalAll()方法；对象是wait()、notify()、notifyAll()方法。对象的几个方法内也是获取内部锁对象进行同步的，要放到synchronized代码块中，先lock()获取锁才能wait()等操作。 volatile 关键字：• 为实例域的同步访问提供一种免锁机制，更轻量级，如果声明一个域为volatile，那么编译器和虚拟机就知道该域可能被另一个线程并发更新。• 作用：禁止指令重排序 (操作系统可以对指令集重排序的(分配内存 -&gt; 初始化对象 -&gt;赋值空间地址给引用)；实现可见性(针对变量)；保证有序性(long、double 等类型)。• 注意：volatile 保证可见性、有序性，不保证原子性，因为有序、可见是针对域的锁定，原子性是一系列操作，已经不是同一级别的锁了，可以在原子操作外部加锁，也可使用 CAS(轻量级的判断 / 再赋值锁)。 线程安全方法 有时候要避免共享变量，使用 ThreadLocal 辅助类可以为各个线程构造单独的实例。ThreadLocal 提供了set()和get()访问器用来访问与当前线程相关联的线程局部变量；ThreadLocal 中有个内部类 ThreadLocalMap，key 为 ThreadLocal，value 为变量 T；每个线程有个变量threadLocals(即 ThreadLocalMap)，在调用set()方法时会取到线程当前这个 map 是否为空，空的话就createMap()，否则就将 key 设为 ThreadLocal，value 设为原共享变量 T 的副本存进去，因此每个线程可以放多个 ThreadLocal 包装过的变量，这些变量线程间独享。 lock()方法获取锁会阻塞；tryLock()方法试图申请一个锁，在成功获得锁后返回 true，否则立即返回 false。lock()方法不能被中断，如果出现死锁lock()就无法终止；带超时的tryLock()方法被中断会抛异常，允许程序打破死锁。 读写锁ReentrantReadWriteLock的readLock()得到一个允许多线程读，排斥写的锁，或者writeLock()得到一个排斥其他读写操作的锁。 线程的stop()方法会立即终止所有未结束的方法，包括run()方法，因此有可能导致对象状态损坏，因此被弃用了。应当在合适的时候中断线程，线程会在安全的时候停止。 阻塞队列 对多线程问题，可以用一个或多个队列以安全的方式将其形式化，生产者向线程队列中插入元素，消费者从中取出它们；可以将例子中的转账指令插入某一队列，而另一个线程从队列中取指令执行，不直接操作 bank 对象，队列自己控制好线程安全即可，对 bank 对象进行操作 (单线程执行，类似 Handler，避免显示控制同步)。 当队列为空或者已满时，阻塞队列将导致操作的线程阻塞：add()/remove()/element()方法会抛异常、offer()/poll()/peek()方法不阻塞也不会抛异常、take()/put()方法会导致阻塞。 阻塞队列的几种类型：• ArrayBlockingQueue(带有指定容量的循环数组阻塞队列)• LinkedBlockingQueue(无上限链表阻塞队列)• PriorityBlockingQueue(无边界的优先堆阻塞队列)• DelayQueue(无边界的阻塞时间有限的阻塞队列) 几种线程安全的集合：• ConcurrenHashMap• ConcurrentSkipListMap• ConcurrentSkipListSet• ConcurrentLinkedQueue集合返回弱一致性的迭代器，不一定能反映出他们被构造之后的所有修改。 并发集视图：ConcurrentHashMap.&lt;T&gt;newKeySet()。写数组拷贝：CopyOnWriteArrayList、CopyOnWriteArraySet，并发读，写的时候生成一个副本，占用双倍内存。 任何集合类都可以使用同步包装器变为线程安全的：Collections.synchronizedList(new ArrayList&lt;E&gt;())、Collections.synchronizedMap(new HashMap&lt;K,V&gt;())。 线程池 Runnable 封装一个无返回值的异步任务，可用在线程或线程池中；Callable 封装一个有返回值的异步任务，只能放在线程池中。 Future 保存并管理异步计算的结果；FutureTask 实现了 Ruannable 和 Future 两个接口，可把自己提交给线程池，完了从自己拿处理结果。 如果程序中创建了大量生命周期很短的线程，或为了减少并发线程的数目，就应该使用线程池。 四种常用线程池：• CachedThreadPool(核心 = 0，最大 = MAX，0 长度阻塞队列，空线程保持 60s，适用于较多异步任务)• FixedThreadPool(核心 = 最大 = 固定数，MAX 长度阻塞队列，适用快速执行任务)• SingleThreadPool(核心 = 固定 = 1，顺序执行任务)• ScheduledThreadPool(延迟执行或延迟后周期执行的线程池)。 submit()方法提交任务，得到一个 Future 对象用于管理结果；shutdown()方法启动线程池关闭序列，被关闭的线程池不再接受新任务，所有任务执行完后线程池死亡；shotdownNow()方法取消尚未开始的所有任务并试图中断正在执行的线程。 同步器 几种常用同步器：• 信号量 Semaphore：一个信号量管理许多的许可证，为了通过信号量，线程通过调用acquire()方法请求许可，否则等待，信号量其实仅维护一个计数，因此用于控制同一时刻的线程数量。任何线程都可以通过release()释放任意数目的许可。• 倒计时门栓 CountDownLatch：让一个线程集等待直到计数器变为 0，用于暂停某个线程等待其他线程执行完必备操作后继续执行。它是一次性的，一旦计数器变为 0，就不能再重用了。• 循环栅栏 CyclicBarrier：允许线程集到达一个公共栅栏 (等待到指定数目) 后执行某段逻辑，然后各自再继续执行(先到达的先 await)。如果任何一个在栅栏上等待的线程离开了栅栏，栅栏就被破坏了，如等待线程的 await 方法超时或者被中断了，这时其他线程的 await 方法会抛异常，那些已经等待的线程会立即终止 await 的调用。 同步队列：将生产者和消费者线程配对的机制。当一个线程调用 SynchronousQueue 的put()方法时，它会阻塞直到另一个线程调用take()方法为止，反之亦然。数据仅沿一个方向传递，从生产者到消费者。它不是一个队列，没有包含任何元素，size()方法总是返回 0。重点：都很重要 补充知识点 Java 内存分配：①运行时数据区域：方法区、堆区、栈区 (虚拟机栈、本地方法栈)、程序计数器。前两者是线程共享区、后面的是线程隔离区。②各部分作用：• 程序计数器：当前线程所执行的字节码的行号指示器，这个计数器记录的是在正在执行的虚拟机字节码指令的地址，当执行的是 Native 方法，这个计数器值为空。此内存区域是唯一一个没有规定任何 OutOfMemoryError 情况的区域 。• Java 虚拟机栈：线程私有的 ，它的生命周期与线程相同。存储方法执行时的局部变量表、操作数栈、方法出口等，含有基本数据类型、引用类型的空间地址。如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。• 本地方法栈：与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。• Java 堆：所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例 ，是垃圾收集器管理的主要区域，由 GC 管理内存的回收，有一套自己的回收机制。如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出 OutOfMemoryError 异常。• 方法区：又称静态存储区，各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 ，运行时常量也是其中一部分。垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需要时，将抛出 OutOfMemoryError 异常。③对象的创建过程：创建一个对象通常是需要 new 关键字，当虚拟机遇到一条 new 指令时，首先检查这个指令的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有那么执行相应的类加载过程。类加载检查通过后，虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。Java 程序通过栈上的 reference 数据来操作堆上的具体对象。主要的访问方式有使用句柄和直接指针两种：句柄就是引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 ；直接指针指引用中存储的就是对象地址 。 ClassLoader• ClassLoader 的具体作用就是将 class 文件加载到 jvm 虚拟机中去，程序就可以正确运行了。但是，jvm 启动的时候，并不会一次性加载所有的 class 文件，而是根据需要去动态加载。• class 文件是字节码格式文件，java 虚拟机并不能直接识别我们平常编写的. java 源文件，所以需要 javac 这个命令转换成. class 文件。其他语言编写的代码只要能编译成. class 文件都可以被 java 虚拟机运行。• 三种 ClassLoader：①BootstrapClassLoader：最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib 下的 rt.jar、resources.jar、charsets.jar 和 class 等。②ExtClassLoader：扩展的类加载器，加载目录 %JRE_HOME%\lib\ext 目录下的 jar 包和 class 文件。③AppClassLoader：也称为 SystemAppClass 加载当前应用的 classpath 的所有类。• 加载顺序：BootstrapClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader。• ExtClassLoader 和 AppClassLoader 都是 UrlClassLoader 的子类。每个类加载器都有一个父加载器，AppClassLoader 的父加载器是 ExtClassLoader，ExtClassLoader 的父加载器是 null。一个 ClassLoader 创建时可以直接指定 parent，如果没有指定 parent，那么它的 parent 默认就是Launcher.getClassLoader()，即 AppClassLoader。• Bootstrap ClassLoader 是由 C/C++ 编写的，它本身是虚拟机的一部分，所以它并不是一个 JAVA 类，也就是无法在 java 代码中获取它的引用。• 双亲委托机制：一个类加载器查找 class 和 resource 时，是通过 “委托模式” 进行的，它首先判断这个 class 是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到 Bootstrap ClassLoader，如果 Bootstrap Classloader 找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象，再找不到就抛异常了。虽然 ExtClassLoader 的 parent 为 null，但是在找类时如果 parent 为 null 就调用findBootstrapClassOrNull(name)Bootstrap ClassLoader 去找。• 自定义 ClassLoader 可以根据自定义路径去加载 class 文件，从而将外部类加载进来并使用。一般复写findClass()方法和在findClass()方法中调用defineClass()方法。可以根据自己的规定来进行类加密解密操作，并自定义类加载器来解析类。]]></content>
      <tags>
        <tag>java并发</tag>
        <tag>待阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[instanceof 运算符用法]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-1%2F</url>
    <content type="text"><![CDATA[运算符是双目运算符, 左面的操作元是一个对象, 右面是一个类. 当 左面的对象是右面的类创建的对象时, 该运算符运算的结果是 true, 否则是 false 例如 a instanceof A如果 a 是类 A 的实例，就返回 true，否则的话，就返回 false。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455interface A&#123; &#125; class B implements A&#123; &#125; class C extends B&#123; &#125; public class Iinstanceof &#123; public static void main(String[] args) &#123; A ab=new B(); A ac=new C(); B bc=new C(); B bb=new B(); C cc=new C(); //对象实现一个接口，用这个对象和这个接口进行instanceof判断，都为true。 System.out.println(&quot;ab instanceof A=&quot;+(ab instanceof A)); System.out.println(&quot;ac instanceof A=&quot;+(ac instanceof A)); System.out.println(&quot;bc instanceof A=&quot;+(bc instanceof A)); System.out.println(&quot;bb instanceof A=&quot;+(bb instanceof A)); System.out.println(&quot;cc instanceof A=&quot;+(cc instanceof A)); //对象和父类进行instanceof判断，都为true System.out.println(&quot;ab instanceof B=&quot;+(ab instanceof B)); System.out.println(&quot;ac instanceof B=&quot;+(ac instanceof B)); System.out.println(&quot;bc instanceof B=&quot;+(bc instanceof B)); System.out.println(&quot;bb instanceof B=&quot;+(bb instanceof B)); System.out.println(&quot;cc instanceof B=&quot;+(cc instanceof B)); //对象和他的子类进行instanceof判断为false System.out.println(&quot;ab instanceof C=&quot;+(ab instanceof C)); System.out.println(&quot;ac instanceof C=&quot;+(ac instanceof C)); System.out.println(&quot;bc instanceof C=&quot;+(bc instanceof C)); System.out.println(&quot;bb instanceof C=&quot;+(bb instanceof C)); System.out.println(&quot;cc instanceof C=&quot;+(cc instanceof C)); &#125; &#125; [java] view plain copy//程序输出： ab instanceof A=true ac instanceof A=true bc instanceof A=true bb instanceof A=true cc instanceof A=true ab instanceof B=true ac instanceof B=true bc instanceof B=true bb instanceof B=true cc instanceof B=true ab instanceof C=false ac instanceof C=true bc instanceof C=true bb instanceof C=false cc instanceof C=true 参考：http://blog.csdn.net/cnmilan/article/details/41696093http://blog.csdn.net/cntanghai/article/details/6096976https://zhidao.baidu.com/question/1175062948955268939.html]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析Java对象的hashCode和hashCode在HashMap的底层数据结构的应用]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14%2F</url>
    <content type="text"><![CDATA[一、java对象的比较 等号(==)： 对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等； equals()： 对比两个对象实例是否相等。 当对象所属的类没有重写根类Object的equals()方法时，equals()判断的是对象实例的ID（内存地址），是否是同一对象实例；该方法就是使用的等号(==)的判断结果，如Object类的源代码所示： Java代码 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 当对象所属的类重写equals()方法（可能因为需要自己特有的“逻辑相等”概念)时，equals()判断的根据就因具体实现而异，有些类是需要比较对象的某些值或内容，如String类重写equals()来判断字符串的值是否相等。判断逻辑相等。 hashCode(): 计算出对象实例的哈希码，并返回哈希码，又称为散列函数。根类Object的hashCode()方法的计算依赖于对象实例的D（内存地址），故每个Object对象的hashCode都是唯一的；当然，当对象所对应的类重写了hashCode()方法时，结果就截然不同了。 二、Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。哈希算法也称为散列算法，当集合要添加新的元素时，将对象通过哈希算法计算得到哈希值（正整数），然后**将哈希值和集合（数组）长度进行&amp;运算**，得到该对象在该数组存放的位置索引。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就表示发生冲突了，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。 这样一来，实际调用equals方法比较的次数就大大降低了，几乎只需要一两次。 简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！ 三、Java 对象的equal方法和hashCode方法的关系 首先，Java对象相同指的是两个对象通过eqauls方法判断的结果为true Java对象的eqauls方法和hashCode方法是这样规定的： 1、相等**（相同）**的对象必须具有相等的哈希码（或者散列码）。 2、如果两个对象的hashCode相同，它们并不一定相同。 以下是Object对象API关于equal方法和hashCode方法的说明： If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.（如果两个对象根据equals（object）方法相等，则对这两个对象中的每个对象调用hashcode方法必须产生相同的整数结果。） It is not required that if two objects are unequal according to the equals(java.lang.Object)) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.（如果两个对象根据equals（java.lang.object）方法不相等，则不要求在两个对象中的每一个上调用hashcode方法都必须产生不同的整数结果。但是，程序员应该意识到，为不等对象生成不同的整数结果可能会提高散列表的性能。） 以上API说明是对之前2点的官方详细说明 关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？ 想象一下，假如两个Java对象A和B，A和B相等（eqauls结果为true），但A和B的哈希码不同，则A和B存入HashMap时的哈希码计算得到的HashMap内部数组位置索引可能不同，那么A和B很有可能允许同时存入HashMap，显然相等/相同的元素是不允许同时存入HashMap，HashMap不允许存放重复元素。 关于第二点，两个对象的hashCode相同，它们并不一定相同 也就是说，不同对象的hashCode可能相同；假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。 四、深入解析HashMap类的底层数据结构 Map接口 Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。 Hashtable类 Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。 Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”： Hashtable numbers = new Hashtable(); numbers.put(“one”, new Integer(1)); numbers.put(“two”, new Integer(2)); numbers.put(“three”, new Integer(3)); 要取出一个数，比如2，用相应的key： Integer n = (Integer)numbers.get(“two”); System.out.println(“two = ” + n); 1. HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 2. HashMap的数据结构：HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。首先，HashMap类的属性中定义了Entry类型的数组。Entry类实现java.ultil.Map.Entry接口，同时每一对key和value是作为Entry类的属性被包装在Entry的类中。 如图所示，HashMap的数据结构： HashMap的部分源码如下： Java代码 123456789101112131415/** * The table, resized as necessary. Length MUST Always be a power of two. * 长度必须是2的n次方 */transient Entry[] table; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; ……&#125; 可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。table数组的元素是Entry类型的。每个 Entry元素其实就是一个key-value对，并且它持有一个指向下一个 Entry元素的引用，这就说明table数组的每个Entry元素同时也作为某个Entry链表的首节点，指向了该链表的下一个Entry元素，这就是所谓的“链表散列”数据结构，即数组和链表的结合体。 3. HashMap的存取实现： 1) 添加元素： 当我们往HashMap中put元素的时候，先根据key的重新计算元素的hashCode，根据hashCode得到这个元素在table数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 HashMap的部分源码如下： Java代码 123456789101112131415161718192021222324252627 public V put(K key, V value) &#123; // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 如果发现 i 索引处的链表的某个Entry的hash和新Entry的hash相等且两者的key相同，则新Entry覆盖旧Entry，返回。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null;&#125; 2) 读取元素： 有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 HashMap的部分源码如下： 12345678910111213public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; 3) 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。 五、**实现**相等的对象必须具有相等的哈希码 如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。 同时复写equals方法和hashCode方法,必须保证“相等的对象必须具有相等的哈希码”，也就是当两个对象通过equals()比较的结果为true时，这两个对象调用hashCode（）方法生成的哈希码必须相等。 如何保证相等，可以参考下面的方法： 复写equals方法和hashCode方法时，equals方法的判断根据和计算hashCode的依据相同。如String的equals方法是比较字符串每个字符，String的hashCode也是通过对该字符串每个字符的ASC码简单的算术运算所得，这样就可以保证相同的字符串的hashCode相同且equals()为真。 String类的equals方法的源代码： Java代码 123456789101112131415161718192021222324252627282930313233343536/** * Compares this string to the specified object. The result is &#123;@code * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code * String&#125; object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the given object represents a &#123;@code String&#125; * equivalent to this string, &#123;@code false&#125; otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125;return false;&#125; Sring类的hashCode方法计算hashCode的源代码： 123456789101112131415161718192021222324252627 /** * Returns a hash code for this string. The hash code for a * &lt;code&gt;String&lt;/code&gt; object is computed as * &lt;blockquote&gt;&lt;pre&gt; * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * &lt;/pre&gt;&lt;/blockquote&gt; * using &lt;code&gt;int&lt;/code&gt; arithmetic, where &lt;code&gt;s[i]&lt;/code&gt; is the * &lt;i&gt;i&lt;/i&gt;th character of the string, &lt;code&gt;n&lt;/code&gt; is the length of * the string, and &lt;code&gt;^&lt;/code&gt; indicates exponentiation. * (The hash value of the empty string is zero.) * * @return a hash code value for this object. */ public int hashCode() &#123;int h = hash; int len = count;if (h == 0 &amp;&amp; len &gt; 0) &#123; int off = offset; char val[] = value; for (int i = 0; i &lt; len; i++) &#123; h = 31*h + val[off++]; &#125; hash = h; &#125; return h; &#125; 参考：http://kakajw.iteye.com/blog/935226]]></content>
      <tags>
        <tag>hashCode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机 知识点总结&面试题]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-1%2F</url>
    <content type="text"><![CDATA[1. 内存模型以及分区，需要详细到每个区放什么。 运行时数据区域：虚拟机栈，本地方法栈，程序计数器，堆，方法区，具体如图所示： 2.2.1 程序计数器（Program Counter Register） 概述：当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有2.无内存溢出：此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 概述：每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆的唯一目的就是存储对象的实例。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。 Eden 区的对象都是朝生夕死，发生 minor gc 的时候会清除 eden 区和 survival 区的，把存活的对象移到另一个 Survival 区，该 survial 区由老年代保证。当在年轻代中对象经过多次 minor gc 以后还存活，达到老年代的年纪，就会移动到老年代，还有就是大对象在年轻代无法存储，直接转到老年代，还有可能因为担保而进入老年代的 3. 对象创建方法，对象的内存分配，对象的访问定位 1 对象的创建包括三步骤： ①当遇到 new 命令的时候，会在常量池中检查该对象的符号引用是否存在，不存在则进行类的加载，否则执行下一步 ②分配内存，将将要分配的内存都清零。 ③虚拟机进行必要的设置，如设置 hashcode，gc 的分代年龄等，此时会执行命令在执行之前所有的字段都为 0，执行指令以后，按照程序顺序进行初始化字段。 2：对象的内存分配：包括对象头，实例数据，对齐填充 ①对象头: 包括对象的 hascode，gc 分代年龄，锁状态标等。 ②实例数据: 也就是初始化以后的对象的字段的内容，包括父类中的字段等 ③对齐填充：对象的地址是 8 字节，虚拟机要求对象的大小是对象的整数倍 (1 倍或者两倍)。因此就会有空白区。 3：对象的访问： hotspot 中 是采用对象直接指向对象地址的方式（这样的方式访问比较快）（还有一种方式就是句柄，也就是建一张表维护各个指向各个地址的指针，然后给指针设置一个句柄 （别名），然后引用直接指向这个别名，就可以获得该对象，这种的优势就是，实例对象地址改变了，只要修改句柄池中的指针就可以了，而不用引用本身不会发生改变）。 4.GC 的两种判别方法：引用计数与引用链 引用计数 给一个对象设置一个计数器，当被引用一次就加 1，当引用失效的时候就减 1，如果该对象长时间保持为 0 值，则该对象将被标记为回收。优点：算法简单，效率高，缺点：很难解决对象之间的相互循环引用问题。 引用链： 现在主流的 gc 都采用可达性分析算法来判断对象是否已经死亡。可达性分析：通过一系列成为 GC Roots 的对象作为起点，从这些起点向下搜索，搜索所走过的路径成为引用链，当一个对象到引用链没有相连时，则判断该对象已经死亡。 可作为 gc roots 的对象： 虚拟机栈（本地方法表）中引用的对象（因为在栈内，被线程引用），方法区中类静态属性引用的对象，方法区中常量引用的（常量存放在常量池中，常量池是方法区的一部分）对象，native 方法引用的对象 引用计数和引用链是只是用来标记，判断一个对象是否失效，而不是用来清除 5.GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？3.3.1 标记 - 清除算法 (Mark-Sweep) 最基础的收集算法。其它算法都是基于这种思路并对其不足进行改进而得到的。 标记 - 清除算法将垃圾回收分为两个阶段： ①. 标记阶段：首先标记出所有需要回收的对象。 如何标记，在上面的 “判断对象是否存活” 里有讲过 ②. 清除阶段：标记完成后，统一回收被标记的对象缺点： ①. 效率问题：标记清除过程效率都不高。 ②. 空间问题：标记清除之后会产生大量的不连续的内存碎片 (空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。） 3.3.2 复制算法 (Copying)为了解决 mark-sweep 算法的效率问题 算法思想： 1). 将现有的内存空间分为两块，每次只使用其中一块. 2). 当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。 3). 再把已使用过的内存空间一次清理掉。 优点： 1). 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 2). 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 2.3 缺点： 1). 内存减少为原来的一半，太浪费了。 2). 对象存活率较高的时候就要执行较多的复制操作，效率变低。 3). 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。2.4. 演进 并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 EdenSpace 和两块较小的 SurvivorSpace JavaHeap 内存回收模型（当前商业虚拟机大多使用此算法回收新生代） jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 3.3.3 标记 - 整理算法 (Mark-Compact) 由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 算法思想 1). 标记阶段：首先标记出所有需要回收的对象。与 “标记 - 清除” 一样 2). 让存活的对象向内存的一段移动。 3). 直接清理掉边界以外的内存。 由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记 - 清理算法或标记 - 清除算法。 3.3.4 代收集算法 (Generational Collecting) 当前的商业虚拟机的垃圾收集都采用，把 Java 堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。 优化收集方法： 优化收集方法：对复制算法的优化：并不是将两块内存分配同等大小，可以将存活率低的区域大一些，而让回收后存活的对象所占的区域小一些，不够的内存由老年代的内存来保证，这样复制算法的空闲的空间减少了。两个 survival 区域目的是为了减少风险，有一个 survivor 区要参与回收，也要参与存储，只要只有 10% 的空间浪费，同时也减少对老年代的依赖。 6.GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。 （见书上3.5） 串行的，也就是采用单线程（比较老了），分类：serial new（收集年轻代，复制算法）和 serial old（收集老年代，标记整理），缺点：单线程，进行垃圾回收时暂时所有的用户线程。优点：实现简单。 并行的，采用多线程，对于年轻代有两个： parallel new（简称 ParNew）（参考 serial new 的多线程版本）和 parallel scavenge；parallel scavenge 是一个针对年轻代的垃圾回收器，采用复制算法，主要的优点是进行垃圾回收时不会停止用户线程（不会发生 stop all world）老年代回收器也有两种：Parallel old 是 parallel scavenge 的老年代设计的。CMS（并发标记清除）采用标记清除算法，采用这种的优点就是快咯，因此会尽快的进行回收，减少停顿时间。 高级杀手：G1 收集器，年轻代和老年代通吃，最新一代的技术。面向服务器端的垃圾收集器（并行 + 并发的垃圾收集器）。 7.Minor GC 与 Full GC 分别在什么时候发生? Minor GC 发生：当 jvm 无法为新的对象分配空间的时候就会发生 minor gc，所以分配对象的频率越高，也就越容易发生 minor gc。 Full GC：发生 GC 有两种情况，①当老年代无法分配内存的时候，会导致 MinorGC,②当发生 Minor GC 的时候可能触发 Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不能清除自己要担保多少空间，因此采取采用动态估算的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次 Minor GC 以后，存活的对象剧增（假设小对象），此时老年代并没有满，但是此时平均值增加了，会造成发生 Full GC 8. 类加载的五个过程：加载、验证、准备、解析、初始化。 加载： 加载有两种情况，①当遇到 new 关键字，或者 static 关键字的时候就会发生（他们对应着对应的指令）如果在常量池中找不到对应符号引用时，就会发生加载 ，②动态加载，当用反射方法（如 class.forName(“类名”)），如果发现没有初始化，则要进行初始化。（注：加载的时候发现父类没有被加载，则要先加载父类） 验证： 这一阶段的目的是确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全（虽然编译器会严格的检查 java 代码并生成 class 文件，但是 class 文件不一定都是通过编译器编译，然后加载进来的，因为虚拟机获取 class 文件字节流的方式有可能是从网络上来的，者难免不会存在有人恶意修改而造成系统崩溃的问题，class 文件其实也可以手写 16 进制，因此这是必要的） 准备： 该阶段就是为对象分派内存空间，然后初始化类中的属性变量，但是该初始化只是按照系统的意愿进行初始化，也就是初始化时都为 0 或者为 null。因此该阶段的初始化和我们常说初始化阶段的初始化时不一样的 解析： 解析就是虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用其实就是 class 文件常量池中的各种引用，他们按照一定规律指向了对应的类名，或者字段，但是并没有在内存中分配空间，因此符号因此就理解为一个标示，而在直接引用直接指向内存中的地址 初始化： 简单讲就是执行对象的构造函数，给类的静态字段按照程序的意愿进行初始化，注意初始化的顺序。（此处的初始化由两个函数完成，一个是, 初始化所有的类变量（静态变量），该函数不会初始化父类变量，还有一个是实例初始化函数, 对类中实例对象进行初始化，此时要如果有需要，是要初始化父类的） 9. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。 类 加载器的工作过程：如果一个类加载器收到类类加载的请求，他首先不会自己去加载这个类，而是把类委派个父类加载器去完成，因此所有的请求最终都会传达到顶 层的启动类加载器中，只有父类反馈无法加载该类的请求（在自己的搜索范围类没有找到要加载的类）时候，子类才会试图去加载该类。 10. 分派：静态分派与动态分派: 静态分派和动态分派都是多态的内容，多态的实现依赖于编译阶段和运行时阶段：在编译阶段主要表现在静态分派， 静态分派就是通过静态类型和方法参数个数来选择哪一个方法版本，这就是主要体现了方法的重载；因为他在编译的时候就能确定调用哪一个函数，所以叫静态分派。 在运行时阶段体现在动态分派（动态绑定），也就是当一个父类引用指向子类对象，通过该父类引用去调用一个该方法，由于在编译阶段生产的调用函数代码的字节码指向的是父类（静态类型）被调用方法，并不知道具体要去调用哪一个实际类型的方法，因 此会发生这样一个过程，虚拟机找到操作数栈中位于栈顶获取该操作数所指向的类，然后到常量池中去搜索与被调用的方法匹配的方法名和描述符，如果找到， 就进行权限校验（校验失败就抛出异常），如果可以访问，则返回该方法的符号引用，并转换成直接引用，调用该执行，如果找不到就到父类中去找，然后重复上面 动作，最后找不到就抛出异常。 对动态绑定的优化：由于要去常量池中搜索每一类的方法名和描述符，因此效率比较低，所以最后进行了优化，就是在方法区为每一类维护一张虚方法表或者接口方法表（虚表中存放了该方法的实际入口地址），让该类的所有方法都维护进去（包括父类的方法），因此要查找方法名的时候，直接去该虚表中去搜索到该方法名对应的直接地址然后执行。对于没有被重写的方法，直接存放父类的入口地址，如果该方法被重写，在存放子类的方法入口地址。 参考:http://blog.csdn.net/qq_30000411/article/details/60334051 JDK 是什么 JRE 是什么 Java 历史版本的特性 Java Version SE 50 Java Version SE 6 Java Version SE 7 Java 8 运行时数据区域包括哪些 程序计数器线程私有 Java 虚拟机栈线程私有 本地方法栈线程私有 Java 堆线程共享 方法区线程共享 运行时常量池 Java 中对象访问是如何进行的 如何判断对象是否死去 什么是引用计数法 引用计数法的缺点 什么是根搜索算法 Java 的 4 种引用方式 强引用 软引用 弱引用 虚引用 有哪些垃圾收集算法 标记 - 清除算法 Mark-Sweep 什么是标记 - 清除算法 有什么缺点 复制算法 Copying- 新生代 优点 缺点 应用 标记 - 整理算法 Mark-Compact - 老年代 分代收集算法 Minor GC 和 Full GC 有什么区别 Java 内存 为什么要将堆内存分区 堆内存分为哪几块 分代收集算法 内存分配有哪些原则 Young Generation Space 采用复制算法 Tenure Generation Space 采用标记 - 整理算法 Permanent Space Class 文件 Java 虚拟机的平台无关性 Class 文件的组成 魔数与 Class 文件的版本 类加载器 类加载器的作用是什么 类加载器有哪些 类加载机制 什么是双亲委派模型 为什么要使用双亲委派模型组织类加载器之间的关系 什么是类加载机制 虚拟机和物理机的区别是什么 运行时栈帧结构 Java 方法调用 什么是方法调用 Java 的方法调用有什么特殊之处 Java 虚拟机调用字节码指令有哪些 虚拟机是如何执行方法里面的字节码指令的 解释执行 基于栈的指令集和基于寄存器的指令集 什么是基于栈的指令集 什么是基于寄存器的指令集 基于栈的指令集的优缺点 Javac 编译过程分为哪些步骤 什么是即时编译器 解释器和编译器 为什么要采用分层编译 分层编译器有哪些层次 编译对象与触发条件 热点代码有哪些 如何判断一段代码是不是热点代码 HotSpot 虚拟机使用第二种有两个计数器 方法调用计数器统计方法 有哪些经典的优化技术即时编译器 公共子表达式消除 数组边界检查消除 方法内联 逃逸分析 如果对象不会逃逸到方法或线程外可以做什么优化 Java 与 CC 的编译器对比 物理机如何处理并发问题 Java 内存模型 什么是 Java 内存模型 Java 内存模型的目标 主内存与工作内存 内存间的交互操作 原子性可见性有序性 volatile 什么是 volatile 为什么基于 volatile 变量的运算在并发下不一定是安全的 为什么使用 volatile 并发与线程 并发与线程的关系 什么是线程 实现线程有哪些方式 Java 线程的实现 Java 线程调度 什么是线程调度 线程调度有哪些方法 线程安全的定义 Java 语言操作的共享数据包括哪些 不可变 如何实现线程安全 阻塞同步互斥同步 非阻塞同步 锁优化是在 JDK 的那个版本 为什么要提出自旋锁 自旋锁的原理 自旋的缺点 什么是自适应自旋 锁消除 锁粗化 轻量级锁 偏向锁 JDK 是什么？JDK 是用于支持 Java 程序开发的最小环境。 Java 程序设计语言 Java 虚拟机 Java API 类库 JRE 是什么？JRE 是支持 Java 程序运行的标准环境。 Java SE API 子集 Java 虚拟机 Java 历史版本的特性？Java Version SE 5.0 引入泛型； 增强循环，可以使用迭代方式； 自动装箱与自动拆箱； 类型安全的枚举； 可变参数； 静态引入； 元数据（注解）； 引入 Instrumentation。 Java Version SE 6 支持脚本语言； 引入 JDBC 4.0 API； 引入 Java Compiler API； 可插拔注解； 增加对 Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos 和 LDAP(Lightweight Directory Access Protocol) 的支持； 继承 Web Services； 做了很多优化。 Java Version SE 7 switch 语句块中允许以字符串作为分支条件； 在创建泛型对象时应用类型推断； 在一个语句块中捕获多种异常； 支持动态语言； 支持 try-with-resources； 引入 Java NIO.2 开发包； 数值类型可以用 2 进制字符串表示，并且可以在字符串表示中添加下划线； 钻石型语法； null 值的自动处理。 Java 8 函数式接口 Lambda 表达式 接口的增强 运行时数据区域包括哪些？ 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 运行时常量池 直接内存 Java 中对象访问是如何进行的？1Object obj = new Object(); 对于上述最简单的访问，也会涉及到 Java 栈、Java 堆、方法区这三个最重要内存区域。 1Object obj 如果出现在方法体中，则上述代码会反映到 Java 栈的本地变量表中，作为 reference 类型数据出现。 1new Object() 反映到 Java 堆中，形成一块存储了 Object 类型所有对象实例数据值的内存。Java 堆中还包含对象类型数据的地址信息，这些类型数据存储在方法区中。 如何判断对象是否 “死去”？ 引用计数法 根搜索算法 什么是引用计数法？给对象添加一个引用计数器，每当有一个地方引用它，计数器就 + 1,；当引用失效时，计数器就 - 1；任何时刻计数器都为 0 的对象就是不能再被使用的。 引用计数法的缺点？很难解决对象之间的循环引用问题。 什么是根搜索算法？通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。 Java 的 4 种引用方式？在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为 强引用 Strong Reference 软引用 Soft Reference 弱引用 Weak Reference 虚引用 Phantom Reference 强引用1Object obj = new Object(); 代码中普遍存在的，像上述的引用。只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。 软引用用来描述一些还有用，但并非必须的对象。软引用所关联的对象，有在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围，并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存异常。提供了 SoftReference 类实现软引用。 弱引用描述非必须的对象，强度比软引用更弱一些，被弱引用关联的对象，只能生存到下一次垃圾收集发生前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。提供了 WeakReference 类来实现弱引用。 虚引用一个对象是否有虚引用，完全不会对其生存时间够成影响，也无法通过虚引用来取得一个对象实例。为一个对象关联虚引用的唯一目的，就是希望在这个对象被收集器回收时，收到一个系统通知。提供了 PhantomReference 类来实现虚引用。 有哪些垃圾收集算法？ 标记 - 清除算法 复制算法 标记 - 整理算法 分代收集算法 标记 - 清除算法（Mark-Sweep）什么是标记 - 清除算法？分为标记和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。 有什么缺点？1. 效率问题。标记和清除过程的效率都不高。2. 空间问题。标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致，程序分配较大对象时无法找到足够的连续内存，不得不提前出发另一次垃圾收集动作。 复制算法（Copying）- 新生代将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。 优点？复制算法使得每次都是针对其中的一块进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点？将内存缩小为原来的一半。在对象存活率较高时，需要执行较多的复制操作，效率会变低。 应用？商业的虚拟机都采用复制算法来回收新生代。因为新生代中的对象容易死亡，所以并不需要按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。每次使用 Eden 和其中的一块 Survivor。 当回收时，将 Eden 和 Survivor 中还存活的对象一次性拷贝到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。Hotspot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80% + 10%），只有 10% 的内存是会被 “浪费” 的。 标记 - 整理算法（Mark-Compact）- 老年代标记过程仍然与 “标记 - 清除” 算法一样，但不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。 分代收集算法根据对象的存活周期，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点，采用最适当的收集算法。 新生代：每次垃圾收集时会有大批对象死去，只有少量存活，所以选择复制算法，只需要少量存活对象的复制成本就可以完成收集。 老年代：对象存活率高、没有额外空间对它进行分配担保，必须使用 “标记 - 清理” 或 “标记 - 整理” 算法进行回收。 Minor GC 和 Full GC 有什么区别？Minor GC：新生代 GC，指发生在新生代的垃圾收集动作，因为 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般回收速度较快。Full GC：老年代 GC，也叫 Major GC，速度一般比 Minor GC 慢 10 倍以上。 Java 内存为什么要将堆内存分区？对于一个大型的系统，当创建的对象及方法变量比较多时，即堆内存中的对象比较多，如果逐一分析对象是否该回收，效率很低。分区是为了进行模块化管理，管理不同的对象及变量，以提高 JVM 的执行效率。 堆内存分为哪几块？ Young Generation Space 新生区（也称新生代） Tenure Generation Space 养老区（也称旧生代） Permanent Space 永久存储区 分代收集算法内存分配有哪些原则？ 对象优先分配在 Eden 大对象直接进入老年代 长期存活的对象将进入老年代 动态对象年龄判定 空间分配担保 Young Generation Space （采用复制算法）主要用来存储新创建的对象，内存较小，垃圾回收频繁。这个区又分为三个区域：一个 Eden Space 和两个 Survivor Space。 当对象在堆创建时，将进入年轻代的 Eden Space。 垃圾回收器进行垃圾回收时，扫描 Eden Space 和 A Suvivor Space，如果对象仍然存活，则复制到 B Suvivor Space，如果 B Suvivor Space 已经满，则复制 Old Gen 扫描 A Suvivor Space 时，如果对象已经经过了几次的扫描仍然存活，JVM 认为其为一个 Old 对象，则将其移到 Old Gen。 扫描完毕后，JVM 将 Eden Space 和 A Suvivor Space 清空，然后交换 A 和 B 的角色（即下次垃圾回收时会扫描 Eden Space 和 B Suvivor Space。 Tenure Generation Space（采用标记 - 整理算法）主要用来存储长时间被引用的对象。它里面存放的是经过几次在 Young Generation Space 进行扫描判断过仍存活的对象，内存较大，垃圾回收频率较小。 Permanent Space存储不变的类定义、字节码和常量等。 Class 文件Java 虚拟机的平台无关性 Class 文件的组成？Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目间没有任何分隔符。当遇到 8 位字节以上空间的数据项时，则会按照高位在前的方式分隔成若干个 8 位字节进行存储。 魔数与 Class 文件的版本每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的 Class 文件。OxCAFEBABE。 接下来是 Class 文件的版本号：第 5,6 字节是次版本号（Minor Version），第 7,8 字节是主版本号（Major Version）。 使用 JDK 1.7 编译输出 Class 文件，格式代码为： 前四个字节为魔数，次版本号是 0x0000，主版本号是 0x0033，说明本文件是可以被 1.7 及以上版本的虚拟机执行的文件。 33：JDK1.7 32：JDK1.6 31：JDK1.5 30：JDK1.4 2F：JDK1.3 类加载器类加载器的作用是什么？类加载器实现类的加载动作，同时用于确定一个类。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。即使两个类来源于同一个 Class 文件，只要加载它们的类加载器不同，这两个类就不相等。 类加载器有哪些？ 启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现（仅限于 HotSpot），是虚拟机自身的一部分。负责将存放在 \lib 目录中的类库加载到虚拟机中。其无法被 Java 程序直接引用。 扩展类加载器（Extention ClassLoader）由 ExtClassLoader 实现，负责加载 \lib\ext 目录中的所有类库，开发者可以直接使用。 应用程序类加载器（Application ClassLoader）：由 APPClassLoader 实现。负责加载用户类路径（ClassPath）上所指定的类库。 类加载机制什么是双亲委派模型？双亲委派模型（Parents Delegation Model）要求除了顶层的启动类加载器外，其余加载器都应当有自己的父类加载器。类加载器之间的父子关系，通过组合关系复用。工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有到父加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，子加载器才会尝试自己去加载。 为什么要使用双亲委派模型，组织类加载器之间的关系？Java 类随着它的类加载器一起具备了一种带优先级的层次关系。比如 java.lang.Object，它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此 Object 类在程序的各个类加载器环境中，都是同一个类。 如果没有使用双亲委派模型，让各个类加载器自己去加载，那么 Java 类型体系中最基础的行为也得不到保障，应用程序会变得一片混乱。 什么是类加载机制？Class 文件描述的各种信息，都需要加载到虚拟机后才能运行。虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 虚拟机和物理机的区别是什么？这两种机器都有代码执行的能力，但是： 物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面的。 虚拟机的执行引擎是自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。 运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构， 存储了方法的 局部变量表 操作数栈 动态连接 方法返回地址 每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 Java 方法调用什么是方法调用？方法调用唯一的任务是确定被调用方法的版本（调用哪个方法），暂时还不涉及方法内部的具体运行过程。 Java 的方法调用，有什么特殊之处？Class 文件的编译过程不包含传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这使得 Java 有强大的动态扩展能力，但使 Java 方法的调用过程变得相对复杂，需要在类加载期间甚至到运行时才能确定目标方法的直接引用。 Java 虚拟机调用字节码指令有哪些？ invokestatic：调用静态方法 invokespecial：调用实例构造器方法、私有方法和父类方法 invokevirtual：调用所有的虚方法 invokeinterface：调用接口方法 虚拟机是如何执行方法里面的字节码指令的？解释执行（通过解释器执行）编译执行（通过即时编译器产生本地代码） 解释执行当主流的虚拟机中都包含了即时编译器后，Class 文件中的代码到底会被解释执行还是编译执行，只有虚拟机自己才能准确判断。 Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译是半独立的实现。 基于栈的指令集和基于寄存器的指令集什么是基于栈的指令集？Java 编译器输出的指令流，里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。 计算 “1+1=2”，基于栈的指令集是这样的： 1234iconst_1iconst_1iaddistore_0 两条 iconst_1 指令连续地把两个常量 1 压入栈中，iadd 指令把栈顶的两个值出栈相加，把结果放回栈顶，最后 istore_0 把栈顶的值放到局部变量表的第 0 个 Slot 中。 什么是基于寄存器的指令集？最典型的是 x86 的地址指令集，依赖寄存器工作。计算 “1+1=2”，基于寄存器的指令集是这样的： 12mov eax, 1add eax, 1 mov 指令把 EAX 寄存器的值设为 1，然后 add 指令再把这个值加 1，结果就保存在 EAX 寄存器里。 基于栈的指令集的优缺点？优点： 可移植性好：用户程序不会直接用到这些寄存器，由虚拟机自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存）放到寄存器以获取更好的性能。 代码相对紧凑：字节码中每个字节就对应一条指令 编译器实现简单：不需要考虑空间分配问题，所需空间都在栈上操作 缺点： 执行速度稍慢 完成相同功能所需的指令数多 频繁的访问栈，意味着频繁的访问内存，相对于处理器，内存才是执行速度的瓶颈。 Javac 编译过程分为哪些步骤？ 解析与填充符号表 插入式注解处理器的注解处理 分析与字节码生成 什么是即时编译器？Java 程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为 “热点代码”（Hot Spot Code）。 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器成为即时编译器（Just In Time Compiler，JIT 编译器）。 解释器和编译器许多主流的商用虚拟机，都同时包含解释器和编译器。 当程序需要快速启动和执行时，解释器首先发挥作用，省去编译的时间，立即执行。 当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，可以提高执行效率。 如果内存资源限制较大（部分嵌入式系统），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时编译器的代码还能退回成解释器的代码。 为什么要采用分层编译？因为即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间越长。 分层编译器有哪些层次？分层编译根据编译器编译、优化的规模和耗时，划分不同的编译层次，包括： 第 0 层：程序解释执行，解释器不开启性能监控功能，可出发第 1 层编译。 第 1 层：也成为 C1 编译，将字节码编译为本地代码，进行简单可靠的优化，如有必要加入性能监控的逻辑。 第 2 层：也成为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 用 Client Compiler 和 Server Compiler 将会同时工作。用 Client Compiler 获取更高的编译速度，用 Server Compiler 获取更好的编译质量。 编译对象与触发条件热点代码有哪些？ 被多次调用的方法 被多次执行的循环体 如何判断一段代码是不是热点代码？要知道一段代码是不是热点代码，是不是需要触发即时编译，这个行为称为热点探测。主要有两种方法： 基于采样的热点探测，虚拟机周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是 “热点方法”。实现简单高效，但是很难精确确认一个方法的热度。 基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认为它是热点方法。 HotSpot 虚拟机使用第二种，有两个计数器： 方法调用计数器 回边计数器（判断循环代码） 方法调用计数器统计方法统计的是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器的热度衰减，这个时间就被称为半衰周期。 有哪些经典的优化技术（即时编译器）？ 语言无关的经典优化技术之一：公共子表达式消除 语言相关的经典优化技术之一：数组范围检查消除 最重要的优化技术之一：方法内联 最前沿的优化技术之一：逃逸分析 公共子表达式消除普遍应用于各种编译器的经典优化技术，它的含义是： 如果一个表达式E已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。没有必要重新计算，直接用结果代替E就可以了。 数组边界检查消除因为 Java 会自动检查数组越界，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑是一种性能负担。 如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组区间内，那么整个循环中就可以把数组的上下界检查消除掉，可以节省很多次的条件判断操作。 方法内联内联消除了方法调用的成本，还为其他优化手段建立良好的基础。 编译器在进行内联时，如果是非虚方法，那么直接内联。如果遇到虚方法，则会查询当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那么也可以内联，不过这种内联属于激进优化，需要预留一个逃生门（Guard 条件不成立时的 Slow Path），称为守护内联。 如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者的继承关系发现变化的类，那么内联优化的代码可以一直使用。否则需要抛弃掉已经编译的代码，退回到解释状态执行，或者重新进行编译。 逃逸分析逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法里面被定义后，它可能被外部方法所引用，这种行为被称为方法逃逸。被外部线程访问到，被称为线程逃逸。 如果对象不会逃逸到方法或线程外，可以做什么优化？ 栈上分配：一般对象都是分配在 Java 堆中的，对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。但是垃圾回收和整理都会耗时，如果一个对象不会逃逸出方法，可以让这个对象在栈上分配内存，对象所占用的内存空间就可以随着栈帧出栈而销毁。如果能使用栈上分配，那大量的对象会随着方法的结束而自动销毁，垃圾回收的压力会小很多。 同步消除：线程同步本身就是很耗时的过程。如果逃逸分析能确定一个变量不会逃逸出线程，那这个变量的读写肯定就不会有竞争，同步措施就可以消除掉。 标量替换：不创建这个对象，直接创建它的若干个被这个方法使用到的成员变量来替换。 Java 与 C/C++ 的编译器对比 即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力。 Java 语言虽然没有 virtual 关键字，但是使用虚方法的频率远大于 C++，所以即时编译器进行优化时难度要远远大于 C++ 的静态优化编译器。 Java 语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，使得全局的优化难以进行，因为编译器无法看见程序的全貌，编译器不得不时刻注意并随着类型的变化，而在运行时撤销或重新进行一些优化。 Java 语言对象的内存分配是在堆上，只有方法的局部变量才能在栈上分配。C++ 的对象有多种内存分配方式。 参考：http://blog.csdn.net/yano_nankai/article/details/50957578#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95mark-compact-%E8%80%81%E5%B9%B4%E4%BB%A3 待阅读：http://blog.csdn.net/maydaysar/article/details/56839617https://my.oschina.net/lock0818/blog/1502746https://www.jianshu.com/p/54eb60cfa7bdhttp://www.bijishequ.com/detail/397600?p=https://juejin.im/post/5a72d8136fb9a01cb9133c39https://github.com/devnan/java-studyhttp://www.importnew.com/23792.htmlhttp://blog.csdn.net/hipilee/article/details/78487848http://blog.csdn.net/hsk256/article/details/49104955 GC(垃圾处理机制)面试题: http://blog.csdn.net/nysyxxg/article/details/8789358http://blog.csdn.net/alwaystiys/article/details/22279181http://blog.csdn.net/nysyxxg/article/details/8789358 印象笔记中关于jvm的总结：待整理]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据分析准备：scratch编程教育竞赛]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12%2F</url>
    <content type="text"><![CDATA[即将开展：编程竞赛，预计4月下旬准备目的：从各个维度全方位地反映活动成果概述：整体：总数aa个学校的bb个学生在累计yy小时创作了zz个作品，累计代码行数为nn。 具体分析：活动前需要设计的数据采集方向：参赛人群分析、活动分析、作品分析、参赛学校分析、学生分析、班级分析、教师分析、编程过程分析。 各方向具体分析：参赛人群分析：地区占比，性别占比，年级占比，学校占比，CT评分总体情况。 活动分析：点赞数，浏览数，参赛作品提交时间段分析，新增用户比（与往期活动纵向对比） 作品分析：关键在于如何确定优秀作品（计算思维评分和榜单排名（总点击量，总收藏量、权重用户收藏量，权重用户点击量）综合考虑），点赞排名，收藏排名，作品tags（在比赛中作品标签类别属于必填项，对于没有标记tags的作品，通过机器学习进行分类？？）类型比重分析，作品改编树关系网络分析、作品转化率：作品a被改编的次数/作品a被浏览次数，需要统计作品转化的代码数。 参赛学校分析：学校数据加权分析（需要获取参与其中的学校名单列表，对同一学校的所有作品的点赞数之和、浏览数之和进行排名）、学校总人数参与比重（需要获取当前学校学生总数）、教师参与度（本次活动指导教师占全体教师的比重，需要获取学校教师数量），学校之间距离远近（不是直线距离而是实际交通距离）与学校之间参与度之间的关系（互助，竞争关系？），学生作品水平与当地教育水平分布图（经济情况，教育机构分布情况，交通情况）之间的关系，学校CT评分情况。 学生分析：重点分析作品评分高，点赞排名和收藏排名靠前的学生群体（权重用户），建立这些学生之间的关系网络模型，分析该学生对不同作品的投稿数，确定用户画像（兴趣、爱好，创造性等指标，宏观分析用户编程习惯特征），横向对比同一班级的学生之间的兴趣爱好分布情况，统计编程用时：这里需要增加一个统计学生累计编程时长的字段（有效时长指处于编程界面下鼠标键盘有操作的情况下）。后续功能可以累计增加经验值，学生CT评分走向（纵向分析）。 班级分析：建立班级和教师关系模型，比如同一个老师教的不同班级学生（需要获取教师教课表（每名教师所带的班级统计信息）），班级课内学习成绩关系和活动参与程度的关系图（了解scratch编程是否有助于提高学生的学习能力，这个需要在时间上纵向开展，跟踪分析），班级CT评分情况。 教师分析：对相同指导教师的作品的统计分析：如作品整体水平、质量（点赞数，浏览数），建立优秀指导教师（优秀作品排名）之间（需要完善个人信息：教师年龄，性别）的关系网络分析模型。 编程过程分析：后续待定 总结：下次活动时采集数据的注意事项： 提交作品请不要使用“新项目”等默认名称 提交作品请选择作品标签类型（使用复选框，并增加提示信息） 请用户完善个人信息：性别，年级，生日，兴趣爱好（至少填写一个兴趣爱好，为了便于统计这个可以使用多选的方式进行填写，作为构建用户画像的参考之一） 明确本次参与活动是以第一学校还是第二课堂学校作为入口，老师要明确告知学生登录时所选的班级。 需要额外收集的数据： 作品标签、 学校名单列表、 各学校学生总数、 各学校教师数量、年龄(使用出生日期)和性别 各教师教课表（每名教师所带的班级统计信息）、 需要设计的内容： 衡量优秀作品的标准（计算思维评分和榜单排名（总点击量，总收藏量、权重用户收藏量，权重用户点击量）综合考虑） 衡量权重用户的标准（登录时长，编程时长，优秀作品数量等） 需要后台完善的内容： 增加一个统计每个学生累计有效编程时长的字段coding_duration，（处于编程界面下鼠标键盘有操作的情况下） 增加一个将代码块转化为代码数量的函数，存入作品模型中的新字段：code_numbers 需要前端完善的内容：1. 前端增加检测编程界面下鼠标键盘有操作的js 需要深入研究的问题： 对于没有标记tags的作品，通过scratch官网上的数据进行模型训练，用机器学习进行分类，测试活动中的分类效果，再用人工方法校验，比较分类效果。 当前问题：教师端没有个人信息中心]]></content>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之十二&十三]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-7%2F</url>
    <content type="text"><![CDATA[第五部分 高效并发第十二章 Java 内存模型与线程并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类 “压榨” 计算机运算能力的最有力武器。 12.1 概述 多任务处理在现代计算机操作系统中几乎已是一项必备的功能了； 除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景； 服务端是 Java 语言最擅长的领域之一，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持，幸好 Java 语言和虚拟机提供了许多工具，把并发编码的门槛降低了不少； 12.2 硬件的效率与一致性 绝大多数的运算任务不可能只靠处理器计算就能完成，处理器至少要与内存交互，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了； 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性；为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI、MOSI、Synapse、Firefly 及 Dragon Protocol 等； 本章将会多次提到内存模型一词，可以理解在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；不同架构的物理机器可以拥有不一样的内存模型，而 Java 虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问具有很高的可比性； 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的； 12.3 Java 内存模型Java 虚拟机规范中视图定义一种 Java 内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 12.3.1 主内存与工作内存 Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节；此处的变量与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享； Java 内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量； 这里所讲的主内存、工作内存与第二章所讲的 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的；线程、主内存和工作内存的关系如下所示： 12.3.2 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下八种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量的某些操作在某些平台允许有例外）： lock unlock read load use assign store write 基于理解难度和严谨性考虑，最新的 JSR-133 文档中，已经放弃采用这八种操作去定义 Java 内存模型的访问协议了，后面将会介绍一个等效判断原则 – 先行发生原则，用来确定一个访问在并发环境下是否安全； 12.3.3 对于 volatile 型变量的特殊规则 关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制； 当一个变量定义为 volatile 之后，它将具备两种特性：第一是保证此变量对所有线程的可见性，这里的可见性是指当一个线程修改了这个变量的值，新的值对于其他线程来说是可以立即得知的，而普通的变量的值在线程间传递均需要通过主内存来完成；另外一个是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致； volatile 变量在各个线程的工作内存中不存在一致性问题，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的； 在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：运算结果并不依赖变量的当前值或者能够确保只有单一的线程修改变量的值、变量不需要与其他的状态变量共同参与不变约束； volatile 变量读操作的性能消耗与普通变量几乎没有任何差别，但是写操作则可能会慢一些；不过大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求； 12.3.4 对于 long 和 double 型变量的特殊规则 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定； 但允许虚拟机选择把这些操作实现为具有原子性的操作，目前各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待； 12.3.5 原子性、可见性与有序性 原子性（Atomicity）：由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write；在 synchronized 块之间的操作也具备原子性； 可见性（Visibility）：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了 volatile 之外，Java 还有 synchronized 和 final 关键字能实现可见性； 有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性； 12.3.6 先行发生原则 先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等； 下面是 Java 内存模型下一些天然的先行发生关系：程序次序规则、管程锁定规则、volatile 变量规则、线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性； 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准； 12.4 Java 与线程12.4.1 线程的实现 线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度； Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的； 实现线程主要有三种方式：使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）、使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）和使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险）； 对于 Sun JDK 来说，它的 Windows 版与 Linux 版都是使用一对一的线程模型实现的，一条 Java 线程就映射到一条轻量级进程之中，因为 Windows 和 Linux 系统提供的线程模式就是一对一的； 12.4.2 Java 线程调度 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（线程的执行时间由线程本身来控制）和抢占式线程调度（线程由系统来分配执行时间，线程的切换不由线程本身来决定）； Java 语言一共设置了 10 个级别的线程优先级，不过线程优先级并不是太靠谱，原因就是操作系统的线程优先级不见得总是与 Java 线程的优先级一一对应，另外优先级还可能被系统自行改变； 12.4.3 状态转换 Java 语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。它们之间相互的转换关系如下所示： 12.5 本章小结本章我们首先了解了虚拟机 Java 内存模型的结构及操作，然后讲解了原子性、可见性、有序性在 Java 内存模型中的体现，最后介绍了先行发生原则的规则及使用。另外，我们还了解了线程在 Java 语言之中是如何实现的。 在本章主要介绍了虚拟机如何实现并发，而在下一章我们主要关注点将是虚拟机如何实现高效，以及虚拟机对我们编写的并发代码提供了什么样的优化手段。 第十三章 线程安全与锁优化13.1 概述 首先需要保证并发的正确性，然后在此基础上实现高效； 13.2 线程安全Brian Goetz 对线程安全有一个比较恰当的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 13.2.1 Java 语言中的线程安全 我们可以将 Java 语言中各个操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立； 不可变：不可变带来的安全性是最简单和最纯粹的，如 final 的基本数据类型；如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如 String 类的 substring、replace 方法；Number 类型的大部分子类都符合不可变要求的类型，但是 AtomicInteger 和 AtomicLong 则并非不可变的； 线程绝对安全：Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全；比如 java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了； 线程相对安全：是我们通常意义上所讲的线程安全，在 Java 语言中，大部分的线程安全类都属于这种类型； 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况； 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java 语言中很少出现； 13.2.2 线程安全的实现方法 互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用，而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式；Java 中最基本的互斥同步手段就是 synchronized 关键字，它对同一个线程来说是可重入的且会阻塞后面其他线程的进入；另外还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步，相比 synchronized 关键字 ReentrantLock 增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件； 非阻塞同步：互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略；随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步；Java 并发包的整数原子类，其中的 compareAndSet 和 getAndIncrement 等方法都使用了 Unsafe 类的 CAS 操作； 无同步方案：要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码； 13.3 锁优化13.3.1 自旋锁与自适应自旋 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力；另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁；为了让线程等待，我们只需让线程执行一个忙循环，这些技术就是所谓的自旋锁； 在 JDK 1.6 已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源； 在 JDK 1.6 中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定； 13.3.2 锁消除 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除； 锁消除的主要判断依据来源于逃逸分析的数据支持； 13.3.3 锁粗化 原则上总是推荐将同步块的作用范围限制得尽量小 – 只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁； 但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗； 13.3.4 轻量级锁 轻量级锁是 JDK 1.6 之中加入的新型锁机制，它是相对于使用操作系统互斥量来实现的传统锁而言的；它并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗； 要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从 HotSpot 虚拟机的对象的内存布局开始介绍；HotSpot 虚拟机的对象头分为两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄等，这部分官方称之为 Mark Word，是实现轻量级锁和偏向锁的关键，另外一部分用于存储指向方法区对象类型数据的指针； Mark Word 被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，在 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0；在其他状态（轻量级锁定、重量级锁定、GC 标志、可偏向）下对象的存储内容如下： 在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的 Mark Word 的拷贝（官方称之为 Displaced Mark Word）；然后虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果更新成功了那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位将转变为 “00”，即表示此对象处于轻量级锁定状态；如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了；如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为 “10”，Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进行阻塞状态； 轻量级锁能提升程序同步性能的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据； 13.3.5 偏向锁 偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能；如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了； 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 假设当前虚拟机启动了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为 “01”，即偏向模式；同时使用 CAS 操作把获取到这个锁的线程 ID 记录在对象的 Mark Word 之中；如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如上面介绍的轻量级锁那样执行；偏向锁、轻量级锁的状态转化以及对象 Mark Work 的关系如下图所示： 偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化； 本章小结本章介绍了线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运行原理，并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part7/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之十&十一]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-6%2F</url>
    <content type="text"><![CDATA[第四部分 程序编译与代码优化第十章 早期（编译器）优化10.1 概述 前端编译器（或叫编译器前端）：把.java 文件转变为.class 文件的过程，比如 Sun 的 javac、Eclipse JDT 中的 ECJ； 后端运行编译器（JIT 编译器）：把字节码转变为机器码的过程，比如 HotSpot VM 的 C1、C2 编译器； 静态提前编译器（AOT 编译器）：直接把 *.java 文件编译成本地机器代码的过程，比如 GNU Compiler for the Java； 本章主要针对第一类，把第二类的编译过程留到下一章讨论； javac 这类编译器对代码运行效率几乎没有任何优化措施，虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样那些不是由 javac 产生的 Class 文件也同样能享受到编译器优化所带来的好处； javac 做了许多针对 Java 语言编码过程的优化措施来改善程序员的编码风格和提高编码效率；可以说，Java 中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译器的优化过程对于程序编码来说关系更加密切； 10.2 javac 编译器javac 编译器本身就是一个由 Java 语言编写的程序，这为纯 Java 的程序员了解它的编译过程带来了很大的便利。 10.2.1 javac 的源码与调试 javac 的源码存放在 JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac，除了 JDK 自身的 API 外，就只引用了 JDK_SRC_HOME/langtools/src/share/classes/com/sun/* 里面的代码； 导入 javac 的源码后就可以运行 com.sun.tools.javac.Main 的 main 方法来执行编译了； javac 编译过程大概可以分为 3 个过程：解析与填充符号表过程、插入式注解处理器的注解处理过程、分析与字节码生成过程； 10.2.2 解析与填充符号表 解析步骤由 parseFiles 方法完成； 词法分析将源代码的字符流转变为标记（Token）集合，由 com.sun.tools.javac.parser.Scanner 类完成； 语法分析是根据 Token 序列构造抽象语法树（AST，一种用来描述程序代码语法结构的树形表示方式）的过程，由 com.sun.tools.javac.parser.Parser 类实现，AST 由 com.sun.tools.javac.tree.JCTree 类表示； 填充符号表：由 enterTrees 方法完成；符号表是由一组符号地址和符号信息构成的表格，所登记的信息在编译的不同阶段都要用到，在语义分析中用于语义检查，在目标代码生成时用于地址分配；由 com.sun.tools.javac.comp.Enter 类实现； 10.2.3 注解处理器 在 JDK 1.6 中实现了 JSR-269 规范，提供了一组插入式注解处理器的标准 API 在编译期间对注解进行处理，可以读取、修改、添加抽象语法树中的任意元素； 通过插入式注解处理器实现的插件在功能上有很大的发挥空间，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情； javac 中，在 initProcessAnnotations 初始化，在 processAnnotations 执行，如果有新的注解处理器，通过 com.sun.tools.javac.processing.JavacProcessingEnviroment 类的 doProcessing 方法生成一个新的 JavaCompiler 对象对编译的后续步骤进行处理； 10.2.4 语义分析与字节码生成 语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，主要包括标注检查、数据及控制流分析两个步骤； 解语法糖（Syntactic Sugar，添加的某种对语言功能没有影响但方便程序员使用的语法）：Java 中最常用的语法糖主要是泛型、变长参数、自动装箱等，他们在编译阶段还原回简单的基础语法结构；在 com.sun.tools.javac.comp.TransTypes 类和 com.sun.tools.javac.comp.Lower 类中完成； 字节码生成：javac 编译的最后一个阶段，不仅仅是把前面各个步骤所生成的信息转化为字节码写入到磁盘中，编译器还进行了少量的代码添加和转换工作（如实例构造器方法和类构造器方法）；由 com.sun.tools.javac.jvm.ClassWriter 类的 writeClass 方法输出字节码，生成最终的 Class 文件； 10.3 Java 语法糖的味道10.3.1 泛型与类型擦除 Java 语言的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型了，并且在相应的地方插入了强制转换，这种基于类型擦除的泛型实现是一种伪泛型； JCP 组织引入了 Signature 属性，它的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，这样我们就可以通过反射手段获取参数化类型； 10.3.2 自动装箱、拆箱与遍历循环 它们的实现比较简单，但却是 Java 语言里使用最多的语法糖； 10.3.3 条件编译 Java 语言之中并没有使用预处理器，因为 Java 编译器并非一个个地编译 Java 文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译； Java 语言可以使用条件为常量的 if 语句进行条件编译；编译器将会把分支中不成立的代码块消除掉； 10.4 实战：插入式注解处理器 实战目标：使用注解处理器 API 来编写一款拥有自己编码风格的校验工具； 代码实现：继承 javax.annotation.processing.AbstractProcessor，实现 process 方法，从第一个参数 annotations 获取此注解处理器所要处理的注解集合，从第二个参数 roundEnv 中访问到当前这个 Round 中的语法树节点；另外还有一个很常用的实例变量 processingEnv，它代表了注解处理器框架提供的一个上下文环境；可以配合使用的 @SupportedAnnotationTypes 和 @SupportedSourceVersion 注解； 10.5 本章小结本章我们从编译器源码实现的层次上了解了 javac 源代码编译为字节码的过程，分析了 Java 语言中多种语法糖的前因后果，并实战实习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。下一章我们将会介绍即时编译器的运作和优化过程。 第十一章 晚期（运行期）优化11.1 概述 为了提高热点代码的执行效率，在运行时虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（JIT）； JIT 不是虚拟机必需的，但是其编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分； 11.2 HotSpot 虚拟机内的即时编译器11.2.1 解释器与编译器 当程序需要迅速启动和执行的时候，解释器可以先发挥作用，省去编译的时间立即执行；在程序运行后，随着时间的推移，编译器把越来越多的代码编译成本地代码提升执行效率； HotSpot 虚拟机中内置了两个即时编译器，分别为 Client Compiler 和 Server Compiler，或简称为 C1 编译器和 C2 编译器；虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，也可以使用 “-client” 或“-server”参数去强制指定运行模式； 想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机还会逐渐启动分层编译的策略：第 0 层，程序解释运行；第 1 层，C1 编译；第 2 层，C2 编译； 实施分层编译后，Client Compiler 和 Server Compiler 将会同时工作，许多代码都可能会被多次编译，用 Client Compiler 获取更高的编译速度，用 Server Compiler 来获取更好的编译质量，在解释执行的时候也无须再承担性能收集监控信息的任务； 11.2.2 编译对象与触发条件 被 JIT 编译的热点代码有两类：被多次调用的方法、被多次执行的循环体；对于前者编译器会以整个方法作为编译对象，属于标准的 JIT 编译方式；对于后者尽管编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译对象，这种编译方式称之为栈上替换（OSR 编译）； 热点探测：基于采样的热点探测和基于计数器的热点探测，在 HotSpot 虚拟机中使用的是第二种，通过方法计数器和回边计数器进行热点探测。方法调用计数器触发的即时编译交互过程如下图所示： 11.2.3 编译过程 对于 Client Compiler 来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了很多耗时较长的全局优化手段；第一阶段一个平台独立的前端将字节码构造成一个高级中间代码表示（HIR），第二阶段一个平台相关的后端从 HIR 中产生低级中间代码表示（LIR），最后阶段是在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。其大致过程如下所示： Server Compiler 是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到 GNU C++ 编译器使用 - 02 参数时的优化强大，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实现如范围检查消除、空值检查消除等 Java 语言特性密切相关的优化技术； 11.2.4 查看及分析即时编译结果 本节的运行参数有一部分需要 Debug 或 FastDebug 版虚拟机的支持； 要知道某个方法是否被编译过，可以使用参数 - XX:+PrintCompilation 要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来； 还可以加上参数 - XX:+PrintInlining 要求虚拟机输出方法内联信息，输出内容如下： 除了查看那些方法被编译之外，还可以进一步查看即时编译器生成的机器码内容，这个需要结合虚拟机提供的反汇编接口来阅读； 11.3 编译优化技术11.3.1 优化技术概览 11.3.2 公共子表达式消除 如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成为了公共子表达式，只需要直接用前面计算过的表达式结果代替 E 就可以了； 11.3.3 数组边界检查消除 对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判断，对于拥有大量数组访问的程序代码无疑是一种性能负担； 11.3.4 方法内联 除了消除方法调用的成本外更重要的意义是为其他优化手段建立良好的基础； 为了解决虚方法的内联问题，引入了类型继承关系分析（CHA）技术和内联缓存（Inline Cache）来完成方法内联； 11.3.5 逃逸分析 逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用（方法逃逸），甚至还可能被外部线程所访问到（线程逃逸）；如果能证明一个对象不会逃逸到方法或线程之外，则可能为这个变量进行一些高效的优化，比如栈上分配（减轻垃圾收集的压力）、同步消除（读写不会有竞争）、标量替换； 11.4 Java 与 C/C++ 的编译器对比 Java 虚拟机的即时编译器与 C/C++ 的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些劣势：即时编译器运行占用用户程序运行时间、动态类型安全语言导致的频繁检查、运行时对方法接收者进行多态选择的频率大、可以动态扩展导致很多全局的优化难以运行、大部分对象在堆上分配导致垃圾收集机制的效率低； Java 语言的特性换取了开发效率的提升、还有许多优化是静态优化编译器不好做的，比如别名分析、还有一些以运行期性能监控为基础的优化措施如调用频率预测等； 11.5 本章小结本章我们着重了解了虚拟机的热点探测方法、HotSpot 的即时编译器、编译触发条件以及如何从虚拟机外部观察和分析 JIT 编译的数据和结果，还选择了集中场景的编译期优化技术进行讲解。对 Java 编译器的深入了解，有助于在工作中分辨哪些代码是编译器可以帮我们处理的，哪些代码需要自己调节以便更适合编译器的优化。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part6/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之九]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-5%2F</url>
    <content type="text"><![CDATA[第九章 类加载及执行子系统的案例与实战9.1 概述 在 Class 文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不多； 能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路； 9.2 案例分析9.2.1 Tomcat：正统的类加载器架构 Java Web 服务器：部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离又要可以互相共享；尽可能保证自身的安全不受部署的 Web 应用程序影响；要支持 JSP 生成类的热替换； 上图中，灰色背景的三个类加载器是 JDK 默认提供的类加载器，而 CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和 WebappClassLoader 是 Tomcat 自己定义的类加载器，分别加载 / common/（可被 Tomcat 和 Web 应用共用）、/server/（可被 Tomcat 使用）、/shared/（可被 Web 应用使用）和 / WebApp/WEB-INF/（可被当前 Web 应用使用）中的 Java 类库，Tomcat 6.x 把前面三个目录默认合并到一起变成一个 / lib 目录（作用同原先的 common 目录）； 9.2.2 OSGI：灵活的类加载架构 OSGI 的每个模块称为 Bundle，可以声明它所依赖的 Java Package（通过 Import-Package 描述），也可以声明它允许导出发布的 Java Package（通过 Export-Package 描述）； 除了更精确的模块划分和可见性控制外，引入 OSGI 的另外一个重要理由是基于 OSGI 的程序很可能可以实现模块级的热插拔功能； OSGI 的类加载器之间只有规则，没有固定的委派关系；加载器之间的关系更为复杂、运行时才能确定的网状结构，提供灵活性的同时，可能会产生许多的隐患； 9.2.3 字节码生成技术与动态代理的实现 在 Java 里面除了 javac 和字节码类库外，使用字节码生成的例子还有 Web 服务器中的 JSP 编译器、编译时植入的 AOP 框架和很常用的动态代理技术等，这里选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的； 动态代理的优势在于实现了在原始类和接口还未知的时候就确定类的代理行为，可以很灵活地重用于不同的应用场景之中； 以下的例子中生成的代理类 “$Proxy0.class” 文件可以看到代理为传入接口的每一个方法统一调用了 InvocationHandler 对象的 invoke 方法；其生成代理类的字节码大致过程其实就是根据 Class 文件的格式规范去拼接字节码； 9.2.4 Retrotranslator：跨越 JDK 版本 Retrotranslator 的作用是将 JDK 1.5 编译出来的 Class 文件转变为可以在 JDK 1.4 或 JDK 1.3 部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持 JDK 1.5 中新增的集合改进、并发包以及对泛型、注解等的反射操作； JDK 升级通常包括四种类型：编译器层面的做的改进、Java API 的代码增强、需要再字节码中进行支持的活动以及虚拟机内部的改进，Retrotranslator 只能模拟前两类，第二类通过独立类库实现，第一类则通过 ASM 框架直接对字节码进行处理； 9.3 实战：自己动手实现远程执行功能 目标：不依赖 JDK 版本、不改变原有服务端程序的部署，不依赖任何第三方类库、不侵入原有程序、临时代码的执行结果能返回到客户端； 思路：如何编译提交到服务器的 Java 代码（客户端编译好上传 Class 文件而不是 Java 代码）、如何执行编译之后的 Java 代码（要能访问其他类库，要能卸载）、如何收集 Java 代码的执行结果（在执行的类中把 System.out 的符号引用替换为我们准备的 PrintStream 的符号引用）； 具体实现：HotSwapClassLoader 用于实现同一个类的代码可以被多次加载，通过公开父类 ClassLoader 的 defineClass 实现；HackSystem 是为了替换 java.lang.System，它直接修改 Class 文件格式的 byte[] 数组中的常量池部分，将常量池中指定内容的 CONSTANT_Utf8_info 常量替换为新的字符串；ClassModifier 涉及对 byte[] 数组操作的部分，主要是将 byte[] 与 int 和 String 互相转换，以及把对 byte[] 数据的替换操作封装在 ByteUtils 类中；经过 ClassModifier 处理过的 byte[] 数组才会传给 HotSwapClassLoader.loadByte 方法进行类加载；而 JavaClassExecutor 是提供给外部调用的入口； 9.4 本章小结只有了解虚拟机如何执行程序，才能更好地理解怎样写出优秀的代码。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之八]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-4%2F</url>
    <content type="text"><![CDATA[第八章 虚拟机字节码执行引擎8.1 概述 执行引擎是 Java 虚拟机最核心的组成部分之一，区别于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行哪些不被硬件直接支持的指令集格式； 在虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，该模型成为各种虚拟机执行引擎的统一外观； 在不同的虚拟机实现里面，执行引擎在执行 Java 代码时可能会有解释执行和编译执行两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观来说是一致的：输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。 8.2 运行时栈帧结构 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素； 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程； 栈帧需要分配多少内存在编译时就完全确定并写入到方法表的 Code 属性之中了，不会受到程序运行期变量数据的影响； 对于执行引擎来说，在活动线程中只有位于栈顶的栈帧才算有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。 8.2.1 局部变量表 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，Code 属性的 max_locals 确定了该方法所需要分配的局部变量表的最大容量； 其容量以变量槽（Variable Slot）为最小单位，虚拟机规范允许 Slot 的长度随处理器、操作系统或虚拟机的不同而发生变化； 一个 Slot 可以存放一个 32 位以内的数据类型，包括 boolean、byte、char。short、int、float、reference 和 returnAddress 这八种类型；对于 64 位的数据类型（long 和 double），虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间； 8.2.2 操作数栈 也常称为操作栈，它是一个后入先出栈；Code 属性的 max_stacks 确定了其最大深度； 比如整数加法的字节码指令 iadd 在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个 int 型的数值，当执行这个指令时，会将这两个 int 值出栈并相加，然后将相加的结果入栈； 操作数栈中元素的类型必须与字节码指令的序列严格匹配； Java 虚拟机的解释执行引擎称为 “基于栈的执行引擎”，其中所指的栈就是操作数栈； 8.2.3 动态连接 每个栈帧都包含一个执行运行时常量池中该栈帧所属方法引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）； Class 文件的常量池的符号引用，有一部分在类加载阶段或者第一次使用时就转换为直接引用，这种称为静态解析，而另外一部分在每一次运行期间转换为直接引用，这部分称为动态连接； 8.2.4 方法返回地址 退出方法的方式：正常完成出口和异常完成出口； 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能只需的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数中，调整 PC 计数器的值以只需方法调用指令后面的一套指令等； 8.2.5 附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分完成取决于具体的虚拟机实现； 8.3 方法调用 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本即调用哪一个方法，暂时还不涉及方法内部的具体运行过程； Class 文件的编译过程中不报警传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂； 8.3.1 解析 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用称为解析； 在 Java 语言中符合编译器可知、运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类； 五条方法调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic； 解析调用是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用；而分派调用则可能是静态的也可能是动态的； 8.3.2 分派 静态分派：“Human man = new Man();” 语句中 Human 称为变量的静态类型，后面的 Man 称为变量的实际类型；静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译器可知的；而实际类型的变化在运行期才确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么；编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的；所有根据静态类型来定位方法执行版本的分派动作称为静态分派，其典型应用是方法重载； 动态分派：invokevirtual 指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质；我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派； 单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派分为单分派（根据一个宗量对目标方法进行选择）与多分派（根据多于一个宗量对目标方法进行选择）两种；今天的 Java 语言是一门静态多分派、动态单分派的语言； 虚拟机动态分派的实现：在方法区中建立一个虚方法表（Virtual Method Table），使用虚方法表索引来代替元数据查找以提高性能；方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化值后，虚拟机会把该类的方法表也初始化完毕； 8.3.3 动态类型语言支持 JDK 1.7 发布增加的 invokedynamic 指令实现了 “动态类型语言” 支持，也是为 JDK 1.8 顺利实现 Lambda 表达式做技术准备； 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器，比如 JavaScript、Python 等； Java 语言在编译期间就将方法完整的符号引用生成出来，作为方法调用指令的参数存储到 Class 文件中；这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息；而在 ECMAScript 等动态语言中，变量本身是没有类型的，变量的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型；变量无类型而变量值才有类型，这个特点也是动态类型语言的一个重要特征； JDK 1.7 实现了 JSR-292，新加入的 java.lang.invoke 包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法外，提供一种新的动态确定目标方法的机制，称为 MethodHandle； 从本质上讲，Reflection（反射）和 MethodHandle 机制都是在模拟方法调用，但 Reflection 是在模拟 Java 代码层次的方法调用，而 MethodHandle 是在模拟字节码层次的方法调用，前者是重量级，而后者是轻量级；另外前者只为 Java 语言服务，后者可服务于所有 Java 虚拟机之上的语言； 每一处含有 invokedynamic 指令的位置都称为 “动态调用点 (Dynamic Call Site)”，这条指令的第一个参数不再是代表符号引用的 CONSTANT_Methodref_info 常量，而是 CONSTANT_InvokeDynamic_info 常量（可以得到引导方法、方法类型和名称）； invokedynamic 指令与其他 invoke 指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定的； 8.4 基于栈的字节码解释执行引擎上节主要讲虚拟机是如何调用方法的，这节探讨虚拟机是如何执行方法中的字节码指令的。 8.4.1 解释执行 只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才比较确切； Java 语言中，javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程；因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现； 8.4.2 基于栈的指令集与基于寄存器的指令集 Java 编译器输出的指令集，基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，它们依赖操作数栈进行工作； 基于栈的指令集主要的优点是可移植性，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；主要缺点是执行速度相对来说会稍慢一点； 8.4.3 基于栈的解释器执行过程一段简单的算法代码 上述代码的字节码表示 123456789101112131415public int calc();Code:Stack=2, Locals=4, Args_size=10:bipush 1002:istore_13:sipush 2006:istore_27:sipush 30010:istore_311:iload_112:iload_213:iadd14:iload_315:imul16:ireturn javap 提示这段代码需要深度为 2 的操作数栈和 4 个 Slot 的局部变量空间，作者根据这些信息画了示意图来说明执行过程中的变化情况： 执行偏移地址为 0 的指令 执行偏移地址为 2 的指令 执行偏移地址为 11 的指令 执行偏移地址为 12 的指令 执行偏移地址为 13 的指令 执行偏移地址为 14 的指令 执行偏移地址为 16 的指令 注：上面的执行过程仅仅是一种概念模型，虚拟机中解析器和即时编译器会对输入的字节码进行优化。 8.5 本章小结本章分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码以及执行代码时涉及的内存结构。这第六、七、八三章中，我们针对 Java 程序是如何存储的、如何载入的以及如何执行的问题进行了讲解，下一章一起看看这些理论知识在具体开发中的经典应用。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记七：虚拟机类加载机制（重点）]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-3%2F</url>
    <content type="text"><![CDATA[第七章 虚拟机类加载机制（重点）7.1 概述 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成，这虽然增量一些性能开销，但是会为 Java 应用程序提供高度的灵活性。 7.2 类加载的时机 类的整个生命周期：加载、验证、准备、解析、初始化、使用和卸载；其中验证、准备和解析统称为连接； 虚拟机规范没有强制约束类加载的时机，但严格规定了有且只有 5 种情况必须立即对类进行初始化：遇到 new、getstatic、putstatic 和 invokestatic 指令；对类进行反射调用时如果类没有进行过初始化；初始化时发现父类还没有进行初始化；虚拟机启动指定的主类；动态语言中 MethodHandle 实例最后解析结果 REF_getStatic 等的方法句柄对应的类没有初始化时； 7.3 类加载的过程7.3.1 加载 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口； 7.3.2 验证 验证是连接阶段的第一步，其目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全； 验证阶段是非常重要的，这个阶段是否严谨决定了 Java 虚拟机是否能承受恶意代码的攻击； 校验动作：文件格式验证（基于二进制字节流）、元数据验证（对类的元数据语义分析）、字节码验证（对方法体语义分析）、符号引用验证（对类自身以外的信息进行匹配性校验）； 7.3.3 准备 正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在这个方法区中进行分配； 需要强调两点：这时候内存分配的仅包括类变量，而不包括类实例变量；这里所说的初始化通常情况下是数据类型的零值，真正的赋值是在初始化阶段，如果是 static final 的则是直接赋值； 7.3.4 解析 解析阶段是虚拟机将常量池内的符号引用（如 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等 7 种）替换为直接引用的过程； 符号引用可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中；而直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，它和虚拟机实现的内存布局相关，引用的目标必定以及在内存中存在； 对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可以对第一次解析的结果进行缓存； 7.3.5 初始化 是类加载过程的最后一步，真正开始执行类中定义的 Java 程序代码（或者说是字节码）； 初始化阶段是执行类构造器方法的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的； 方法与类的构造函数（或者说是实例构造器方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的方法执行之前，父类的方法已执行完毕； 执行接口的方法不需要先执行父接口的方法，只有当父接口中定义的变量使用时父接口才会初始化，接口的实现类在初始化时也一样不会执行接口的方法； 方法初始化是加锁阻塞等待的，应当避免在方法中有耗时很长的操作； 7.4 类加载器 虚拟机设计团队把类加载阶段的 “通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到虚拟机外部去实现，实现这个动作的代码模块称为类加载器； 这时 Java 语言的一项创新，也是 Java 语言流行的重要原因，在类层次划分、OSGI、热部署、代码加密等领域大放异彩； 7.4.1 类与类加载器 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每一个类加载器都拥有一个独立的类名称空间； 比较两个类是否相等（如 Class 对象的 equals 方法、isAssignableFrom 方法、isInstance 方法），只有在这两个类是由同一个类加载器加载的前提下才有意义； 7.4.2 双亲委派模型 三种系统提供的类加载器：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）； 双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器，这里一般不会以继承的关系来实现，而是使用组合的关系来复用父加载器的代码； 其工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载； 这样的好处是 Java 类随着它的类加载器具备了一种带有优先级的层次关系，对保证 Java 程序的稳定运作很重要； 实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass 方法中，逻辑清晰易懂； 7.4.3 破坏双亲委派模型 上一小节的双亲委派模型是 Java 设计者推荐给开发者的类加载器实现方法，但不是一个强制性的约束模型； 典型的两种情况：为了解决 JNI 接口提供者（SPI）引入的线程上下文类加载器；为了程序动态性加强的 OSGI 的 Bundle 类加载器； 7.5 本章小结本章介绍了类加载过程的加载、验证、准备、解析和初始化五个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。下一章将一起看看虚拟机如果执行定义在 Class 文件里的字节码。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/推荐扩展阅读：http://blog.csdn.net/javazejian/article/details/73413292]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记六：类文件结构（了解）]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-2%2F</url>
    <content type="text"><![CDATA[第三部分 虚拟机执行子系统第六章 类文件结构（了解）代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 6.1 概述由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。 6.2 无关性的基石 Java 刚诞生的宣传口号：一次编写，到处运行（Write Once, Run Anywhere）。其最终实现在操作系统的应用层：Sun 公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码。 字节码（ByteCode）是构成平台无关的基石； 另外虚拟机的语言无关性也越来越被开发者所重视，JVM 设计者在最初就考虑过实现让其他语言运行在 Java 虚拟机之上的可能性，如今已发展出一大批在 JVM 上运行的语言，比如 Clojure、Groovy、JRuby、Jython、Scala； 实现语言无关性的基础仍是虚拟机和字节码存储格式，Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与 Class 文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成 Class 文件，从而在虚拟机上运行。 6.3 Class 类文件的结构 Class 文件是一组以 8 个字节为基础单位的二进制流（可能是磁盘文件，也可能是类加载器直接生成的），各个数据项目严格按照顺序紧凑地排列，中间没有任何分隔符； Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，其中只有两种数据类型：无符号数和表； 无符号数属于基本的数据类型，以 u1、u2、u4 和 u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值； 表是由多个无符号数获取其他表作为数据项构成的复合数据类型，习惯以 “_info” 结尾； 无论是无符号数还是表，当需要描述同一个类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据未某一类型的集合。 下面我以自己本机写的一个简单的 Java 文件来学习其中各个部分的含义： 使用 javac 编译成 TestClass.class 文件，使用 16 进制打开： 使用 javap 命令输出 Class 文件信息： 6.3.1 魔数和版本 Class 文件的头 4 个字节，唯一作用是确定文件是否为一个可被虚拟机接受的 Class 文件，固定为 “0xCAFEBABE”。 第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号（0x0034 为 52，对应 JDK 版本 1.8）；能向下兼容之前的版本，无法运行后续的版本； 6.3.2 常量池 常量池可以理解为 Class 文件之中的资源仓库，是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项之一； 由于常量池中的常量数量不固定，因此需要在常量池前放置一项 u2 类型的数据来表示容量，该值是从 1 开始的，上图的 0x0013 为十进制的 19，代表常量池中有 18 项常量，索引值范围为 1~18； 常量池主要存放两大类常量：字面量（Literal，笔记接近 Java 的常量概念，比如文本字符串和 final 常量等）和符号引用（Symbolic References，主要包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）； Java 代码在 javac 编译时不会有 “连接” 这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接；所以在 Class 文件不会保存各个方法、字段和最终内存布局信息；当虚拟机运行时需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中； JDK 1.7 中常量池共有 14 种不同的表结构数据，这些表结构开始的第一位是一个 u1 类型的标志位，代表当前常量的类型，具体如下图所示： 之所以说常量池是最繁琐的数据就是因为这 14 种常量类型都有自己的结结构。可以结合下图中各个表结构的说明和之前使用 javap 解析的文件内容一起看。 第 1 项：0x0A（15 标志为方法句柄），0x0004（指向第 4 项的类描述符），0x000F（指向第 15 项的名称及类型描述符）； 第 2 项：0x09（9 标志为字段符号引用），0x0003（指向第 3 项类描述符），0x0010（指向第 16 项的名称及类型描述符）； 第 3 项：0x07（7 标志为类符号引用），0x0011（指向第 17 项全限定名常量项）； 第 4 项：0x07（7 标志为类符号引用），0x0012（指向第 18 项全限定名常量项）； 第 5 项：0x01（1 标志为 UTF - 字符串常量），0x0001（字符串占用 1 个字节），6D（字符 “m”）； 第 6 项：0x01（1 标志为 UTF - 字符串常量），0x0001（字符串占用 1 个字节），49（字符 “I”）； 第 7 项：0x01（1 标志为 UTF - 字符串常量），0x0006（字符串占用 6 个字节），3C 69 6E 69 74 3E（字符 “”）； 第 8 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），28 29 56（字符 “()V”）； 第 9 项：0x01（1 标志为 UTF - 字符串常量），0x0004（字符串占用 4 个字节），43 6F 64 65（字符 “Code”）； 第 10 项：0x01（1 标志为 UTF - 字符串常量），0x000F（字符串占用 15 个字节），4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65（字符 “LineNumberTable”）； 第 11 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），69 6E 63（字符 “inc”）； 第 12 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），28 29 49（字符 “()I”）； 第 13 项：0x01（1 标志为 UTF - 字符串常量），0x000A（字符串占用 10 个字节），53 6F 75 72 63 65 46 69 6C 65（字符 “SourceFile”）； 第 14 项：0x01（1 标志为 UTF - 字符串常量），0x000E（字符串占用 14 个字节），54 65 73 74 43 6C 61 73 73 2E 6A 61 76 61（字符 “TestClass.java”）； 第 15 项：0x0C（12 标志为名称和类型符号引用），0x0007（指向第 7 项名称常量项）， 0x0008（指向第 8 项描述符常量项）； 第 16 项：0x0C（12 标志为名称和类型符号引用），0x0005（指向第 5 项名称常量项）， 0x0006（指向第 6 项描述符常量项）； 第 17 项：0x01（1 标志为 UTF - 字符串常量），0x001F（字符串占用 31 个字节），63 6F 6D 2F 67 69 6E 6F 62 65 66 75 6E 6E 79 2F 63 6C 61 7A 7A 2F 54 65 73 74 43 6C 61 73 73（字符 “com/ginobefunny/clazz/TestClas”）； 第 18 项：0x01（1 标志为 UTF - 字符串常量），0x0010（字符串占用 16 个字节），6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74（字符 “java/lang/Object”）； 6.3.3 访问标志 紧接在常量池后面的是两个字节的访问标志，用于标识类或接口的访问信息； 访问标志一个有 16 个标志位，但目前只采用了其中 8 位，本例子中的 0x0021 标识为一个 public 的普通类； 6.3.4 类索引、父类索引与接口索引集合 类索引：u2 类型的数据，用于确定类的全限定名。本例子中为 0x0003，指向常量池中第 3 项； 父类索引：u2 类型的数据，用于确定父类的全限定名。本例子中为 0x0004，指向常量池中第 4 项； 接口索引计算器：u2 类型的数据，用于表示索引集合的容量。本例子中为 0x0000，说明没有实现接口； 接口索引集合：一组 u2 类型的数据的集合，用于确定实现的接口（对于接口来说就是 extend 的接口）。本例子不存在。 6.3.5 字段表集合 用于描述接口或者类中声明的变量，包括类级变量和实例级变量，但不包括方法内部声明的局部变量；它不会列出从父类和超类继承而来的字段； 0x0001 表示这个类只有一个字段表数据； 字段修饰符放在 access_flag 中，是一个 u2 的数据类型，0x0002 表示为 private 的属性； 字段名称 name_index，是一个 u2 的数据类型，0x0005 表示该属性的名称为常量池的第 5 项； 字段描述符 descriptor_index，是一个 u2 的数据类型，0x0006 表示该属性的描述符为常量池的第 6 项，其值 “I” 表示类型为整形； 字段属性计算器和属性集合：0x0000 表示该例子中不存在； 6.3.6 方法表集合 和字段表集合的方式几乎一样； 方法里面的代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 Code 的属性里面； 0x0002 表示这个类有两个方法表数据，分别是编译器添加的实例构造器和源码中的方式 inc()； 第一个方法的访问标志是 0x0001（public 方法），名称索引值为 0x0007（常量池第 7 项，“”），描述符索引值为 0x0008（常量池第 8 项，“()V”），属性表计算器为 0x0001（有一项属性），属性名称索引为 0x0009（常量池第 9 项，“Code”）； 根据 “6.3.7.1 Code 属性” 说明，属性值的长度为 23（0x0000001D 表示 29，但需要减去属性名称索引和属性长度固定的 6 个字节长度），操作数栈深度的最大值为 1（0x0001，虚拟机运行时根据这个值来分配栈帧中操作栈深度），局部变量表所需要的存储空间为 1 个 Slot（0x0001，Slot 是内存分配的最小单位），字节码长度为 5（0x00000005），分别为 2A（aload_0，将第 0 个 Slot 中为 reference 类型的本地变量推送到操作数栈顶）、B7（invokespecial，以栈顶的 reference 类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private 方法或者它父类的方法，后面接着一个 u2 的参数指向常量池的方法引用）、0x0001（表示常量池的第 1 项，即 Object 类的方法）、B1（对应的指令为 return，返回值为 void）；显式异常表为空（0x0000，计数器为 0）；该 Code 属性还内嵌 1 个属性（0x0001），属性的名称索引为 0x000A（即 “LineNumberTable” 属性，用于记录对应的代码行数），该内嵌属性的长度为 6（0x00000006），对应的行数信息为源码的第 3 行（0x000100000003）； 第二个方法的访问标志是 0x0001（public 方法），名称索引值为 0x000B（常量池第 11 项，“inc”），描述符索引值为 0x000C（常量池第 12 项，“()I”），属性表计算器为 0x0001（有一项属性），属性名称索引为 0x0009（常量池第 9 项，“Code”）； 根据 “6.3.7.1 Code 属性” 说明，属性值的长度为 25（0x0000001F 表示 31，但需要减去属性名称索引和属性长度固定的 6 个字节长度），操作数栈深度的最大值为 2（0x0002），局部变量表所需要的存储空间为 1 个 Slot（0x0001），字节码长度为 7（0x00000007），分别为 2A（aload_0）、B4（getfield，后面接着一个 u2 的参数指向常量池的属性引用）、0x0002（表示常量池的第 2 项，即 TestClass 类的 m 属性）、04（对应的指令为 iconst_1）、60（对应的指令为 iadd，整形求和）、AC（对应的指令为 ireturn，返回值为整形）；显式异常表为空（0x0000，计数器为 0）；该 Code 属性还内嵌 1 个属性（0x0001），属性的名称索引为 0x000A（即 “LineNumberTable” 属性，用于记录对应的代码行数），该内嵌属性的长度为 6（0x00000006），对应的行数信息为源码的第 8 行（0x000100000008）； 6.3.7 属性表集合 在 Class 文件、字段表、方法表都可以携带自己的属性表集合； 属性表集合的限制较为宽松，不再要求严格的顺序，只要属性名不重复即可； 以下是 Java 虚拟机规范里预定义的虚拟机实现应当能识别的属性： 接着我们的例子的 Class 文件还有最后一段：0x0001 表示该 Class 有一个属性，0x000D 表示属性名索引为第 13 项（对应 “SourceFile”），0x00000002 表示该属性长度为 2，0x000E 表示该类的 SourceFile 名称为第 14 项（对应 “TestClass.java”）。 6.3.7.1 Code 属性Java 程序方法体中的代码经过 javac 编译后，字节码指令存放在 Code 属性，其属性表结构如下： 6.3.7.2 Exceptions 属性方法描述时 throws 关键字后面列举的异常，和 Code 属性里的异常表不同。其属性表结构如下： 6.3.7.3 LineNumberTable 属性用于描述 Java 源码行号与字节码行号之间的对应关系，它不是必须的，可以通过 javac -g:none 取消该信息。没有该信息的影响是运行时抛异常不会显示出错的行号，在代码调试时无法按照源码行来设置断点。 6.3.7.4 LocalVariableTable 属性用于描述栈帧中局部变量与 Java 源码中定义的变量之间的关系，它不是运行时必须的，可以通过 javac -g:none 取消该信息。如果没有这个属性，所有的参数名称都会丢失，取之以 arg0、arg1 这样的占位符来替代。 其中 local_variable_info 项代表了一个栈帧与源码中局部变量的关联，如下所示： 6.3.7.5 SourceFile 属性用于记录生成这个 Class 的源码文件名称，这个属性也是可选的。 6.3.7.6 ConstantValue 属性作用是通知虚拟机自动为静态变量赋值，只有被 static 关键字修饰的变量才可以用这个属性。对于非 static 类型的变量的赋值是在实例构造器方法中进行的；而对于类变量有两种方式：在类构造器方法中或者使用 ConstantValue 属性。目前 Sun javac 编译器的选择是：同时使用 final 和 static 修饰的变量且为基本数据类型或 String 类型使用 ConstantValue 属性初始化，否则使用初始化。 6.3.7.7 InnerClass 属性用于记录内部类与宿主类之间的关联。 其中 number_of_class 代表需要记录多少个内部类信息，每个内部类的信息都由一个 inner_class_info 表进行描述。 6.3.7.8 Deprecated 及 Synthetic 属性Deprecated（不推荐使用）和 Synthetic（不是由 Java 源码直接产生编译器自行添加的，有两个例外是实例构造器和类构造器）这两个属性都属于布尔属性，只存在有和没有的区别，没有属性值的概念。在属性结构中 attribute_length 的数据值必须为 0x00000000。 6.3.7.9 StackMapTable 属性这是一个复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 6.3.7.10 Signature 属性一个可选的定长属性，在 JDK 1.5 发布后增加的，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，则 Signature 属性会为它记录泛型签名信息。这主要是因为 Java 的泛型采用的是擦除法实现的伪泛型，在字节码中泛型信息编译之后统统被擦除，在运行期无法将泛型类型与用户定义的普通类型同等对待。通过 Signature 属性，Java 的反射 API 能够获取泛型类型。 6.3.7.11 BootstrapMethods 属性一个复杂的变长属性，位于类文件的属性表中，用于保存 invokedynamic 指令引用的引导方法限定符。 6.4 字节码指令简介Java 虚拟机的指令由一个字节长度的、代表着特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。 在指令集中大多数的指令都包含了其操作所对应的数据类型信息，如 iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中。 加载和存储指令：iload/iload 等（加载局部变量到操作栈）、istore/istore 等（从操作数栈存储到局部变量表）、bipush/sipush/ldc/iconst_（加载常量到操作数栈）、wide（扩充局部变量表访问索引）； 运算指令：没有直接支持 byte、short、char 和 boolean 类型的算术指令而采用 int 代替；iadd/isub/imul/idiv 加减乘除、irem 求余、ineg 取反、ishl/ishr 位移、ior 按位或、iand 按位与、ixor 按位异或、iinc 局部变量自增、dcmpg/dcmpl 比较； 类型转换指令：i2b/i2c/i2s/l2i/f2i/f2l/d2i/d2l/d2f； 对象创建与访问指令：new 创建类实例、newarray/anewarray/multianewarray 创建数组、getfield/putfield/getstatic/putstatic 访问类字段或实例字段、baload/iaload/aaload 把一个数组元素加载到操作数栈、bastore/iastore/aastore 将一个操作数栈的值存储到数组元素中、arraylength 取数组长度、instanceof/checkcast 检查类实例类型； 操作数栈管理指令：pop/pop2 一个或两个元素出栈、dup/dup2 复制栈顶一个或两个数组并将复制值或双份复制值重新压力栈顶、swap 交互栈顶两个数值； 控制转移指令：ifeq/iflt/ifnull 条件分支、tableswitch/lookupswitch 复合条件分支、goto/jsr/ret 无条件分支； 方法调用和返回指令：invokevirtual/invokeinterface/invokespecial/invokestatic/invokedynamic 方法调用、ireturn/lreturn/areturn/return 方法返回； 异常处理指令：athrow 同步指令：monitorenter/monitorexit 6.5 公有设计和私有实现 Java 虚拟机的实现必须能够读取 Class 文件并精确实现包含在其中的 Java 虚拟机代码的含义； 但一个优秀的虚拟机实现，通常会在满足虚拟机规范的约束下具体实现做出修改和优化； 虚拟机实现的方式主要有两种：将输入的 Java 虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集或宿主主机 CPU 的本地指令集。 6.6 Class 文件结构的发展 Class 文件结构一直比较稳定，主要的改进集中向访问标志、属性表这些可扩展的数据结构中添加内容； Class 文件格式所具备的平台中立、紧凑、稳定和可扩展的特点，是 Java 技术体系实现平台无关、语言无关两项特性的重要支柱； 6.7 本章小结本章详细讲解了 Class 文件结构的各个部分，通过一个实例演示了 Class 的数据是如何存储和访问的，后面的章节将以动态的、运行时的角度去看看字节码在虚拟机执行引擎是怎样被解析执行的。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part4/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记五：案例分析]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-1%2F</url>
    <content type="text"><![CDATA[5.2 案例分析5.2.1 高性能硬件上的程序部署策略 背景：一个15万pv、天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个cpu,16GB物理内存，操作系统为 64位的 CentOS 5.4 ，Resin作为服务器。管理员选用了 64位的 jdk 1.5,通过-Xmx,-Xms 将堆固定在12GB，使用一段时间后，出现了卡B现象，长时间无响应。监控发现卡B是由于GC停顿导致的。虚拟机运行在Server模式，默认使用吞吐量优先收集器，一次回收12GB的堆，一次 Full Gc的时间高达 14秒，再加上程序设计的关系，访问文档中需要一次性把文档从磁盘中读取到内存，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有在Minor GC中清理掉。在这种情况下，即使有12GB的堆，内存也很快会被消耗殆尽，有次导致每隔十几分钟出现十几秒的卡B，令网站开发人员和管理人员感到郁闷。 分析：在高性能硬件上部署程序，目前主要有两种方式：1 通过 64位 JDK 来使用大内存。2 使用若干个32位虚拟机简历逻辑集群来利用硬件资源。 如果读者计划使用64位的JDK来管理大内存，还需要考虑下面可能面临的问题：1 内存回收导致的长时间停顿。2 现阶段，64位JDK的性能测试普遍地域32位JDK。3 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照(因为要产生十几GB乃至更大的dump文件)，即使产生了快照也几乎无法进行分析。4 相同的程序在64位JDK中消耗的内存一般比32位的JDK大，这是由指针膨胀以及数据类型对其补白等因素导致的。 考虑到以上几点因素，你可能会选择使用若干个虚拟机集群来利用硬件资源，具体做法是子啊一台物理机器上启动多个应用服务器进程，给每个服务器进程分配不同的端口，然后在前端大减一个负载均衡器，以反向代理的方式来分配访问请求。 这种部署方式可能会遇到下面的问题： 1 尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同事访问某个磁盘文件的话，很容易导致IO异常。 2 很难高效率的利用某些资源池，譬如连接池，一般都是在各个节点上简历自己的独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余，尽管可以使用集中式的JNDI，但这有一定的复杂性并且可能带来额外的性能代价。 3 各个节点仍然不可避免的收到32位的内存限制，在32位window平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些linux unix 系统(Solaris)可以提升到3GB乃至接近4Gb的内存，但32位中仍然接受最高4GB内存的限制。 4 大量使用本地缓存的应用，在逻辑集群中会造成大量的内存浪费，因为每个逻辑节点上都有一份缓存，这时可以考虑把本地缓存改为集中式缓存。 最终解决方案最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算(其中堆固定为1.5GB)，占用了10GB的内存。另外建立一个Apache服务作为前端均衡器代理访问门户。考虑到用户对响应较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较多提升。 5.2.2 集群间同步导致的内存溢出由于集群同步大量数据，导致数据过多，而超过内存限制。 心得： 发生 OOM 的时候自动生成堆 dump 文件可以加参数： -XX:+HeapDumpOnOutOfMemoryError 由于信息有传输失败需要重发的可能性，在确认所有注册的GMS(GroupMembership Service)的节点都收到正确的信息前，发送的信息必须在内存中保留。此MIS的服务端中有一个负责安全校验的全局Filter，每当接收请求时，均会更新 一次最后的操作时间，并且将这个时间同步到所有节点中，使得一个用户在一段时间内不能在多台机器上登录。在服务器使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间的网络交互非常频繁。 当网络情况不能满足传输要求时，重发数据在内存中不断地积累，很快就产生了内存溢出。 这个案例中的问题，既有JBossCache的缺陷，也有MIS系统实现方式上的缺陷。JBossCache官方的mailist中讨论过很多次类似的内存溢出异常问题，据说后续版本有了改进。而更重要的缺陷是这一类被集群共享的数据如果要使用类似JBossCache 这种集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动作不会耗费多少资源，但不应当有过于频繁的写操作，这会带来很大的网络同步的开销。 5.2.3 堆外内存导致的溢出错误当出现 OOM 的时候不得不考虑下堆外内存导致的错误。第 2 章的时候也提到过，出现堆外内存导致的 OOM 时，heap dump 是无效的。异常栈里面可以明显看到 DirectByteBuffer、NIO 等字样的时候就可以考虑是堆外内存溢出导致的问题了。 最佳实践：因此总内存在分配给 JAVA 堆的时候，也确保预留了足够的堆外内存。 重点知识： 堆外内存不足的时候不会执行主动触发 GC，只会抛一些 OOM 的错误。 堆外内存导致的 OOM，heap dump 是无效的 只能等老年代 full GC 的时候顺便回收下堆外空间 其他心得：如果内存不足时抛出 StackOverflowError（纵向上，无法分配栈帧）或者 OutOfMemoryError:unable to create native thread（横向上，无法建立新的线程），考虑增加 - Xss 5.2.4 外部命令导致系统缓慢避免在 Java 中使用 Runtime.getRuntime().exec() 方法来执行外部的 shell 脚本。这样的实现方式开销较大。如果频繁调用会给 CPU 和内存带来极大压力。 JVM 执行这个命令的过程： 克隆一个和当前虚拟机拥有一样环境变量的进程 勇这个心得进程去执行外部命令，最后再退出这个进程。 5.2.5 服务器 JVM 进程崩溃使用异步调用，但是被调用方和调用发速度不匹配导致大量等待的线程和 socket 连接。最后积压太多超过 JVM 承受能力使得虚拟机进程崩溃。 解决办法： 采用生产者、消费者模式的消息队列来实现 5.2.6 不恰当数据结构导致内存占用过大例如： HashMap &lt;long,long&gt;这个种类型，各种头部开销比内容 (两个 Long 类型) 开销都要大得多，导致空间利用率低。&lt;/long,long&gt; 5.2.7 由 Windows 虚拟内存导致的长时间停顿GUI 程序最小化的时候，他的工作内存被自动交换到磁盘的页面文件之中，这样发生 GC 时就又可能因为恢复页面文件的操作而导致不正常的 GC 停顿。 解决办法：加入参数 “-Dsum.awt.keepWorkingSetOnMinimize=true” 5.3 实战：IDEA 运行速度调优这个整个过程较长，可以看书 P142 页开始。 我这里仅仅记录下一些值得注意的点： hostSpot 虚拟机名字由来： 如果一段 JAVA 方法被调用次数达到一定程度，就会判断为热带码交给 JIT 编译器（Just in time compiler）编译为本地代码，提高运行速度。 visualVM 里面的 visualGC 插件还是很有用的 参考： http://ningg.top/tool-personal-intellij-idea-for-mac-optimize/ http://blog.csdn.net/zhouping118/article/details/78185362 http://blog.csdn.net/u013295276/article/details/78543190 参考：https://kaimingwan.com/post/books/shen-ru-li-jie-javaxu-ni-ji/di-wu-zhang-diao-you-an-li-fen-xi-yu-shi-zhan]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记四：JVM 小工具]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11%2F</url>
    <content type="text"><![CDATA[JVM 小工具在 ${JAVA_HOME}/bin / 目录下 Sun/Oracle 给我们提供了一些处理应用程序性能问题、定位故障的工具, 包含 bin 描述 功能 jps 打印 Hotspot VM 进程 VMID、JVM 参数、main()函数参数、主类名 / Jar 路径 jstat 查看 Hotspot VM 运行时信息 类加载、内存、GC[可分代查看]、JIT 编译 jinfo 查看和修改虚拟机各项配置 -flag name=value jmap heapdump: 生成 VM 堆转储快照、查询 finalize 执行队列、Java 堆和永久代详细信息 jmap -dump:live,format=b,file=heap.bin [VMID] jstack 查看 VM 当前时刻的线程快照: 当前 VM 内每一条线程正在执行的方法堆栈集合 Thread.getAllStackTraces()提供了类似的功能 javap 查看经 javac 之后产生的 JVM 字节码代码 自动解析.class文件, 避免了去理解 class 文件格式以及手动解析 class 文件内容 jcmd 一个多功能工具, 可以用来导出堆, 查看 Java 进程、导出线程信息、 执行 GC、查看性能相关数据等 几乎集合了 jps、jstat、jinfo、jmap、jstack 所有功能 jconsole 基于 JMX 的可视化监视、管理工具 可以查看内存、线程、类、CPU 信息, 以及对 JMX MBean 进行管理 jvisualvm JDK 中最强大运行监视和故障处理工具 可以监控内存泄露、跟踪垃圾回收、执行时内存分析、CPU 分析、线程分析… 4.2 JDK 命令行工具 名称 主要作用 jps JVM Process Status Tool，显示指定系统内所有 HotSpot 虚拟机进程 jstat JVM Statistics Monitoring Tool，用于手机 HotSpot 虚拟机各方面运行数据 jinfo Configuration Info For Java，显示虚拟机配置信息 jmap Memory Map For Java，生成虚拟机内存转储快照（heapdumap 文件） jhat JVM Heap Dump Brower，用于分析 heapdump 文件 jstack Stack Trace For Java，显示虚拟机线程快照 4.2.1 jps：虚拟机进程状况工具1jps [options] [hostid] 参数 功能 -q 只输出 LVMID，省略主类名称 -m 输出虚拟机进程启动时传递给主类 main() 函数的参数 -l 输出主类全名，如果进程执行的是 jar 包，输出 jar 路径 -v 输出虚拟机启动时的 JVM 参数 4.2.2 jstat：虚拟机统计信息监视工具主要查询 3 类信息： 类装载 垃圾收集 运行期编译 1jstat [ option vmid [interval [s|ms] [count]] ] 参数 功能 -class 监视类装载、卸载数量、总空间及类装载所耗费的时间 -gc 监视 Java 堆状况，包括 Eden 区，2 个 survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息 -gccapacity 与 - gc 基本相同，主要关注 Java 堆各个区域使用到的最大和最小空间 -gcutil 与 - gc 基本相同，主要关注已使用空间占总空间百分比 -gccause 与 - gcutil 基本相同，但是会额外输出导致上一次 gc 产生的原因 -gcnew 监视新生代 GC 状况 -gcnewcapacity 监视内容与 - gcnew 一样，主要关注使用到的最大和最小空间 -gcold 监视老年代 GC 情况 -gcoldcapacity -compiler 输出 JIT 编译器编译过的方法、耗时等信息 -printcompilation 输出已经被 JIT 编译的方法 4.2.3 jinfo：Java 配置信息工具1jinfo [option] pid 4.2.4 jmap：Java 内存映像工具1jmap [option] vmid 参数 功能 -dump 生成 Java 堆转储快照。格式：-dump:[live,]format=b,file=，其中 live 子参数说明是否只 dump 出存活的对象 -finalizerinfo 在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只在 Linux/Solaris 下有效 -heap 显示 Java 堆详细信息，如使用哪种回收期、参数配置、分代状况等。只在 Linux/Solaris 下有效 -histo 显示堆中对象统计信息，包括类、实例数量和合计总量 4.2.5 jhat：虚拟机堆转储快照分析工具4.2.6 jstack：Java 堆栈跟踪工具1jstack [option] vmid 参数 功能 -F 强制输出 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用了本地方法的话，可以显示 C/C++ 的堆栈 4.3 JDK 可视化工具4.3.1 JConsole：Java 监视与管理控制台4.3.2 VisualVm：多合一故障处理工具 下载地址：http://visualvm.github.io/download.html 插件中心：https://visualvm.github.io/pluginscenters.html 参考：https://www.jianshu.com/p/c56884715567?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记三（垃圾收集器与内存分配策略，重点）]]></title>
    <url>%2F2018%2F03%2F10%2F2018-03-10%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略（重点）3.2 判断对象是否存活3.2.1 引用计数算法 (Reference Counting) 非主流 3.2.2 可达性分析算法 (GC Roots Analysis) 主流用这个判断 在主流的商用程序语言中 (Java 和 C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，下图对象 object5, object6, object7 虽然有互相判断，但它们到 GC Roots 是不可达的，所以它们将会判定为是可回收对象。 在 Java 语言里，可作为 GC Roots 对象的包括如下几种： a. 虚拟机栈 (栈桢中的本地变量表) 中的引用的对象 b. 方法区中的类静态属性引用的对象 c. 方法区中的常量引用的对象 d. 本地方法栈中 JNI 的引用的对象 3.2.3 引用在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用：就是指在程序代码之中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。 3.2.4 finalize() 方法最终判定对象是否存活 即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑” 阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 标记的前提是对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链。1). 第一次标记并进行一次筛选。 筛选的条件是此对象是否有必要执行 finalize() 方法。 当对象没有覆盖 finalize 方法，或者 finzlize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”，对象被回收。 2). 第二次标记 如果这个对象被判定为有必要执行 finalize（）方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的 “执行” 是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象 finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。 Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模标记，如果对象要在 finalize（）中成功拯救自己—- 只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出 “即将回收” 的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。不过大家尽量避免使用这个方法流程图如下： 注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，因此第二段代码的自救行动失败了。 并且建议大家尽量避免使用它 GC 日志说明： GC 打印时间: [垃圾回收类型回收时间: [收集器名称: 年轻代回收前占用大小 -&gt;年轻代回收后占用大小 (年轻代当前容量), 年轻代局部 GC 时 JVM 暂停处理的时间] 堆空间 GC 前占用的空间 -&gt; 堆空间 GC 后占用的空间(堆空间当前容量),GC 过程中 JVM 暂停处理的时间]。 垃圾回收类型：分为 GC 和 Full GC. GC 一般为堆空间某个区发生了垃圾回收， Full GC 基本都是整个堆空间及持久代发生了垃圾回收，通常优化的目标之一是尽量减少 GC 和 Full GC 的频率。 收集器名称：一般都为收集器的简称或别名，通过收集器名称基本都能判断出那个区发生了 GC。 DefNew：年轻代（新生代）发生了 GC （若为 DefNew 可知当前 JVM 年轻代使用的串行收集器） ParNew：年轻代（新生代）发生了 GC （若为 ParNew 可知当前 JVM 年轻代使用了并行收集器） Tenured：老年代发生了 GC Perm：持久代发生了 GC 3.2.5回收方法区 Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价表” 一般比较低。 方法区中的垃圾回收主要是：废弃常量及无用类。判断常量是否废弃与判断堆中对象十分相似。例如，若常量池中存在字符串 “abc”，而系统中并没有任何 String 对象的值为“abc” 的，也就是没有任何对象引用它，那么它就可以被回收了。无用类的判定稍微复杂点，需要满足： 1). 该类的所有对象实例已经被回收，也就是 Java 堆中不存在该类的任何实例； 2). 加载该类的 ClassLoader 已经被回收； 3). 该类的类对象 Class 没有在任何地方被引用，无法使用反射来访问该类的方法。 当方法区中的类满足以上条件时，就可以对无用类进行回收了，这里说的仅仅是 “可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了各种配置，这里不多讲。 在大量使用反射、动态代理、CGLIB 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保存永久代不会溢出。 3.3 垃圾收集算法（本书重点中的重点）3.3.1 标记 - 清除算法 (Mark-Sweep) 最基础的收集算法。其它算法都是基于这种思路并对其不足进行改进而得到的。 标记 - 清除算法将垃圾回收分为两个阶段： ①. 标记阶段：首先标记出所有需要回收的对象。 如何标记，在上面的 “判断对象是否存活” 里有讲过 ②. 清除阶段：标记完成后，统一回收被标记的对象缺点： ①. 效率问题：标记清除过程效率都不高。 ②. 空间问题：标记清除之后会产生大量的不连续的内存碎片 (空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。） 3.3.2 复制算法 (Copying)为了解决 mark-sweep 算法的效率问题 算法思想： 1). 将现有的内存空间分为两块，每次只使用其中一块. 2). 当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。 3). 再把已使用过的内存空间一次清理掉。 优点： 1). 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 2). 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 2.3 缺点： 1). 内存减少为原来的一半，太浪费了。 2). 对象存活率较高的时候就要执行较多的复制操作，效率变低。 3). 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。2.4. 演进 并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 EdenSpace 和两块较小的 SurvivorSpace JavaHeap 内存回收模型（当前商业虚拟机大多使用此算法回收新生代） jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 3.3.3 标记 - 整理算法 (Mark-Compact) 由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 算法思想 1). 标记阶段：首先标记出所有需要回收的对象。与 “标记 - 清除” 一样 2). 让存活的对象向内存的一段移动。 3). 直接清理掉边界以外的内存。 由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记 - 清理算法或者标记整理算法。 3.3.4 代收集算法 (Generational Collecting) 当前的商业虚拟机的垃圾收集都采用，把 Java 堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。 3.4 HotSpot的算法实现3.4.1 枚举根节点可达性分析在执行 GC 的时候会停顿一下，如果引用关系不断变换的时候很难进行准确的可达性分析。目前虚拟机主要采用的是准确性 GC，虚拟机应该有办法知道哪些地方存着对象引用，在 HotSpot 的实现中，用一组叫做 OopMap 的数据结构来实现这个目的，在类加载完成后记录下对象内的数据类型与偏移量，在 JIT 编译 过程中记录下栈和寄存器中哪些位置是引⽤。 3.4.2 安全点导致 OopMap 变化的指令非常多，我们只在特定的地点做记录，我们把这些点叫做安全点，也就是说让所以线程（不包括 JNI 调用的线程）跑到最近的安全点再停顿下来，所以安全点不能让 GC 等待时间过长，也不能太频繁。这里我们分为两种方式 抢占式中断，在 GC 的时候停下所以线程，再让没有到安全点的跑到安全点，目前几乎没有虚拟机采用这种方式进行 GC 主动式中断，当 GC 需要中断线程的时候，在安全点上设置中断标 志，线程执⾏时主动轮询中断标志，发现标志为真时则主动中断挂 起线程。轮训标志的地方和安全点重合。 3.4.3 安全区域指线程在某⼀段代码⽚段中，引⽤关系不会发⽣变化，在这个区域中的任意点开始 GC 都是安全的。GC 的时候不用考虑处于安全区域的，当线程出安全区域的时候要检查是否 GC 完成了，在线程处于 blocked 或 sleep 状态⽆法跑到安全点时，采⽤安全区域可以避免 GC ⻓时间等待。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 3.5 垃圾收集器 如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。 GC实现目标: 准确、高效、低停顿、空闲内存规整. ————————–新生代收集器———————— 3.5.1 Serial 收集器Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在 JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。 特性：这个收集器是一个单线程的收集器，但它的 “单线程” 的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Stop The World 应用场景：Serial 收集器是虚拟机运行在 Client 模式下的默认新生代收集器。 优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 3.5.2 ParNew 收集器 特性：ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。 应用场景：ParNew 收集器是许多运行在 Server 模式下的虚拟机中首选的新生代收集器。 很重要的原因是：除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS 收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。 Serial 收集器 VS ParNew 收集器：ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。然而，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的有效利用还是很有好处的。 3.5.3 Parallel Scavenge 收集器 1. 特性： Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 应用场景：停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 对比分析： Parallel Scavenge 收集器 VS CMS 等收集器：Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为 “吞吐量优先” 收集器。 Parallel Scavenge 收集器 VS ParNew 收集器：Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别是它具有自适应调节策略。 GC 自适应的调节策略：Parallel Scavenge 收集器有一个参数 -XX:+UseAdaptiveSizePolicy。当这个参数打开之后，就不需要手工指定新生代的大小、Eden 与 Survivor 区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。 ————————- 老年代收集器—————————- 3.5.4 Serial Old 收集器 特性：Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记－整理算法。 应用场景： Client 模式Serial Old 收集器的主要意义也是在于给 Client 模式下的虚拟机使用。 Server 模式如果在 Server 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 3.5.5 Parallel Old 收集器 特性：Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记－整理” 算法。 应用场景：在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作）。由于老年代 Serial Old 收集器在服务端应用性能上的 “拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。直到 Parallel Old 收集器出现后，“吞吐量优先” 收集器终于有了比较名副其实的应用组合。 3.5.6 CMS(Concurrent Mark Sweep) 收集器 1. 特性： CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。 CMS 收集器是基于 “标记—清除” 算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤： 初始标记（CMS initial mark）初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要 “Stop The World”。 并发标记（CMS concurrent mark）并发标记阶段就是进行 GC Roots Tracing 的过程。 重新标记（CMS remark）重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要 “Stop The World”。 并发清除（CMS concurrent sweep）并发清除阶段会清除对象。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。 优点：CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。 缺点： CMS 收集器对 CPU 资源非常敏感其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU 数量 + 3）/ 4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大。 CMS 收集器无法处理浮动垃圾CMS 收集器无法处理浮动垃圾，可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为 “浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS 收集器会产生大量空间碎片CMS 是一款基于 “标记—清除” 算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。—————————新生代和老年代均适用——————— 3.5.7 G1 收集器 特性：G1（Garbage-First）是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。 并行与并发G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。 分代收集与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合与 CMS 的 “标记—清理” 算法不同，G1 从整体来看是基于 “标记—整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。 可预测的停顿这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。 在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。 G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 执行过程：G1 收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking）初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 3.5.8、GC 相关参数总结VM 常用参数整理 参数 描述 -Xms 最小堆大小 -Xmx 最大堆大小 -Xmn 新生代大小 -XX:PermSize 永久代大小 -XX:MaxPermSize 永久代最大大小 -XX:+PrintGC 输出 GC 日志 -verbose:gc - -XX:+PrintGCDetails 输出 GC 的详细日志 -XX:+PrintGCTimeStamps 输出 GC 时间戳 (以基准时间的形式) -XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息 -Xloggc:/path/gc.log 日志文件的输出路径 -XX:+PrintGCApplicationStoppedTime 打印由 GC 产生的停顿时间 垃圾收集器参数总结 参数 描述 -XX:+UseSerialGC Jvm 运行在 Client 模式下的默认值，打开此开关后，使用 Serial + Serial Old 的收集器组合进行内存回收 -XX:+UseParNewGC 打开此开关后，使用 ParNew + Serial Old 的收集器进行垃圾回收 -XX:+UseConcMarkSweepGC 使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收，Serial Old 作为 CMS 出现 “Concurrent Mode Failure” 失败后的后备收集器使用。 -XX:+UseParallelGC Jvm 运行在 Server 模式下的默认值，打开此开关后，使用 Parallel Scavenge + Serial Old 的收集器组合进行回收 -XX:+UseParallelOldGC 使用 Parallel Scavenge + Parallel Old 的收集器组合进行回收 -XX:SurvivorRatio 新生代中 Eden 区域与 Survivor 区域的容量比值，默认为 8，代表 Eden:Subrvivor = 8:1 -XX:PretenureSizeThreshold 直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 -XX:MaxTenuringThreshold 晋升到老年代的对象年龄，每次 Minor GC 之后，年龄就加 1，当超过这个参数的值时进入老年代 -XX:UseAdaptiveSizePolicy 动态调整 java 堆中各个区域的大小以及进入老年代的年龄 -XX:+HandlePromotionFailure 是否允许新生代收集担保，进行一次 minor gc 后, 另一块 Survivor 空间不足时，将直接会在老年代中保留 -XX:ParallelGCThreads 设置并行 GC 进行内存回收的线程数 -XX:GCTimeRatio GC 时间占总时间的比列，默认值为 99，即允许 1% 的 GC 时间，仅在使用 Parallel Scavenge 收集器时有效 -XX:MaxGCPauseMillis 设置 GC 的最大停顿时间，在 Parallel Scavenge 收集器下有效 -XX:CMSInitiatingOccupancyFraction 设置 CMS 收集器在老年代空间被使用多少后出发垃圾收集，默认值为 68%，仅在 CMS 收集器时有效，-XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSCompactAtFullCollection 由于 CMS 收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在 CMS 收集器时有效 -XX:+CMSFullGCBeforeCompaction 设置 CMS 收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与 UseCMSCompactAtFullCollection 参数一起使用 -XX:+UseFastAccessorMethods 原始类型优化 -XX:+DisableExplicitGC 是否关闭手动 System.gc -XX:+CMSParallelRemarkEnabled 降低标记停顿 -XX:LargePageSizeInBytes 内存页的大小不可设置过大，会影响 Perm 的大小，-XX:LargePageSizeInBytes=128m Client、Server 模式默认 GC 服务端 or 客户端 新生代 GC 方式 老年代和持久代 GC 方式 Client Serial 串行 GC Serial Old 串行 GC Server Parallel Scavenge 并行回收 GC Parallel Old 并行 GC Sun/oracle JDK GC 组合方式 参数 新生代 GC 方式 老年代和持久代 GC 方式 -XX:+UseSerialGC Serial 串行 GC Serial Old 串行 GC -XX:+UseParallelGC Parallel Scavenge 并行回收 GC Serial Old 并行 GC -XX:+UseConcMarkSweepGC ParNew 并行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时，采用 Serial Old 串行 GC -XX:+UseParNewGC ParNew 并行 GC Serial Old 串行 GC -XX:+UseParallelOldGC Parallel Scavenge 并行回收 GC Parallel Old 并行 GC -XX:+UseConcMarkSweepGC -XX:+UseParNewGC Serial 串行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时采用 Serial Old 串行 GC 常用的收集器组合 服务器 31 新生代 GC 策略 老年老代 GC 策略 说明 组合 1 Serial Serial Old Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。 组合 2 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。 组合 3 ParNew CMS 使用-XX:+UseParNewGC选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用 - XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用 ParNew GC 策略。 组合 4 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。 组合 5 Parallel Scavenge Serial Old Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 组合 6 Parallel Scavenge Parallel Old Parallel Old 是 Serial Old 的并行版本 组合 7 G1GC G1GC -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启；-XX:MaxGCPauseMillis =50 #暂停时间目标；-XX:GCPauseIntervalMillis =200 #暂停间隔目标；-XX:+G1YoungGenSize=512m #年轻代大小；-XX:SurvivorRatio=6 #幸存区比例 1. 与串行回收器相关的参数 -XX:+UseSerialGC: 在新生代和老年代使用串行回收器。 -XX:+SuivivorRatio: 设置 eden 区大小和 survivor 区大小的比例。 -XX:+PretenureSizeThreshold: 设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。 -XX:MaxTenuringThreshold: 设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。 2. 与并行 GC 相关的参数 -XX:+UseParNewGC: 在新生代使用并行收集器。 -XX:+UseParallelOldGC: 老年代使用并行回收收集器。 -XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。 -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。 -XX:GCTimeRatio: 设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 -XX:+UseAdaptiveSizePolicy: 打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 3. 与 CMS 回收器相关的参数 -XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS + 串行收集器。 -XX:+ParallelCMSThreads: 设定 CMS 的线程数量。 -XX:+CMSInitiatingOccupancyFraction: 设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。 -XX:+UseFullGCsBeforeCompaction: 设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 -XX:+CMSClassUnloadingEnabled: 允许对类元数据进行回收。 -XX:+CMSParallelRemarkEndable: 启用并行重标记。 -XX:CMSInitatingPermOccupancyFraction: 当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是 - XX:+CMSClassUnloadingEnabled 激活了)。 -XX:UseCMSInitatingOccupancyOnly: 表示只在到达阈值的时候，才进行 CMS 回收。 -XX:+CMSIncrementalMode: 使用增量模式，比较适合单 CPU。 4. 与 G1 回收器相关的参数 -XX:+UseG1GC：使用 G1 回收器。 -XX:+UnlockExperimentalVMOptions: 允许使用实验性参数。 -XX:+MaxGCPauseMills: 设置最大垃圾收集停顿时间。 -XX:+GCPauseIntervalMills: 设置停顿间隔时间。 5. 其他参数 -XX:+DisableExplicitGC: 禁用显示 GC。 3.6 内存分配与回收策略（重点） Java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题： 1). 给对象分配内存; 2). 回收分配给对象的内存。关于回收内存这一点请参考如下文章 内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为 “对象游离”。 Jvm 怎么判断对象可以回收了？ 1). 对象没有引用，被判定为 “死亡”（并不是这个对象被赋值为 null 之后就一定被标记为可回收） 2). 作用域发生未捕获异常 3). 程序在作用域正常执行完毕 4). 程序执行了 System.exit() 5). 程序发生意外终止（被杀进程等） 对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 分配前请先了解下新年代和老年代： 3.6.1 对象优先在 Eden 分配 前面的文章介绍过 Hotspot 虚拟机新生代内存布局及算法： a. 将新生代内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。b. 每次使用 Enden 和其中一块 Survivor。c. 当回收时，将 Eden 和使用中的 Sruvivor 中还存的对象一次性复制到另一块 Survivor；d. 然后清理掉 Eden 和使用过的 Survivor 空间；e. 后面就使用 Eden 和另一块 Survivior 空间，重复步骤 3。 默认 Eden：Survivor=8：1，即每次可以使用 90% 的空间，只有一块 Survivor 空间被浪费。 大多数情况下，对象在 Eden 区中分配；当 Eden 区没有足够空间进行分配时，JVM 将会发起一次 MinorGC(新生代 GC)。MinorGC 时，如果发现存活的对象无法全部放入 Servivor 空间，只好通过分配机制提前转入熬年老代中。 3.6.2 大对象直接进入老年代 所谓的大对象是指：需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。 大对象对虚拟机的内存分配来说就是一个坏消息，比遇到一个大对象更加坏的消息就是：遇到一群 “朝生夕灭” 的 “短命大对象”。 经常出现大对象容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。 所以我们应该避免创建大对象； “-XX:PretenureSizeThreshold”： 可以设置这个阀值，大于这个参数值的对象直接在年老代中分配。 默认为 0(无效)，且只对 Serail 和 ParNew 两款收集器有效。 如果需要使用该参数，可以考虑 ParNew+CMS 组合 长期存活的对象将进入年老代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.3 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.4 动态对象年龄判定JVM 为了更好适应不同程序，不是永远要求等到 MaxTenuringThreshold 参数设置的年龄。 如果在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，大于或等于该年龄的对象就可以直接进入年老代。 3.6.5 空间分配担保 当 Survivor 空间不够用时，需要依赖其他内存 (年老代) 进行分配担保(Hanle Promotion) 分配担保流程如下： a. 在发生 Minor GC 之前，JVM 首先检查年老代最大可用的连续空间是否大于新生所有对象的空间。 b. 如果大于，那么可以确保 Minor GC 是安全的。 c. 如果不大于，则 JVM 查看 HandlePromotionFailure 值是否允许担保失败。 d. 如果允许，将尝试进行一次 Minor GC，但这是有风险对的； e. 如果小于或 HandlePromotionFailure 值不允许冒险，那这时，要改为进行一次 Full GC； 尝试 Minor GC 的风险 – 担保失败： 因为尝试 Minor GC 前，无法知道存货的对象大小，所以使用历次晋升到年老代对象的平均大小作为经验值。 加入尝试的 Minor GC 最终存活的对象远远高于经验值的话，会导致担保失败 (Handle Promotion Failure)。 失败后只有重新发起一次 Full GC，这绕了一个大圈，代价较高。 但一般还是要开启 HandlePromotionFailure，避免 Full GC 过于频繁，而且担保失败概率还是比较低的。 JDK1.6 之后，JVM 代码中已经不再使用 HandlePromotionFailure 参数了… 规则变为： 只要年老代最大可用的连续空间大于新生所有对象的空间或历次晋升到年老代对象的平均大小，就会进行 MinorGC，否则进行 Full GC。 即年老代最大可用的连续空间小于新生所有对象空间时，不在检查 HandlePromotionFailure，而是直接检查历次晋升熬年老代对象的平均大小。 参考：http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/https://www.jianshu.com/p/50d5c88b272dhttp://blog.csdn.net/simba_cheng/article/details/78223010]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM参数调优]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09%2F</url>
    <content type="text"><![CDATA[常见配置汇总堆设置-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值.如:为3,表示年轻代与年老代比值为1:3,年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:3,表示Eden:Survivor=3:2,一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数.并行收集线程数.-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式.适用于单CPU情况.-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数. 参考：http://blog.csdn.net/xiajian2010/article/details/17376157]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理数据可视化]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[根据现有数据集进行数据表查询集构建： galleryproduction 左外联结 production: 1234SELECT scratch_api_production.id,scratch_api_galleryproduction.production_id,scratch_api_production.nameFROM scratch_api_galleryproduction LEFT JOIN scratch_api_productionON scratch_api_production.id=scratch_api_galleryproduction.production_id production 左外联结 user: 1234SELECT scratch_api_production.author_id,scratch_api_user.baseuser_ptr_id,scratch_api_user.sex,scratch_api_user.gradeFROM scratch_api_production LEFT JOIN scratch_api_user ON scratch_api_production.author_id=scratch_api_user.baseuser_ptr_id 再构建三联表： galleryproduction左外联结production左外联结user 三表联结查询模版： 123select username,psw,gname,tel from (t1 left join t2 on t1.t1_id=t2.t1_id) left join t3 on t1.t1_id=t3.t1_id 我根据业务流程实现的sql查询： 查询某专题活动中的所有信息 1234SELECT *FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 然后使用阿里云的DataV进行数据可视化: 需要对接接口： 查询点赞数最多作品排行： 12345SELECT scratch_api_production.like,scratch_api_production.name FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' AND sex='男'ORDER BY scratch_api_production.like DESC 查询结果集中的男女人数 123456789SELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='男'UNIONSELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='女' 查询某专题活动学校参与度排名 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询某专题活动中的参与性别 1234SELECT scratch_api_user.sexFROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' 查询年级占比 123456SELECT scratch_api_user.grade ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.grade is not NULLGROUP BY scratch_api_user.gradeorder by count(*) desc 查询学校占比 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询作品提交时间 12345SELECT DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") as '日期',count(*) as '当日投票数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1GROUP BY DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") 把地址转换成经纬度不要方，利用高德地图经纬度快速查询工具可以轻松地把任何地址转换成经纬度，可具体到门牌号喔，工具地址： 控制台 | 高德开放平台 | 高德地图API 义乌市首届Scratch编程周实时数据状态网址(动态页面):http://datav.aliyun.com/share/07ef37b235d9763bd364f344912d1a05大数据可视化说明:大数据屏幕：1920*1080（可修改）最高实时更新频率：1min/次正常显示的预览效果参考（静态截图）：http://p4lmrb1gp.bkt.clouddn.com/15205615855957.jpg本机上如果不是上述参考效果请检查自己的浏览器如下:推荐电脑上预览：首选谷歌 Chrome 浏览器版本56以上，其他浏览器则需更新至最新版并开启极速（chrome内核）模式，不要使用IE浏览器，否则无法正常显示。不推荐手机上预览：无法按默认长宽比例展示 预览效果：]]></content>
      <tags>
        <tag>数据可视化</tag>
        <tag>DataV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记二：Java内存区域与内存溢出异常&实战（重点）]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-05-2%2F</url>
    <content type="text"><![CDATA[第二章 Java内存区域与内存溢出异常&amp;实战第二章结构： Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。参考：https://www.jianshu.com/p/989c90f339b9 2.2 运行时数据区域具体见下图： 2.2.1 程序计数器（Program Counter Register） 概述：该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有：因为 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。2.无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法（本地方法，一个调用非Java代码的接口），这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。（个人理解：参考C++理解是：当线程中调用native方法的时候，当前线程应当会被阻塞，重新启动一个新的线程，那么计数器为空则不会影响新线程的计数器，相互独立。当前线程应当会被阻塞，直到另外一个线程执行结束。当然参数也会被保留） 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 我们经常将 Java 内存分为堆内存（Heap）和栈内存（Stack），这种分法中所指的栈就是 Java 虚拟机栈，或者说是虚拟机栈中 局部变量表 部分。 概述：描述 Java 方法执行的内存模型，每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆是所有线程共享的一块内存区域，由虚拟机启动时创建，堆的唯一目的就是存储对象的实例。几乎所有的对象实例都在改内存区域分配，但是随着JIT编译器（即时编译）的发展及逃逸分析技术（分析指针的动态范围）的发展，栈上分配、标量替换导致堆分配不那么“绝对”了。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开。 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 内存：Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。 相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对 常量池的回收 和 类型的卸载。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。Class 文件中除了有类的（版本、字段、方法、接口）等描述信息外，还有一项信息就是常量池。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2.3 HotSpot 虚拟机对象探秘 这一部分内容将以 HotSpot 虚拟机和常用的内存区域 Java 堆为例，阐述对象分配、布局和访问的全过程。 2.3.1 对象的创建 概述：Java 是一门面向对象的编程语言，在 Java 程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个 new 关键字而已，而在虚拟机中对象的创建则分为以下几个步骤。 虚拟机遇到New指令 首先检查指令的参数能否在常量池中定位到一个类的符号引用 检查这个符号引用对应的类是否已被加载、解析、初始化过 没有加载，则需要先加载 为新生对象分配内存区域（指针碰撞&amp;空闲列表） 线程安全（方案1：对分配内存空间的动作同步；方案2：本地线程分配缓冲 TLAB） 对对象进行必要的设置 调用init方法 类加载概述：虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存概述：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。 分配方式：1.指针碰撞（Bump the Pointer）：假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。2.空闲列表（Free List）：如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。 同步控制概述：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。 方案一：对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。 初始化概述：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。作用：保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。 对象头（Object Header）概述：接下来，虚拟机要为对象头数据进行设置。（e.g. 对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄） init概述：在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，&lt;init&gt; 方法还没有被执行，所有的字段还为零值。 一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，将对象按照我们的意愿进行初始化，这样一个真正的对象才算完全产生。 2.3.2对象的内存布局 在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域。 对象头（存放对象自身的运行时数据&amp;类型指针） 实例数据 对齐填充 2.3.2.1 对象头（Header） HotSpot 虚拟机的对象头包括两部分信息，存储自身的运行时数据的（Mark Word） 和 类型指针。 第一部分：Mark Word 概述：用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。 内存：对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 HotSpot 虚拟机对象头 Mark Word 表如下 第二部分：类型指针 概述：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 Reminder并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。(见2.2.3节) 数组对象：如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。 2.3.2.2 实例数据（Instance Data） 概述：这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 存储顺序：这部分的存储顺序会受到虚拟机 分配策略参数（FieldsAllocationStyle） 和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles =&gt; ints =&gt; shorts/chars =&gt; bytes/booleans =&gt; oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 2.3.2.3 对齐填充（Padding） 概述：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 原理：由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 2.3.3 对象的访问定位 概述：建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以 对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有两种。 句柄访问：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。 直接指针：Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示。 比较：1.句柄访问：使用句柄访问的最大好处就是 reference 中存储的是 稳定的 句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。2.指针访问：使用直接访问最大的好处就是 速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 Sun HotSpot 使用的是第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 2.4 实战：OutOfMemoryError 异常 在 Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemory（OOM）异常的可能。 目的：1. 通过代码验证 Java 虚拟机规范中描述的各个运行时区域的存储内容。2. 遇到实际的内存溢出异常时，能根据异常的信息快速判断哪个区域的内存溢出。3. 了解什么样的代码可能会导致这些区域内存溢出，并了解如何处理。 VM Args 设置 Eclipse IDE：Debug Configurations =&gt; Java Application =&gt; YoungGenGC =&gt; Arguments 中的 VM arguments 中进行书写（书写参数以 - 开头，以空格分隔）。 控制台：直接跟在 Java 命令之后书写。 本人运行在 Mac 系统下，使用 IDEA 进行配置，步骤如下所示👇。 1\. 打开 Run Configurations（⌃ + ⌥ + R 选择 0 ）或者（⌘ + ⇧ + A 输入 run 选择 run…）。 2\. 点击并打开 VM options。 3\. 写入虚拟机启动参数。 4.Apply 并 Run。 2.4.1 - Java 堆溢出 概述：Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 测试环境： 12345-verbose:gc-Xms20M // 最小 GC 启动-Xmx20M // 最大 GC 启动-XX:+PrintGCDetails // 打印设置-XX:SurvivorRatio=8 // 存活对象比率 测试代码：HeapOOM 123456789101112131415import java.util.*;public class Main &#123; private static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 运行结果： 1java.lang.OutOfMemoryError: Java heap space 分析：Java 堆内存的 OOM 异常是时机应用中常见的内存溢出异常情况。当出现 Java 堆内存溢出时，异常堆栈信息 java.lang.OutOfMemoryError 会跟着进一步提示 Java heap space。 解决方式 堆转储快照：要解决这个区域的异常，一般的手段是先通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。 内存泄露：进一步通过工具查看泄露对象到 CG Roots 的引用链，于是就能找到内存泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄露代码的位置。 内存溢出：如果不存在泄露，换句话说，就是内存中的对象确实都必须还活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对象看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗。 2.4.2 - 虚拟机栈和本地方法栈溢出 概述：由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoos 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 -Xss 参数设定。关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常。 异常类型 发生条件 StackOverflowError 线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。 OutOfMemoryError 无法申请到足够的内存时抛出该异常。 这里把异常分为两种情况，看似更加严谨，但却存在一些相互重叠的地方：方栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事的两种描述而已。 2.4.2.1 - StackOverflowError 测试环境：在此测试中，将测试范围限制于单线程中操作。1. 使用 -Xss 参数减少栈内存容量，结果抛出 SOF 异常，异常出现时输出的堆栈深度相应缩小。2. 定义了大量的本地变量，增大此方法栈中本地变量表长度。结果抛出 SOF 异常时输出的堆栈深度相应缩小。 JavaVMStackSOF: 1234567891011121314151617181920212223242526//JavaVMStackSOF//VM Args: -Xss160k // 栈内存容量public class Main &#123; public static class JavaVMStackSOF&#123; private int stackLength = 1; public void stackLeak() &#123; stackLength++; stackLeak(); &#125; &#125; public static void main(String[] args) throws Throwable &#123; JavaVMStackSOF oom = new JavaVMStackSOF(); try &#123; oom.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println("Stack length: " + oom.stackLength); throw e; &#125; &#125;&#125; 运行结果 123Exception in thread &quot;main&quot; Stack length: 771java.lang.StackOverflowError at Main$JavaVMStackSOF.stackLeak(Main.java:8) 分析：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者确切地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 理解：操作系统分配给每个进程的内存是有限的，虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存 -Xms（最大堆容量） -MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略不计。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈瓜分了。每个线程分配到的栈容量越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。 探索：出现 SOF 异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的）达到 1000 - 2000 完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果建立过多线程导致内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过 减少最大堆 和 减少栈容量 来换更多的线程。 2.4.2.2 - OutOfMemoryError 测试环境注意：下面这块代码运行有风险，书上说在windows上会造成系统假死，我在mac上的IDEA上运行，也死机了，测了两次，都导致了系统假死。 JavaVMStackOOM 12345678910111213141516171819202122232425262728293031323334public class Main &#123; //VM Args: -Xss2M // 栈内存容量 //测试代码：创建线程导致内存溢出异常 private void dontStop() &#123; while (true) &#123; &#125; &#125; // 循环开启线程 public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; Main oom = new Main(); oom.stackLeakByThread(); &#125;&#125; 运行结果（参考别人的结果） 1Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread 这是mac死机时用手机照的(；′⌒`)cpu已爆表 2.4.3 - 方法区和运行时常量池溢出 概述：由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。 脑补：String.intern() 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。在 JDK1.6 以及之前的版本中，由于常量池分配在永久代内，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小名，从而间接限制其中常量池的容量。 2.4.3.1 - OutOfMemoryError 测试环境 12-XX:PermSize=10M // 方法区最小值-XX:MaxPermSize=10M // 方法区最大值 测试代码RuntimeConstantPoolOOM 12345678910111213package com.company.bupt;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); long i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 在JDK1.6上运行结果如下： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at com.company.bupt.Main.main(Main.java:10) 分析：从运行结果中可以看到，运行时常量池溢出，在 OutOfMemoryError 后面跟随的提示信息是 PermGen space，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分。 在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为JVM实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。 在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。 在JDK8之前的HotSpot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域。永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过‑XX:MaxPermSize 设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误(OOM)。 参考：Java永久代去哪儿了 http://www.infoq.com/cn/articles/Java-PERMGEN-Removed 总结：java jdk1.7中的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域，如果想了解更多可以参考：http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.htmlhttp://blog.csdn.net/zhyhang/article/details/17246223/ 在JDK1.7上测试 模拟了一下常量池的oom，突然发现设置的参数-XX:PermSize=10M -XX:MaxPermSize=10M不管用了，同时发现内存一直在上升，当上升到一个极值就会趋于平稳，然后再过一段时间会报：Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded这个异常是当GC的时间超过总运行时间的98%才会报的，是为了防止GC占用的时间过长。 运行结果 2.4.3.2 - String 常量池测试 使用 JDK1.7 运行这段程序就不会得到相同的结果，while 循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响。 测试代码RuntimeConstantPoolOOM1 12345678910111213package com.company.bupt;public class Main &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); &#125;&#125; 分析： JDK1.6：会得到两个 false，而在 JDK1.7 中运行，会得到一个 true 和一个 false。产生差异的原因是：是 JDK1.6 中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由 StringBuilder 创建的字符串实例在 Java 堆上，所以必然不是同一个引用，将返回 false JDK1.7：intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此 intern() 返回的引用和由 StringBuilder 创建的那个字符串实例是同一个。对 str2 比较返回 false 是因为 java 这个字符串在执行 StringBuilder.toString() 之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而 计算机软件 这个字符串是首次出现的，因此返回 true。 JVM启动的时候已经写到常量池里了，类似的还有’main’、’int’、’float’。参考：https://www.jianshu.com/p/b98851899f37 JDK1.7上测试结果: 12345678String str1 = new StringBuilder("jc").append( "vc" ).toString();//JVM不会自动加载jcvc，所以这个jcvc是首次出现的，返回true System.out.println(str1.intern()==str1); String str2=new StringBuilder("mai").append( "n" ).toString(); //main已经被自动加载了，不是首次出现，所以返回false System.out.println(str2.intern()==str2); String str3=new StringBuilder("in").append( "t" ).toString(); //flase System.out.println(str3.intern()==str3); String str4=new StringBuilder("flo").append( "at" ).toString(); //flase System.out.println(str4.intern()==str4); JDK1.6上测试上述代码则全返回是false 2.4.3.3 - 方法区溢出 方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本思路就是运行时产生大量的类去填满方法区，直到溢出。另外的，直接使用 Java SE API 也可以动态产生类（如反射时的 GeneratedConstorAccessor 和动态代理等）。 但在本次试验使用CGLIB直接操作字节码运行时，生成大量的动态类。 值得注意的是，当前主流的很多框架 如：Spring,Hibernate对类进行增强时，都会使用到类似CGLIB这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载如内存。 注意：项目必须引入asm-6.0.jar和cglib-3.2.6.jar，需要手动寻找引入 测试代码JavaMethodAreaOOM： 1234567891011121314151617181920212223242526272829303132333435package com.company.bupt;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 测试方法区内存溢出 * 方法区保存的是Class的相关信息，如类名，字段描述符等等，在这里使用cglib来创建大量的类信息来使方法区内存溢出 * * 异常信息为：java.lang.OutOfMemoryError: PermGen space * VM args:-XX:PermSize=10m -XX:MaxPermSize=10m * @author Tim * */public class Main &#123; public static void main(String[] args) &#123; while(true)&#123; Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125; static class OOMObject&#123; &#125;&#125; 以下是我的实测情况： 下列是在JDK1.6上测试得到的： 下列是在JDK1.7上测试得到的： 2.4.3.4 - 总结 方法区溢出是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量的 Class 的应用中，需要特别注意类的回收情况。这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 2.4.4 - 本机直接内存溢出 概述：DirectMemory 容量可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（-Xmx指定）一样，下面的测试代码越过了 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）。因为，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 unfase.allocateMemory()。 测试代码DirectMemoryOOM 12345678910111213141516171819202122package com.company.bupt;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M * @author zzm */public class Main &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 运行结果参考： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryErrorat sun.misc.Unsafe.allocateMemory(Native Method)at org.fenixsoft.oom.DMOOM.main(DMOOM.java:20) 以下是JDK1.6上实测：程序并没有报错 分析：由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看到明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，那就可以考虑检查一下是不是这方面的原因。 参考:https://www.jianshu.com/p/989c90f339b9]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记一：（实战）自己编译JDK]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-06%2F</url>
    <content type="text"><![CDATA[全书核心分布： 第一章 走近JAVA1.6 实战：自己编译JDK(已成功编译) 疑问： 将JDK源码进行编译是做了点什么？是将JDK中的.java文件编译成.class文件吗？ JDK中包含开发工具包和JVM，作者编译完JDK以后，用的还是原来包中的JVM吗？ 我们平常使用的JDK，例如JDK1.7中，里面的文件是以.java形式存在的还是以.class形式存在的，或者是以.java形式存在，要用的时候再用JVM去编译的?答： JDK是c/c++写的, 编译就是把JDK编译成可以运行的状态, 可运行的意思是指可以编译运行.java文件. 而一般情况下官方下载的JDK都是已经帮你编译好而已. 作者可以用自己编译的, 也可以用官方编译好的. 这个要看书中的说明了 JDK是c/c++写的, 里面和其他c++程序没什么区别, windows下面是一堆dll和一堆exe. 你说的.java文件是JDK的功能之一, 帮你编译java文件成class, JVM是运行class文件的容器 一 环境： 操作系统：CentOS6.8计划编译的jdk: openjdk7现成的jdk: java version “1.6.0_25”(Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode))jdk6下载链接如果你当前的系统版本不是这个，没关系，只要下载上述版本安装rpm（默认安装到/usr/java路径下）(不必配置环境变量)即可 二 编译前准备工作如下123456yum install -y mercurialyum install -y ant ant-nodepsyum install -y libX11* libX*yum install -y libXi-devel libXtst-devel libXt-devel freetype* yum install -y alsa-lib-devel cups-develyum install -y gcc gcc-c++ 三 下载计划编译的openjdk7(jdk源码网站：http://hg.openjdk.java.net/jdk7u/ ， 你值得收藏) 1234hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-devcd jdk7u-devchmod 755 get_source.sh ./get_source.sh 四 编译4.1准备好编译环境相关参数解释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export LANG=C#Bootstrap JDK的安装路径，必须设置export ALT_BOOTDIR=/export/servers/jdk1.6.0_25/#允许自动下载依赖export ALLOW_DOWNLOADS=true#并行编译的线数，设置和cpu的数量一致即可export HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2#比较本次build出来的映像与先前版本的差异，这对我们来说没有意义，export SKIP_COMPARE_IMAGES=true#使用预编译头文件，不加这个编译会更慢一些export USE_PRECOMPILED_HEADER=true#指定要编译的内容export BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=falseexport BUILD_JAXWS=falseexport BUILD_CORBA=false#要编译的版本#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueexport DEBUG_NAME=debug#可以避开javaws和浏览器Java插件之类的部分buildBUILD_DEPLOY=false#设置成false就不会build出包装包，因为包装包里有些奇怪的依赖#但是即使不build出它也已经能得到完整的JDK映像，所以还是别build它好了BUILD_INSTALL=false#编译结果存放的路径export ALT_OUTPUTDIR=/root/temp/jdk7u WARNINGS_ARE_ERRORS=#卸载环境变量，避免诡异的事情发生unset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS#make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 好了，我们将上面一系列的环境变量，创建环境文件VAR来统一管理吧vi VAR 12345678910111213141516171819202122232425262728293031323334353637383940export LANG=Cexport ALT_BOOTDIR=/usr/java/jdk1.6.0_25export ALLOW_DOWNLOADS=trueexport HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2export SKIP_COMPARE_IMAGES=trueexport USE_PRECOMPILED_HEADER=trueexport BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=trueexport BUILD_JAXWS=trueexport BUILD_CORBA=true#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueBUILD_DEPLOY=falseBUILD_INSTALL=falseexport ALT_OUTPUTDIR=/home/cloudpai/app/jdk7u #export CORBA_DIST=$ALT_OUTPUTDIR/corba/dist#export JAXP_DIST=$ALT_OUTPUTDIR/jaxp/dist#export JAXWS_DIST=$ALT_OUTPUTDIR/jaxws/distunset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS 使之生效. VAR 4.2检测设置是否全部正确make sanity当看到如下输出时则表示成功 123456789101112131415161718192021Build Machine Information: build machine = workstation.centos.vbirdBuild Directory Structure: CWD = /root/temp/jdk7u-dev TOPDIR = . LANGTOOLS_TOPDIR = ./langtools JAXP_TOPDIR = ./jaxp JAXWS_TOPDIR = ./jaxws CORBA_TOPDIR = ./corba HOTSPOT_TOPDIR = ./hotspot JDK_TOPDIR = ./jdk ……Sanity check passed. 4.3真正开始编译make (命令等同于make all) 成功的标志 12345678910111213#-- Build times ----------Target all_product_buildStart 2018-03-06 21:03:26End 2018-03-06 21:20:0900:02:02 corba00:05:08 hotspot00:00:16 jaxp00:00:19 jaxws00:08:34 jdk00:00:23 langtools00:16:43 TOTAL-------------------------make[1]: Leaving directory `/home/cloudpai/Downloads/jdk7u-dev' 4.4测试自己编译出来的jdk吧正确编译后，可以执行如下命令验证 1234[cloudpai@hadoop000 bin]$ /home/cloudpai/app/jdk7u/j2sdk-image/bin/java -versionopenjdk version "1.7.0-internal"OpenJDK Runtime Environment (build 1.7.0-internal-cloudpai_2018_03_06_21_03-b00)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) OK，到些就大功告成了。 五 可能出现的错误/usr/bin/ld: cannot find -lX11 collect2: ld returned 1 exit status解决办法yum install -y libX11* /bin/sh: line 0: cd: /NOT-SET/re/jdk/1.7.0/promoted/latest/binaries/linux-amd64: No such file or directory make[4]: *** [/root/temp/jdk7u/tmp/java/components_imported] Error 1解决办法VAR文件确认执行过了，正确的姿势. VAR 参考博客：http://blog.csdn.net/hl_java/article/details/76691321 由1.6.4得我们得到了自己的虚拟机1.7.0-internal-cloudpai_2018_03_06_21_03-b00 现在我们要将JVM运行起来： 在大多数时候，如果我们并不关心JDK中HotSpot虚拟机以外的内容，只想单独编译 HotSpot虚拟机的话（例如调试虚拟机时，每次改动程序都执行整个OpenJDK的Makefile，速 度肯定受不了），那么使用hotspot/make目录下的Makefile进行替换即可，其他参数设置与前 面是一致的，这时候虚拟机的输出结果存放在build/hotspot/outputdir/bsd_amd64_compiler2目录(在不同机器上，最后一个目录名称会有所差别，bsd表示Mac OS系统（内核为 FreeBSD），amd64表示是64位JDK（32位是x86），compiler2表示是Server VM（Client VM表 示是compiler1）。) 中，进入后可以见到以下几个目录。 在路径：/home/cloudpai/app/jdk7u/hotspot/outputdir/linux_amd64_compiler2 12345678910[cloudpai@hadoop000 linux_amd64_compiler2]$ lltotal 48drwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 debugdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 fastdebugdrwxrwxr-x. 7 cloudpai cloudpai 4096 Mar 6 21:06 generateddrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 jvmgdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 optimizeddrwxrwxr-x. 3 cloudpai cloudpai 20480 Mar 6 21:11 productdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 profiled-rw-rw-r--. 1 cloudpai cloudpai 1778 Mar 6 21:06 shared_dirs.lst 这些目录对应了不同的优化级别，优化级别越高，性能自然就越好，但是输出代码与源 码的差距就越大，难于调试，具体哪个目录有内容，取决于make命令后面的参数。 在编译结束之后、运行虚拟机之前，还要手工编辑目录下的env.sh文件，这个文件由编 译脚本自动产生，用于设置虚拟机的环境变量，里面已经发布了“JAVA_HOME、 CLASSPATH、HOTSPOT_BUILD_USER”3个环境变量， 还要在在product下边（看网上都是在jvmg下边，可我的jvmg下边没有gamma，不知道什么情况）的env.sh下加入： 123456export JAVA_HOME=/usr/java/jdk1.6.0_25export PATH=$JAVA_HOME/bin:$PATHLD_LIBRARY_PATH=.:$&#123;JAVA_HOME&#125;/jre/lib/amd64/native_threads:$&#123;JAVA_HOME&#125;/jre/lib/amd64:export LD_LIBRARY_PATH 然后执行以下命令启动虚拟机（这时的启动器名为gamma），输出版本号。 12source ./env.sh ./gamma -version 最后运行虚拟机成功！！ 12345[cloudpai@hadoop000 product]$ ./gamma -versionUsing java runtime at: /usr/java/jdk1.6.0_25/jrejava version &quot;1.6.0_25&quot;Java(TM) SE Runtime Environment (build 1.6.0_25-b06)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) 1.6.5 JVM 在IDE工具中进行源码调试注意这里是源码调试，是对1.6.4中计划编译的jdk源码进行操作: openjdk7（centos上的存储路径是/home/cloudpai/Downloads/jdk7u-dev） centos下安装NetBeans集成开发环境 官网下载地址：http://download.netbeans.org/netbeans/7.0.1/final/bundles/netbeans-7.0.1-ml-cpp-linux.sh 以netbeans-7.0.1-ml-cpp-linux.sh为例 首先，到NetBeans网站（http://netbeans.org/）上下载最新版的NetBeans（网上说7.0.1版本没问题，我就直接用这个版本了），下载时选择支持 C/C++开发的那个版本。 注意：不要在本地远程用SecureCRT输入命令啊，要在Linux下用终端输入命令： 1sh netbeans-7.0.1-ml-cpp-linux.sh 这样就会在centos中弹出安装界面： 配置好安装路径和IDE使用的java环境（注意与编译时的环境一致） 安装好以后，桌面上就有了NetBeans： 后续操作可以参考这个博客：使用Netbeans开发调试OpenJDK中的HotSpothttp://blog.csdn.net/pange1991/article/details/51580969 CentOS下安装NetBeans集成开发环境http://www.itboth.com/d/QriYZj/centos-java-windows-linux-netbeans]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java1.8 帮助文档]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05-1%2F</url>
    <content type="text"><![CDATA[java 1.6 帮助文档中文链接：http://download.csdn.net/detail/qw599186875/9608735英文Java1.8 帮助文档英文中文 – 谷歌版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-google/下载链接：http://download.csdn.net/detail/qw599186875/9802192]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站架构技能图谱（Java版）]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05%2F</url>
    <content type="text"><![CDATA[每天都要有进步！]]></content>
      <tags>
        <tag>java</tag>
        <tag>图谱</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[workflow工作流]]></title>
    <url>%2F2018%2F03%2F04%2F2018-03-04%2F</url>
    <content type="text"><![CDATA[工作流脚本测试：测试成功~晚安~~]]></content>
      <tags>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scratch编程探究]]></title>
    <url>%2F2018%2F03%2F02%2F2018-03-02%2F</url>
    <content type="text"><![CDATA[转载自：儿童使用Scratch编程时，与程序员在工作中的编程有什么区别？ - Milo Yip的回答 - 知乎https://www.zhihu.com/question/42012520/answer/310430799]]></content>
      <tags>
        <tag>scratch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018拜年祭单品]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01-1%2F</url>
    <content type="text"><![CDATA[2018拜年祭单品传送门： 1.【逆浪千秋】av20204904 2.【如果我的一生只需要做一件事 — Bilibili Zeitgeist 2017】av20203478 3.【梦想小剧场-遗失的宝物】av20203610 4.【口袋竞技场ー冰与铁之歌】av20203938 5.【相遇day by day】av20203945 6.【上海一夜】av20204014 7.【神鬼恋曲】av20204051 8.【UP主的奇妙冒险之勇者传说】av20204517 9.【我的破烂之掀起波澜】av20204332 10.【palette】av20204403 11.【广告高手】av20204701 12.【滑稽君大冒险】av20204534 13.【journey】av20204614 14.【全靠我勤劳的手】av20204705 15.【演奏区的偷心计划】av20204824 16.【乒乓帝国】av20205319 17.【鬼畜大战之真相黎明】av20205316 18.【如何翻拍一个CG短片】av20205314 19.【坦克大战】av20205375 20.【星空花火】av20203411 彩蛋【举头三尺有神明】av16201808]]></content>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blogs 上的标签tag参数]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01%2F</url>
    <content type="text"><![CDATA[12345678910---title: Mac终端翻墙tags: Linux&amp;Unixcategories: Linux&amp;Unixcomments: trueabbrlink: 745a6d7date: 2016-11-24 18:26:33updated: 2016-11-24 18:26:33copyright: true---]]></content>
      <tags>
        <tag>mac</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要进行的改进]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[TODO： 测试git的备份功能 学习 Alfred workflow实现打开重启任意应用 脚本实现清理浏览器缓存]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac使用]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28%2F</url>
    <content type="text"><![CDATA[Mac系统如何显示隐藏文件？以”.”开头的隐藏文件如何在MAC系统下显示？ 答：Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 显示 隐藏文件 1234567#显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool trueosascript -e 'tell application "Finder" to quit'#不显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool falseosascript -e 'tell application "Finder" to quit']]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog通过git备份与恢复的最优操作]]></title>
    <url>%2F2018%2F02%2F28%2Fblog%E9%80%9A%E8%BF%87git%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%9A%84%E6%9C%80%E4%BC%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引言：Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。特别简洁。 关于搭建的流程 创建仓库，http://CrazyMilk.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库； 在本地http://CrazyMilk.github.io 仓库新建一个文件后，进入文件中。在该文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 关于日常的改动流程 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的http://CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 其实只要把hexo和需要每个插件都写入到package.json中（平常安装时加–save参数会自动写入），那么git clone下来之后，只要一句npm install就能装好hexo和所有的依赖，开箱即用 ^_^ 迁移源码库一开始用了该方法，后来意识到备份到github分支的博客源码也是public的，后来改为备份到开源中国git私有库了 参考1：GitHub Pages + Hexo搭建博客参考2：使用hexo，如果换了电脑怎么更新博客？ - CrazyMilk的回答 - 知乎]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28-1%2F</url>
    <content type="text"><![CDATA[创建的仓库：默认master克隆的仓库：默认origin（源） git add 开始跟踪一个新文件git status显示git状态 git commit提交更新 git diff：比较工作区和缓存区的不同。git diff --cached：比较缓存区和仓库的不同。 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 git push [remote-name] [branch-name] 如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：git push origin master git log显示从最近到最远的提交日志。包含每个提交的SHA1校验和、作者的名字和邮箱、提交时间以及提交说明等。gitk使用图形化工具查阅提交历史 git commit --amend修改最后一次提交 git reset HEAD &lt;file&gt;...取消已经暂存的文件 Git 分支git branch创建一个新的分支 git commit -a -m &#39;made other changes&#39; 提交分支git mergetool调用一个可视化的合并工具并引导你解决所有冲突 git学习链接]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客样式改进杂记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8D%9A%E5%AE%A2%E6%A0%B7%E5%BC%8F%E6%94%B9%E8%BF%9B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[评论区样式修改：文件位置：themes/next/source/css/_common/components/comments.styl 修改内容： 1234.comments &#123; background white; opacity:0.8;&#125; 移动端不加载背景图一点优化，移动端不加载背景图。在_layout.swig底部L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});标签前，加上移动端浏览器内核判断语句，当为PC端浏览器时，加载背景js 123456789101112131415161718192021222324252627&lt;!--移动端判断，是否引入背景--&gt;&lt;script&gt;var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123;//移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase() &#125; if(browser.versions.mobile || browser.versions.ios || browser.versions.android || browser.versions.iPhone || browser.versions.iPad)&#123; &#125;else&#123; document.write("&lt;script type=\'text/javascript\' src=\'/js/src/particle.js\'&gt;&lt;\/script&gt;"); &#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🎵记录点滴生活]]></title>
    <url>%2F2018%2F02%2F24%2F%F0%9F%8E%B5%E8%AE%B0%E5%BD%95%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[记录点滴生活《BINGBIAN病变》歌曲不错，曲调有些忧伤 [00:00.21]罗之豪 - BINGBIAN病变 [00:01.87]词：Cubi/Fi9 [00:02.76]曲：Jurrivh [00:03.72]混音：Fi9 [00:19.36][02:01.33][03:09.30]有天我睡醒看到我的身边没有你 [00:23.52][02:05.53][03:13.50]在我的右边是你曾经喜欢的玩具 [00:27.75][02:09.76][03:17.66]可当我站起身来在房间里寻找你 [00:32.04][02:14.00][03:21.93]留下的只有带着你味道的一封信 [00:36.50][02:18.48][03:26.35]就在昨天还一起看我们的照片 [00:40.47][02:22.48][03:30.46]可现在让我感觉像烂剧里的主演 [00:44.74][02:26.71][03:34.69]为什么这种事情会发生在我身边 [00:48.97][02:31.00][03:38.92]是不是老天没能看到对你的疯癫 [00:54.46]还想着 创造你的宇宙 [00:56.53]但现在 已经被我清空 [00:58.57]你让我 整个人都冰冻 [01:00.68]还怎么 再次为你心动 [01:02.88]Wake me 不是你的意愿 [01:04.97]离开我 开始新的起点 [01:07.12]可能我 还会对你贪恋 [01:09.30]谁让你 曾经让我疯癫 [01:11.18]疯癫 那也是过去的画面 [01:14.54]看往后的几天 [01:16.72]我猜你也不会出现 [01:18.78]我回想这几年 [01:20.93]就像是要命的病变 [01:23.16]你可能听不见 [01:25.16]来自我对你的挂念 [01:27.53]可能有点累 [01:28.85]觉得对不对这是第几次在为你宿醉 [01:31.98]没了我肩膀 [01:33.08]你在谁身旁买的礼物变成了灰 [01:35.99]曾经我多想 [01:37.25]把你变漂亮看着别人羡慕你的模样 [01:40.50]没关系有小熊陪着你看月亮 [01:44.40]我已经看到跟你断电的过程 [01:46.96]但我假装看不见 [01:48.76]是不是要我变得像个厉鬼 [01:50.96]才能进入你的世界 [01:52.95]为什么不说再见 [01:54.31]我猜你应该是不小心的忘记 [01:57.04]都无所谓也有点累 [01:59.09]也可以开始新的记忆 [02:35.19]我不能够停止啊 [02:37.43]这些年我对你的疯癫 [02:39.49]戴上那条围巾吧 [02:41.59]在每个寒风刺骨的冬天 [02:43.92]每次送你回家你抱着我 [02:45.63]不经意间又触碰到你的手 [02:48.10]你穿裙子眨眼睛 望着我 [02:50.52]让我每次心动的瞬间 [02:52.49]那条十字路口 [02:54.39]始终有你身上的气味 [02:57.00]车水马龙过后的路灯下的身影 [03:00.10]又会是谁 [03:00.83]他想说我真的 [03:02.01]喜欢你但是每次欲言又闭嘴 [03:05.57]那时荒唐的男孩 [03:07.64]又浑浊了几岁 var ap = new APlayer({ element: document.getElementById("aplayer1"), narrow: false, autoplay: false, showlrc: 2, music: { title: "BINGBIAN病变", author: "Cubi / Fi9江澈", url: "http://p4lmrb1gp.bkt.clouddn.com/Cubi,Aydo$,BRGang%20-%20BINGBIAN%E7%97%85%E5%8F%98.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/BINGBIAN%E7%97%85%E5%8F%98.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的blog自动发布脚本]]></title>
    <url>%2F2018%2F02%2F23%2Fmac%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[遇到的坑： -bash: ./install.sh: /bin/bash: bad interpreter: Operation not permitted出现这个问题的主要原因是：-rwxrwxrwx@ 文件的属性最后带个@，这个@代表的是更多的一些属性，具体含义不太清楚，但有它就是执行不了解决：可以用这个命令来去除这个属性：xattr -d com.apple.quarantine ./*后来进入目录发现目录下面的文件还是带有@属性，我们到根目录加一个-r就好了：xattr -d -r com.apple.quarantine ./* 我的blog自动发布脚本:blog_publish.sh 123456789#!/bin/bashsay "blogs updating"cd /Users/pailiu/Library/Mobile\ Documents/iCloud~com~coderforart~iOS~MWeb/Documents/mweb_documents_library/Bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo dsay "blogs published"rm -rf /Users/pailiu/Library/Caches/Google/Chrome/Profile\ 1/*open -a "/Applications/Google Chrome.app" 'http://cloudpai.site/'# hexo server]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客插入音频、视频]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为了避免后期外链失效，可以将视频、音频图片等资源传至七牛云等cdn服务器上，从中获取外链。 常用排版：居中： 1&lt;center&gt; &lt;/center&gt; 插入图片：有尺寸要求时： 1&lt;img src="http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg" width="80%" height="80%"&gt; 无尺寸要求时快速插入（md格式）： 1![](http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg) 插入音乐网易云音乐外链获取：见官网修改博客音乐播放器歌曲路径：/Blog/themes/hexo-theme-next-master/layout/_macro/sidebar.swig qq音乐外链获取： http://www.qqmusic.cc/插入音频播放器代码： 1&lt;audio src="http://mp3.qqmusic.cc/yq/211758246.mp3" controls="controls"&gt;&lt;/audio&gt; hexo-tag-aplayer：博客中插入自定义音乐 安装成功后，在 Markdown 文档中添加比如添加如下代码使用hexo-tag-aplayer 参数12345678title ：音乐标题author：音乐作者url：音乐文件网址picture_url：可选，音乐图片网址narrow：可选，窄款式autoplay：可选，自动播放音乐，不支持移动浏览器width:xxx：可选，前缀width:，播放器宽度（默认值：100％）lrc:xxx：可选，前缀lrc:，LRC文件url 示例: 1&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125; [ti:春意红包 (Vocaloid Ver.)] [ar:乐正绫/心华/洛天依] [al:春意红包] [by:] [offset:0] [00:00.29]春意红包 (Vocaloid Ver.) - 乐正绫/心华/洛天依 [00:00.89]词：泠鸢YOUSA [00:01.05]曲：Wing翼 [00:01.18]编曲：Wing翼 [00:01.95]小麦面包饺 喜色上眉梢 [00:05.78]点柳翠 画春晓 [00:08.85] [00:10.08]找旧样铜板穿一串吉兆 [00:14.20]把春意装满红包 [00:17.86] [00:37.11]廊下的小阿妹摇头晃脑 [00:41.25]望着瓦上的碎嘴家雀 [00:44.76] [00:45.56]问它们春日的鸟儿 何时才能到 [00:49.81] [00:50.35]穿街搜巷沿路找 [00:53.26] [00:53.76]看邻家的老人摘下毡帽 [00:57.88]虽是脱去冬衣还尚早 [01:01.89]宰鸡鸭 起炉灶 揭开自家陈酿 [01:07.91]偷偷尝一瓢 [01:09.81] [01:13.01]大鬼叫 小鬼叫 邪祟吓得跌倒 [01:16.73]该用什么清扫 锣鼓鞭炮 [01:20.58] [01:21.30]小孩儿 快来瞧 别再人堆胡闹 [01:24.85] [01:25.43]只有听话乖巧 来年才能长高 [01:29.08] [01:30.21]和纸浆 采朱砂 攒一摞春联叠好 [01:34.25]剪金花 染红料 [01:36.24]再糊一个四方小包 [01:37.98] [01:38.56]对花调 抄童谣 写一串吉祥安好 [01:42.51]扶正了封面 画上春来到 [01:46.14]一片翠色葱葱明快又跳跃 [01:50.13]几瓣海棠山茶花儿相映笑 [01:54.29]再蘸浓墨潦草添只燕子闹 [01:58.48]红绳绕 来封一个大红包 [02:02.83] [02:19.34]找一张晒烫的板凳歇脚 [02:22.80] [02:23.58]看你眼下又布满操劳 [02:27.59]编织橙黄蓝绿把烦恼全部忘掉 [02:32.00] [02:32.65]抬手捧一把红枣 [02:34.70] [02:35.97]骗怕生的小妹点灯睡觉 [02:40.05]会有鬼祟在夜晚来到 [02:43.55] [02:44.13]她慌张 我偷笑 连说不怕不怕 [02:50.16]让我去赶跑 [02:52.62] [02:55.34]左搭肩 右帮腔 [02:57.19]挤兑迟来的大忙人 [02:59.59]礼物未到 人怎能到 [03:03.02] [03:03.62]表嫂吵 大舅闹 连天地喳喳叫 [03:07.03] [03:07.71]我装作听不到 盘坐把碗沿敲 [03:11.35] [03:12.37]踩高跷 抓花包 撩一挂红衣鞭炮 [03:16.52]打年糕 串辣椒 [03:18.59]抹花我的胭脂粉膏 [03:20.67]侃八卦 讲小道 等杯中茶酒减少 [03:24.79]将手上红包 塞进你棉袄 [03:28.05] [03:28.60]你送吉祥如意 幸福快来到 [03:32.57]我送百年顺遂 不怕被火烧 [03:36.57]再求来年生辰 添一分美貌 [03:40.74]拱手摇 同鞠一躬对眼笑 [03:44.55] [03:47.29]小麦面包饺 喜色上眉梢 [03:51.29]点柳翠 画春晓 [03:55.45]找旧样铜板穿一串吉兆 [03:59.58]把春意赠与明朝 [04:03.12] [04:04.16]左搭肩 右帮腔 热闹话不见少 [04:08.24]你来蒸 我来挑 塞满嘴的玉米包 [04:12.41]干柴烧 火焰高 烦心事已寥寥 [04:16.05] [04:16.66]眯眼瞧 把红包塞进你棉袄 [04:20.59]一片翠色葱葱 明快又跳跃 [04:24.66]几瓣海棠山茶 花儿相映笑 [04:28.80]封着吉祥如意 幸福快来到 [04:32.97]红绳绕 拆开春意大红包 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 2, music: { title: "春意红包", author: "三无MarBlue,祖娅纳惜,泠鸢yousa", url: "http://p4lmrb1gp.bkt.clouddn.com/%E4%B8%89%E6%97%A0MarBlue,%E7%A5%96%E5%A8%85%E7%BA%B3%E6%83%9C,%E6%B3%A0%E9%B8%A2yousa%20-%20%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 播放列表123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; "narrow": false, // Optional, narrow style "autoplay": true, // Optional, autoplay song(s), not supported by mobile browsers "mode": "random", // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` "showlrc": 3, // Optional, show lrc, can be 1, 2, 3 "mutex": true, // Optional, pause other players when this player playing "theme": "#e6d0b2", // Optional, theme color, default: #b7daff "preload": "metadata", // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' "listmaxheight": "513px", // Optional, max height of play list "music": [ &#123; "title": "CoCo", "author": "Jeff Williams", "url": "caffeine.mp3", "pic": "caffeine.jpeg", "lrc": "caffeine.txt" &#125;, &#123; "title": "アイロニ", "author": "鹿乃", "url": "irony.mp3", "pic": "irony.jpg" &#125; ]&#125;&#123;% endaplayerlist %&#125; 插入视频：video 标签： 123&lt;video src="http://lxqncdn.miaopai.com/stream/BvmaXK2X49guVi4ehlOjjQ__.mp4" width="100%" height="100%" controls="controls"&gt;Your browser does not support the video tag.&lt;/video&gt; embed标签： 1&lt;embed src="http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA==/v.swf" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" allowFullScreen="true" mode="transparent" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; iframe标签： 1&lt;iframe height=498 width=510 src="http://player.youku.com/embed/XMTY1MTI3NjMyNA==" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
