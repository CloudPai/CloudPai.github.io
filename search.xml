<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式计算平台 之 实时/离线平台]]></title>
    <url>%2F2018%2F04%2F24%2F2018-04-24%2F</url>
    <content type="text"><![CDATA[离线计算MapReduce Google 的三篇论文开启了大数据处理的篇章，其中 MapReduce 被各大公司作为数据处理的主要方案。MapReduce 的思想也是从早期的函数式编程语言中借鉴而来，推广到了分布式系统中，接触的东西多了，发现原来很多知识都是相通的。 传统的数据处理方式通常是将数据导入至专门的数据分析工具中，这样会面临两个问题：1、如果源数据非常大时，往往数据的移动就要花费较长时间。2、传统的数据处理工具往往是单机模型，面对海量数据时，数据处理的时间也是一个很大的问题。 MapReduce 是离线批量计算的代表，采用移动计算优于移动数据的理念，计算任务通常直接在 HDFS 的 datanode 上运行，这样避免了数据的移动（当然 reduce 阶段还是需要节点间传输数据），并且采用并行计算的方式，大大减少了数据处理时间。 如图所示，MR 模型将数据切分成大小相同的数据块，分别在对应的数据节点上启动 map 任务，map 任务并行读取 HDFS 上的数据，根据 reduce 任务的个数将结果写入不同的临时文件中，map 任务计算完毕之后，reduce 任务从 map 节点处拉取自己负责处理的数据，并输出最终结果。 wordcount 例子： 拿 wordcount 例子举例，map 任务读取自身负责的数据，统计词频后，中间结果发送到对应的 reduce 节点，reduce 节点负责统计最终的词频结果。 MR 结合 HDFS 通过并行计算的方式，很大程度上解决了我们对数据存储、计算的需求，但是大家并不满足于现状，慢慢大家发现了 MR 依然存在一些问题。 1.API 较单一，对复杂的迭代计算并不友好 下面我们来看一个解方程的例子： 如图，上过初中的人一眼都能看出 X=1，但是计算机不会因式分解呀，那如何利用计算机思想来求解方程呢？ 首先，我们需要将方程转换（图中红色部分），将其看成一个级数，并且保证该级数收敛。 然后，在该级数收敛区间假设一个初始值，这里我们选取了 X=1.5，代入方程右端，求出新的 X 值。 最后，将新的 X 值不断的进行迭代，当第 K+1 次和第 K 次的结果的差值小于我们预先定义好的阈值时，我们可以认为此时的 X 值已经无限接近于真实值，计算结束。 对计算机解决数学计算感兴趣的同学可以复习一下线性代数和数值分析 这里我们可以看到，计算机求解方程需要多次迭代，如果用 MR 实现，每一次迭代都要启动一次 MR 任务，这仅仅还只是一个最简单的例子，当面对数据挖掘这类涉及到比较复杂的组合计算时，采用 MR 效率就显得比较低下了。 2.MR 任务不能有效的利用内存 map 任务在处理数据后，会根据 reduce 的个数，生成对应个数中间文件，这些文件保存在磁盘上，map 计算完成后 reduce 将文件 fetch 过来进行汇总。也就是说如果采用 MR，无论输入源数据有多少，哪怕内存放得下，中间结果还是需要落盘，而我们知道 io 是计算机中最耗时的操作，这也是造成 MR 效率较低的一个原因。 从上面的介绍可以看出 MR 存在两个缺点： 1. 无论源数据有多少，shuffle 过程的中间数据都需要落盘，效率较低，不能很好的利用内存。 2.MapReduce 只提供了 map 和 reduce 函数，api 不够友好，编写代码时，首先都需要将计算思想转化成 MapReduce 模型，非常反人类（写过 MR 的应该非常有感触），而且稍微复杂点的计算需要多次迭代（尤其现在都在提人工智能，深度学习，这些都是比较复杂的逻辑计算），迭代启动任务也有较大的开销。 Spark Spark 对这两点进行了优化，Spark 也是一个批量计算框架，我们来看一下 Spark 的 job 逻辑图： Spark 的将数据抽象成 RDD，RDD：弹性分布式数据集（Resilient Distributed Datasets），这是一种分布式的内存抽象，允许在大型集群上执行基于内存的计算，与此同时还保持了 MapReduce 等数据流模型的容错特性。RDD 可以常驻的内存的属性，大大简化了迭代计算所需的开销，Spark 任务可以立马利用上一次计算出来的 RDD 来进行下次迭代。 Spark 不仅仅提供 Map 和 Reduce 函数，还提供了额外的 api，比如 join，图中我们看到数据源 data1 和 data2 在中间处进行了 join，丰富的 api 大大简化了编码逻辑，开发更高效（更详细 api 的可以在 Spark 官网了解）。 RDD 优化： 需要注意的是内存不够用时 RDD 也可以采用磁盘作为其第二存储介质，而且如果计算中包含 shuffle 过程为了保证容灾，shuffle 处的 RDD 也是需要落盘的。 Shuffle描述着数据从map task输出到reduce task输入的这段过程。在分布式情况下，reduce task需要跨节点去拉取其它节点上的map task结果。这一过程将会产生网络资源消耗和内存，磁盘IO的消耗。 上图中我们可以看到任务被划分为 3 个 stage，这里简单解释一下 stage 的意义，如果采用 MR 的运行方式，每个 partition 都启动一个 task，stage1 应该启动 6 个 task，因为 RDD 需要存放在内存（内存不够时放磁盘），这样来看开销还是很大的，而且上下游 task 的 RDD 传输也会占用不小的开销。 Spark 为了提高效率，采取了如下优化：当下游的 RDD 和上游的 RDD 是 NarrowDependency 时（也就是上游 partition 和下游 partition 是 1 对 1，或 n 对 1 的关系，不涉及 shuffle 逻辑，比如 map，flatmap 等操作），将这些 RDD 放在一个 task 里面执行，大大减少了计算时所需的内存开销，也减少了网络传输的数据量，详细可以参考。（很多计算框架都有采用这种优化，比如 Flink） 总结一下 Spark 的优点： 1. 它不止提供了 map 和 reduce 逻辑，还提供了额外的 api，更好的支持了复杂的迭代计算，如：groupby、join 等函数。 2. 更好的利用内存：内存够用的情况下，数据直接在内存进行处理，减少数据落盘次数，提高计算效率。 这时候问题来了：那既然 Spark 这么好，是不是 Spark 可以完全取代 MR 了？ 答：也没有那么绝对，任何东西都有它存在的理由，都有它发光发热的地方，比如当数据量非常大，Spark 内存放不下的时候，数据也是需要落盘的。对海数据简单清洗，排序时，Spark 的性能并不一定就比 MR 好，所以还需要看具体的业务。 而且前两年大家都在说 Spark 将会取代 Hadoop，与其说是取代 Hadoop，倒不如说 Spark 有可能取代 MapReduce，因为 Spark 自身是没有存储功能的，数据源往往依赖 HDFS 存储。 MR 和 Spark 采用批量的方式解决离线计算业务，那想象一下另一些场景：在金融业务中，我们希望能够马上检测到有问题的账单，或者我们希望实时得到系统状态的统计信息，若采用批量框架，很难及时的得到反馈结果，这时就需要实时计算。 实时计算上篇文章大致介绍了离线计算 MapReduce 和 Spark，但是无法满足对实时性要求较高的业务，下面我们来了解一下实时计算。 离线和批量、实时和流式 在聊实时计算之前，先说一下我对离线和批量、实时和流式的一些看法。 我们首先来简单看一下计算任务的大致流程： 首先说下批量计算和流式计算： 图中显示了一个计算的基本流程，receiver 处负责从数据源接收数据，并发送给下游的 task，数据由 task 处理后由 sink 端输出。 以图为例，批量和流式处理数据粒度不一样，批量每次处理一定大小的数据块（输入一般采用文件系统），一个 task 处理完一个数据块之后，才将处理好的中间数据发送给下游。流式计算则是以 record 为单位，task 在处理完一条记录之后，立马发送给下游。 假如我们是对一些固定大小的数据做统计，那么采用批量和流式效果基本相同，但是流式有一个好处就是可以实时得到计算中的结果，这对某些应用很有帮助，比如每 1 分钟统计一下请求 server 的 request 次数。 那问题来了，既然流式系统也可以做批量系统的事情，而且还提供了更多的功能，那为什么还需要批量系统呢？因为早期的流式系统并不成熟，存在如下问题： 1. 流式系统的吞吐不如批量系统 2. 流式系统无法提供精准的计算 后面的介绍 Storm、Spark streaming、Flink 主要根据这两点来进行介绍。 批量和流式的区别： 1. 数据处理单位： 批量计算按数据块来处理数据，每一个 task 接收一定大小的数据块，比如 MR，map 任务在处理完一个完整的数据块后（比如 128M），然后将中间数据发送给 reduce 任务。 流式计算的上游算子处理完一条数据后，会立马发送给下游算子，所以一条数据从进入流式系统到输出结果的时间间隔较短（当然有的流式系统为了保证吞吐，也会对数据做 buffer）。 这样的结果就是：批量计算往往得等任务全部跑完之后才能得到结果，而流式计算则可以实时获取最新的计算结果。 2. 数据源： 批量计算通常处理的是有限数据（bound data），数据源一般采用文件系统，而流式计算通常处理无限数据（unbound data），一般采用消息队列作为数据源。 3. 任务类型： 批量计算中的每个任务都是短任务，任务在处理完其负责的数据后关闭，而流式计算往往是长任务，每个 work 一直运行，持续接受数据源传过来的数据。 离线 = 批量？实时 = 流式？习惯上我们认为离线和批量等价；实时和流式等价，但其实这种观点并不完全正确。 假设一种情况：当我们拥有一个非常强大的硬件系统，可以毫秒级的处理 Gb 级别的数据，那么批量计算也可以毫秒级得到统计结果（当然这种情况非常极端，目前不可能），那我们还能说它是离线计算吗？ 所以说离线和实时应该指的是：数据处理的延迟；批量和流式指的是：数据处理的方式。两者并没有必然的关系。事实上 Spark streaming 就是采用小批量（batch）的方式来实现实时计算。 可以参考下面链接：https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101。作者是 Google 实时计算的负责人，里面阐述了他对批量和实时的理解，并且作者认为批量计算只是流式计算的子集，一个设计良好的流式系统完全可以替代批量系统。本人也从中受到了很多启发。 介绍完这些概念后，下面我们就来简单看看目前流行的实时计算框架的实现和区别。 Storm Storm 做为最早的一个实时计算框架，早期应用于各大互联网公司，这里我们依然使用 work count 举例： spout：负责从数据源接收数据 bolt：负责数据处理，最下游的 bolt 负责数据输出 spout 不断从数据源接收数据，然后按一定规则发送给下游的 bolt 进行计算，最下游的 bolt 将最终结果输出到外部系统中（这里假设输出到 DB），这样我们在 DB 中就可以看到最新的数据统计结果。Storm 每一层的算子都可以配置多个，这样保证的水平扩展性。因为往往处理的是 unbound data，所以 storm 中的算子都是长任务。 容灾容灾是所有系统都需要考虑的一个问题，考虑一下：假如运行过程中，一个算子（bolt）因某种原因挂了，Storm 如何恢复这个任务呢？ 批处理解决方案就比较简单，拿 MR 举例，假如一个运行中 map 或 reduce 失败，那么任务重新提交一遍就 ok（只不过重头计算又要花费大量时间），下面我们看看 Storm 是如何解决的： storm 的 spout 有一个 buffer，会缓存接收到的 record，并且 Storm 还有一个 acker（可以认为是一个特殊的 bolt 任务），每条 record 和该 record 所产生的所有 tuple 在处理完成后都会向对应的 acker 发送 ack 消息，当 acker 接收到该 record 所有的 ack 消息之后，便认为该 record 处理成功，并通知 spout 从 buffer 中将该 record 移除，若 receiver 没有在规定的时间内接收到 ack，acker 则通知 spout 重放数据。 acker 个数可以由用户指定，因为数据量比较大时，一个 acker 可能处理不过来所有的 ack 信息，成为系统瓶颈（如果可以容忍数据丢失，当然也可以关闭 ack 机制，可以显著提高系统性能）。并且 acker 采用了巧妙的机制，优化了 ack 机制的资源占用（有兴趣的同学可以参考官网，网上也有很多博客介绍 ack 具体实现）。 Storm 采用 ack 机制实现了数据的重放，尽管做了很多优化，但是毕竟每条 record 和它产生的 tuple 都需要 ack，对吞吐还是有较大的影响，关闭 ack 的话，对于某些不允许丢数据的业务来说又是不可接受的。 Storm 的这种特点会导致大家认为：流式计算的吞吐不如批量计算。（这点其实是不对的，只能说 Storm 的设计导致了它的吞吐不如批量计算，一个设计优秀的流式系统是有可能拥有和批处理系统一样的吞吐） 数据不重不丢之前我们提到早期的流式系统无法提供精准的计算服务，下面我们详细了解一下： sink 处的重复输出：假如运行过程中，boltA 数据入库后，boltB 因为某种原因 crash 了，这时候会导致该 record 重放，boltA 中已经处理过的数据会再次入库，导致部分数据重复输出。 不仅 sink 处存在重复输出的问题，receiver 处也同样存在这种问题。（在讲解 Spark streaming 处会详细介绍什么情况下 receiver 会重复接收数据） Storm 没有提供 exactly once 的功能，并且开启 ack 功能后又会严重影响吞吐，所以会给大家一种印象：流式系统只适合吞吐相对较小的、低延迟不精确的计算；而精确的计算则需要由批处理系统来完成，所以出现了 Lambda 架构，该架构由 Storm 的创始人提出，简单的理解就是同时运行两个系统：一个流式，一个批量，用批量计算的精确性来弥补流式计算的不足，但是这个架构存在一个问题就是需要同时维护两套系统，代价比较大。 那么有没有一种架构，可以满足高吞吐、低延迟的要求，同时也提供 exactly once 功能？有的，下面我们来看看 Spark streaming。 Spark streaming 吞吐Spark streaming 采用小批量的方式，提高了吞吐性能： 这里我们简单展示 Spark streaming 的运行机制，主要是与 Storm 做下对比。Spark streaming 批量读取数据源中的数据，然后把每个 batch 转化成内部的 RDD。Spark streaming 以 batch 为单位进行计算（默认 1s 产生一个 batch），而不是以 record 为单位，大大减少了 ack 所需的开销，显著提高了吞吐。 但也因为处理数据的粒度变大，导致 Spark streaming 的数据延时不如 Storm，Spark streaming 是秒级返回结果（与设置的 batch 间隔有关），Storm 则是毫秒级。 不重不丢（exactly once）Spark streaming 通过 batch 的方式提高了吞吐，但是同样存在上面所说的数据丢失和重复的问题。 在解答这个问题之前，我们先来了解一下一些概念： 1.at most once：最多消费一次，会存在数据丢失 2.at least once：最少消费一次，保证数据不丢，但是有可能重复消费 3.exactly once：精确一次，无论何种情况下，数据都只会消费一次，这是我们最希望看到的结果 大部分流式系统都提供了 at most once 和 at least once 功能，但不是所有系统都能提供 exactly once。 我们先看看 Spark streaming 的 at least once 是如何实现的，Spark streaming 的每个 batch 可以看做是一个 Spark 任务，receiver 会先将数据写入 WAL，保证 receiver 宕机时，从数据源获取的数据能够从日志中恢复（注意这里，早期的 Spark streaming 的 receiver 存在重复接收数据的情况），并且依赖 RDD 实现内部的 exactly once（可以简单的理解采用批量计算的方式来实现）。RDD：Resilient Distributed Dataset 弹性分布式数据集，Spark 保存着 RDD 之间的依赖关系，保证 RDD 计算失败时，可以通过上游 RDD 进行重新计算（RDD 如何实现容错这里就不解释了，可以自行查资料）。 上面简单解释了 Spark streaming 依赖源数据写 WAL 和自身 RDD 机制提供了容灾功能，保证 at least once，但是依然无法保证 exactly once，在回答这个问题前，我们再来看一下，什么情况 Spark streaming 的数据会重复计算。 WAL 即 write ahead log（预写日志）。作用就是，将数据通过日志的方式写到可靠的存储，比如 HDFS、s3，在 driver 或 worker failure 时可以从在可靠存储上的日志文件恢复数据。WAL 在 driver 端和 executor 端都有应用。我们分别来介绍。 这里我们主要关注图中的 3 个红框： Spark streaming 的 RDD 机制只能保证内部计算 exactly once（图中的 1），但这是不够的，回想一下刚才 Storm 的例子，假如某个 batch 中，sink 处一部分数据已经入库，这时候某个 sink 节点宕机，导致该节点处理的数据重复输出（图中的 3，Storm 处已经解释过了）。还有另一种情况就是 receiver 处重复接收数据（图中的 2），我们看一下 receiver 重复接收数据的情况： 假如 receiverA 目前从 kafka 读到 pos=100 的记录，并且已经持久化到 HDFS，但是由于网络延迟没有及时更新 pos，此时 receiverA 宕机了，receiverB 接管 A 的数据，并且后续的任务还会从 pos=100 处重新读取，导致重复消费。造成这种情况的主要原因就是：receiver 处数据消费和 Kafka 中 position 的更新没有做到原子性。 根据上面的讨论，可以得出：一个流式系统如果要做到 exactly once，必须满足 3 点： 1.receiver 处保证 exactly once 2. 流式系统自身保证 exactly once 3.sink 处保证 exactly once 这里数据源采用 Kafka 举例是因为 Kafka 作为目前主流的分布式消息队列，比较有代表性。Kafka consumer 的 position 可以保存在 ZK 或者 Kafka 中，也可以由 consumer 自己来保存。前者的话就可能存在数据消费和 position 更新不一致的问题（因为无法保证原子性，也是之前 Spark streaming 采用的方式），而采用后者的话，consumer 可以采用事务更新的方式（写本地或者采用事务的方式写数据库），保证数据消费和 position 更新的原子性，从而实现 exactly once（参考）。 Spark streaming 实现 exactly onceSpark streaming1.3 版本新添加了 Kafka Direct API 来实现数据接收的 exactly once，本质上就是上面提到的后者，Spark streaming 自己维护 position，streaming 的 worker 直接从 Kafka 读取数据，position 由 Spark streaming 管理，不再依赖 ZK 保存，同时保证数据消费和更新 position 的原子性，从而实现 exactly once。 并且新的方式已经不再需要 receiver 持久化数据，因为 Kafka 本身就支持数据持久化，可以避免 receiver 处持久化数据的开销，实现 exactly once 的同时也提高了性能。 而 sink 处的 exactly once 的实现则视外部系统而定，比如文件系统本身就支持幂等（同一个操作执行多次，不会改变之前的结果），同时 Spark streaming 也提供了 api，用户可以自己实现 sink 处的事务更新，receiver、sink 和 Spark streaming 三者结合起来才能实现了真正的 exactly once。 Storm trident 本质上也是采用了小批量的方式，并且也实现了 exactly once 语义，这里就不做过多讨论。 直到这里，我们了解到 Spark streaming 拥有较好的吞吐和 exactly once 语义，解决了 Storm 一些不足，是不是只有采用类似 Spark streaming 这种小批量（micro-batch）的方式才能实现这些功能？答案是：NO。下面我们来看看 Flink。 Flink Flink 在数据处理的方式上和 Storm 类似，并没有采用小批量，是一个真正的流式系统。它不仅拥有了不弱于 Spark streaming 的吞吐，并且提供了 exactly once 语义。既然 Flink 也是逐条处理记录，那么它是怎么做到的呢？跟上我的脚步…（下面内容大部分参考官网，捡重点的翻译，想起来一个段子：如何快速成为业界大牛？答：翻译英文文档。。hahaha，开个玩笑 ^ ^） 简单来说，Flink 采用轻量级分布式快照实现容错，大致流程是：Flink 不断的对整个系统做 snapshot，snapshot 数据可以放在 master 上或外部系统（如 HDFS），假如发生故障时，Flink 停止整个数据流，并选出最近完成的 snapshot，将整个数据流恢复到该 snapshot 那个时间点，snapshot 本身比较轻量，而且用户可以自行配置 snapshot 的间隔，snapshot 的性能开销对系统的影响很小（官方测试 snapshot 开启前后的性能差距不大）。 barrier 是分布式 snapshot 实现中一个非常核心的元素，barrier 和 records 一起在流式系统中传输，barrier 是当前 snapshot 和下一个 snapshot 的分界点，它携带了当前 snapshot 的 id，假设目前在做 snapshot N，算子在发送 barrier N 之前，都会对当前的状态做 checkpoint（checkpoint 数据可以保存在外部系统中，如 HDFS），checkpoint 只包含了 barrier N 之前的数据状态，不会涉及 barrier N 之后的数据。 因为算子很多情况下需要接收多个算子的数据（shuffle 操作），所以只有当所有上游的发送的 barrier N 都到达之后，算子才会将 barrier N 发送给下游（所有的下游）。当所有的 sink 算子都接收到 barrier N 之后，才会认为该 snapshot N 成功完成。 为了保证一致性，需要遵守以下几个原则： 1. 一旦算子接收到某一个上游算子的 barrier 之后，它不能再处理该上游后面的数据，只有当它所有上游算子的 barrier 都到达，并将 barrier 发送给下游之后，才能继续处理数据，否则的话会造成 snapshot N 和 N+1 的数据重叠。 2. 某个上游算子的 barrier 到达之后，该上游算子后续的数据将会被缓存在 input buffer 中。 3. 一旦所有上游的算子的 barrier 都到达之后，该算子将数据和 barrier 发送给下游。 4. 发送成功之后，该算子继续处理 input buffer 中的数据，并继续接收处理上游算子发送过来的数据。（有点啰嗦啊） 下面我们来看一个完整的 snapshot 流程图： 图中的 Master 保存了 snapshot 的状态，假设数据还是从 Kafka 中获取，首先 receiver 算子会先将当前的 position 发送给 master，记录在 snapshot 中，并同时向下游发送 barrier，下游的算子接收到 barrier 后，发起 checkpoint 操作，将当前的状态记录在外部系统中，并更新 Master 中 snapshot 状态，最后当所有的 sink 算子都接收到 barrier 之后，更新 snapshot 中的状态，此时认为该 snapshot 完成。 通过这种轻量级的分布式 snapshot 方式，Flink 实现了 exactly once，同时 Flink 也支持 at least once，也就是算子不阻塞 barrier 已经到达的上游算子的数据（多个上游算子的情况），这样可以降低延迟，但是不保证 exactly once。 从图中我们可以看出 Kafka position 也是由 Flink 自己维护的，所以能够保证 receiver 处的 exactly once，sink 处也同样存在 Spark streaming 一样的问题，exactly once 依赖外部系统或需要用户自己实现。Flink 官网给出了目前支持的 Data Sources 和 Sinks 以及容错的粒度。 其中 sink 处采用 Kafka 的话不支持 exactly once，个人猜想是不是因为早期的 Kafka producer 没有支持 exactly once 语义，而导致 Flink 无法支持。Kafka0.11 版本中添加了 producer exactly once 的支持，是否后续能够添加进来？ 讲到这里，我们可以了解到： 1. 流式系统并不一定就是吞吐差的代名词 2. 流式系统也可以做到 exactly once 就如 Google 流式系统负责人 Tyler Akidau 所说：一个设计良好的流式系统是能够在吞吐完全媲美批量系统，并且提供精准的实时服务。（那是不是以后可以完全用流式系统取代批量系统？） window 和 event time Flink 相比 Spark streaming 不仅提供了更低的延迟，而且 Flink 还对 window 和 event time 提供了更好的支持。window 和 event time 又是什么呢？ window现实生活中，大部分数据源其实是 unbound data，没有边界，我们没有办法得到一个最终的统计结果，很多情况下我们会对固定时间间隔的数据进行统计，比如每 5s 统计一下服务器的 qps，window 机制能够帮我们很好的完成这项需求。 如图（标号代表事件发生的时间），流式系统会每隔 5s 创建一个 window，将该时间段的数据放入 buffer，累加后输出结果。图中 0-5s 产生的数据放在第一个 window 中（3s 处有两条数据），累加后输出 count=6。 window 类型也有很多种，上图是一个 Tumbling Windows 的例子，另外还有 Sliding Windows 和 session window，具体区别读者可以自行查资料。 上图是一个比较理想的示例图，理想很丰满，现实很骨感，事情往往不尽如人意（情不自禁的都想唱起来了：人生已经如此的艰难，有些事情就不要 ao…… 流式系统的破事怎么这么多！！），直接按接收时间来划分 window 可能会存在误差： 假设由于网络延迟，应该属于第一个窗口的数据 3 延迟到达，被分到了第二个窗口，这时候计算结果并不准确。怎么办呢？ event time 和 process time：假设一个流式系统目前正在接收并处理用户手机的日志，但是由于网络延迟，或者用户手机离线，导致日志没有及时发送到流式系统，流式系统观察到数据的时间和数据真正产生的时间可能存在偏差，我们把数据真正产生的时间叫做：event time，把流式系统处理该数据的时间叫做：process time。 event time 和 process time 往往会存在延迟，这种不一致会导致数据乱序，如图所示：蓝色事件晚于黄色事件发生，但是事件的处理却先于黄色事件。 早期的流式系统并没有区分 process time 和 event time，往往将 process time 等同于 event time。针对这一问题，一个很直观的解决方案就是：让数据自身携带 timestamp，该 timestamp 记录该数据产生的时间，即为 event time，流式系统按数据的 event time 来将数据分配到对应的窗口，而不是按处理数据的时间。 window 需要知道该窗口的数据都已经全部到达，然后触发计算逻辑，window 如何判断时间 T 之前的数据是否都已经到达呢？ watermark那就是引入 watermark 机制，watermark 同样也携带一个时间戳，当算子接收到 watermark T 后，就代表时间 T 之前的数据已经接收完毕，不会再有小于时间 T 的数据。 如图：W(17）到达后，表示后续数据的时间戳不会小于 17。那可能有人会问了：那就是有一部分小于 17 的数据他喵的就是比 w(17) 还晚到了怎么办？ watermark 还会配合一个 allow lateness 参数，window 接收到 watermark 后，再等待一段时间才会关闭窗口，如果这段时间有些数据依然没有发送过来，那就只能忽略它们了（window 的内心 os：我也尝试过等待，但我还有更重要的事情要做），而且考虑到流式系统的实时性，假如可接受的时间内，数据没有传输过来，那就算等到它过来再计算，从实时性这个角度来说，这时计算的结果也有可能也已经没有意义了。 Flink 对 window 和 watermark 都提供了较好的支持，Spark streaming 从 2.0 中也开始引入 watermark 功能，但是支持的功能有限，并且真正的流式可以更优雅、简单的实现 window 和 watermark，从这个角度来看，Flink 是优于 Spark streaming 的。 总结： 了解了 Storm、Spark streaming、Flink 各自的特点后，我们知道 Storm 提供了低延迟的计算，但是吞吐较低，并且无法保证 exactly once（Storm trident 采用 batch 的方式改善了这两点） Spark streaming 通过小批量的方式保证了吞吐的情况下，同时提供了 exactly once 语义，但是实时性不如 Storm，而且由于采用 micro-batch 的方式，对 window 和 event time 的支持比较有限（Spark streaming2.0 中引入了 window 和 event time，还在起步阶段）。 Flink 采用分布式快照的方式实现了一个高吞吐、低延迟、支持 exactly once 的流式系统，流式处理的方式也能更优雅的支持 window 和 event time。 当然也不是说 Flink 一定就比 Storm、Spark streaming 好，没有最好的框架，只有最合适的框架，根据自身的业务、公司的技术储备选择最合适的框架才是正确的选择。 参考：离线计算——聊一聊我所经历的计算框架 - 简书https://www.jianshu.com/p/fdae83981422实时计算——聊一聊我所经历的计算框架 - 简书https://www.jianshu.com/p/16323566f3c6]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式计算平台 之 数据库]]></title>
    <url>%2F2018%2F04%2F24%2F2018-04-24-1%2F</url>
    <content type="text"><![CDATA[互联网时代各种存储框架层出不穷，眼花缭乱，比如传统的关系型数据库：Oracle、MySQL；新兴的 NoSQL：HBase、Cassandra、Redis；全文检索框架：ES、Solr 等。如何为自己的业务选取合适的存储方案，相信大家都思考过这个问题，本文简单聊聊我对 Mysql、HBase、ES 的理解，希望能和大家一起探讨进步，有不对的地方还请指出。 MySQL：关系型数据库，主要面向 OLTP，支持事务，支持二级索引，支持 sql，支持主从、Group Replication 架构模型（本文全部以 Innodb 为例，不涉及别的存储引擎）。 HBase：基于 HDFS，支持海量数据读写（尤其是写），支持上亿行、上百万列的，面向列的分布式 NoSql 数据库。天然分布式，主从架构，不支持事务，不支持二级索引，不支持 sql。 ElasticSearch：ES 是一款分布式的全文检索框架，底层基于 Lucene 实现，虽然 ES 也提供存储，检索功能，但我一直不认为 ES 是一款数据库，但是随着 ES 功能越来越强大，与数据库的界限也越来越模糊。天然分布式，p2p 架构，不支持事务，采用倒排索引提供全文检索。 下面分别从数据存储方式、读写方式、索引、分布式等方面对它们进行对比。 参考链接： ES：http://www.jianshu.com/p/e8ee319a238d HBase：http://www.cnblogs.com/songlee/p/5738027.html 数据存储方式 MySQL 采用行存储，HBase 是面向列的 NoSql 数据库，这篇文章很好的解释了行、列存储的区别，至于 ES，呃~ 我也说不清楚它是什么存储方式，暂且叫它索引存储吧。 假设有这样一张人员信息表： MySQL 中要提前定义表结构，也就是说表共有多少列（属性）需要提前定义好，并且同时需要定义好每个列所占用的存储空间。数据以行为单位组织在一起的，假如某一行的某一列没有数据，也需要占用存储空间。 HBase 则是以列为单位存储数据，每一列就是一个 key-value，HBase 的表列（属性）不用提前定义，而且列可以动态扩展，比如人员信息表中需要添加一个新的 “address” 字段，MySQL 需要提前 alter 表，HBase 的话直接插入即可。 ES 比较灵活，索引中的 field 类型可以提前定义（定义 mapping），也可以不定义，如果不定义，会有一个默认类型，不过出于可控性考虑，关键字段最好提前定义好。（Solr 中必须提前定义好 schema.xml 文件） 上图简单的展示了数据在 MySQL 和 HBase 中存储差异（和真实的情况还有差距），可以看到即使第二条记录的 sex 字段为空，MySQL 依然会为该字段保留空间，因为后续有可能会有 update 语句来更新该记录，补上 sex 内容。而 HBase 则是把每一列都看做是一条记录，row + 列名作为 key，data 作为 value，依次存放。假如某一行的某一个列没有数据，则直接跳过该列。对于稀疏矩阵的大表，HBase 能节省空间。 看到这里，大家是否会有一个疑问：使用 HBase 存储时，假如此时需要添加第二行的 sex 内容，如何实现呢，数据是否连续？后面介绍读写流程会解释。 不一样的 ES说完 MySQL、HBase，这里要重点说一下 ES，ES 的存储方式和上面两个都不一样，MySQL 和 HBase 是将数据按不同的方式进行存储，好歹它们存的还是数据，而 ES 则存的是倒排索引。我们先来了解一下什么是倒排索引，以及为什么需要倒排索引（Inverted Index）： 我们肯定都会这样的经历：偶然看到一段很好的文字，但是却不知道出处，这时候去图书馆，一个一个翻找，无疑是大海捞针，这个时候肿么办呢，于是便有了全文检索这项技术，而它最核心的就是倒排索引。假如有如下文档： 我们想要知道有哪些文档含有 you 这个关键字，首先可以创建一个倒排索引，格式如下： 我们把前面的部分叫做 dictionary（字典），里面的每个单词叫做 term，后面的文档列表叫做 posting-list，list 中记录了所有含有该 term 的文档 id，两个组合起来就是一个完成的倒排索引（Inverted Index）。能够看出，假如需要查找含有 “you” 的文档时，根据 dictionary 然后找到对应的 posting-list 即可。 而全文检索中，创建 Inverted Index 是最关键也是最耗时的过程，而且真正的 Inverted Index 结构也远比图中展示的复杂，不仅需要对文档进行分词（ES 里中文可以自定义分词器），还要计算 TF-IDF，方便评分排序（当查找 you 时，评分决定哪个 doc 显示在前面，也就是所谓的搜索排名），压缩等操作。每接收一个 document，ES 就会将其信息更新在倒排索引中。 从这里我们就可以看出 ES 和 MySQL、HBase 的存储还是有很大的区别。而且 ES 不仅包含倒排索引，默认同时还会把文档 doc 存储起来，所以当我们使用 ES 时，也能拿到完整的文档信息，所以某种程度上，感觉就像在使用数据库一样，但是也可以配置不存储文档信息，这时只能根据查询条件得到文档 id，并不能拿到完整的文档内容。 总结：MySQL 行存储的方式比较适合 OLTP 业务。列存储的方式比较适合 OLAP 业务，而 HBase 采用了列族的方式平衡了 OLTP 和 OLAP，支持水平扩展，如果数据量比较大、对性能要求没有那么高、并且对事务没有要求的话，HBase 也是个不错的考虑。ES默认对所有字段都建了索引，所以比较适合复杂的检索或全文检索。 读写方式 存储方式和读写方式很大程度上决定了系统的吞吐，本节主要介绍 MySQL、HBase、ES 各自是如何读写数据的。 Mysql 先说说 MySQL，MySQL 的 Innodb 中的数据是按主键的顺序依次存放，主键即为聚簇索引（对聚簇索引和非聚簇索引不了解同学可以看看这篇文章），索引采用 B + 树结构进行组织。 从图中可以看出，数据是按聚簇索引顺序依次存放，假设下面一些场景： 1. 查询Innodb 中主键即为聚簇索引，假如根据主键查询，聚簇索引的叶子节点存放就是真正的数据，可以直接查到相应的记录。 假如是二级索引查询，那么需要先通过二级索引找到该记录的主键，然后根据主键通过聚簇索引找到对应的记录，这里多了一个索引查找的过程。 2. 插入顺序插入：因为 Innodb 的数据是按聚簇索引的顺序依次存放的，如果是根据主键索引的顺序插入，即插入的数据的主键是连续的，因为是顺序 io，所以插入效率会较高。 随机插入：假如每次插入的数据主键是不连续的，MySQL 需要取出每条记录对应的物理 block，会引起大量的随机 io，随机 io 操作和顺序 io 的性能差距很大，尤其是机械盘。 _（Kafka 官网提到一个机械盘的顺序写能达到 600M/s，而随机写可能只有 100k/s。As a result the performance of linear writes on aJBODconfiguration with six 7200rpm SATA RAID-5 array is about 600MB/sec but the performance of random writes is only about 100k/sec—a difference of over 6000X. 这也是为什么 HBase、ES 将所有的 insert、update、delete 操作都统一看成顺序写操作，避免随机 io）_ note：这也是为什么 MySQL 的主键通常定义为自增 id，不涉及业务逻辑，这样新数据插入时能保证是顺序 io。另外 MySQL 为了提高随机 io 的性能，提供了 insert buffer 的功能。 3. 更新 &amp; 删除update 和 delete 如果不是顺序的话，也会包含大量的随机 io，当然 MySQL 都针对随机 io 都进行了一些优化，尽量减少随机 io 带来的性能损失。 HBase HBase 不支持二级索引，它只有一个主键索引，采用 LSM 树（LSM 可以参考这篇博客）。 HBase 是一个分布式系统，这点跟 MySQL 不同，它的数据是分散不同的 server 上，每个 table 由一个或多个 region 组成，region 分散在集群中的 server 上，一个 server 可以负责多个 region。 这里有一点需要特别注意：table 中各个 region 的存放数据的 rowkey（主键）范围是不会重叠的，可以认为 region 上数据基于 rowkey 全局有序，每个 region 负责它自己的那一部分的数据。 1. 查询假如我们要查询 rowkey=150 的这条记录，首先从 zk 中获取 hbase:meta 表（存放 region 和 key 的对应关系的元数据表）的位置，通过查询 meta 表得知 rowkey=150 的数据在哪个 server 的哪个 region 上。 2. 插入 上图粗略的展示了 HBase 的 region 的结构，region 不单单是一个文件，它是由一个 memstore 和多个 storeFile 组成（storeFile 上的上限可以配置）。插入数据时首先将数据写入 memstore，当 memstore 大小达到一定阈值，将 memstore flush 到硬盘，变成一个新的 storeFile。flush 的时候会对 memstore 中的数据进行排序，压缩等操作。可以看到单个 storeFile 中的数据是有序的，但是 region 中的 storeFile 间的数据不是全局有序的。 这样有的好处就是：不管主键是否连续，所有的插入一律变成顺序写，大大提高了写入性能。 看到这里大家可能会有一个疑问：这种写入方式导致了一条记录如果不是一次性插入，很可能分散在不同的 storeFile 中，那在该 region 上面查询一条记录时，怎么知道去找哪个 storeFile 呢？答案就是：全部查询。HBase 会采用多路归并的方式，对该 region 上的所有 storeFile 进行查询，直到找到符合条件的记录。所以 HBase 的拥有很好的写入性能，但是读性能较差。 当然 HBase 也做了很多优化，比如每个 storeFile 都有自己的 index、用于过滤的 bloom filter、compaction：按可配置的方式将多个 storeFile 合并成一个，减少检索时打开的文件数。 3. 更新 &amp; 删除HBase 将更新和删除也全部看做插入操作，用 timestamp 和 delete marker 来区分该记录是否是最新记录、是否需要删除。也正是因为这样，除了查询，其他的操作统一转换成了顺序写，保证了 HBase 高效的写性能。 ES ES 的也是一个分布式系统，与 ES 类似的还有一个叫 Solr 的项目，都是基于 Lucene 的全文检索分布式框架，有兴趣的可以去 Lucene 官网了解，这里就不做对比了。 上如展示了 ES 和传统数据库的概念对比。下面的介绍中，统一使用 index 对应 DB 中 table，doc 对应 table 中的记录，field 对应 row 中的一列。 ES 集群由一个或多个 node 组成，一个 node 即为一个 ES 服务进程。一个 index 由多个分片 shard 组成，shard 分散在各个 node 上面，每个 shard 都采用 Lucene 来创建倒排索引，维护各自的索引数据。 图中的一个小方框即为一个 shard，出于容灾考虑，每个 shard 都会有多副本，副本个数可以配置，默认为 2，绿色的即为 primary shard，灰色的即为 replica shard。 1. 插入先来说说写入吧，由于有多个 shard，请求过来时，如何判断写入到哪个 shard 呢，ES 中每个 doc 都会有一个唯一 id，默认会对 id 取 hash 值，根据 shard 的个数 mode 到对应的 shard 上，默认情况下 shard 中的数据 id 不是全局有序的，这点和 Mysql、HBase 有很大区别。 ES 的写入和 HBase 有些类似，也是将所有的写操作变成顺序写，也是先将数据写入内存，然后一段时间后会将内存数据 flush 到磁盘，磁盘的索引文件会定时进行 merge，保证索引文件不会过多而影响检索性能。 另外提一点, 数据存入 ES 后并不是立马就能检索到，这点跟 MySQL 和 HBase，或者说跟数据库系统是完全不一样的。主要是因为由于 Inverted Index 结构的复杂，需要一个专门的 indexReader 来查询数据，但是 indexReader 是以 snapshot 的方式打开的索引，也就是说 indexReader 看不到之后的新数据。所以 ES 提供了一个 refresh 功能，refresh 会重新打开 indexReader，使其能够读到最新的数据。默认 refresh 的间隔是 1s，所以 ES 自称是近实时检索功能。 说到顺序写, 这时候大家可能会想：那 ES 的写入速度和 HBase 差不多喽？那，其实不是的，不止不如而且差的还不是一点点，因为 ES 多了两个最关键的步骤：build index 和 refresh index！这两个过程是很耗时的: build index 时需要分词、计算权重等复杂的操作（对 inverted index 创建，检索感兴趣的，可以参考《信息检索导论》）。而 refresh 会重新打开 index, 这两个过程加起来导致 ES 接收文档的速率并不高（可以通过 bulk 方式来加快数据导入）。但也正是因为这些过程才使 ES 有强大的检索功能。（虽然我 insert 慢，但是我花样多呀 ^ ^） 2. 读取每个 node 都可以接收读 request，然后该 node 会把 request 分发到含有该 index 的 shard 的节点上，对应的节点会查询、并计算出符合条件的文档，排序后结果汇聚到分发 request 的 node（所以查询请求默认会轮循的将发送到各个节点上，防止请求全部打到一个节点），由该 node 将数据返回给 client。（ES 也支持指定 shard 查询，默认是根据文档 id 进行路由，相当于主键查询，但是假如不能确定数据在哪个 shard 上时，还是需要查询所有 shard） 这里要强调一下，由于 ES 支持全文检索，根据 Inverted Index 的特性，大部分情况下，一个关键字对应了很多的 doc，如果全部返回，数据量较大，会对集群造成较大压力，所以 ES 默认只返回权重最高的前 20 条记录（可配置），也可以通过 scroll 功能获取全部数据。类似的场景跟我们平时使用 baidu、google 是一样的，我们使用搜索引擎时，往往是希望得到关联性最强的 top N 文档，并不关心全部文档有多少个，这也是为什么要计算权重的原因。 现在的 ES 的功能越来越丰富，不仅仅包含全文检索的功能，而且还有统计分析等功能，说它是全文检索框架吧，它比全文检索功能要丰富，说它是数据库吧，但是它不支持事务，只能说现在各个框架之间的界限越来越模糊了。 3. 更新 &amp; 删除ES 的更新和删除和 HBase 类似，也是全部看做是插入操作，通过 timestamp 和 delete marker 来区分。 又到了问题环节 :D ：既然这种将更新删除统一变成顺序写的方式能够提高写性能，那它难道没有什么坏处吗？ 答案是肯定有的呀，这种方式能够有效的提升写性能，但是存在一个很大的问题就是后台经常会需要 merge，而 merge 是一个非常耗资源的过程，对于某些稳定性要求较高的业务来说，这是不能接受的，但是不 merge 的话，又会降低查询性能（过多的小文件影响查询性能）。目前通用的做法是尽量选择业务低峰期进行 merge 操作。 ————————————————— 我是分割线 ——————————————————— 容灾 数据库系统，数据的完整性和一致性是非常重要的问题，数据库进程挂了，可以恢复，但是数据丢了，就再也找不回来了。下面说说各个系统的容灾方式。 MySQL 单节点： 现在的数据库普遍采用 write ahead log 策略来避免数据丢失，wal 机制简单的解释就是：在提交 CUD 操作，数据写入内存的同时，也要写一份到 log 文件中，而且要保证 log 数据落盘成功后才能向 client 返回操作成功，假如此时数据库宕机，已经提交到内存的数据还没来得及刷回磁盘，重启数据库后可以通过回放 log 文件来恢复内存中的数据。 问题又来了：写 log 的话，对性能影响会不会很大？其实多少还是有点影响的，不过 log 文件是顺序写入，相对来说为了保证数据完整性，这点性能损失还是可以接受的。 单机情况下，MySQL 的 innodb 通过 redo log 和 checkpoint 机制来保证数据的完整性。因为怕 log 越写越大，占用过多磁盘，而且当 log 特别大的时候，恢复起来也比较耗时。而 checkpoint 的出现就是为了解决这些问题。 checkpoint 机制保证了之前的 log 数据一定已经刷回磁盘，当数据库宕机时，只需要将 checkpoint 之后的 log 回放即可，数据库会定时做 checkpoint，这样就保证了数据库恢复的效率。 但是考虑到如果硬件故障时机器无法启动，或者磁盘故障时数据无法恢复，checkpoint+redo log 方案也就不起作用了，为了防止这种故障，MySQL 还提供了 master-slave 和 group replication 集群级别的容灾方案。 Master-Slave 架构主要思路是：master 负责业务的读写请求，然后通过 binlog 复制到 slave 节点，这样如果主库因为不可抗拒因素无法恢复时，从库可以提供服务，这里我们用了 “复制“这个词，而不是” 同步“，因为基于 binlog 复制的方案并不能做到主从数据强一致，这种主从同步方式会导致主库挂掉之后从库有可能丢失少量的数据。 正是因为主从架构存在数据不一致的问题，所以 MySQL5.7 出现了 Mysql Group Replication 方案，mgr 采用 paxos 协议实现了数据节点的强同步，保证了所有节点都可以写数据，并且所有节点读到的也是最新的数据。（原谅本人水平有限，说不清楚主从架构为什么会丢数据，也讲不清楚 mgr 是怎么实现的，但是这里强烈推荐一本前司同事的书：《MySQL 运维内参》，里面详细解释了 Master-Slave 和 Group Replication 的架构，是深入理解 Mysql 的不二之选，据说本书的出现拉低了 DBA 的门槛，没有任何打广告的嫌疑 ^ ^） HBase： HBase 的容灾和 MySQL 的单机容灾有些类似，但具体实现上还是很有自己的特点。在介绍 HBase 容灾前，我们先来了解一下 HBase 和 HDFS 的关系：HBase 中的数据都是存放在 HDFS 上，可以简单理解 HBase 分为两层：一层为 NoSql service（即提供分布式检索服务），一层是分布式文件系统（数据真正存放的位置，目前采用 HDFS）。HBase 中 region 分布在不同的 regionserver 上，client 端通过 meta 表来定位数据在在哪个 regionserver 的 region 上，然后获取数据，但是数据有可能并不一定在该 regionserver 本地保存，每个 region 都知道自己对应的数据在 HDFS 的哪些数据块上，最后通过访问 HDFS 来获取数据，尤其当 HBase 和 HDFS 部署在不同的集群上时，数据的读写完全是通过 RPC 来实现，为了减少 RPC 的开销，保证服务稳定，往往会将 HBase 和 HDFS 部署在同一个集群。同理，当一个 regionserver 挂了，region 可以快速切换到别的 regionserver 上，因为只涉及到回放 Log，并不会移动已经落盘的数据，而且 HBase 也会控制 log 的大小，来减少恢复时间。 HBase 也是采用写 log 的方式防止数据丢失，数据写内存的同时，同时也会写入 HLog，HLog 也是存储在 HDFS 上，写入 HLog 后才会认为数据写成功，某个 regionserver 挂掉之后，master 将故障机器上的 regions 调度到别的 regionserver 上，regionserver 通过回放 HLog 来恢复 region 的数据，恢复成功后，region 重新上线，由于 log 是直接写在 HDFS 上，所以不用担心单个节点挂掉 log 数据丢失的问题。 这里引出一个问题：回放 HLog 的时候，正在被恢复的 region 会短时间不可用，直到 HLog 回放成功。HBase1.0 版本中加入了 region replicas 功能，也就是提供一个 slave region，当主 region 挂掉的时候，依然可以通过 slave replicas 来读数据，但是 slave 不提供 write，而且 slave replicas 和 primary region 并不是强同步的，并不一定总能读到最新的数据，所以开启该功能时，也要考虑自己业务是否必须要求强一致。 HBase 也提供了 cluster replication，目的是为了做机房级的容灾，boss 说现在 cluster replication 功能还有些 bug，目前也在积极优化改进，相信以后会 cluster replication 会越来越完善。 ES： ES 的容灾也是采用写 log 的方式，与 HBase 不同的是，ES 的节点保存各自的 log，这点跟 MySQL 类似，log 是存放在本地的，这也就存在和 MySQL 一样的问题，假如机器宕机或硬盘故障，log 数据也会丢失，所以 index 每个 shard 也有主备，默认配置是一个 primary shard，一个 replica shard，当然也可以配置多个 replica。 默认情况下：primary shard 首先接收 client 端发送过来的数据，然后将数据同步到 replica shard 中，当 replica shard 也写入成功后，才会告知 client 数据已正确写入，这样就防止数据还没写入 replica shard 时，primary 挂掉导致的数据丢失。 又到了提问环节，如果有一个 replica 节点出了问题，比如网络故障无法写入，那岂不是数据一直写入不成功了？所以 ES 的 master 维护了一个 in-sync set，里面保存了目前存活、且与 primary 同步的 replica 集合，只要 set 中的 replica 同步完成即认为数据写入成功。考虑到一种情况：所有的 replica 因为网络故障都下线了，in-sync set 此时为空，数据只在 primary 中保留一份，很有可能因 primary 故障而导致丢数据，所以 ES 新增了 wait_for_active_shards 参数，只有当存活的 replica 数大于该参数时，才能正常写入，若不满足，则停止写服务。 （这是 5.X 版本的实现，由于 ES 版本更新过快，这和 2.X 之前的版本有些差异，5.X 中 in-sync set 的方式和 Kafka 的容灾模式非常类似，但和 Kafka 有一点区别：ES 的 primary 负责写服务，但是 primary 和 replica 都可以提供读服务，而 Kafka 只有 primary partition 提供读写服务，replica 只是同步 primary 上的数据，并不提供读。具体为什么 Kafka 不用 replica 提供读服务，大家可以思考一下哈。而 ES 2.X 之前版本的容灾更像 ZK，采用 quorum 的方式，如果不对请指正） 使用场景 说了这么多，其实还是希望对 MySQL，HBase，ES 各自的实现做下对比，方便我们根据业务特点选择最合适的存储、检索方案。下面说一下笔者在工作中使用的经验： MySQL 在三款中最为成熟，而且支持事务，支持二级索引，容灾备份方案也最为成熟，所以线上核心业务 Mysql 是不二之选（当然如果不差钱，Oracle 也挺不错，而且出问题自己解决不了的话，打电话就可以了，手动斜眼）。 HBase 因为其强大的写入能力和水平扩展能力，比较适合存储日志，用户行为等数据量比较大的数据，这种数据一般不涉及事务级别的读写，对二级索引的需求也不是很高。而且 HBase 的主键不像 Mysql，往往是涉及到业务逻辑的，如果查询条件单一的话，可以把直接把需要查询的字段作为主键的一部分，类似 MySQL 的联合索引，来提供检索功能。 ES 现在不仅提供全文检索，还提供统计功能，并且提供的 Restful 接口非常好用，配上 Kibana 还可以进行图形化展示，第三方插件也很丰富。虽然 ES 可以水平扩展，但是考虑到 ES 的大部分检索都会检索该 index 的所有 shard，如果单个 index 数据过大，性能多少也会受到影响，所以单个 index 的大小最好控制在一定的范围，比如存储用户行为日志的 index，可以每隔一段时间归一次档，创建新的 index，做到冷热分离。而且 ES 也可以作为 MySQL 或 HBase 的索引来使用，虽然 Mysql 也有索引功能，但是过多的索引往往会拖累 MySQL 的性能，并且线上 MySQL 数据库一般也不允许执行统计类的 sql，这时可以用 ES 辅助实现统计，HBase 因为只有主键检索，所以更需要二级索引的功能。 举一个笔者前司组合使用的场景：trace 系统的 log 数据以 HBase 作为主要存储，同时最近三个月的数据也在 ES 里面保留一份，ES 主要用来完成各种复杂检索、统计。但数据同步需要业务自己实现，当然 trace 业务对一致性要求不那么高，也可以忽略这个问题。 tip：将数据库的数据向 ES 中同步的时候，因为网络延迟等问题，到达的顺序可能会乱序，这时老数据有可能会覆盖新的数据，ES 提供了一个 version 功能，可以将数据的 timestamp 作为 version 值，防止旧 version 的数据覆盖新 version 的数据。 展望传统的关系型数据库有着强大的事物处理能力，满足了大部分线上业务需求，但是水平扩展性一直是一个头疼的问题，NoSql 数据库虽然解决了水平扩展问题，但是功能太单一，现在越来越多的公司开始着手研究新一代 NewSQL 数据库，结合了关系型数据库的优点外还拥有水平扩展能力，比如淘宝的 Oceanbase，PingCAP 的 TiDB，国外的 CockroachDB，让我们做好拥抱 NewSQL 的准备吧。 下一篇聊一聊实时计算 ^ ^。 参考：聊聊MySQL、HBase、ES的特点和区别 - 简书https://www.jianshu.com/p/4e412f48e820]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式虚拟化之 Docker]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-6%2F</url>
    <content type="text"><![CDATA[什么是 DockerDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源)，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 图 1.4.1.1 - 传统虚拟化 图 1.4.1.2 - Docker 为什么要使用 Docker？作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。 持续交付和部署对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成 (Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署 (Continuous Delivery/Deployment) 系统进行自动部署。 而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 基本概念Docker 包括三个基本概念 镜像（Image） 容器（Container） 仓库（Repository） 理解了这三个概念，就理解了 Docker 的整个生命周期。 Docker 微服务教程 - 阮一峰的网络日志http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.htmlDocker —— 从入门到实践 · GitBookhttps://legacy.gitbook.com/book/yeasy/docker_practice/details]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式微服务之 Dubbo]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-5%2F</url>
    <content type="text"><![CDATA[背景随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架 (ORM) 是关键。 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web 框架 (MVC) 是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架 (RPC) 是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心 (SOA) 是关键。 需求 在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的 URL 地址进行调用，通过 F5 等硬件进行负载均衡。 当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover(故障转移)，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。 以上是 Dubbo 最基本的几个需求。 架构 节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。 连通性 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 健壮性 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 伸缩性 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者 升级性当服务集群规模进一步扩大，带动 IT 治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构： 节点角色说明 节点 角色说明 Deployer 自动部署服务的本地代理 Repository 仓库用于存储服务应用发布包 Scheduler 调度中心基于访问压力自动增减服务提供者 Admin 统一管理控制台 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 原文：Introduction · GitBookhttp://dubbo.apache.org/books/dubbo-user-book/]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式微服务之 spring cloud]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-4%2F</url>
    <content type="text"><![CDATA[研究了一段时间 Spring Boot 了准备向 Spring Cloud 进发，公司架构和项目也全面拥抱了 Spring Cloud。在使用了一段时间后发现 Spring Cloud 从技术架构上降低了对大型系统构建的要求，使我们以非常低的成本（技术或者硬件）搭建一套高效、分布式、容错的平台，但 Spring Cloud 也不是没有缺点，小型独立的项目不适合使用。 Spring Cloud 是什么鬼？Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，springcloud 就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，springcloud 做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。 主要的小弟有：Spring Cloud Config、Spring Cloud Netflix（Eureka、Hystrix、Zuul、Archaius…）、Spring Cloud Bus、Spring Cloud for Cloud Foundry、Spring Cloud Cluster、Spring Cloud Consul、Spring Cloud Security、Spring Cloud Sleuth、Spring Cloud Data Flow、Spring Cloud Stream、Spring Cloud Task、Spring Cloud Zookeeper、Spring Cloud Connectors、Spring Cloud Starters、Spring Cloud CLI，每个小弟身怀独门绝技武功高强下面来做一一介绍。 核心成员Spring Cloud Netflix这可是个大 boss，地位仅次于老大，老大各项服务依赖与它，与各种 Netflix OSS 组件集成，组成微服务的核心，它的小弟主要有 Eureka, Hystrix, Zuul, Archaius… 太多了 Netflix Eureka 服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是 springcloud 最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。 Netflix Hystrix 熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点, 从而对延迟和故障提供更强大的容错能力。比如突然某个小弟生病了，但是你还需要它的支持，然后调用之后它半天没有响应，你却不知道，一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技，那么当请求多之后，就会发生严重的阻塞影响老大的整体计划。这个时候 Hystrix 就派上用场了，当 Hystrix 发现某个小弟不在状态不稳定立马马上让它下线，让其它小弟来顶上来，或者给你说不用等了这个小弟今天肯定不行，该干嘛赶紧干嘛去别在这排队了。 Netflix Zuul Zuul 是在云平台上提供动态路由, 监控, 弹性, 安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。当其它门派来找大哥办事的时候一定要先经过 zuul, 看下有没有带刀子什么的给拦截回去，或者是需要找那个小弟的直接给带过去。 Netflix Archaius 配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置， 原理是每隔 60s（默认，可配置）从配置源读取一次内容，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用 archaius 的 API 来读取。 Spring Cloud Config俗称的配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Subversion。就是以后大家武器、枪火什么的东西都集中放到一起，别随便自己带，方便以后统一管理、升级装备。 Spring Cloud Bus事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。相当于水浒传中日行八百里的神行太保戴宗，确保各个小弟之间消息保持畅通。 Spring Cloud for Cloud FoundryCloud Foundry 是 VMware 推出的业界第一个开源 PaaS 云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题 其实就是与 CloudFoundry 进行集成的一套解决方案，抱了 Cloud Foundry 的大腿。 Spring Cloud ClusterSpring Cloud Cluster 将取代 Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens 等常见状态模式的抽象和实现。 如果把不同的帮派组织成统一的整体，Spring Cloud Cluster 已经帮你提供了很多方便组织成统一的工具。 Spring Cloud ConsulConsul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件, 由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查, 并允许 HTTP 和 DNS 协议调用 API 存储键值对. Spring Cloud Consul 封装了 Consul 操作，consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。 其它小弟Spring Cloud Security 基于 spring security 的安全工具包，为你的应用程序添加安全控制。这个小弟很牛鼻专门负责整个帮派的安全问题，设置不同的门派访问特定的资源，不能把秘籍葵花宝典泄漏了。 Spring Cloud Sleuth 日志收集工具包，封装了 Dapper 和 log-based 追踪以及 Zipkin 和 HTrace 操作，为 SpringCloud 应用实现了一种分布式追踪解决方案。 Spring Cloud Data Flow Data flow 是一个用于开发和执行大范围数据处理其模式包括 ETL，批量运算和持续运算的统一编程模型和托管服务。 对于在现代运行环境中可组合的微服务程序来说，Spring Cloud data flow 是一个原生云可编配的服务。使用 Spring Cloud data flow，开发者可以为像数据抽取，实时分析，和数据导入 / 导出这种常见用例创建和编配数据通道 （data pipelines）。 Spring Cloud data flow 是基于原生云对 spring XD 的重新设计，该项目目标是简化大数据应用的开发。Spring XD 的流处理和批处理模块的重构分别是基于 Spring Boot 的 stream 和 task/batch 的微服务程序。这些程序现在都是自动部署单元而且他们原生的支持像 Cloud Foundry、Apache YARN、Apache Mesos 和 Kubernetes 等现代运行环境。 Spring Cloud data flow 为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践。 Spring Cloud Stream Spring Cloud Stream 是创建消息驱动微服务应用的框架。Spring Cloud Stream 是基于 Spring Boot 创建，用来建立单独的／工业级 spring 应用，使用 spring integration 提供与消息代理之间的连接。数据流操作开发包，封装了与 Redis,Rabbit、Kafka 等发送接收消息。 一个业务会牵扯到多个任务，任务之间是通过事件触发的，这就是 Spring Cloud stream 要干的事了 Spring Cloud Task Spring Cloud Task 主要解决短命微服务的任务管理，任务调度的工作，比如说某些定时任务晚上就跑一次，或者某项数据分析临时就跑几次。 Spring Cloud Zookeeper ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 操作 Zookeeper 的工具包，用于使用 zookeeper 方式的服务发现和配置管理，抱了 Zookeeper 的大腿。 Spring Cloud Connectors Spring Cloud Connectors 简化了连接到服务的过程和从云平台获取操作的过程，有很强的扩展性，可以利用 Spring Cloud Connectors 来构建你自己的云平台。 便于云端应用程序在各种 PaaS 平台连接到后端，如：数据库和消息代理服务。 Spring Cloud Starters Spring Boot 式的启动项目，为 Spring Cloud 提供开箱即用的依赖管理。 Spring Cloud CLI 基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。 和 Spring Boot 是什么关系Spring Boot 是 Spring 的一套快速配置脚手架，可以基于 Spring Boot 快速开发单个微服务，Spring Cloud 是一个基于 Spring Boot 实现的云应用开发工具；Spring Boot 专注于快速、方便集成的单个个体，Spring Cloud 是关注全局的服务治理框架；Spring Boot 使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud 很大的一部分是基于 Spring Boot 来实现, 可以不基于 Spring Boot 吗？不可以。 Spring Boot 可以离开 Spring Cloud 独立使用开发项目，但是 Spring Cloud 离不开 Spring Boot，属于依赖的关系。 spring -&gt; spring boot &gt; Spring Cloud 这样的关系。 Spring Cloud 的优势微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用 Spring Cloud 的呢？ 产出于 spring 大家族，spring 在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善。比如 dubbo 现在就差不多死了 有 Spring Boot 这个独立干将可以省很多事，大大小小的活 Spring Boot 都搞的挺不错。 作为一个微服务治理的大家伙，考虑的很全面，几乎服务治理的方方面面都考虑到了，方便开发开箱即用。 Spring Cloud 活跃度很高，教程很丰富，遇到问题很容易找到解决方案 轻轻松松几行代码就完成了熔断、均衡负责、服务中心的各种平台功能 Spring Cloud 对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用 Spring Cloud 一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和 Docker 容器概念的火爆，也会让 Spring Cloud 在未来越来越 “云” 化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前 Servlet 规范的诞生，有效推进服务端软件系统技术水平的进步。 示例代码 - github 示例代码 - 码云 作者：纯洁的微笑出处：http://www.ityouknow.com/ 上次写了一篇文章叫 Spring Cloud 在国内中小型公司能用起来吗? 介绍了 Spring Cloud 是否能在中小公司使用起来，这篇文章是它的姊妹篇。其实我们在这条路上已经走了一年多，从 16 年初到现在。在使用 Spring Cloud 之前我们对微服务实践是没有太多的体会和经验的。从最初的开源软件云收藏来熟悉 Spring Boot，到项目中的慢慢使用，再到最后全面拥抱 Spring Cloud。这篇文章就给大家介绍一下我们使用 Spring Boot/Cloud 一年多的经验。 在开始之前我们先介绍一下几个概念，什么是微服务，它的特点是什么? Spring Boot/Cloud 都做了那些事情？他们三者之间又有什么联系？ 技术背景什么是微服务微服务的概念源于 2014 年 3 月 Martin Fowler 所写的一篇文章 “Microservices”。 微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。 微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。 微服务架构优势复杂度可控：在将应用分解的同时，规避了原本复杂度无止境的积累。每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。 独立部署：由于微服务具备独立的运行进程，所以每个微服务也可以独立部署。当某个微服务发生变更时无需编译、部署整个应用。由微服务组成的应用相当于具备一系列可并行的发布流程，使得发布更加高效，同时降低对生产环境所造成的风险，最终缩短应用交付周期。 技术选型灵活：微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。由于每个微服务相对简单，故需要对技术栈进行升级时所面临的风险就较低，甚至完全重构一个微服务也是可行的。 容错：当某一组件发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用。在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。 扩展：单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。 什么是 Spring BootSpring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 maven 整合了所有的 jar 包，Spring Boot 整合了所有的框架（不知道这样比喻是否合适）。 Spring Boot 简化了基于 Spring 的应用开发，通过少量的代码就能创建一个独立的、产品级别的 Spring 应用。 Spring Boot 为 Spring 平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。Spring Boot 的核心思想就是约定大于配置，多数 Spring Boot 应用只需要很少的 Spring 配置。采用 Spring Boot 可以大大的简化你的开发模式，所有你想集成的常用框架，它都有对应的组件支持。 Spring Cloud 都做了哪些事Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包 以下为 Spring Cloud 的核心功能： 分布式 / 版本化配置 服务注册和发现 路由 服务和服务之间的调用 负载均衡 断路器 分布式消息传递 我们再来看一张图： 通过这张图，我们来了解一下各组件配置使用运行流程： 1、请求统一通过 API 网关（Zuul）来访问内部服务. 2、网关接收到请求后，从注册中心（Eureka）获取可用服务 3、由 Ribbon 进行均衡负载后，分发到后端具体实例 4、微服务之间通过 Feign 进行通信处理业务 5、Hystrix 负责处理服务超时熔断 6、Turbine 监控服务间的调用和熔断相关指标 Spring Cloud 体系介绍上图只是 Spring Cloud 体系的一部分，Spring Cloud 共集成了 19 个子项目，里面都包含一个或者多个第三方的组件或者框架！ Spring Cloud 工具框架 1、Spring Cloud Config 配置中心，利用 git 集中管理程序的配置。2、Spring Cloud Netflix 集成众多 Netflix 的开源软件3、Spring Cloud Bus 消息总线，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化4、Spring Cloud for Cloud Foundry 利用 Pivotal Cloudfoundry 集成你的应用程序5、Spring Cloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。6、Spring Cloud Cluster 基于 Zookeeper, Redis, Hazelcast, Consul 实现的领导选举和平民状态模式的抽象和实现。7、Spring Cloud Consul 基于 Hashicorp Consul 实现的服务发现和配置管理。8、Spring Cloud Security 在 Zuul 代理中为 OAuth2 rest 客户端和认证头转发提供负载均衡9、Spring Cloud Sleuth SpringCloud 应用的分布式追踪系统，和 Zipkin，HTrace，ELK 兼容。10、Spring Cloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。11、Spring Cloud Stream 基于 Redis,Rabbit,Kafka 实现的消息微服务，简单声明模型用以在 Spring Cloud 应用中收发消息。12、Spring Cloud Stream App Starters 基于 Spring Boot 为外部系统提供 spring 的集成13、Spring Cloud Task 短生命周期的微服务，为 SpringBooot 应用简单声明添加功能和非功能特性。14、Spring Cloud Task App Starters15、Spring Cloud Zookeeper 服务发现和配置管理基于 Apache Zookeeper。16、Spring Cloud for Amazon Web Services 快速和亚马逊网络服务集成。17、Spring Cloud Connectors 便于 PaaS 应用在各种平台上连接到后端像数据库和消息经纪服务。18、Spring Cloud Starters （项目已经终止并且在 Angel.SR2 后的版本和其他项目合并）19、Spring Cloud CLI 插件用 Groovy 快速的创建 Spring Cloud 组件应用。 当然这个数量还在一直增加… 三者之间的关系微服务是一种架构的理念，提出了微服务的设计原则，从理论为具体的技术落地提供了指导思想。Spring Boot 是一套快速配置脚手架，可以基于 Spring Boot 快速开发单个微服务；Spring Cloud 是一个基于 Spring Boot 实现的服务治理工具包；Spring Boot 专注于快速、方便集成的单个微服务个体，Spring Cloud 关注全局的服务治理框架。 Spring Boot/Cloud 是微服务实践的最佳落地方案。 实战经历遇到问题，寻找方案2015 年初的时候，因为公司业务的大量发展，我们开始对原有的业务进行拆分，新上的业务线也全部使用独立的项目来开发，项目和项目之间通过 http 接口进行访问。15 年的业务发展非常迅速，项目数量也就相应急剧扩大，到了 15 底的时候项目达 60 多个，当项目数达到 30 几个的时候，其实我们就遇到了问题，经常某个项目因为扩展增加了新的 IP 地址，我们就需要被动的更新好几个相关的项目。服务越来越多，服务之间的调用关系也越来越复杂，有时候想画一张图来表示项目和项目之间的依赖关系，线条密密麻麻无法看清。 这个时候我们就想找一种方案，可以将我们这么多分布式的服务给管理起来，到网上进行了技术调研。我们发现有两款开源软件比较适合我们，一个是 Dubbo，一个是 Spring Cloud。 其实刚开始我们是走了一些弯路的。这两款框架我们当时都不熟悉，当时国内使用 Spring Cloud 进行开发的企业非常的少，我在网上也几乎没找到太多应用的案例。但是 Dubbo 当时在国内的使用还是挺普遍的，相关的资料各方面都比较完善。因此在公司扩展新业务线众筹平台的时候，技术选型就先定了 Dubbo，因为也是全新的业务没有什么负担，这个项目我们大概开发了六个月投产，上线之初也遇到了一些问题，但最终还比较顺利。 在新业务线选型使用 Dubbo 的同时，我们也没有完全放弃 Spring Cloud，我们抽出了一两名开发人员学习 Spring Boot 我也参与其中，为了验证 Spring Boot 是否可以到达实战的标准，我们在业余的时间使用 Spring Boot 开发了一款开源软件云收藏，经过这个项目的实战验证我们对 Spring Boot 就有了信心。最重要的是大家体会到使用 Spring Boot 的各种便利之后，就再也不想使用传统的方式来进行开发了。 但是还有一个问题，在选择了 Spring Boot 进行新业务开发的同时，并没有解决我们上面的那个问题，服务于服务直接调用仍然比较复杂和传统，这时候我们就开始研究 Spring Cloud。因为大家在前期对 Spring Boot 有了足够的了解，因此学习 Sprig Cloud 就显得顺风顺水了。所以在使用 Dubbo 半年之后，我们又全面开始拥抱 Spring Cloud。 为什么选择使用 Spring Cloud 而放弃了 Dubbo可能大家会问，为什么选择了使用 Dubbo 之后，而又选择全面使用 Spring Cloud 呢？其中有几个原因： 1）从两个公司的背景来谈：Dubbo，是阿里巴巴服务化治理的核心框架，并被广泛应用于中国各互联网公司；Spring Cloud 是大名鼎鼎的 Spring 家族的产品。阿里巴巴是一个商业公司，虽然也开源了很多的顶级的项目，但从整体战略上来讲，仍然是服务于自身的业务为主。Spring 专注于企业级开源框架的研发，不论是在中国还是在世界上使用都非常广泛，开发出通用、开源、稳健的开源框架就是他们的主业。 2）从社区活跃度这个角度来对比，Dubbo 虽然也是一个非常优秀的服务治理框架，并且在服务治理、灰度发布、流量分发这方面做的比 Spring Cloud 还好，除过当当网在基础上增加了 rest 支持外，已有两年多的时间几乎都没有任何更新了。在使用过程中出现问题，提交到 github 的 Issue 也少有回复。 相反 Spring Cloud 自从发展到现在，仍然在不断的高速发展，从 github 上提交代码的频度和发布版本的时间间隔就可以看出，现在 Spring Cloud 即将发布 2.0 版本，到了后期会更加完善和稳定。 3) 从整个大的平台架构来讲，dubbo 框架只是专注于服务之间的治理，如果我们需要使用配置中心、分布式跟踪这些内容都需要自己去集成，这样无形中使用 dubbo 的难度就会增加。Spring Cloud 几乎考虑了服务治理的方方面面，更有 Spring Boot 这个大将的支持，开发起来非常的便利和简单。 4）从技术发展的角度来讲，Dubbo 刚出来的那会技术理念还是非常先进，解决了各大互联网公司服务治理的问题，中国的各中小公司也从中受益不少。经过了这么多年的发展，互联网行业也是涌现了更多先进的技术和理念，Dubbo 一直停滞不前，自然有些掉队，有时候我个人也会感到有点可惜，如果 Dubbo 一直沿着当初的那个路线发展，并且延伸到周边，今天可能又是另一番景象了。 Spring 推出 Spring Boot/Cloud 也是因为自身的很多原因。Spring 最初推崇的轻量级框架，随着不断的发展也越来越庞大，随着集成项目越来越多，配置文件也越来越混乱，慢慢的背离最初的理念。随着这么多年的发展，微服务、分布式链路跟踪等更多新的技术理念的出现，Spring 急需一款框架来改善以前的开发模式，因此才会出现 Spring Boot/Cloud 项目，我们现在访问 Spring 官网，会发现 Spring Boot 和 Spring Cloud 已经放到首页最重点突出的三个项目中的前两个，可见 Spring 对这两个框架的重视程度。 总结一下，dubbo 曾经确实很牛逼，但是 Spring Cloud 是站在近些年技术发展之上进行开发，因此更具技术代表性。 如何进行微服务架构演进当我们将所有的新业务都使用 Spring Cloud 这套架构之后，就会出现这样一个现象，公司的系统被分成了两部分，一部分是传统架构的项目，一部分是微服务架构的项目，如何让这两套配合起来使用就成为了关键，这时候 Spring Cloud 里面的一个关键组件解决了我们的问题，就是 Zuul。在 Spring Cloud 架构体系内的所有微服务都通过 Zuul 来对外提供统一的访问入口，所有需要和微服务架构内部服务进行通讯的请求都走统一网关。如下图： 从上图可以看出我们对服务进行了分类，有四种：基础服务、业务服务、组合服务、前置服务。不同服务迁移的优先级不同 基础服务，是一些基础组件，与具体的业务无关。比如：短信服务、邮件服务。这里的服务最容易摘出来做微服务，也是我们第一优先级分离出来的服务。 业务服务，是一些垂直的业务系统，只处理单一的业务类型，比如：风控系统、积分系统、合同系统。这类服务职责比较单一，根据业务情况来选择是否迁移，比如：如果突然有需求对积分系统进行大优化，我们就趁机将积分系统进行改造，是我们的第二优先级分离出来的服务。 前置服务，前置服务一般为服务的接入或者输出服务，比如网站的前端服务、app 的服务接口这类，这是我们第三优先级分离出来的服务。 组合服务，组合服务就是涉及到了具体的业务，比如买标过程，需要调用很多垂直的业务服务，这类的服务我们一般放到最后再进行微服务化架构来改造，因为这类服务最为复杂，除非涉及到大的业务逻辑变更，我们是不会轻易进行迁移。 在这四类服务之外，新上线的业务全部使用 Sprng Boot/Cloud 这套技术栈。就这样，我们从开源项目云收藏开始，上线几个 Spring Boot 项目，到现在公司绝大部分的项目都是在 Spring Cloud 这个架构体系中。 经验和教训架构演化的步骤 在确定使用 Spring Boot/Cloud 这套技术栈进行微服务改造之前，先梳理平台的服务，对不同的服务进行分类，以确认演化的节奏。 先让团队熟悉 Spring Boot 技术，并且优先在基础服务上进行技术改造，推动改动后的项目投产上线 当团队熟悉 Spring Boot 之后，再推进使用 Spring Cloud 对原有的项目进行改造。 在进行微服务改造过程中，优先应用于新业务系统，前期可以只是少量的项目进行了微服务化改造，随着大家对技术的熟悉度增加，可以加快加大微服务改造的范围 传统项目和微服务项目共存是一个很常见的情况，除非公司业务有大的变化，不建议直接迁移核心项目。 服务拆分原则服务拆分有以下几个原则和大家分享 横向拆分。按照不同的业务域进行拆分，例如订单、营销、风控、积分资源等。形成独立的业务领域微服务集群。 纵向拆分。把一个业务功能里的不同模块或者组件进行拆分。例如把公共组件拆分成独立的原子服务，下沉到底层，形成相对独立的原子服务层。这样一纵一横，就可以实现业务的服务化拆分。 要做好微服务的分层：梳理和抽取核心应用、公共应用，作为独立的服务下沉到核心和公共能力层，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求 服务拆分是越小越好吗？微服务的大与小是相对的。比如在初期，我们把交易拆分为一个微服务，但是随着业务量的增大，可能一个交易系统已经慢慢变得很大，并且并发流量也不小，为了支撑更多的交易量，我会把交易系统，拆分为订单服务、投标服务、转让服务等。因此微服务的拆分力度需与具体业务相结合，总的原则是服务内部高内聚，服务之间低耦合。 微服务 vs 传统开发使用微服务有一段时间了，这种开发模式和传统的开发模式对比，有很大的不同。 分工不同，以前我们可能是一个一个模块，现在可能是一人一个系统。 架构不同，服务的拆分是一个技术含量很高的问题，拆分是否合理对以后发展影响巨大。 部署方式不同，如果还像以前一样部署估计累死了，自动化运维不可不上。 容灾不同，好的微服务可以隔离故障避免服务整体 down 掉，坏的微服务设计仍然可以因为一个子服务出现问题导致连锁反应。 给数据库带来的挑战每个微服务都有自己独立的数据库，那么后台管理的联合查询怎么处理？这应该是大家会普遍遇到的一个问题，有三种处理方案。 1）严格按照微服务的划分来做，微服务相互独立，各微服务数据库也独立，后台需要展示数据时，调用各微服务的接口来获取对应的数据，再进行数据处理后展示出来，这是标准的用法，也是最麻烦的用法。 2) 将业务高度相关的表放到一个库中，将业务关系不是很紧密的表严格按照微服务模式来拆分，这样既可以使用微服务，也避免了数据库分散导致后台系统统计功能难以实现，是一个折中的方案。 3）数据库严格按照微服务的要求来切分，以满足业务高并发，实时或者准实时将各微服务数据库数据同步到 NoSQL 数据库中，在同步的过程中进行数据清洗，用来满足后台业务系统的使用，推荐使用 MongoDB、HBase 等。 三种方案在不同的公司我都使用过，第一种方案适合业务较为简单的小公司；第二种方案，适合在原有系统之上，慢慢演化为微服务架构的公司；第三种适合大型高并发的互联网公司。 微服务的经验和建议1、建议尽量不要使用 Jsp，页面开发推荐使用 Thymeleaf。Web 项目建议独立部署 Tomcat，不要使用内嵌的 Tomcat，内嵌 Tomcat 部署 Jsp 项目会偶现龟速访问的情况。 2、服务编排是个好东西，主要的作用是减少项目中的相互依赖。比如现在有项目 a 调用项目 b，项目 b 调用项目 c… 一直到 h，是一个调用链，那么项目上线的时候需要先更新最底层的 h 再更新 g… 更新 c 更新 b 最后是更新项目 a。这只是这一个调用链，在复杂的业务中有非常多的调用，如果要记住每一个调用链对开发运维人员来说就是灾难。 有这样一个好办法可以尽量的减少项目的相互依赖，就是服务编排，一个核心的业务处理项目，负责和各个微服务打交道。比如之前是 a 调用 b，b 掉用 c，c 调用 d，现在统一在一个核心项目 W 中来处理，W 服务使用 a 的时候去调用 b，使用 b 的时候 W 去调用 c，举个例子：在第三方支付业务中，有一个核心支付项目是服务编排，负责处理支付的业务逻辑，W 项目使用商户信息的时候就去调用 “商户系统”，需要校验设备的时候就去调用 “终端系统”，需要风控的时候就调用 “风控系统”，各个项目需要的依赖参数都由 W 来做主控。以后项目部署的时候，只需要最后启动服务编排项目即可。 3、不要为了追求技术而追求技术，确定进行微服务架构改造之前，需要考虑以下几方面的因素：1）团队的技术人员是否已经具备相关技术基础。2）公司业务是否适合进行微服务化改造，并不是所有的平台都适合进行微服务化改造，比如：传统行业有很多复杂垂直的业务系统。3）Spring Cloud 生态的技术有很多，并不是每一种技术方案都需要用上，适合自己的才是最好的。 总结Spring Cloud 对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用 Spring Cloud 一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和 Docker 容器概念的火爆，也会让 Spring Cloud 在未来越来越 “云” 化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前 Servlet 规范的诞生，有效推进服务端软件系统技术水平的进步。 近期我会在 GitChat 分享从架构演进的角度聊聊 Spring Cloud 都做了些什么？，如果你感兴趣也可以来听听。 作者：纯洁的微笑出处：http://www.ityouknow.com/版权所有，欢迎保留原文链接进行转载：) 推荐一个关注spring boot 和 spring cloud 的博客： 纯洁的微笑http://www.ityouknow.com/ 12.2 Spring Cloud 构建微服务架构参考资料：1.https://eacdy.gitbooks.io/spring-cloud-book/content/2.https://springcloud.cc/3.https://springcloud.cc/spring-cloud-netflix-zhcn.html4.http://projects.spring.io/spring-cloud/5.http://www.infoworld.com/article/2878659/application-development/reducing-technical-debt-with-microservices.html6.http://blog.csdn.net/stubborn_cow/article/details/502875977.http://www.javacodegeeks.com/2015/04/microservices-monoliths-and-noops.html8.http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-029.https://www.oschina.net/news/70121/microservice]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式微服务之 spring boot]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-7%2F</url>
    <content type="text"><![CDATA[一、导览本文主要介绍以下几部分：1. 什么是 spring Boot?2. 为什么使用 Spring Boot?3. Spring Boot 提供哪些功能？4. Spring Boot 有哪些模块？5. 如何使用 Spring Boot？6. Spring Boot 有哪些不足？ 二、什么是 Spring Boot?Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式 (继承 starter，约定优先于配置) 来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot 致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。Spring Boot 并不是一个框架，从根本上将，它就是一些库的集合，maven 或者 gradle 项目导入相应依赖即可使用 Spring Boot，而且无需自行管理这些库的版本。目前最新的稳定版本是 1.3.6.RELEASE，github 地址：https://github.com/spring-projects/spring-boot 三、为什么使用 Spring Boot?Spring Boot 是为简化 Spring 项目配置而生，使用它使得 jar 依赖管理以及应用编译和部署更为简单。Spring Boot 提供自动化配置，使用 Spring Boot，你只需编写必要的代码和配置必须的属性。使用 Spring Boot，只需 20 行左右的代码即可生成一个基本的 Spring Web 应用，并且内置了 tomcat，构建的 fat Jar 包通过 Java -jar 就可以直接运行。如下特性使得 Spring Boot 非常契合微服务的概念，可以结合 Spring Boot 与 Spring Cloud 和 Docker 技术来构建微服务并部署到云端： 一个可执行 jar 即为一个独立服务 很容易加载到容器，每个服务可以在自己的容器（例如 docker）中运行 通过一个脚本就可以实现配置与部署，很适合云端部署，并且自动扩展也更容易 简单而言，即 Spring Boot 使编码更简单，使配置更简单，使部署更简单，使监控更简单。 四、Spring Boot 提供哪些功能？1. 无需手动管理依赖 jar 包的版本Spring boot 通过 spring boot starter 项目管理其提供的所有依赖的版本，当升级 spring boot 时，这些依赖的版本也会随之升级。个人无需指定版本号，但是也可以自定义版本号覆盖 spring boot 的默认值。每个版本的 boot 都有对应的 base spring version，不建议明确地指定 spring 版本。例如，使用 maven 时，只需简单的在 pom 中包含 spring-boot-starter-web 即引入了 Spring MVC 和 Tomcat 的依赖。下面是 Spring Boot 在 org.springframework.boot 组下提供的一些 Starters： 名称 描述 spring-boot-starter 核心 Spring Boot starter，包括自动配置支持，日志和 YAML spring-boot-starter-actuator 生产准备的特性，用于帮你监控和管理应用 spring-boot-starter-web 对全栈 web 开发的支持，包括 Tomcat 和 spring-webmvc spring-boot-starter-aop 对面向切面编程的支持，包括 spring-aop 和 AspectJ spring-boot-starter-data-jpa 对”Java 持久化 API” 的支持，包括 spring-data-jpa ， spring-orm 和 Hibernate spring-boot-starter-jdbc 对 JDBC 数据库的支持 spring-boot-starter-security 对 spring-security 的支持 1.1 starter poms每个 starter 都包含特定的依赖集，并且都遵循统一的命名模式：spring-boot-starter-*。 如何修改依赖的版本？1. 如果你使用 Maven 进行一个直接或间接继承 spring-boot-dependencies （比如 spring-boot-starter-parent ）的构建，并想覆盖一个特定的第三方依赖，那你可以添加合适的 properties 元素。浏览 spring-boot-dependencies POM 可以获取一个全面的属性列表。例如，想要选择一个不同的 slf4j 版本，你可以添加以下内容： &lt;slf4j.version&gt;1.7.5&lt;slf4j.version&gt;2. 如果你使用 import 将 spring-boot-dependencies 添加到自己的 dependencyManagement 片段，那你必须自己重新定义 artifact 而不是覆盖属性。※ 每个 Spring Boot 发布都是基于一些特定的第三方依赖集进行设计和测试的，覆盖版本可能导致兼容性问题。 1.2 spring-boot-starter-parent 提供的特性 默认的编译级别是 java1.6 source 编码是 UTF-8 一个 dependency management 区域，继承自 spring-boot-dependencies POM。用户可以省略普通依赖的 标签。 资源过滤 （maven 中的 filter）。 插件配置（exec, surefile, git commit ID, shade） 针对 application.properties 和 application.yml 的资源过滤。※ 因为默认的配置文件接受 spring 表达式 ${}，因此 maven 的资源过滤符号被修改为 @..@。可使用 maven 属性 resource.delimiter 来修改。 2. 自动配置，无需 xmlSpring Boot 尝试根据你添加的 jar 依赖自动配置你的应用。例如，如果 HSQLDB 在类路径中，并且你没有手动配置任何 db 连接 bean，则 Spring Boot 会自动配置一个内存 db。使用 @EnableAutoConfiguration 或者 @SpringBootApplication 注解，配合 @Configuration 注解类，即可达到自动配置的目的。Spring Boot 的这种自动配置是非侵入式的，你可以定义自己的配置或 bean 来替代自动配置的内容。 3. 可执行 jar 包Spring Boot 默认将应用打包成一个可执行的 jar 包文件，构建成功后使用 java -jar 命令即可运行应用。Java 并没有提供任何标准的方式来加载 jar 包中内嵌的 jar 包。一般开发者使用影子 jar 技术来解决这种问题。一个影子 jar 只是简单的将所有 jar 的类打包到一个单独的超级 jar 包中。由此带来的问题是它很难分辨在你的应用中实际可以使用哪些库，并且多个 jar 文件中的同名文件也是一个问题。Spring Boot 则另辟蹊径，使用如下文件格式让你能够直接嵌套 jar 包：依赖需要放到内部的 lib 文件夹下。 Spring Boot 可执行 jar 的原理是什么？Spring Boot 用于支持加载内嵌 jars 的核心类是 org.springframework.boot.loader.jar.JarFile（继承自 java.util.jar.JarFile） 。它允许你从一个标准的 jar 文件或内嵌的子 jar 数据中加载 jar 内容。当首次加载的时候，每个 JarEntry 的位置被映射到一个偏移于外部 jar 的物理文件：上面的示例展示了如何在 myapp.jar 的 0063 处找到 A.class。来自于内嵌 jar 的 B.class 实际可以在 myapp.jar 的 3452 处找到，C.class 可以在 3980 处找到。 4. 外部化配置Spring Boot 可以使用 properties 文件，YAML 文件，环境变量，命令行参数等来外部化配置。属性值可以使用 @Value 注解直接注入到 bean 中，并通过 Spring 的 Environment 抽象或经过 @ConfigurationProperties 注解绑定到结构化对象来访问。例子：YAML 配置文件内容：使用 @Value 注解注入单个属性：使用 @ConfigurationProperties 注入属性组： 5. 嵌入式 servlet 容器Spring Boot 的 web 模块内置嵌入的 Tomcat, Jetty, Undertow 来构建自包含的 Servlet 容器。web 应用打包成可执行 jar 包时，相应的 servlet 容器也会被嵌入到应用 jar 中。并且 servlets, filters 和 listeners 都可以通过声明为 bean 来被容器注册。servlet 容器还可以通过外部化配置来相关定制属性，如 server.port, server.session.persistence 等。 6. 无缝集成 Spring security，Spring data, Spring Message 等Spring Boot 通过 stater pom 来导入这些依赖，当发现相关 jar 在 classpath 中时，Spring Boot 将启动相应的自动配置。例如，如果 security 的 jar 在 classpath 中，Spring Boot 的 web 应用将自动启动安全限制，并且默认启动 basic 认证（默认用户名是 user，密码在启动 log 里会显示）。后面教程里会演示 Spring jpa，Spring DATA REST，Spring Security 的集成。 7.devtools 提供的开发时特性Spring Boot 的 devtools 模块可以为应用增加开发时（development time）特性，例如开发环境属性默认值，自动重启，LiveReload（在自愿发生变化时触发浏览器刷新），全局设置等。 7.1 开启 devtools 特性pom 中引入 spring-boot-devtools 依赖即可打开 devtools 特性。developer tools 在运行完整的 packaged app 时是自动关闭的，即若使用 java –jar 时会被当做生产应用。安全起见，可以在 maven 中增加 excludeDevtools 编译属性来移除 jar 包。 7.2 devtools 的自动重启要想在 Eclipse 中使用 Devtools 的重启功能，需要将自动编译功能打开。每次保存文件并自动编译后，devtools 会检测到 classpath 内容的修改，并触发应用重启。重启时实际只重新加载了一部分类，因此速度会非常快。详细原理会在后面教程里介绍。 7.3 devtools 的 livereload开启 devtools 特性的应用在启动时会启动一个 livereload 的 server，在浏览器（如 chrome，Firefox）安装 livereload 插件后，该插件会监测到 livereload server 的更新，并自动刷新页面。详细介绍会在后面教程里介绍。 8.Actuator 提供的生产特性（health，metrics 等）Actuator 是个机器术语，目前没有统一的翻译，可以直译为促动器或执行器，Actuator 通过微小的改变就可以产生很大的移动。Spring Boot Actuator 为你的应用提供一些生产环境必需的特性，如审计 (audit)，健康(health) 和数据采集 (metrics) 等。使你可以在部署应用到生产环境后，通过 HTTP（需要 SpringMVC），JMX 甚至 remote shell(SSH, Telnet)等来管理和监视应用。例如，HTTP 环境下，访问 contextUrl/health 路径即可查询当前环境的磁盘空间，应用和数据库的状态等；访问 contextUrl/metrics 路径即可查询当前 jvm 的内存使用情况，线程池的状态等。 五、Spring Boot 各模块介绍Spring Boot 由一些模块构成，如 spring-boot, spring-boot-autoconfigure, spring-boot-starters, spring-boot-cli, spring-boot-actuator 等。下面简单介绍以下各模块。 1. spring-boot主库，为其他模块提供特性支持。包括以下内容：SpringApplication 类，提供静态方法，方便编写独立运行的 Spring 应用。唯一的任务是创建和刷新一个合适的 Spring ApplicationContext。嵌入式 web 应用，自带容器 (Tomcat, Jetty 等)。 2. spring-boot-autoconfigureSpring Boot 可以基于 classpath 下的内容配置通用应用的大部分模块。一个 @EnableAutoConfiguration 注解触发 Spring 上下文的自动配置。自动配置尝试推测用户可能需要的 bean。例如，如果 H2DB 在 classpath 中，但是用户没有配置任何 db 连接，那么 spring-boot-autoconfigure 推断用户需要一个 in-memory 的 db，因此自动配置为用户配置（默认创建的 h2db 的 db 名为 testdb, 用户名为 sa，密码无）。自动配置优先级低于用户自定义的 bean。 3. spring-boot-startersstarters 是一系列便利的依赖描述，用户可以增加到应用中，并由此取得 Spring 和相关技术的一站式配置体验，无需查看 sample 代码并贴来贴去。例如，若用户想要使用 Spring 和 JPA 来访问 db，则只需包含 spring-boot-starter-data-jpa 依赖到 pom 中即可。 4. spring-boot-cliSpring 的命令行应用，编译和运行 Groovy 源码，只需极少的代码就可以运行应用，Spring CLI 还可以监视文件，在它们改变时自动重新编译和重启。 5. spring-boot-actuatorspring boot actuator 提供额外的自动配置，为你的应用装饰一些特性，使应用在生产环境下也可以快速部署和支持。例如，若你正在编写一个 JSON web 服务，该模块会提供一个服务器，安全，日志，外部化配置，管理端点 (management endpoints)，评审等。关闭这些内建特性，或者扩展或替代它们都很容易。 6. spring-boot-loaderSpring Boot Loader 提供秘籍允许你构建可用 java –jar 直接运行的 jar 包。一般无需直接使用 spring-boot-loader, 而是通过 Gradle 或 Maven 插件使用。 六、如何使用 Spring Boot?1. 系统要求默认情况下，Spring Boot 1.3.6.RELEASE 需要 Java7 和 Spring 框架 4.2.7.RELEASE 或以上。你可以在 Java6 下使用 Spring Boot，不过需要添加额外配置。明确支持的构建工具是 Maven（3.2+）和 Gradle（1.12+）。注：尽管你可以在 Java6 或 Java7 环境下使用 Spring Boot，通常我们建议你如果可能的话就使用 Java8。 2. 内嵌 Servlet 容器要求下列内嵌容器在满足对应的 Servlet 和 JDK 版本要求时，支持开箱即用（out of the box）： 名称 Servlet 版本 Java 版本 Tomcat 8 3.1 Java7+ Tomcat 7 3.0 Java6+ Jetty 9 3.1 Java7+ Jetty 8 3.0 Java6+ Undertow 1.1 3.1 Java7+ ※ Undertow 是一个采用 Java 开发的灵活的高性能 Web 服务器，提供包括阻塞和基于 NIO 的非堵塞机制。Undertow 是红帽公司的开源产品，是 Wildfly 默认的 Web 服务器。 你也可以将 Spring Boot 应用部署到任何兼容 Servlet 3.0 + 的容器。 3. 使用 Spring Boot3.1 直接在 Spring Boot CLI 上运行，或者在 http://start.spring.io/ 上构建。3.2 Eclipse 上使用 Spring IDE 插件提供的 New -&gt; Spring Stater Project 菜单。此方法和 3.1 中的 start.spring.io 是一样的。 3.3 Maven 的 pom 直接继承 spring-boot-starter-parent。Spring Boot 依赖的 groupId 为 org.springframework.boot 。通常你的 Maven POM 文件需要继承 spring-boot-starter-parent ，然后声明一个或多个 “Starter POMs” 依赖。典型的 spring boot 项目的 pom 文件结构如下所述： 3.4 不使用继承，使用 importScope=import 可以使你无需继承 spring-boot-starter-parent，而又保留 spring-boot-starter-parent 提供的依赖管理（插件管理除外）： ※ 除了 3.4 以外，3.1 到 3.3 最终形成的 pom 文件和项目结构是一样的。 七、Spring Boot 有哪些不足？如图所示，Spring Boot 没有提供相应的服务发现和注册的配套功能（例如需要借助 Spring Cloud 和 Netflix 的 Eureka），自身的 Actuator 所提供的监控功能，也需要与现有的监控对接。没有配套的安全管控方案，对于 REST 的落地，还需要自行结合实际进行 URI 的规范化工作。可见 Spring Boot 作为一个微框架，离微服务的实现还是有些距离的。 参考：Spring-boot介绍 - CSDN博客https://blog.csdn.net/tanga842428/article/details/54425387]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式微服务]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-3%2F</url>
    <content type="text"><![CDATA[推荐一个关注spring boot 和 spring cloud 的博客： 纯洁的微笑http://www.ityouknow.com/ 对微服务的详解： Martin Fowler的《微服务》 · 微服务学习笔记https://skyao.gitbooks.io/learning-microservice/content/definition/Martin-Fowler/microservices.html 分布式微服务随着 RESTful web 服务和 JSON 数据交换格式流行，简单快速建立一个可连接的服务已经越来越方便了。随着持续交付概念推广以及 Docker 容器普及，微服务将这两种理念和技术结合起来，形成新的微服务 + API + 平台的开发模式，以及容器化微服务的持续交付概念。 如何理解持续集成、持续交付、持续部署？ 集成是指软件个人研发的部分向软件整体部分交付，以便尽早发现个人开发部分的问题； 部署是代码尽快向可运行的开发/测试节交付，以便尽早测试； 交付是指研发尽快向客户交付，以便尽早发现生产环境中存在的问题。 如果说等到所有东西都完成了才向下个环节交付，导致所有的问题只能再最后才爆发出来，解决成本巨大甚至无法解决。而所谓的持续，就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整。使得问题不会放大到其他部分和后面的环节。这种做法的核心思想在于：既然事实上难以做到事先完全了解完整的、正确的需求，那么就干脆一小块一小块的做，并且加快交付的速度和频率，使得交付物尽早在下个环节得到验证。早发现问题早返工。——————–补充：从敏捷思想中提出的这三个观点，还强调一件事：通过技术手段自动化这三个工作。加快交付速度。作者：赵劼链接：https://www.zhihu.com/question/23444990/answer/26995938来源：知乎 微服务 (micro services) 这个概念不是新概念，很多公司已经在实践了，例如亚马逊、Google、FaceBook，Alibaba。微服务架构模式 (Microservices Architecture Pattern) 的目的是将大型的、复杂的、长期运行的应用程序构建为一组相互配合的服务，每个服务可以独立迭代开发运维。 Micro 这个词意味着每个服务都应该足够小，但是，这里的小不能用代码量来比较，而应该是从业务逻辑上比较——符合 “单一职责模式”（SRP）原则的才叫微服务。 单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 来源：面向对象设计原则之单一职责原则 · 设计模式Java版https://quanke.gitbooks.io/design-pattern-java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99.html 分布式的、去中心化的。Smart endpoints and dumb pipes, 本质就是去 ESB，把所有的 “思考” 逻辑包括路由、消息解析等放在服务内部（Smart endpoints），去掉一个大一统的 ESB，服务间轻（dumb pipes）通信，是比 SOA 更彻底的拆分。 要搞微服务架构，先要搞定 RPC 框架。 12.1 微服务架构先来看看传统的 web 开发方式，通过对比比较容易理解什么是 Microservice Architecture。和 Microservice 相对应的，这种方式一般被称为 Monolithic（比较难传神的翻译）。所有的功能打包在一个 WAR 包里，基本没有外部依赖（除了容器），部署在一个 JEE 容器（Tomcat，JBoss，WebLogic）里，包含了 DO/DAO，Service，UI 等所有逻辑。 Monolithic 比较适合小项目，优点是： 开发简单直接，集中式管理 基本不会重复开发 功能都在本地，没有分布式的管理开销和调用开销 它的缺点也非常明显，特别对于互联网公司来说： 开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断 代码维护难：代码功能耦合在一起，新人不知道何从下手 部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长 稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉 扩展性不够：无法满足高并发情况下的业务需求 于是诞生了基于微服务的架构。简单来说， 微服务的目的是有效的拆分应用，实现敏捷开发和部署 。 SOA 简述早在 1996 年，Gartner 就提出面向服务架构（SOA）。SOA 阐述了 “对于复杂的企业 IT 系统，应按照不同的、可重用的粒度划分，将功能相关的一组功能提供者组织在一起为消费者提供服务”，其目的是为了解决企业内部不同 IT 资源之间无法互联而导致的信息孤岛问题。 2002 年，SOA 被称作 “现代应用开发领域最重要的课题之一”，其正在帮助企业从资源利用的角度出发，将 IT 资源整合成可操作的、基于标准的服务，使其能被重新组合和应用。 但是，由于 SOA 本身的广义性以及抽象性，在其诞生的相当长一段时间内，人们对 SOA 存在着不同的认知和理解。 到 2000 年左右，ESB(Enterprise Service Bus)、WebService、SOAP 等这类技术的出现，才使得 SOA 渐渐落地。同时，更多的厂商像 IBM、Oracle 等也分别提出基于 SOA 的解决方案或者产品。 实际上，微服务架构并不是一个全新的概念。仔细分析 SOA 的概念，就会发现，其和我们今天所谈到的微服务思想几乎一致。那在 SOA 诞生这么多年后，为什么又提出了微服务架构呢？ 鉴于过去十几年互联网行业的高速发展，以及敏捷、持续集成、持续交付、DevOps，云技术等的深入人心，服务架构的开发、测试、部署以及监控等，相比我们提到的传统的 SOA 实现，已经大相径庭，主要区别如下表所示： SOA 实现 微服务架构实现 企业级，自顶向下开展实施 团队级，自底向上开展实施 服务由多个子系统组成，粒度大 一个系统被拆分成多个服务，粒度细 企业服务总线，集中式的服务架构 无集中式总线，松散的服务架构 集成方式复杂（ESB/WS/SOAP） 集成方式简单（HTTP/REST/JSON） 单块架构系统，相互依赖，部署复杂 服务都能独立部署 相比传统 SOA 的服务实现方式，微服务更具有灵活性、可实施性以及可扩展性，其强调的是一种独立测试、独立部署、独立运行的软件架构模式。 微服务是什么？ 在 CPU 处理器的指令集中，有 CISC 与 RISC。在操作系统中，有宏内核与微内核。 微服务，本质是一个系统架构解耦的过程。它是把一个大型复杂系统服务 M（Monolithic Architecture，整体式架构）拆分成多个相对简单独立的子系统的服务 MS（Microservice Architecture, 微服务架构）ms1, ms2, ms3, … 。 系统中的各个微服务可被独立部署，各个微服务之间松耦合。之前整体的系统服务 M，在 MS 中通过微服务提供的 API 交互完成。API 之间的通信由 RPC 框架来完成。 这个思想理念，跟 UNIX 哲学理念—— 小是美的。（Small is Beautiful） 是相通的。 另外，不同的微服务 MS 可以使用不同的技术架构，比如 Node.js ，Java， Ruby， Python 等等，这些单个的服务都可以独立完成交付生命周期。 我们最早使用传统的整体式架构应用开发系统，如 CRM、ERP 等大型应用，可能会遇到以下的一些问题： 1. 随着新需求的不断增加，更新和迭代大型的整体式应用会变得越来越困难； 2. 随着移动互联网的快速发展，要求我们能够实现功能的快速迭代上线； 3. 但对于快速变化的需求，受到整体式应用架构的限制，有时候显得力不从心； 此外，大量开源轻量级技术不断涌现并日渐成熟： 轻量级运行时技术的出现 (node.js, WAS Liberty 等)； 新的思想方法论与工具 (Agile, DevOps, TDD, CI, XP, Puppet, Chef…)； 新的轻量级协议 (RESTful API 接口, 轻量级消息机制)； 简化的基础设施：操作系统虚拟化, 容器化 (e.g. Docker), 基础设施即服务 (IaaS), 工作负载虚拟化(Kubernetes,Spark…) 等； 服务平台化 (PaaS)： 云服务平台上具有自动缩放、工作负载管理、SLA 管理、消息机制、缓存、构建管理等各种按需使用的服务； 新的可替代数据持久化模型：如 NoSQL, MapReduce, BASE, CQRS 等； 标准化代码管理，如：Gitlab 等。 这一切都催生了新的架构设计风格 – 微服务架构的出现。 在整体式架构应用中，我们将所有功能都打成一个包，可以是 JAR、WAR、EAR 或其它归档格式，然后，直接运行它，或者丢到一个容器（例如 Tomcat）里跑。 整体式架构应用的一些不足： 不够灵活：对应用程序做任何细微的修改都需要将整个应用程序重新构建、重新部署。开发人员需要等到整个应用程序部署完成后才能看到变化。如果多个开发人员共同开发一个应用程序，那么还要等待其他开发人员完成了各自的开发。这降低了团队的灵活性和功能交付频率； 妨碍持续交付：单体应用可能会比较大，构建和部署时间也相应地比较长，不利于频繁部署，阻碍持续交付。在移动应用开发中，这个问题会显得尤为严重； 受技术栈限制：对于这类应用，技术是在开发之前经过慎重评估后选定的，每个团队成员都必须使用相同的开发语言、持久化存储及消息系统，而且要使用类似的工具，无法根据具体的场景做出其它选择； 技术债务：“不坏不修（Not broken，don’t fix）”，这在软件开发中非常常见，单体应用尤其如此。系统设计或写好的代码难以修改，因为应用程序的其它部分可能会以意料之外的方式使用它。随着时间推移、人员更迭，这必然会增加应用程序的技术债务。 而随着业务需求的快速发展变化，敏捷性、灵活性和可扩展性需求不断增长，迫切需要一种更加快速高效的软件交付方式。于是，微服务架构应运而生。（当然，如果你没有遇到诸如上面的问题，你可能也就用不到微服务的架构了。） 这里的 “微” 不是针对代码行数而言，而是说服务的范围限定到单个功能。 微服务特点 康威定律：任何设计系统的组织，最终产生的设计等同于组织之内、之间的沟通结构。系统架构的设计符合组织沟通结构取得的收益最大。 微服务有如下特点： 小, 且专注于做⼀件事情 进程独立 轻量级的通信机制 松耦合 独立部署 领域驱动设计：应用程序功能分解可以通过 Eric Evans 在《领域驱动设计》中明确定义的规则实现；每个团队负责与一个领域或业务功能相关的全部开发；团队拥有全系列的开发人员，具备用户界面、业务逻辑和持久化存储等方面的开发技能； 单一职责原则：每个服务应该负责该功能的一个单独的部分，这是 SOLID) 原则之一； 明确发布接口：每个服务都会发布一个定义明确的接口，而且保持不变；服务消费者只关心接口，而对于被消费的服务没有任何运行依赖； 独立部署、升级、扩展和替换：每个服务都可以单独部署及重新部署而不影响整个系统。这使得服务很容易升级，每个服务都可以沿着《Art of Scalability》一书定义的 X 轴和 Z 轴进行扩展； 可以异构 / 采用多种语言：每个服务的实现细节都与其它服务无关，这使得服务之间能够解耦，团队可以针对每个服务选择最合适的开发语言、持久化存储、工具和方法； 轻量级通信：服务通信使用轻量级的通信协议，例如，同步的 REST，异步的 AMQP、STOMP、MQTT 等。 微服务架构的思想本质跟互联网的思想是一致的。它的组件对外发布的服务视同 HTTP 协议，采用 HTTP Rest API 的方式来进行。很多开放平台的 API 服务，基本都采用了 Http API 的方式进行服务的发布和管理。 Fictitious e-commerce application Let’s imagine that you are building an e-commerce application that takes orders from customers, verifies inventory and available credit, and ships them. The application consists of several components including the StoreFrontUI, which implements the user interface, along with some backend services for checking credit, maintaining inventory and shipping orders. The application consists of a set of services. 基于微服务的架构, 目的是有效的拆分应用，实现敏捷开发和部署 。 服务之间如何通信？ 因为所有的微服务都是独立的 Java 进程跑在独立的虚拟机上，所以服务间的通行就是 IPC（inter process communication），最通用的有两种方式： 同步调用 REST（JAX-RS，Spring Boot） RPC（Thrift, Dubbo） 异步消息调用Kafka， Notify， MetaQ 微服务优点相应地，微服务具有如下优点： 迭代开发灵活，快速适应需求变化（前提是，得架构良好才行）； 局部修改很容易部署，有利于持续集成和持续交付； 故障隔离，一个服务出现问题不会影响整个应用； 技术栈自由。 随着持续交付概念推广以及 Docker 容器普及，微服务将这两种理念和技术结合起来，形成新的微服务 + API + 平台的开发模式，提出了容器化微服务的持续交付概念。 传统 Monolithic 的 DevOps 开发队伍方式，如下图： 这种整体型架构要求产品队伍横跨产品管理 Dev 开发 QA DBA 以及系统运营管理，而微服务架构引入以后，如下图： 微服务促进了 DevOps 方式的重组，将一个大臃肿的整体产品开发队伍切分为根据不同微服务的划分的产品队伍，以及一个大的整体的平台队伍负责运营管理，两者之间通过 API 交互，做到了松耦合隔绝。 由于 Docker 引入，不同的微服务可以使用不同的技术架构，比如 Node.js Java Ruby Python 等等，这些单个的服务都可以独立完成交付生命周期，如下： 微服务缺点微服务看上去像一枚银弹，可以解决许多软件开发方面的问题。这看上去很美好，但并不易于实现。微服务会极大地增加运维工作量，使用微服务，一些技术债务势必从开发转到运维，因此，你最好有一个一流的开发运维团队。 总体来看，微服务架构可能带来过多的操作。缺点如下： 分布式系统可能复杂难以管理。 分布式部署跟踪解决问题难。 当服务数量增加，管理复杂性增加。 系统部署依赖（DevOps） 服务间通信成本（RPC 框架） 数据一致性 系统集成测试 系统监控等。 当然，这是一个循序渐进的重构的过程。 因此，微服务对基础设施提出了一些额外的需求。通常，我们将它们总称为 NoOps，本质上讲，就是一组服务，提供一个更好的应用程序部署流程并确保其运行，包括服务复制、服务发现、服务恢复和服务监控等。 服务化的一个好处就是，不限定服务的提供方使用什么技术选型，能够实现大公司跨团队的技术解耦，如下图： 服务 A 是欧洲团队提供服务，欧洲团队的技术背景是 Java，可以用 Java 实现服务;服务 B 是美洲团队提供服务，可以用 C++ 实现服务;服务 C 是中国团队提供服务，可以用 Go 实现服务;服务的上游调用方，按照接口、协议即可完成对远端服务的调用。但实际上，99.9% 的公司的团队规模有限，技术团队人数也有限，基本是使用同一套技术体系来调用和提供服务的：这样的话，如果没有统一的服务框架，RPC 框架，各个团队的服务提供方就需要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理、状态机等 “业务之外” 的重复技术劳动，造成整体的低效。所以，统一 RPC 框架把上述 “业务之外” 的技术劳动统一处理，是服务化首要解决的问题。 六种微服务架构简单介绍六种微服务架构模式 [7]。 聚合器微服务设计模式这是一种最常用也最简单的设计模式，如下图所示： 聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的 Web 页面，将检索到的数据进行处理展示。它也可以是一个更高层次的组合微服务， 对检索到的数据增加业务逻辑后进一步发布成一个新的微服务，这符合 DRY 原则。另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它 也有自己的缓存和数据库。聚合器可以沿 X 轴和 Z 轴独立扩展。 代理微服务设计模式这是聚合器模式的一个变种，如下图所示： 在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。 链式微服务设计模式这种模式在接收到请求后会产生一个经过合并的响应，如下图所示： 在这种情况下，服务 A 接收到请求后会与服务 B 进行通信，类似地，服务 B 会同服务 C 进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。因此，服务调用链不宜过长，以免客户端长时间等待。 分支微服务设计模式这种模式是聚合器模式的扩展，允许同时调用两个微服务链，如下图所示： 数据共享微服务设计模式自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的 “单体应用（monolithic application）” 时，SQL 数据库反规范化可能会导致数据重复和不一致。因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式，如下图所示： 在这种情况下，部分微服务可能会共享缓存和数据库存储。不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式。 异步消息传递微服务设计模式虽然 REST 设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替 REST 请求 / 响应，如下图所示： 原文：第12章 Spring Boot与微服务 - 简书https://www.jianshu.com/p/572f264d0bb5]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式协调服务之 zookeeper]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-2%2F</url>
    <content type="text"><![CDATA[Zookeeper 简介ZooKeeper（动物园管理员），顾名思义，是用来管理Hadoop（大象）、Hive（蜜蜂）、Pig（小猪）的管理员，同时Apache HBase、Apache Solr、LinkedIn Sensei等众多项目中都采用了ZooKeeper。 ZooKeeper曾是Hadoop的正式子项目，后发展成为Apache顶级项目，与Hadoop密切相关但却没有任何依赖。它是一个针对大型应用提供高可用的数据管理、应用程序协调服务的分布式服务框架，基于对Paxos算法的实现，使该框架保证了分布式环境中数据的强一致性，提供的功能包括：配置维护、统一命名服务、状态同步服务、集群管理等。 ZooKeeper 是一个开源的分布式协调服务，由雅虎创建，是 Google Chubby 的开源实现。ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。 ZooKeeper 是一个典型的分布式数据一致性的解决方案。分布式应用程序可以基于它实现诸如数据发布 / 订阅、负载均衡、命名服务、分布式协调 / 通知、集群管理、Master 选举、分布式锁和分布式队列等功能。ZooKeeper 可以保证如下分布式一致性特性。 顺序一致性从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到 ZooKeeper 中。 原子性所有事务请求的结果在集群中所有机器上的应用情况是一致的，也就是说要么整个集群所有集群都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。 单一视图无论客户端连接的是哪个 ZooKeeper 服务器，其看到的服务端数据模型都是一致的。 可靠性一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。 实时性通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper 仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。 Zookeeper 基本概念zk 角色Zookeeper 中的角色主要有以下三类，如下表所示： zk service 网络结构Zookeeper 的工作集群可以简单分成两类，一个是 Leader，唯一一个，其余的都是 follower，如何确定 Leader 是通过内部选举确定的。 Leader 和各个 follower 是互相通信的，对于 zk 系统的数据都是保存在内存里面的，同样也会备份一份在磁盘上。对于每个 zk 节点而言，可以看做每个 zk 节点的命名空间是一样的，也就是有同样的数据。（可查看下面的树结构） 如果 Leader 挂了，zk 集群会重新选举，在毫秒级别就会重新选举出一个 Leaer。 集群中除非有一半以上的 zk 节点挂了，zk service 才不可用。 zk 命名空间结构Zookeeper 的命名空间就是 zk 应用的文件系统，它和 linux 的文件系统很像，也是树状，这样就可以确定每个路径都是唯一的，对于命名空间的操作必须都是绝对路径操作。与 linux 文件系统不同的是，linux 文件系统有目录和文件的区别，而 zk 统一叫做 znode，一个 znode 节点可以包含子 znode，同时也可以包含数据。 提示：比如 / Nginx/conf，/ 是一个 znode，/Nginx 是 / 的子 znode，/Nginx 还可以包含数据，数据内容就是所有安装 Nginx 的机器 IP，/Nginx/conf 是 / Nginx 子 znode，它也可以包含内容，数据就是 Nginx 的配置文件内容。在应用中，我们可以通过这样一个路径就可以获得所有安装 Nginx 的机器 IP 列表，还可以获得这些机器上 Nginx 的配置文件。 zk 读写数据 写数据，但一个客户端进行写数据请求时，会指定 zk 集群中节点，如果是 follower 接收到写请求，就会把请求转发给 Leader，Leader 通过内部的 Zab 协议进行原子广播，直到所有 zk 节点都成功写了数据后（内存同步以及磁盘更新），这次写请求算是完成，然后 zk service 就会给 client 发回响应 读数据，因为集群中所有的 zk 节点都呈现一个同样的命名空间视图（就是结构数据），上面的写请求已经保证了写一次数据必须保证集群所有的 zk 节点都是同步命名空间的，所以读的时候可以在任意一台 zk 节点上 ps: 其实写数据的时候不是要保证所有 zk 节点都写完才响应，而是保证一半以上的节点写完了就把这次变更更新到内存，并且当做最新命名空间的应用。所以在读数据的时候可能会读到不是最新的 zk 节点，这时候只能通过 sync() 解决。这里先不考虑了，假设整个 zk service 都是同步 meta 信息的，后面的文章再讨论。 zk znode 类型Zookeeper 中 znode 的节点创建时候是可以指定类型的，主要有下面几种类型。 PERSISTENT：持久化 znode 节点，一旦创建这个 znode 点存储的数据不会主动消失，除非是客户端主动的 delete。 SEQUENCE：顺序增加编号 znode 节点，比如 ClientA 去 zk service 上建立一个 znode 名字叫做 / Nginx/conf，指定了这种类型的节点后 zk 会创建 / Nginx/conf0000000000，ClientB 再去创建就是创建 / Nginx/conf0000000001，ClientC 是创建 / Nginx/conf0000000002，以后任意 Client 来创建这个 znode 都会得到一个比当前 zk 命名空间最大 znode 编号 + 1 的 znode，也就说任意一个 Client 去创建 znode 都是保证得到的 znode 是递增的，而且是唯一的。 EPHEMERAL：临时 znode 节点，Client 连接到 zk service 的时候会建立一个 session，之后用这个 zk 连接实例创建该类型的 znode，一旦 Client 关闭了 zk 的连接，服务器就会清除 session，然后这个 session 建立的 znode 节点都会从命名空间消失。总结就是，这个类型的 znode 的生命周期是和 Client 建立的连接一样的。比如 ClientA 创建了一个 EPHEMERAL 的 / Nginx/conf0000000011 的 znode 节点，一旦 ClientA 的 zk 连接关闭，这个 znode 节点就会消失。整个 zk service 命名空间里就会删除这个 znode 节点。 PERSISTENT|SEQUENTIAL：顺序自动编号的 znode 节点，这种 znoe 节点会根据当前已经存在的 znode 节点编号自动加 1，而且不会随 session 断开而消失。 EPHEMERAL|SEQUENTIAL：临时自动编号节点，znode 节点编号会自动增加，但是会随 session 消失而消失 Zookeeper 设计目的 最终一致性：client 不论连接到哪个 Server，展示给它都是同一个视图，这是 zookeeper 最重要的性能。 可靠性：具有简单、健壮、良好的性能，如果消息 m 被到一台服务器接受，那么它将被所有的服务器接受。 实时性：Zookeeper 保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper 不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用 sync() 接口。 等待无关（wait-free）：慢的或者失效的 client 不得干预快速的 client 的请求，使得每个 client 都能有效的等待。 原子性：更新只能成功或者失败，没有中间状态。 顺序性：包括全局有序和偏序两种：(全序是相对于zookeeper服务端对外来说，偏序是客户端提交相对于zookeeper服务端来说，总之zookeeper要保证操作的串行执行。)全局有序是指如果在一台服务器上消息 a 在消息 b 前发布，则在所有 Server 上消息 a 都将在消息 b 前被发布；偏序是指如果一个消息 a在消息 b 前被同一个发送者发布，在该Server上 a 必将排b 前面。 Zookeeper 工作原理Zookeeper 的核心是广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。 Zab 协议有两种模式，它们分别是恢复模式（选主）和广播 模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后， 恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。为了保证事务的顺序一致性，zookeeper 采用了递增的事务 id 号 （zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了 zxid。实现中 zxid 是一个 64 位的数字，它高 32 位是 epoch 用 来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增计数。 每个 Server 在工作过程中有三种状态： LOOKING：当前 Server 不知道 leader 是谁，正在搜寻。 LEADING：当前 Server 即为选举出来的 leader。 FOLLOWING：leader 已经选举出来，当前 Server 与之同步。 选主流程当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 Server 都恢复到一个正确的状态。Zookeeper 的选举算法有两种： 一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的。系统默认的选举算法为 fast paxos。basic paxos 流程： 选举线程由当前 Server 发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的 Server； 选举线程首先向所有 Server 发起一次询问 (包括自己)； 选举线程收到回复后，验证是否是自己发起的询问 (验证 zxid 是否一致)，然后获取对方的 id(myid)，并存储到当前询问对象列表中，最后获取对方提议的 leader 相关信息 (id,zxid)，并将这些信息存储到当次选举的投票记录表中； 收到所有 Server 回复以后，就计算出 zxid 最大的那个 Server，并将这个 Server 相关信息设置成下一次要投票的 Server； 线程将当前 zxid 最大的 Server 设置为当前 Server 要推荐的 Leader，如果此时获胜的 Server 获得 n/2 + 1 的 Server 票数， 设置当前推荐的 leader 为获胜的 Server，将根据获胜的 Server 相关信息设置自己的状态，否则，继续这个过程，直到 leader 被选举出来。通 过流程分析我们可以得出：要使 Leader 获得多数 Server 的支持，则 Server 总数必须是奇数 2n+1，且存活的 Server 的数目不得少于 n+1. 每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信 息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选举的具体流程图如下所示： fast paxos 流程： 在选举过程中，某 Server 首先向所有 Server 提议自己要成为 leader，当其它 Server 收到提议以后，解决 epoch 和 zxid 的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出 Leader。选举的具体流程图如下所示： 同步流程选完 leader 以后，zk就进入状态同步过程。 leader 等待 server 连接； Follower 连接 leader，将最大的 zxid 发送给 leader； Leader 根据 follower 的 zxid 确定同步点； 完成同步后通知 follower 已经成为 uptodate 状态； Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。同步的具体流程图如下所示： 工作流程Leader 工作流程恢复数据； 维持与 Learner 的心跳，接收 Learner 请求并判断 Learner 的请求消息类型； Learner 的消息类型主要有 PING 消息、REQUEST 消息、ACK 消息、REVALIDATE 消息，根据不同的消息类型，进行不同的处理。 PING 消息是指 Learner 的心跳信息；REQUEST 消息是 Follower 发送的提议信息，包括写请求及同步请求；ACK 消息是 Follower 的对提议 的回复，超过半数的 Follower 通过，则 commit 该提议；REVALIDATE 消息是用来延长 SESSION 有效时间。 Leader 的工作流程简图具体如下所示： Follower 工作流程Follower 主要有四个功能： 向 Leader 发送请求（PING 消息、REQUEST 消息、ACK 消息、REVALIDATE 消息）； 接收 Leader 消息并进行处理； 接收 Client 的请求，如果为写请求，发送给 Leader 进行投票； 返回 Client 结果。Follower 的消息循环处理如下几种来自 Leader 的消息： PING 消息： 心跳消息； PROPOSAL 消息：Leader 发起的提案，要求 Follower 投票； COMMIT 消息：服务器端最新一次提案的信息； UPTODATE 消息：表明同步完成； REVALIDATE 消息：根据 Leader 的 REVALIDATE 结果，关闭待 revalidate 的 session 还是允许其接受消息； SYNC 消息：返回 SYNC 结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。Follower 的工作流程简图具体如下所示： 应用篇分布式系统的运行是很复杂的，因为涉及到了网络通信还有节点失效等不可控的情况。下面介绍在最传统的 master-workers 模型，主要可以会遇到什么问题，传统方法是怎么解决以及怎么用 zookeeper 解决。 Master 节点管理集群当中最重要的是 Master，所以一般都会设置一台 Master 的 Backup。Backup 会定期向 Master 获取 Meta 信息并且检测 Master 的存活性，一旦 Master 挂了，Backup 立马启动，接替 Master 的工作自己成为 Master，分布式的情况多种多样，因为涉及到了网络通信的抖动，针对下面的情况: Backup 检测 Master 存活性传统的就是定期发包，一旦一定时间段内没有收到响应就判定 Master Down 了，于是 Backup 就启动，如果 Master 其实是没有 down，Backup 收不到响应或者收到响应延迟的原因是因为网络阻塞的问题呢？Backup 也启动了，这时候集群里就有了两个 Master，很有可能部分 workers 汇报给 Master，另一部分 workers 汇报给后来启动的 Backup，这下子服务就全乱了。 Backup 是定期同步 Master 中的 meta 信息，所以总是滞后的，一旦 Master 挂了，Backup 的信息必然是老的，很有可能会影响集群运行状态。 解决问题: Master 节点高可用，并且保证唯一。 Meta 信息的及时同步。 Zookeeper Master 选举Zookeeper 会分配给注册到它上面的客户端一个编号，并且 zk 自己会保证这个编号的唯一性和递增性，N 多机器中只需选出编号最小的 Client 作为 Master 就行，并且保证这些机器的都维护一个一样的 meta 信息视图，一旦 Master 挂了，那么这 N 机器中编号最小的胜任 Master，Meta 信息是一致的。 集群 worker 管理集群中的 worker 挂了是很可能的，一旦 worker A 挂了，如果存在其余的 workers 互相之间需要通信，那么 workers 必须尽快更新自己的 hosts 列表，把挂了的 worker 剔除，从而不在和它通信，而 Master 要做的是把挂了 worker 上的作业调度到其他的 worker 上。同样的，这台 worker 重新恢复正常了，要通知其他的 workers 更新 hosts 列表。传统的作法都是有专门的监控系统，通过不断去发心跳包 (比如 ping) 来发现 worker 是否 alive，缺陷就是及时性问题，不能应用于在线率要求较高的场景解决问题:集群 worker 监控。Zookeeper 监控集群利用 zookeeper 建立 znode 的强一致性，可以用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。 分布式锁在一台机器上要多个进程或者多个线程操作同一资源比较简单，因为可以有大量的状态信息或者日志信息提供保证，比如两个 A 和 B 进程同时写一个文件，加锁就可以实现。但是分布式系统怎么办？需要一个三方的分配锁的机制，几百台 worker 都对同一个网络中的文件写操作，怎么协同？还有怎么保证高效的运行？解决问题:高效分布式的分布式锁Zookeeper 分布式锁分布式锁主要得益于 ZooKeeper 为我们保证了数据的强一致性，zookeeper 的 znode 节点创建的唯一性和递增性能保证所有来抢锁的 worker 的原子性。 配置文件管理集群中配置文件的更新和同步是很频繁的，传统的配置文件分发都是需要把配置文件数据分发到每台 worker 上，然后进行 worker 的 reload，这种方式是最笨的方式，结构很难维护，因为如果集群当中有可能很多种应用的配置文件要同步，而且效率很低，集群规模一大负载很高。还有一种就是每次更新把配置文件单独保存到一个数据库里面，然后 worker 端定期 pull 数据，这种方式就是数据及时性得不到同步。解决问题:统一配置文件分发并且及时让 worker 生效Zookeeper 发布与订阅模型发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZK 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。 参考：分布式服务框架Zookeeper介绍、原理及应用 - 简书https://www.jianshu.com/p/bf32e44d3113ZooKeeper原理与应用 - 简书https://www.jianshu.com/p/84ad63127cd1]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列之 RocketMQ]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-1%2F</url>
    <content type="text"><![CDATA[分布式消息系统作为实现分布式系统可扩展、可伸缩性的关键组件，需要具有高吞吐量、高可用等特点。而谈到消息系统的设计，就回避不了两个问题： 消息的顺序问题 消息的重复问题 RocketMQ 作为阿里开源的一款高性能、高吞吐量的消息中间件，它是怎样来解决这两个问题的？RocketMQ 有哪些关键特性？其实现原理是怎样的？ 关键特性以及其实现原理一、顺序消息消息有序指的是可以按照消息的发送顺序来消费。例如：一笔订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照顺序依次消费才有意义。与此同时多笔订单之间又是可以并行消费的。首先来看如下示例： 假如生产者产生了 2 条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样： 的原理与实践/image1) 假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，那么需要 M1 到达消费端被消费后，通知 S2，然后 S2 再将 M2 发送到消费端。 这个模型存在的问题是，如果 M1 和 M2 分别发送到两台 Server 上，就不能保证 M1 先达到 MQ 集群，也不能保证 M1 被先消费。换个角度看，如果 M2 先于 M1 达到 MQ 集群，甚至 M2 被消费后，M1 才达到消费端，这时消息也就乱序了，说明以上模型是不能保证消息的顺序的。如何才能在 MQ 集群保证消息的顺序？一种简单的方式就是将 M1、M2 发送到同一个 Server 上： 的原理与实践/image2) 这样可以保证 M1 先于 M2 到达 MQServer（生产者等待 M1 发送成功后再发送 M2），根据先达到先被消费的原则，M1 会先于 M2 被消费，这样就保证了消息的顺序。 这个模型也仅仅是理论上可以保证消息的顺序，在实际场景中可能会遇到下面的问题： 的原理与实践/image3) 只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送 M1 耗时大于发送 M2 的耗时，那么 M2 就仍将被先消费，仍然不能保证消息的顺序。即使 M1 和 M2 同时到达消费端，由于不清楚消费端 1 和消费端 2 的负载情况，仍然有可能出现 M2 先于 M1 被消费的情况。 那如何解决这个问题？将 M1 和 M2 发往同一个消费者，且发送 M1 后，需要消费端响应成功后才能发送 M2。 聪明的你可能已经想到另外的问题：如果 M1 被发送到消费端后，消费端 1 没有响应，那是继续发送 M2 呢，还是重新发送 M1？一般为了保证消息一定被消费，肯定会选择重发 M1 到另外一个消费端 2，就如下图所示。 的原理与实践/image4) 这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端 1 没有响应 Server 时有两种情况，一种是 M1 确实没有到达 (数据在网络传送中丢失)，另外一种消费端已经消费 M1 且已经发送响应消息，只是 MQ Server 端没有收到。如果是第二种情况，重发 M1，就会造成 M1 被重复消费。也就引入了我们要说的第二个问题，消息重复问题，这个后文会详细讲解。 回过头来看消息顺序问题，严格的顺序消息非常容易理解，也可以通过文中所描述的方式来简单处理。总结起来，要实现严格的顺序消息，简单且可行的办法就是： 保证生产者 - MQServer - 消费者是一对一对一的关系 这样的设计虽然简单易行，但也会存在一些很严重的问题，比如： 并行度就会成为消息系统的瓶颈（吞吐量不够） 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 但我们的最终目标是要集群的高容错性和高吞吐量。这似乎是一对不可调和的矛盾，那么阿里是如何解决的？ 世界上解决一个计算机问题最简单的方法：“恰好” 不需要解决它！—— 沈询 有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。从这个角度来看消息的顺序问题，我们可以得出两个结论： 不关注乱序的应用实际大量存在 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是不是我们应该寻求的一种更合理的方式？ 最后我们从源码角度分析 RocketMQ 怎么实现发送顺序消息。 RocketMQ 通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。比如下面的示例中，订单号相同的消息会被先后发送到同一个队列中： 1234567891011// RocketMQ通过MessageQueueSelector中实现的算法来确定消息发送到哪一个队列上// RocketMQ默认提供了两种MessageQueueSelector实现：随机/Hash// 当然你可以根据业务实现自己的MessageQueueSelector来决定消息按照何种策略发送到消息队列中SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123; @Override public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123; Integer id = (Integer) arg; int index = id % mqs.size(); return mqs.get(index); &#125;&#125;, orderId); 在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个 OrderId 获取到的肯定是同一个队列。 12345678910111213private SendResult send() &#123; // 获取topic路由信息 TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) &#123; MessageQueue mq = null; // 根据我们的算法，选择一个发送队列 // 这里的arg = orderId mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg); if (mq != null) &#123; return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout); &#125; &#125;&#125; 二、消息重复上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么 RocketMQ 是怎样解决消息重复的问题呢？还是 “恰好” 不解决。 造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？ 消费端处理消息的业务逻辑保持幂等性 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现 第 1 条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第 2 条原理就是利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 第 1 条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。第 2 条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是 RocketMQ 不解决消息重复的问题的原因。 RocketMQ 不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。 三、事务消息RocketMQ 除了支持普通消息，顺序消息，另外还支持事务消息。首先讨论一下什么是事务消息以及支持事务消息的必要性。我们以一个转帐的场景为例来说明这个问题：Bob 向 Smith 转账 100 块。 在单机环境下，执行事务的情况，大概是下面这个样子： 的原理与实践/image5) 当用户增长到一定程度，Bob 和 Smith 的账户及余额信息已经不在同一台服务器上了，那么上面的流程就变成了这样： 的原理与实践/image6) 这时候你会发现，同样是一个转账的业务，在集群环境下，耗时居然成倍的增长，这显然是不能够接受的。那如何来规避这个问题？ 大事务 = 小事务 + 异步 将大事务拆分成多个小事务异步执行。这样基本上能够将跨机事务的执行效率优化到与单机一致。转账的事务就可以分解成如下两个小事务： 的原理与实践/image7) 图中执行本地事务（Bob 账户扣款）和发送异步消息应该保证同时成功或者同时失败，也就是扣款成功了，发送消息一定要成功，如果扣款失败了，就不能再发送消息。那问题是：我们是先扣款还是先发送消息呢？ 首先看下先发送消息的情况，大致的示意图如下： 的原理与实践/image8) 存在的问题是：如果消息发送成功，但是扣款失败，消费端就会消费此消息，进而向 Smith 账户加钱。 先发消息不行，那就先扣款吧，大致的示意图如下： 的原理与实践/image9) 存在的问题跟上面类似：如果扣款成功，发送消息失败，就会出现 Bob 扣钱了，但是 Smith 账户未加钱。 可能大家会有很多的方法来解决这个问题，比如：直接将发消息放到 Bob 扣款的事务中去，如果发送失败，抛出异常，事务回滚。这样的处理方式也符合 “恰好” 不需要解决的原则。 这里需要说明一下：如果使用 Spring 来管理事物的话，大可以将发送消息的逻辑放到本地事物中去，发送消息失败抛出异常，Spring 捕捉到异常后就会回滚此事物，以此来保证本地事物与发送消息的原子性。 RocketMQ 支持事务消息，下面来看看 RocketMQ 是怎样来实现的。 的原理与实践/image10) RocketMQ 第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。 细心的你可能又发现问题了，如果确认消息发送失败了怎么办？RocketMQ 会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端 (生产者) 确认，Bob 的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。 那我们来看下 RocketMQ 源码，是如何处理事务消息的。客户端发送事务消息的部分（完整代码请查看：rocketmq-example工程下的com.alibaba.rocketmq.example.transaction.TransactionProducer）： 12345678910111213141516// =============================发送事务消息的一系列准备工作========================================// 未决事务，MQ服务器回查客户端// 也就是上文所说的，当RocketMQ发现`Prepared消息`时，会根据这个Listener实现的策略来决断事务TransactionCheckListener transactionCheckListener = new TransactionCheckListenerImpl();// 构造事务消息的生产者TransactionMQProducer producer = new TransactionMQProducer(&quot;groupName&quot;);// 设置事务决断处理类producer.setTransactionCheckListener(transactionCheckListener);// 本地事务的处理逻辑，相当于示例中检查Bob账户并扣钱的逻辑TransactionExecuterImpl tranExecuter = new TransactionExecuterImpl();producer.start()// 构造MSG，省略构造参数Message msg = new Message(......);// 发送消息SendResult sendResult = producer.sendMessageInTransaction(msg, tranExecuter, null);producer.shutdown(); 接着查看sendMessageInTransaction方法的源码，总共分为 3 个阶段：发送Prepared消息、执行本地事务、发送确认消息。 1234567891011// ================================事务消息的发送过程=============================================public TransactionSendResult sendMessageInTransaction(.....) &#123; // 逻辑代码，非实际代码 // 1.发送消息 sendResult = this.send(msg); // sendResult.getSendStatus() == SEND_OK // 2.如果消息发送成功，处理与消息关联的本地事务单元 LocalTransactionState localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg); // 3.结束事务 this.endTransaction(sendResult, localTransactionState, localException);&#125; endTransaction方法会将请求发往broker(mq server)去更新事务消息的最终状态： 根据sendResult找到Prepared消息 ，sendResult包含事务消息的 ID 根据localTransaction更新消息的最终状态 如果endTransaction方法执行失败，数据没有发送到broker，导致事务消息的 状态更新失败，broker会有回查线程定时（默认 1 分钟）扫描每个存储事务状态的表格文件，如果是已经提交或者回滚的消息直接跳过，如果是prepared状态则会向Producer发起CheckTransaction请求，Producer会调用DefaultMQProducerImpl.checkTransactionState()方法来处理broker的定时回调请求，而checkTransactionState会调用我们的事务设置的决断方法来决定是回滚事务还是继续执行，最后调用endTransactionOneway让broker来更新消息的最终状态。 再回到转账的例子，如果 Bob 的账户的余额已经减少，且消息已经发送成功，Smith 端开始消费这条消息，这个时候就会出现消费失败和消费超时两个问题，解决超时问题的思路就是一直重试，直到消费端消费消息成功，整个过程中有可能会出现消息重复的问题，按照前面的思路解决即可。 的原理与实践/image11) 这样基本上可以解决消费端超时问题，但是如果消费失败怎么办？阿里提供给我们的解决方法是：人工解决。大家可以考虑一下，按照事务的流程，因为某种原因 Smith 加款失败，那么需要回滚整个流程。如果消息系统要实现这个回滚流程的话，系统复杂度将大大提升，且很容易出现 Bug，估计出现 Bug 的概率会比消费失败的概率大很多。这也是 RocketMQ 目前暂时没有解决这个问题的原因，在设计实现消息系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，这也是大家在解决疑难问题时需要多多思考的地方。 20160321 补充：在 3.2.6 版本中移除了事务消息的实现，所以此版本不支持事务消息，具体情况请参考 rocketmq 的 issues(已失效)：https://github.com/alibaba/RocketMQ/issues/65https://github.com/alibaba/RocketMQ/issues/138https://github.com/alibaba/RocketMQ/issues/156 四、Producer 如何发送消息Producer轮询某 topic 下的所有队列的方式来实现发送方的负载均衡，如下图所示： 的原理与实践/image12) 首先分析一下 RocketMQ 的客户端发送消息的源码： 12345678910111213// 构造ProducerDefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);// 初始化Producer，整个应用生命周期内，只需要初始化1次producer.start();// 构造MessageMessage msg = new Message(&quot;TopicTest1&quot;,// topic &quot;TagA&quot;,// tag：给消息打标签,用于区分一类消息，可为null &quot;OrderID188&quot;,// key：自定义Key，可以用于去重，可为null (&quot;Hello MetaQ&quot;).getBytes());// body：消息内容// 发送消息并返回结果SendResult sendResult = producer.send(msg);// 清理资源，关闭网络连接，注销自己producer.shutdown(); 在整个应用生命周期内，生产者需要调用一次 start 方法来初始化，初始化主要完成的任务有： 如果没有指定namesrv地址，将会自动寻址 启动定时任务：更新 namesrv 地址、从 namsrv 更新 topic 路由信息、清理已经挂掉的 broker、向所有 broker 发送心跳… 启动负载均衡的服务 初始化完成后，开始发送消息，发送消息的主要代码如下： 123456789101112private SendResult sendDefaultImpl(Message msg,......) &#123; // 检查Producer的状态是否是RUNNING this.makeSureStateOK(); // 检查msg是否合法：是否为null、topic,body是否为空、body是否超长 Validators.checkMessage(msg, this.defaultMQProducer); // 获取topic路由信息 TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); // 从路由信息中选择一个消息队列 MessageQueue mq = topicPublishInfo.selectOneMessageQueue(lastBrokerName); // 将消息发送到该队列上去 sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);&#125; 代码中需要关注的两个方法tryToFindTopicPublishInfo和selectOneMessageQueue。前面说过在 producer 初始化时，会启动定时任务获取路由信息并更新到本地缓存，所以tryToFindTopicPublishInfo会首先从缓存中获取 topic 路由信息，如果没有获取到，则会自己去namesrv获取路由信息。selectOneMessageQueue方法通过轮询的方式，返回一个队列，以达到负载均衡的目的。 如果 Producer 发送消息失败，会自动重试，重试的策略： 重试次数 &lt; retryTimesWhenSendFailed（可配置） 总的耗时（包含重试 n 次的耗时） &lt; sendMsgTimeout（发送消息时传入的参数） 同时满足上面两个条件后，Producer 会选择另外一个队列发送消息 五、消息存储RocketMQ 的消息存储是由consume queue和commit log配合完成的。 1、Consume Queueconsume queue是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commit log上的位置。 我们可以在配置中指定consumequeue与commitlog存储的目录每个topic下的每个queue都有一个对应的consumequeue文件，比如： 1$&#123;rocketmq.home&#125;/store/consumequeue/$&#123;topicName&#125;/$&#123;queueId&#125;/$&#123;fileName&#125; Consume Queue 文件组织，如图所示： 的原理与实践/image13) 根据topic和queueId来组织文件，图中 TopicA 有两个队列 0,1，那么 TopicA 和 QueueId=0 组成一个 ConsumeQueue，TopicA 和 QueueId=1 组成另一个 ConsumeQueue。 按照消费端的GroupName来分组重试队列，如果消费端消费失败，消息将被发往重试队列中，比如图中的%RETRY%ConsumerGroupA。 按照消费端的GroupName来分组死信队列，如果消费端消费失败，并重试指定次数后，仍然失败，则发往死信队列，比如图中的%DLQ%ConsumerGroupA。 死信队列（Dead Letter Queue）一般用于存放由于某种原因无法传递的消息，比如处理失败或者已经过期的消息。 Consume Queue 中存储单元是一个 20 字节定长的二进制数据，顺序写顺序读，如下图所示： 的原理与实践/image14) CommitLog Offset 是指这条消息在 Commit Log 文件中的实际偏移量 Size 存储中消息的大小 Message Tag HashCode 存储消息的 Tag 的哈希值：主要用于订阅时消息过滤（订阅时如果指定了 Tag，会根据 HashCode 来快速查找到订阅的消息） 2、Commit LogCommitLog：消息存放的物理文件，每台broker上的commitlog被本机所有的queue共享，不做任何区分。文件的默认位置如下，仍然可通过配置文件修改： 1$&#123;user.home&#125; \store\$&#123;commitlog&#125;\$&#123;fileName&#125; CommitLog 的消息存储单元长度不固定，文件顺序写，随机读。消息的存储结构如下表所示，按照编号顺序以及编号对应的内容依次存储。 的原理与实践/image15) 3、消息存储实现消息存储实现，比较复杂，也值得大家深入了解，后面会单独成文来分析 (目前正在收集素材)，这小节只以代码说明一下具体的流程。 1234567891011121314151617181920212223242526272829303132333435363738// Set the storage timemsg.setStoreTimestamp(System.currentTimeMillis());// Set the message body BODY CRC (consider the most appropriate settingmsg.setBodyCRC(UtilAll.crc32(msg.getBody()));StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();synchronized (this) &#123; long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now(); // Here settings are stored timestamp, in order to ensure an orderly global msg.setStoreTimestamp(beginLockTimestamp); // MapedFile：操作物理文件在内存中的映射以及将内存数据持久化到物理文件中 MapedFile mapedFile = this.mapedFileQueue.getLastMapedFile(); // 将Message追加到文件commitlog result = mapedFile.appendMessage(msg, this.appendMessageCallback); switch (result.getStatus()) &#123; case PUT_OK:break; case END_OF_FILE: // Create a new file, re-write the message mapedFile = this.mapedFileQueue.getLastMapedFile(); result = mapedFile.appendMessage(msg, this.appendMessageCallback); break; DispatchRequest dispatchRequest = new DispatchRequest( topic,// 1 queueId,// 2 result.getWroteOffset(),// 3 result.getWroteBytes(),// 4 tagsCode,// 5 msg.getStoreTimestamp(),// 6 result.getLogicsOffset(),// 7 msg.getKeys(),// 8 /** * Transaction */ msg.getSysFlag(),// 9 msg.getPreparedTransactionOffset());// 10 // 1.分发消息位置到ConsumeQueue // 2.分发到IndexService建立索引 this.defaultMessageStore.putDispatchRequest(dispatchRequest);&#125; 4、消息的索引文件如果一个消息包含 key 值的话，会使用 IndexFile 存储消息索引，文件的内容结构如图： 的原理与实践/image16) 索引文件主要用于根据 key 来查询消息的，流程主要是： 根据查询的 key 的 hashcode%slotNum 得到具体的槽的位置 (slotNum 是一个索引文件里面包含的最大槽的数目，例如图中所示 slotNum=5000000) 根据 slotValue(slot 位置对应的值) 查找到索引项列表的最后一项 (倒序排列, slotValue 总是指向最新的一个索引项) 遍历索引项列表返回查询时间范围内的结果集 (默认一次最大返回的 32 条记录) 六、消息订阅RocketMQ 消息订阅有两种模式，一种是 Push 模式，即 MQServer 主动向消费端推送；另外一种是 向消费端推送；，即消费端在需要时，主动到 MQServer 拉取。但在具体实现时，Push 和 Pull 模式都是采用消费端主动拉取的方式。 首先看下消费端的负载均衡： 的原理与实践/image17) 消费端会通过 RebalanceService 线程，10 秒钟做一次基于 topic 下的所有队列负载： 遍历 Consumer 下的所有 topic，然后根据 topic 订阅所有的消息 获取同一 topic 和 Consumer Group 下的所有 Consumer 然后根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费端配置等 如同上图所示：如果有 5 个队列，2 个 consumer，那么第一个 Consumer 消费 3 个队列，第二 consumer 消费 2 个队列。这里采用的就是平均分配策略，它类似于分页的过程，TOPIC 下面的所有 queue 就是记录，Consumer 的个数就相当于总的页数，那么每页有多少条记录，就类似于某个 Consumer 会消费哪些队列。 通过这样的策略来达到大体上的平均消费，这样的设计也可以很方面的水平扩展 Consumer 来提高消费能力。 消费端的 Push 模式是通过长轮询的模式来实现的，就如同下图： 的原理与实践/image18) Consumer 端每隔一段时间主动向 broker 发送拉消息请求，broker 在收到 Pull 请求后，如果有消息就立即返回数据，Consumer 端收到返回的消息后，再回调消费者设置的 Listener 方法。如果 broker 在收到 Pull 请求时，消息队列里没有数据，broker 端会阻塞请求直到有数据传递或超时才返回。 当然，Consumer 端是通过一个线程将阻塞队列LinkedBlockingQueue&lt;PullRequest&gt;中的PullRequest发送到 broker 拉取消息，以防止 Consumer 一致被阻塞。而 Broker 端，在接收到 Consumer 的PullRequest时，如果发现没有消息，就会把PullRequest扔到 ConcurrentHashMap 中缓存起来。broker 在启动时，会启动一个线程不停的从 ConcurrentHashMap 取出PullRequest检查，直到有数据返回。 七、RocketMQ 的其他特性前面的 6 个特性都是基本上都是点到为止，想要深入了解，还需要大家多多查看源码，多多在实际中运用。当然除了已经提到的特性外，RocketMQ 还支持： 定时消息 消息的刷盘策略 主动同步策略：同步双写、异步复制 海量消息堆积能力 高效通信 ……. 其中涉及到的很多设计思路和解决方法都值得我们深入研究： 消息的存储设计：既要满足海量消息的堆积能力，又要满足极快的查询效率，还要保证写入的效率。 高效的通信组件设计：高吞吐量，毫秒级的消息投递能力都离不开高效的通信。 ……. RocketMQ 最佳实践一、Producer 最佳实践1、一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。只有发送消息设置了 tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。2、每个消息在业务层面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。3、消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。4、对于消息不可丢失应用，务必要有消息重发机制。例如：消息发送失败，存储到数据库，能有定时程序尝试重发或者人工触发重发。5、某些应用如果不关注消息是否发送成功，请直接使用sendOneWay方法发送消息。 二、Consumer 最佳实践1、消费过程要做到幂等（即消费端去重）2、尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。3、优化每条消息消费过程 三、其他配置线上应该关闭autoCreateTopicEnable，即在配置文件中将其设置为false。 RocketMQ 在发送消息时，会首先获取路由信息。如果是新的消息，由于 MQServer 上面还没有创建对应的Topic，这个时候，如果上面的配置打开的话，会返回默认 TOPIC 的（RocketMQ 会在每台broker上面创建名为TBW102的 TOPIC）路由信息，然后Producer会选择一台Broker发送消息，选中的broker在存储消息时，发现消息的topic还没有创建，就会自动创建topic。后果就是：以后所有该 TOPIC 的消息，都将发送到这台broker上，达不到负载均衡的目的。 所以基于目前 RocketMQ 的设计，建议关闭自动创建 TOPIC 的功能，然后根据消息量的大小，手动创建 TOPIC。 RocketMQ 设计相关RocketMQ 的设计假定： 每台 PC 机器都可能宕机不可服务任意集群都有可能处理能力不足最坏的情况一定会发生内网环境需要低延迟来提供最佳用户体验 RocketMQ 的关键设计： 分布式集群化强数据安全海量数据堆积毫秒级投递延迟（推拉模式） 这是 RocketMQ 在设计时的假定前提以及需要到达的效果。我想这些假定适用于所有的系统设计。随着我们系统的服务的增多，每位开发者都要注意自己的程序是否存在单点故障，如果挂了应该怎么恢复、能不能很好的水平扩展、对外的接口是否足够高效、自己管理的数据是否足够安全…… 多多规范自己的设计，才能开发出高效健壮的程序。 参考资料 RocketMQ 用户指南 RocketMQ 原理简介 RocketMQ 最佳实践 阿里分布式开放消息服务 (ONS) 原理与实践 2 阿里分布式开放消息服务 (ONS) 原理与实践 3 RocketMQ 原理解析 原文：分布式开放消息系统(RocketMQ)的原理与实践 - 简书https://www.jianshu.com/p/453c6e7ff81c]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列之 kafka]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22%2F</url>
    <content type="text"><![CDATA[kafka 是一种高吞吐量的分布式发布订阅消息系统。kafka 的目的是通过并行加载机制来统一线上和离线的消息处理，也是为了通过集群机来提供实时的消费。 结构： 生产消息： Producer 将消息发布到指定的 Topic 中, 同时 Producer 也能决定将此消息归属于哪个 partition; 比如基于 “round-robin”(轮询调度算法) 方式或者通过其他的一些算法等. Kafka 系统的角色 Broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic topic： 可以理解为一个 MQ 消息队列的名字 Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。partition 中的每条消息 都会被分配一个有序的 id（offset）。kafka 只保证按一个 partition 中的顺序将消息发给 consumer，不保证一个 topic 的整体 （多个 partition 间）的顺序。也就是说，一个 topic 在集群中可以有多个 partition，那么分区的策略是什么？(消息发送到哪个分区上，有两种基本的策略，一是采用 Key Hash 算法，一是采用 Round Robin 算法) 消费消息： • 于 consumer 而言, 它需要保存消费消息的 offset, 对于 offset 的保存和使用, 由 consumer 来控制; 当 consumer 正常消费消息时, offset 将会 “线性” 的向前驱动, 即消息将依次顺序被消费. 事实上 consumer 可以使用任意顺序消费消息, 它只需要将 offset 重置为任意值 •consumer 端向 broker 发送 “fetch” 请求, 并告知其获取消息的 offset; 此后 consumer 将会获得一定条数的消息; consumer 端也可以重置 offset 来重新消费消息. 消息过期处理： • 即使消息被消费, 消息仍然不会被立即删除. 日志文件将会根据 broker 中的配置要求, 保留一定的时间之后删除; 比如 log 文件保留 2 天, 那么两天后, 文件会被清除, 无论其中的消息是否被消费. kafka 通过这种简单的手段, 来释放磁盘空间, 以及减少消息消费之后对文件内容改动的磁盘 IO 开支. 分布式： • 一个 Topic 的多个 partitions, 被分布在 kafka 集群中的多个 server 上; 每个 server(kafka 实例) 负责 partitions 中消息的读写操作; 此外 kafka 还可以配置 partitions 需要备份的个数 (replicas), 每个 partition 将会被备份到多台机器上, 以提高可用性. • 基于 replicated 方案, 需要对多个备份进行调度; 每个 partition 都有一个 server 为 “leader”;leader 负责所有的读写操作, 如果 leader 失效, 那么将会有其他 follower 来接管 (成为新的 leader);follower 只是单调的和 leader 跟进, 同步消息即可.. 由此可见作为 leader 的 server 承载了全部的请求压力, 因此从集群的整体考虑, 有多少个 partitions 就意味着有多少个 “leader”,kafka 会将 “leader” 均衡的分散在每个实例上, 来确保整体的性能稳定. 适用场景： 对于一些常规的消息系统，kafka 是个不错的选择，partitons/replication 和容错，可以使得 kafka 具有良好的扩展性和性能优势； kafka 可以作为 “网站活性跟踪” 的工具，可以将网页 / 用户操作等信息发送到 kafka 中，并实时监控，或离线统计分析等 消息存储： 如果一个 topic 的名称为 “my_topic”, 它有 2 个 partitions, 那么日志将会保存在 my_topic_0 和 my_topic_1 两个目录中; 日志文件中保存了一序列 “log entries”(日志条目), 每个 log entry 格式为 “4 个字节的数字 N 表示消息的长度” + “N 个字节的消息内容”; 每个日志都有一个 offset 来唯一的标记一条消息, offset 的值为 8 个字节的数字, 表示此消息在此 partition 中所处的起始位置.. 每个 partition 在物理存储层面, 有多个 log file 组成 (称为 segment).segmentfile 的命名为 “最小 offset”.kafka. 例如 “00000000000.kafka”; 其中 “最小 offset” 表示此 segment 中起始消息的 offset. 当 segment 文件尺寸达到一定阀值时 (可以通过配置文件设定, 默认 1G), 将会创建一个新的文件; 当 buffer 中消息的条数达到阀值时将会触发日志信息 flush 到日志文件中, 同时如果 “距离最近一次 flush 的时间差” 达到阀值时, 也会触发 flush 到日志文件. zookeeper： ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 •1) Producer 端使用 zookeeper 用来 “发现”broker 列表, 以及和 Topic 下每个 partition leader 建立 socket 连接并发送消息. •2) Broker 端使用 zookeeper 用来注册 broker 信息, 以及监测 partitionleader 存活性. •3) Consumer 端使用 zookeeper 用来注册 consumer 信息, 其中包括 consumer 消费的 partition 列表等, 同时也用来发现 broker 列表, 并和 partition leader 建立 socket 连接, 并获取消息. 参考：kafka 分布式消息队列 - 简书https://www.jianshu.com/p/22e8166bf974]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列之 ActiveMQ]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-11%2F</url>
    <content type="text"><![CDATA[ActiveMQ 是什么ActiveMQ 是一个 MOM，具体来说是一个实现了 JMS 规范的系统间远程通信的消息代理。 什么是 MOMMOM 就是面向消息中间件（Message-oriented middleware），是用于以分布式应用或系统中的异步、松耦合、可靠、可扩展和安全通信的一类软件。MOM 的总体思想是它作为消息发送器和消息接收器之间的消息中介, 这种中介提供了一个全新水平的松耦合。 JMS是什么JMS 叫做 Java 消息服务（Java Message Service）, 是 Java 平台上有关面向 MOM 的技术规范，旨在通过提供标准的产生、发送、接收和处理消息的 API 简化企业应用的开发，类似于 JDBC 和关系型数据库通信方式的抽象 Provider：纯 Java 语言编写的 JMS 接口实现（比如 ActiveMQ 就是） Domains：消息传递方式，包括点对点（P2P）、发布 / 订阅（Pub/Sub）两种 Connection factory：客户端使用连接工厂来创建与 JMS provider 的连接 Destination：消息被寻址、发送以及接收的对象 P2P 和 Pub/Sub 的区别P2P （点对点）消息域使用 queue 作为 Destination，消息可以被同步或异步的发送和接收，每个消息只会给一个 Consumer 传送一次。 Consumer 可以使用 MessageConsumer.receive() 同步地接收消息，也可以通过使用 MessageConsumer.setMessageListener() 注册一个 MessageListener 实现异步接收。 多个 Consumer 可以注册到同一个 queue 上，但一个消息只能被一个 Consumer 所接收，然后由该 Consumer 来确认消息。并且在这种情况下，Provider 对所有注册的 Consumer 以轮询的方式发送消息。 Pub/Sub（发布 / 订阅，Publish/Subscribe）消息域使用 topic 作为 Destination，发布者向 topic 发送消息，订阅者注册接收来自 topic 的消息。发送到 topic 的任何消息都将自动传递给所有订阅者。接收方式（同步和异步）与 P2P 域相同。除非显式指定，否则 topic 不会为订阅者保留消息。当然，这可以通过持久化（Durable）订阅来实现消息的保存。这种情况下，当订阅者与 Provider 断开时，Provider 会为它存储消息。当持久化订阅者重新连接时，将会受到所有的断连期间未消费的消息。 使用JMS创建应用程序的通用步骤 获取连接工厂 使用连接工厂创建连接 启动连接 从连接创建会话 获取 Destination 创建 Producer，或 创建 Producer 创建 message 创建 Consumer，或发送或接收 message 发送或接收 message 创建 Consumer 注册消息监听器（可选） 发送或接收 message 关闭资源（connection, session, producer, consumer 等) “66666，厉害啊我的王哥！” 成小胖的小聪明被老王击得粉碎！ 上面步骤对应的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142public class JMSDemo &#123; ConnectionFactory connectionFactory; Connection connection; Session session; Destination destination; MessageProducer producer; MessageConsumer consumer; Message message; boolean useTransaction = false; try &#123; Context ctx = new InitialContext(); connectionFactory = (ConnectionFactory) ctx.lookup(&quot;ConnectionFactoryName&quot;); //使用ActiveMQ时：connectionFactory = new ActiveMQConnectionFactory(user, password, getOptimizeBrokerUrl(broker)); connection = connectionFactory.createConnection(); connection.start(); session = connection.createSession(useTransaction, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(&quot;TEST.QUEUE&quot;); //生产者发送消息 producer = session.createProducer(destination); message = session.createTextMessage(&quot;this is a test&quot;); //消费者同步接收 consumer = session.createConsumer(destination); message = (TextMessage) consumer.receive(1000); System.out.println(&quot;Received message: &quot; + message); //消费者异步接收 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; if (message != null) &#123; doMessageEvent(message); &#125; &#125; &#125;); &#125; catch (JMSException e) &#123; ... &#125; finally &#123; producer.close(); session.close(); connection.close(); &#125;&#125; ActiveMQ 在 queue 中存储 Message 时，采用先进先出顺序（FIFO）存储。同一时间一个消息被分派给单个消费者，且只有当 Message 被消费并确认时，它才能从存储中删除。 对于持久化订阅者来说，每个消费者获得 Message 的副本。为了节省存储空间，Provider 仅存储消息的一个副本。持久化订阅者维护了指向下一个 Message 的指针，并将其副本分派给消费者。以这种方式实现消息存储，因为每个持久化订阅者可能以不同的速率消费 Message，或者它们可能不是全部同时运行。此外，因每个 Message 可能存在多个消费者，所以在它被成功地传递给所有持久化订阅者之前，不能从存储中删除。 消息类型 是否持久化 是否有 Durable 订阅者 消费者延迟启动时，消息是否保留 Broker 重启时，消息是否保留 Queue N - Y N Queue Y - Y Y Topic N N N N Topic N Y Y N Topic Y N N N Topic Y Y Y Y ActiveMQ 常用的存储方式1.KahaDBActiveMQ 5.3 版本起的默认存储方式。KahaDB 存储是一个基于文件的快速存储消息，设计目标是易于使用且尽可能快。它使用基于文件的消息数据库意味着没有第三方数据库的先决条件。 要启用 KahaDB 存储，需要在 activemq.xml 中进行以下配置： 12345&lt;broker broker&gt; &lt;persistenceAdapter&gt; &lt;kahaDB directory=&quot;$&#123;activemq.data&#125;/kahadb&quot; journalMaxFileLength=&quot;16mb&quot;/&gt; &lt;/persistenceAdapter&gt;&lt;/broker&gt; 2.AMQ与 KahaDB 存储一样，AMQ 存储使用户能够快速启动和运行，因为它不依赖于第三方数据库。AMQ 消息存储库是可靠持久性和高性能索引的事务日志组合，当消息吞吐量是应用程序的主要需求时，该存储是最佳选择。但因为它为每个索引使用两个分开的文件，并且每个 Destination 都有一个索引，所以当你打算在代理中使用数千个队列的时候，不应该使用它。 12345678&lt;persistenceAdapter&gt; &lt;amqPersistenceAdapter directory=&quot;$&#123;activemq.data&#125;/kahadb&quot; syncOnWrite=&quot;true&quot; indexPageSize=&quot;16kb&quot; indexMaxBinSize=&quot;100&quot; maxFileLength=&quot;10mb&quot; /&gt;&lt;/persistenceAdapter&gt; 3.JDBC选择关系型数据库，通常的原因是企业已经具备了管理关系型数据的专长，但是它在性能上绝对不优于上述消息存储实现。事实是，许多企业使用关系数据库作为存储，是因为他们更愿意充分利用这些数据库资源。 123456789101112131415&lt;beans&gt; &lt;broker broker&gt; &lt;persistenceAdapter&gt; &lt;jdbcPersistenceAdapter dataSource=&quot;#mysql-ds&quot;/&gt; &lt;/persistenceAdapter&gt; &lt;/broker&gt; &lt;bean id=&quot;mysql-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property /&gt; &lt;property jdbc:mysql://localhost/activemq?relaxAutoCommit=true&quot;/&gt; &lt;property /&gt; &lt;property /&gt; &lt;property /&gt; &lt;property /&gt; &lt;/bean&gt;&lt;/beans&gt; 4. 内存存储内存消息存储器将所有持久消息保存在内存中。在仅存储有限数量 Message 的情况下，内存消息存储会很有用，因为 Message 通常会被快速消耗。在 activema.xml 中将 broker 元素上的 persistent 属性设置为 false 即可。 12345&lt;broker broker&gt; &lt;transportConnectors&gt; &lt;transportConnector uri=&quot;tcp://localhost:61635&quot;/&gt; &lt;/transportConnectors&gt;&lt;/broker&gt; ActiveMQ 的部署模式1. 单例模式这个就不啰嗦了，略过。 2. 无共享主从模式这是最简单的 Provider 高可用性的方案，主从节点分别存储 Message。从节点需要配置为连接到主节点，并且需要特殊配置其状态。 所有消息命令（消息，确认，订阅，事务等）都从主节点复制到从节点，这种复制发生在主节点对其接收的任何命令生效之前。并且，当主节点收到持久消息，会等待从节点完成消息的处理（通常是持久化到存储），然后再自己完成消息的处理（如持久化到存储）后，再返回对 Producer 的回执。 从节点不启动任何传输，也不能接受任何客户端或网络连接，除非主节点失效。当主节点失效后，从节点自动成为主节点，并且开启传输并接受连接。这是，使用 failover 传输的客户端就会连接到该新主节点。 Broker 连接配置如下： failover://(tcp://masterhost:61616,tcp://slavehost:61616)?randomize=false 但是，这种部署模式有一些限制， 主节点只会在从节点连接到主节点时复制其活动状态，因此当从节点没有连接上主节点之前，任何主节点处理的 Message 或者消息确认都会在主节点失效后丢失。不过你可以通过在主节点设置 waitForSlave 来避免，这样就强制主节点在没有任何一个从节点连接上的情况下接受连接。 就是主节点只能有一个从节点，并且从节点不允许再有其他从节点。 把正在运行的单例配置成无共享主从，或者配置新的从节点时，你都要停止当前服务，修改配置后再重启才能生效。 在可以接受一些故障停机时间的情况下，可以使用该模式。 从节点配置： 123&lt;services&gt; &lt;masterConnector remoteURI=&quot;tcp://remotehost:62001&quot; user/&gt;&lt;/services&gt; 此外，可以配置 shutdownOnMasterFailure 项，表示主节点失效后安全关闭，保证没有消息丢失，允许管理员维护一个新的从节点。 3. 共享存储主从模式允许多个代理共享存储，但任意时刻只有一个是活动的。这种情况下，当主节点失效时，无需人工干预来维护应用的完整性。另外一个好处就是没有从节点数的限制。 有两种细分模式： （1）基于数据库 它会获取一个表上的排它锁，以确保没有其他 ActiveMQ 代理可以同时访问数据库。其他未获得锁的代理则处于轮询状态，就会被当做是从节点，不会开启传输也不会接受连接。 （2）基于文件系统 需要获取分布式共享文件锁，linux 系统下推荐用 GFS2。 ActiveMQ 的网络连接1. 代理网络支持将 ActiveMQ 消息代理链接到不同拓扑，这就是被人们熟知的代理网络。 ActiveMQ 网络使用存储和转发的概念，其中消息总是存储在本地代理中，然后通过网络转发到另一个代理。 当连接建立后，远程代理将把包含其所有持久和活动消费者目的地的信息传递给本地代理，本地代理根据信息决定远程代理感兴趣的 Message 并将它发送给远程代理。 如果希望网络是双向的，您可以使用网络连接器将远程代理配置为指向本地代理，或将网络连接器配置为双工，以便双向发送消息。 12345678&lt;networkConnectors&gt; &lt;networkConnector uri=&quot;static://(tcp://backoffice:61617)&quot; duplex=&quot;true&quot; conduitSubscriptions=&quot;true&quot; decreaseNetworkConsumerPriority=&quot;false&quot;&gt; &lt;/networkConnector&gt;&lt;/networkConnectors&gt; 注意，配置的顺序很重要： 1. 网络连接——需要在消息存储前建立好连接，对应 networkConnectors 元素 2. 消息存储——需要在传输前配置好，对应 persistenceAdapter 元素 3. 消息传输——最后配置，对应 transportConnectors 元素 2. 网络发现（1）动态发现 使用多播来支持网络动态发现。配置如下： 123&lt;networkConnectors&gt; &lt;networkConnector uri=&quot;multicast://default&quot;/&gt;&lt;/networkConnectors&gt; 其中，multicast:// 中的默认名称表示该代理所属的组。因此使用此方式时，强烈推荐你使用一个独特的组名，避免你的代理连接到其他不相关代理。 （2）静态发现 静态发现接受代理 URI 列表，并将尝试按列表中确定的顺序连接到远程代理。 123&lt;networkConnectors&gt; &lt;networkConnector uri=&quot;static:(tcp://remote-master:61617,tcp://remote-slave:61617)&quot;/&gt;&lt;/networkConnectors&gt; 相关配置如下： initialReconnectDelay：默认值 1000，表示尝试连接前的时延。 maxReconnectDelay：默认值 30000，表示连接失败后到重新建立连接之间的时延，仅在 useExponentialBackOff 启用时生效。 useExponentialBackOff：默认值 true，如果启用，表示每次失败后增加重建连接的时延。 backOffMultiplier：默认值 2，表示启用 useExponentialBackOff 后每次的时延增量需要注意的是，网络连接将始终尝试建立到远程代理的连接。 需要注意的是，网络连接将始终尝试建立到远程代理的连接。 （3）多连接场景 当网络负载高时，使用多连接很有意义。但是你需要确保不会重复传递消息，这可以通过过滤器来实现。 12345678910111213141516&lt;networkConnectors&gt; &lt;networkConnector uri=&quot;static://(tcp://remotehost:61617)&quot; duplex=&quot;true&quot; &lt;excludedDestinations&gt; &lt;topic physical/&gt; &lt;/excludedDestinations&gt; &lt;/networkConnector&gt; &lt;networkConnector uri=&quot;static://(tcp://remotehost:61617)&quot; duplex=&quot;true&quot; &lt;excludedDestinations&gt; &lt;queue physical/&gt; &lt;/excludedDestinations&gt; &lt;/networkConnector&gt;&lt;/networkConnectors&gt; 参考：成小胖学习ActiveMQ·基础篇 - cyfonly - 博客园https://www.cnblogs.com/cyfonly/p/6380860.html]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解JMS]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-10%2F</url>
    <content type="text"><![CDATA[1.JMS 简介学习 ActiveMQ 之前，先来学习一下 JMS： JMS（Java Messaging Service），即 Java 消息服务，是 Java 平台上关于面向消息中间件 (MOM) 的 API，它便于应用程序之间，或分布式系统之间进行异步的消息交换, 并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。 JMS 是 Java 消息服务的标准（或者叫规范），它使分布式通信耦合更低，消息服务更加可靠，这个标准在企业应用中十分的重要和广泛，所以开篇来重点学习一下它。 2. 消息的模型 点对点队列模型：Point-to-Point（P2P）发布订阅模型：Publish/Subscribe（Pub/Sub） 2.1 P2P 模型 2.1.1 相关对象 消息队列（Queue） 发送者（Sender） 接收者（Receiver） 2.1.2 过程发送者将消息发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被接收者消费或超时。 2.1.3 特点 每个消息只有一个消费者（Consumer），消息一旦被消费就会从队列中移除 发送者和接收者在时间上没有依赖性（异步），即发送者发送消息时接收者无需处于运行状态，同样接收者接收消息时发送者无需处于运行状态 接收者接收消息之后需向队列应答成功 2.2 Pub/Sub 模型 2.2.1 相关对象 主题（Topic） 发布者（Publisher） 订阅者（Subscriber） 2.2.2 过程发布者向一个特定的主题发布消息，0 或多个订阅者可能对该特定主题的消息感兴趣并接收；这种模型下，发布者和订阅者彼此不知道对方。 2.2.3 特点 每个消息可以有多个消费者 发布者和订阅者之间有时间上的依赖性。订阅者必须保持持续的运行状态才能接收到消息 JMS 提供了持久化订阅，这时候，订阅者未连接主题时（发布者）发布的消息，将在订阅者重新连接时进行重新发布，以便订阅者接收消息 3. 消息的消费在 JMS 中，消息的产生和消息是异步的。对于消费来说，JMS 的消息者可以通过两种方式来消费消息。 同步：接收者或订阅者调用receive()方法来接收消息，消息到达（或超时）之前将一直阻塞。 异步：接收者或订阅者可以注册为一个消息监听器，当消息到达之后，系统会自动调用监听器的onMessage方法。 4. 消息的组成消息传递系统的中心就是消息，一条消息由三个部分组成：头、属性、主体。 4.1 头（head）每条 JMS 消息都必须具有消息头。头字段包含用于路由和识别消息的值。可以通过多种方式来设置消息头的值：1. 由 JMS 提供者在生成或传送消息的过程中自动设置2. 由生产者客户机通过在创建消息生产者时指定的设置进行设置3. 由生产者客户机逐一对各条消息进行设置 4.2 属性（property）消息可以包含称作属性的可选头字段。他们是以属性名和属性值对的形式制定的。可以将属性视为消息头的扩展，其中可以包括如下信息：创建数据的进程、数据的创建时间以及每条数据的结构。JMS 提供者也可以添加影响消息处理的属性，如是否应压缩消息或如何在消息生命周期结束时废弃消息。 4.3 主体（body）包含要发送的内容。每个消息接口特定于它所支持的内容类型。JMS 为不同类型的内容提供了他们各自的消息类型，但是所有消息都派生自 Message 接口。 StreamMessage：一种主体中包含 Java 基元值流的消息。其填充和读取均按顺序进行。 MapMessage：一种主体中包含一组键–值对的消息。没有定义条目顺序。 TextMessage：一种主体中包含 Java 字符串的消息（例如，XML 消息）。 ObjectMessage：一种主体中包含序列化 Java 对象的消息。 BytesMessage：一种主体中包含连续字节流的消息。 5. JMS 编程模型5.1 ConnectionFactory（连接工厂）创建 Connection 对象的工厂，针对两种不同的 jms 消息模型，分别有 QueueConnectionFactory 和 TopicConnectionFactory 两种。可以通过 JNDI 来查找 ConnectionFactory 对象。 5.2 Destination（目标）Destination 的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的 Destination 是某个队列（Queue）或某个主题（Topic）; 对于消息消费者来说，它的 Destination 也是某个队列或主题（即消息来源）。 所以，Destination 实际上就是两种类型的对象：Queue、Topic 可以通过 JNDI 来查找 Destination。 5.3 Connection（连接）Connection 表示在客户端和 JMS 系统之间建立的链接（对 TCP/IP socket 的包装）。Connection 可以产生一个或多个 Session。跟 ConnectionFactory 一样，Connection 也有两种类型：QueueConnection 和 TopicConnection。 5.4 Session（会话）Session 是我们操作消息的接口。可以通过 session 创建生产者、消费者、消息等。Session 提供了事务的功能。当我们需要使用 session 发送 / 接收多个消息时，可以将这些发送 / 接收动作放到一个事务中。同样，也分 QueueSession 和 TopicSession。 5.5 MessageProducer（消息生产者）消息生产者由 Session 创建，并用于将消息发送到 Destination。同样，消息生产者分两种类型：QueueSender 和 TopicPublisher。可以调用消息生产者的方法（send 或 publish 方法）发送消息。 5.6 MessageConsumer（消息消费者）消息消费者由 Session 创建，用于接收被发送到 Destination 的消息。两种类型：QueueReceiver 和 TopicSubscriber。可分别通过 session 的 createReceiver(Queue) 或 createSubscriber(Topic) 来创建。当然，也可以 session 的 creatDurableSubscriber 方法来创建持久化的订阅者。 5.7 Message（消息）是在消费者和生产者之间传送的对象，也就是说从一个应用程序传送到另一个应用程序。 5.7 MessageListener消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的 onMessage 方法。 参考：ActiveMQ学习（一）了解JMS - CSDN博客https://blog.csdn.net/qq_16313365/article/details/78452396]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列之 ZeroMQ]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-9%2F</url>
    <content type="text"><![CDATA[ZeroMQ 消息队列介绍ZeroMQ官方说法： ZMQ 是一个简单好用的传输层，像框架一样的一个 socket library，它使得 Socket编程更加简单、简洁和性能更高。它是一个消息处理队列库，可在多线程、内核和主机盒之间弹性伸缩。ZMQ 的明确目标是 “成为标准网络协议栈的一部分，之后进入 Linux 内核”。现在还未看到它们的成功，但是，它无疑是极具前景的、并且是人们更加需要的 “传统”BSD 套接字之上的一层封装。ZMQ 让编写高性能网络应用程序极为简单和有趣。 特点连接先后顺序无关、自动重连机制。ZeroMQ 的 socket 有个特色就是对于谁先 bind 谁后 connect 之类的完全都不在乎，如果是 connect 先行，发现连接无法建立，ZMQ 会自动重试，当 bind 也确立了，连线就自动接上了。 多人 Socket 连线、多位址绑定。ZMQ 的 socket 之间可以多个互相连线，所以一个 socket 的另一端可能有 N 个结点连接，除此之外，同一个 socket 也可以绑在不同的位址上。 自动负载平衡。REQ 端会将 send 的 message 用 Round-robin 的方式（这个又是什么？）分给所有远端连线，而你有多少个连线，他都会照一样的规则分配。 讯息传输。ZMQ 可以提供你传送多段资料在一笔讯息里，因此我们在这看到的 send_multipart 和 recv_multipart 作用即为如此，有了这样的特性，就不同担心通讯协定的问题，只需专心处理讯息。 支援不同的通讯方式。TCP、IPC（目前只支援 Linux 下的 domain socket）、基于 UDP 的广播通讯方式（节省大量的重复封包传送）、thread 之间的通讯方式，故如果你的两个节点放在同一个 process 里，为了效能考量，你可以用这种协定让通讯效率最佳化。 更多的样式 REQ/REP 样式：一个 request 一个 response，而 REQ 端会对所有的连线做 fairly queue，也就是会公平第把 request 塞给 REP 端。 PUB/SUB 样式：观察者模式，特点是所有 PUB 发送的消息会广播给所有 SUB 的连线，而且 SUB 可以设定只要某段字串开头的讯息。 PUSH/PULL 样式：当我们需要将资料往某个方向负载平衡地推送，就可以使用这种样式，PUSH 会将负载分散给 PULL 端，而且只能由 PUSH 推往 PULL。 PAIR 样式：和一般的 socket 一样，一对一连线。 多样式参杂实现分散式服务器 使用 ZMQ，使分散式系统的实现难度降低，因为通讯的部份由 ZMQ 来完成了，开发者只要专心考虑节点之间的拓扑与连接方式、通讯方式，以及讯息的处理。ZMQ 的本意是用于即时处理大量的金融资料，效率更是 ZMQ 的金字招牌之一。 ZeroMQ 只是一个网络编程的 Pattern 库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之 socket 之上、MQ 之下。对于 MQ 来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker 服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。 为什么我希望用 C 而不是 C++ 来实现 ZeroMQZeroMQ 是需要长期连续不停运行的一个网络库，它应该永远不会出错，而且永远不能出现未定义的行为。因此，错误处理对于 ZeroMQ 来说至关重要，错误处理必须是非常明确的而且对错误应该是零容忍的。 但是 C++ 的异常处理机制却无法满足这个要求。C++ 的异常机制对于确保程序不会失败时非常有效的——只要将主函数包装在 try/catch 块中，然后你就可以在一个单独的位置处理所有的错误。然而，当你的目标是确保没有未定义行为发生时，噩梦就产生了。C++ 中引发异常和处理异常时松耦合的，这使得在 C++ 中避免错误是十分容易的，但却使得保证程序永远不会出现未定义行为变得基本不可能。 在 C 语言中，引发错误和处理错误的部分是紧耦合的，它们在源代码中处于同一个位置，使得我们在错误发生时能很容易理解到底发生了什么。 ZeroMQ 的层级模型最顶层的是 ZObject 与 IPollEvent。 ZObject 是所有 ZeroMQ 体系中类的父类，它存在的意义是发送与接收命令（命令是指告诉 ZeroMQ 该做什么，需要做什么）。 IPollEvent 则是一个接口，定义了若干操作，包括读操作，写操作，客户端请求连接，服务端应答连接，超时操作等共 5 个操作，其实现类包括 Req、Rep 等具体 Socket，该接口的目的是顶你一终端间发生操作时的行为。 Ctx 是一个上下文类，通常一个终端只需要创建一个上下文。 IOObject 本身并没有太多的属性，主要是其内部维护了一个 IOThread。 MailBox 是一个重要的类，它被用作处理命令，包括命令的发送与接收，需要注意的是，这里的命令其实是本地发送的，不是端点间发送的。 Pipe 用于处理接收到或者需要发送的数据，是实际存储待处理数据的数据结构，其内部是用队列的形式实现的。 LB、FQ 全名分别为 “LoadBalance” 和“FairQueue”，也就是负载均衡与公平排队分别用于处理要发送的数据与要接收的数据。 SocketBase 是例如 Req、Rep、Pull 等包装后 Socket 的父类。其内含有一对 Pipe，用于在 SocketBase 与 SessionBase 之间传递消息，具体传递过程在接下去说明。 SessionBase 是创建 SocketChannel 并与目标终端进行连接的地方，是与底层 Poller 最先进行交互的一层（通过 StreamEngine 进行交互）。具有超时重连，断线重连等功能。 Poller 是整个 ZeroMQ 的核心，它实现了命令的发送与接收，数据的发送与接收。由他来真正的发送数据到其他终端，也是他处理来自其他终端的数据后交给 SessionBase。 基于此层级模型的交互逻辑： 发送消息 Socket -&gt; Session -&gt; StreamEngine -&gt; Poller 接收消息 Poller -&gt; StreamEngine -&gt; Session -&gt; Socket 参考：ZeroMQ消息队列介绍 - Dyman博客http://www.dyman.xyz/2017/10/10/zeromq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D/]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列之 RabbitMQ]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-8%2F</url>
    <content type="text"><![CDATA[市面上的消息队列产品有很多，比如老牌的 ActiveMQ、RabbitMQ ，目前我看最火的 Kafka ，还有 ZeroMQ ，去年底阿里巴巴捐赠给 Apache 的 RocketMQ ，连 redis 这样的 NoSQL 数据库也支持 MQ 功能。总之这块知名的产品就有十几种，就我自己的使用经验和兴趣只打算谈谈 RabbitMQ、Kafka 和 ActiveMQ ，本文先讲 RabbitMQ ，在此之前先看下消息队列的相关概念。 RabbitMQ 特点RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。 AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括： 可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。 灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。 消息集群（Clustering）多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。 高可用（Highly Available Queues）队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 多语言客户端（Many Clients）RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。 管理界面（Management UI）RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。 跟踪机制（Tracing）如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 插件机制（Plugin System）RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 RabbitMQ 中的概念模型消息模型所有 MQ 产品从模型抽象上来说都是一样的过程：消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。 RabbitMQ 基本概念上面只是最简单抽象的描述，具体到 RabbitMQ 则有更详细的概念需要解释。上面介绍过 RabbitMQ 是 AMQP 协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念： Message消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Exchange交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Binding绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 Queue消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。 Connection网络连接，比如一个 TCP 连接。 Channel信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。 Consumer消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 Virtual Host虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。 Broker表示消息队列服务器实体。 AMQP 中的消息路由AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。 Exchange 类型Exchange 分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型： direct 消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为 “dog”，则只转发 routing key 标记为“dog” 的消息，不会转发 “dog.puppy”，也不会转发“dog.guard” 等等。它是完全匹配、单播的模式。 fanout 每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。 topic topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号 “#” 和符号“”。# 匹配 0 个或多个单词，匹配不多不少一个单词。 RabbitMQ 安装一般来说安装 RabbitMQ 之前要安装 Erlang ，可以去 Erlang 官网下载。接着去 RabbitMQ 官网下载安装包，之后解压缩即可。根据操作系统不同官网提供了相应的安装说明：Windows、Debian / Ubuntu、RPM-based Linux、Mac 如果是 Mac 用户，个人推荐使用 HomeBrew 来安装，安装前要先更新 brew： 1brew update 接着安装 rabbitmq 服务器： 1brew install rabbitmq 这样 RabbitMQ 就安装好了，安装过程中会自动其所依赖的 Erlang 。 RabbitMQ 运行和管理 启动启动很简单，找到安装后的 RabbitMQ 所在目录下的 sbin 目录，可以看到该目录下有 6 个以 rabbitmq 开头的可执行文件，直接执行 rabbitmq-server 即可，下面将 RabbitMQ 的安装位置以 . 代替，启动命令就是： 1./sbin/rabbitmq-server 启动正常的话会看到一些启动过程信息和最后的 completed with 7 plugins，这也说明启动的时候默认加载了 7 个插件。 后台启动如果想让 RabbitMQ 以守护程序的方式在后台运行，可以在启动的时候加上 -detached 参数： 1./sbin/rabbitmq-server -detached 查询服务器状态sbin 目录下有个特别重要的文件叫 rabbitmqctl ，它提供了 RabbitMQ 管理需要的几乎一站式解决方案，绝大部分的运维命令它都可以提供。查询 RabbitMQ 服务器的状态信息可以用参数 status ： 1./sbin/rabbitmqctl status 该命令将输出服务器的很多信息，比如 RabbitMQ 和 Erlang 的版本、OS 名称、内存等等 关闭 RabbitMQ 节点我们知道 RabbitMQ 是用 Erlang 语言写的，在 Erlang 中有两个概念：节点和应用程序。节点就是 Erlang 虚拟机的每个实例，而多个 Erlang 应用程序可以运行在同一个节点之上。节点之间可以进行本地通信（不管他们是不是运行在同一台服务器之上）。比如一个运行在节点 A 上的应用程序可以调用节点 B 上应用程序的方法，就好像调用本地函数一样。如果应用程序由于某些原因奔溃，Erlang 节点会自动尝试重启应用程序。如果要关闭整个 RabbitMQ 节点可以用参数 stop ： 1./sbin/rabbitmqctl stop 它会和本地节点通信并指示其干净的关闭，也可以指定关闭不同的节点，包括远程节点，只需要传入参数 -n ： 1./sbin/rabbitmqctl -n rabbit@server.example.com stop -n node 默认 node 名称是 rabbit@server ，如果你的主机名是 server.example.com ，那么 node 名称就是 rabbit@server.example.com 。 关闭 RabbitMQ 应用程序如果只想关闭应用程序，同时保持 Erlang 节点运行则可以用 stop_app： 1./sbin/rabbitmqctl stop_app 这个命令在后面要讲的集群模式中将会很有用。 启动 RabbitMQ 应用程序 1./sbin/rabbitmqctl start_app 重置 RabbitMQ 节点 1./sbin/rabbitmqctl reset 该命令将清除所有的队列。 查看已声明的队列 1./sbin/rabbitmqctl list_queues 查看交换器 1./sbin/rabbitmqctl list_exchanges 该命令还可以附加参数，比如列出交换器的名称、类型、是否持久化、是否自动删除： 1./sbin/rabbitmqctl list_exchanges name type durable auto_delete 查看绑定 1./sbin/rabbitmqctl list_bindings Java 客户端访问RabbitMQ 支持多种语言访问，以 Java 为例看下一般使用 RabbitMQ 的步骤。 maven 工程的 pom 文件中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt; 消息生产者 1234567891011121314151617181920212223242526272829303132package org.study.rabbitmq;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(&quot;guest&quot;); factory.setPassword(&quot;guest&quot;); //设置 RabbitMQ 地址 factory.setHost(&quot;localhost&quot;); //建立到代理服务器到连接 Connection conn = factory.newConnection(); //获得信道 Channel channel = conn.createChannel(); //声明交换器 String exchangeName = &quot;hello-exchange&quot;; channel.exchangeDeclare(exchangeName, &quot;direct&quot;, true); String routingKey = &quot;hola&quot;; //发布消息 byte[] messageBodyBytes = &quot;quit&quot;.getBytes(); channel.basicPublish(exchangeName, routingKey, null, messageBodyBytes); channel.close(); conn.close(); &#125;&#125; 消息消费者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.study.rabbitmq;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(&quot;guest&quot;); factory.setPassword(&quot;guest&quot;); factory.setHost(&quot;localhost&quot;); //建立到代理服务器到连接 Connection conn = factory.newConnection(); //获得信道 final Channel channel = conn.createChannel(); //声明交换器 String exchangeName = &quot;hello-exchange&quot;; channel.exchangeDeclare(exchangeName, &quot;direct&quot;, true); //声明队列 String queueName = channel.queueDeclare().getQueue(); String routingKey = &quot;hola&quot;; //绑定队列，通过键 hola 将队列和交换器绑定起来 channel.queueBind(queueName, exchangeName, routingKey); while(true) &#123; //消费消息 boolean autoAck = false; String consumerTag = &quot;&quot;; channel.basicConsume(queueName, autoAck, consumerTag, new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String routingKey = envelope.getRoutingKey(); String contentType = properties.getContentType(); System.out.println(&quot;消费的路由键：&quot; + routingKey); System.out.println(&quot;消费的内容类型：&quot; + contentType); long deliveryTag = envelope.getDeliveryTag(); //确认消息 channel.basicAck(deliveryTag, false); System.out.println(&quot;消费的消息体内容：&quot;); String bodyStr = new String(body, &quot;UTF-8&quot;); System.out.println(bodyStr); &#125; &#125;); &#125; &#125;&#125; 启动 RabbitMQ 服务器 1./sbin/rabbitmq-server 运行 Consumer先运行 Consumer ，这样当生产者发送消息的时候能在消费者后端看到消息记录。 运行 Producer接着运行 Producer , 发布一条消息，在 Consumer 的控制台能看到接收的消息： RabbitMQ 集群RabbitMQ 最优秀的功能之一就是内建集群，这个功能设计的目的是允许消费者和生产者在节点崩溃的情况下继续运行，以及通过添加更多的节点来线性扩展消息通信吞吐量。RabbitMQ 内部利用 Erlang 提供的分布式通信框架 OTP 来满足上述需求，使客户端在失去一个 RabbitMQ 节点连接的情况下，还是能够重新连接到集群中的任何其他节点继续生产、消费消息。 RabbitMQ 集群中的一些概念RabbitMQ 会始终记录以下四种类型的内部元数据： 队列元数据包括队列名称和它们的属性，比如是否可持久化，是否自动删除 交换器元数据交换器名称、类型、属性 绑定元数据内部是一张表格记录如何将消息路由到队列 vhost 元数据为 vhost 内部的队列、交换器、绑定提供命名空间和安全属性 在单一节点中，RabbitMQ 会将所有这些信息存储在内存中，同时将标记为可持久化的队列、交换器、绑定存储到硬盘上。存到硬盘上可以确保队列和交换器在节点重启后能够重建。而在集群模式下同样也提供两种选择：存到硬盘上（独立节点的默认设置），存在内存中。 如果在集群中创建队列，集群只会在单个节点而不是所有节点上创建完整的队列信息（元数据、状态、内容）。结果是只有队列的所有者节点知道有关队列的所有信息，因此当集群节点崩溃时，该节点的队列和绑定就消失了，并且任何匹配该队列的绑定的新消息也丢失了。还好 RabbitMQ 2.6.0 之后提供了镜像队列以避免集群节点故障导致的队列内容不可用。 RabbitMQ 集群中可以共享 user、vhost、exchange 等，所有的数据和状态都是必须在所有节点上复制的，例外就是上面所说的消息队列。RabbitMQ 节点可以动态的加入到集群中。 当在集群中声明队列、交换器、绑定的时候，这些操作会直到所有集群节点都成功提交元数据变更后才返回。集群中有内存节点和磁盘节点两种类型，内存节点虽然不写入磁盘，但是它的执行比磁盘节点要好。内存节点可以提供出色的性能，磁盘节点能保障配置信息在节点重启后仍然可用，那集群中如何平衡这两者呢？ RabbitMQ 只要求集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入火离开集群时，它们必须要将该变更通知到至少一个磁盘节点。如果只有一个磁盘节点，刚好又是该节点崩溃了，那么集群可以继续路由消息，但不能创建队列、创建交换器、创建绑定、添加用户、更改权限、添加或删除集群节点。换句话说集群中的唯一磁盘节点崩溃的话，集群仍然可以运行，但知道该节点恢复，否则无法更改任何东西。 RabbitMQ 集群配置和启动如果是在一台机器上同时启动多个 RabbitMQ 节点来组建集群的话，只用上面介绍的方式启动第二、第三个节点将会因为节点名称和端口冲突导致启动失败。所以在每次调用 rabbitmq-server 命令前，设置环境变量 RABBITMQ_NODENAME 和 RABBITMQ_NODE_PORT 来明确指定唯一的节点名称和端口。下面的例子端口号从 5672 开始，每个新启动的节点都加 1，节点也分别命名为 test_rabbit_1、test_rabbit_2、test_rabbit_3。 启动第 1 个节点： 1RABBITMQ_NODENAME=test_rabbit_1 RABBITMQ_NODE_PORT=5672 ./sbin/rabbitmq-server -detached 启动第 2 个节点： 1RABBITMQ_NODENAME=test_rabbit_2 RABBITMQ_NODE_PORT=5673 ./sbin/rabbitmq-server -detached 启动第 2 个节点前建议将 RabbitMQ 默认激活的插件关掉，否则会存在使用了某个插件的端口号冲突，导致节点启动不成功。 现在第 2 个节点和第 1 个节点都是独立节点，它们并不知道其他节点的存在。集群中除第一个节点外后加入的节点需要获取集群中的元数据，所以要先停止 Erlang 节点上运行的 RabbitMQ 应用程序，并重置该节点元数据，再加入并且获取集群的元数据，最后重新启动 RabbitMQ 应用程序。 停止第 2 个节点的应用程序： 1./sbin/rabbitmqctl -n test_rabbit_2 stop_app 重置第 2 个节点元数据： 1./sbin/rabbitmqctl -n test_rabbit_2 reset 第 2 节点加入第 1 个节点组成的集群： 1./sbin/rabbitmqctl -n test_rabbit_2 join_cluster test_rabbit_1@localhost 启动第 2 个节点的应用程序 1./sbin/rabbitmqctl -n test_rabbit_2 start_app 第 3 个节点的配置过程和第 2 个节点类似： 123456789RABBITMQ_NODENAME=test_rabbit_3 RABBITMQ_NODE_PORT=5674 ./sbin/rabbitmq-server -detached./sbin/rabbitmqctl -n test_rabbit_3 stop_app./sbin/rabbitmqctl -n test_rabbit_3 reset./sbin/rabbitmqctl -n test_rabbit_3 join_cluster test_rabbit_1@localhost./sbin/rabbitmqctl -n test_rabbit_3 start_app RabbitMQ 集群运维停止某个指定的节点，比如停止第 2 个节点： 1RABBITMQ_NODENAME=test_rabbit_2 ./sbin/rabbitmqctl stop 查看节点 3 的集群状态： 1./sbin/rabbitmqctl -n test_rabbit_3 cluster_status 参考：消息队列之 RabbitMQ - 简书https://www.jianshu.com/p/79ca08116d57?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负载均衡和LVS]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-7%2F</url>
    <content type="text"><![CDATA[在大规模互联网应用中，负载均衡设备是必不可少的一个节点，源于互联网应用的高并发和大流量的冲击压力，我们通常会在服务端部署多个无状态的应用服务器和若干有状态的存储服务器（数据库、缓存等等）。 一、负载均衡的作用 负载均衡设备的任务就是作为应用服务器流量的入口，挑选最合适的一台服务器，将客户端的请求转发给它处理，实现客户端到真实服务端的透明转发。最近几年很火的「云计算」以及分布式架构，本质上也是将后端服务器作为计算资源、存储资源，由某台管理服务器封装成一个服务对外提供，客户端不需要关心真正提供服务的是哪台机器，在它看来，就好像它面对的是一台拥有近乎无限能力的服务器，而本质上，真正提供服务的，是后端的集群。 一个典型的互联网应用的拓扑结构是这样的： 二、负载均衡的类型 负载均衡可以采用硬件设备，也可以采用软件负载。 商用硬件负载设备成本通常较高（一台几十万上百万很正常），所以在条件允许的情况下我们会采用软负载，软负载解决的两个核心问题是：选谁、转发，其中最著名的是 LVS（Linux Virtual Server）。 三、软负载——LVS LVS 是四层负载均衡，也就是说建立在 OSI 模型的第四层——传输层之上，传输层上有我们熟悉的 TCP/UDP，LVS 支持 TCP/UDP 的负载均衡。 LVS 的转发主要通过修改 IP 地址（NAT 模式，分为源地址修改 SNAT 和目标地址修改 DNAT）、修改目标 MAC（DR 模式）来实现。 那么为什么 LVS 是在第四层做负载均衡？ 首先 LVS 不像 HAProxy 等七层软负载面向的是 HTTP 包，所以七层负载可以做的 URL 解析等工作，LVS 无法完成。其次，某次用户访问是与服务端建立连接后交换数据包实现的，如果在第三层网络层做负载均衡，那么将失去「连接」的语义。软负载面向的对象应该是一个已经建立连接的用户，而不是一个孤零零的 IP 包。后面会看到，实际上 LVS 的机器代替真实的服务器与用户通过 TCP 三次握手建立了连接，所以 LVS 是需要关心「连接」级别的状态的。 LVS 的工作模式主要有 4 种： DR NAT TUNNEL Full-NAT 这里挑选常用的 DR、NAT、Full-NAT 来简单介绍一下。 1、DR 请求由 LVS 接受，由真实提供服务的服务器（RealServer, RS）直接返回给用户，返回的时候不经过 LVS。 DR 模式下需要 LVS 和绑定同一个 VIP（RS 通过将 VIP 绑定在 loopback 实现）。 一个请求过来时，LVS 只需要将网络帧的 MAC 地址修改为某一台 RS 的 MAC，该包就会被转发到相应的 RS 处理，注意此时的源 IP 和目标 IP 都没变，LVS 只是做了一下移花接木。 RS 收到 LVS 转发来的包，链路层发现 MAC 是自己的，到上面的网络层，发现 IP 也是自己的，于是这个包被合法地接受，RS 感知不到前面有 LVS 的存在。 而当 RS 返回响应时，只要直接向源 IP（即用户的 IP）返回即可，不再经过 LVS。 DR 模式是性能最好的一种模式。 2、NAT NAT（Network Address Translation）是一种外网和内网地址映射的技术。 NAT 模式下，网络报的进出都要经过 LVS 的处理。LVS 需要作为 RS 的网关。 当包到达 LVS 时，LVS 做目标地址转换（DNAT），将目标 IP 改为 RS 的 IP。RS 接收到包以后，仿佛是客户端直接发给它的一样。 RS 处理完，返回响应时，源 IP 是 RS IP，目标 IP 是客户端的 IP。 这时 RS 的包通过网关（LVS）中转，LVS 会做源地址转换（SNAT），将包的源地址改为 VIP，这样，这个包对客户端看起来就仿佛是 LVS 直接返回给它的。客户端无法感知到后端 RS 的存在。 3、Full-NAT 无论是 DR 还是 NAT 模式，不可避免的都有一个问题：LVS 和 RS 必须在同一个 VLAN 下，否则 LVS 无法作为 RS 的网关。 这引发的两个问题是： 1、同一个 VLAN 的限制导致运维不方便，跨 VLAN 的 RS 无法接入。 2、LVS 的水平扩展受到制约。当 RS 水平扩容时，总有一天其上的单点 LVS 会成为瓶颈。 Full-NAT 由此而生，解决的是 LVS 和 RS 跨 VLAN 的问题，而跨 VLAN 问题解决后，LVS 和 RS 不再存在 VLAN 上的从属关系，可以做到多个 LVS 对应多个 RS，解决水平扩容的问题。 Full-NAT 相比 NAT 的主要改进是，在 SNAT/DNAT 的基础上，加上另一种转换，转换过程如下： 在包从 LVS 转到 RS 的过程中，源地址从客户端 IP 被替换成了 LVS 的内网 IP。 内网 IP 之间可以通过多个交换机跨 VLAN 通信。 当 RS 处理完接受到的包，返回时，会将这个包返回给 LVS 的内网 IP，这一步也不受限于 VLAN。 LVS 收到包后，在 NAT 模式修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内网 IP 改为客户端的 IP。 Full-NAT 主要的思想是把网关和其下机器的通信，改为了普通的网络通信，从而解决了跨 VLAN 的问题。采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的便利性。 4、Session 客户端与服务端的通信，一次请求可能包含多个 TCP 包，LVS 必须保证同一连接的 TCP 包，必须被转发到同一台 RS，否则就乱套了。为了确保这一点，LVS 内部维护着一个 Session 的 Hash 表，通过客户端的某些信息可以找到应该转发到哪一台 RS 上。 5、LVS 集群化 采用 Full-NAT 模式后，可以搭建 LVS 的集群，拓扑结构如下图： 6、容灾 容灾分为 RS 的容灾和 LVS 的容灾。 RS 的容灾可以通过 LVS 定期健康检测实现，如果某台 RS 失去心跳，则认为其已经下线，不会在转发到该 RS 上。 LVS 的容灾可以通过主备 + 心跳的方式实现。主 LVS 失去心跳后，备 LVS 可以作为热备立即替换。 容灾主要是靠 KeepAlived 来做的。 参考：Web基础架构：负载均衡和LVS - ImportNewhttp://www.importnew.com/11229.html]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redisson项目介绍]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-6%2F</url>
    <content type="text"><![CDATA[Redisson项目介绍Redisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。 Redisson采用了基于NIO的Netty框架，不仅能作为Redis底层驱动客户端，具备提供对Redis各种组态形式的连接功能，对Redis命令能以同步发送、异步形式发送、异步流形式发送或管道形式发送的功能，LUA脚本执行处理，以及处理返回结果的功能，还在此基础上融入了更高级的应用方案，不但将原生的Redis Hash，List，Set，String，Geo，HyperLogLog等数据结构封装为Java里大家最熟悉的映射（Map），列表（List），集（Set），通用对象桶（Object Bucket），地理空间对象桶（Geospatial Bucket），基数估计算法（HyperLogLog）等结构，在这基础上还提供了分布式的多值映射（Multimap），本地缓存映射（LocalCachedMap），有序集（SortedSet），计分排序集（ScoredSortedSet），字典排序集（LexSortedSet），列队（Queue），阻塞队列（Blocking Queue），有界阻塞列队（Bounded Blocking Queue），双端队列（Deque），阻塞双端列队（Blocking Deque），阻塞公平列队（Blocking Fair Queue），延迟列队（Delayed Queue），布隆过滤器（Bloom Filter），原子整长形（AtomicLong），原子双精度浮点数（AtomicDouble），BitSet等Redis原本没有的分布式数据结构。不仅如此，Redisson还实现了Redis文档中提到像分布式锁Lock这样的更高阶应用场景。事实上Redisson并没有不止步于此，在分布式锁的基础上还提供了联锁（MultiLock），读写锁（ReadWriteLock），公平锁（Fair Lock），红锁（RedLock），信号量（Semaphore），可过期性信号量（PermitExpirableSemaphore）和闭锁（CountDownLatch）这些实际当中对多线程高并发应用至关重要的基本部件。正是通过实现基于Redis的高阶应用方案，使Redisson成为构建分布式系统的重要工具。 在提供这些工具的过程当中，Redisson广泛的使用了承载于Redis订阅发布功能之上的分布式话题（Topic）功能。使得即便是在复杂的分布式环境下，Redisson的各个实例仍然具有能够保持相互沟通的能力。在以这为前提下，结合了自身独有的功能完善的分布式工具，Redisson进而提供了像分布式远程服务（Remote Service），分布式执行服务（Executor Service）和分布式调度任务服务（Scheduler Service）这样适用于不同场景的分布式服务。使得Redisson成为了一个基于Redis的Java中间件（Middleware）。 Redisson Node的出现作为驻内存数据网格的重要特性之一，使Redisson能够独立作为一个任务处理节点，以系统服务的方式运行并自动加入Redisson集群，具备集群节点弹性增减的能力。然而在真正意义上让Redisson发展成为一个完整的驻内存数据网格的，还是具有将基本上任何复杂、多维结构的对象都能变为分布式对象的分布式实时对象服务（Live Object Service），以及与之相结合的，在分布式环境中支持跨节点对象引用（Distributed Object Reference）的功能。这些特色功能使Redisson具备了在分布式环境中，为Java程序提供了堆外空间（Off-Heap Memory）储存对象的能力。 Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。如果您现在正在使用其他的Redis的Java客户端，希望Redis命令和Redisson对象匹配列表 能够帮助您轻松的将现有代码迁徙到Redisson框架里来。如果目前Redis的应用场景还仅限于作为缓存使用，您也可以将Redisson轻松的整合到像Spring和Hibernate这样的常用框架里。除此外您也可以间接的通过Java缓存标准规范JCache API (JSR-107)接口来使用Redisson。 Redisson生而具有的高性能，分布式特性和丰富的结构等特点恰巧与Tomcat这类服务程序对会话管理器（Session Manager）的要求相吻合。利用这样的特点，Redisson专门为Tomcat提供了会话管理器（Tomcat Session Manager）。 在此不难看出，Redisson同其他Redis Java客户端有着很大的区别，相比之下其他客户端提供的功能还仅仅停留在作为数据库驱动层面上，比如仅针对Redis提供连接方式，发送命令和处理返回结果等。像上面这些高层次的应用则只能依靠使用者自行实现。 Redisson支持Redis 2.8以上版本，支持Java1.6+以上版本。 关于Redisson项目的详细介绍可以在官方网站找到。 每个Redis服务实例都能管理多达1TB的内存。 能够完美的在云计算环境里使用，并且支持AWS ElastiCache主备版，AWS ElastiCache集群版，Azure Redis Cache和阿里云（Aliyun）的云数据库Redis版 1. 概述以下是Redisson的结构： Redisson作为独立节点 可以用于独立执行其他节点发布到分布式执行服务 和 分布式调度任务服务 里的远程任务。 如果你现在正在使用其他的Redis的Java客户端，那么Redis命令和Redisson对象匹配列表 能够帮助你轻松的将现有代码迁徙到Redisson框架里来。 Redisson底层采用的是Netty 框架。支持Redis 2.8以上版本，支持Java1.6+以上版本。 欢迎试用高性能Redisson PRO版。 8. 分布式锁和同步器8.1. 可重入锁（Reentrant Lock）基于Redis的Redisson分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口。 123RLock lock = redisson.getLock("anyLock");// 最常见的使用方法lock.lock(); 大家都知道，如果负责储存这个分布式锁的Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。 另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。 12345678// 加锁以后10秒钟自动解锁// 无需调用unlock方法手动解锁lock.lock(10, TimeUnit.SECONDS);// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);...lock.unlock(); Redisson同时还为分布式锁提供了异步执行的相关方法： 1234RLock lock = redisson.getLock("anyLock");lock.lockAsync();lock.lockAsync(10, TimeUnit.SECONDS);Future&lt;Boolean&gt; res = lock.tryLockAsync(100, 10, TimeUnit.SECONDS); RLock对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出IllegalMonitorStateException错误。但是如果遇到需要其他进程也能解锁的情况，请使用分布式信号量Semaphore 对象. 8.2. 公平锁（Fair Lock）基于Redis的Redisson分布式可重入公平锁也是实现了java.util.concurrent.locks.Lock接口的一种RLock对象。它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。 123RLock fairLock = redisson.getFairLock("anyLock");// 最常见的使用方法fairLock.lock(); 大家都知道，如果负责储存这个分布式锁的Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。 另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。 12345678// 10秒钟以后自动解锁// 无需调用unlock方法手动解锁fairLock.lock(10, TimeUnit.SECONDS);// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁boolean res = fairLock.tryLock(100, 10, TimeUnit.SECONDS);...fairLock.unlock(); Redisson同时还为分布式可重入公平锁提供了异步执行的相关方法：1234RLock fairLock = redisson.getFairLock("anyLock");fairLock.lockAsync();fairLock.lockAsync(10, TimeUnit.SECONDS);Future&lt;Boolean&gt; res = fairLock.tryLockAsync(100, 10, TimeUnit.SECONDS); 8.3. 联锁（MultiLock）基于Redis的Redisson分布式联锁RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。 12345678910RLock lock1 = redissonInstance1.getLock("lock1");RLock lock2 = redissonInstance2.getLock("lock2");RLock lock3 = redissonInstance3.getLock("lock3");RedissonMultiLock lock = new RedissonMultiLock(lock1, lock2, lock3);// 同时加锁：lock1 lock2 lock3// 所有的锁都上锁成功才算成功。lock.lock();...lock.unlock(); 大家都知道，如果负责储存某些分布式锁的某些Redis节点宕机以后，而且这些锁正好处于锁住的状态时，这些锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。 另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。 12345678RedissonMultiLock lock = new RedissonMultiLock(lock1, lock2, lock3);// 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开lock.lock(10, TimeUnit.SECONDS);// 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);...lock.unlock(); 8.4. 红锁（RedLock）基于Redis的Redisson红锁RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。 12345678910RLock lock1 = redissonInstance1.getLock("lock1");RLock lock2 = redissonInstance2.getLock("lock2");RLock lock3 = redissonInstance3.getLock("lock3");RedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);// 同时加锁：lock1 lock2 lock3// 红锁在大部分节点上加锁成功就算成功。lock.lock();...lock.unlock(); 大家都知道，如果负责储存某些分布式锁的某些Redis节点宕机以后，而且这些锁正好处于锁住的状态时，这些锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。 另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。 12345678RedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);// 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开lock.lock(10, TimeUnit.SECONDS);// 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);...lock.unlock(); 8.5. 读写锁（ReadWriteLock）基于Redis的Redisson分布式可重入读写锁RReadWriteLock Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。同时还支持自动过期解锁。该对象允许同时有多个读取锁，但是最多只能有一个写入锁。12345RReadWriteLock rwlock = redisson.getLock("anyRWLock");// 最常见的使用方法rwlock.readLock().lock();// 或rwlock.writeLock().lock(); 大家都知道，如果负责储存这个分布式锁的Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。 另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。 123456789101112// 10秒钟以后自动解锁// 无需调用unlock方法手动解锁rwlock.readLock().lock(10, TimeUnit.SECONDS);// 或rwlock.writeLock().lock(10, TimeUnit.SECONDS);// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁boolean res = rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);// 或boolean res = rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);...lock.unlock(); 8.6. 信号量（Semaphore）基于Redis的Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。 123456789101112131415RSemaphore semaphore = redisson.getSemaphore("semaphore");semaphore.acquire();//或semaphore.acquireAsync();semaphore.acquire(23);semaphore.tryAcquire();//或semaphore.tryAcquireAsync();semaphore.tryAcquire(23, TimeUnit.SECONDS);//或semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);semaphore.release(10);semaphore.release();//或semaphore.releaseAsync(); 8.7. 可过期性信号量（PermitExpirableSemaphore）基于Redis的Redisson可过期性信号量（PermitExpirableSemaphore）是在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。 123456RPermitExpirableSemaphore semaphore = redisson.getPermitExpirableSemaphore("mySemaphore");String permitId = semaphore.acquire();// 获取一个信号，有效期只有2秒钟。String permitId = semaphore.acquire(2, TimeUnit.SECONDS);// ...semaphore.release(permitId); 8.8. 闭锁（CountDownLatch）基于Redisson的Redisson分布式闭锁（CountDownLatch）Java对象RCountDownLatch采用了与java.util.concurrent.CountDownLatch相似的接口和用法。 1234567RCountDownLatch latch = redisson.getCountDownLatch("anyCountDownLatch");latch.trySetCount(1);latch.await();// 在其他线程或其他JVM里RCountDownLatch latch = redisson.getCountDownLatch("anyCountDownLatch");latch.countDown(); 参考：Home · redisson/redisson Wikihttps://github.com/redisson/redisson/wiki]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式事务处理模型(DTP)]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-5%2F</url>
    <content type="text"><![CDATA[一、传统的分布式事务模型 关于分布式事务，有一个被大家广泛接受的分布式处理模型：X/Open DTP 模型。 该模型主要由 4 个组件构成：应用程序 (Application Program)[AP]、资源管理器(Resource Manager)[RM]、事务管理器(Transaction Manager)[TM] 和通信资源管理器(Communication Resource Manager)[CRM], 如下所示： 其中：AP 使用 TX 接口与 TM 交互，开始或提交全局事务； TM 给事务分配标识符，与 RM 通过 XA 接口规范，使用两阶段提交协议来完成全局事务； RM 提供对共享数据资源的访问； CRM 负责对通信进行控制； 1.1 二阶段提交协议关于二阶段提交协议，在这里不再做详细的说明，大家可以参与下图： 二阶段提交协议存在如下问题： 1、可靠性差： 当网络环境较差时，数据操作出错的机率较大，任意一个事务参与者的临时故障，甚至是数据接收的延迟，都会导致全局事务的失败； 2、处理效率低：RM 在事务执行过程及准备提交阶段需要锁定事务处理涉及到的所有数据资源，此时其它需要访问的事务就会一直处于等待状态； 3、可能存在阻塞现象 二、基于 JMS 的分布式异步处理技术基于 JMS 的分布式处理模型如下所示： 采用 JMS 消息中间件作为通信资源管理器，分布式事务处理可以转化为消息处理和传统的本地事务处理两个部分。 基于 JMS 的分布式异步事务处理模型的事务处理过程如下所示： 事务发起者：AP 调用全局 TM 启动一个全局事务，锁定数据资源执行本地操作，本地操作执行完成后，释放数据资源锁定，创建事务处理请求和事务上下文消息，发送到 JMS 消息服务器； 事务参与者：AP 通过监听事务处理请求队列，获取本地事务处理请求和事务上下文消息，调用本地 TM 开始事务的执行，事务处理结果封装成 JMS 消息发送到 JMS 服务器的事务处理结果队列； 事务发起者：全局 TM 从事务处理结果队列中获取各个事务的处理结果。 其它分布式相关资源请参见：https://yq.aliyun.com/articles/7119 另蚂蚁花呗的分布式事务管理可以参见：http://www.infoq.com/cn/articles/technical-architecture-of-alipay-and-ant-check-later 分布式事务框架的流程图： 实现： 一个完整的业务活动由一个主业务服务与若干从业务服务组成。 主业务服务负责发起并完成整个业务活动。 从业务服务提供 TCC 型业务操作。 业务活动管理器控制业务活动的一致性，它登记业务活动中的操作，并在活动提交时确认所有的两阶段事务的 confirm 操作，在业务活动取消时调用所有两阶段事务的 cancel 操作。” 与 2PC 协议比较： 没有单独的 Prepare 阶段，降低协议成本 系统故障容忍度高，恢复简单 其中关键组件异步可靠消息策略如下： 其中一些关键设计点： 若在第 2、3、4 步出现故障，业务系统自行决定回滚还是另起补偿机制；若在第 6、7 步出现异常，消息中心需要回查生产者；若在第 8 步出现异常，消息中心需要重试。第 6 步的确认消息由消息中心组件封装，应用系统无需感知。 此套机制保障了消息数据的完整性，进而保障了与通过异步可靠消息通讯的系统数据最终一致性。 某些业务的前置检查，需要消息中心提供指定条件回查机制。 参考：分布式事务处理模型 - moonandstar08 - 博客园http://www.cnblogs.com/moonandstar08/p/5374154.html]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式服务化系统一致性（分布式事务、ACID、BASE、CAP）原理与解决方案]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-4%2F</url>
    <content type="text"><![CDATA[1 背景无论是水平拆分还是垂直拆分，都解决了特定场景下的特定问题，凡事有好的一面，都会有坏的一面，拆分后的系统或者服务化的系统最大的问题就是一致性问题，这么多个具有元功能的模块，或者同一个功能池中的多个节点之间，如何保证他们的信息是一致的、工作步伐是一致的、状态是一致的、互相协调有序的工作呢？ 本文根据作者在互联网企业的实际项目经验，对服务化系统中最难解决的一致性问题进行研究和探讨，试图从实践经验中找到规律，抽象出模式，分享给大家，希望对大家的项目实施有所帮助，在对实践的总结中也会对相关的一致性术语做最朴实的解释，希望能帮助大家彻底理解一致性的本质，并能将其应用到实践，解决读者现实中遇到的服务化系统的一致性问题，本文使用理论与实践相结合的方法，突出在实践中解决问题的模式，因此叫做《分布式服务化系统一致性的 “最佳实干”》。 2 问题本节列举不一致会导致的种种问题，这也包括一例生活中的问题。 案例 1：买房假如你想要享受生活的随意，只想买个两居，不想让房贷有太大压力，而你媳妇却想要买个三居，还得带花园的，那么你们就不一致了，不一致导致生活不愉快、不协调，严重情况下还会吵架，可见生活中的不一致问题影响很大。 案例 2：转账转账是经典的不一致案例，设想一下银行为你处理一笔转账，扣减你账户上的余额，然后增加别人账户的余额；如果扣减你的账户余额成功，增加别人账户余额失败，那么你就会损失这笔资金。反过来，如果扣减你的账户余额失败，增加别人账户余额成功，那么银行就会损失这笔资金，银行需要赔付。对于资金处理系统来说，上面任何一种场景都是不允许发生的，一旦发生就会有资金损失，后果是不堪设想的，严重情况会让一个公司瞬间倒闭，可参考案例。 案例 3：下订单和扣库存电商系统中也有一个经典的案例，下订单和扣库存如何保持一致，如果先下订单，扣库存失败，那么将会导致超卖；如果下订单没有成功，扣库存成功，那么会导致少卖。两种情况都会导致运营成本的增加，严重情况下需要赔付。 案例 4：同步超时服务化的系统间调用常常因为网络问题导致系统间调用超时，即使是网络很好的机房，在亿次流量的基数下，同步调用超时也是家常便饭。系统 A 同步调用系统 B 超时，系统 A 可以明确得到超时反馈，但是无法确定系统 B 是否已经完成了预定的功能或者没有完成预定的功能。于是，系统 A 就迷茫了，不知道应该继续做什么，如何反馈给使用方。（曾经的一个 B2B 产品的客户要求接口超时重新通知他们，这个在技术上是难以实现的，因为服务器本身可能并不知道自己超时，可能会继续正常的返回数据，只是客户端并没有接受到结果罢了，因此这不是一个合理的解决方案）。 案例 5：异步回调超时此案例和上一个同步超时案例类似，不过这个场景使用了异步回调，系统 A 同步调用系统 B 发起指令，系统 B 采用受理模式，受理后则返回受理成功，然后系统 B 异步通知系统 A。在这个过程中，如果系统 A 由于某种原因迟迟没有收到回调结果，那么两个系统间的状态就不一致，互相认知不同会导致系统间发生错误，严重情况下会影响核心事务，甚至会导致资金损失。 案例 6：掉单分布式系统中，两个系统协作处理一个流程，分别为对方的上下游，如果一个系统中存在一个请求，通常指订单，另外一个系统不存在，则导致掉单，掉单的后果很严重，有时候也会导致资金损失。 案例 7：系统间状态不一致这个案例与上面掉单案例类似，不同的是两个系统间都存在请求，但是请求的状态不一致。 案例 8：缓存和数据库不一致交易相关系统基本离不开关系型数据库，依赖关系型数据库提供的 ACID 特性（后面介绍），但是在大规模高并发的互联网系统里，一些特殊的场景对读的性能要求极高，服务于交易的数据库难以抗住大规模的读流量，通常需要在数据库前垫缓存，那么缓存和数据库之间的数据如何保持一致性？是要保持强一致呢还是弱一致性呢？ 案例 9：本地缓存节点间不一致一个服务池上的多个节点为了满足较高的性能需求，需要使用本地缓存，使用了本地缓存，每个节点都会有一份缓存数据的拷贝，如果这些数据是静态的、不变的，那永远都不会有问题，但是如果这些数据是半静态的或者常被更新的，当被更新的时候，各个节点更新是有先后顺序的，在更新的瞬间，各个节点的数据是不一致的，如果这些数据是为某一个开关服务的，想象一下重复的请求走进了不同的节点（在 failover 或者补偿导致的场景下，重复请求是一定会发生的，也是服务化系统必须处理的），一个请求走了开关打开的逻辑，同时另外一个请求走了开关关闭的逻辑，这导致请求被处理两次，最坏的情况下会导致灾难性的后果，就是资金损失。 案例 10：缓存数据结构不一致这个案例会时有发生，某系统需要种某一数据结构的缓存，这一数据结构有多个数据元素组成，其中，某个数据元素都需要从数据库中或者服务中获取，如果一部分数据元素获取失败，由于程序处理不正确，仍然将不完全的数据结构存入缓存，那么缓存的消费者消费的时候很有可能因为没有合理处理异常情况而出错。 3 模式3.1 生活中不一致问题的解决大家回顾一下上一节列举的生活中的案例 1 - 买房，如果置身事外来看，解决这种不一致的办法有两个，一个是避免不一致的发生，如果已经是媳妇了就不好办了:)，还有一种方法就是慢慢的补偿，先买个两居，然后慢慢的等资金充裕了再换三居，买比特币赚了再换带花园的房子，于是问题最终被解决了，最终大家处于一致的状态，都开心了。这样可以解决案例 1 的问题，很自然由于有了过渡的方法，问题在不经意间就消失了，可见 “过渡” 也是解决一致性问题的一个模式。 从案例 1 的解决方案来看，我们要解决一致性问题，一个最直接最简单的方法就是保持强一致性，对于案例 1 的情况，尽量避免在结婚前两个人能够互相了解达成一致，避免不一致问题的发生；不过有些事情事已至此，发生了就是发生了，出现了不一致的问题，我们应该考虑去补偿，尽最大的努力从不一致状态修复到一致状态，避免损失全部或者一部分，也不失为一个好方法。 因此，避免不一致是上策，出现了不一致及时发现及时修复是中策，有问题不积极解决留给他人解决是下策。 3.2 酸碱平衡理论ACID 在英文中的意思是 “酸”，BASE 的意思是“碱”，这一段讲的是“酸碱平衡” 的故事。 1. ACID（酸）如何保证强一致性呢？计算机专业的童鞋在学习关系型数据库的时候都学习了 ACID 原理，这里对 ACID 做个简单的介绍。如果想全面的学习 ACID 原理，请参考 ACID。 关系型数据库天生就是解决具有复杂事务场景的问题，关系型数据库完全满足 ACID 的特性。 ACID 指的是： A: Atomicity，原子性 C: Consistency，一致性 I: Isolation，隔离性 D: Durability，持久性 具有 ACID 的特性的数据库支持强一致性，强一致性代表数据库本身不会出现不一致，每个事务是原子的，或者成功或者失败，事物间是隔离的，互相完全不影响，而且最终状态是持久落盘的，因此，数据库会从一个明确的状态到另外一个明确的状态，中间的临时状态是不会出现的，如果出现也会及时的自动的修复，因此是强一致的。 3 个典型的关系型数据库 Oracle、Mysql、Db2 都能保证强一致性，Oracle 和 Mysql 使用多版本控制协议实现，而 DB2 使用改进的两阶段提交协议来实现。 如果你在为交易相关系统做技术选型，交易的存储应该只考虑关系型数据库，对于核心系统，如果需要较好的性能，可以考虑使用更强悍的硬件，这种向上扩展（升级硬件）虽然成本较高，但是是最简单粗暴有效的方式，另外，Nosql 完全不适合交易场景，Nosql 主要用来做数据分析、ETL（数据仓库技术）、报表、数据挖掘、推荐、日志处理等非交易场景。 前面提到的案例 2 - 转账和案例 3 - 下订单和扣库存都可以利用关系型数据库的强一致性解决。 然而，前面提到，互联网项目多数具有大规模高并发的特性，必须应用拆分的理念，对高并发的压力采取 “大而化小、小而化了” 的方法，否则难以满足动辄亿级流量的需求，即使使用关系型数据库，单机也难以满足存储和 TPS 上的需求。为了保证案例 2 - 转账可以利用关系型数据库的强一致性，在拆分的时候尽量的把转账相关的账户放入一个数据库分片，对于案例 3，尽量的保证把订单和库存放入同一个数据库分片，这样通过关系型数据库自然就解决了不一致的问题。 然而，有些时候事与愿违，由于业务规则的限制，无法将相关的数据分到同一个数据库分片，这个时候我们就需要实现最终一致性。 对于案例 2 - 转账场景，假设账户数量巨大，对账户存储进行了拆分，关系型数据库一共分了 8 个实例，每个实例 8 个库，每个库 8 个表，共 512 张表，假如要转账的两个账户正好落在了一个库里，那么可以依赖关系型数据库的事务保持强一致性。 如果要转账的两个账户正好落在了不同的库里，转账操作是无法封装在同一个数据库事务中的，这个时候会发生一个库的账户扣减余额成功，另外一个库的账户增加余额失败的情况。 对于这种情况，我们需要继续探讨解决之道，CAP 原理和 BASE 原理，BASE 原理通过记录事务的中间的临时状态，实现最终一致性。 2. CAP（帽子理论）如果想深入的学习 CAP 理论，请参考 CAP。 由于对系统或者数据进行了拆分，我们的系统不再是单机系统，而是分布式系统，针对分布式系的帽子理论包含三个元素： C：Consistency，一致性, 数据一致更新，所有数据变动都是同步的 A：Availability，可用性, 好的响应性能，完全的可用性指的是在任何故障模型下，服务都会在有限的时间处理响应 P：Partition tolerance，分区容错性，可靠性 帽子理论证明，任何分布式系统只可同时满足二点，没法三者兼顾。关系型数据库由于关系型数据库是单节点的，因此，不具有分区容错性，但是具有一致性和可用性，而分布式的服务化系统都需要满足分区容错性，那么我们必须在一致性和可用性中进行权衡，具体表现在服务化系统处理的异常请求在某一个时间段内可能是不完全的，但是经过自动的或者手工的补偿后，达到了最终的一致性。 3. BASE（碱）BASE 理论解决 CAP 理论提出了分布式系统的一致性和可用性不能兼得的问题，如果想全面的学习 BASE 原理，请参考 Eventual consistency。 BASE 在英文中有 “碱” 的意思，对应本节开头的 ACID 在英文中 “酸” 的意思，基于这两个名词提出了酸碱平衡的结论，简单来说是在不同的场景下，可以分别利用 ACID 和 BASE 来解决分布式服务化系统的一致性问题。 BASE 模型与 ACID 模型截然不同，满足 CAP 理论，通过牺牲强一致性，获得可用性，一般应用在服务化系统的应用层或者大数据处理系统，通过达到最终一致性来尽量满足业务的绝大部分需求。 BASE 模型包含个三个元素： BA：Basically Available，基本可用 S：Soft State，软状态，状态可以有一段时间不同步 E：Eventually Consistent，最终一致，最终数据是一致的就可以了，而不是时时保持强一致 BASE 模型的软状态是实现 BASE 理论的方法，基本可用和最终一致是目标。按照 BASE 模型实现的系统，由于不保证强一致性，系统在处理请求的过程中，可以存在短暂的不一致，在短暂的不一致窗口请求处理处在临时状态中，系统在做每步操作的时候，通过记录每一个临时状态，在系统出现故障的时候，可以从这些中间状态继续未完成的请求处理或者退回到原始状态，最后达到一致的状态。 以案例 1 - 转账为例，我们把用户 A 给用户 B 转账分成四个阶段，第一个阶段用户 A 准备转账，第二个阶段从用户 A 账户扣减余额，第三个阶段对用户 B 增加余额，第四个阶段完成转账。系统需要记录操作过程中每一步骤的状态，一旦系统出现故障，系统能够自动发现没有完成的任务，然后，根据任务所处的状态，继续执行任务，最终完成任务，达到一致的最终状态。 在实际应用中，上面这个过程通常是通过持久化执行任务的状态和环境信息，一旦出现问题，定时任务会捞取未执行完的任务，继续未执行完的任务，直到执行完成为止，或者取消已经完成的部分操作回到原始状态。这种方法在任务完成每个阶段的时候，都要更新数据库中任务的状态，这在大规模高并发系统中不会有太好的性能，一个更好的办法是用 Write-Ahead Log（写前日志），这和数据库的 Bin Log（操作日志）相似，在做每一个操作步骤，都先写入日志，如果操作遇到问题而停止的时候，可以读取日志按照步骤进行恢复，并且继续执行未完成的工作，最后达到一致。写前日志可以利用机械硬盘的追加写而达到较好性能，因此，这是一种专业化的实现方式，多数业务系系统还是使用数据库记录的字段来记录任务的执行状态，也就是记录中间的 “软状态”，一个任务的状态流转一般可以通过数据库的行级锁来实现，这比使用 Write-Ahead Log 实现更简单、更快速。 有了 BASE 理论作为基础，我们对复杂的分布式事务进行拆解，对其中的每一步骤都记录其状态，有问题的时候可以根据记录的状态来继续执行任务，达到最终的一致，通过这个方法我们可以解决案例 2 - 转账和案例 3 - 下订单和扣库存中遇到的问题。 4. 酸碱平衡的总结 使用向上扩展（强悍的硬件）运行专业的关系型数据库（例如：Oracle 或者 DB2）能够保证强一致性，钱能解决的问题就不是问题 如果钱是问题，可以对廉价硬件运行的开源关系型数据库（例如：Mysql）进行分片，将相关的数据分到数据库的同一个片，仍然能够使用关系型数据库保证事务 如果业务规则限制，无法将相关的数据分到同一个片，就需要实现最终一致性，通过记录事务的软状态（中间状态、临时状态），一旦处于不一致，可以通过系统自动化或者人工干预来修复不一致的情况 3.3 分布式一致性协议国际开放标准组织 Open Group 定义了 DTS（分布式事务处理模型），模型中包含 4 个角色：应用程序、事务管理器、资源管理器、通信资源管理器四部分。事务处理器是统管全局的管理者，资源处理器和通信资源处理器是事务的参与者。 J2EE 规范也包含此分布式事务处理模型的规范，并在所有的 AppServer 中进行实现，J2EE 规范中定义了 TX 协议和 XA 协议，TX 协议定义应用程序与事务管理器之间的接口，而 XA 协议定义了事务管理器与资源处理器之间的接口，在过去，大家使用 AppServer，例如：Websphere、Weblogic、Jboss 等配置数据源的时候会看见类似 XADatasource 的数据源，这就是实现了 DTS 的关系型数据库的数据源。企业级开发 JEE 中，关系型数据库、JMS 服务扮演资源管理器的角色，而 EJB 容器则扮演事务管理器的角色。 下面我们就介绍两阶段提交协议、三阶段提交协议以及阿里巴巴提出的 TCC，它们都是根据 DTS 这一思想演变出来的。 1. 两阶段提交协议上面描述的 JEE 的 XA 协议就是根据两阶段提交来保证事务的完整性，并实现分布式服务化的强一致性。 两阶段提交协议把分布式事务分成两个过程，一个是准备阶段，一个是提交阶段，准备阶段和提交阶段都是由事务管理器发起的，为了接下来讲解方便，我们把事务管理器称为协调者，把资管管理器称为参与者。 两阶段如下： 准备阶段：协调者向参与者发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，参与者会写 redo 或者 undo 日志（这也是前面提起的 Write-Ahead Log 的一种），然后锁定资源，执行操作，但是并不提交 提交阶段：如果每个参与者明确返回准备成功，也就是预留资源和执行操作成功，协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者明确返回准备失败，也就是预留资源或者执行操作失败，协调者向参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志，释放锁定的资源 两阶段提交协议成功场景示意图如下： 我们看到两阶段提交协议在准备阶段锁定资源，是一个重量级的操作，并能保证强一致性，但是实现起来复杂、成本较高，不够灵活，更重要的是它有如下致命的问题： 阻塞：从上面的描述来看，对于任何一次指令必须收到明确的响应，才会继续做下一步，否则处于阻塞状态，占用的资源被一直锁定，不会被释放 单点故障：如果协调者宕机，参与者没有了协调者指挥，会一直阻塞，尽管可以通过选举新的协调者替代原有协调者，但是如果之前协调者在发送一个提交指令后宕机，而提交指令仅仅被一个参与者接受，并且参与者接收后也宕机，新上任的协调者无法处理这种情况 脑裂：协调者发送提交指令，有的参与者接收到执行了事务，有的参与者没有接收到事务，就没有执行事务，多个参与者之间是不一致的 上面所有的这些问题，都是需要人工干预处理，没有自动化的解决方案，因此两阶段提交协议在正常情况下能保证系统的强一致性，但是在出现异常情况下，当前处理的操作处于错误状态，需要管理员人工干预解决，因此可用性不够好，这也符合 CAP 协议的一致性和可用性不能兼得的原理。 2. 三阶段提交协议三阶段提交协议是两阶段提交协议的改进版本。它通过超时机制解决了阻塞的问题，并且把两个阶段增加为三个阶段： 询问阶段：协调者询问参与者是否可以完成指令，协调者只需要回答是还是不是，而不需要做真正的操作，这个阶段超时导致中止 准备阶段：如果在询问阶段所有的参与者都返回可以执行操作，协调者向参与者发送预执行请求，然后参与者写 redo 和 undo 日志，执行操作，但是不提交操作；如果在询问阶段任何参与者返回不能执行操作的结果，则协调者向参与者发送中止请求，这里的逻辑与两阶段提交协议的的准备阶段是相似的，这个阶段超时导致成功 提交阶段：如果每个参与者在准备阶段返回准备成功，也就是预留资源和执行操作成功，协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者返回准备失败，也就是预留资源或者执行操作失败，协调者向参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志，释放锁定的资源，这里的逻辑与两阶段提交协议的提交阶段一致 三阶段提交协议成功场景示意图如下： 然而，这里与两阶段提交协议有两个主要的不同： 增加了一个询问阶段，询问阶段可以确保尽可能早的发现无法执行操作而需要中止的行为，但是它并不能发现所有的这种行为，只会减少这种情况的发生 在准备阶段以后，协调者和参与者执行的任务中都增加了超时，一旦超时，协调者和参与者都继续提交事务，默认为成功，这也是根据概率统计上超时后默认成功的正确性最大 三阶段提交协议与两阶段提交协议相比，具有如上的优点，但是一旦发生超时，系统仍然会发生不一致，只不过这种情况很少见罢了，好处就是至少不会阻塞和永远锁定资源。 3. TCC上面两节讲解了两阶段提交协议和三阶段提交协议，实际上他们能解决案例 2 - 转账和案例 3 - 下订单和扣库存中的分布式事务的问题，但是遇到极端情况，系统会发生阻塞或者不一致的问题，需要运营或者技术人工解决。无论两阶段还是三阶段方案中都包含多个参与者、多个阶段实现一个事务，实现复杂，性能也是一个很大的问题，因此，在互联网高并发系统中，鲜有使用两阶段提交和三阶段提交协议的场景。 阿里巴巴提出了新的 TCC 协议，TCC 协议将一个任务拆分成 Try、Confirm、Cancel，正常的流程会先执行 Try，如果执行没有问题，再执行 Confirm，如果执行过程中出了问题，则执行操作的逆操 Cancel，从正常的流程上讲，这仍然是一个两阶段的提交协议，但是，在执行出现问题的时候，有一定的自我修复能力，如果任何一个参与者出现了问题，协调者通过执行操作的逆操作来取消之前的操作，达到最终的一致状态。 可以看出，从时序上，如果遇到极端情况下 TCC 会有很多问题的，例如，如果在 Cancel 的时候一些参与者收到指令，而一些参与者没有收到指令，整个系统仍然是不一致的，这种复杂的情况，系统首先会通过补偿的方式，尝试自动修复的，如果系统无法修复，必须由人工参与解决。 从 TCC 的逻辑上看，可以说 TCC 是简化版的三阶段提交协议，解决了两阶段提交协议的阻塞问题，但是没有解决极端情况下会出现不一致和脑裂的问题。然而，TCC 通过自动化补偿手段，会把需要人工处理的不一致情况降到到最少，也是一种非常有用的解决方案，据说阿里在内部的一些中间件上实现了 TCC 模式。 我们给出一个使用 TCC 的实际案例，在秒杀的场景，用户发起下单请求，应用层先查询库存，确认商品库存还有余量，则锁定库存，此时订单状态为待支付，然后指引用户去支付，由于某种原因用户支付失败，或者支付超时，系统会自动将锁定的库存解锁供其他用户秒杀。 TCC 协议使用场景示意图如下： 总结一下，两阶段提交协议、三阶段提交协议、TCC 协议都能保证分布式事务的一致性，他们保证的分布式系统的一致性从强到弱，TCC 达到的目标是最终一致性，其中任何一种方法都可以不同程度的解决案例 2：转账、案例 3：下订单和扣库存的问题，只是实现的一致性的级别不一样而已，对于案例 4：同步超时可以通过 TCC 的理念解决，如果同步调用超时，调用方可以使用 fastfail 策略，返回调用方的使用方失败的结果，同时调用服务的逆向 cancel 操作，保证服务的最终一致性。 3.4 保证最终一致性的模式在大规模高并发服务化系统中，一个功能被拆分成多个具有单一功能的元功能，一个流程会有多个系统的多个元功能组合实现，如果使用两阶段提交协议和三阶段提交协议，确实能解决系统间一致性问题，除了这两个协议带来的自身的问题，这些协议的实现比较复杂、成本比较高，最重要的是性能并不好，相比来看，TCC 协议更简单、容易实现，但是 TCC 协议由于每个事务都需要执行 Try，再执行 Confirm，略微显得臃肿，因此，在现实的系统中，底线要求仅仅需要能达到最终一致性，而不需要实现专业的、复杂的一致性协议，实现最终一致性有一些非常有效的、简单粗暴的模式，下面就介绍这些模式及其应用场景。 1. 查询模式任何一个服务操作都需要提供一个查询接口，用来向外部输出操作执行的状态。服务操作的使用方可以通过查询接口，得知服务操作执行的状态，然后根据不同状态来做不同的处理操作。 为了能够实现查询，每个服务操作都需要有唯一的流水号标识，也可使用此次服务操作对应的资源 ID 来标志，例如：请求流水号、订单号等。 首先，单笔查询操作是必须提供的，我们也鼓励使用单笔订单查询，这是因为每次调用需要占用的负载是可控的，批量查询则根据需要来提供，如果使用了批量查询，需要有合理的分页机制，并且必须限制分页的大小，以及对批量查询的 QPS 需要有容量评估和流控等。 查询模式的示意图如下： 对于案例 4：同步超时、案例 5：异步回调超时、案例 6：掉单、案例 7：系统间状态不一致，我们都需要使用查询模式来了解被调用服务的处理情况，来决定下一步做什么：补偿未完成的操作还是回滚已经完成的操作。 2. 补偿模式有了上面的查询模式，在任何情况下，我们都能得知具体的操作所处的状态，如果整个操作处于不正常的状态，我们需要修正操作中有问题的子操作，这可能需要重新执行未完成的子操作，后者取消已经完成的子操作，通过修复使整个分布式系统达到一致，为了让系统最终一致而做的努力都叫做补偿。 对于服务化系统中同步调用的操作，业务操作发起的主动方在还没有得到业务操作执行方的明确返回或者调用超时，场景可参考案例 4：同步超时，这个时候业务发起的主动方需要及时的调用业务执行方获得操作执行的状态，这里使用查询模式，获得业务操作的执行方的状态后，如果业务执行方已经完预设的工作，则业务发起方给业务的使用方返回成功，如果业务操作的执行方的状态为失败或者未知，则会立即告诉业务的使用方失败，然后调用业务操作的逆向操作，保证操作不被执行或者回滚已经执行的操作，让业务的使用方、业务发起的主动方、业务的操作方最终达成一致的状态。 补偿模式的示意图如下： 补偿操作根据发起形式分为： 自动恢复：程序根据发生不一致的环境，通过继续未完成的操作，或者回滚已经完成的操作，自动来达到一致 通知运营：如果程序无法自动恢复，并且设计时考虑到了不一致的场景，可以提供运营功能，通过运营手工进行补偿 通知技术：如果很不巧，系统无法自动回复，又没有运营功能，那必须通过技术手段来解决，技术手段包括走数据库变更或者代码变更来解决，这是最糟的一种场景 3. 异步确保模式异步确保模式是补偿模式的一个典型案例，经常应用到使用方对响应时间要求并不太高，我们通常把这类操作从主流程中摘除，通过异步的方式进行处理，处理后把结果通过通知系统通知给使用方，这个方案最大的好处能够对高并发流量进行消峰，例如：电商系统中的物流、配送，以及支付系统中的计费、入账等。 实践中，将要执行的异步操作封装后持久入库，然后通过定时捞取未完成的任务进行补偿操作来实现异步确保模式，只要定时系统足够健壮，任何一个任务最终会被成功执行。 异步确保模式的示意图如下： 对于案例 5：异步回调超时，使用的就是异步确保模式，这种情况下对于某个操作，如果迟迟没有收到响应，我们通过查询模式和补偿模式来继续未完成的操作。 4. 定期校对模式既然我们在系统中实现最终一致性，系统在没有达到一致之前，系统间的状态是不一致的，甚至是混乱的，需要补偿操作来达到一致的目的，但是我们如何来发现需要补偿的操作呢？ 在操作的主流程中的系统间执行校对操作，我们可以事后异步的批量校对操作的状态，如果发现不一致的操作，则进行补偿，补偿操作与补偿模式中的补偿操作是一致的。 另外，实现定期校对的一个关键就是分布式系统中需要有一个自始至终唯一的 ID，ID 的生成请参考 SnowFlake。 在分布式系统中，全局唯一 ID 的示意图如下： 一般情况下，生成全局唯一 ID 有两种方法： 持久型：使用数据库表自增字段或者 Sequence 生成，为了提高效率，每个应用节点可以缓存一批次的 ID，如果机器重启可能会损失一部分 ID，但是这并不会产生任何问题 时间型：一般由机器号、业务号、时间、单节点内自增 ID 组成，由于时间一般精确到秒或者毫秒，因此不需要持久就能保证在分布式系统中全局唯一、粗略递增等特点 实践中，为了能在分布式系统中迅速的定位问题，一般的分布式系统都有技术支持系统，它能够跟踪一个请求的调用链，调用链是在二维的维度跟踪一个调用请求，最后形成一个调用树，原理可参考谷歌的论文 Dapper, a Large-Scale Distributed Systems Tracing Infrastructure，一个开源的参考实现为 pinpoint。 在分布式系统中，调用链的示意图如下： 全局的唯一流水 ID 可以把一个请求在分布式系统中的流转的路径聚合，而调用链中的 spanid 可以把聚合的请求路径通过树形结构进行展示，让技术支持人员轻松的发现系统出现的问题，能够快速定位出现问题的服务节点，提高应急效率。 关于订单跟踪、调用链跟踪、业务链跟踪，我们会在后续文章中详细介绍。 在分布式系统中构建了唯一 ID，调用链等基础设施，我们很容易对系统间的不一致进行核对，通常我们需要构建第三方的定期核对系统，以第三方的角度来监控服务执行的健康程度。 定期核对系统示意图如下： 对于案例 6：掉单、案例 7：系统间状态不一致通常通过定期校对模式发现问题，并通过补偿模式来修复，最后完成系统间的最终一致性。 定期校对模式多应用在金融系统，金融系统由于涉及到资金安全，需要保证百分之百的准确性，所以，需要多重的一致性保证机制，包括：系统间的一致性对账、现金对账、账务对账、手续费对账等等，这些都属于定期校对模式，顺便说一下，金融系统与社交应用在技术上本质的区别在于社交应用在于量大，而金融系统在于数据的准确性。 到现在为止，我们看到通过查询模式、补偿模式、定期核对模式可以解决案例 4 到案例 7 的所有问题，对于案例 4：同步超时，如果同步超时，我们需要查询状态进行补偿，对于案例 5：异步回调超时，如果迟迟没有收到回调响应，我们也会通过查询状态进行补偿，对于案例 6：掉单、案例 7：系统间状态不一致，我们通过定期核对模式可以保证系统间操作的一致性，避免掉单和状态不一致导致问题。 5. 可靠消息模式在分布式系统中，对于主流程中优先级比较低的操作，大多采用异步的方式执行，也就是前面提到的异步确保型，为了让异步操作的调用方和被调用方充分的解耦，也由于专业的消息队列本身具有可伸缩、可分片、可持久等功能，我们通常通过消息队列实现异步化，对于消息队列，我们需要建立特殊的设施保证可靠的消息发送以及处理机的幂等等。 消息的可靠发送 消息的可靠发送可以认为是尽最大努力发送消息通知，有两种实现方法： 第一种，发送消息之前，把消息持久到数据库，状态标记为待发送，然后发送消息，如果发送成功，将消息改为发送成功。定时任务定时从数据库捞取一定时间内未发送的消息，将消息发送。 第二种，实现方式与第一种类似，不同的是持久消息的数据库是独立的，并不耦合在业务系统中。发送消息之前，先发送一个预消息给某一个第三方的消息管理器，消息管理器将其持久到数据库，并标记状态为待发送，发送成功后，标记消息为发送成功。定时任务定时从数据库捞取一定时间内未发送的消息，回查业务系统是否要继续发送，根据查询结果来确定消息的状态。 一些公司把消息的可靠发送实现在了中间件里，通过 Spring 的注入，在消息发送的时候自动持久消息记录，如果有消息记录没有发送成功，定时会补偿发送。 消息处理器的幂等性 如果我们要保证消息可靠的发送，简单来说，要保证消息一定要发送出去，那么就需要有重试机制，有了重试机制，消息一定会重复，那么我们需要对重复做处理。 处理重复的最佳方式为保证操作的幂等性，幂等性的数学公式为： f(f(x)) = f(x) 保证操作的幂等性常用的几个方法： 使用数据库表的唯一键进行滤重，拒绝重复的请求 使用分布式表对请求进行滤重 使用状态流转的方向性来滤重，通常使用行级锁来实现 (后续在锁相关的文章中详细说明) 根据业务的特点，操作本身就是幂等的，例如：删除一个资源、增加一个资源、获得一个资源等 6. 缓存一致性模型大规模高并发系统中一个常见的核心需求就是亿级的读需求，显然，关系型数据库并不是解决高并发读需求的最佳方案，互联网的经典做法就是使用缓存抗读需求，下面有一些使用缓存的保证一致性的最佳实践： 如果性能要求不是非常的高，尽量使用分布式缓存，而不要使用本地缓存 缓存的时候一定种完全，如果缓存数据的一部分有效，一部分无效，宁可放弃种缓存，也不要把部分数据种入缓存 数据库与缓存只需要保持弱一致性，而不需要强一致性，读的顺序要先缓存，后数据库，写的顺序要先数据库，后缓存 这里的最佳实践能够解决案例 8：缓存和数据库不一致、案例 9：本地缓存节点间不一致、案例 10：缓存数据结构不一致的问题，对于数据存储层、缓存与数据库、Nosql 等的一致性是更深入的存储一致性技术，将会在后续文章单独介绍，这里的数据一致性主要是处理应用层与缓存、应用层与数据库、一部分的缓存与数据库的一致性。 3.5 专题模式这一节介绍特殊场景下的一致性问题和解决方案。 迁移开关的设计在大多数企业里，新项目和老项目一般会共存，大家都在努力的下掉老项目，但是由于种种原因总是下不掉，如果要彻底的下掉老项目，就必须要有非常完善的迁移方案，迁移是一项非常复杂而艰巨的任务，我会在将来的文章中详细探讨迁移方案、流程和技术，这里我们只对迁移中使用的开关进行描述。 迁移过程必须使用开关，开关一般都会基于多个维度来设计，例如：全局的、用户的、角色的、商户的、产品的等等，如果迁移过程中遇到问题，我们需要关闭开关，迁移回老的系统，这需要我们的新系统兼容老的数据，老的系统也兼容新的数据，从某种意义上来讲，迁移比实现新系统更加困难。 曾经看过很多简单的开关设计，有的开关设计在应用层次，通过一个 curl 语句调用，没有权限控制，这样的开关在服务池的每个节点都是不同步的、不一致的；还有的系统把开关配置放在中心化的配置系统、数据库或者缓存等，处理的每个请求都通过统一的开关来判断是否迁移等等，这样的开关有一个致命的缺点，服务请求在处理过程中，开关可能会变化，各个节点之间开关可能不同步、不一致，导致重复的请求可能走到新的逻辑又走了老的逻辑，如果新的逻辑和老的逻辑没有保证幂等性，这个请求就被重复处理了，如果是金融行业的应用，可能会导致资金损失，电商系统可能会导致发货并退款等问题。 这里面我们推荐使用订单开关，不管我们在什么维度上设计了开关，接收到服务请求后，我们在请求创建的关联实体（例如：订单）上标记开关，以后的任何处理流程，包括同步的和异步的处理流程，都通过订单上的开关来判断，而不是通过全局的或者基于配置的开关，这样在订单创建的时候，开关已经确定，不再变更，一旦一份数据不再发生变化(类似单例模式)，那么它永远是线程安全的，并且不会有不一致的问题。 这个模式在生产中使用比较频繁，建议每个企业都把这个模式作为设计评审的一项，如果不检查这一项，很多开发童鞋都会偷懒，直接在配置中或者数据库中做个开关就上线了。 4 总结本文从一致性问题的实践出发，从大规模高并发服务化系统的实践经验中进行总结，列举导致不一致的具体问题，围绕着具体问题，总结出解决不一致的方法，并且抽象成模式，供大家在开发服务化系统的过程中参考。 另外，由于篇幅有限，还有一些关于分布式一致性的技术无法在一篇文章中与大家分享，包括：paxos 算法、raft 算法、zab 算法、nwr 算法、一致性哈希等，我会在后续文章中详细介绍。 原文：分布式服务化系统一致性的“最佳实干” - 简书https://www.jianshu.com/p/1156151e20c8原作者个人信息李艳鹏]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>一致性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大工版小幸运]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-3%2F</url>
    <content type="text"><![CDATA[母校69周年，怀念逝去的青春 大工版小幸运 var ap = new APlayer({ element: document.getElementById("aplayer1"), narrow: false, autoplay: false, showlrc: 0, music: { title: "大工版小幸运", author: "填词：小白/演唱：于佳彤", url: "http://p4lmrb1gp.bkt.clouddn.com/%E5%A4%A7%E5%B7%A5%E7%89%88%E3%80%8A%E5%B0%8F%E5%B9%B8%E8%BF%90%E3%80%8B.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E5%A4%A7%E8%BF%9E%E7%90%86%E5%B7%A5%E6%A0%A1%E5%BE%BD.jpeg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 填词：小白 演唱：于佳彤 我听见风轻抚在福佳草地 我听见伯川闭馆歌声响起 可是我没有在意你的声音 直到 毕业季来临 记得清晨食堂温暖的热气 令希落地窗外城市的风景 夏夜驿路风华的浮光掠影 太多思念 无处逃离 也许是玉兰和银杏的倾听 或者是朝夕相伴的鼓励 给我披荆斩棘的勇气 走过长夜和黎明 成为更优秀的自己 原来你是我最想留住的幸运 原来我们和梦想曾经靠得那么近 那教我自立自强的决心 那认真的努力 庆幸我拥有你 给我无言的相信 与你相遇 好幸运 我就要写完莽莽撞撞青春的日记 但愿在不久之后的将来 你张开了双臂 而我回到这里 成为你的幸运 记得曾经为谁占座而早起 山礼的墙边晃过谁的身影 一馆哪个教室谁去得最勤 每个角落 关乎于你 也许当时愁着考试或实习 有时窝在寝室里打打游戏 无缘遇见好的爱情 遗憾这些年错过了独一无二的连理 原来你是我最想留住的幸运 原来我们的梦想曾经靠得那么近 那些年无话不说的真心 那眼角的笑意 庆幸我拥有你 给我无言的相信 与你相遇 好幸运 我就要写完莽莽撞撞青春的日记 拥有了不可代替的回忆 也许你已忘记 我曾经在这里 青春里爱过你]]></content>
      <tags>
        <tag>大连理工</tag>
        <tag>母校</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大工版《成都》_ 和我在西山一条街走一走]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-2%2F</url>
    <content type="text"><![CDATA[母校69周年，怀念逝去的青春 大工版《成都》 var ap = new APlayer({ element: document.getElementById("aplayer2"), narrow: false, autoplay: false, showlrc: 0, music: { title: "大工版《成都》", author: "填词：蛋花汤（大工微生活）曹建楠（凌分贝）/演唱：张雨农（凌分贝）", url: "http://p4lmrb1gp.bkt.clouddn.com/%E5%A4%A7%E5%B7%A5%E7%89%88%E3%80%8A%E6%88%90%E9%83%BD%E3%80%8B.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E5%A4%A7%E8%BF%9E%E7%90%86%E5%B7%A5%E6%A0%A1%E5%BE%BD.jpeg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 歌曲：成 都（大工版） 又名：和我在西山一条街走一走 填词：蛋花汤（大工微生活）曹建楠（凌分贝） 演唱：张雨农（凌分贝） 混音：黄逸歆（凌分贝） 编曲：赵 雷 / 喜 子 原唱：赵 雷 让我掉下眼泪的 不止毕业的酒让我恋恋不舍的 是玉兰的温柔情人路走也没尽头 有你牵我的手 银杏泛黄飘落的 是西山的深秋 相识总是在九月 伯川门前的路口青涩稚嫩的面孔 诗歌唱着乡愁在北山球场的角落里 我第一次邂逅你大工 我带走的 只有你 和我在西山一条街走一走 喔哦…直到寝室的灯都熄灭了也不停留一起熬夜背过思修 一起迷路在综合楼走到凌工路的尽头 仰望在令希门口 分别总是在九月 伯川门前的路口睿智成熟的面孔 含泪不忍回首在那彩虹桥上挥挥手 我不会忘记你大工 带不走的 还是你 和我在西山一条街走一走 喔哦…直到寝室的灯都熄灭了也不停留一起看过峰岚的 Show 一起爬到牛角山头走过四年每个春秋 醉在西便门儿门口 和我在西山一条街走一走 喔哦… 直到寝室的灯都熄灭了也不停留 和我在西山一条街走一走 喔哦… 直到寝室的灯都熄灭了也不停留 一起看过峰岚的 Show一起爬到牛角山头 走过四年每个春秋醉在西便门儿门口]]></content>
      <tags>
        <tag>大连理工</tag>
        <tag>母校</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《一次就好》大工版 _ 送给同在 DUT 的你]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-1%2F</url>
    <content type="text"><![CDATA[母校69周年，怀念逝去的青春 大工版《一次就好》 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 0, music: { title: "大工版《一次就好》", author: "填词：蛋花汤/演唱：张 策", url: "http://p4lmrb1gp.bkt.clouddn.com/%E5%A4%A7%E5%B7%A5%E7%89%88%E3%80%8A%E4%B8%80%E6%AC%A1%E5%B0%B1%E5%A5%BD%E3%80%8B.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E5%A4%A7%E8%BF%9E%E7%90%86%E5%B7%A5%E6%A0%A1%E5%BE%BD.jpeg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 填词：蛋花汤 演唱：张 策 一次就好——大工版 秋风萧萧 冬雪飘飘 夏的海上明月照 上一秒 路灯下 诗朗稿 下一秒 主楼前 毕业照 几点早操 哪天排票 嘉年华上谁的欢笑 球场上谁投篮谁尖叫 谁坐在哪位置期末考 一次就好 我还想去看水杉影摇 在令希的清晨看过的雾清云薄 在海风飒飒的日子看银杏渐黄 你可知道那句别离难道 世界还小 你让我看到青春尚好。 山礼峰岚舞台上她的白衣飘飘 伯川夕阳里他埋首侧脸的光芒 你可知道我挥手起航时 湿了眼眶 报爷的报 水哥的笑 十点四十的声悄悄 上一秒，相遇，请多关照 下一秒，转身，紧紧拥抱 牛角山高 情人路长 DUT 我的骄傲 一路梦想因为你闪耀 一颗心早已为你燃烧 一次就好 我还想再看玉兰香飘 一路上的脚印丈量曾经的年少 深深浅浅的回忆里都是你的好 感谢你鼓励我走过泥沼 世界还小 我将要成为那只飞鸟 用你给的勇气穿越低谷和风暴 在阳光灿烂的日子里怀念浅笑 走过四年似水的流光 青春，不老 图片来自大工新闻网]]></content>
      <tags>
        <tag>大连理工</tag>
        <tag>母校</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大连理工的日子》_ 我爱大工，从未离开]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21%2F</url>
    <content type="text"><![CDATA[母校69周年，怀念逝去的青春 《大连理工的日子》 var ap = new APlayer({ element: document.getElementById("aplayer3"), narrow: false, autoplay: false, showlrc: 0, music: { title: "大连理工的日子", author: "填词：蛋花汤（大工微生活）/演唱：于佳彤 赵方琪（凌分贝原创音乐工作室）", url: "http://p4lmrb1gp.bkt.clouddn.com/%E5%A4%A7%E8%BF%9E%E7%90%86%E5%B7%A5%E7%9A%84%E6%97%A5%E5%AD%90.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E5%A4%A7%E8%BF%9E%E7%90%86%E5%B7%A5%E6%A0%A1%E5%BE%BD.jpeg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 填词：蛋花汤（大工微生活） 演唱：于佳彤 赵方琪（凌分贝原创音乐工作室） 编曲：汪 源 孙 磊 开始的开始 我们都是孩子 最后的最后 渴望变成天使 歌谣的歌谣 藏着童话的影子 孩子的孩子 该要飞往哪儿去 当某天 你若听见 有人抱怨清晨早操的疲倦 当某天 你若看见 毕业的照片连理的亲切 当某天 再想起 牵起过谁的手说过的永远 当某天 再踏进 凌工路二号谁的曾经 这里的青春四年 表示林荫路绿色的剪影 那年青涩倔强 一馆西综材料馆记得你 奋斗的模样 峰舞于岚镁光灯下是谁 如花的脸庞 倾刻心动是你看黑板眼里 闪烁着的光芒 这里多少名字多少笑脸 变成我故事里的面孔 多少日升 多少日落 多少岁月青葱 海浪替我歌唱那年 夏天的青春懵懂 曾经欢笑荡漾成 此刻的 泪眼朦胧 十年后 你若听见 有人抱怨清晨早操的疲倦 十年后 你若听见 有人在定格连理的笑脸 直到十二月的大雪飞扬成 六月的星空 九月路灯下是否依旧是 诗朗声重重 谁不醉不休谁说不出的 那一句珍重 我们挥手再次启程终点是 南北西东 时光清浅倒映 我们曾经 稚嫩彷徨的面孔 岁月绵长谱写出 一首我爱你我的大工 满满的行李箱装着 少年拿云梦 这个叫凌工路二号的故事 说好的 我们永远不剧终]]></content>
      <tags>
        <tag>大连理工</tag>
        <tag>母校</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【大型网站技术实践】初级篇]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-11%2F</url>
    <content type="text"><![CDATA[【大型网站技术实践】初级篇：借助 Nginx 搭建反向代理服务器【大型网站技术实践】初级篇：搭建 MySQL 主从复制经典架构【大型网站技术实践】初级篇：海量图片的分布式存储设计与实现【大型网站技术实践】初级篇：借助 LVS+Keepalived 实现负载均衡 在此推荐一个网站，各种精华的博客整理得很不错：网站开发教程大全 - 在线手册 - 参考手册 - 手册网http://www.shouce.ren/ 例如：Docker学习总结（50篇+） - 后端区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15484 Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》笔记8 固若金汤：网站的安全架构]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-10%2F</url>
    <content type="text"><![CDATA[8 固若金汤：网站的安全架构 一、网站应用攻击与防御 二、信息加密技术与密钥安全 三、信息过滤与反垃圾 四、电子商务风险控制 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》笔记7 随机应变：网站的可扩展架构]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-9%2F</url>
    <content type="text"><![CDATA[7 随机应变：网站的可扩展架构 一、可伸缩与可扩展—傻傻分不清楚 上篇笔记我们学习了可伸缩架构，但在实际场合中，包括许多架构师也常常混淆可伸缩和可扩展，用可扩展表示伸缩性。那么在此，跟随作者我们来理清这两个概念，避免我们以后对其傻傻分不清楚。 （1）扩展性（Extensibiltiy） 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。我们不禁想到了面向对象中一大原则：开闭原则，对扩展开放，对修改封闭。也就说，当系统新增一个功能时，不需要对现有系统的结构和代码进行修改。 （2）伸缩性（Scalability） 指系统能够通过增加（或减少）自身资源规模的方式增强（或减少）自己计算事务的能力。在网站架构中，通常是指利用集群的方式增加服务器数量，从而提高系统的整体事务吞吐能力。 设计网站可扩展架构的核心思想是：模块化，并在此基础之上降低模块间的耦合，提高模块的复用性。在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器（集群）上，从物理上分离模块之间的耦合关系，进一步降低耦合性从而提高复用性。 二、利用分布式消息队列降低系统耦合性 上面我们提到说要分离模块之间的耦合，如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块的影响最小，这样系统的可扩展性无疑会更好一些。那么，有没有一种架构是基于如此考虑而设计的呢？于是，我们将眼光转向一个名叫 “事件驱动” 的架构。 2.1 事件驱动架构 根据事件驱动架构（Event Driven Architecture）的定义：通过在低耦合的模块之间传输消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作。典型的 EDA 架构就是操作系统中常见的生产者消费者模式。在大型网站架构中，具体实现手段有很多，但是最常见的是分布式消息队列。 如上图所示，消息队列利用发布—订阅模式工作，消息发送者发布消息，一个或多个消息接受者订阅消息。消息发送者是消息源，在对消息进行处理后发送至分布式消息队列，消息接收者从分布式消息队列获取该消息后继续进行处理。可以明显看出，发送者与接受者之间没有直接耦合，消息发送者只需将消息发送给分布式消息队列即操作结束，而消息接受者也只需要从分布式消息队列获取消息后进行处理，不需要知道该消息从何而来。因此，对于新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展设计。 2.2 分布式消息队列 队列是一种先进先出的数据结构，分布式消息队列则可以看作是将这种数据结构部署到独立服务器上，应用程序可以通过远程访问接口使用分布式消息队列，进行消息存取操作，进而实现分布式的异步调用。 如上图所示，我们可以明确三个步骤： ①消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后马上返回成功响应给消息生产者。 ②消息队列服务器根据消息订阅列表查找订阅该消息的消费者应用程序，将消息队列中的消息按照先进先出的原则将消息通过远程通信接口发送给消费者应用程序； ③消费者应用程序接收到推送过来的消息之后进行相关的一系列处理，过程终止； PS：那么，有没有这样一种情况：消息队列服务器宕机后导致消息丢失。事实上，这种情况的确存在于实际的运维过程中。那么，我们如何来避免呢？有关于分布式消息队列的实践可以采用 NoSQL 产品来构建，例如 Redis 就提供了队列数据类型，可以方便地构建分布式消息队列，如果你有兴趣，也可以参阅另一篇博文：《使用 Redis 作为消息队列服务应用场景案例》 三、利用分布式服务打造可复用的业务平台 如果说分布式消息队列通过消息对象分解系统耦合性，不同子系统处理同一个消息；那么分布式服务则通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。 3.1 巨无霸的应用系统带来的问题 网站由小到大的演化过程中，表现为整个网站是由单一系统逐步膨胀发展变化而来的，随着网站功能的日益复杂，网站应用系统会逐渐成为一个巨无霸，如下图所示。可以看出，一个应用中聚合了大量的应用和服务组件，这个巨无霸给整个网站的开发（编译麻烦、代码分支管理困难）、维护（新增业务困难）和部署（部署困难）都带来了巨大的麻烦。 3.2 拆分，拆分还是拆分 解决方案还是我们多次提到的拆分，将模块独立部署，降低系统耦合性。拆分又分为：横向拆分和纵向拆分。这里我们再次回顾一下这两种方式： （1）纵向拆分：将一个大应用拆分为多个小应用，如果新增的业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统； （2）横向拆分：将可以复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务即可，不需要依赖于具体的模块代码。如果模块内业务逻辑发生变化时，只要接口保持一致就不会影响业务程序和其他模块。 四、可扩展的数据结构 传统的关系数据库为了保证关系运算（通过 SQL 语句）的正确性，在设计表结构的时候就需要制定表的 Schema—字段名称、数据类型等，还要遵循制定的设计范式（例如：1NF、2NF、3NF 等等）。这些规范带来的一个问题就是僵硬的数据结构难以面对需求变更带来的挑战，有些系统设计者通过预先设计一些冗余字段来应付，但这显然是一种糟糕的数据库设计。 那么，有木有办法能够做到可扩展的数据结构设计呢？是否可以不需要修改表结构就可以新增字段呢？答案是肯定的，目前许多 NoSQL 数据库使用的 ColumnFamily（列族）设计就是一个解决方案。ColumnFamily 最早在 Google 的 BigTable 中使用，这是一种面向列族的稀疏矩阵存储格式。或许这么说大家还是不明白，但可以通过下图来理解： 这是一个学生基本信息表，不同学生的联系方式不同，选修的课程也不同，而且在将来会有更多的联系方式和课程加入这张表，如果按照传统的数据库设计，无论提前预设多少冗余字段都不够用，捉襟见肘，疲于应付。而是用 ColumnFamily 结构的 NoSQL 数据库，创建表的时候，只需要指定 ColumnFamily 的名字，无需指定字段（Column），可以在数据写入时再指定，通过这种方式，数据表可以包含数百万的字段，使应用程序的数据结构可以随意扩展。 五、利用开放平台建设网站生态圈 网站的价值在于为他的用户创造价值，大型网站为了更好地服务自己的用户，会开发更多的增值服务，会把网站内部的服务封装一些调用接口开放出去，供外部的第三方开发者使用，这个提供开放接口的平台被称作开放平台。第三方开发者利用这些开放的接口开发应用程序（APP）或者网站，为更多的用户提供价值。这样一来，网站、用户、第三方开发者相互依赖，形成一个网站的生态圈，即为用户提供更多的价值，也提高了网站和第三方开发者的竞争能力和盈利能力。 目前 BAT 等国内互联网巨头都建设有自己的开放平台，力图利用自己庞大的用户群吸引第三方开发者，打造一个更加庞大的航母战斗群，在市场竞争中呼风唤雨，立于不败之地。 六、学习小结 网站不停上新产品是其生存的本能，谁能更快更好地推出更多的新产品，谁就活得更滋润。马克思的劳动价值理论在 IT 业得到了印证：产品的内在价值在于劳动的时间，而劳动的时间不在于个体付出的劳动时间，而在于行业一般劳动时间，资本家只会为行业一般劳动时间买单，如果你的效率低于行业一般时间，对不起，请你加班。 本章思维导图 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》笔记5 万无一失：网站的高可用架构]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-7%2F</url>
    <content type="text"><![CDATA[5 万无一失：网站的高可用架构 一、可用性度量与考核 首先，不得不说：要保证一个网站永远完全可用几乎是一件不可能完成的任务。 （1）如何度量网站可用性？ 一个神奇的数字—9！你有几个 9，就代表了你的可用性。例如 1565730756@QQ.COM 可用性达到了 4 个 9：99.99% ①2 个 9 = 基本可用 ②3 个 9 = 较高可用 ③4 个 9 = 具有自动恢复能力的高可用 ④5 个 9 = 极高可用 -&gt; 理想状态 那么，可用性的 9 又是怎么计算出来的呢： ①网站不可用时间 = 故障修复时间点 - 故障发现时间点 ②网站年度可用性指标 =（1 - 网站不可用时间 / 年度总时间）*100% （2）如何考核网站可用性？ 广泛采用故障分的，它是对网站故障进行分类加权计算故障责任的方法。一般会给每个分类的故障设置一个权重（例如事故级故障权重为 100，A 类为 20 等），其计算公式为：故障分 = 故障时间（分钟）* 故障权重。公司对技术团队的考核一般会参考故障分，例如某团队今年发生了几个事故级故障，那么其绩效考核估计受到很大影响，年终奖什么的就悲剧了。 二、高可用的架构 目前，通常企业级应用系统（特别是政府部门和大企业的应用系统）一般会采用安规的软硬件设备，如 IOE（IBM 的小型机、Oracle 数据、EMC 存储设备）系列。而一般互联网公司更多地采用 PC 级服务器（x86），开源的数据库（MySQL）和操作系统（Linux）组建廉价且高容错（硬件故障是常态）的应用集群。 （1）设计的目的？ 保证服务器硬件故障服务依然可用，数据依然保存并能够被访问。 （2）主要的手段？ 数据和服务的①冗余备份以及②失效转移： 对于服务而言，一旦某个服务器宕机，就将服务切换到其他可用的服务器上； 对于数据而言，如果某个磁盘损坏，就从备份的磁盘（事先就做好了数据的同步复制）读取数据。 三、高可用的应用 应用层处理网站应用的业务逻辑，应用的一个最显著的特点是：应用的无状态性。 （1）通过负载均衡进行无状态服务的失效转移 （2）应用服务器集群的 Session 管理 首先，不得不说的是：Web 应用中将上下文对象称为会话（Session），单机情况下由部署在服务器上得 Web 容器（如 IIS、Tomcat、JBoss 等）管理。在使用了负载均衡的集群环境中，由于请求的分发是随机的，所以保证每次请求依然能够获得正确的 Session 比单机时要复杂得多。 其次，我们来看看在集群环境中，Session 管理的几种常见手段。 ①Session 复制：该方案简单易行，集群中的几台服务器之间同步 Session 对象，任何一台服务器宕机都不会导致 Session 对象的丢失，服务器也只需要从本机获取即可。但是，该方案只适合集群规模较小的情况下。当规模较大时，大量的 Session 复制操作会占用服务器和网络的大量资源，系统不堪重负。 ②Session 绑定：利用负载均衡的源地址 Hash 算法，总是将源于同一 IP 地址的请求分发到同一台服务器上。这样的话，在整个会话期间，用户所有的请求都在同一台服务器上进行处理，即 Session 绑定在某台特定服务器上，保证 Session 总能在这台服务器上获取。（这种方案又叫做会话粘滞）。 但是，这种方案不符合高可用的需求。因为一旦某台服务器宕机，那么该机器上得 Session 也就不复存在了，用户请求切换到其他机器后因为没有 Session 而无法完成业务处理。因此，很少有网站采用此方案进行 Session 管理。 ③Cookie 记录 Session：利用浏览器支持的 Cookie 记录 Session 简单易行，可用性高，并且支持服务器的线性伸缩，因此，许多网站都或多或少地使用了 Cookie 来记录 Session。但是 Cookie 记录 Session 有缺点：比如受 Cookie 大小限制、每次请求响应都要传输 Cookie 影响性能、用户关闭了 Cookie 会造成访问不正常等。 ④Session 服务器：利用独立部署的 Session 服务器（集群）统一管理 Session，应用服务器每次读写 Session 时，都访问 Session 服务器。这种方案实际上是将应用服务器的状态分离，分为无状态的应用服务器和有状态的 Session 服务器。 对于，有状态的 Session 服务器，一种较简单的方法是利用分布式缓存（如 Memcached、Redis 等，有关 Redis 的简单介绍可以阅读我的博文：NoSQL 初探之人人都爱 Redis）、数据库等，在这些产品的基础上进行封装，使其符合 Session 的存储和访问要求。 四、高可用的服务 高可用的服务模块为业务产品提供基础公共服务，在大型站点中这些服务通常都独立分布式部署，被具体应用远程调用。 在具体实践中，有以下几点高可用的服务策略可以参考： ①分级管理：核心应用和服务具有更高的优先级，比如用户及时付款比能否评价商品更重要； ②超时设置：设置服务调用的超时时间，一旦超时后，通信框架抛出异常，应用程序则根据服务调度策略选择重试 or 请求转移到其他服务器上； ③异步调用：通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。 PS：不是所有服务都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失。对于那些必须确认服务调用成功后才能继续进行下一步的操作的应用也不适合异步调用。有关具体使用消息队列实现异步调用的案例，请阅读我的博文：《使用 Redis 作为消息队列服务场景的应用案例》。 ④服务降级：网站访问高峰期间，为了保证核心应用的正常运行，需要对服务降级。 降级有两种手段：一是拒绝服务，拒绝较低优先级的应用的调用，减少服务调用并发数，确保核心应用的正常运行；二是关闭功能，关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约系统开销，为核心应用服务让出资源； ⑤幂等性设计：保证服务重复调用和调用一次产生的结果相同； 五、高可用的数据 对于大多数网站而言，数据是其最宝贵的物质资产。 保证数据高可用的主要手段有两种：一是数据备份，二是失效转移机制； ①数据备份：又分为冷备份和热备份，冷备份是定期复制，不能保证数据可用性。热备份又分为异步热备和同步热备，异步热备是指多份数据副本的写入操作异步完成，而同步方式则是指多份数据副本的写入操作同时完成。 关系数据库的热备机制就是通常所说的主从同步机制，实践中通常使用读写分离的方法来访问 Master 和 Slave 数据库，也就是说写操作只访问 Master 库，读操作均访问 Slave 库。 PS：在 MS SQL Server 中，可以通过发布订阅功能实现主从分离。关于发布订阅，可以参考 MSDN 的这篇文章：http://technet.microsoft.com/zh-cn/ff806143.aspx ②失效转移：若数据服务器集群中任何一台服务器宕机，那么应用程序针对这台服务器的所有读写操作都要重新路由到其他服务器，保证数据访问不会失败。 六、高可用的 QA ①网站发布：在柔性的发布过程中，每次关闭的服务都是集群中的一小部分，并在发布完成后立即可以访问； ②自动化测试：使用自动测试工具或脚本完成测试； ③预发布验证：引入预发布服务器，与正式服务器几乎一致，只是没有配置在负载均衡服务器上，外部用户无法访问； ④代码控制：目前大多数网站采用 SVN，分支开发，主干发布模式；另外，目前开源社区广泛采用 Git 作为版本控制工具，正逐步取代 SVN 的地位； 七、网站运行监控 ” 不允许没有监控的系统上线 “ （1）监控数据采集 ①用户行为日志收集：服务器端的日志收集和客户端的日志收集；目前许多网站逐步开发基于实时计算框架 Storm 的日志统计与分析工具； ②服务器性能监控：收集服务器性能指标，如系统 Load、内存占用、磁盘 IO 等，及时判断，防患于未然； ③运行数据报告：采集并报告，汇总后统一显示，应用程序需要在代码中处理运行数据采集的逻辑； （2）监控管理 ①系统报警：配置报警阀值和值守人员联系方式，系统发生报警时，即使工程师在千里之外，也可以被及时通知； ②失效转移：监控系统在发现故障时，主动通知应用进行失效转移； ③自动优雅降级：为了应付网站访问高峰，主动关闭部分功能，释放部分系统资源，保证核心应用服务的正常运行；—&gt; 网站柔性架构的理想状态 参考文献 （1）李智慧，《大型网站技术架构 - 核心原理与案例分析》，http://item.jd.com/11322972.html 本章思维导图 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》笔记6 永无止境：网站的伸缩性架构]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-8%2F</url>
    <content type="text"><![CDATA[6 永无止境：网站的伸缩性架构 一、网站架构的伸缩性设计1.1 不同功能进行物理分离实现伸缩 （1）纵向分离：将业务处理流程上得不同部分分离部署，实现系统的伸缩性； （2）横向分离：将不同的业务模块分离部署，实现系统的伸缩性； 1.2 单一功通过集群规模实现伸缩 使用服务器集群，即将相同服务部署在多台服务器上构成一个集群整体对外提供服务。具体来说，集群伸缩性又分为应用服务器集群伸缩性和数据服务器集群伸缩性。这两种集群对于数据状态管理的不同，技术实现也有很大的区别。 It is said that 当一头牛拉不动车的时候，不要去寻找一头更强壮的牛，而是用两头牛来拉车。 二、应用服务器集群的伸缩性设计2.1 应用服务器那点必须知道的事儿 （1）应用服务器应该被设计成无状态的，即应用服务器不存储请求上下文信息；构建集群后，每次用户的请求都可以发到集群中任意一台服务器上处理，任何一台服务器的处理结果都是相同的； （2）HTTP 本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是 Cookie 和 Session 了。 （3）HTTP 请求的分发是应用服务器集群实现伸缩性的核心问题，而负载均衡服务器就是 HTTP 请求的分发装置，它是网站必不可少的基础手段，也被称为网站的杀手锏之一。 2.2 负载均衡技术—网站必不可少的基础技术手段 负载均衡的实现方式多种多样，从硬件到软件，从商业产品到开源产品，应有尽有。但是，实现负载均衡的基础技术不外乎以下几种： （1）HTTP 重定向负载均衡 评价：★★ 此方案的优点是简单易行，缺点是： ①浏览器需要两次请求才能完成一次访问，性能较差； ②重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限； ③使用 HTTP 302 重定向有可能使搜索引擎判断为 SEO 作弊，降低搜索排名； （2）DNS 域名解析负载均衡 评价：★★★ 此方案要求在 DNS 服务器中配置多个 A 记录，例如： | www.mysite.com IN A | 114.100.80.1 || www.mysite.com IN A | 114.100.80.2 || www.mysite.com IN A | 114.100.80.3 | 此方案的优点是将负载均衡的工作转交给了 DNS，省掉了网站管理维护负载均衡服务器的麻烦。而缺点是： ①目前的 DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效仍然需要较长时间。这段期间，会导致用户访问已经下线的服务器造成访问失败。 ②DNS 负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和管理； TIPS：事实上，大型网站总是部分使用 DNS 域名解析，利用域名解析作为第一级负载均衡手段，即域名解析得到的一组服务器不是实际的 Web 服务器，而是同样提供负载均衡的内部服务器，这组内部服务器再进行负载均衡，请求分发到真实的 Web 服务器上。 （3）反向代理负载均衡 评价：★★★★ Web 服务器不需要使用外部 IP 地址，而反向代理服务器则需要配置双网卡和内外部两套 IP 地址。 此方案的优点是和反向代理服务器功能集成在一起，部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。 （4）IP 负载均衡 评价：★★★★ 此方案优点在于在内核进程完成数据分发，较反向代理负载均衡（在应用程序中分发数据）有更好的处理性能。缺点是由于所有请求响应都需要经过负载均衡服务器，集群的最大响应数据吞吐量不得不受制于负载均衡服务器网卡带宽。 （5）数据链路层负载均衡 评价：★★★★★ 此种方式又称作三角传输模式，负载均衡数据分发过程中不修改 IP 地址，只修改 mac 地址，由于实际处理请求的真实物理 IP 地址和数据请求目的 IP 地址一致，所以不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载均衡方式又称作直接路由方式（DR）。 使用三角传输模式的链路层负载均衡是目前大型网站使用最广泛的一种负载均衡手段。在 Linux 平台上最好的链路层负载均衡开源产品是 LVS（Linux Virutal Server）。 2.3 负载均衡算法—负载均衡技术赖以生存的核心 前面的方法解决了负载均衡通过何种方式实现，而更为重要的则是如何从 Web 服务器列表中计算得到一台 Web 服务器的地址，而这正是负载均衡的核心—算法。这里简单介绍一下通常的集中负载均衡计算的算法，如果需要深入了解请自行百度。 （1）轮询 所有请求被以此分发到每台应用服务器上，即每台服务器需要处理的请求数目都相同，适合于所有服务器硬件都相同的场景。 （2）加权轮询 根据应用服务器的配置性能的情况，在轮询的基础上，按照配置的权重将请求分发到每个服务器，高性能的服务器能分配更多的请求。 （3）随机 此算法比较简单实用，请求被随机分配到各个应用服务器，因为好的随机数本身就很均衡。 （4）最少连接 记录每个应用服务器正在处理的连接数（请求数），将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。 （5）源地址散列 根据请求来源的 IP 地址进行 Hash 计算得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。 三、分布式缓存集群的伸缩性设计 不同于应用服务器集群的伸缩性设计，分布式缓存集群的伸缩性不能使用简单的负载均衡手段来实现。因为：分布式缓存服务器集群中缓存的数据各不相同，缓存访问请求不可以在缓存服务器集群中的任意一台处理，必须先找到缓存有需要的数据的服务器，然后才能访问。 分布式缓存集群伸缩性设计的目标：让新上线的缓存服务器对整个分布式缓存集群影响最小，也就是说新加入缓存服务器后应使整个缓存服务器集群中已经缓存的数据尽可能还被访问到。 （1）以 Memcached 为代表的分布式缓存集群的访问模型 以上图片展示了一个典型的缓存写操作，应用程序需要写缓存数据 &lt;’CHENGDU’,DATA&gt;，API 将 KEY（’CHENGDU’）输入路由算法模块，路由算法根据 KEY 和 Memcached 服务器集群列表计算得到一台服务器编号（如 Node1），进而得到该机器的 IP 地址和端口（10.0.0.1:91000）。然后，API 调用通信模块和编号为 Node1 的 Memcached 服务器进行通信，将数据 &lt;’CHENGDU’,DATA &gt; 写入该服务器，至此便完成了一次分布式缓存的写操作。 而读操作和写操作一样，使用同样的路由算法和服务器列表，只要提供相同的 KEY（如上面提到的’CHENGDU’），Memcached 客户端总是访问相同的服务器（如上面计算得到的 Node1）去读取数据。 （2）以 Memcached 为代表的分布式缓存集群的伸缩性挑战 简单的路由算法（通过使用余数 Hash）无法满足业务发展时服务器扩容的需要：缓存命中率下降。例如：当 3 台服务器扩容至 4 台时，采用普通的余数 Hash 算法会导致大约 75%（3/4）被缓存了的数据无法正确命中，随着服务器集群规模的增大，这个比例会线性地上升。那么，可以想象，当 100 台服务器的急群众加入一台服务器，不能命中的概率大概是 99%（N/N+1），这个结果显然是无法接受的。 那么，能否通过改进路由算法，使得新加入的服务器不影响大部分缓存数据的正确性呢？请看下面的一致性 Hash 算法。 （3）分布式缓存的一致性 Hash 算法 说明：一致性 Hash 算法是分布式缓存的核心理论，这里只是简单介绍一下 一致性 Hash 算法通过一个叫做一致性 Hash 还的数据结构实现 KEY 到缓存服务器的 Hash 映射，如下图所示： 具体算法过程是： ①先构造一个长度为 0~2^32（2 的 32 次幂）个的整数环（又称：一致性 Hash 环），根据节点名称的 Hash 值将缓存服务器节点防置在这个 Hash 环中，如上图中的 node1，node2 等； ②根据需要缓存的数据的 KEY 值计算得到其 Hash 值，如上图中右半部分的 “键”，计算其 Hash 值后离 node2 很近； ③在 Hash 环上顺时针查找距离这个 KEY 的 Hash 值最近的缓存服务器节点，完成 KEY 到服务器的 Hash 映射查找，如上图中离右边这个键的 Hash 值最近的顺时针方向的服务器节点是 node2，因此这个 KEY 会到 node2 中读取数据； 当缓存服务器集群需要扩容的时候，只需要将新加入的节点名称（如 node5）的 Hash 值放入一致性 Hash 环中，由于 KEY 总是顺时针查找距离其最近的节点，因此新加入的节点只影响整个环中的一部分。如下图中所示，添加 node5 后，只影响右边逆时针方向的三个 Key/Value 对数据，只占整个 Hash 环中的一小部分。 因此，我们可以与之前的普通余数 Hash 作对比：采用一直性 Hash 算法时，当 3 台服务器扩容到 4 台时，可以继续命中原有缓存数据的概率为 75%，远高于普通余数 Hash 的 25%，而且随着集群规模越大，继续命中原有缓存数据的概率也会随之增大。当 100 台服务器增加 1 台时，继续命中的概率是 99%。虽然，仍有小部分数据缓存在服务器中无法被读取到，但是这个比例足够小，通过访问数据库也不会对数据库造成致命的负载压力。 四、数据存储服务器集群的伸缩性设计 首先，数据存储服务器必须保证数据的可靠存储，任何情况下都必须保证数据的可用性和正确性。因此，缓存服务器集群的伸缩性架构方案不能直接适用于数据库等存储服务器。 （1）关系数据库集群的伸缩性设计 ①市场上主要的关系数据库都支持数据复制功能，使用这个功能可以对数据库进行简单伸缩。下图显示了使用数据复制的 MySQL 集群伸缩性方案：多台 MySQL 的角色有主从之分，写操作都在主服务器上，由主服务器将数据同步到集群中其他从服务器。而读操作及数据分析等离线操作都会在从服务器上完成。 ②前面提到的业务分割模式也可以用在数据库，不同业务数据表部署在不同的数据库集群上，这就是所谓的 “数据分库”；但是其有一个制约条件：跨库的表无法进行 Join 操作； ③在实际运维中，对一些单表数据仍然很大的表，例如 Facebook 的用户数据库、淘宝的商品数据库等，还需要进行分片，将一张表拆分开分别存储在多个数据库中，这就是所谓的 “数据分片”； （2）NoSQL 数据库的伸缩性设计 首先，NoSQL 主要指非关系的、分布式的数据库设计模式。也有许多专家将 NoSQL 解读为 Not Only SQL，表示 NoSQL 是关系数据库的补充，而不是替代方案。一般而言，NoSQL 数据库产品都放弃了关系数据库的两大重要基础：①以关系代数为基础的结构化查询语言（SQL）②事务的一致性保证（ACID）；与之对应的是强化一些大型网站更关注的特性：高可用性和可伸缩性； 开源社区的 NoSQL 产品不尽其数，其支持的数据结构和伸缩性特性也各不相同。目前看来，应用最广泛的是 Apache HBase。HBase 的伸缩性主要依赖于其可分裂的 HRegion 及可伸缩的分布式文件系统 HDFS（如果您不知道 HDFS 又对 HDFS 有兴趣，可以阅读我的另一篇博文《不怕故障的海量存储—HDFS 基础入门》）实现。 上图是 HBase 的整体架构图： ①HBase 中数据以 HRegion 为单位进行管理，也就是说应用程序如果想要访问一个数据，必须先找到 HRegion，然后将数据读写操作提交给 HRegion，由 HRegion 完成存储层面的数据操作。 ②每个 HRegion 中存储一段 Key 区间（例如：[Key1,Key2)）的数据，HRegionServer 是物理服务器，每个 HRegionServer 上可以启动多个 HRegion 实例。当一个 HRegion 中写入的数据太多，达到配置的阀值时，HRegion 会分裂成两个 HRegion，并将 HRegion 在整个集群中进行迁移，以使 HRegionServer 的负载均衡。 ③所有的 HRegion 的信息都（例如：存储的 Key 值区间、所在 HRegionServer 的 IP 地址和端口号等）记录在 HMaster 服务器上。同时为了保证高可用，HBase 启动了多个 HMaster，并通过 ZooKeeper（一个支持分布式一致性的数据管理服务）选举出一个主服务器，通过这个主 HMaster 服务器获得 Key 值所在的 HRegionServer，最后请求该 HRegionServer 上的 HRegion 实例，获得需要的数据。其具体的数据寻址访问流程如下图所示： 五、学习小结 在本章的学习中，我们了解到要实现网站的可伸缩性，关键技术就在于如何构建 “良好” 的服务器集群。要达到良好的目标，就要求每次扩容和减少服务器时，对整个网站的影响是最小的，甚至无影响的。伸缩性是复杂的，没有通用的、完美的解决方案和产品。一个具有良好伸缩性的网站，其设计总是走在业务发展的前面，在业务需要处理更多访问和处理之前，就已经做好了充分的准备，当业务需要时，只需要增加服务器并简单部署就可以了，技术团队便可轻松应对了。 参考文献 （1）李智慧，《大型网站技术架构 - 核心原理与案例分析》，http://item.jd.com/11322972.html （2）老徐的私房菜，《HTTP 无状态协议和 Session 原理》，http://laoxu.blog.51cto.com/4120547/1219699 （3）百度百科，《一致性 Hash 算法》，http://baike.baidu.com/view/1588037.htm （4）charlee，《Memcached 完全剖析》，http://kb.cnblogs.com/page/42731/ （5）bluishglc，《数据库 Sharding 的基本思想和切分策略》，http://blog.csdn.net/bluishglc/article/details/6161475 本章思维导图 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》笔记4 瞬时响应：网站的高性能架构]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-6%2F</url>
    <content type="text"><![CDATA[4 瞬时响应：网站的高性能架构 一、网站性能测试（1）性能测试指标：①响应时间；②并发数；③吞吐量；④性能计数器； （2）性能测试方法：①性能测试；②负载测试；③压力测试；④稳定性测试； （3）性能优化策略： ①性能分析：检查请求处理各个环节的日志，分析哪个环节响应时间不合理，检查监控数据分析影响性能的因素； ②性能优化：Web 前端优化，应用服务器优化，存储服务器优化； 二、Web 前端性能优化（1）浏览器访问优化： ①减少 http 请求：因为 http 是无状态的，每次请求的开销都比较昂贵（需要建立通信链路、进行数据传输，而服务器端对于每个 http 请求都需要启动独立的线程去处理）；减少 http 的主要手段是合并 CSS、合并 JS、合并图片（CSS 精灵，利用偏移定位 image）； ②使用浏览器缓存：设置 http 头中 Cache-Control 和 Expires 属性； ③启用压缩：可以对 html、css、js 文件启用 Gzip 压缩，可以达到较高的压缩效率，但是压缩会对服务器及浏览器产生一定的压力； ④CSS 放页面最上面，JS 放页面最下面：浏览器会在下载完全部 CSS 之后才开始对整个页面进行渲染，因此最好将 CSS 放在页面最上面；而浏览器在加载 JS 后会立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此最好将 JS 放在页面最下面； ⑤减少 Cookie 传输：一方面，太大的 Cookie 会严重影响数据传输；另一方面，对于某些静态资源的访问（如 CSS、JS 等）发送 Cookie 没有意义； （2）CDN 加速： CDN（内容分发网络）仍然是一个缓存，它将数据缓存在离用户最近的地方，便于用户以最快速度获取数据。即所谓的 “网络访问第一跳”，如下图所示： CDN 只将访问频度很高的热点内容（例如：图片、视频、CSS、JS 脚本等访问频度很高的内容）进行缓存，可以极大地加快用户访问速度，减少数据中心负载。 （3）反向代理： 反向代理服务器位于网站机房，代理网站 Web 服务器接收 Http 请求，对请求进行转发，如下图所示： 反向代理服务器具有以下功能： ①保护网站安全：任何来自 Internet 的请求都必须先经过代理服务器； ②通过配置缓存功能加速 Web 请求：减轻真实 Web 服务器的负载压力； ③实现负载均衡：均衡地分发请求，平衡集群中各个服务器的负载压力； 三、应用服务器性能优化（1）分布式缓存： PS：网站性能优化第一定律：优先考虑使用缓存优化性能。缓存是指将数据存储在相对较高访问速度的存储介质中（如内存），以供系统进行快速处理响应用户请求。 ①缓存本质是一个内存 Hash 表，数据以 (Key,Value) 形式存储在内存中。 ②缓存主要用来存放那些读写比很高、很少变化的数据，如商品的类目信息、热门商品信息等。这样，应用程序读取数据时，先到缓存中取，如缓存中没有或失效，再到数据库中取出，重新写入缓存以供下一次访问。因此，可以很好地改善系统性能，提高数据读取速度，降低存储访问压力。 ③分布式缓存架构：一方面是以以 JBoss Cache 为代表的互相通信派；另一方面是以 Memcached 为代表的互不通信派； JBoss Cache 需要将缓存信息同步到集群中的所有机器，代价比较大；而 Memcached 采用一种集中式的缓存集群管理，缓存与应用分离部署，应用程序通过一致性 Hash 算法选择缓存服务器远程访问缓存数据，缓存服务器之间互不通信，因而集群规模可以轻易地扩容，具有良好的伸缩性。 Memcached 由两个核心组件组成：服务端（ms）和客户端（mc），在一个 memcached 的查询中，mc 先通过计算 key 的 hash 值来确定 kv 对所处在的 ms 位置。当 ms 确定后，客户端就会发送一个查询请求给对应的 ms，让它来查找确切的数据。因为这之间没有交互以及多播协议，所以 memcached 交互带给网络的影响是最小化的。 （2）异步操作： ①使用消息队列将调用异步化，可改善网站的扩展性，还可改善网站性能； ②消息队列具有削峰的作用 -&gt; 将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务； PS：任何可以晚点做的事情都应该晚点再做。前提是：这个事儿确实可以晚点再做。 （3）使用集群： ①在高并发场景下，使用负载均衡技术为一个应用构建多台服务器组成的服务器集群； ②可以避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性； ③负载均衡可以采用硬件设备，也可以采用软件负载。商用硬件负载设备（例如出名的 F5）成本通常较高（一台几十万上百万很正常），所以在条件允许的情况下我们会采用软负载，软负载解决的两个核心问题是：选谁、转发，其中最著名的是 LVS（Linux Virtual Server）。 _PS：_LVS 是四层负载均衡，也就是说建立在 OSI 模型的第四层——传输层之上，传输层上有我们熟悉的 TCP/UDP，LVS 支持 TCP/UDP 的负载均衡。 LVS 的转发主要通过修改 IP 地址（NAT 模式，分为源地址修改 SNAT 和目标地址修改 DNAT）、修改目标 MAC（DR 模式）来实现。有关 LVS 的详情请参考：http://www.importnew.com/11229.html实际上LVS的机器代替真实的服务器与用户通过TCP三次握手建立了连接，所以LVS是需要关心「连接」级别的状态的。 （4）代码优化： ①多线程：使用多线程的原因：一是 IO 阻塞，二是多 CPU，都是为了最大限度地利用 CPU 资源，提高系统吞吐能力，改善系统性能； ②资源复用：目的是减少开销很大的系统资源的创建和销毁，主要采用两种模式实现：单例（Singleton）和对象池（Object Pool）。例如，在. NET 开发中，经常使用到的线程池，数据库连接池等，本质上都是对象池。 ③数据结构：在不同场合合理使用恰当的数据结构，可以极大优化程序的性能。 ④垃圾回收：理解垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。这里主要针对 Java（JVM）和 C#（CLR）一类的具有 GC（垃圾回收机制）的语言。 四、存储性能优化（1）机械硬盘 还是 固态硬盘？ ①机械硬盘：通过马达驱动磁头臂，带动磁头到指定的磁盘位置访问数据。它能够实现快速顺序读写，慢速随机读写。 ②固态硬盘（又称 SSD）：无机械装置，数据存储在可持久记忆的硅晶体上，因此可以像内存一样快速随机访问。 在目前的网站应用中，大部分应用访问数据都是随机的，这种情况下 SSD 具有更好的性能表现，但是性价比有待提升（蛮贵的）。 （2）B + 树 vs LSM 树 ①传统关系型数据库广泛采用 B + 树，B + 树是对数据排好序后再存储，加快数据检索速度。 PS：目前大多数 DB 多采用两级索引的 B + 树，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 ID，一次数据文件读操作，一次数据文件写操作，终于知道数据库操作有多麻烦多耗时了） ②NoSQL（例如：HBase）产品广泛采用 LSM 树： 具体思想是：将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。不过读取的时候稍微麻烦，需要合并磁盘中历史数据和内存中最近的修改操作，所以写入性能大大提升，读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件。 LSM 树的原理是：把一棵大树拆分成 N 棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会被清除并写入到磁盘中，磁盘中的树定期可以做合并操作，合并成一棵大树，以优化读性能。 LSM 树的优势在于：在 LSM 树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远快于 B + 树。 五、学习总结 对于网站的高性能架构这一章的阅读，通过大牛的书籍我们学到了从三个主要方面的性能优化策略，虽然都是理论，而且还只是浅显地说明，但是对于我们这些广大的开发菜鸟来说，扩展知识面，了解一点优化策略不是一件坏事，我们可以从中注意到日常的代码规范，如何写出高效的代码也是一件值得研究的事儿。在书中，看到了作者写了这样一句话，贴出来与各位正在学习途中的菜鸟们共享：“归根结底，技术是为业务服务的，技术选型和架构决策依赖业务规划乃至企业战略规划，离开业务发展的支撑和驱动，技术走不远，甚至还会迷路”。 参考文献（1）李智慧，《大型网站技术架构 - 核心原理与案例分析》，http://item.jd.com/11322972.html （2）周言之，《Memcached 详解》，http://blog.csdn.net/zlb824/article/details/7466943 （3）百度百科，CDN，http://baike.baidu.com/view/8689800.htm （4）王晨纯，《Web 基础架构：负载均衡和 LVS》，http://www.importnew.com/11229.html （5）辉之光，《B 树、B - 树、B + 树》，http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html （6）yanghuahui’s blog，《LSM 树由来、设计思想以及应用到 HBase 的索引》，http://www.cnblogs.com/yanghuahui/p/3483754.html 本章思维导图 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》笔记3 大型网站核心架构要素]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-5%2F</url>
    <content type="text"><![CDATA[3 大型网站核心架构要素 一、性能—响应时间决定用户（1）浏览器端： ①浏览器缓存； ②使用页面压缩； PS：Gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右。想要启用 Gzip 压缩，提高浏览速度，可以浏览这篇文章：http://www.chinaz.com/web/2012/1017/278682.shtml ③合理布局页面； CSS：把样式表置于顶部；避免使用 CSS 表达式（expression_r）；使用外部 JavaScript 和 CSS；削减 JavaScript 和 CSS；用 &lt;link&gt; 代替 @import；避免使用滤镜； JavaScript：把脚本置于页面底部；使用外部 JavaScript 和 CSS；削减 JavaScript 和 CSS；剔除重复脚本；减少 DOM 访问；开发智能事件处理程序； ④减少 Cookie 传输； （2）CDN：内容分发网络（Content Delivery Network，简称 CDN）将加速内容分发至离用户最近的节点，缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性，解决网络带宽小、用户访问量大、网点分布不均等问题。详情请见百度百科：http://baike.baidu.com/view/8689800.htm?from_id=420951&amp;type=search&amp;fromtitle=CDN&amp;fr=aladdin （3）应用服务器端：服务器本地缓存和分布式缓存； Memcached 简介：http://baike.baidu.com/view/794242.htm Redis 简介：http://baike.baidu.com/view/4595959.htm （4）服务器集群技术：Web 服务器集群、数据库服务器集群、分布式缓存服务器集群等等，通过部署多台服务器共同对外提供同类服务，提高整体处理能力。 （5）数据库服务器端： ①索引：索引（index）是对数据库表中一个或多个列（例如，employee 表的姓氏 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。 PS：要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。 ②缓存：数据库缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对数据库的物理数据源访问的频次，从而提高了应用的运行性能。 ③SQL 优化：当一个基于数据库的应用程序运行起来很慢时，90% 的可能都是由于数据访问程序的问题，要么是没有优化，要么是没有按最佳方法编写代码，因此你需要审查和优化你的数据访问 / 处理程序。具体可以浏览这篇文章：http://www.cnblogs.com/Shaina/archive/2012/04/22/2464576.html ④NoSQL：方兴未艾的 NoSQL 数据库通过优化数据模型、存储结构、伸缩性等手段在性能方面的优势日趋明显。 二、可用性—你能保证几个 9？（1）如何衡量可用性？全靠 9 来撑腰：几乎所有网站都承诺 7*24 小时可用，但事实上都不可能完全实现，总会有一些故障时间。那么，去除这些故障时间就是网站的总可用时间。换算成网站的可用性指标，以此衡量网站的可用性，例如某些知名网站可用性达到 99.99%。 （2）哪些手段提高可用性？ ①核心：冗余 - 各服务器互相备份保证整体可用； ②应用服务器端：通过负载均衡设备建立集群，其中一台宕机立即切换到其他服务器继续提供服务，这就保证了高可用性。 ③存储服务器端：需要对数据进行实时备份，当某台宕机立即将数据访问请求转换到其他服务器上，并进行数据恢复以保证数据高可用。 三、伸缩性—能屈能伸方为大丈夫（1）衡量标准： ①是否可以多态服务器构建集群？ ②是否容易向集群中添加新服务器？ ③加入服务器后是否能提供无差别服务？ （2）主要手段： ①应用服务器：使用合适的负载均衡设备（硬件还是软件？F5 还是 LVS+KeepAlived）； ②缓存服务器：改进缓存路由算法保证缓存数据的可访问性； ③数据库服务器：通过路由区分等手段将多服务器组成一个集群； 四、扩展性—不痛不痒之间新业务就上线了（1）衡量标准：增加新业务时是否可以实现对现有产品透明无影响（是否需要对现有业务进行修改匹配？）； （2）主要手段： ①事件驱动架构：利用消息队列实现； ②分布式服务：将业务和可复用服务分离； 五、安全性—妈妈再也不用担心的我的照片了（1）何为安全性？保护网站不受恶意访问和攻击，保护网站的重要数据不被窃取； （2）衡量标准：针对现存和潜在的攻击窃密手段，是否有可靠的应对策略； 本章思维导图 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》笔记2 大型架构模式]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-4%2F</url>
    <content type="text"><![CDATA[2 大型架构模式一、分层 最常见的架构模式，将系统在横向维度上切分成几个部分，每个部分单一职责。网站一般分为三个层次：应用层、服务层和数据层，其具体结构如下图所示： 通过分层，一个庞大系统切分成不同部分，便于分工合作和维护。 但是，分层架构也有一些挑战：①必须合理规划层次边界和接口；②禁止跨层次的调用及逆向调用。 二、分割 分割是在纵向方面对软件进行切分 -&gt; 将不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，有助于软件开发和维护，还便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。 三、分布式 ①分布式应用和服务：应用和服务模块分布式部署，便于业务功能扩展； ②分布式静态资源：JS、CSS、LOGO 图片等资源独立部署，采用独立域名 -&gt; 动静分离； ③分布式数据和存储：传统 RDBMS 分布式部署和 NoSQL 产品； ④分布式计算：Hadoop 及其 MapReduce 分布式计算框架，其特点是移动计算而不是移动数据。 四、集群 多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。当某台服务器发生故障，负载均衡设备或者系统的失效转移机制将请求转发到集群中的其他服务器上，提高系统的可用性，即所谓的 HA（高可用性）。 所以，在网站应用中，即使是访问量很小的分布式应用和服务，也至少要部署两台服务器构成一个小集群。 五、缓存 缓存是改善软件性能的第一手段。在复杂的软件设计中，缓存几乎无处不在。 ①CDN：内容分发网络，缓存网站的一些静态资源； ②反向代理：部署在网站的前端，最先访问到的就是反向代理服务器； ③本地缓存：在应用服务器本地缓存热点数据，无需访问数据库； ④分布式缓存：应用程序通过网络通信访问缓存数据； 网站应用中，缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力。 六、异步 业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行进行协作。 异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常便利。 异步消息队列可以提高系统可用性、加快网站响应速度，消除并发访问高峰。 七、冗余 要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样当某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。 数据库除了定期备份存档保存实现冷备份之外，为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份。 八、自动化 在无人值守的情况下，网站可以正常运行，一切都可以自动化是网站的理想状态。目前大型网站的自动化架构设计主要集中在发布运维方面。 ①发布部署过程自动化； ②自动化代码管理； ③自动化测试； ④自动化安全监测； 九、安全 ①通过密码和手机校验码进行身份验证； ②对登录、交易等操作进行加密； ③使用验证码进行识别； ④对于常见的 XSS 攻击、SQL 注入、编码转换等进行防范； ⑤对垃圾或敏感信息进行过滤； ⑥对交易转账等操作进行风险控制； 十、总结 好的设计绝对不是模仿，不是生搬硬套某个模式，而是对问题深刻理解之上的创造与创新，即使是 “微创新”，也是让人耳目一新的似曾相识。山寨与创新的最大区别不在于是否抄袭，是否模仿，而在于对问题和需求是否真正理解与把握。 本章思维导图 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》笔记1 大型网站架构演化]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-3%2F</url>
    <content type="text"><![CDATA[1 大型网站架构演化 一、大型网站系统特点 （1）高并发、大流量：PV 量巨大 （2）高可用：7*24 小时不间断服务 （3）海量数据：文件数目分分钟 xxTB （4）用户分布广泛，网络情况复杂：网络运营商 （5）安全环境恶劣：黑客的攻击 （6）需求快速变更，发布频繁：快速适应市场，满足用户需求 （7）渐进式发展：慢慢地运营出大型网站 二、大型网站架构演化过程 （1）初始阶段网站架构：一台 Server 就刚需—应用程序、数据库、文件等所有资源都集中在一台 Server 上，典型案例：基于 LAMP 架构的 PHP 网站 （2）应用和数据服务分离：三台 Server 平天下—业务发展，单台不再适应业务的发展，将应用和数据分离后成三台 Sever（应用服务器、文件服务器与数据库服务器）。分离后三台 Server 对硬件资源的需求各不相同：应用服务器需要更快更强大的 CPU，而数据库服务器需要更快的硬盘和更大的内存，文件服务器则需要更大的硬盘； （3）使用缓存改善网站性能：3+X 的 Server 模式—减少数据库访问压力，提高网站的数据访问速度。缓存又可以分为：本地缓存和远程缓存（可以是分布式的），本地缓存访问速度快，但数据量有限；远程分布式缓存可以集群，因此容量不受限制； （4）使用应用服务器集群改善网站并发处理能力：集群—解决高并发、海量数据问题的常用手段，实现系统的可伸缩性。通过负载均衡调度器，可将用户访问分发到集群中的某台 Server 上，应用服务器的负载压力不再成为整个网站的瓶颈。 （5）数据库读写分离：使用缓存后绝大部分都可以不通过 DB 就能完成，但仍有一部分（缓存访问不命中、缓存过期）和全部的写操作需要访问 DB，在网站的用户达到一定规模后，DB 因为负载压力过高成为网站的瓶颈。大部分主流 DB 都提供主从热备功能，利用这一功能就可以配置两台 DB 主从关系，一台数据更新同步到另一台 Server 上。网站利用 DB 的这一功能，实现 DB 读写分离，从而改善 DB 负载压力。 （6）使用反向代理和 CDN 加速网站响应：CDN 和反向代理的基本原理都是缓存，区别在于 CDN 部署在网络提供商的机房，而反向代理则部署在网站的中心机房。使用 CDN 和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。 （7）使用分布式文件系统和分布式数据库系统：随着网站业务的发展，两台 DB 服务器依然不能满足需求，文件系统也一样。 （8）使用 NoSQL 和搜索引擎：NoSQL 和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。 （9）业务拆分：通过分而治之的手段将整个网站业务分成不同的产品线，如淘宝将首页、商铺、订单、卖家、买家等拆分成不同的产品线，分归不同的业务团队负责。各个应用之间可以通过建立一个超链接建立关系，也可以通过消息队列进行数据分发。 （10）分布式服务：既然每一个应用系统都需要执行许多相通的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。 三、大型网站架构演化价值观（1）核心价值：随网站所需灵活应对 大型网站不是从无到有一步就搭建好一个大型网站，而是能够伴随小型网站业务的渐进发展，慢慢地演化成一个大型网站。 （2）驱动力量：网站的业务发展—业务成就了技术，事业成就了人，而不是相反 四、大型网站架构设计的误区 （1）一味追随大公司的解决方案 （2）为了技术而技术 -&gt; 常见问题 （3）企图用技术解决所有问题：技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决； 本章思维导图 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》 笔记概览]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-2%2F</url>
    <content type="text"><![CDATA[思维导图： 1 大型网站架构演化 2 大型架构模式 3 大型网站核心架构要素 4 瞬时响应：网站的高性能架构 5 万无一失：网站的高可用架构 6 永无止境：网站的伸缩性架构 7 随机应变：网站的可扩展架构 8 固若金汤：网站的安全架构 参考：大型网站技术架构（12篇） - 综合区 - [ 博客精选 ] - 手册网http://www.shouce.ren/api/view/a/15512Edison Chou - 博客园http://www.cnblogs.com/edisonchou/]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown文件中图片到图床的转换的解决方法]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-1%2F</url>
    <content type="text"><![CDATA[使用: python 脚本名 文件名 [是否图片压缩] 例： 1python md_transfer.py t.md 0 0 - 不需要压缩1 - 需要压缩，注意tiniPNG的key 原文：useful_script/自动转换markdown文件中图片到图床.md at master · JyHu/useful_scripthttps://github.com/JyHu/useful_script/blob/master/Scripts/md%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E5%9B%BE%E5%BA%8A%E8%BD%AC%E6%8D%A2/%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2markdown%E6%96%87%E4%BB%B6%E4%B8%AD%E5%9B%BE%E7%89%87%E5%88%B0%E5%9B%BE%E5%BA%8A.md]]></content>
      <tags>
        <tag>图床</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统中python导入第三方模块失败的解决方法]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19%2F</url>
    <content type="text"><![CDATA[问题：在 mac OSx 操作系统下，安装了 python 第三方模块，requests、xlrt、xlwt、selenium 等等，在 pip 中可以成功安装这些模块，但是在 python 中缺始终无法导入，提示 “no module named xxxx”。 使用 pip 安装一个 python3 第三方库： 1sudo python3 -m pip install requests 完美解决问题 原文：Mac系统中python导入第三方模块成功，但是import python第三方模块失败解决方法 - CSDN博客https://blog.csdn.net/fei2636/article/details/77499011]]></content>
      <tags>
        <tag>python</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式服务框架]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18-4%2F</url>
    <content type="text"><![CDATA[分布式架构的演进 系统架构演化历程 - 初始阶段架构 初始阶段 的小型系统 应用程序、数据库、文件等所有的资源都在一台服务器上通俗称为 LAMP特征：应用程序、数据库、文件等所有的资源都在一台服务器上。描述：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。 系统架构演化历程 - 应用服务和数据服务分离 好景不长，发现随着系统访问量的再度增加，webserver 机器的压力在高峰期会上升到比较高，这个时候开始考虑增加一台 webserver特征：应用程序、数据库、文件分别部署在独立的资源上。描述：数据量增加，单台服务器性能及存储空间不足，需要将应用和数据分离，并发处理能力和数据存储空间得到了很大改善。 系统架构演化历程 - 使用缓存改善性能 特征：数据库中访问较集中的一小部分数据存储在缓存服务器中，减少数据库的访问次数，降低数据库的访问压力。描述：系统访问特点遵循二八定律，即 80% 的业务访问集中在 20% 的数据上。缓存分为本地缓存和远程分布式缓存，本地缓存访问速度更快但缓存数据量有限，同时存在与应用程序争用内存的情况。 系统架构演化历程 - 使用应用服务器集群 在做完分库分表这些工作后，数据库上的压力已经降到比较低了，又开始过着每天看着访问量暴增的幸福生活了，突然有一天，发现系统的访问又开始有变慢的趋势了，这个时候首先查看数据库，压力一切正常，之后查看 webserver，发现 apache 阻塞了很多的请求，而应用服务器对每个请求也是比较快的，看来 是请求数太高导致需要排队等待，响应速度变慢特征：多台服务器通过负载均衡同时向外部提供服务，解决单台服务器处理能力和存储空间上限的问题。描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。 系统架构演化历程 - 数据库读写分离 享受了一段时间的系统访问量高速增长的幸福后，发现系统又开始变慢了，这次又是什么状况呢，经过查找，发现数据库写入、更新的这些操作的部分数据库连接的资源竞争非常激烈，导致了系统变慢特征：多台服务器通过负载均衡同时向外部提供服务，解决单台服务器处理能力和存储空间上限的问题。描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，使得服务器的负载压力不在成为整个系统的瓶颈。 系统架构演化历程 - 反向代理和 CDN 加速 特征：采用 CDN 和反向代理加快系统的 访问速度。描述：为了应付复杂的网络环境和不同地区用户的访问，通过 CDN 和反向代理加快用户访问的速度，同时减轻后端服务器的负载压力。CDN 与反向代理的基本原理都是缓存。 系统架构演化历程 - 分布式文件系统和分布式数据库 随着系统的不断运行，数据量开始大幅度增长，这个时候发现分库后查询仍然会有些慢，于是按照分库的思想开始做分表的工作特征：数据库采用分布式数据库，文件系统采用分布式文件系统。描述：任何强大的单一服务器都满足不了大型系统持续增长的业务需求，数据库读写分离随着业务的发展最终也将无法满足需求，需要使用分布式数据库及分布式文件系统来支撑。分布式数据库是系统数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。 系统架构演化历程 - 使用 NoSQL 和搜索引擎 特征：系统引入 NoSQL 数据库及搜索引擎。描述：随着业务越来越复杂，对数据存储和检索的需求也越来越复杂，系统需要采用一些非关系型数据库如 NoSQL 和分数据库查询技术如搜索引擎。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。 系统架构演化历程 - 业务拆分 特征：系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。描述：为了应对日益复杂的业务场景，通常使用分而治之的手段将整个系统业务分成不同的产品线，应用之间通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。 系统架构演化历程 - 分布式服务 特征：公共的应用模块被提取出来，部署在分布式服务器上供应用服务器调用。描述：随着业务越拆越小，应用系统整体复杂程度呈指数级上升，由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。 Q：分布式服务应用会面临哪些问题？A：(1) 当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。(2) 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。(3) 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？(4) 服务多了，沟通成本也开始上升，调某个服务失败该找谁？服务的参数都有什么约定？(5) 一个服务有多个业务消费者，如何确保服务质量？(6) 随着服务的不停升级，总有些意想不到的事发生，比如 cache 写错了导致内存溢出，故障不可避免，每次核心服务一挂，影响一大片，人心慌慌，如何控制故障的影响面？服务是否可以功能降级？或者资源劣化？ Java 分布式应用技术基础 分布式服务下的关键技术：消息队列架构 消息对列通过消息对象分解系统耦合性，不同子系统处理同一个消息 分布式服务下的关键技术：消息队列原理 分布式服务下的关键技术：服务框架架构 服务框架通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用服务框架是一个点对点模型服务框架面向同构系统适合：移动应用、互联网应用、外部系统 分布式服务下的关键技术：服务框架原理 分布式服务下的关键技术：服务总线架构 服务总线同服务框架一样，均是通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用服务总线是一个总线式的模型服务总线面向同构、异构系统适合：内部系统 分布式服务下的关键技术：服务总线原理 分布式架构下系统间交互的 5 种通信模式request/response 模式（同步模式）：客户端发起请求一直阻塞到服务端返回请求为止。Callback（异步模式）：客户端发送一个 RPC 请求给服务器，服务端处理后再发送一个消息给消息发送端提供的 callback 端点，此类情况非常合适以下场景：A 组件发送 RPC 请求给 B，B 处理完成后，需要通知 A 组件做后续处理。Future 模式：客户端发送完请求后，继续做自己的事情，返回一个包含消息结果的 Future 对象。客户端需要使用返回结果时，使用 Future 对象的. get(), 如果此时没有结果返回的话，会一直阻塞到有结果返回为止。Oneway 模式：客户端调用完继续执行，不管接收端是否成功。Reliable 模式：为保证通信可靠，将借助于消息中心来实现消息的可靠送达，请求将做持久化存储，在接收方在线时做送达，并由消息中心保证异常重试。 五种通信模式的实现方式 - 同步点对点服务模式 五种通信模式的实现方式 - 异步点对点消息模式 1 五种通信模式的实现方式 - 异步点对点消息模式 2 五种通信模式的实现方式 - 异步广播消息模式 分布式架构下的服务治理服务治理是服务框架 / 服务总线的核心功能。所谓服务治理，是指服务的提供方和消费方达成一致的约定，保证服务的高质量。服务治理功能可以解决将某些特定流量引入某一批机器，以及限制某些非法消费者的恶意访问，并在提供者处理量达到一定程度是，拒绝接受新的访问。基于服务框架 Dubbo 的服务治理 - 服务管理道你的系统，对外提供了多少服务，可以对服务进行升级、降级、停用、权重调整等操作可以知道你提供的服务，谁在使用，因业务需求，可以对该消费者实施屏蔽、停用等操作基于服务框架 Dubbo 的服务治理 - 服务监控 可以统计服务的每秒请求数、平均响应时间、调用量、峰值时间等，作为服务集群规划、性能调优的参考指标。 基于服务框架 Dubbo 的服务治理 - 服务路由 基于服务框架 Dubbo 的服务治理 - 服务保护 基于服务总线 OSB 的服务治理 - 功能介绍 基于服务总线 OSB 的服务治理 Q：Dubbo 到底是神马？A： 淘宝开源的高性能和透明化的 RPC 远程调用服务框架SOA 服务治理方案 Q：Dubbo 原理是？A： 参考：Java分布式应用如何入门以及有哪些资料？ - 知乎https://www.zhihu.com/question/22764869]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis面试总结&史上最全Redis面试题及答案]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18-3%2F</url>
    <content type="text"><![CDATA[Redis 在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在 Redis 的使用和原理方面对小伙伴们进行各种刁难。作为一名在互联网技术行业打击过成百上千名【请允许我夸张一下】的资深技术面试官，看过了无数落寞的身影失望的离开，略感愧疚，故献上此文，希望各位读者以后面试势如破竹，永无失败！ Redis 有哪些数据结构？ 字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。 如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、Geo、Pub/Sub。 如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。 使用过 Redis 分布式锁么，它是什么回事？ 先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。 这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？ 这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 使用 keys 指令可以扫出指定模式的 key 列表。 对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？ 这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。 使用过 Redis 做异步队列么，你是怎么用的？ 一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。 如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。 如果对方追问能不能生产一次消费多次呢？使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。 如果对方追问 pub/sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。 如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。 到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？ 如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。 Redis 如何做持久化的？ bgsave 做镜像全量持久化，aof 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 aof 来配合使用。在 redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 aof 重放近期的操作指令来实现完整恢复重启之前的状态。 对方追问那如果突然机器掉电会怎样？取决于 aof 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync，比如 1s1 次，这个时候最多就会丢失 1s 的数据。 对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow。fork 是指 redis 通过创建子进程来进行 bgsave 操作，cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。 Pipeline 有什么好处，为什么要用 pipeline？ 可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。 Redis 的同步机制了解么？ Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。 是否使用过 Redis 集群，集群的原理是什么？ Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。 Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。 史上最全Redis面试题及答案1、什么是Redis？ Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 2、Redis相比memcached有哪些优势？ (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 (2) redis的速度比memcached快很多 (3) redis可以持久化其数据 3、Redis支持哪几种数据类型？ String、List、Set、Sorted Set、hashes 4、Redis主要消耗什么物理资源？ 内存。 5、Redis的全称是什么？ Remote Dictionary Server。 6、Redis有哪几种数据淘汰策略？ noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外） allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 7、Redis官方为什么不提供Windows版本？ 因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。 8、一个字符串类型的值能存储最大容量是多少？ 512M 9、为什么Redis需要把所有数据放到内存中？ Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。 10、Redis集群方案应该怎么做？都有哪些方案？ 1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。 2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。 3.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。 4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。 11、Redis集群方案什么情况下会导致整个集群不可用？ 有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。 12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？ redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 13、Redis有哪些适合的场景？ （1）、会话缓存（Session Cache） 最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。 （2）、全页缓存（FPC） 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。 此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 （3）、队列 Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。 （4），排行榜/计数器 Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 （5）、发布/订阅 最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。 14、Redis支持的Java客户端都有哪些？官方推荐用哪个？ Redisson、Jedis、lettuce等等，官方推荐使用Redisson。 15、Redis和Redisson有什么关系？ Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。 16、Jedis与Redisson对比有什么优缺点？ Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 17、Redis如何设置密码及验证密码？ 设置密码：config set requirepass 123456 授权密码：auth 123456 18、说说Redis哈希槽的概念？ Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。 19、Redis集群的主从复制模型是怎样的？ 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品. 20、Redis集群会有写操作丢失吗？为什么？ Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 21、Redis集群之间是如何复制的？ 异步复制 22、Redis集群最大节点个数是多少？ 16384个。 23、Redis集群如何选择数据库？ Redis集群目前无法做数据库选择，默认在0数据库。 24、怎么测试Redis的连通性？ ping 25、Redis中的管道有什么用？ 一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。 这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。 26、怎么理解Redis事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 27、Redis事务相关的命令有哪几个？ MULTI、EXEC、DISCARD、WATCH 28、Redis key的过期时间和永久有效分别怎么设置？ EXPIRE和PERSIST命令。 29、Redis如何做内存优化？ 尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面. 30、Redis回收进程如何工作的？ 一个客户端运行了新的命令，添加了新的数据。Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 31、Redis回收使用的是什么算法？ LRU算法 32、Redis如何做大量数据插入？ Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。 33、为什么要做Redis分区？ 分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。 34、你知道有哪些Redis分区实现方案？ 客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。 代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy 查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。 35、Redis分区有什么缺点？ 涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。同时操作多个key,则不能使用Redis事务.分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。36、Redis持久化数据和缓存怎么做扩容？ 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。37、分布式Redis是前期做还是后期规模上来了再做好？为什么？ 既然Redis是如此的轻量（单实例只使用1M内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。 一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。 这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。 38、Twemproxy是什么？ Twemproxy是Twitter维护的（缓存）代理系统，代理Memcached的ASCII协议和Redis协议。它是单线程程序，使用c语言编写，运行起来非常快。它是采用Apache 2.0 license的开源软件。 Twemproxy支持自动分区，如果其代理的其中一个Redis节点不可用时，会自动将该节点排除（这将改变原来的keys-instances的映射关系，所以你应该仅在把Redis当缓存时使用Twemproxy)。 Twemproxy本身不存在单点问题，因为你可以启动多个Twemproxy实例，然后让你的客户端去连接任意一个Twemproxy实例。 Twemproxy是Redis客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。 39、支持一致性哈希的客户端有哪些？ Redis-rb、Predis等。 40、Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。41、Redis的内存占用情况怎么样？ 给你举个例子： 100万个键值对（键是0到999999值是字符串“hello world”）在我的32位的Mac笔记本上 用了100MB。同样的数据放到一个key里只需要16MB， 这是因为键值有一个很大的开销。 在Memcached上执行也是类似的结果，但是相对Redis的开销要小一点点，因为Redis会记录类型信息引用计数等等。 当然，大键值对时两者的比例要好很多。 64位的系统比32位的需要更多的内存开销，尤其是键值对都较小时，这是因为64位的系统里指针占用了8个字节。 但是，当然，64位系统支持更大的内存，所以为了运行大型的Redis服务器或多或少的需要使用64位的系统。 42、都有哪些办法可以降低Redis的内存使用情况呢？ 如果你使用的是32位的Redis实例，可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。 43、查看Redis使用情况及状态信息用什么命令？ info 44、Redis的内存用完了会发生什么？ 如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。 45、Redis是单线程的，如何提高多核CPU的利用率？ 可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。 46、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？ 理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。 任何list、set、和sorted set都可以放232个元素。 换句话说，Redis的存储极限是系统中的可用内存值。 47、Redis常见性能问题和解决方案？ (1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件 (2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 (3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 (4) 尽量避免在压力很大的主库上增加从库 (5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。 48、Redis提供了哪几种持久化方式？ RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始。49、如何选择合适的持久化方式？ 一般来说， 如果想达到足以媲美PostgreSQL的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。 有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外， 使用RDB还可以避免之前提到的AOF程序的bug。 50、修改配置不重启Redis会实时生效吗？ 针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。 但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。]]></content>
      <tags>
        <tag>面试</tag>
        <tag>待阅</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis持久化（RDB、AOF）]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18-2%2F</url>
    <content type="text"><![CDATA[第5章 持久化5.1 RDBRDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持 久化过程分为手动触发和自动触发。 5.1.1 触发机制手动触发分别对应save和bgsave命令： save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。 bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。 显然bgsave命令是针对save阻塞问题做的优化。因此Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃。 除了执行命令手动触发之外，Redis内部还存在自动触发RDB的持久化 机制，例如以下场景： 1）使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。2）如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点，更多细节见6.3节介绍的复制原理。3）执行debug reload命令重新加载Redis时，也会自动触发save操作。4）默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则 自动执行bgsave。 5.1.2 流程说明bgsave是主流的触发RDB持久化方式，下面根据图5-1了解它的运作流程。 1）执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进程，如RDB/AOF子进程，如果存在bgsave命令直接返回。 2）父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗 时，单位为微秒。 3）父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。 4）子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的时间，对应info统计的rdb_last_save_time选项。 5）进程发送信号给父进程表示完成，父进程更新统计信息，具体见 info Persistence下的rdb_*相关选项。 5.1.3 RDB文件的处理保存：RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配 置指定。可以通过执行config set dir{newDir}和config set dbfilename{newFileName}运行期动态执行，当下次运行时RDB文件会保存到 新目录。 5.1.4 RDB的优缺点RDB的优点： RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。 Redis加载RDB恢复数据远远快于AOF的方式。 RDB的缺点： RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运 行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。 RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式 的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。 针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。 5.2 AOFAOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。理解掌握好AOF持久化机制对我们兼顾数据安全性和性能非常有帮助。 5.2.1 使用AOF开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名通过appendfilename配置设置，默认文件名是appendonly.aof。保存路径同RDB持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load），如图5-2所示。 流程如下：1）所有的写入命令会追加到aof_buf（缓冲区）中。2）AOF缓冲区根据对应的策略向硬盘做同步操作。3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。 了解AOF工作流程之后，下面针对每个步骤做详细介绍。 5.2.2 命令写入AOF命令写入的内容直接是文本协议格式。例如set hello world这条命令，在AOF缓冲区会追加如下文本： 1*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n Redis协议格式具体说明见4.1客户端协议小节，这里不再赘述，下面介绍关于AOF的两个疑惑： 1）AOF为什么直接采用文本协议格式？可能的理由如下： 文本协议具有很好的兼容性。 开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销。 文本协议具有可读性，方便直接修改和处理。 2）AOF为什么把命令追加到aof_buf中？Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负 载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区 同步硬盘的策略，在性能和安全性方面做出平衡。 5.2.3 文件同步Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制， 不同值的含义如表5-1所示。 系统调用write和fsync说明： write操作会触发延迟写（delayed write）机制。Linux在内核提供页缓 冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步 硬盘操作依赖于系统调度机制，例如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。 fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化。除了write、fsync，Linux还提供了sync、fdatasync操作，具体API说明参见：http://linux.die.net/man/2/write，http://linux.die.net/man/2/fsync，http://linux.die.net/m 配置为always时，每次写入都要同步AOF文件，在一般的SATA硬盘上，Redis只能支持大约几百TPS写入，显然跟Redis高性能特性背道而驰，不建议配置。 配置为no，由于操作系统每次同步AOF文件的周期不可控，而且会加 大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。 配置为everysec，是建议的同步策略，也是默认配置，做到兼顾性能和 数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据。（严格 来说最多丢失1秒数据是不准确的，5.3节会做具体介绍到。） 5.2.4 重写机制随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis 引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。 重写后的AOF文件为什么可以变小？有如下原因： 1）进程内已经超时的数据不再写入文件。 2）旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保 留最终数据的写入命令。 3）多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢 出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。 AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF 文件可以更快地被Redis加载。 AOF重写过程可以手动触发和自动触发： 手动触发：直接调用bgrewriteaof命令。 自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。 auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认 为64MB。 auto-aof-rewrite-percentage：代表当前AOF文件空间 （aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。 自动触发时机=aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size-aof_base_size）/aof_base_size&gt;=auto-aof-rewritepercentage 其中aof_current_size和aof_base_size可以在info Persistence统计信息中查 看。 当触发AOF重写时，内部做了哪些事呢？下面结合图5-3介绍它的运行流程。 流程说明：1）执行AOF重写请求。 如果当前进程正在执行AOF重写，请求不执行并返回如下响应： 1ERR Background append only file rewriting already in progress 如果当前进程正在执行bgsave操作，重写命令延迟到bgsave完成之后再 执行，返回如下响应： 1Background append only file rewriting scheduled 2）父进程执行fork创建子进程，开销等同于bgsave过程。 3.1）主进程fork操作完成后，继续响应其他命令。所有修改命令依然写 入AOF缓冲区并根据appendfsync策略同步到硬盘，保证原有AOF机制正确 性。 3.2）由于fork操作运用写时复制技术，子进程只能共享fork操作时的内 存数据。由于父进程依然响应命令，Redis使用“AOF重写缓冲区”保存这部 分新数据，防止新AOF文件生成期间丢失这部分数据。 4）子进程根据内存快照，按照命令合并规则写入到新的AOF文件。每 次批量写入硬盘数据量由配置aof-rewrite-incremental-fsync控制，默认为 32MB，防止单次刷盘数据过多造成硬盘阻塞。 5.1）新AOF文件写入完成后，子进程发送信号给父进程，父进程更新 统计信息，具体见info persistence下的aof_*相关统计。 5.2）父进程把AOF重写缓冲区的数据写入到新的AOF文件。 5.3）使用新AOF文件替换老文件，完成AOF重写。 5.2.5 重启加载AOF和RDB文件都可以用于服务器重启时的数据恢复。如图5-4所示， 表示Redis持久化文件加载流程。图5-4 Redis持久化文件加载流程 流程说明：1）AOF持久化开启且存在AOF文件时，优先加载AOF文件，打印如下 日志： 1* DB loaded from append only file: 5.841 seconds 2）AOF关闭或者AOF文件不存在时，加载RDB文件，打印如下日志： 1* DB loaded from disk: 5.586 seconds 3）加载AOF/RDB文件成功后，Redis启动成功。4）AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。 5.2.6 文件校验加载损坏的AOF文件时会拒绝启动，并打印如下日志： 1# Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix 对于错误格式的AOF文件，先进行备份，然后采用redis-check-aof–fix命 令进行修复，修复后使用diff-u对比数据的差异，找出丢失的数据，有些可 以人工修改补全。 AOF文件可能存在结尾不完整的情况，比如机器突然掉电导致AOF尾部 文件命令写入不全。Redis为我们提供了aof-load-truncated配置来兼容这种情 况，默认开启。加载AOF时，当遇到此问题时会忽略并继续启动，同时打印 如下警告日志： 123# !!! Warning: short read while loading the AOF file !!! # !!! Truncating the AOF at offset 397856725 !!!# AOF loaded anyway because aof-load-truncated is enabled 5.5 本章重点回顾1）Redis提供了两种持久化方式：RDB和AOF。 2）RDB使用一次性生成内存快照的方式，产生的文件紧凑压缩比更 高，因此读取RDB恢复速度更快。由于每次生成RDB开销较大，无法做到实 时持久化，一般用于数据冷备和复制传输。 3）save命令会阻塞主线程不建议使用，bgsave命令通过fork操作创建子 进程生成RDB避免阻塞。 4）AOF通过追加写命令到文件实现持久化，通过appendfsync参数可以 控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积逐渐 变大，需要定期执行重写操作来降低文件体积。 5）AOF重写可以通过auto-aof-rewrite-min-size和auto-aof-rewrite- percentage参数控制自动触发，也可以使用bgrewriteaof命令手动触发。 6）子进程执行期间使用copy-on-write机制与父进程共享内存，避免内 存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免 数据丢失。 7）持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间 跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张。 8）单机下部署多个实例时，为了防止出现多个子进程执行重写操作， 建议做隔离控制，避免CPU和IO资源竞争。 参考：《redis开发与运维》]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>RDB</tag>
        <tag>AOF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fabric 架构深度解读]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18-1%2F</url>
    <content type="text"><![CDATA[前言Hyperledger Project 由 Linux 基金会创办于 2015 年 10 月，是一个开源的区块链研发孵化项目，致力于提供可协同开发以区块链为底层的分布式账本。旗下的 Fabric 项目目标为打造一个提供分布式账本解决方案的平台。 业务上所期望解决的问题——信用问题 首先从比特币说起，大家对比特币算力证明（POW）的名词应该不陌生，先不说其耗费大量的资源，从共识机制上来看，拥有超过 50% 的算力即可掌控整个比特币，无论从技术还是业务的角度都是一个风险极高的机制，但神奇的金融圈没有人会去触碰这样的底线，一旦有人拥有超过 50% 的算力，比特币可能就玩不下去了：） 那么实际的业务场景中的需求应该是怎样的呢？比如说，银行结算清算系统，传统的银行交易系统中，如果出现跨行交易，那么交易数据便需要一个清算系统进行定时对账确保双方的交易数据是同步无误的，那么就可能导致跨行转账需要 T+1 的时长，而主要的原因是因为双方的系统及数据相互独立，数据互不 “信任”，所以需要一个清算系统去验证交易数据，而区块链可以说是为了解决这种“信任” 问题而产生的技术，在双方进行交易的同时对数据进行了认证，那么便无需交易后再进行清算而达到实时转账等功能。下面来说为了解决 “信用” 问题，技术上需要哪些手段去满足。 技术上需要哪些特性去达到 “数据可信任”** 以上面提出的清算系统为例，可能有人提出，双方使用同一个分布式数据库不就可以达到实时的数据同步了嘛。确实，区块链其中一个特性便是分布式，但是和传统的分布式数据库区别在哪呢？在回归到业务中，如果双方银行进行交易的时候，使用这样一个分布式数据库，难道不担心对方偷偷地把数据改了吗？如果你说有日志可以追述得到修改记录，首先日志也是容易被修改的，且日志也无法挽回动不动可能就上百万千万甚至过亿的金额损失，所以说传统的分布式数据库对于企业之间来说是” 不可信的 “，那么便要求区块链需要达到数据不可篡改、用户有身份认证、交易可追述、交易有权重等一系列的特性。 剖析技术原理 上面说到区块链的各种特性，从功能上来说这些特性有些是相辅相成。那么应当如何去实现这些功能呢，接下来结合 Fabric 的一些具体实现来一一阐述。 存储数据结构 要达到数据不可篡改首先从数据结构上来看，也是区块链之所以称之为区块链的原因。如下图所示，每个存储单元包含上一存储单元的 hash 值（图中 hash 值的对应关系不完全精确，仅示意用）以及自身存储的交易数据块，可以从表象来看就像把所有数据块连接在一起，称之为 “区块链”，形成链状可追述的交易记录。这种链状结构的数据称之为账本数据，保存着所有交易的记录，此外还有一个 “世界状态”，其实质为 Key-Value 数据库，维护着交易数据的最终状态，便于查询等操作运算，并且每个数据都有其对应的版本号。 Fabric 主要模块 总体来说，市面上各种区块链的实现方案都是基于这种数据结构，而仅靠数据结构并不能保证数据不可篡改，还有一个非常重要的因素，便是共识机制，一个好的共识机制才是保障整个业务运转的根本，相当于双方签订的合同或者协议，只有双方都遵守条约才能合作将业务展开进行。例如常见的 POW，POS，PBFT 等都属于共识机制，而其原理或者弊端这里不做赘述，主要来详细讲解 Fabric 应用的设计方案及其原理，此前先解释下一些特定名词的概念。 首先说” 智能合约 “的概念。在传统中心化的系统中，例如支付宝用户 A 给 B 转账 100 元，那么假设起始 A 有 100 元 B 有 0 元，那么在支付宝系统内调用转账的函数可能是这样的一个流程，调用 transfer(A,B,100)，而函数内可能会去读取用户 A 和 B 的账户余额，那么我们可以表达成 input(A,B,100),read(A:100,B:0),write(A:0,B:100)，那么这个仅是在支付宝的系统内执行了便完成了，那如何形成一个合约呢？ 就如 A、B 在签订一份合同，双方都要对合同进行签名认可，在程序中就等于，用户 A 在其本地执行 transfer(A,B,100) 得出 input(A,B,100),read(A:100,B:0),write(A:0,B:100) 并对其签名认证，用户 B 在其本地执行 transfer(A,B,100) 得出 input(A,B,100),read(A:100,B:0),write(A:0,B:100) 并对其签名认证，然后双方将结果发给对方，然后判断对方结果是否一致并对其签名进行校验无误后便认为合约达成将结果写入本地。通俗来说就是将一段核心代码抽出来，所有参与方都去执行该代码并对其结果进行签名认证比对，便称之为执行智能合约，而其中共有的代码便是 “合约 “。 再说” 背书策略 “的概念。那么根据上面所言的共有代码在交易中是不是所有用户都要执行呢？比如说 A、B 用户转账，那么 C、D 用户显然就不需要规定其参与执行职能合约了，那么背书策略便是规定智能合约的结果需要哪些成员的签名背书才算交易成功。 在 Fabric 的交易流程中，主要有几个关键节点参与，包括 Peer 节点、Orderer 节点、CA 节点及 client 端。 Peer 节点 该节点是参与交易的主体，可以说是代表每个参与到链上的成员，他负责储存完整的账本数据即区块链数据，负责共识环节中的执行智能合约，其中所有的 Peer 节点都维护完整的账本数据称之为 Committer，而根据具体的业务划分背书策略时决定哪些 Peer。 Orderer 节点 该节点负责收集交易请求进行排序并打包生产新的区块，主体功能便是对交易排序从而保证各 Peer 节点上的数据一致性，也包含了 ACL 进行访问控制。 CA 节点 该节点负责对加入链内的所有节点进行授权认证，包括上层的 client 端，每一个节点都有其颁发的证书用于交易流程中的身份识别。 client Fabric 对于 client 端提供了 SDK 让开发人员可以更容易地对接到区块链内的交易环节，交易的发起便是通过 SDK 进行。 供应链金融中的应用 以上简单的阐述了各模块的功能，当然实际当中包含更多服务支持的功能，那么这里在套进供应链金融来举例，更好地理解各节点的意义。 一个简单的供应链模型，一个核心企业向其供应商进行采购 1000w 物资，按照赊销合同在收到物资后半年进行结账，那么半年的账期供应商资金无法周转开便拿着核心企业开具的银行承兑汇票进行抵押融资，那么银行审核通过后将票据 95% 的金额马上转给了供应商，半年账期到后，核心企业便直接将货款转给银行，这样就形成了一次供应链的融资交易了。 在实际的业务当中大部分都是在线下进行操作的，耗费众多的人力及时间，那如何将这样的业务转成线上电子化呢？有人或许说银行提供这样的平台服务不就好了嘛，那假设这个平台不仅仅是这一家银行参与呢，若所有的银行或者企业都可以在同一个平台进行，那么交由某一个银行提供服务就显得不合适了。好，那么我们用 Fabric 来实现这样一个系统我们看看在部署上是怎样分布的呢。 上面是理想下的模型，当然在实际当中这样的部署方案也可能不成立，比如供应商并不一定有能力在其内部接入服务器等。我们仍然以此为例说明节点的意义，图中每个参与方都在本地部署 Peer 节点以及接入业务系统 client 端，那么每个 Peer 节点都保持了所有交易的数据，那么在查数据的时候仅在本地便可完成，当然也可以去查他人的 Peer 节点比对数据，而中心的 CA 节点负责给每一个节点包括 client 端颁发证书让其在交易流程中可以互相认证从而防止外部恶意接入查看数据或者参与交易，而 Orderer 节点与所有的 Peer 节点相连接获取交易结果进行排序控制，那么这里涉及到了整体的交易流程，引用官方的示例图来解释。 来描述一下上图的交易流程，首先由 client 发起一个交易请求，而上图中的背书策略要求 Peer1、Peer2 及 Peer3 参与交易，所以 client 将请求分别发给 Peer1、Peer2 和 Peer3，然后三个 Peer 接收到交易请求后执行对应的智能合约并对结果进行签名然后分别将输出结果返回给 client，client 收到所有执行结果后打包一并发送到 Orderer，Orderer 将接收到的该次交易在交易池里进行排序并组合打包生成一个新的区块，Orderer 将新的区块发送给所有的 Peer 节点，每个 Peer 节点接收到新区块后，对其中的每一笔交易结果的签名进行验证是否符合背书策略，以及比对读写集合（Read-Write Set，在下面的章节中解释）与本地的版本是否相同，如满足所有条件则将新的区块写入本地账本内完成交易。 以上是相对粗略的描述了交易流程，而实际当中还有很多细节的处理。除此外可能有人会问，共识节点去哪了？为什么有 Orderer 这样的中心节点？如果再细细思考一下，你会发现共识机制已经融合在整个交易流程中了，这也是这个设计优越的所在，我们来分析一下，假设 Orderer 节点是恶意节点，是否能控制交易生成” 假账 “呢？那么再来看一下 Orderer 的功能，接收交易数据进行排序并打包成块，假设 Orderer 要造假数据，那么他需要绕过的是每个 Peer 节点将数据写入前进行的背书策略的校验，那么数据里就必须包含背书策略里要求的节点签名，而 Orderer 是没有办法获取到各 Peer 节点的私钥也就没办法生成对应的签名，由此 Orderer 是没办法控制交易链造假的，可以说 Orderer 是一个工具服务并不参与到任何业务流程内，其关心的只是服务的稳定性，如果需要数据对 Orderer 节点保密，目前需要自行实现数据加密。正因为其背书策略的设定，可以精确地满足的具体的业务场景需求不会受到任何形式的恶意节点入侵，这也是区别于 POW 或者拜占庭容错等，他们在一定条件后是可能被恶意节点所操控的。 核心基础服务 对 Fabric 的主体模块及流程有一定认识后，我们在继续深究里面的细节功能，为了让整个框架能运作起来当然需要用到更多的技术手段，这里主要讲几个相对核心的功能点。 Gossip Protocol 回顾上述的交易流程图中，Orderer 将交易数据排序打包后分发给各个 Peer 节点，若假设有成百上千甚至更多的 Peer 节点都由 Orderer 节点进行分发那么首先单点的压力是否能承受，其次如果出现失败的情况又该如何同步等问题。在 Fabric 的实现当中，采用的是让 Peer 节点之间相互同步而非 Orderer 节点来分发消息，每个 Peer 节点都会维护其他 Peer 节点的信息，随机的与部分其他 Peer 节点进行通信互换区块信息，传输时利用 Peer-to-Peer 的技术去加快数据的传输，而 Orderer 节点仅是将打包好的区块发送至特定的 Leader Peer（可手动指定也可由 Orderer 自行选取），然后 Peer 节点之间在通过 Gossip 协议相互交换数据达到最终一致性。 Eventhub 那么根据上面描述的 Gossip 协议，可见每个 Peer 节点写入区块的时间可能是不一致的，那么 client 端进行业务逻辑判断（如事务逻辑）如何获知特定交易数据是否已经写入 Peer 节点内呢？实际上每个 Peer 都会和 client 端保持一个 Eventhub 的连接，在 Peer 节点完成交易后，如将区块写入账本后便会发送消息通知各个 client，但是也要注意，回调总是不可信的，存在消息丢失的可能性，Fabric 也并没有保证消息的最终到达。 Read-Write Set 在 Peer 节点将一个区块写入账本前，如上所述会进行背书策略的校验，以防止恶意节点的入侵，达到有权重划分，可实名制交易的联盟链。除去验证各节点签名验证，当然还要比对个节点输出的结果是否一致，那如何去衡量结果是否一致呢？这里提出了读写集合的概念，一段程序我们化做为 IO，如果使用相同 Input 得出一致的 Output，那么我们便可以认同在这一特定情况下函数性质是相同的。在这里我们并不关心 Input，只要写入 / 修改的数据一致便可认为达成了共识，所以 Write Set 是用于保存最终需要写入 / 修改的数据集，这个是用来比对各节点的结果集是否一致，而 Read Set 中存着各节点执行合约中读取了哪些数据，并会把这个数据的当前版本记录在 Read Set 中，在 Peer 节点写入区块前也会校验 Read Set 中读取的数据版本是否和当前数据环境中的版本一致，以防止交易并发带来的错乱。 认证体系 刚接触区块链的同学可能会有一个概念，区块链应该保证公平公正公开，所以形成了 “公有链” 的一个概念，例如比特币，全员可参与，对所有人透明。但是区块链并不仅局限于 “公有链”，对于大多数业务场景来说，应该属于“联盟链”，即由特定成员参与、有权重分配的业务，例如银行间的对账环节，A、B、C 银行互相的交易中，A、B 银行间的交易当然不愿意透露给 C 银行，而 A、B、C 银行的所有交易或许都要上报给央行，可见此处“公有链” 是不可取的。那如何去保证公平公正公开呢？首先代码必须对成员开源，所有服务可由自身搭建，利益相关成员共同审核“智能合约”，全员共识的背书策略，相互授权或由可信第三方认证中心授权。那么最基础的一道认证体系便显得尤为重要了，我们在来看看 Fabric 是如何去实现他的认证体系的。 首先有几个概念需要明确，Fabric 的 CA 认证中心是基于 PKI 体系打造的，相关资料可参考如下。 PKI(Public Key Infrastructure) X.509 证书 Membership Service Providers(MSP) 在划分成员结构的时候 Fabric 用 MSP 来定义一个成员，在最佳实例推荐中，一个企业或者机构可以是一个单独的 MSP，例如上述说到的供应链的案例，由例图来说明，核心企业便是一个 MSP，银行和供应商各代表一个 MSP，那么在一个 MSP 下可以有多个 Peer 节点，而不同的授权便有不同的功能，MSP 具体应用场景主要如下。 在部署智能合约或者初始化时需要拥有对应 CA 赋权的证书才可执行（默认为 PeerAdmin 用户）。 为新节点或用户注册证书时，需要 CA 对该操作证书赋予权限（一般为 Admin 用户）。 在背书策略中可通过 MSP 来代表背书成员，可设定单个 Peer 节点代表其 MSP 达成协议（也可以要求全部 Peer 节点通过才达成协议）。 在跨 MSP 间的 Peer 节点通信，先通过各 MSP 内指定的 Anchor Peer 收集 MSP 内的 Peer 列表，然后通过各 MSP 下的 Anchor Peer 交互其 Peer 列表，将其他 MSP 下的 Peer 列表同步到内部 Peer 后，便通过 Gossip 协议 Peer 节点间随机通信。 每个 MSP 都有自己独立的 CA 节点，为其提供所有的证书需求，各 MSP 共享其 CA 节点的 ROOT 证书达到互相认证。 匿名交易。在一笔交易中，包含着每一个参与背书的用户证书，这可以认为是公开实名制的交易，所有链内成员都可以看见每一笔交易是由谁参与的，但是如果我们希望匿名交易该如何实现呢？在 Fabric 0.6 版本内有 Ecert 和 Tcert 的概念，Ecert 即为用户的证书，而 Tcert 则是用于匿名交易，用户可以通过向 CA 申请一批 Tcert 用于交易，而该 Tcert 不包含用户的信息，当需要验证查验信息时可通过 CA 来认证该用户的身份。（此功能在 1.0 版本尚未实现） Revoke，废除证书。在 PKI 体系中，其最大的优势便是 Off line 的，即在证书颁发后，不需要 CA 节点的存在也可以在本地进行认证，而遇到很大的问题是类似于废除证书时如果希望能即是将废除证书的消息通知到各个节点，目前的做法是需要 CA 节点保持在线并与各节点保持通信。（获取 Tcert 也需要 CA 节点在线） 在每个区块链中其相关的配置信息也包含了 MSP 的划分，阐述相对复杂这里便不描述，有兴趣可以参考官方文档 ：） 难点及待解决的问题 上述篇幅主要是给读者对 Fabric 的整体框架有基本的认识，仍有许多细微的问题无法一一讨论。当然，在区块链尚未大规模能应用于市场下其技术也是不完善的，在 Fabric 中也有许多需要解决的难点问题。 在官方推荐的实践当中，划分数据的隔离是通过账本的粒度进行隔离，不关联的交易便在不同的账本中了，但是实际业务当中，总有需要在单账本内进行数据隔离的场景，早前已经看到有相关的设计文档出稿了，不过距离正式发布该功能就不确定合适能完成了，目前只能自行在业务逻辑中对数据进行加密隔离。 当两个数据通过账本隔离后需要交互的场景目前来看是比较难实现的，及跨账本调用，首要解决的问题便是认证模型如何去进行融合。 目前想要接入区块链的成本仍然是很高的，即便 Fabric 项目大部分功能都无法通过可视化的配置，需要了解更多的底层细节才能正确搭建环境及配置。 引用 https://hyperledger-fabric.readthedocs.io/en/release/ https://github.com/hyperledger/fabric https://www.ibm.com/blockchain/hyperledger.html 原文：如何用区块链技术解决信任问题？Fabric 架构深度解读http://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247487205&amp;idx=1&amp;sn=64231eeb18feaca84d8b1a16496f01b8&amp;chksm=e92933eade5ebafc6f3cdf345dc1ce607ea1c4d4ffc579e6735821e2bed016ba03d818ce5446&amp;mpshare=1&amp;scene=1&amp;srcid=0418Qu3SeKn98SXOHInSFBS8%23rd]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18%2F</url>
    <content type="text"><![CDATA[注解是什么？注解（Annotation），也叫元数据。一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 简单来说注解其实就是代码中的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相对应的处理。 JDK 内置了哪些注解？ OverriedOverried 是告诉编译器要检查该方法是实现父类的方法。 DeprecatedDeprecated 用于标记一些过时的代码。 SuppressWarningsSuppressWarnings 用于消除一些警告信息，使用集合的时候，如果没有指定泛型，IDE 会提示安全检查的警告。 FunctionalInterfaceFunctionalInterface 是 JDK8 中的注解，用来指定该接口是函数式接口。 SafeVarargsSafeVarargs 是 JDK 7 中的注解，主要目的是处理可变长参数中的泛型，此注解告诉编译器：在可变长参数中的泛型是类型安全的。 怎么自定义一个注解？在 Java 中，类使用 class 定义，接口使用 interface 定义，注解和接口的定义差不多，增加了一个 @符号，即 @interface，代码如下： 1public @interface EnableAuth &#123;&#125; 注解中可以定义成员变量，用于信息的描述，跟接口中方法的定义类似，代码如下： 1public @interface EnableAuth &#123; String name();&#125; 还可以添加默认值： 1public @interface EnableAuth &#123; String name() default "猿天地";&#125; 上面的介绍只是完成了自定义注解的第一步，开发中日常使用注解大部分是用在类上，方法上，字段上，示列代码如下： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface EnableAuth &#123;&#125; Target用于指定被修饰的注解修饰哪些程序单元，也就是上面说的类，方法，字段 Retention用于指定被修饰的注解被保留多长时间，分别 SOURCE（注解仅存在于源码中，在 class 字节码文件中不包含）,CLASS（默认的保留策略，注解会在 class 字节码文件中存在，但运行时无法获取）,RUNTIME（注解会在 class 字节码文件中存在，在运行时可以通过反射获取到）三种类型，如果想要在程序运行过程中通过反射来获取注解的信息需要将 Retention 设置为 RUNTIME Documented用于指定被修饰的注解类将被 javadoc 工具提取成文档 Inherited用于指定被修饰的注解类将具有继承性 如何获取注解中的值？可以通过反射来判断类，方法，字段上是否有某个注解以及获取注解中的值, 获取某个类中方法上的注解代码示例如下： 1234567Class&lt;?&gt; clz = bean.getClass();Method[] methods = clz.getMethods();for (Method method : methods) &#123; if (method.isAnnotationPresent(EnableAuth.class)) &#123; String name = method.getAnnotation(EnableAuth.class).name(); &#125;&#125; 通过 isAnnotationPresent 判断是否存在某个注解，通过 getAnnotation 获取注解对象，然后获取值 工作中经常接触的注解有哪些？注解在很多框架中都应用非常多，这个问题你可以说下 Spring 中的即可，大概的解释下每个注解的含义和用途，除了 Spring 还有很多别的框架中也有使用注解，比如 Swagger, Lombok，JPA，Spring Data 等 Component Controller Repository Service RequestMapping RequestParam RequestAttribute RequestBody ResponseBody …… 注解的使用场景？ 生成文档Swagger 中就是通过注解对接口，实体类中的字段进行描述生成可视化的文档 代替配置文件Spring 中 Bean 的装载注入 导出数据可以写一个统一的导出工具类，传入一个 List &lt;实体类&gt; 进去即可导出 Excel 文件，Excel 的表头可以用注解加载字段上 框架层面的统一处理注解在底层框架中用的比较多，在框架中需要考虑到通用性，能用注解做很多事情，比如对 API 进行权限控制，限流等操作都可以通过自定义注解来标识是否需要进行认证，限流等，还有数据的缓存，典型的就是 @Cacheable, 还有异步方法的调用 @Async，ORM 框架中的使用，可以用注解标识表名，字段名，JPA 中，Spring Data 框架中都有使用 权限控制详细讲解比如我们有的接口需要认证才能调用，有的不需要，简单的做法就是用配置的方式，将需要认证的接口配置好，然后进行拦截过滤，缺点是需要经常维护配置信息，用注解可以避免这个情况。可以自定义一个注解，只要加了这个注解我们就对这个接口进行认证拦截操作，接下里详细的讲解下这个功能实现。 定义开启认证的注解，作用在方法上，运行时可获取注解信息 12345/** * 开启API权限认证 * @author yinjihuan * */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface EnableAuth &#123;&#125; 在需要认证的接口上增加注解 1234567891011121314151617181920@EnableAuth@GetMapping("/userCollectCityInfo")@ApiOperation(value="获取登录用户关注的城市信息", notes="获取登录用户关注的城市信息", produces = "application/json")@ApiResponses( @ApiResponse(response = UserCollectCityInfoDto.class, code = 200, message = ""))public Response getUserCollectCityInfos(HttpServletRequest request) &#123; try &#123; Long uid = UserInfoUtils.getLoginUserId(request); List&lt;CityCollect&gt; citys =cityCollectService.findAllByUid(uid); List&lt;UserCollectCityInfoDto&gt; results = citys.stream().map(this::ofCityInfo).sorted((l1, l2) -&gt; l1.getRangeLevel().compareTo(l2.getRangeLevel())) .collect(Collectors.toList()); return Response.ok(results); &#125; catch (Exception e) &#123; logger.error("获取登录用户关注的城市信息异常", e); return Response.fail("获取登录用户关注的城市信息异常" ); &#125;&#125; 在拦截器中进行拦截，拦截需要知道当前请求的接口是不是需要拦截的，我们可以在启动时将所有增加了 @EnableAuth 的接口信息保存起来，这样在拦截器中就知道哪个接口是需要认证。 初始化需要认证的接口信息代码如下： 1234567891011121314151617181920212223242526/** * API 验证数据初始化 * @author yinjihuan * */@Component@Configurationpublic class ApiAuthDataInit implements ApplicationContextAware &#123; public static List&lt;String&gt; checkApis = new ArrayList&lt;String&gt;(); @Override public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123; Map&lt;String, Object&gt; beanMap = ctx.getBeansWithAnnotation(RestController.class); if (beanMap != null) &#123; for (Object bean : beanMap.values()) &#123; Class&lt;?&gt; clz = bean.getClass(); Method[] methods = clz.getMethods(); for (Method method : methods) &#123; if (method.isAnnotationPresent(EnableAuth.class)) &#123; String uri = getApiUri(clz, method); checkApis.add(uri); &#125; &#125; &#125; &#125; &#125; private String getApiUri(Class&lt;?&gt; clz, Method method) &#123; StringBuilder uri = new StringBuilder(); uri.append(clz.getAnnotation(RequestMapping.class).value()[0]); if (method.isAnnotationPresent(GetMapping.class)) &#123; uri.append(method.getAnnotation(GetMapping.class).value()[0]); &#125; else if (method.isAnnotationPresent(PostMapping.class)) &#123; uri.append(method.getAnnotation(PostMapping.class).value()[0]); &#125; else if (method.isAnnotationPresent(RequestMapping.class)) &#123; uri.append(method.getAnnotation(RequestMapping.class).value()[0]); &#125; return uri.toString(); &#125;&#125; 实现 ApplicationContextAware 接口，然后通过 getBeansWithAnnotation 获取所有接口的 bean 信息，通过 RestController 注解来获取，也就是说只要 class 上增加了 RestController 注解，这边就都能获取到。 然后通过反射获取 bean 中所有的方法，如果有增加 EnableAuth 的话就获取接口的 uri 存储到 map 中，这样过滤器中就可以根据 map 中的值来判断是不是需要进行权限认证了。 原文：http://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&amp;mid=2650319298&amp;idx=1&amp;sn=674ad268a974e9737b063eb06b46782f&amp;chksm=8ef5fdb6b98274a0724ff195260554604886070e427d55e4bdcb6c3c9ed85e49ba4e7f3fb1f1&amp;mpshare=1&amp;scene=1&amp;srcid=0417Q7hARGlsYLuhyCZ2Xpr2%23rd]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring框架实现远程服务暴露与调用]]></title>
    <url>%2F2018%2F04%2F16%2F2018-04-16-1%2F</url>
    <content type="text"><![CDATA[这里要结合《spring技术内幕》进一步研究 一、前言 Spring 框架提供了通过 HTTP 协议实现远程调用的方式，具体是调用方使用 HttpInvokerProxyFactoryBean 生成一个代理对象，通过代理对象远程通过 http 服务调用服务提供方法的服务并，服务提供方通过 HttpInvokerServiceExporter 在服务端暴漏远程调用接口。 二、远程服务暴露 2.1 简单使用 第一步需要定义需要暴露的服务接口和实现 12345public interface UserServiceBo &#123; String sayHello(String name); String sayHello2(String name); String testPojo(Person person);&#125; 1234567891011121314public class UserServiceImpl implements UserServiceBo&#123; @Override public String sayHello(String name) &#123; return name; &#125; @Override public String sayHello2(String name) &#123; return name; &#125; @Override public String testPojo(Person person) &#123; return JSON.toJSONString(person); &#125; &#125; 第二步创建服务导出 HttpInvokerServiceExporter 的实例 1&lt;bean id="userService" class="com.test.UserServiceImpl" /&gt; 1234&lt;bean &gt; &lt;property /&gt; &lt;property /&gt;&lt;/bean&gt; 第三步 暴露远程服务的 URL 123456789&lt;bean id="simpleUrlRequestHandler" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property /&gt; &lt;property &gt; &lt;map&gt; &lt;entry key="/remote/test/userService" value-ref="useServiceExporter" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 注意这个 bean 要配置到 dispatcher 类的配置文件里面。 2.2 原理 三、远程服务调用 3.1 简单使用 1234567HttpInvokerProxyFactoryBean factoryBean = new HttpInvokerProxyFactoryBean(); factoryBean.setServiceUrl("http://127.0.0.1:7001/test/userService.do"); factoryBean.setServiceInterface(UserServiceBo.class); factoryBean.afterPropertiesSet(); UserServiceBo userService = (UserServiceBo) factoryBean.getObject(); System.out.println(userService.sayHello("jiaduo")); 3.2 原理 四、总结 Spring 框架提供了通过 HTTP 协议实现远程调用的方式，我们可以通过重写 invoker 自定义 http 请求 header 和 body 传递一些信息到服务暴露端，比如函数签名指，序列化协议等。 通过重写 exporter 可以进行鉴权操作，比如进行函数签名校验，然后可以定制反序列化方式。 (全文完) 使用Spring框架实现远程服务暴露与调用http://mp.weixin.qq.com/s?__biz=MjM5NzQ3ODAwMQ==&amp;mid=2686978705&amp;idx=1&amp;sn=ac0933225582fbd939d98caf1cee4c47&amp;chksm=8305c18fb472489903feb0fdb5de50650feedfe332b91e55c540495d2c6bf4468ecb0dca83db&amp;mpshare=1&amp;scene=1&amp;srcid=0416SpTp7aFRVK77JHtTDPhz%23rd《Spring技术内幕》学习笔记17——Spring HTTP调用器实现远程调用 - CSDN博客https://blog.csdn.net/chjttony/article/details/6553693]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>待阅</tag>
        <tag>远程服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据系统构建： 笔记]]></title>
    <url>%2F2018%2F04%2F16%2F2018-04-16%2F</url>
    <content type="text"><![CDATA[专栏：分布式系统构建手册 - CSDN博客https://blog.csdn.net/column/details/mds-history.html科学网—Big Data: Principles and best practices of scalable realtime - 唐李洋的博文http://blog.sciencenet.cn/blog-425672-528502.html]]></content>
      <tags>
        <tag>架构</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raft协议:分布式一致性算法]]></title>
    <url>%2F2018%2F04%2F15%2F2018-04-15-1%2F</url>
    <content type="text"><![CDATA[很久之前研究过 raft 协议，最近项目中一直没有使用，有些生疏了，这次重温了一下 raft，花了两天的时间，就顺便做下笔记。 一致性问题在分布式系统中, 一致性问题 (consensus problem) 是指对于一组服务器，给定一组操作，我们需要一个协议使得最后它们的结果达成一致。 由于 CAP 理论告诉我们对于分布式系统，如果不想牺牲一致性，我们就只能放弃可用性，所以，数据一致性模型主要有以下几种：强一致性、弱一致性和最终一致性等，在本篇章中，我们主要讨论的算法 Raft，是一种分布式系统中的强一致性的实现算法。 强一致性的一般实现的原理：当其中某个服务器收到客户端的一组指令时, 它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令, 这样的话所有的服务器会产生一致的结果, 看起来就像是一台机器一样. Raft 算法描述在 Raft 被提出来之前，Paxos 协议是第一个被证明的一致性算法，但是 Paxos 的论文非常难懂，导致基于 Paxos 的工程实践和教学都十分头疼，于是 Raft 在设计的过程中，就从可理解性出发，使用算法分解和减少状态等手段，目前已经应用非常广泛。 在 Raft 中，问题分解为：领导选取、日志复制、安全和成员变化。 基本概念复制状态机（Replicated State Machine） 复制状态机通过复制日志来实现： 日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令 状态机：状态机会按顺序执行这些命令 一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的 一致性算法作用于一致性模型，一般有以下特性： safety：在非拜占庭问题下（网络延时，网络分区，丢包，重复发包以及包乱序等），结果是正确的 availability：在半数以上机器能正常工作时，则系统可用 timing-unindependent：不依赖于时钟来保证日志一致性，错误的时钟以及极端的消息时延最多会造成可用性问题 注意：真实的实现中，建议状态机的每个命令操作都采用幂等的，这样一致性的保证会更容易。 服务器状态每台服务器一定会处于三种状态： 领导者 候选人 追随者 追随者只响应其他服务器的请求。如果追随者没有收到任何消息，它会成为一个候选人并且开始一次选举。收到大多数服务器投票的候选人会成为新的领导人。领导人在它们宕机之前会一直保持领导人的状态。 任期 (Term)Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。 RPCRaft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起，然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制。为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。RPC 有三种： RequestVote RPC：候选人在选举期间发起 AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成 InstallSnapshot RPC: 领导者使用该 RPC 来发送快照给太落后的追随者。 超时设置： BroadcastTime : 领导者的心跳超时时间 Election Timeout: 追随者设置的候选超时时间 MTBT : 指的是单个服务器发生故障的间隔时间的平均数 BroadcastTime &lt;&lt; ElectionTimeout &lt;&lt; MTBF两个原则： BroadcastTime 应该比 ElectionTimeout 小一个数量级，为的是使领导人能够持续发送心跳信息（heartbeat）来阻止追随者们开始选举； ElectionTimeout 也要比 MTBF 小几个数量级，为的是使得系统稳定运行。 一般 BroadcastTime 大约为 0.5 毫秒到 20 毫秒，ElectionTimeout 一般在 10ms 到 500ms 之间。大多数服务器的 MTBF 都在几个月甚至更长。 领导人选取 触发条件： 一般情况下，追随者接到领导者的心跳时，把 ElectionTimeout 清零，不会触发； 领导者故障，追随者的 ElectionTimeout 超时发生时，会变成候选者，触发领导人选取； 候选操作过程： 追随者自增当前任期，转换为 Candidate，对自己投票，并发起 RequestVote RPC，等待下面三种情形发生； 获得超过半数服务器的投票，赢得选举，成为领导者； 另一台服务器赢得选举，并接收到对应的心跳，成为追随者； 选举超时，没有任何一台服务器赢得选举，自增当前任期，重新发起选举； 注意事项： 服务器在一个任期内，最多能给一个候选人投票，采用先到先服务原则； 候选者等待投票时，可能会接收到来自其它声明为领导人的的 AppendEntries RPC。如果该领导人的任期（RPC 中有）比当前候选人的当前任期要大，则候选人认为该领导人合法，并转换成追随者；如果 RPC 中的任期小于候选人的当前任期，则候选人拒绝此次 RPC，继续保持候选人状态； 候选人既没有赢得选举也没有输掉选举：如果许多追随者在同一时刻都成为了候选人，选票会被分散，可能没有候选人能获得大多数的选票。当这种情形发生时，每一个候选人都会超时，并且通过自增任期号和发起另一轮 RequestVote RPC 来开始新的选举。然而，如果没有其它手段来分配选票的话，这种情形可能会无限的重复下去。所以 Raft 使用的随机的选举超时时间（150~300ms 之间），来避免这种情况发生。 问题探讨：为什么这里没有谈收到其他候选者的 RequestVote RPC 请求？可能的解释： 候选者已经给自己投票了，一个候选者在一个任期只会给一个人投票，不会给其他人再投票了； 也有可能算法本身设定候选者就拒绝所有的其他服务器的请求。 日志复制 接受命令的过程： 领导者接受客户端请求； 领导者把指令追加到日志； 发送 AppendEntries RPC 到追随者； 领导者收到大多数追随者的确认后，领导者 Commit 该日志，把日志在状态机中回放，并返回结果给客户端； 提交过程： 在下一个心跳阶段，领导者再次发送 AppendEntries RPC 给追随者，日志已经 commited； 追随者收到 Commited 日志后，将日志在状态机中回放。 安全性到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令，例如：一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。 1. 领导者追加日志（Append-Only)领导者永远不会覆盖已经存在的日志条目；日志永远只有一个流向：从领导者到追随者； 2. 选举限制：投票阻止没有全部日志条目的服务器赢得选举如果投票者的日志比候选人的新，拒绝投票请求；这意味着要赢得选举，候选者的日志至少和大多数服务器的日志一样新，那么它一定包含全部的已经提交的日志条目。 3. 永远不提交任期之前的日志条目（只提交任期内的日志条目）在 Raft 算法中，当一个日志被安全的复制到绝大多数的机器上面，即 AppendEntries RPC 在绝大多数服务器正确返回了，那么这个日志就是被提交了，然后领导者会更新 commit index。 如果允许提交任期之前的日志条目，那么在步骤 c 中，我们就会把之前任期为 2 的日志提交到其他服务器中去，并造成了大多数机器存在了日志为 2 的情况。所以造成了 d 中 S5 中任期为 3 的日志条目会覆盖掉已经提交的日志的情况。 Raft 从来不会通过计算复制的数目来提交之前人气的日志条目。只有领导人当前任期的日志条目才能通过计算数目来进行提交。一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配原则（Log Matching Property），之前的日志条目也都会被间接的提交。 论文中的这段话比较难理解，更加直观的说：由于 Raft 不会提交任期之前的日志条目，那么就不会从 b 过渡到 c 的情况，只能从 b 发生 S5down 机的情况下直接过渡到 e，这样就产生的更新的任期，这样 S5 就没有机会被选为领导者了。 4. 候选者和追随者崩溃候选者和追随者崩溃的情况处理要简单的多。如果这类角色崩溃了，那么后续发送给他们的 RequestVote 和 AppendEntries 的所有 RCP 都会失败，Raft 算法中处理这类失败就是简单的无限重试的方式。 如果这些服务器重新可用，那么这些 RPC 就会成功返回。如果一个服务器完成了一个 RPC，但是在响应 Leader 前崩溃了，那么当他再次可用的时候还会收到相同的 RPC 请求，此时接收服务器负责检查，比如如果收到了已经包含该条日志的 RPC 请求，可以直接忽略这个请求，确保对系统是无害的。 集群成员变更集群成员的变更和成员的宕机与重启不同，因为前者会修改成员个数进而影响到领导者的选取和决议过程，因为在分布式系统这对于 majority 这个集群中成员大多数的概念是极为重要的。 简单的做法是，运维人员将系统临时下线，修改配置，重新上线。但是这种做法存在两个缺点： 更改时集群不可用 人为操作失误风险 直接从一种配置转到新的配置是十分不安全的如下图所示： 因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。 两阶段方法保证安全性：为了保证安全性，配置更改必须使用两阶段方法。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合。 共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程人依然响应服务器请求。 一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定。领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。当 C-old,new 日志条目被提交以后，领导人在使用相同的策略提交 C-new，如下图所示，C-old 和 C-new 没有任何机会同时做出单方面的决定，这就保证了安全性。 一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的条目，实线表示最后被提交的日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old,new 的大多数和 C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在 C-new 和 C-old 可以同时做出决定的时间点。 日志压缩日志会随着系统的不断运行会无限制的增长，这会给存储带来压力，几乎所有的分布式系统 (Chubby、ZooKeeper) 都采用快照的方式进行日志压缩，做完快照之后快照会在稳定持久存储中保存，而快照之前的日志和快照就可以丢弃掉。 Raft 的具体做法如下图所示： 与 Raft 其它操作 Leader-Based 不同，snapshot 是由各个节点独立生成的。除了日志压缩这一个作用之外，snapshot 还可以用于同步状态：slow-follower 以及 new-server，Raft 使用 InstallSnapshot RPC 完成该过程，不再赘述。 Client 交互 Client 只向领导者发送请求； Client 开始会向追随者发送请求，追随者拒绝 Client 的请求，并重定向到领导者； Client 请求失败，会超时重新发送请求； Raft 算法要求 Client 的请求线性化，防止请求被多次执行。有两个解决方案： Raft 算法提出要求每个请求有个唯一标识； Raft 的请求保持幂等性； 参考：Raft协议详解https://zhuanlan.zhihu.com/p/27207160Raft一致性算法笔记 - 简书https://www.jianshu.com/p/096ae57d1fe0raft-zh_cn/raft-zh_cn.md at master · maemual/raft-zh_cnhttps://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>协议</tag>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 缓存机制&源码分析]]></title>
    <url>%2F2018%2F04%2F15%2F2018-04-15%2F</url>
    <content type="text"><![CDATA[前言MyBatis 是常见的 Java 数据库访问层框架。在日常工作中，开发人员多数情况下是使用 MyBatis 的默认缓存配置，但是 MyBatis 缓存机制有一些不足之处，在使用中容易引起脏数据，形成一些潜在的隐患。 个人在业务开发中也处理过一些由于 MyBatis 缓存引发的开发问题，带着个人的兴趣，希望从应用及源码的角度为读者梳理 MyBatis 缓存机制。 本次分析中涉及到的代码和数据库表均放在 GitHub 上，地址： mybatis-cache-demo 。 目录本文按照以下顺序展开。 一级缓存介绍及相关配置。 一级缓存工作流程及源码分析。 一级缓存总结。 二级缓存介绍及相关配置。 二级缓存源码分析。 二级缓存总结。 全文总结。 一级缓存一级缓存介绍在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的 SQL，MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的 SQL 语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。具体执行过程如下图所示。 每个 SqlSession 中持有了 Executor，每个 Executor 中有一个 LocalCache。当用户发起查询时，MyBatis 根据当前执行的语句生成 MappedStatement，在 Local Cache 进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入 Local Cache，最后返回结果给用户。具体实现类的类关系图如下图所示。 一级缓存配置我们来看看如何使用 MyBatis 一级缓存。开发者只需在 MyBatis 的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，SESSION 或者 STATEMENT，默认是 SESSION 级别，即在一个 MyBatis 会话中执行的所有语句，都会共享这一个缓存。一种是 STATEMENT 级别，可以理解为缓存只对当前执行的这一个 Statement 有效。 1&lt;setting /&gt; 一级缓存实验接下来通过实验，了解 MyBatis 一级缓存的效果，每个单元测试后都请恢复被修改的数据。 首先是创建示例表 student，创建对应的 POJO 类和增改的方法，具体可以在 entity 包和 mapper 包中查看。 123CREATE TABLE `student` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(200) COLLATE utf8_bin DEFAULT NULL, `age` tinyint(3) unsigned DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_bin; 在以下实验中，id 为 1 的学生名称是凯伦。 实验 1开启一级缓存，范围为会话级别，调用三次 getStudentById，代码如下所示： 1234567public void getStudentById() throws Exception &#123; SqlSession sqlSession = factory.openSession(true); // 自动提交事务 StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); System.out.println(studentMapper.getStudentById(1)); System.out.println(studentMapper.getStudentById(1)); System.out.println(studentMapper.getStudentById(1)); &#125; 执行结果： 我们可以看到，只有第一次真正查询了数据库，后续的查询使用了一级缓存。 实验 2增加了对数据库的修改操作，验证在一次数据库会话中，如果对数据库发生了修改操作，一级缓存是否会失效。 123456789@Testpublic void addStudent() throws Exception &#123; SqlSession sqlSession = factory.openSession(true); // 自动提交事务 StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class); System.out.println(studentMapper.getStudentById(1)); System.out.println("增加了" + studentMapper.addStudent(buildStudent()) + "个学生"); System.out.println(studentMapper.getStudentById(1)); sqlSession.close();&#125; 执行结果： 我们可以看到，在修改操作后执行的相同查询，查询了数据库，一级缓存失效。 实验 3开启两个 SqlSession，在 sqlSession1 中查询数据，使一级缓存生效，在 sqlSession2 中更新数据库，验证一级缓存只在数据库会话内部共享。 1234567891011121314@Testpublic void testLocalCacheScope() throws Exception &#123; SqlSession sqlSession1 = factory.openSession(true); SqlSession sqlSession2 = factory.openSession(true); StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class); StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);h System.out.println("studentMapper读取数据: " + studentMapper.getStudentById(1)); System.out.println("studentMapper读取数据: " + studentMapper.getStudentById(1)); System.out.println("studentMapper2更新了" + studentMapper2.updateStudentName("小岑",1) + "个学生的数据"); System.out.println("studentMapper读取数据: " + studentMapper.getStudentById(1)); System.out.println("studentMapper2读取数据: " + studentMapper2.getStudentById(1));&#125; sqlSession2 更新了 id 为 1 的学生的姓名，从凯伦改为了小岑，但 session1 之后的查询中，id 为 1 的学生的名字还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部共享。 一级缓存工作流程 &amp; 源码分析那么，一级缓存的工作流程是怎样的呢？我们从源码层面来学习一下。 工作流程一级缓存执行的时序图，如下图所示。 源码分析接下来将对 MyBatis 查询相关的核心类和一级缓存的源码进行走读。这对后面学习二级缓存也有帮助。 SqlSession： 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是 DefaultSqlSession。 Executor： SqlSession 向用户提供操作数据库的方法，但和数据库操作有关的 职责都会委托给 Executor。 如下图所示，Executor 有若干个实现类，为 Executor 赋予了不同的能力，大家可以根据类名，自行学习每个类的基本作用。 在一级缓存的源码分析中，主要学习 BaseExecutor 的内部实现。 BaseExecutor： BaseExecutor 是一个实现了 Executor 接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。 12345protected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException;protected abstract List&lt;BatchResult&gt; doFlushStatements(boolean isRollback) throws SQLException;protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException;protected abstract &lt;E&gt; Cursor&lt;E&gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException; 在一级缓存的介绍中提到对 Local Cache 的查询和写入是在 Executor 内部完成的。在阅读 BaseExecutor 的代码后发现 Local Cache 是 BaseExecutor 内部的一个成员变量，如下代码所示。 12public abstract class BaseExecutor implements Executor &#123;protected ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;protected PerpetualCache localCache; Cache： MyBatis 中的 Cache 接口，提供了和缓存相关的最基本的操作，如下图所示。 有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示。 BaseExecutor 成员变量之一的 PerpetualCache，是对 Cache 接口最基本的实现，其实现非常简单，内部持有 HashMap，对一级缓存的操作实则是对 HashMap 的操作。如下代码所示。 123public class PerpetualCache implements Cache &#123; private String id; private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); 在阅读相关核心类代码后，从源代码层面对一级缓存工作中涉及到的相关代码，出于篇幅的考虑，对源码做适当删减，读者朋友可以结合本文，后续进行更详细的学习。 为执行和数据库的交互，首先需要初始化 SqlSession，通过 DefaultSqlSessionFactory 开启 SqlSession： 12345private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; ............ final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit);&#125; 在初始化 SqlSesion 时，会使用 Configuration 类创建一个全新的 Executor，作为 DefaultSqlSession 构造函数的参数，创建 Executor 代码如下所示： 12345678910111213141516public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123; executorType = executorType == null ? defaultExecutorType : executorType; executorType = executorType == null ? ExecutorType.SIMPLE : executorType; Executor executor; if (ExecutorType.BATCH == executorType) &#123; executor = new BatchExecutor(this, transaction); &#125; else if (ExecutorType.REUSE == executorType) &#123; executor = new ReuseExecutor(this, transaction); &#125; else &#123; executor = new SimpleExecutor(this, transaction); &#125; // 尤其可以注意这里，如果二级缓存开关开启的话，是使用CahingExecutor装饰BaseExecutor的子类 if (cacheEnabled) &#123; executor = new CachingExecutor(executor); &#125; executor = (Executor) interceptorChain.pluginAll(executor); return executor;&#125; SqlSession 创建完毕后，根据 Statment 的不同类型，会进入 SqlSession 的不同方法中，如果是 Select 语句的话，最后会执行到 SqlSession 的 selectList，代码如下所示： 123@Overridepublic &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; MappedStatement ms = configuration.getMappedStatement(statement); return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);&#125; SqlSession 把具体的查询职责委托给了 Executor。如果只开启了一级缓存的话，首先会进入 BaseExecutor 的 query 方法。代码如下所示： 1234@Overridepublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; BoundSql boundSql = ms.getBoundSql(parameter); CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); return query(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125; 在上述代码中，会先根据传入的参数生成 CacheKey，进入该方法查看 CacheKey 是如何生成的，代码如下所示： 12345CacheKey cacheKey = new CacheKey();cacheKey.update(ms.getId());cacheKey.update(rowBounds.getOffset());cacheKey.update(rowBounds.getLimit());cacheKey.update(boundSql.getSql());//后面是update了sql中带的参数cacheKey.update(value); 在上述的代码中，将 MappedStatement 的 Id、sql 的 offset、Sql 的 limit、Sql 本身以及 Sql 中的参数传入了 CacheKey 这个类，最终构成 CacheKey。以下是这个类的内部结构： 123456private static final int DEFAULT_MULTIPLYER = 37;private static final int DEFAULT_HASHCODE = 17;private int multiplier;private int hashcode;private long checksum;private int count;private List&lt;Object&gt; updateList;public CacheKey() &#123; this.hashcode = DEFAULT_HASHCODE; this.multiplier = DEFAULT_MULTIPLYER; this.count = 0; this.updateList = new ArrayList&lt;Object&gt;();&#125; 首先是成员变量和构造函数，有一个初始的 hachcode 和乘数，同时维护了一个内部的 updatelist。在 CacheKey 的 update 方法中，会进行一个 hashcode 和 checksum 的计算，同时把传入的参数添加进 updatelist 中。如下代码所示。 12345678public void update(Object object) &#123; int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); count++; checksum += baseHashCode; baseHashCode *= count; hashcode = multiplier * hashcode + baseHashCode; updateList.add(object);&#125; 同时重写了 CacheKey 的 equals 方法，代码如下所示： 1234567@Overridepublic boolean equals(Object object) &#123; ............. for (int i = 0; i &lt; updateList.size(); i++) &#123; Object thisObject = updateList.get(i); Object thatObject = cacheKey.updateList.get(i); if (!ArrayUtil.equals(thisObject, thatObject)) &#123; return false; &#125; &#125; return true;&#125; 除去 hashcode，checksum 和 count 的比较外，只要 updatelist 中的元素一一对应相等，那么就可以认为是 CacheKey 相等。只要两条 SQL 的下列五个值相同，即可以认为是相同的 SQL。 Statement Id + Offset + Limmit + Sql + Params BaseExecutor 的 query 方法继续往下走，代码如下所示： 123456list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;if (list != null) &#123; // 这个主要是处理存储过程用的。 handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); &#125; else &#123; list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125; 如果查不到的话，就从数据库查，在 queryFromDatabase 中，会对 localcache 进行写入。 在 query 方法执行的最后，会判断一级缓存级别是否是 STATEMENT 级别，如果是的话，就清空缓存，这也就是 STATEMENT 级别的一级缓存无法共享 localCache 的原因。代码如下所示： 123if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; clearLocalCache();&#125; 在源码分析的最后，我们确认一下，如果是 insert/delete/update 方法，缓存就会刷新的原因。 SqlSession 的 insert 方法和 delete 方法，都会统一走 update 的流程，代码如下所示： 1234567@Overridepublic int insert(String statement, Object parameter) &#123; return update(statement, parameter); &#125; @Overridepublic int delete(String statement) &#123; return update(statement, null);&#125; update 方法也是委托给了 Executor 执行。BaseExecutor 的执行方法如下所示。 12345678@Overridepublic int update(MappedStatement ms, Object parameter) throws SQLException &#123; ErrorContext.instance().resource(ms.getResource()).activity("executing an update").object(ms.getId()); if (closed) &#123; throw new ExecutorException("Executor was closed."); &#125; clearLocalCache(); return doUpdate(ms, parameter);&#125; 每次执行 update 前都会清空 localCache。 至此，一级缓存的工作流程讲解以及源码分析完毕。 小结 MyBatis 一级缓存的生命周期和 SqlSession 一致。 MyBatis 一级缓存内部设计简单，只是一个没有容量限定的 HashMap，在缓存的功能性上有所欠缺。 MyBatis 的一级缓存最大范围是 SqlSession 内部，有多个 SqlSession 或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为 Statement。 二级缓存二级缓存介绍在上文中提到的一级缓存中，其最大的共享范围就是一个 SqlSession 内部，如果多个 SqlSession 之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在 CachingExecutor 进行二级缓存的查询，具体的工作流程如下所示。 二级缓存开启后，同一个 namespace 下的所有操作语句，都影响着同一个 Cache，即二级缓存被多个 SqlSession 共享，是一个全局的变量。 当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。 二级缓存配置要正确的使用二级缓存，需完成如下配置的。 在 MyBatis 的配置文件中开启二级缓存。 1&lt;setting /&gt; 在 MyBatis 的映射 XML 中配置 cache 或者 cache-ref 。 cache 标签用于声明这个 namespace 使用二级缓存，并且可以自定义配置。 1&lt;cache/&gt; type：cache 使用的类型，默认是 PerpetualCache，这在一级缓存中提到过。 eviction： 定义回收的策略，常见的有 FIFO，LRU。 flushInterval： 配置一定时间自动刷新缓存，单位是毫秒。 size： 最多缓存对象的个数。 readOnly： 是否只读，若配置可读写，则需要对应的实体类能够序列化。 blocking： 若缓存中找不到对应的 key，是否会一直 blocking，直到有对应的数据进入缓存。 cache-ref 代表引用别的命名空间的 Cache 配置，两个命名空间的操作使用的是同一个 Cache。 1&lt;cache-ref namespace="mapper.StudentMapper"/&gt; 二级缓存实验接下来我们通过实验，了解 MyBatis 二级缓存在使用上的一些特点。 在本实验中，id 为 1 的学生名称初始化为点点。 实验 1测试二级缓存效果，不提交事务，sqlSession1 查询完数据后，sqlSession2 相同的查询是否会从缓存中获取数据。 1234567891011@Testpublic void testCacheWithoutCommitOrClose() throws Exception &#123; SqlSession sqlSession1 = factory.openSession(true); SqlSession sqlSession2 = factory.openSession(true); StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class); StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class); System.out.println("studentMapper读取数据: " + studentMapper.getStudentById(1)); System.out.println("studentMapper2读取数据: " + studentMapper2.getStudentById(1));&#125; 执行结果： 我们可以看到，当 sqlsession 没有调用 commit() 方法时，二级缓存并没有起到作用。 实验 2测试二级缓存效果，当提交事务时，sqlSession1 查询完数据后，sqlSession2 相同的查询是否会从缓存中获取数据。 123456789101112@Testpublic void testCacheWithCommitOrClose() throws Exception &#123; SqlSession sqlSession1 = factory.openSession(true); SqlSession sqlSession2 = factory.openSession(true); StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class); StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class); System.out.println("studentMapper读取数据: " + studentMapper.getStudentById(1)); sqlSession1.commit(); System.out.println("studentMapper2读取数据: " + studentMapper2.getStudentById(1));&#125; 从图上可知，sqlsession2 的查询，使用了缓存，缓存的命中率是 0.5。 实验 3测试 update 操作是否会刷新该 namespace 下的二级缓存。 123456789101112131415161718@Testpublic void testCacheWithUpdate() throws Exception &#123; SqlSession sqlSession1 = factory.openSession(true); SqlSession sqlSession2 = factory.openSession(true); SqlSession sqlSession3 = factory.openSession(true); StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class); StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class); StudentMapper studentMapper3 = sqlSession3.getMapper(StudentMapper.class); System.out.println("studentMapper读取数据: " + studentMapper.getStudentById(1)); sqlSession1.commit(); System.out.println("studentMapper2读取数据: " + studentMapper2.getStudentById(1)); studentMapper3.updateStudentName("方方",1); sqlSession3.commit(); System.out.println("studentMapper2读取数据: " + studentMapper2.getStudentById(1));&#125; 我们可以看到，在 sqlSession3 更新数据库，并提交事务后，sqlsession2 的 StudentMapper namespace 下的查询走了数据库，没有走 Cache。 实验 4验证 MyBatis 的二级缓存不适用于映射文件中存在多表查询的情况。 通常我们会为每个单表创建单独的映射文件，由于 MyBatis 的二级缓存是基于 namespace 的，多表查询语句所在的 namspace 无法感应到其他 namespace 中的语句对多表查询中涉及的表进行的修改，引发脏数据问题。 123456789101112131415161718@Testpublic void testCacheWithDiffererntNamespace() throws Exception &#123; SqlSession sqlSession1 = factory.openSession(true); SqlSession sqlSession2 = factory.openSession(true); SqlSession sqlSession3 = factory.openSession(true); StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class); StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class); ClassMapper classMapper = sqlSession3.getMapper(ClassMapper.class); System.out.println("studentMapper读取数据: " + studentMapper.getStudentByIdWithClassInfo(1)); sqlSession1.close(); System.out.println("studentMapper2读取数据: " + studentMapper2.getStudentByIdWithClassInfo(1)); classMapper.updateClassName("特色一班",1); sqlSession3.commit(); System.out.println("studentMapper2读取数据: " + studentMapper2.getStudentByIdWithClassInfo(1));&#125; 执行结果： 在这个实验中，我们引入了两张新的表，一张 class，一张 classroom。class 中保存了班级的 id 和班级名，classroom 中保存了班级 id 和学生 id。我们在 StudentMapper 中增加了一个查询方法 getStudentByIdWithClassInfo，用于查询学生所在的班级，涉及到多表查询。在 ClassMapper 中添加了 updateClassName，根据班级 id 更新班级名的操作。 当 sqlsession1 的 studentmapper 查询数据后，二级缓存生效。保存在 StudentMapper 的 namespace 下的 cache 中。当 sqlSession3 的 classMapper 的 updateClassName 方法对 class 表进行更新时，updateClassName 不属于 StudentMapper 的 namespace，所以 StudentMapper 下的 cache 没有感应到变化，没有刷新缓存。当 StudentMapper 中同样的查询再次发起时，从缓存中读取了脏数据。 实验 5为了解决实验 4 的问题呢，可以使用 Cache ref，让 ClassMapper 引用 StudenMapper 命名空间，这样两个映射文件对应的 Sql 操作都使用的是同一块缓存了。 执行结果： 不过这样做的后果是，缓存的粒度变粗了，多个 Mapper namespace 下的所有操作都会对缓存使用造成影响。 二级缓存源码分析MyBatis 二级缓存的工作流程和前文提到的一级缓存类似，只是在一级缓存处理前，用 CachingExecutor 装饰了 BaseExecutor 的子类，在委托具体职责给 delegate 之前，实现了二级缓存的查询和写入功能，具体类关系图如下图所示。 源码分析源码分析从 CachingExecutor 的 query 方法展开，源代码走读过程中涉及到的知识点较多，不能一一详细讲解，读者朋友可以自行查询相关资料来学习。 CachingExecutor 的 query 方法，首先会从 MappedStatement 中获得在配置初始化时赋予的 Cache。 1Cache cache = ms.getCache(); 本质上是装饰器模式的使用，具体的装饰链是 SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; LruCache -&gt; PerpetualCache。 以下是具体这些 Cache 实现类的介绍，他们的组合为 Cache 赋予了不同的能力。 SynchronizedCache： 同步 Cache，实现比较简单，直接使用 synchronized 修饰方法。 LoggingCache： 日志功能，装饰类，用于记录缓存的命中率，如果开启了 DEBUG 模式，则会输出命中率日志。 SerializedCache： 序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的 Copy，用于保存线程安全。 LruCache： 采用了 Lru 算法的 Cache 实现，移除最近最少使用的 key/value。 PerpetualCache： 作为为最基础的缓存类，底层实现比较简单，直接使用了 HashMap。 然后是判断是否需要刷新缓存，代码如下所示： 1flushCacheIfRequired(ms); 在默认的设置中 SELECT 语句不会刷新缓存，insert/update/delte 会刷新缓存。进入该方法。代码如下所示： 12345private void flushCacheIfRequired(MappedStatement ms) &#123; Cache cache = ms.getCache(); if (cache != null &amp;&amp; ms.isFlushCacheRequired()) &#123; tcm.clear(cache); &#125;&#125; MyBatis 的 CachingExecutor 持有了 TransactionalCacheManager，即上述代码中的 tcm。 TransactionalCacheManager 中持有了一个 Map，代码如下所示： 1private Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;(); 这个 Map 保存了 Cache 和用 TransactionalCache 包装后的 Cache 的映射关系。 TransactionalCache 实现了 Cache 接口，CachingExecutor 会默认使用他包装初始生成的 Cache，作用是如果事务提交，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响。 在 TransactionalCache 的 clear，有以下两句。清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存，代码如下所示： 1234@Overridepublic void clear() &#123; clearOnCommit = true; entriesToAddOnCommit.clear();&#125; CachingExecutor 继续往下走，ensureNoOutParams 主要是用来处理存储过程的，暂时不用考虑。 12if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123; ensureNoOutParams(ms, parameterObject, boundSql); 之后会尝试从 tcm 中获取缓存的列表。 1List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key); 在 getObject 方法中，会把获取值的职责一路传递，最终到 PerpetualCache。如果没有查到，会把 key 加入 Miss 集合，这个主要是为了统计命中率。 123Object object = delegate.getObject(key);if (object == null) &#123; entriesMissedInCache.add(key);&#125; CachingExecutor 继续往下走，如果查询到数据，则调用 tcm.putObject 方法，往缓存中放入值。 123if (list == null) &#123; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); // issue #578 and #116&#125; tcm 的 put 方法也不是直接操作缓存，只是在把这次的数据和 key 放入待提交的 Map 中。 1234@Overridepublic void putObject(Object key, Object object) &#123; entriesToAddOnCommit.put(key, object);&#125; 从以上的代码分析中，我们可以明白，如果不调用 commit 方法的话，由于 TranscationalCache 的作用，并不会对二级缓存造成直接的影响。因此我们看看 Sqlsession 的 commit 方法中做了什么。代码如下所示： 1234@Overridepublic void commit(boolean force) &#123; try &#123; executor.commit(isCommitOrRollbackRequired(force)); 因为我们使用了 CachingExecutor，首先会进入 CachingExecutor 实现的 commit 方法。 12345@Overridepublic void commit(boolean required) throws SQLException &#123; delegate.commit(required); tcm.commit();&#125; 会把具体 commit 的职责委托给包装的 Executor。主要是看下 tcm.commit()，tcm 最终又会调用到 TrancationalCache。 1234567public void commit() &#123; if (clearOnCommit) &#123; delegate.clear(); &#125; flushPendingEntries(); reset();&#125; 看到这里的 clearOnCommit 就想起刚才 TrancationalCache 的 clear 方法设置的标志位，真正的清理 Cache 是放到这里来进行的。具体清理的职责委托给了包装的 Cache 类。之后进入 flushPendingEntries 方法。代码如下所示： 12345private void flushPendingEntries() &#123; for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123; delegate.putObject(entry.getKey(), entry.getValue()); &#125; ................&#125; 在 flushPendingEntries 中，将待提交的 Map 进行循环处理，委托给包装的 Cache 类，进行 putObject 的操作。 后续的查询操作会重复执行这套流程。如果是 insert|update|delete 的话，会统一进入 CachingExecutor 的 update 方法，其中调用了这个函数，代码如下所示： 1private void flushCacheIfRequired(MappedStatement ms) 在二级缓存执行流程后就会进入一级缓存的执行流程，因此不再赘述。 小结 MyBatis 的二级缓存相对于一级缓存来说，实现了 SqlSession 之间缓存数据的共享，同时粒度更加的细，能够到 namespace 级别，通过 Cache 接口实现类不同的组合，对 Cache 的可控性也更强。 MyBatis 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。 在分布式环境下，由于默认的 MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将 MyBatis 的 Cache 接口实现，有一定的开发成本，直接使用 Redis,Memcached 等分布式缓存可能成本更低，安全性也更高。 全文总结本文对介绍了 MyBatis 一二级缓存的基本概念，并从应用及源码的角度对 MyBatis 的缓存机制进行了分析。最后对 MyBatis 缓存机制做了一定的总结，个人建议 MyBatis 缓存特性在生产环境中进行关闭，单纯作为一个 ORM 框架使用可能更为合适。 原文：聊聊MyBatis缓存机制http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653193628&amp;idx=1&amp;sn=8a88bbda1e45b20917cc78714ff1b8ea&amp;chksm=8c99f746bbee7e50a4efd09ad2c476ff91145b88329f14d9b2f397e2b287c8b65700f1b94d85&amp;mpshare=1&amp;scene=1&amp;srcid=04157BoblWCmXP0reps0qn5D%23rd]]></content>
      <tags>
        <tag>源码</tag>
        <tag>MyBatis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能、机器学习和深度学习]]></title>
    <url>%2F2018%2F04%2F14%2F2018-04-14%2F</url>
    <content type="text"><![CDATA[用户行为分析机器学习流程图:https://www.processon.com/view/59c90da6e4b061a3d10e0a65 参考：人工智能、机器学习和深度学习的区别? - 知乎https://www.zhihu.com/question/57770020[论文] 如何用深度学习实现用户行为预测与推荐？ – ＮＵＬＬ-http://www.infosec-wiki.com/?p=215971用户在线广告点击行为预测的深度学习模型 | 数据分析网http://www.afenxi.com/post/33722]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis 笔记]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13%2F</url>
    <content type="text"><![CDATA[http://www.redis.cn/ p20 下边和P21上面 redis速度快的原理 P23 分布式锁的实现 https://blog.csdn.net/bobshute/article/details/77624964 https://blog.csdn.net/u010942020/article/details/79265827 参考：《redis开发与运维》]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memcached redis 对比分析]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-7%2F</url>
    <content type="text"><![CDATA[简介memcached 和 redis 都属于内存 (memory) 键 - 值 (key-value) 数据库，在设计和思想上有许多相同之处，功能和应用在很多场合 (如分布式缓存服务) 也相似。它们都从属于数据库解决方案中的 nosql 家族，由于两者都将数据存储在内存中，自然而然，它们都是非常理想的缓存实现方案。 memcached 最初是由 Brad Fitzpatrick 于 2003 年开发而成。而 redis 则由 Salvatore Sanfilippo 于 2009 年创建，它本身也从 memcached 上吸取借鉴大量宝贵经验教训，被称为 “强化版 memcached”。确实，redis 在功能多样性方面要胜过 memcached，虽然强大且更具灵活性，但复杂程度也比 memcached 更甚。 基本架构和思想两者的架构和设计思想 memcachedmemcached 采用客户端 - 服务器 (C/S) 的架构，客户端和服务器端的通讯使用自定义的协议标准，只要满足协议格式要求，客户端 Library 可以用任何语言实现。 从用户的角度来说，服务器维护了一个键 - 值关系的数据表，服务器之间相互独立，互相之间不共享数据也不做任何通讯操作。也就是说，memcached 本身不支持分布式扩展。客户端需要知道所有的服务器，并自行负责管理数据在各个服务器间的分配。 在服务器端，内部的数据存储，使用基于 Slab 的内存管理方式，有利于减少内存碎片和频繁分配销毁内存所带来的开销。各个 Slab 按需动态分配一个 page 的内存（和 4Kpage 的概念不同，这里默认 page 为 1M），page 内部按照不同 slab class 的尺寸再划分为内存 chunk 供服务器存储 KV 键值对使用。 memcached 的基本应用模型： redisredis 的基本应用模式和上图 memcached 的基本相似，不难发现网上到处都是关于 redis 是否可以完全替代 memcached 使用的问题。 redis 内部的数据结构最终也会落实到 key-value 对应的形式，不过从暴露给用户的数据结构来看，要比 memcached 丰富，除了标准的通常意义的键值对，redis 还支持 List，Set， Hashes，Sorted Set 等数据结构。 基本命令memcached 的命令或者说通讯协议非常简单，server 所支持的命令基本就是对特定 key 的添加，删除，替换，原子更新，读取等，具体包括 set, get, add, replace, append, inc/dec 等等。 memcached 的通讯协议包括文本格式和二进制格式，用于满足简单网络客户端工具（如 telnet）和对性能要求更高的客户端的不同需求。 redis 的命令在 kv(string 类型) 上提供与 memcached 类似的基本操作，在其它数据结构上也支持基本类似的操作（当然还有这些数据结构所特有的操作，如 set 的 union，list 的 pop 等）而支持更多的数据结构，在一定程度上也就意味着更加广泛的应用场合 除了多种数据结构的支持，redis 相比 memcached 还提供了许多额外的特性，比如 subscribe/publish 命令，以支持发布 / 订阅模式这样的通知机制等等，这些额外的特性同样有助于拓展它的应用场景。 redis 的客户端 - 服务器通讯协议完全采用文本格式 (在将来可能的服务器间通讯会采用二进制格式)。 事务redis 通过 multi / watch / exec 等命令可以支持事务的概念，原子性的执行一批命令。在 2.6 以后的版本中由于添加了对 script 脚本的支持，而脚本固有的是以 transaction 事务的方式执行的，并且更加易于使用，所以不排除将来取消 multi 等命令接口的可能性。 memcached 的应用模式中，除了 increment/decrement 这样的原子操作命令，不存在对事务的支持。 数据备份，有效性，持久化等memcached 不保证存储的数据的有效性，slab 内部基于 LRU 也会自动淘汰旧数据，客户端不能假设数据在服务器端的当前状态，这应该说是 memcached 的 feature 设定，用户不必太多关心或者自己管理数据的淘汰更新工作，当然是否适合你的应用，取决于具体的需求，它也可能成为你需要精确自行控制 cache 生命周期的一个障碍。 memcached 也不做数据的持久化工作，但是有许多基于 memcached 协议的项目实现了数据的持久化，例如 memcache DB 使用 BerkeleyDB 进行数据存储，但本质上它已经不是一个 cache server，而只是一个兼容 memcached 的协议 key-valueData Store 了 redis 可以以 master-slave 的方式配置服务器，slave 节点对数据进行 replica 备份，slave 节点也可以充当 read only 的节点分担数据读取的工作 redis 内建支持两种持久化方案，snapshot 快照和 AOF 增量 Log 方式。快照顾名思义就是隔一段时间将完整的数据 dump 下来存储在文件中。AOF 增量 Log 则是记录对数据的修改操作（实际上记录的就是每个对数据产生修改的命令本身），两种方案可以并存，也各有优缺点，具体参见 http://redis.io/topics/persistence 以上 Redis 的数据备份持久化方案等，如果不需要，为了提高性能，也完全可以 Disable 性能memcachedmemcached 自身并不主动定期检查和标记哪些数据需要被淘汰，只有当再次读取相关数据时才检查时间戳，或者当内存不够使用需要主动淘汰数据时进一步检查 LRU 数据。 redisredis 为了减少大量小数据 CMD 操作的网络通讯时间开销 RTT (Round Trip Time)，支持 pipeline 和 script 技术。 所谓的 pipeline 就是支持在一次通讯中，发送多个命令给服务器批量执行，带来的代价是服务器端需要更多的内存来缓存查询结果。 redis 内嵌了 LUA 解析器，可以执行 lua 脚本，脚本可以通过 eval 等命令直接执行，也可以使用 script load 等方式上传到服务器端的 script cache 中重复使用。 这两种方式都可以有效地减少网络通讯开销，增加数据吞吐率。 对于 KV 的操作，memcached 和 redis 都支持 multiple 的 get 和 set 命令（memcached 的 multiple set 命令貌似只在二进制的协议中支持），这同样有利于性能的提升。 实际性能方面，网上有很多测试比较，给出的结果各不相同，这无疑和各种测试的测试用例，测试环境，和测试时具体使用的客户端 Library 实现有关。但是总体看下来，比较靠谱的结论是在 kv 类操作上，两者的性能接近，memcached 的结构更加简单，理论上应该会略微快一些。 集群memcached 的服务器端互相完全独立，客户端通常通过对键值应用 hash 算法决定数据的分区，为了减少服务器的增减对 hash 结果的影响，导致大面积的缓存失效，多数客户端实现了一致性 hash 算法。 redis 计划在服务器端内建对集群的支持，在此之前，同样可以认为每个 redis 服务器实例相互之间是完全独立的，需要依靠客户端处理分区算法和可用服务器列表管理的工作。 redis 官方推荐的用于 sharding 的客户端程序库是 Twitter 的开源项目 Twemproxy， Twemproxy 同时支持 Memcached 和 Redis 的文本通讯协议。 需要注意的是，redis 的许多命令在集群环境下是不能正确运行的，例如 set 的交集，以及跨节点的事务操作等等，因为目前的 redis 集群设计，根本目标也就是服务器之间互相汇报一下存活状态，以及对数据做荣誉备份平衡负载等而已，本质上对数据的跨节点操作并不提供任何额外支持，所以在数据服务的层面上来说，各个服务器依旧是完全独立的。 这些操作如果一定要实现，当然可以通过客户端代码来实现（效率有多高且不说），类似的问题 memcached 集群当然也会遇上，但是原本 memcached 就不支持复杂的操作和数据类型，许多运算逻辑原本就是由客户端代码或应用程序自己处理的。 如何选择何时应该使用 memcached相对 memcached 而言，redis 的面世时间更晚且具备更多功能，因此开发人员通常将其视为默认性首选方案。不过有两类特殊场景仍然是 memcached 的一家天下。首先就是对小型静态数据进行缓存处理，最具代表性的例子就是 HTML 代码片段。memcached 的内部内存管理机制虽然不像 redis 的那样复杂，但却更具实际效率——这是因为 memcached 在处理元数据时所消耗的内存资源相对更少。作为 memcached 所支持的惟一一种数据类型，字符串非常适合用于保存那些只需要进行读取操作的数据，因为字符串本身无需进行进一步处理。 除此之外，memcached 在横向扩展方面也比 redis 更具优势。由于其在设计上的思路倾向以及相对更为简单的功能设置，memcached 在实现扩展时的难度比 redis 低得多。不过根据我们了解到的情况，目前已经有多种经过测试且切实有效的方案能够将 redis 扩展至多台服务器之上，而其即将发布的 3.0 版本 (感兴趣的朋友可以点击此处查看其候选版本说明) 将包含专门针对横向扩展场景的内置集群化机制。 何时应该使用 redis除非大家需要考虑某种限定性条件 (例如处理传统应用程序) 对于 memcached 的特殊依赖性，或者自己的实际用例属于前面提到的两类场景中的一种，否则请直接选择 redis 并加以运用。凭借着 redis 所带来的卓越缓存方案，我们将拥有强大的处理能力——例如对缓存内容及持久性进行细节调整的能力——以及出色的整体执行效率。 redis 几乎在缓存管理工作中的每一个侧面都表现出显而易见的优越性。这套缓存方案采用所谓数据回收机制，能够将陈旧数据从内存中删除以提供新数据所必需的缓存空间。memcached 的数据回收机制使用的是 LRU(即最低近期使用量) 算法，而且往往会比较武断地直接删除掉与新数据体系相近的原有内容。相比之下，redis 允许用户更为精准地进行细化控制，利用六种不同回收策略确切提高缓存资源的实际利用率。redis 还采用更为复杂的内存管理与回收对象备选方案。 redis 还能为我们带来最大程度的灵活性空间，从而保证管理员在打理缓存对象时拥有充裕的施展平台。在这方面，memcached 将键名限制在 250 字节，值也被限制在不超过 1MB，且只适用于普通字符串。相比之下，redis 则将键名与值的最大上限各自设定为 512MB，且支持二进制格式。redis 支持六种数据类型，因此能够更加智能地对数据进行缓存处理及操作，这相当于为应用程序开发人员敞开了一道通往无尽可能性的大门。 相对于将对象保存为序列化字符串，redis 允许开发人员以散列方式将对象域及值加以保存，并利用单一键对其进行管理。redis 散列机制的存在保证开发人员无需经历获取完整字符串、反序列化、更新值、对象重新序列化并在每次值更新后利用其替代缓存内完整字符串这一系列复杂的流程——这也意味着资源消耗量得以降低、性能表现迎来显著提升。redis 所支持的其它数据类型，例如 lists 以及 sets——也可被用于实现更加复杂的缓存管理模式。 redis 的另一大重要优势在于，它所保存的数据具备透明化特性，也就是说服务器能够直接对这些数据进行操作。redis 当中提供 160 多种可用命令，其中大部分用于实现数据处理操作并通过服务器端脚本将逻辑嵌入至数据存储体系当中。这些内置命令及用户脚本带来了极大的灵活性优势，足以帮助大家直接在 redis 内部完成数据处理任务——而不必将数据在网络中的其它专门处理系统之间来回移动。 redis 还提供可选而且能够具体调整的数据持久性方案，其设计目的在于在发生规划内停机或者计划外故障之后对缓存内容进行重新引导。虽然我们更倾向于强调缓存内数据的易失性与暂时性，但将数据在磁盘中加以持久保存在某些缓存场景当中仍然极具现实意义。这种机制能够在设备重启之后快速将保存在磁盘上的数据重新载入至缓存当中，从而大大缩短缓存预热周期并根据主数据存储内容对当前缓存内容进行重新评估。 最后但也同样重要的一点是，redis 能够提供复制功能。复制功能旨在帮助缓存体系实现高可用性配置方案，从而在遭遇故障的情况下继续为应用程序提供不间断的缓存服务。很明显，一套成熟的缓存方案应该能够在应用程序发生故障时略微甚至完全不给用户体验或者应用程序性能表现带来任何影响，而这种对缓存内容及服务可用性的有力保障在大多数情况下也成为缓存解决方案的一大主要优势。 小结redis 的作者 Salvatore Sanfilippo 曾经对这两种基于内存的数据存储系统进行过比较，总体来看还是比较客观的，现总结如下： 性能对比：由于 redis 只使用单核，而 memcached 可以使用多核，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高。而在 100k 以上的数据中，memcached 性能要高于 redis，虽然 redis 最近也在存储大数据的性能上进行优化，但是比起 memcached，还是稍有逊色。 内存使用效率对比：使用简单的 key-value 存储的话，memcached 的内存利用率更高，而如果 redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩，其内存利用率会高于 memcached。另外，memcached 使用预分配的内存池的方式，带来一定程度的空间浪费 并且在内存仍然有很大空间时，新的数据也可能会被剔除，而 redis 使用现场申请内存的方式来存储数据，不会剔除任何非临时数据 redis 更适合作为存储而不是 cache。 redis 支持服务器端的数据操作：redis 相比 memcached 来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在 memcached 里，你需要将数据拿到客户端来进行类似的修改再 set 回去。这大大增加了网络 IO 的次数和数据体积。在 redis 中，这些复杂的操作通常和一般的 GET/SET 一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么 redis 会是不错的选择。 另外，贴一些前辈们使用 redis 的经验和教训： 要进行 master-slave 配置，出现服务故障时可以支持切换。 在 master 侧禁用数据持久化，只需在 slave 上配置数据持久化。 物理内存 + 虚拟内存不足，这个时候 dump 一直死着，时间久了机器挂掉。这个情况就是灾难。 当 redis 物理内存使用超过内存总容量的 3/5 时就会开始比较危险了，就开始做 swap, 内存碎片大。 当达到最大内存时，会清空带有过期时间的 key，即使 key 未到过期时间。 redis 与 DB 同步写的问题，先写 DB，后写 redis，因为写内存基本上没有问题。 原文：memcached redis 对比分析 - 简书https://www.jianshu.com/p/e94fa7340923]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 数据库引擎]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-6%2F</url>
    <content type="text"><![CDATA[mysql 数据库引擎一、数据库引擎 数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。 使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。 二、数据库引擎任务 在数据库引擎文档中，各主题的顺序遵循用于实现使用数据库引擎进行数据存储的系统的任务的主要顺序。 设计并创建数据库以保存系统所需的关系或 XML 文档 实现系统以访问和更改数据库中存储的数据。包括实现网站或使用数据的应用程序，还包括生成使用 SQL Server 工具和实用工具以使用数据的过程。 为单位或客户部署实现的系统 提供日常管理支持以优化数据库的性能 三、MySQL 数据库引擎类别 你能用的数据库引擎取决于 mysql 在安装的时候是如何被编译的。要添加一个新的引擎，就必须重新编译 MYSQL。在缺省情况下，MYSQL 支持三个引擎：ISAM、MYISAM 和 HEAP。另外两种类型 INNODB 和 BERKLEY（BDB），也常常可以使用。 ISAM ISAM 是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到数据库被查询的次数要远大于更新的次数。因此，ISAM 执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM 的两个主要不足之处在于，它不支持事务处理，也不能够容错：如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把 ISAM 用在关键任务应用程序里，那就必须经常备份你所有的实时数据，通过其复制特性，MYSQL 能够支持这样的备份应用程序。 MYISAM MYISAM 是 MYSQL 的 ISAM 扩展格式和缺省的数据库引擎。除了提供 ISAM 里所没有的索引和字段管理的功能，MYISAM 还使用一种表格锁定的机制，来优化多个并发的读写操作。其代价是你需要经常运行 OPTIMIZE TABLE 命令，来恢复被更新机制所浪费的空间。MYISAM 还有一些有用的扩展，例如用来修复数据库文件的 MYISAMCHK 工具和用来恢复浪费空间的 MYISAMPACK 工具。 MYISAM 强调了快速读取操作，这可能就是为什么 MYSQL 受到了 WEB 开发如此青睐的主要原因：在 WEB 开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和 INTERNET 平台提供商只允许使用 MYISAM 格式。 HEAP HEAP 允许只驻留在内存里的临时表格。驻留在内存里让 HEAP 要比 ISAM 和 MYISAM 都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。在数据行被删除的时候，HEAP 也不会浪费大量的空间。HEAP 表格在你需要使用 SELECT 表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格。 INNODB 和 BERKLEYDB INNODB 和 BERKLEYDB（BDB）数据库引擎都是造就 MYSQL 灵活性的技术的直接产品，这项技术就是 MYSQL++ API。在使用 MYSQL 的时候，你所面对的每一个挑战几乎都源于 ISAM 和 MYISAM 数据库引擎不支持事务处理也不支持外来键。尽管要比 ISAM 和 MYISAM 引擎慢很多，但是 INNODB 和 BDB 包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。如前所述，如果你的设计需要这些特性中的一者或者两者，那你就要被迫使用后两个引擎中的一个了。 四、mysql 数据引擎更换方式1、查看当前数据库支持的引擎和默认的数据库引擎：1show engines; 我的查询结果如下： 2、更改数据库引擎2.1、更改方式 1：修改配置文件 my.ini 将 my-small.ini 另存为 my.ini，在 [mysqld] 后面添加 default-storage-engine=InnoDB，重启服务，数据库默认的引擎修改为 InnoDB 2.2、更改方式 2: 在建表的时候指定 建表时指定： 1234create table mytbl( id int primary key, name varchar(50) )type=MyISAM; 2.3、更改方式 3：建表后更改 alter table mytbl2 type = InnoDB; 3、查看修改结果 方式 1： 1show table status from mytest; 方式 2： 1show create table table_name 五、MyIASM 和 Innodb 引擎详解Innodb 引擎 Innodb 引擎提供了对数据库 ACID 事务的支持，并且实现了 SQL 标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于 MySQL 后台的完整数据库系统，MySQL 运行时 Innodb 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持 FULLTEXT 类型的索引，而且它没有保存表的行数，当 SELECT COUNT(*) FROM TABLE 时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用 Innodb 引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表。 名词解析： ACID A 事务的原子性 (Atomicity)：指一个事务要么全部执行, 要么不执行. 也就是说一个事务不可能只执行了一半就停止了. 比如你从取款机取钱, 这个事务可以分成两个步骤: 1 划卡, 2 出钱. 不可能划了卡, 而钱却没出来. 这两步必须同时完成. 要么就不完成. C 事务的一致性 (Consistency)：指事务的运行并不改变数据库中数据的一致性. 例如, 完整性约束了 a+b=10, 一个事务改变了 a, 那么 b 也应该随之改变. I 独立性 (Isolation）: 事务的独立性也有称作隔离性, 是指两个以上的事务不会出现交错执行的状态. 因为这样可能会导致数据不一致. D 持久性 (Durability）: 事务的持久性是指事务执行成功以后, 该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚. MyIASM 引擎 MyIASM 是 MySQL 默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT(插入) 或 UPDATE(更新) 数据时即写操作需要锁定整个表，效率便会低一些。不过和 Innodb 不同，MyIASM 中存储了表的行数，于是 SELECT COUNT(*) FROM TABLE 时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么 MyIASM 也是很好的选择。 两种引擎的选择 大尺寸的数据集趋向于选择 InnoDB 引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB 可以利用事务日志进行数据恢复，这会比较快。主键查询在 InnoDB 引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的 INSERT 语句 (在每个 INSERT 语句中写入多行，批量插入) 在 MyISAM 下会快一些，但是 UPDATE 语句在 InnoDB 下则会更快一些，尤其是在并发量大的时候。 Index——索引 索引（Index）是帮助 MySQL 高效获取数据的数据结构。MyIASM 和 Innodb 都使用了树这种数据结构做为索引。下面我接着讲这两种引擎使用的索引结构，讲到这里，首先应该谈一下 B-Tree 和 B+Tree。 MyIASM 引擎的索引结构 MyISAM 引擎的索引结构为 B+Tree，其中 B+Tree 的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。如下图所示： 这里设表一共有三列，假设我们以 Col1 为主键，则上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示： 同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。 Innodb 引擎的索引结构 与 MyISAM 引擎的索引结构同样也是 B+Tree，但是 Innodb 的索引文件本身就是数据文件，即 B+Tree 的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的 key 就是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。 并且和 MyISAM 不同，InnoDB 的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以 Innodb 不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样 B+Tree 的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。 两者区别： 第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。 上图是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。 第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。例如，下图为定义在 Col3 上的一个辅助索引： 这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调 (可能是指“非递增” 的意思)的字段作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗 B+Tree，非单调 (可能是指“非递增” 的意思)的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 参考：mysql 数据库引擎 - WhyWin - 博客园https://www.cnblogs.com/0201zcr/p/5296843.html]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>Innodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据挖掘]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-5%2F</url>
    <content type="text"><![CDATA[近期需要完成的，先看课件了解个大概。 参考：如何系统地学习数据挖掘？ - 知乎https://www.zhihu.com/question/20751219]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计和 E-R 模型]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-4%2F</url>
    <content type="text"><![CDATA[《数据库系统概念》第 7 章知识点总结 数据库设计和 E-R 模型 本章我们将学习将数据库表示为一个关系数据库设计和一个与之关联的约束集合 实体：指示所有可明确识别的个体。各种各样的实体以多种方式互相关联，而所有这些方式都需要在数据库设计中反映出来 设计一个数据库模式的时候，必须避免的两个主要的缺陷 （1）冗余：一个不好的设计可能会重复信息。信息的冗余表达的最大问题是当对一条信息进行更新，但没有将这条信息的所有拷贝都更新时这条信息的拷贝会变得不一致。 （2）不完整：如字面意思，一个不好的设计可能会使得企事业机构的某些方面难于甚至无法建模。 实体 - 联系模型 实体 - 联系（E-R）数据模型的提出旨在方便数据库的设计，它是通过允许定义代表数据库全局逻辑结构的企业模式实现的。 实体：是现实世界中可区别于所有其他对象的一个 “事物” 或“对象” 实体集：是相同类型即具有相同性质（或属性）的一个实体集合。例如一所给定大学的所有教师的集合可定义为实体集 instructor 联系：是指多个实体间的相互关联 联系集：是相同类型联系的集合。 参与：实体集之间的关联称为参与。也就是说，实体集 E1,E2,…,En 参与联系集 R 角色：实体在联系中扮演的功能称为实体的角色。 属性：实体集的属性是将实体集映射到域的函数。由于一个实体集可能有多个属性，因此每个实体可以用一组（属性，数据值）对来表示，实体集的每个属性对应一个这样的对。 E-R 模型中的属性可以按照如下的属性类型来划分 （1）简单和复合属性：简单属性指不能划分为更小的部分；复合属性指可以再划分为更小的部分（即其他属性）。例如属性 name 可设计为一个包含 first_name、middle_initial 和 last_name 的复合属性 （2）单值和多值属性：我们直接用例子说明：对某个特定的学生实体而言，student_ID 属性只对应于一个学生 ID，这样的属性为单值；在教师实体中，每个教师可以有 0 个、1 个或多个电话号码，这个 phone_number 属性就是多值的。 （3）派生属性：这类属性的值可以从别的相关属性或实体派生出来。 约束 映射基数：表示一个实体通过一个联系集能关联的实体的个数。 （1）一对一：A 中的一个实体至多与 B 中的一个实体相关联，并且 B 中的一个实体也至多与 A 中的一个实体相关联 （2）一对多：A 中的一个实体至多与 B 中的零个或多个实体相关联，而 B 中的一个实体也至多与 A 中的一个实体相关联 （3）多对一：A 中的一个实体至多与 B 中的一个实体相关联，而 B 中的一个实体可以与 A 中的零个或多个实体相关联 （4）多对多：A 中的一个实体至多与 B 中的零个或多个实体相关联，而且 B 中的一个实体也可以与 A 中的零个或多个实体相关联 码 关系模式中的超码、候选码、主码的概念同样适用于实体集 实体 - 联系图 基本结构 分成两部分的矩形：代表实体集，上面的第一部分为实体集的名字，下面的第二部分包含实体集中所有属性的名字 菱形：代表联系集 未分割的矩形：代表联系集的属性，构成主码的属性以下划线表明 线段：将实体集连接到联系集 虚线：将联系集属性连接到联系集 双线：显示实体在联系集中的参与度 双菱形：代表连接到弱实体集的标志性联系集 联系集和实体集之间也有映射基数，意思同约束中的映射技术，联系集为实体 A，实体集为实体 B 约束的方式有两种： 一、 二、用 l..h 的形式表示一个关联的最小和最大的映射基数 复杂的属性 表示方法： name、address、street 为复合属性 {phone_number} 为多值属性 {age()} 为派生属性 age 角色 通过在菱形和矩形之间的连线上进行标注来表示角色，例如下图中的 course_id 和 prereq_id 弱实体集：没有足够的属性以形成主码的实体集称作弱实体集 强实体集：有主码的实体集称作强实体集 弱实体集必须与另一个称作标识或属主实体集的实体集关联才能有意义。每个弱实体必须和一个标识实体关联；也就是说，弱实体集存在依赖于标识实体集。我们称标识实体集拥有它所标识的弱实体集。将弱实体集与其标识实体集相联的联系称为标识性联系。 分辨符：虽然弱实体集没有主码，但是我们仍然需要区分依赖于特定强实体集的弱实体集中的实体的方法。弱实体集的分辨符是使我们进行这种区分的属性集合，也称为该实体集的部分码。 弱实体集这个知识点有待完善 转换为关系模式 具有简单属性的强实体集的表示 设 E 是只具有简单描述性属性 a1,a2,…,an 的强实体集。我们用具有 n 个不同属性的模式 E 来表示这个实体集。该模式的关系中的每个远足同实体集 E 的一个实体相对应。 具有复杂属性的强实体集的表示 这个就比上面的情况复杂一点，我们通过为每个子属性创建一个单独的和属性来处理符合属性，我们并不为符合属性自身出啊关键一个单独的属性。 例如 instructor 实体集，里面有复合属性 name，为 instructor 生成的末世包括属性 first_name、middle_initial 和 last_name；没有单独的属性或末世表示 name。其他属性类似。 弱实体集的表示 设 A 是具有属性 a1,a2,…,am 的弱实体集，设 B 是 A 所依赖的强实体集，设 B 的主码包括属性 b1,b2,…,bn。我们用名为 A 的关系模式表示实体集 A，该模式的每个属性对应以下集合中的一个成员： 所以 A 的模式的属性有：A 的属性和 B 的主码 该模式的主码由实体集 B 的主码和 A 的分辨符组成 联系集的表示 扩展的 E-R 特性 特化（自顶向下） 在实体集内部进行分组的过程称为特化。 特化是因为实体集中的某个实体子集可能具有不被该实体集中所有实体所共享的一些属性。 概化（自底向上） 概化是高层实体集与一个或多个底层实体集间的包含关系。 概化是多个实体集根据共同具有的特征综合成一个较高层的实体集 注：图片均来自《数据库系统概念》第 6 版——机械工业出版社 原文：【数据库系统概念】第7章 数据库设计和E-R模型 知识总结 - CSDN博客https://blog.csdn.net/qq_37792173/article/details/76668059]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>E-R图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引为什么使用 B + 树]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-3%2F</url>
    <content type="text"><![CDATA[概述B tree： 二叉树（Binary tree），每个节点只能存储一个数。B-tree：B 树（B-Tree，并不是 B“减” 树，横杠为连接符，容易被误导）B 树属于多叉树又名平衡多路查找树。每个节点可以多个数（由磁盘大小决定）。B+tree 和 B*tree 都是 B-tree 的变种 索引为什么是用 B 树呢？一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。而 B-/+/*Tree，经过改进可以有效的利用系统对磁盘的块读取特性，在读取相同磁盘块的同时，尽可能多的加载索引数据，来提高索引命中效率，从而达到减少磁盘 IO 的读取次数。 不了解磁盘相关知识的可以查看 硬盘基本知识（磁头、磁道、扇区、柱面） 下面通过示意图来看一下，B-tree、B+tree、B*tree B-tree 从图中可以看出，B-tree 利用了磁盘块的特性进行构建的树。每个磁盘块一个节点，每个节点包含了很关键字。把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。 B-tree 巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页（每页为 4K），这样每个节点只需要一次 I/O 就可以完全载入。B-tree 的数据可以存在任何节点中。 B+tree B+tree 是 B-tree 的变种，数据只能存储在叶子节点。 B+tree 是 B-tree 的变种，B+tree 数据只存储在叶子节点中。这样在 B 树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定; 如果每个节点能存放 M 个数据，每个节点的数据在 M/2 到 M 之间。预留出空间可以插入新的数据。 B*tree B*tree 每个磁盘块中又添加了对下一个磁盘块的引用。这样可以在当前磁盘块满时，不用扩容直接存储到下一个临近磁盘块中。当两个邻近的磁盘块都满时，这两个磁盘块各分出 1/3 的数据重新分配一个磁盘块，这样这三个磁盘块的数据都为 2/3。 如果每个节点能存放 M 个数据，每个节点的数据在 2M/3 到 M 之间。预留出空间可以插入新的数据。 在 B + 树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得 B * 树额分解次数变得更少； 原文：数据库索引为什么使用B+树？ - 简书https://www.jianshu.com/p/4dbbaaa200c4]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多进程程实战]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-2%2F</url>
    <content type="text"><![CDATA[多进程中，每个进程都是独立的，各自持有一份数据，无法共享。本篇文章介绍三种用于进程数据共享的方法 queues Array Manager.dict pipe Queue12345678910111213from multiprocessing import queuesimport multiprocessingdef func(i, q): q.put(i) print("---&gt;", i, q.qsize())q = queues.Queue(9, ctx=multiprocessing)for i in range(5): p = multiprocessing.Process(target=func, args=(i, q,)) p.start()p.join() Queue 是多进程安全的队列，可以使用 Queue 实现多进程之间的数据传递。put 方法用以插入数据到队列中，put 方法还有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余的空间。如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该 Queue 已满，会立即抛出 Queue.Full 异常 get 方法可以从队列读取并且删除一个元素。同样，get 方法有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常。如果 blocked 为 False，有两种情况存在，如果 Queue 有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出 Queue.Empty 异常 123456789101112import multiprocessingdef func(i, q): q.put(i) print("---&gt;", i, q.qsize())q = multiprocessing.Queue()for i in range(5): p = multiprocessing.Process(target=func, args=(i, q,)) p.start()p.join() Array1234567891011121314from multiprocessing import Processfrom multiprocessing import Arraydef func(i, ar): ar[i] = i for item in ar: print(item) print("------")ar = Array('i', 5)for i in range(5): p = Process(target=func, args=(i, ar,)) p.start()p.join() Array 的局限性在于受制于数组的特性，即需要指定数据类型且长度固定 1234567# 数据类型对照表'c': ctypes.c_char, 'u': ctypes.c_wchar,'b': ctypes.c_byte, 'B': ctypes.c_ubyte,'h': ctypes.c_short, 'H': ctypes.c_ushort,'i': ctypes.c_int, 'I': ctypes.c_uint,'l': ctypes.c_long, 'L': ctypes.c_ulong,'f': ctypes.c_float, 'd': ctypes.c_double Manager.dict123456789101112131415161718192021222324from multiprocessing import Process, Manager# 每个子进程执行的函数# 参数中，传递了一个用于多进程之间数据共享的特殊字典def func(i, d): d[i] = i + 100 print(d.values())# 在主进程中创建特殊字典m = Manager()d = m.dict()for i in range(5): # 让子进程去修改主进程的特殊字典 p = Process(target=func, args=(i, d)) p.start()p.join()------------[100][100, 101][100, 101, 102, 103][100, 101, 102, 103][100, 101, 102, 103, 104] Manager.dict 是多进程数据共享中比较常用的做法 pipePipe 方法返回 (conn1, conn2) 代表一个管道的两个端。Pipe 方法有 duplex 参数，如果 duplex 参数为 True(默认值)，那么这个管道是全双工模式，也就是说 conn1 和 conn2 均可收发。duplex 为 False，conn1 只负责接受消息，conn2 只负责发送消息 send 和 recv 方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用 conn1.send 发送消息，conn1.recv 接收消息。如果没有消息可接收，recv 方法会一直阻塞。如果管道已经被关闭，那么 recv 方法会抛出 EOFError 12345678910111213141516171819import multiprocessingdef func1(arg, pp): pp.send(arg)def func2(pp): recv = pp.recv() print(recv)pp = multiprocessing.Pipe()p1 = multiprocessing.Process(target=func1, args=("PolarSnow", pp[0],))p2 = multiprocessing.Process(target=func2, args=(pp[1],))p1.start()p2.start()p1.join()p2.join()------------PolarSnow 这个是我写的多进程处理数据的方法： 亲测多进程的效率提升取决于你的cpu核心数，四核的话时间就缩短为原来的四分之一程序片段： 12345678910111213141516171819202122232425262728293031import timeimport concurrent.futuresdef run_thread(num,thread_nums,filepath, queuePath,queueGen,all_count,pathDir): i = 0 for allDir in pathDir: i +=1 if i % thread_nums == num: try: child = os.path.join(filepath, allDir) print("name=", allDir) listener_blockCount = gen(child) #这里用时最长，需要多进程 lock.acquire() queuePath.put(allDir) queueGen.put(listener_blockCount) #写入数据前需要加锁 print(str(allDir)) all_count += 1 lock.release() print("process-" +str(num)+':'+'No.'+ str(all_count)) except: pass continue end_time = time.time() thread_sec = end_time - begin_time print("thread-" +str(num)+':'+'成功写入数据量：' + str(all_count) + "个！") print("当前耗时(s): " + str(thread_sec)) 程序片段： 123456789101112131415161718192021222324252627#进行多进程处理 queuePath = multiprocessing.Queue() queueGen = multiprocessing.Queue() # process_nums = 3 # for i in range(process_nums): # myProcess = Process(target=run_thread, args=(i, process_nums, filepath, queuePath,queueGen, all_count,pathDir)) # myProcess.start() # myProcess.join() t1 = Process(target=run_thread, args=(0,4,filepath, queuePath,queueGen, all_count,pathDir)) t2 = Process(target=run_thread, args=(1,4,filepath, queuePath,queueGen, all_count,pathDir)) t3 = Process(target=run_thread, args=(2,4, filepath, queuePath,queueGen, all_count, pathDir)) t4 = Process(target=run_thread, args=(3,4, filepath, queuePath, queueGen, all_count, pathDir)) t1.start() t2.start() t3.start() t4.start() t1.join() t2.join() t3.join() t4.join() while not queuePath.empty(): blockCount[queuePath.get()] = queueGen.get() 注意：这里主要注意是使用进程间共享变量以及进程锁来实现多进程。 参考:Python中多进程之间的数据共享 | Polar Snow Documentationhttps://docs.lvrui.io/2016/07/24/Python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/]]></content>
      <tags>
        <tag>python</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概念 总结]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-1%2F</url>
    <content type="text"><![CDATA[该书的思维导图svg文件如下： http://p4lmrb1gp.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.svg 参考:qq_37792173的博客 - CSDN博客https://blog.csdn.net/qq_37792173/article/category/7037092]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能计算环境搭建]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12%2F</url>
    <content type="text"><![CDATA[Linux高性能计算集群 – Beowulf集群http://www.jointforce.com.cn/page/hardware_linux.html在亚马逊云中搭建1万个核心的Linux超级计算机_Linux新闻_Linux公社-Linux系统门户网站https://www.linuxidc.com/Linux/2011-04/34323.htm]]></content>
      <tags>
        <tag>高性能计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多线程实战]]></title>
    <url>%2F2018%2F04%2F11%2F2018-04-11%2F</url>
    <content type="text"><![CDATA[当初在刚学习 python 多线程时，上网搜索资料几乎都是一片倒的反应 python 没有真正意义上的多线程，python 多线程就是鸡肋。当时不明所以，只是了解到 python 带有 GIL 解释器锁的概念，同一时刻只能有一个线程在运行，遇到 IO 操作才会释放切换。那么，python 多线程是否真的很鸡肋呢？要解决这个疑惑，我想必须亲自动手测试。 经过对比 python 与 java 的多线程测试，我发现 python 多线程的效率确实不如 java，但远还没有达到鸡肋的程度，那么跟其他机制相比较呢？ 观点：用多进程替代多线程需求 辗转了多篇博文，我看到了一些网友的观点，觉得应该使用 python 多进程来代替多线程的需求，因为多进程不受 GIL 的限制。于是我便动手使用多进程去解决一些并发问题，期间也遇到了一些坑，所幸大部分查找资料解决了，然后对多进程做了简单汇总介绍 Python 多进程。 那么是否多进程能完全替代多线程呢？别急，我们继续往下看。 观点：协程为最佳方案 协程的概念目前来说是比较火热的，协程不同于线程的地方在于协程不是操作系统进行切换，而是由程序员编码进行切换的，也就是说切换是由程序员控制的，这样就没有了线程所谓的安全问题。协程的概念非常广而深，本文暂不做具体介绍，以后会单独成文。 测试数据 好了，网上的观点无非是使用多进程或者协程来代替多线程（当然换编程语言，换解释器之类方法除外），那么我们就来测试下这三者的性能之差。既然要公平测试，就应该考虑 IO 密集型与 CPU 密集型的问题，所以分两组数据进行测试。 IO 密集型测试 测试 IO 密集型，我选择最常用的爬虫功能，计算爬虫访问 bing 所需要的时间。（主要测试多线程与协程，单线程与多进程就不测了，因为没有必要）测试代码： 12345678910111213141516171819202122232425262728293031323334#! -*- coding:utf-8 -*-from gevent import monkey;monkey.patch_all()import geventimport timeimport threadingimport urllib2def urllib2_(url): try: urllib2.urlopen(url,timeout=10).read() except Exception,e: print edef gevent_(urls): jobs=[gevent.spawn(urllib2_,url) for url in urls] gevent.joinall(jobs,timeout=10) for i in jobs: i.join()def thread_(urls): a=[] for url in urls: t=threading.Thread(target=urllib2_,args=(url,)) a.append(t) for i in a: i.start() for i in a: i.join()if __name__=="__main__": urls=["https://www.bing.com/"]*10 t1=time.time() gevent_(urls) t2=time.time() print 'gevent-time:%s' % str(t2-t1) thread_(urls) t4=time.time() print 'thread-time:%s' % str(t4-t2) 测试结果：访问 10 次gevent-time:0.380326032639thread-time:0.376606941223访问 50 次gevent-time:1.3358900547thread-time:1.59564089775访问 100 次gevent-time:2.42984986305thread-time:2.5669670105访问 300 次gevent-time:6.66330099106thread-time:10.7605059147从结果可以看出，当并发数不断增大时，协程的效率确实比多线程要高，但在并发数不是那么高时，两者差异不大。 CPU 密集型CPU 密集型，我选择科学计算的一些功能，计算所需时间。（主要测试单线程、多线程、协程、多进程）测试代码： 12345678910111213141516171819202122232425262728293031323334#! -*- coding:utf-8 -*-from multiprocessing import Process as profrom multiprocessing.dummy import Process as thrfrom gevent import monkey;monkey.patch_all()import geventdef run(i): lists=range(i) list(set(lists)) if __name__=="__main__": ''' 多进程 ''' for i in range(30): ##10-2.1s 20-3.8s 30-5.9s t=pro(target=run,args=(5000000,)) t.start() ''' 多线程 ''' # for i in range(30): ##10-3.8s 20-7.6s 30-11.4s # t=thr(target=run,args=(5000000,)) # t.start() ''' 协程 ''' # jobs=[gevent.spawn(run,5000000) for i in range(30)] ##10-4.0s 20-7.7s 30-11.5s # gevent.joinall(jobs) # for i in jobs: # i.join() ''' 单线程 ''' # for i in range(30): ##10-3.5s 20-7.6s 30-11.3s # run(5000000) 测试结果： 并发 10 次：【多进程】2.1s 【多线程】3.8s 【协程】4.0s 【单线程】3.5s 并发 20 次：【多进程】3.8s 【多线程】7.6s 【协程】7.7s 【单线程】7.6s 并发 30 次：【多进程】5.9s 【多线程】11.4s 【协程】11.5s 【单线程】11.3s 可以看到，在 CPU 密集型的测试下，多进程效果明显比其他的好，多线程、协程与单线程效果差不多。这是因为只有多进程完全使用了 CPU 的计算能力。在代码运行时，我们也能够看到，只有多进程可以将 CPU 使用率占满。 本文结论 从两组数据我们不难发现，python 多线程并没有那么鸡肋。如若不然，Python3 为何不去除 GIL 呢？对于此问题，Python 社区也有两派意见，这里不再论述，我们应该尊重 Python 之父的决定。 至于何时该用多线程，何时用多进程，何时用协程？想必答案已经很明显了。 当我们需要编写并发爬虫等 IO 密集型的程序时，应该选用多线程或者协程（亲测差距不是特别明显）；当我们需要科学计算，设计 CPU 密集型程序，应该选用多进程。当然以上结论的前提是，不做分布式，只在一台服务器上测试。 答案已经给出，本文是否就此收尾？既然已经论述 Python 多线程尚有用武之地，那么就来介绍介绍其用法吧。 Multiprocessing.dummy 模块Multiprocessing.dummy 用法与多进程 Multiprocessing 用法类似，只是在 import 包的时候，加上. dummy。用法参考 Multiprocessing 用法 threading 模块 这是 python 自带的 threading 多线程模块，其创建多线程主要有 2 种方式。一种为继承 threading 类，另一种使用 threading.Thread 函数，接下来将会分别介绍这两种用法。 Usage【1】利用 threading.Thread() 函数创建线程。代码： 12345def run(i): print ifor i in range(10): t=threading.Thread(target=run,args=(i,)) t.start() 说明：Thread() 函数有 2 个参数，一个是 target，内容为子线程要执行的函数名称；另一个是 args，内容为需要传递的参数。创建完子线程，将会返回一个对象，调用对象的 start 方法，可以启动子线程。 线程对象的方法： Start() 开始线程的执行 Run() 定义线程的功能的函数 Join(timeout=None) 程序挂起，直到线程结束；如果给了 timeout，则最多阻塞 timeout 秒 getName() 返回线程的名字 setName() 设置线程的名字 isAlive() 布尔标志，表示这个线程是否还在运行 isDaemon() 返回线程的 daemon 标志 setDaemon(daemonic) 把线程的 daemon 标志设为 daemonic（一定要在 start（）函数前调用） t.setDaemon(True) 把父线程设置为守护线程，当父进程结束时，子进程也结束。 threading 类的方法： threading.enumerate() 正在运行的线程数量 Usage【2】通过继承 threading 类，创建线程。代码： 1234567891011121314import threadingclass test(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): try: print "code one" except: passfor i in range(10): cur=test() cur.start()for i in range(10): cur.join() 说明：此方法继承了 threading 类，并且重构了 run 函数功能。 获取线程返回值问题 有时候，我们往往需要获取每个子线程的返回值。然而通过调用普通函数，获取 return 值的方式在多线程中并不适用。因此需要一种新的方式去获取子线程返回值。代码： 12345678910111213141516import threadingclass test(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): self.tag=1 def get_result(self): if self.tag==1: return True else: return Falsef=test()f.start()while f.isAlive(): continueprint f.get_result() 说明：多线程获取返回值的首要问题，就是子线程什么时候结束？我们应该什么时候去获取返回值？可以使用 isAlive() 方法判断子线程是否存活。 控制线程运行数目当需要执行的任务非常多时，我们往往需要控制线程的数量，threading 类自带有控制线程数量的方法。代码： 12345678910111213141516171819import threadingmaxs=10 ##并发的线程数量threadLimiter=threading.BoundedSemaphore(maxs)class test(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): threadLimiter.acquire() #获取 try: print "code one" except: pass finally: threadLimiter.release() #释放for i in range(100): cur=test() cur.start()for i in range(100): cur.join() 说明：以上程序可以控制多线程并发数为 10，超过这个数量会引发异常。除了自带的方法，我们还可以设计其他方案： 1234567891011121314151617threads=[]'''创建所有线程'''for i in range(10): t=threading.Thread(target=run,args=(i,)) threads.append(t)'''启动列表中的线程'''for t in threads: t.start() while True: #判断正在运行的线程数量,如果小于5则退出while循环, #进入for循环启动新的进程.否则就一直在while循环进入死循环 if(len(threading.enumerate())&lt;5): break 以上两种方式皆可以，本人更喜欢用下面那种方式。 线程池12345678910111213141516import threadpooldef ThreadFun(arg1,arg2): passdef main(): device_list=[object1,object2,object3......,objectn]#需要处理的设备个数 task_pool=threadpool.ThreadPool(8)#8是线程池中线程的个数 request_list=[]#存放任务列表 #首先构造任务列表 for device in device_list: request_list.append(threadpool.makeRequests(ThreadFun,[((device, ), &#123;&#125;)])) #将每个任务放到线程池中，等待线程池中线程各自读取任务，然后进行处理，使用了map函数，不了解的可以去了解一下。 map(task_pool.putRequest,request_list) #等待所有任务处理完成，则返回，如果没有处理完，则一直阻塞 task_pool.poll()if __name__=="__main__": main() 参考：Python多线程鸡年不鸡肋 | nMask’s Bloghttps://thief.one/2017/02/17/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%B8%A1%E5%B9%B4%E4%B8%8D%E9%B8%A1%E8%82%8B/python异步并发模块concurrent.futures简析 | 大爱http://lovesoo.org/analysis-of-asynchronous-concurrent-python-module-concurrent-futures.html【Multiprocessing系列】Multiprocessing基础 | nMask’s Bloghttps://thief.one/2016/11/23/Python-multiprocessing/]]></content>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[史上最简单的 MySQL 教程]]></title>
    <url>%2F2018%2F04%2F10%2F2018-04-10%2F</url>
    <content type="text"><![CDATA[（一）「数据库」数据库1 定义数据库，可以简单的解释为：高效的存储和处理数据的介质（主要分为磁盘和内存两种）。 2 分类根据数据库存储介质的不同，可以将其分为两类，即：关系型数据库（SQL）和非关系型数据库（NoSQL，Not Only SQL）。 3 举例关系型数据库： 大型：Oracle、DB2 等； 中型：SQL Server、MySQL 等； 小型：Access 等。 非关系型数据库： Memcached、MongoDB 和 Redis 等。 4 区别关系型数据库： 安全，其将数据保存到磁盘之中，基本不可能出现丢失数据的情况； 比较浪费空间，因为其用二维表的形式存储数据。 非关系型数据库： 存储数据的效率比较高； 不是特别安全，突然断电时会导致数据丢失。 （二）「关系型数据库」关系型数据库1 定义关系型数据库，是一种建立在关系模型（数学模型）上的数据库。 至于关系模型，则是一种所谓建立在关系上的模型，其包含三个方面，分别为： 数据结构：数据存储的形式，二维表（行和列）； 操作指令集合：所有的 SQL 语句； 完整性约束：表内数据约束（字段与字段）和表与表之间的约束（外键）。 2 设计 数据库：从需要存储的数据需求中分析，如果是一类数据（实体），则应该设计成二维表； 二维表：由表头（字段名，用来规定数据的名称）和数据（实际存储的内容）部分组成。 在此处，需要特别注意：如果表中对应的某个字段值为空，但是系统依然会为其分配存储空间，这也就是关系型数据库比较浪费空间的原因啦！ 3 关键字说明 DB：Database，数据库； DBMS：Database Management System，数据库管理系统； DBS：Database System = DBMS + DB，数据库系统； DBA：Database Administrator，数据库管理员。 行\记录：row\record，本质都是指表中的一行（一条记录），行是从结构角度出发，记录则是从数据角度出发。 列\字段：column\field，本质都是指表中的一列（一个字段），列是从结构角度出发，字段则是从数据角度出发。 4 SQLSQL：Structured Query Language，结构化查询语言（数据以查询为主，99% 都是在进行查询操作）。 SQL 主要分为三种： DDL：Data Definition Language，数据定义语言，用来维护存储数据的结构（数据库、表），代表指令为create、drop和alter等。 DML：Data Manipulation Language，数据操作语言，用来对数据进行操作（表中的内容）代表指令为insert、delete和update等，不过在 DML 内部又单独进行了一个分类，即 DQL（Data Query Language），数据查询语言，代表指令为select. DCL：Data Control Language，数据控制语言，主要是负责（用户）权限管理，代表指令为grant和revoke等。 SQL 是关系型数据库的操作指令，是一种约束，但不强制，类似于 W3C，因此这意味着：不同的数据库产品（如 Oracle 和 MySQL）内部可能会有一些细微的区别。 （三）「 MySQL 数据库」MySQL 数据库MySQL 数据库是一种C\S结构的软件，即分为：客户端和服务端。 若想访问服务器，则必须通过客户端；服务器应该一直运行，客户端则在需要使用的时候运行。 交互方式 客户端连接认证，即连接服务器，认证身份mysql.exe -hPup -h，主机地址，本地为localhost，远程为IP地址 -P，端口号，用来找软件 -u，用户名 -p，密码 发送 SQL 指令； 服务器接受 SQL 指令，然后处理 SQL 指令并返回操作结果； 客户端接受结果并显示结果； 由于服务器并发限制，需要断开连接（三种指令，分别为：exit、quit和\q），释放资源。 服务器对象由于没办法完全了解服务器内部的结构，因此只能粗略的分析数据库服务器的内部结构。 一般来说，将 MySQL 数据库服务器的内部对象分为四层，分别为：数据管理系统（DBMS）–&gt; 数据库（DB）–&gt; 表（Table）–&gt; 字段（Filed）. （四）「SQL 基本操作」SQL 基本操作基本操作：CURD，即增删改查。 根据操作对象的不同，咱们可以将 SQL 的基本操作分为三类，分别为：库操作、表（字段）操作和数据操作。 库操作1 新增数据库 基本语法：create database + 数据库名称 + [库选项]; 其中，库选项是用来约束数据库的，为可选项（有默认值），共有两种，分别为： 字符集设定：charset/ character set+ 具体字符集，用来表示数据存储的编码格式，常用的字符集包括GBK和UTF8等。 校对集设定：collate+ 具体校对集，表示数据比较的规则，其依赖字符集。 示例：create database TBL_ERROR_CODE charset utf8; 其中，数据库的名字不能用关键字（已经被占用的字符，例如 update 和 insert 等）或者保留字（将来可能会用的，例如 access 和 cast 等）。 如果非要使用数据库的关键字或者保留字作为数据库名称，那么必须用反引号将其括起来，例如： create databaseaccesscharset utf8; 如果还想使用中文作为数据库的名称，那就得保证数据库能够识别中文（强烈建议不要用中文命名数据库的名称），例如： 123-- 设置中文名称的方法，其中 gbk 为当前数据库的默认字符集set names gbk;create database 北京 charset gbk; 2 查询数据库 查看全部 –&gt; 基本语法：show databases; 查看部分（模糊查询）–&gt; 基本语法：show databases like &#39;pattern&#39;; 其中，pattern是匹配模式，有两种，分别为： %：表示匹配多个字符； _：表示匹配单个字符。 此外，在匹配含有下划线_的数据库名称的时候，需要在下划线前面加上反斜线\_进行转义操作。 示例：show databases like &#39;TBL%&#39;;表示匹配所有TBL开头的数据库。 查看数据库的创建语句 –&gt; 基本语法：show create database + 数据库名称; 在这里，查看的结果有可能与咱们书写的 SQL 语句不同，这是因为数据库在执行 SQL 语句之前会优化 SQL，系统保存的是优化后的结果。 3 更新数据库 在这里，需要注意：数据库的名字不可以修改。 数据库的修改仅限库选项，即字符集和校对集（校对集依赖字符集）。 基本语法：alter database + 数据库名称 + [库选项]; charset/character set[=] 字符集; collate[=] 校对集; 示例：alter database TBL_ERROR_CODE charset gbk;表示修改此数据库的字符集为gbk. 4 删除数据库 基本语法：drop database + 数据库名称; 在这里，需要注意：在删除数据库之前，应该先进行备份操作，因为删除为不可逆操作，所以不要随意删除数据库。 表操作1 新增表 基本语法：12345create table [if not exists] + 表名( 字段名称 数据类型, …… 字段名称 数据类型 /* 最后一行，不需要加逗号 */)[表选项]; 其中，if not exists表示 如果表名不存在，就执行创建代码；如果表名存在，则不执行创建代码。 表选项则是用来控制表的表现形式的，共有三种，分别为： 字符集设定：charset/ character set+ 具体字符集，用来表示数据存储的编码格式，常用的字符集包括GBK和UTF8等。 校对集设定：collate+ 具体校对集，表示数据比较的规则，其依赖字符集。 存储引擎：engine+具体存储引擎，默认为InnoDB，常用的还有MyISAM. 由于任何表都归属于某个数据库，因此在创建表的时候，都必须先指定具体的数据库。在这里，指定数据库的方式有两种，分别为： 第 1 种：显式的指定表所属的数据库，示例 12345create table if not exists test.student( name varchar(10), age int, /* 整型不需要指定具体的长度 */ grade varchar(10) /* 最后后一行，不需要加逗号 */)charset utf8; 第 2 种：隐式的指定表所属的数据库，示例 123456use test; /* use + 数据库名称，表示切换到指定的数据库，这句命令其实不加分号也可以，但不建议这么做 */create table if not exists student( name varchar(10), age int, /* 整型不需要指定具体的长度 */ grade varchar(10) /* 最后后一行，不需要加逗号 */)charset utf8; 2 查询表 查看全部 –&gt; 基本语法：show tables; 查看部分（模糊查询）–&gt; 基本语法：show tables like &#39;pattern&#39;; 其中，pattern是匹配模式，有两种，分别为： %：表示匹配多个字符； _：表示匹配单个字符。 此外，在匹配含有下划线_的表名的时候，需要在下划线前面加上反斜线\_进行转义操作。 示例：show tables like &#39;%t&#39;;表示匹配所有以t结尾的表。 查看表的创建语句 –&gt; 基本语法：show create table + 表名; 在这里，咱们也可以用\g和\G代替上述语句中的;分号，其中\g等价于分号，\G则在等价于分号的同时，将查的表结构旋转90度，变成纵向结构。 查看表中的字段信息 –&gt; 基本语法：desc/describe/show columns from + 表名; 3 更新表 在这里，需要注意：表的修改，分为修改表本身和修改表中的字段。 第 1 类：修改表本身 修改表名，基本语法：rename table 旧表名 to 新表名; 修改表选项，基本语法：alter table + 表名 + 表选项[=] + 值; 第 2 类：修改表中的字段，新增、修改、重命名和删除 新增字段，基本语法：alter table + 表名 + add + [column] + 字段名 + 数据类型 + [列属性][位置]; 其中，位置表示此字段存储的位置，分为first（第一个位置）和after + 字段名（指定的字段后，默认为最后一个位置）. 示例：alter table student add column id int first; 修改字段，基本语法：alter table + 表名 + modify + 字段名 + 数据类型 + [列属性][位置]; 其中，位置表示此字段存储的位置，分为first（第一个位置）和after + 字段名（指定的字段后，默认为最后一个位置）. 示例：alter table student modify name char(10) after id; 重命名字段，基本语法：alter table + 表名 + change + 旧字段名 + 新字段名 + 数据类型 + [列属性][位置]; 其中，位置表示此字段存储的位置，分为first（第一个位置）和after + 字段名（指定的字段后，默认为最后一个位置）. 示例：alter table student change grade class varchar(10); 删除字段，基本语法：alter table + 表名 + drop+ 字段名; 示例：alter table student drop age; 注意：如果表中已经存在数据，那么删除该字段会清空该字段的所有数据，而且不可逆，慎用。 4 删除表 基本语法： 12-- 可以一次删除多张表drop table + 表1, 表2 ... ; 在这里，需要注意：此删除为不可逆操作，希望大家谨慎使用。 数据操作1 新增数据 对于数据的新增操作，有两种方法。 第 1 种：给全表字段插入数据，不需要指定字段列表，但要求数据的值出现的顺序必须与表中的字段出现的顺序一致，并且凡是非数值数据，都需要用引号（建议使用单引号）括起来。 基本语法：insert into + 表名 + values(值列表)[,(值列表)]; 示例：insert into test valus(&#39;charies&#39;,18,&#39;3.1&#39;); 第 2 种：给部分字段插入数据，需要选定字段列表，字段列表中字段出现的顺序与表中字段的顺序无关，但值列表中字段值的顺序必须与字段列表中的顺序保持一致。 基本语法：insert into + 表名(字段列表) + values(值列表)[,(值列表)]; 示例：insert into test(age,name) valus(18,&#39;guo&#39;); 2 查询数据 查看全部 –&gt; 基本语法：select * from + 表名 + [where 条件]; 示例：select * from test; 查看部分 –&gt; 基本语法：select + 字段名称[,字段名称] + from + 表名 + [where 条件]; 示例：select name,age,grade from test where age = &#39;18&#39;; 3 更新数据 基本语法：update + 表名 + set + 字段 = 值 + [where 条件]; 示例：update test set age = 20 where name = &#39;guo&#39;; 在这里，建议尽量加上where条件，否则的话，操作的就是全表数据。 此外，判断更新操作是否成功，并不是看 SQL 语句是否执行成功，而是看是否有记录受到影响，即affected的数量大于1时，才是真正的更新成功。 4 删除数据 基本语法：delete from + 表名 + [where 条件]; 示例：delete from test where grade = &#39;3.1&#39;; 当然，我们也可以用drop来实现删除操作，不过与delete相比，drop的威力更强，其在执行删除操作的时候，不仅会删除数据，还会删除定义并释放存储空间；而delete在执行删除操作的时候，仅会删除数据，并不会删除定义和释放存储空间。 温馨提示：用符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （五）「中文数据问题」中文数据问题中文数据问题的本质就是字符集的问题。 由于计算机仅识别二进制数据，而且人类则更倾向于识别字符（符号），因此就需要一个二进制与字符的对应关系，也就是字符集。 在咱们通过 MySQL 数据库的客户端向服务器插入中文数据的时候，有可能失败，原因则可能是客户端和服务器的字符集设置不同导致的，例如： 客户端的字符集为gbk，则一个中文字符，对应两个字节； 服务器的字符集为utf8，则一个中文字符，对应三个字节。 这样显然会在编码转换的过程中出现问题，从而导致插入中文数据失败。 由于所有的数据库服务器表现的一些特性都是通过服务器端的变量来保持的，因此系统会先读取自己的变量，看看具体的表现形式。这样的话，咱们就可以通过以下语句查看服务器到底识别哪些字符集： 12-- 查看服务器识别的全部字符集show character set; 通过以上查询，咱们会发现：服务器是万能的，其支持所有字符集。 既然服务器支持这么多字符集，总会有一种是服务器默认的和客户端打交道的字符集。因此，咱们可以通过以下语句查看服务器默认的对外处理的字符集： 12-- 查看服务器默认的对外处理的字符集show variables like &apos;character_set%&apos;; 标注1：服务器默认的客户端传来的数据字符集为utf8； 标注2：连接层字符集为utf8； 标注3：当前数据库的字符集为utf8； 标注4：服务器默认的对外处理的字符集utf8. 通过以上查询，咱们会发现：服务器默认的对外处理的字符集是utf8. 那么反过来，咱们在通过客户端的属性查看客户端支持的字符集： 显然，咱们已经找到了问题的根源，确实是：客户端支持的字符集为gbk，而服务器默认的对外处理的字符集为utf8，因此产生矛盾。 既然问题已经找到了，那么解决方案就是：修改服务器默认接收的字符集为gbk. 12-- 修改服务器默认接收的字符集为 GBK（不区分大小写）set character_set_client = gbk; 这样的话，咱们再插入中文数据的时候，就会插入成功啦！But，在咱们查看数据的时候，又发现了一个问题，就是之前咱们插入的中文数据显示乱码啦！不过这也正常，因为查询的时候，数据的来源是服务器（utf8），解析数据的是客户端，而客户端仅识别gbk格式的数据，显示乱码也就在意料之中啦！ 因此，解决方案就是：修改服务器给客户端的数据字符集为gbk. 12-- 修改服务器给客户端的数据字符集为 GBK（不区分大小写）set character_set_results = gbk; 如上图所示，向服务器插入中文数据的问题已经解决啦！ 此外，咱们之前使用的 SQL 语句： 12-- 修改的只是会话级别，即当前客户端当次连接有效，关闭后失效set 变量 = 值; 这样的话，每当咱们重启客户端的时候，都要依次重新进行设置，比较麻烦，因此咱们可以使用快捷的设置方式，即： 1set names 字符集; 例如， 123456/*** 恒等于 set character_set_client = gbk;* 恒等于 set character_set_results = gbk;* 恒等于 set character_set_connection = gbk;*/set names gbk; 表示上述一条语句，将同时改变三个变量的值。其中，connection为连接层，是字符集转换的中间者，如果其和client和results的字符集一致，则效率更高，不一致也没有关系。 （六）「校对集问题」校对集问题校对集，其实就是数据的比较方式。 校对集，共有三种，分别为： _bin：binary，二进制比较，区分大小写； _cs：case sensitive，大小写敏感，区分大小写； _ci：case insensitive，大小写不敏感，不区分大小写。 查看（全部）校对集 –&gt; 基本语法：show collation; 如上图所示，MySQL 数据库支持百多种校对集。 接下来，咱们在一起看看校对集的应用，因为只有当数据进行比较的时候，校对集才会生效。在这里，咱们用utf8的_bin和_ci两种校对集进行比较： 12345678-- 创建两张使用不同校对集的表create table my_collate_bin( name char(10))charset utf8 collate utf8_bin;create table my_collate_ci( name char(10))charset utf8 collate utf8_general_ci; 如上图所示，咱们创建了两张表，分别为my_collate_bin和my_collate_ci，其校对集分别为_bin和_ci. 然后，分别向这两张表中添加数据： 123-- 向表中添加数据insert into my_collate_bin values (&apos;a&apos;),(&apos;A&apos;),(&apos;B&apos;),(&apos;b&apos;);insert into my_collate_ci values (&apos;a&apos;),(&apos;A&apos;),(&apos;B&apos;),(&apos;b&apos;); 再分别查看两张表中的数据： 123-- 查看表中的数据select * from my_collate_bin;select * from my_collate_ci; 下面，咱们根据表中的某个字段（在这里my_collate_bin和my_collate_ci都仅有一个字段）进行排序，其基本语法为： 1order by + 字段名 + [asc/desc]; 其中，asc表示升序，desc表示降序，默认为升序。执行如下 SQL 语句： 123-- 排序比较select * from my_collate_bin order by name;select * from my_collate_ci order by name; 如上图所示，显然校对集生效啦！ 此外，咱们需要特别注意的是： 校对集必须在没有数据之前声明好，如果有了数据之后，再进行校对集的修改，则修改无效。 温馨提示：用符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （七）「列类型」列类型（数据类型）所谓的列类型，其实就是指数据类型，即对数据进行统一的分类，从系统的角度出发是为了能够使用统一的方式进行管理，更好的利用有限的空间。 在 SQL 中，将数据类型分成了三大类，分别为：数值型、字符串型和日期时间型。 对于数值型数据，可以进一步将其划分为整数型和小数型。 整数型在 SQL 中，由于要考虑节省磁盘空间的问题，因此系统又将整型细分成五类，分别为： tinyint：迷你整型，使用 1 个字节存储数据（常用）； smallint：小整型，使用 2 个字节存储数据； mediumint：中整型，使用 3 个字节存储数据； int：标准整型，使用 4 个字节存储数据（常用）； bigint：大整型，使用 8 个字节存储数据。 接下来，输入如下 SQL 语句进行测试： 1234567-- 创建整型表create table my_int( int_1 tinyint, int_2 smallint, int_3 int, int_4 bigint)charset utf8; 如上图所示，咱们已经成功创建my_int表，再插入数据： 1234-- 插入数据insert into my_int values (1,2,3,4);insert into my_int values (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;);insert into my_int values (255,2,3,4); 如上图所示，通过列类型，咱们可以限定插入数据的类型以及长度范围。 至于为什么在对int_1赋值时，报出超出范围的错误，则是因为在 SQL 中数值类型默认是有符号位的，即分正负。如果需要使用无符号的数据，这就需要咱们自己对数据类型进行声明啦，即在声明数据类型时，追加unsigned关键字。例如： 12-- 在 my_int 表中，添加 int_5 字段，设置其数据类型为 tinyint unsignedalter table my_int add int_5 tinyint unsigned; 如上图所示，添加int_5字段成功，继续插入数据： 12-- 插入数据insert into my_int values (1,2,3,4,255); 如上图所示，当咱们将tinyint限定为unsigned之后，已经可以插入0~255之间的任何整数啦！但是，回过头来，让咱们仔细看看下面这张图： 通过观察上面这张图，咱们会发现：每个字段的数据类型后面都会跟着一对括号，并且里面含有数字。这些数字啊，其实并没有什么特别的含义，只是表示数据的显示宽度。实际上，咱们可以修改显示的宽度，但是这种修改并不会改变数据本身的大小。 显示宽度的意义：在于当数据不够显示宽度的时候，会自动让数据变成对应的显示宽度，通常需要搭配一个前导0来增加宽度，其不改变数据值的大小，即用zerofill进行零填充，并且零填充会导致数值自动变成无符号。 下面，执行如下 SQL 语句： 12-- 在 my_int 表中，添加 int_6 字段，设置其数据类型为 tinyint zerofillalter table my_int add int_6(3) tinyint zerofill; 再插入数据，进行测试： 12-- 插入数据insert into my_int values (1,2,3,4,5,6); 如上图所示，零填充的意义：在于保证数据的格式。 小数型小数型，即带有小数点或者范围超出整型的数值类型。 在 SQL 中，将小数型细分为浮点型和定点型两种，其中： 浮点型：小数点浮动，精度有限，容易丢失精度； 定点型：小数点固定，精度固定，不会丢失精度。 第 1 种：浮点型 浮点型数据是一种精度型数据，因为超出指定范围之后，其会丢失精度，自动进行四舍五入操作。理论上，浮点型分为两种精度： float：单精度，占用 4 个字节存储数据，精度范围大概为 7 位左右； double：双精度，占用 8 个字节存储数据，精度范围大概为 15 位左右。 浮点型的使用方式：如果直接用float，则表示没有小数部分；如果用float(M,D)，其中M代表总长度，D代表小数部分长度，M-D则为整数部分长度。 执行如下 SQL 语句创建浮点数表，进行测试： 123456-- 创建浮点数表create table my_float( f1 float, f2 float(10,2), f3 float(6,2))charset utf8; 在咱们向浮点数表my_float插入数据的时候，可以直接插入小数，也可以插入用科学计数法表示的数据。此外，插入浮点型数据时，整数部分是不能超出长度范围的，但是小数部分是可以超出长度范围的，系统会自动进行四舍五入的操作。特别是，如果浮点数是因为系统进位（四舍五入）导致整数部分超出指定的长度，那么系统是允许成立的。 1234-- 插入测试数据insert into my_float values (2.15e4,20.15,9999.99);insert into my_float values (20151120,123456789.99,9999.99);insert into my_float values (5211314,123456.99,99.99999); 如上图所示，咱们的结论得到了验证。 第 2 种：定点型 定点型数据，绝对的保证整数部分不会被四舍五入，也就是说不会丢失精度，但小数部分有可能丢失精度，虽然理论上小数部分也不会丢失精度。 执行如下 SQL 语句创建定点数表，以浮点数做对比，进行测试： 12345-- 创建定点数表create table my_decimal( f1 float(10,2), d1 decimal(10,2))charset utf8; 当咱们插入数据的时候，定点数的整数部分一定不能超出长度范围（进位也不可以），小数部分的长度则可以随意超出，没有限制，系统会自动进行四舍五入的操作： 1234-- 插入测试数据insert into my_decimal values (99999999.99,99999999.99);insert into my_decimal values (123456789.99,2015.1314);insert into my_decimal values (123456.99,2015.1314); 如上图所示，咱们的结论同样得到了验证。 日期时间型日期时间型数据，顾名思义，就是用来表示日期和时间的数据类型，共有五种类型，分别为： datetime：日期时间，其格式为yyyy-MM-dd HH:mm:ss，表示的范围是从 1000 年到 9999 年，有零值，即0000-00-00 0000:00； date：日期，就是datetime的date部分； time：时间，或者说是时间段，为指定的某个时间区间之间，包含正负时间； timestamp：时间戳，但并不是真正意义上的时间戳，其是从1970年开始计算的，格式和datetime一致； year：年份，共有两种格式，分别为year(2)和year(4). 执行如下 SQL 语句创建日期时间表，进行测试： 12345678-- 创建日期时间表create table my_date( d1 datetime, d2 date, d3 time, d4 timestamp, d5 year)charset utf8; 当咱们插入数据时，日期时间型中的time，可以为负数，甚至可以是很大的负数；year，可以使用 2 位数据插入，也可以使用 4 位数据插入；timestamp，只要当前所在的记录被更新，该字段就会自动更新为当前时间，且时间戳类型默认为非空的。 1234-- 插入测试数据insert into my_date values (&apos;2017-05-06 13:15:00&apos;,&apos;2017-05-06&apos;,&apos;13:15:00&apos;,&apos;2017-05-06 13:15:00&apos;,2017);insert into my_date values (&apos;2017-05-06 13:15:00&apos;,&apos;2017-05-06&apos;,&apos;-113:15:00&apos;,&apos;2017-05-06 13:15:00&apos;,69);insert into my_date values (&apos;2017-05-06 13:15:00&apos;,&apos;2017-05-06&apos;,&apos;-2 13:15:00&apos;,&apos;2017-05-06 13:15:00&apos;,70); 如上图所示，以上 3 条记录已经插入成功，接下来，咱们再来验证更新记录时，时间戳类型的字段d4是否会自动更新： 12-- 更新记录，验证时间戳类型的字段是否会自动更新update my_date set d1 = &apos;2017-05-06 13:24:00&apos; where d5 = 1970; 如上图所示，显然咱们的结论全部得到了验证。 字符串型在 SQL 中，将字符串类型分成了 6 类，分别为：char、varchar、text、blob、enum和set. 第 1 类：定长字符串 定长字符串：char，即磁盘（二维表）在定义结构的时候就已经确定了最终数据的存储长度。 char(L)：L 表示 Length，即可以存储的长度，单位为字符，最大长度为 255； char(4)：表示在 UTF8 环境下，需要 4*3=12 个字节。 第 2 类：变长字符串 变长字符串：varchar，即在分配存储空间的时候，按照最大的空间分配，但是实际用了多少，则是根据具体的数据来确定。 varchar(L)：L 表示 Length，理论长度是 65536，但是会多出 1 到 2 个字节来确定存储的实际长度； varchar(10)：例如存储 10 个汉字，在 UTF8 环境下，需要 10*3+1=31 个字节。 实际上，如果存储长度超过 255 个字符，则既不用定长字符串也不用变长字符串，而是用文本字符串text. 如何选择定长字符串或者是变长字符串呢？ 定长字符串对磁盘空间比较浪费，但是效率高：如果数据基本上确定长度都一样，就使用定长字符串，例如身份证、电话号码等； 变长字符串对磁盘空间比较节省，但是效率低：如果数据不能确定长度（不同的数据有变化），就使用变长字符串，例如地址、姓名等。 第 3 类：文本字符串 如果数据量非常大，通常说超过 255 个字符就会使用文本字符串。 文本字符串根据存储的格式进行分类，可以分为： text：存储文字； blob：存储二进制数据（其实际上都是存储路径），通常不用。 第 4 类：枚举字符串 枚举字符串：enum，需要事先将所有可能出现的结果都设计好，实际上存储的数据必须是规定好的数据中的一个。 枚举字符串的使用方式： 定义：enum(&#39;元素1&#39;,&#39;元素2&#39;,&#39;元素3&#39;...)，例如enum(&#39;男&#39;,&#39;女&#39;,&#39;保密&#39;)； 使用：存储的数据，只能是事先定义好的数据。 执行如下 SQL 语句创建枚举表，进行测试： 1234-- 创建枚举表create table my_enum( gender enum(&apos;男&apos;,&apos;女&apos;,&apos;保密&apos;))charset utf8; 再执行如下 SQL 语句，向表my_enum中插入测试数据： 123-- 插入测试数据insert into my_enum values (&apos;男&apos;),(&apos;女&apos;),(&apos;保密&apos;);insert into my_enum values (&apos;male&apos;); 通过上面的测试，咱们可以发现使用枚举字符串有一个好处，那就是：规范数据格式，插入表中的数据只能是事先定义好的某个数据。 此外，枚举字符串还有一个作用，那就是：节省存储空间（枚举数据通常都有一个别名），枚举实际上存储的是数值而不是字符串本身。 在 MySQL 中，系统是有自动转换数据格式的功能的。在这里，咱们可以证明枚举字段存储的是数值，具体方法为：将数据取出来+0，如果是字符串最终结果永远为0，否则就是其他值。 12-- 验证枚举字段实际存储的格式select gender + 0,gender from my_enum; 观察上述结果，咱们可以找出枚举元素的实际规律，即按照元素出现的顺序，从1开始编号。接下来，咱们再来了解枚举的原理： 枚举在进行数据规范（定义）的时候，系统会自动建立一个数字与枚举元素的对应关系（放在日志中）；在进行数据插入的时候，系统自动将字符串转换为对应的数值进行存储；在进行数据提取的时候，系统自动将数值转换成对应的字符串进行显示。 通过阅读以上枚举的原理，咱们可以知道：使用枚举的效率并不高（低于其他类型的数据），但能规范数据和节省存储空间。 第 5 类：集合字符串 集合字符串：set，跟枚举类似，实际存储的是数值而不是字符串。 集合字符串的使用方式： 定义：set，元素列表； 使用：可以使用元素列表中的多个元素，用逗号分隔。 执行如下 SQL 语句创建枚举表，进行测试： 1234-- 创建集合表create table my_set( hobby set(&apos;音乐&apos;,&apos;电影&apos;,&apos;旅行&apos;,&apos;美食&apos;,&apos;摄影&apos;,&apos;运动&apos;,&apos;宠物&apos;))charset utf8; 再执行如下 SQL 语句，向表my_set中插入测试数据：123-- 插入测试数据insert into my_set values (&apos;电影,美食,宠物&apos;);insert into my_set values (3); 再执行如下 SQL 语句，查看表my_set中的数据： 12-- 查看数据select hobby + 0,hobby from my_set; 观察上面的结果，相信大部分童鞋也懵啦！对于3还好理解，3=2+1，对应于集合中数据的编号，也正是音乐和电影；但是74是什么鬼啊？在此，咱们不妨将集合（&#39;音乐&#39;,&#39;电影&#39;,&#39;旅行&#39;,&#39;美食&#39;,&#39;摄影&#39;,&#39;运动&#39;,&#39;宠物&#39;）中的元素选中的记为1，没有选中的记为0，表示成二进制，也就是： 0101001 再将上面的二进制反过来： 1001010 不妨算算，上述二进制对应的十进制数，即为74. 到这里，相信大家已经恍然大悟啦，原来：集合字符串中每一个元素都对应一个二进制位，其中被选中的为1，未选中的为0，最后在反过来，这个二进制数对应的十进制数即为其数据库中实际存储的是数值。 此外，集合字符串中插入元素的顺序并没有影响，最终系统都会自动去匹配集合的顺序，即： 123-- 插入测试数据insert into my_set values (&apos;电影,美食,旅行&apos;);insert into my_set values (&apos;旅行,电影,美食&apos;); 上述两个 SQL 语句会产生相同的结果： 如上图所示，显然咱们的结论得到了验证。 最后，集合的原理同枚举类似，因此可以的到相同的结论，即：使用集合的效率并不高（低于其他类型的数据），但能规范数据和节省存储空间。 （八）「记录长度」记录长度MySQL 中规定：任何一条记录最长不超过 65535 个字节，这意味着varchar永远达不到理论最大值。 那么，varchar实际存储长度能达到多大呢？这由编码字符集决定。 下面，以varchar在UTF-8和GBK的情况为例，执行如下 SQL 语句，进行演示： 12345678-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值create table my_utf8( name varchar(65535))charset utf8;create table my_gbk( name varchar(65535))charset gbk; 观察上面的结果，发现咱们定义的字段name的长度超过限制啦，并且提示了其在utf8和gbk字符集下各自的最大值。那么，咱们修改 SQL 语句如下，并再次执行： 12345678-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值create table my_utf8( name varchar(21845))charset utf8;create table my_gbk( name varchar(32767))charset gbk; 观察上面的执行结果，好吧，仍然在报错，为什么呢？观察如下 SQL 语句，并执行： 12345678-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值create table my_utf8( name varchar(21844) -- 21844 * 3 + 2 = 65534)charset utf8;create table my_gbk( name varchar(32766) -- 32766 * 2 + 2 = 65534)charset gbk; 如上图所示，咱们已经创建成功啦！至于什么定义字段name的长度为21844和32766是由于： 21845 * 3 + 2 = 65537 &gt; 65535 32767 * 2 + 2 = 65536 &gt; 65535 因此，在提示的最大值的基础上各自减1. 至于，为什么还要加2，则是因为varchar为变长字符串，在其定义的时候，也就是说在分配存储空间的时候，都会自动多分配1到2个字节空间，因为咱们想要算最大的存储范围，所以加2. 在这里，细心的同学会发现一个问题，那就是：在咱们创建表my_utf8和my_gbk的时候，咱们仅用了65534个字节，还剩余一个字节。现在，如果咱们想要将65535个字节都用了，怎么办呢？好说，增加一个tinyint类型的字段即可： 12345678910-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值create table my_utf81( stuno tinyint, -- 1 name varchar(21844) -- 21844 * 3 + 2 = 65534)charset utf8;create table my_gbk1( stuno tinyint, -- 1 name varchar(32766) -- 32766 * 2 + 2 = 65534)charset gbk; 观察上面的结果，呃，竟然又出错啦！为什么啊？65534 + 1 = 65535，并没有超出范围啊！其实吧，之所以会出现这样的问题，是因为：在 MySQL 的记录中，如果有任何一个字段允许为空，那么系统就会自动从整个记录中保留一个字节来存储null，若想释放null所占的字节，则必须保证所有字段都不允许为空。 12345678910-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值create table my_utf82( stuno tinyint not null, -- 1 name varchar(21844) not null -- 21844 * 3 + 2 = 65534)charset utf8;create table my_gbk2( stuno tinyint not null, -- 1 name varchar(32766) not null -- 32766 * 2 + 2 = 65534)charset gbk; 如上图所示，咱们已经成功创建了表my_utf82和my_gbk2. 此外，在 MySQL 中，text文本字符串不占用记录长度，额外存储，但是text文本字符串也是属于记录的一部分，无论是在utf8还是在gbk字符集之中，其都占用记录中的10个字节长度，用来保存数据的地址以及长度。 （九）「列属性 之 空属性、列描述和默认值」列属性列属性：实际上，真正约束字段的是数据类型，但是数据类型的约束比较单一，因此就需要额外的一些约束来保证数据的有效性，这就是列属性。 列属性有很多，例如：null、not null、default、primary key、unique key、auto_increment和comment等。 空属性空属性有两个值，分别为：null和not null. 虽然默认数据库的字段基本都为空，但是实际上在真正开发的时候，要尽可能的保证数据不为空，因为空数据没有意义，也没办法参与运算。 执行如下 SQL 语句，进行演示： 12345-- 空属性演示create table my_class( grade varchar(20) not null, room varchar(20) null -- 显式声明为空，实际上，默认就为空)charset utf8; 列描述列描述：comment，表示描述，没有实际含义，是专门用来描述字段的，其会随着表创建语句自动保存，用来给程序员（数据库管理员）了解数据库使用。 执行如下 SQL 语句，进行演示： 12345-- 列描述演示create table my_friend( name varchar(20) not null comment &apos;姓名&apos;, age tinyint not null comment &apos;年龄&apos;)charset utf8; 默认值默认值：default，某一数据会经常性出现某个具体的值，因此可以在开始的时候就指定好，而在需要真实数据的时候，用户可以选择性的使用默认值。 执行如下 SQL 语句，进行演示： 123456-- 默认值演示create table my_default( name varchar(20) not null, age tinyint unsigned default 0, gender enum(&apos;男&apos;,&apos;女&apos;) default &apos;男&apos;)charset utf8; 如上图所示，在列属性Default中已经展示了age和gender字段的默认值，这说明咱们设置成功啦！接下来，咱们再演示如何使用默认值： 123-- 演示默认值的使用（即不该对应的字段赋值）insert into my_default (name) values (&apos;Charies&apos;);insert into my_default values (&apos;Guo&apos;,18,default); 观察上面的 SQL 语句及执行结果，相信大家已经知道如何使用默认值啦，即不给设置默认值的字段赋值或者用default代替相应的字段值。 （十）「列属性 之 主键」主键主键：primary key，表中主要的键，每张表只能有一个字段（复合主键，可以多个字段）使用此属性，用来唯一的约束该字段里面的数据，不能重复。 增加主键在 SQL 操作中，有 3 种方法可以给表增加主键，分别为： 第 1 种：在创建表的时候，直接在字段之后，添加primary key关键字 12345-- 增加主键create table my_pri1( name varchar(20) not null comment &apos;姓名&apos;, number char(10) primary key comment &apos;学号&apos;)charset utf8; 如上图所示，此方法的优点是清晰明了，缺点则是只能使用一个字段作为主键。 第 2 种：在创建表的时候，在所有的字段之后，使用primary key(主键字段列表)来创建主键（如果有多个字段作为主键，则称之为复合主键） 12345678-- 复合主键create table my_pri2( number char(10) not null comment &apos;学号&apos;, course char(10) not null comment &apos;课程编号&apos;, score tinyint unsigned default 60, -- 增加主键限制，学号和课程编号应该是对应的，具有唯一性 primary key(number,course))charset utf8; 第 3 种：当表创建完之后，额外追加主键，可以直接追加主键，也可以通过修改表字段的属性追加主键 12345-- 追加主键create table my_pri3( course char(10) not null comment &apos;课程编号&apos;, name varchar(10) not null comment &apos;课程名称&apos;)charset utf8; 在这里，追加主键有两种方式，分别为： alter table my_pri3 modify course char(10) primary key comment &#39;课程编号&#39;; -- 不建议使用 alter table my_pri3 add primary key(course); -- 推荐使用 如上图所示，咱们追加主键成功。不过，想要用此方法，有一个前提，那就是：表中对应字段的数据是不重复的，即保证唯一性。 主键约束主键约束，即主键对应的字符中的数据不允许重复，如果重复，则数据操作（主要是增和改）失败。 123-- 主键约束（冲突）测试insert into my_pri3 values(&apos;MATH00123&apos;,&apos;泛函分析&apos;);insert into my_pri3 values(&apos;MATH00123&apos;,&apos;非线性分析&apos;); 更新主键 &amp; 删除主键对于主键，没有办法直接更新，主键必须先删除，然后才能更新。 基本语法：alter table + 表名 + drop primary key; 执行如下 SQL 语句，进行测试：12-- 删除主键alter table my_pri3 drop primary key; 如上图所示，咱们已经成功删除表my_pri3的主键啦！想要增加主键，只需要通过前面讲的 3 种方法即可。 主键分类根据主键的字段类型，咱们可以将主键分为两类，分别为： 业务主键，即使用真实的业务数据作为主键，例如学号、课程编号等等，很少使用； 逻辑主键，即使用逻辑性的字段作为主键，字段没有业务含义，值有没有都没有关系，经常使用。 至此，咱们已经将主键的相关内容讲完啦！ 温馨提示：符号+表示连接的意思。 （十一）「列属性 之 自动增长」自动增长自动增长：auto_increment，当对应的字段，不给值，或者是默认值，或者是null的时候，就会自动的被系统触发，系统会从当前字段中取已有的最大值再进行+1操作，得到新的字段值。 自增长通过跟主键进行搭配使用，其特点为： 任何字段要做自增长，前提其本身必须是一个索引，即key栏有值； 自增长字段必须是数字（整型）； 每张表最多有一个自增长字段。 执行如下 SQL 语句，进行测试： 12345-- 自增长示例create table my_auto( id int primary key auto_increment, name varchar(20) not null)charset utf8; 使用自增长当自增长给定的值为null或者默认值的时候，就是触发自动增长。 1234-- 触发自增长insert into my_auto (name) values(&apos;Charies&apos;);insert into my_auto values(null,&apos;Guo&apos;);insert into my_auto values(default,&apos;ChariesGuo&apos;); 如上图所示，自增长的第一个元素默认是1，自增长每次都是自增1。此外，如果自增长对应的字段输入了值，那么自增长失效，但是下一次还是能够正确的自增长，即从取该字段的最大值+1. 那么，如何确定下一次自增长的数值是什么呢？简单，咱们可以通过查看表的创建语句看到。 12-- 查看表的创建语句show create table my_auto; 如上图所示，显然在咱们之前插入的 3 条记录之后，下一次自增长是4，符合咱们的结论。 修改自增长自增长如果是涉及到字段改变，就必须先删除自增长，然后再增加自增长，因为每张表只能有一个自增长字段。 如果修改当前自增长字段已经存在的值，则只能修改比当前已有自增长字段中的最大值更大，不能更小，因为更小不生效。 基本语法：alter table + 表名 + auto_increment = 值; 执行如下 SQL 语句，进行测试： 12-- 修改自增长测试alter table my_auto auto_increment = 2; 如上图所示，当咱们修改自增长小于当前自增长字段中的最大值时，虽然显示 SQL 语句执行成功，但实际上并没有修改成功。下面，在执行如下 SQL 语句，进行测试： 12-- 修改自增长测试alter table my_auto auto_increment = 5; 如上图所示，显然当咱们修改自增长大于当前自增长字段中的最大值时，修改成功。 在这里，咱们不妨思考一下，为什么自增长是从1开始呢？为什么每次都自增1呢？虽然现在咱们不知道是什么原因导致上面的表示形式，但是咱们知道，所有系统的表现（如字符集、校对集）都是由系统内部的变量进行控制的，因此咱们可以查看自增长对应的变量： 基本语法：show variables like &#39;auto_increment%&#39;; 12-- 查看自增长变量show variables like &apos;auto_increment%&apos;; 如上图所示，其中auto_increment_increment表示步长，auto_increment_offset表示初始值. 因此，咱们可以通过修改上面的两个变量实现不同的效果，但是需要注意的是：修改是会话级别，并且修改的是整个数据库，而不是单张表。 基本语法：set auto_increment_increment = 值; 执行如下 SQL 语句，进行测试： 123-- 修改自增长步长set auto_increment_increment = 5;insert into my_auto values (null,&apos;Guobinhit&apos;); 如上图所示，咱们已经修改成功！接下来，执行如下 SQL 语句，进行测试：123-- 插入测试数据insert into my_auto values (null,&apos;Guobinhit&apos;);insert into my_auto values (default,&apos;Guobinhit&apos;); 如上图所示，咱们插入的第一个Guobinhit的id值竟然是6，第二个Guobinhit的id值倒是在6的基础上增加了5为11正常。这个现象产生的原因是：咱们之前的修改会导致系统产生一个误差，从初始值1开始计算加5，因此第一个Guobinhit的id值是6. 不过说实话，修改自增长并没有什么实际的意义，在此只是想让大家知道：自增长的初始值和步长都是可以修改的而已。 删除自增长自增长是字段的一个属性，因此可以通过modify来进行修改。想要删除自增长的话，只需要保证字段没有auto_increment即可。 基本语法：alter table + 表名 + modify + 字段 + 类型; 执行如下 SQL 语句，进行测试： 12-- 删除自增长alter table my_auto modify id int primary key; 如上图所示，呃，好吧，出错啦！这是因为表my_auto之前已经定义了主键，所以在执行上述 SQL 语句的时候，系统会认为咱们想要定义多个主键，自然就要报错啦！解决方法就是，去掉上述 SQL 语句中的primary key即可。 如上图所示，显然咱们已经成功删除自增长啦！ 温馨提示：符号+表示连接的意思。 （十二）「列属性 之 唯一键」唯一键唯一键：每张表往往有多个字段需要具有唯一性，数据不能重复，但是在每张表中，只能有一个主键，因此唯一键就是用来解决表中多个字段需要具有唯一性的问题。 唯一键的本质与主键差不多，唯一键默认的允许字段为空，而且可以多个字段为空，因此空字段不参与唯一性的比较。 增加唯一键增加唯一键的方法和主键类似，有 3 种方法，分别为： 第一种：在创建表的时候，字段后面直接添加unique或者unique key关键字 12345-- 增加唯一键create table my_unique( number char(10) unique comment &apos;学号&apos;, name varchar(20) not null)charset utf8; 第 2 种：在所有字段之后，增加unique key(字段列表)，可以设置复合唯一键 123456-- 测试唯一键create table my_unique2( number char(10) not null, name varchar(20) not null, unique key(number) )charset utf8; 观察上图，咱们可能会发现一个问题，那就是：咱们设置的唯一键UNI，怎么变成了主键PRI啊？这是由于当唯一键满足非空条件的时候，其性质就和主键一样啦，因此在表中显示为PRI. 当然，在咱们执行如下 SQL 语句的时候，其就会表现出真正的性质： 12-- 查看表创建语句show create table my_unique2; 第 3 种：在创建表之后，增加唯一键 123456-- 创建未设置唯一键的表create table my_unique3( id int primary key auto_increment, number char(10) not null, name varchar(20) not null)charset utf8; 如上图所示，表my_unique3未设置唯一键。接下来，执行如下 SQL 语句，进行测试： 12-- 增加唯一键alter table my_unique3 add unique key(number); 如上图所示，咱们已经成功向表中增加唯一键啦！ 唯一键约束唯一键与主键本质相同，区别在于：唯一键允许字段值为空，并且允许多个空值存在。 123-- 测试唯一键约束insert into my_unique values(null,&apos;Charies&apos;);insert into my_unique values(null,&apos;Guo&apos;); 更新唯一键 &amp; 删除唯一键在表中，更新唯一键的时候，可以不用先删除唯一键，因为表的唯一键允许有多个。 删除唯一键的语法为： 基本语法：alter table + 表名 + drop index + 索引名字; 在这里，唯一键默认使用字段名作为索引名。 12-- 删除唯一键alter table my_unique3 drop index number; 如上图所示，显然咱们已经成功删除表中的唯一键啦！ 温馨提示：符号+表示连接的意思。 （十三）「索引」索引索引：系统根据某种算法，将已有的数据（未来可能新增的数据），单独建立一个文件，这个文件能够实现快速匹配数据，并且能够快速的找到对应的记录，几乎所有的索引都是建立在字段之上的。 索引的意义： 提升查询数据的效率； 约束数据的有效性。 但是增加索引是有前提条件的，这是因为索引本身会产生索引文件（有的时候可能会比数据本身都大），因此非常耗费磁盘空间。 如果某个字段需要作为查询的条件经常使用，可以使用索引； 如果某个字段需要进行数据的有效性约束，也可以使用索引（主键或唯一键）。 MySQL 中提供了多种索引，包括： 主键索引primary key 唯一键索引unique key 全文索引fulltext index 普通索引index 其中，主键和唯一键咱们之前已经了解过啦！至于普通索引，顾名思义，并没有什么特色，唯一的任务就是加快数据的查询速度。 在这里，咱们说说全文索引。全文索引，即根据文章内部的关键字进行索引，其最大的难度就是在于如何确定关键字。对于英文来说，全文索引的建立相对容易，因为英文的两个单词之间有空格；但是对于中文来说，全文索引的建立就比较难啦，因为中文两个字之间不仅没有空格，而是还可以随意组合。 （十四）「关系」关系在数据库中，将实体与实体的关系反应到表的设计上来，可以细分为 3 种，分别为：一对一(1:1)，一对多(1:N)（或多对一(N:1)）和多对多(N:N)。 在此，所有的关系都是指表与表之间的关系。 一对一一对一，即一张表的一条记录只能与另外一张表的一条记录相对应，反之亦然。 例如，咱们设计一张「个人信息表」，其字段包含：姓名、性别、年龄、身高、体重、籍贯和居住地等。 如上表所示，基本满足咱们的要求，其中姓名、性别和年龄属于常用数据，但是身高、体重、籍贯和居住地为不常用数据。如果每次查询都要查询所有数据的话，那么不常用数据就会影响效率，而且又不常用。因此，咱们可以将常用的数据和不常用的数据分离存储，即分为两张表，例如： 表 1：常用数据 表 2：不常用数据 如上面表1和表2所示，通过字段ID，表1中的一条记录只能匹配表2中的一条记录，反之亦然，这就是一对一的关系。 一对多/多对一一对多，即一张表中的记录可以对应另外一张表中的多条记录，但是反过来，另外一张表中的一条记录只能对应第一张表中的一条记录。 例如，咱们设计「国家城市表」，其包含两个实体，即国家和城市。 表 3：国家表 表 4：城市表 如上面表3和表4所示，通过字段国家，表3中的一条记录可以匹配表4中的多条记录，但反过来，表4中的一条记录只能匹配表3中的一条记录，这就是典型的一对多的关系。 多对多多对多，即一张表中的记录可以对应另外一张表中的多条记录，反过来，另外一张表中的一条记录也可以对应第一张表中的多条记录。 例如，咱们设计「教师学生表」，其包含两个实体，即教师和学生。 表 5：教师表 表 6：学生表 观察上面的表5和表6，咱们会发现：表5和表6的设计满足了实体的属性，但没有维护实体之间的关系，即一个老师教过多个学生，一个学生也被多个老师教过。但是无论咱们在表5中还是在表6中增加字段，都会出现一个问题，那就是：该字段要保存多个数据，并且还是与其他表有关系的字段，不符合设计规范。因此，咱们可以再设计一张「中间表」，专门用来维护表5和表6的关系。 表 7：中间表 观察上面的表5、表6和表7，咱们会发现增加表7之后，咱们维护表5和表6的关系更加方便啦！无论是想从表5通过表7查到表6，还是想从表6通过表7查到表5，都非常容易啦！这就是典型的多对多的关系。 （十五）「范式」范式范式：Normal Farmat，是为了解决数据的存储和优化问题。 在数据存储之后，凡是能够通过关系寻找出来的数据，坚决不再重复存储，范式的终极目标是减少数据冗余。 范式是一种分层结构的规范，共 6 层，分别为1NF、2NF、3NF、4NF、5NF和6NF，每一层都比上一层严格，若要满足下一层范式，其前提是先满足上一层范式。其中，1NF是最底层的范式，6NF为最高层的范式，也最严格。 MySQL 数据库属于关系型数据库，其存储数据的时候有些浪费空间，但也致力于节省空间，这就与范式想要解决的问题不谋而合，因此在设计数据库的时候，大都会利用范式来指导设计。但是数据库不单是要解决存储空间的问题，还要保证效率的问题，而范式只为解决存储空间的问题，所以数据库的设计又不能完全按照范式的要求来实现，因此在一般情况下，只需要满足前三种范式即可。 此外，咱们需要知道：范式在数据库的设计中是有指导意义的，但不是强制规范。 1NF第一范式：在设计表存储数据的时候，如果表中设计的字段存储的数据，在取出来使用之前还需要额外的处理（拆分），那么表的设计就不满足第一范式，第一范式要求字段的数据具有原子性，不可再分。 例如，咱们设计一个「学校假期时间表」，如下所示： 表 1：学校假期时间表 ID(P) 学校名称 起始日期，结束日期 1 哈尔滨工业大学 20170625，20170903 2 浙江大学 20170630，20170901 观察上表，咱们会发现表1的设计并没有什么问题，但是如果需求是查询各学校开始放假的日期呢？那显然上表的设计并不满足1NF，数据不具有原子性。对于此类问题，解决的方案就是将表1进行拆分： 表 2：拆分后的表 1 ID(P) 学校名称 起始日期 结束日期 1 哈尔滨工业大学 20170625 20170903 2 浙江大学 20170630 20170901 2NF第二范式：在数据表的设计过程中，如果有复合主键（多字段主键），且表中有字段并不是由整个主键来确定，而是依赖复合主键中的某个字段（主键的部分），也就是说存在字段依赖主键的部分的问题（称之为部分依赖），第二范式就是要解决表设计中不允许出现部分依赖。 例如，咱们设计一个「教室授课表」，如下所示： 表 3：教室授课表 教师(P) 性别 课程 授课地点(P) 许仙 男 《如何追到心爱的女孩》 杭州西湖 白娘子 女 《论女人的恋爱修养》 雷峰塔 白娘子 女 《如何打赢与和尚之间的持久战》 金山寺 观察上表，咱们会发现：教师不能作为独立的主键，需要与授课地点相结合才能作为主键（复合主键，每个教师的某个课程只能在固定的地点上），其中性别依赖于具体的教师，而课程依赖于授课地点，这就出现了表的字段依赖于部分主键的问题，从而导致不满足第二范式。 解决方案 1：将教师和性别，课程和授课地点，分成两张单独的表； 解决方案 2：取消复合主键，使用逻辑主键。 在此，咱们采用 方案 2 的解决方法，即取消复合主键，使用逻辑主键。 ID(P) 教师 性别 课程 授课地点 1 许仙 男 《如何追到心爱的女孩》 杭州西湖 2 白娘子 女 《论女人的恋爱修养》 雷峰塔 3 白娘子 女 《如何打赢与和尚之间的持久战》 金山寺 3NF第三范式：需要满足第一范式和第二范式，理论上讲，每张表中的所有字段都应该直接依赖主键（逻辑主键，代表是业务主键），如果表设计中存在一个字段，并不直接依赖主键，而是通过某个非主键字段依赖，最终实现主键依赖（把这种不是直接依赖主键，而是依赖非主键字段的依赖关系，称之为传递依赖），第三范式就是要解决表设计中出现传递依赖的问题。 以上述的添加逻辑主键后的 表3 为例： ID(P) 教师 性别 课程 授课地点 1 许仙 男 《如何追到心爱的女孩》 杭州西湖 2 白娘子 女 《论女人的恋爱修养》 雷峰塔 3 白娘子 女 《如何打赢与和尚之间的持久战》 金山寺 在以上表的设计中，性别依赖教师，教师依赖主键；课程依赖授课地点，授课地点依赖主键，因此性别和课程都存在传递依赖的问题。 解决方案：将存在传递依赖的字段，以及依赖的字段本身单独取出来，形成一个单独的表，然后在需要使用对应的信息的时候，把对应的实体表的主键添加进来。 表 4：教师表 TEACHER_ID(P) 教师 性别 1 许仙 男 2 白娘子 女 3 白娘子 女 表 5：授课地点表 ADDRESS_ID(P) 课程 授课地点 1 《如何追到心爱的女孩》 杭州西湖 2 《论女人的恋爱修养》 雷峰塔 3 《如何打赢与和尚之间的持久战》 金山寺 表 6：进行处理后的表 ID(P) TEACHER_ID ADDRESS_ID 1 1 1 2 2 2 3 3 3 在观察上述 表 4 和 表 5，咱们会发现TEACHER_ID等价于教师且ADDRESS_ID等价于授课地点，因此其逻辑主键并没有什么实际的限制意义，咱们只需要看其具体代表的业务主键即可。咱们之所以使用逻辑主键，是因为：逻辑主键可以实现自动增长，并且数字传递比较方便，而且有利于节省空间。 逆规范化在某些特定的环境中（例如淘宝数据库），在设计表的时候，如果一张表中有几个字段是需要从另外的表中去获取数据，理论上讲，的确可以获得想要的数据，但是相对来说，其效率低会一点。此时为了提高查询效率，咱们会刻意的在某些表中，不去保存另外一张表的主键（逻辑主键），而是直接保存想要存储的数据信息，这样的话，在查询数据的时候，这张表就可以直接提供咱们想要的数据，而不需要多表查询，但是这样做会导致数据冗余。 实际上，逆规范化是磁盘利用率和效率之间的对抗。 （十六）「数据的高级操作 之 主键冲突」数据的高级操作数据的操作，无外乎增删改查。 新增数据的基本语法为： insert into + 表名 + [(字段列表)] + values (值列表); 在数据插入的时候，假设主键对应的值已经存在，则插入失败！这就是主键冲突。 主键冲突当主键存在冲突（duplicate key）的时候，可以选择性的进行处理，即更新或替换。 下面，以表my_class为例，进行测试： 其中，grade为主键。 第一种情况：主键冲突，进行更新操作。 基本语法：insert into + 表名 + [(字段列表：包含主键)] + values (值列表) on duplicate key update 字段 = 新值; 执行如下 SQL 语句，进行测试： 12-- 测试主键冲突的 SQL 语句insert into my_class values (&apos;PM3527&apos;,&apos;B315&apos;); 如上图所示，当主键已经存在的时候，产生主键冲突。再执行如下 SQL 语言，解决主键冲突的问题： 123456-- 当主键冲突的时候，进行更新操作insert into my_class values (&apos;PM3527&apos;,&apos;B315&apos;)-- 冲突处理on duplicate key update-- 更新主键值room = &apos;B315&apos;; 第二种情况：主键冲突，选择替换操作。 基本语法：replace insert into + 表名 + [(字段列表：包含主键)] + values (值列表); 执行如下 SQL 语句，进行测试： 12-- 测试主键冲突的 SQL 语句insert into my_class values (&apos;PM3528&apos;,&apos;B215&apos;); 如上图所示，当主键已经存在的时候，产生主键冲突。再执行如下 SQL 语言，解决主键冲突的问题： 12-- 当主键冲突的时候，进行替换操作replace into my_class values (&apos;PM3528&apos;,&apos;B215&apos;); 通过以上两种情况的演示，当再发生主键冲突的时候，咱们已经可以从容应对并解决啦！ 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （十七）「数据的高级操作 之 蠕虫复制」数据的高级操作蠕虫复制蠕虫复制：从已有的数据表中获取数据，然后将数据进行新增操作，数据成倍（以指数形式）的增加。 根据已有表创建新表，即复制表结构，其基本语法为： create table + 表名 + like + [数据库名.]表名; 执行如下 SQL 语句，进行测试： 12-- 根据已有表，创建新表，当两张表位于同一数据库时，可以省略数据库名称create table my_copy like my_gbk; 如上图所示，表my_copy和表my_gbk的表结构完成相同。 蠕虫复制的步骤为：先查出数据，然后将查出的数据新增一遍。 基本语法：insert into + 表名 + [()] + select + 字段列表/* + from + 表名; 执行如上 SQL 语句，进行测试： 12-- 蠕虫复制insert into my_copy select * from my_collate_bin; 如上图所示，咱们已经成功将表my_collate_bin中的数据复制到表my_copy中啦！接下来，咱们再执行如下 SQL 语句，测试蠕虫复制的效果： 12-- 蠕虫复制insert into my_copy select * from my_copy; 如上图所示，通过观察每次执行 SQL 语句后影响的列数，分别为4、8和16等，咱们会发现蠕虫复制的效果呈（指数）爆炸性增长。 蠕虫复制的意义： 从已有的数据表中拷贝数据到新的数据表； 可以迅速的让表中的数据膨胀到一定的数量级，多用于测试表的压力及效率。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （十八）「数据的高级操作 之 更新 &amp; 删除」数据的高级操作更新数据 基本语法： update + 表名 + set + 字段 = 值 + [where 条件]; 高级语法： update + 表名 + set + 字段 = 值 + [where 条件] + [limit 更新数量]; 执行如下 SQL 语句，进行测试： 12-- 将表 my_copy 中的部分 a 更新为 cupdate my_copy set name = &apos;c&apos; where name = &apos;a&apos; limit 3; 执行上述 SQL 语句前： 执行上述 SQL 语句后： 删除数据与更新类似，可以通过limit来限制删除的数量。 基本语法： delete + from + 表名 + [where 条件]; 高级语法： delete + from + 表名 + [where 条件] + [limit 删除数量]; 执行如下 SQL 语句，进行测试： 12-- 将表 my_copy 中的部分 b 删除delete from my_copy where name = &apos;b&apos; limit 10; 此外，在删除记录的过程中，如果表中存在自增长的主键，那么删除之后，自增长不会还原。执行如下 SQL 语句，进行测试： 123-- 删除表 student 中的记录，查看自增长属性delete from student;show create table student; 如上图所示，显然在咱们删除表student中的全部数据之后，id的自增长属性值3并没有发生改变，这是因为数据的删除是不会改变表结构的。如果想要还原自增长属性，思路是：先删除表，然后重新建表。 基本语法：truncate + 表名; 执行如下 SQL 语句，进行测试： 12-- 先清空 student 表，再重新创建 student 表truncate student; 如上图所示，显然咱们已经测试成功啦！ 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （十九）「数据的高级操作 之 查询」数据的高级操作 - 查询数据 基本语法： select + 字段列表/* + from + 表名 + [where 条件]; 完整语法： select + [select 选项] + 字段列表[字段别名]/* + from + 数据源 + [where 条件] + [1] + [2] + [3]; [1] = [group by 子句] [2] = [order by 子句] [3] = [limit 子句] SELECT 选项select选项，即select对查出来的结果的处理方式。 all：默认，保留所有的查询结果； distinct：去重，将查出来的结果中所有字段都相同的记录去除。 执行如下 SQL 语句，进行测试： 1234-- 查询表 my_copy 中的数据select * from my_copy;select all * from my_copy;select distinct * from my_copy; 字段别名字段别名，即当数据进行查询的时候，有时候字段的名字并不一定满足需求（特别地，在多表查询的时候，很可能会有同名字段），这时就需要对字段进行重命名、取别名。 基本语法：字段名 + [as] + 别名; 执行如下 SQL 语句，进行测试： 123456-- 使用别名select id,name as 姓名,age as 年龄，grade as 年级from student; 数据源数据源，即数据的来源，关系型数据库的数据源都是数据表，本质上只要保证数据类似二维表，最终就可以作为数据源。 数据源分为 3 种，分别为：单表数据源，多表数据源和查询语句。 第 1 种：单表数据源 基本语法：select * from + 表名; 第 2 种：多表数据源 基本语法：select * from + 表名1,表名2...; 如上图所示，使用多表数据源时默认从一张表中取出一条记录去另外一张表中匹配所有记录，而且全部保留，比较浪费资源，应该尽量避免。 第 3 种：查询语句（子查询） 基本语法：select * from + (select * from + 表名) + [as] + 别名; 如上图所示，数据的来源是一条查询语句，而查询语句的结果是一张二维表。 where子句where字句：用来判断数据和筛选数据，返回的结果为0或者1，其中0代表false，1代表true，where是唯一一个直接从磁盘获取数据的时候就开始判断的条件，从磁盘中读取一条数据，就开始进行where判断，如果判断的结果为真，则保持，反之，不保存。 判断条件： 比较运算符：&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、=、like、between and、in和not in； 逻辑运算符：&amp;&amp;、||、和!. 执行如下 SQL 语句，进行测试： 123-- 查询表 student 中 id 为 2、3、5 的记录select * from student where id = 2 || id = 3 || id = 5;select * from student where id in (2,3,5); 12-- 查询表 student 中 id 在 2 和 5 之间的记录select * from student where id between 2 and 5; 如上图所示，咱们会发现：在使用between and的时候，其选择的区间为闭区间，即包含端点值。此外，and前面的数值必须大于等于and后面的数值，否则会出现空判断，例如： group by子句group by子句：根据表中的某个字段进行分组，即将含有相同字段值的记录放在一组，不同的放在不同组。 基本语法：group by + 字段名; 执行如下 SQL 语句，进行测试： 12-- 将表 student 中的数据按字段 sex 进行分组select * from student group by sex; 观察上图，咱们会发现：表student在分组过后，数据“丢失”啦！实际上并非如此，产生这样现象原因为：group by分组的目的是为了（按分组字段）统计数据，并不是为了单纯的进行分组而分组。为了方便统计数据，SQL 提供了一系列的统计函数，例如： cout()：统计分组后，每组的总记录数； max()：统计每组中的最大值； min()：统计每组中的最小值； avg()：统计每组中的平均值； sum()：统计每组中的数据总和。 执行如下 SQL 语句，进行测试： 12-- 将表 student 中的数据按字段 sex 进行分组，并进行统计select sex,count(*),max(age),min(age),avg(age),sum(age) from student group by sex; 其中，count()函数里面可以使用两种参数，分别为：*表示统计组内全部记录的数量；字段名表示统计对应字段的非null（如果某条记录中该字段的值为null，则不统计）记录的总数。此外，使用group by进行分组之后，展示的记录会根据分组的字段值进行排序，默认为升序。当然，也可以人为的设置升序和降序。 基本语法：group by + 字段名 + [asc/desc]; 执行如下 SQL 语句，进行测试： 1234-- 将表 student 中的数据按字段 sex 进行分组，并排序select sex,count(*) from student group by sex;select sex,count(*) from student group by sex asc;select sex,count(*) from student group by sex desc; 通过观察上面数个分组示例，细心的同学会发现：咱们在之前的示例中，都是用单字段进行分组。实际上，咱们也可以使用多字段分组，即：先根据一个字段进行分组，然后对分组后的结果再次按照其他字段（前提是分组后的结果中包含此字段）进行分组。 执行如下 SQL 语句，进行测试： 12-- 将表 student 中的数据先按字段 grade 进行分组，再按字段 sex 进行分组select *,count(*) from student group by grade,sex; 在这里，函数group_concat(字段名)可以对分组的结果中的某个字段值进行字符串连接，即保留该组某个字段的所有值。例如： 12-- 将表 student 中的数据按字段 sex进行分组，并保留字段 name 的值select sex,age,count(*),group_concat(name) from student group by sex; 此外，简单介绍回溯统计的概念：利用with rollup关键字（书写在 SQL 语句末尾），可以在每次分组过后，根据当前分组的字段进行统计，并向上一级分组进行汇报。例如： 12-- 将表 student 中的数据按字段 sex进行分组，并进行回溯统计select sex,count(*) from student group by sex with rollup; 观察上图，咱们会发现：在进行回溯统计的时候，会将分组字段置空。 having子句having字句：与where子句一样，都是进行条件判断的，但是where是针对磁盘数据进行判断，数据进入内存之后，会进行分组操作，分组结果就需要having来处理。思考可知，having能做where能做的几乎所有事情，但是where却不能做having能做的很多事情。 第 1 点：分组统计的结果或者说统计函数只有having能够使用 执行如下 SQL 语句，进行测试： 123-- 求出表 student 中所有班级人数大于等于 2 的班级select grade,count(*) from student group by grade having count(*) &gt;= 2;select grade,count(*) from student where count(*) &gt;= 2 group by grade; 如上图所示，显然having子句可以对统计函数得到的结果进行筛选，但是where却不能。 第 2 点：having能够使用字段别名，where则不能 执行如下 SQL 语句，进行测试： 123-- 求出表 student 中所有班级人数大于等于 2 的班级select grade,count(*) as total from student group by grade having total &gt;= 2;select grade,count(*) as total from student where total &gt;= 2 group by grade; 如上图所示，显然咱们的结论得到了验证。究其原因，where是从磁盘读取数据，而磁盘中数据的名字只能是字段名，别名是数据（字段）进入到内存后才产生的。值得注意的是，在上述 SQL 语句中咱们使用了字段别名，这在无意中就优化了 SQL 并提高了效率，因为少了一次统计函数的计算。 order by子句order by子句：根据某个字段进行升序或者降序排序，依赖校对集。 基本语法：order by + [asc/desc]; 其中，asc为升序，为默认值；desc为降序。 执行如下 SQL 语句，进行测试： 12-- 将表 student 中的数据按年龄 age 进行排序select * from student order by age; 此外，咱们可以进行「多字段排序」，即先根据某个字段进行排序，然后在排序后的结果中，再根据某个字段进行排序。 执行如下 SQL 语句，进行测试： 12-- 将表 student 中的数据先按年龄 age 升序排序，再按班级 grade 降序排序select * from student order by age,grade desc; limit子句limit子句：是一种限制结果的语句，通常来限制结果的数量。 基本语法：limit + [offset] + length; 其中，offset为起始值；length为长度。 第 1 种：只用来限制长度（数据量） 执行如下 SQL 语句，进行测试： 1234-- 查询表 student 中的全部记录select * from student;-- 查询表 student 中的 3 条记录select * from student limit 3; 第 2 种：限制起始值，限制长度（数据量） 执行如下 SQL 语句，进行测试： 1234-- 查询表 student 中的记录select * from student limit 0,2;-- 查询表 student 中的记录select * from student limit 2,2; 第 3 种：主要用来实现数据的分页，目的是为用户节省时间，提高服务器的响应效率，减少资源的浪费 大致设计： 对于用户来讲，可以通过点击页码按钮，如1、2、3等来进行选择； 对于服务器来讲，可以根据用户选择的页码来获取不同的数据。 其中， length：表示每页的数据量，基本不变； offset：表示每页的起始值，公式为offset=(页码-1)*length. 如果大家感兴趣的话，可以结合Java或者其他语言进行测试。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十）「连接查询」连接查询：将多张表（大于等于 2 张表）按照某个指定的条件进行数据的拼接，其最终结果记录数可能有变化，但字段数一定会增加。 连接查询的意义：在用户查询数据的时候，需要显示的数据来自多张表。 连接查询为join，使用方式为：左表join右表。 左表：join左边的表； 右表：join右边的表。 连接查询分类：在 SQL 中将连接查询分为四类，分别为内连接、外链接、自然连接和交叉连接。 交叉连接交叉连接：cross join，从一张表中循环取出每一条记录，每条记录都去另外一张表进行匹配，匹配的结果都保留（没有条件匹配），而连接本身的字段会增加，最终形成的结果为笛卡尔积形式。 基本语法：左表 cross join 右边; 其结果与多表查询相同。 执行如下 SQL 语句，进行测试： 1234-- 将表 student 与 class 进行交叉连接select * from student cross join class;-- 将表 student 与 class 进行多表查询select * from student,class; 实际上，笛卡尔积形式（交叉连接和多表查询）的结果并没有什么实际意义，应该尽量避免，其存在的价值就是保证连接这种结构的完整性。 内连接内连接：inner join，从左表中取出每一条记录，和右表中的所有记录进行匹配，并且仅当某个条件在左表和右表中的值相同时，结果才会保留，否则不保留。 基本语法：左表 + [inner] + join + 右表 + on + 左表.字段 = 右表.字段; 其中，关键字on表示连接条件，两表中的条件字段有着相同的业务含义。 执行如下 SQL 语句，进行测试： 123-- 将表 student 与 class 进行内连接select * from student inner join class on student.grade = class.grade;select * from student join class on student.grade = class.grade; 在这里，值得注意的是：如果两表中有某个表的条件字段名唯一，那么在书写连接条件的时候，可以省略表名，直接书写字段名，MySQL 会自动识别唯一字段名，但不建议这么做。此外，咱们会发现，在上面的结果中有同名字段，这会给咱们理解数据的意义造成一定的困扰，这时就需要使用字段别名和表别名做区别啦！ 执行如下 SQL 语句，进行测试： 12-- 将表 student 与 class 进行内连接，起别名select s.*,c.id as c_id,c.grade as c_grade,room from student as s inner join class as c on s.grade = c.grade; 最后，内连接可以没有连接条件，即可以没有on及之后的内容，这时内连接的结果全部保留，与交叉连接的结果完全相同。而且在内连接的时候可以使用where关键字代替on，但不建议这么做，因为where没有on的效率高。 执行如下 SQL 语句，进行测试： 1234567891011-- 将表 student 与 class 进行内连接，不加连接条件select s.*,c.id as c_id,c.grade as c_grade,room from student as s inner join class as c;-- 将表 student 与 class 进行交叉连接 select s.*,c.id as c_id,c.grade as c_grade,room from student as s cross join class as c;-- 使用 on 关键字进行内连接select s.*,c.id as c_id,c.grade as c_grade,room from student as s inner join class as c on s.grade = c.grade;-- 使用 where 关键字进行内连接select s.*,c.id as c_id,c.grade as c_grade,room from student as s inner join class as c where s.grade = c.grade; 外连接外连接：left\right join，以某张表为主表，取出里面的所有记录，然后让主表中的每条记录都与另外一张表进行连接，不管能否匹配成功，其最终结果都会保留，匹配成功，则正确保留；匹配失败，则将另外一张表的字段都置为NULL. 基本语法：左表 + left\right + join + 右表 + on + 左表.字段 = 右表.字段; 其中，关键字on表示连接条件，两表中的条件字段有着相同的业务含义。在这里，以主表为依据，外连接分为两种，分别为： left join：左外连接（左连接），以左表为主表； right join：右外连接（右连接），以右表为主表。 执行如下 SQL 语句，进行测试： 12345-- 将表 student 与 class 进行左连接select s.*,c.id as c_id,c.grade as c_grade,room from student as s left join class as c on s.grade = c.grade;-- 将表 student 与 class 进行右连接select s.*,c.id as c_id,c.grade as c_grade,room from student as s right join class as c on s.grade = c.grade; 实际上，无论以那张表为主表，其外连接的结果（记录数量）都不会少于主表的记录总数。此外，虽然左连接与右连接有主表差异，但显示的结果都是：左表的数据在左边，右表的数据在右边。 自然连接自然连接：nature join，自然连接其实就是自动匹配连接条件，系统以两表中同名字段作为匹配条件，如果两表有多个同名字段，那就都作为匹配条件。在这里，自然连接可以分为自然内连接和自然外连接。 自然内连接 基本语法：左表 + nature + join + 右表; 执行如下 SQL 语句，进行测试： 12345-- 将表 student 与 class 进行自然内连接select * from student natural join class;-- 将表 student 与 class 进行内连接，连接条件为 id 和 gradeselect * from student inner join class on student.id = class.id and student.grade = class.grade; 观察上图，咱们会发现：自然连接自动使用同名字段作为连接条件，而且在连接完成之后合并同名字段。 自然外连接 基本语法：左表 + nature + left/right + join + 右表; 执行如下 SQL 语句，进行测试： 12345-- 将表 student 与 class 进行自然左外连接select * from student natural left join class;-- 将表 student 与 class 进行自然右外连接select * from student natural right join class; 实际上，自然连接并不常用。而且，咱们可以用内连接和外连接来模拟自然连接，模拟的关键就在于使用同名字段作为连接条件及合并同名字段。 基本语法：左表 + inner/left/right + join + 右表 + using(字段名); 其中，using内部的字段名就是作为连接条件的字段，也是需要合并的同名字段。 执行如下 SQL 语句，进行测试： 12345-- 将表 student 与 class 进行自然左外连接select * from student natural left join class;-- 用左外连接模拟自然左外连接select * from student left join class using(id,grade); 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十一）「外键」外键外键：foreign key，外面的键，即不在自己表中的键。如果一张表中有一个非主键的字段指向另外一张表的主键，那么将该字段称之为外键。每张表中，可以有多个外键。 新增外键外键既可以在创建表的时候增加，也可以在创建表之后增加（但是要考虑数据的问题）。 第 1 种：在创建表的时候，增加外键 基本语法：foreign key(外键字段) + references + 外部表名(主键字段); 执行如下 SQL 语句，进行测试： 12345678-- 创建外键create table my_foreign1( id int primary key auto_increment, name varchar(20) not null comment &apos;学生姓名&apos;, c_id int comment &apos;班级表ID&apos;, -- 增加外键 foreign key(c_id) references class(id) )charset utf8; 观察上图可知，字段c_id的key显示为MUL，表示多个键的意思。这是因为外键要求字段本身是一个索引（普通索引）如果字段本身没有索引，外键就会先创建一个索引，然后才创建外键本身。此外，CONSTRAINT后面的my_foreign_ibfk_1表示外键的名字。 第 2 种：在创建表之后，增加外键 基本语法：alter table + 表名 + add[constraint + 外键名字] + foreign key(外键字段) + references + 外部表名(主键字段); 执行如下 SQL 语句，进行测试： 123456789101112131415-- 创建外键create table my_foreign2( id int primary key auto_increment, name varchar(20) not null comment &apos;学生姓名&apos;, c_id int comment &apos;班级表ID&apos;)charset utf8;-- 增加外键alter table my_foreign2 add-- 指定外键名constraint test_foreign-- 指定外键字段foreign key(c_id)-- 引用外部表主键references class(id); 如上图所示，显然咱们已经增加外键成功啦！ 修改外键 &amp; 删除外键外键不能修改，只能先删除后增加。 基本语法：alter table + 表名 + drop foreign key + 外键名字; 执行如下 SQL 语句，进行测试： 12-- 删除外键alter table my_foreign1 drop foreign key my_foreign1_ibfk_1; 观察上图可知，删除外键不能通过查看表结构来体现，而是应该通过创建表的语句来查看。 外键作用首先，给出父表和子表的定义： 父表，指外键所指向的表； 子表，指相对于父表，拥有外键的表。 外键默认的作用有两个，分别对子表和父表进行约束。 第 1 种：约束子表 在子表进行数据的写操作（增和改）的时候，如果对应的外键字段在父表找不到对应的匹配，那么操作就会失败。 执行如下 SQL 语句，进行测试： 12345-- 插入数据，外键字段在父表不存在insert into my_foreign2 values(null,&apos;Charies&apos;,&apos;6&apos;); -- 插入数据，外键字段在父表存在insert into my_foreign2 values(null,&apos;Charies&apos;,&apos;1&apos;); 如上图所示，在我们向子表my_foreign2插入外键字段为6的时候，提示插入失败，原因就是在父表class中，没有ID为6的记录。而在我们向子表my_foreign2插入外键字段为1的时候，提示成功，原因就是在父表class中，有ID为1的记录。 第 2 种：约束父表 在父表进行数据的写操作（删和改，且涉及主键）的时候，如果对应的主键字段在子表已经被数据引用，那么操作就会失败。 执行如下 SQL 语句，进行测试： 123-- 更新父表记录update class set id = 5 where id = 1;update class set id = 5 where id = 3; 如上图所示，在我们修改父表class中ID为1的时候，提示修改失败，原因就是在子表my_foreign2中已经引用了该值的主键字段。而在我们修改父表class中ID为3的时候，提示修改成功，原因就是在子表my_foreign2中并没有引用该值的主键字段。 外键条件在我们使用外键的时候，应该遵循如下条件： 外键要存在，首先必须保证表的引擎是 InnoDB（默认的存储引擎），如果不是 InnoDB 存储引擎，那么外键可以创建成功，但没有约束作用； 外键字段的字段类型（列类型），必须与父表的主键类型完全一致； 每张表中的外键名称不能重复； 增加外键的字段，如果数据已经存在，那么要保证数据与父表中的主键对应。 下面以最后一个条件为例，执行如下 SQL 语句，进行测试： 12345-- 新增数据insert into my_foreign1 valuse(1,&apos;Gavin&apos;,3);-- 增加外键alter table my_foreign1 add foreign key(c_id) references class(id); 如上图所示，在新增外键的时候，如果子表中（想要新增外键的字段）的数据已经存在，而父表中又没有与子表中（想要新增外键的字段）的数据相匹配的主键的话，那么操作就会失败；反之，则会成功。 执行如下 SQL 语句，进行测试： 12345-- 新增数据insert into class valuse(3,&apos;PM3.4&apos;,&apos;A115&apos;);-- 增加外键alter table my_foreign1 add foreign key(c_id) references class(id); 如上图所示，显然当父表中存在与子表中（想要新增外键的字段）的数据相匹配的主键的话，增加主键的操作就会成功。 外键约束所谓外键约束，就是指外键的作用。之前所讲的外键的作用都是默认的作用，实际上，可以通过对外键的需求，进行定制操作。 外键约束有三种模式，分别为： district：严格模式（默认），父表不能删除或更新一个已经被子表数据引用的记录； cascade：级联模式，父表的操作，对应子表关联的数据也跟着被删除； set null：置空模式，父表的操作之后，子表对应的数据（外键字段）被置空。 在此需要注意：以上三种模式，都是对父表的约束。 基本语法：foreign key(外键字段) + references + 父表(主键字段) + [on delete + 模式 + on update + 模式]; 通常一个合理的做法（约束模式）是：删除的时候， 子表被置空；更新的时候，子表进行级联操作。 执行如下 SQL 语句，进行测试： 1234567891011121314-- 创建外键，指定模式：删除置空，更新级联create table my_foreign3( id int primary key auto_increment, name varchar(20) not null, c_id int, -- 增加外键 foreign key(c_id) -- 引用父表 references class(id) -- 指定删除模式 on delete set null -- 指定更新模式 on update cascade)charset utf8; 如上图所示，在我们指定外键的约束模式之后，通过查看表的创建语句，可以看到具体的约束语句。 接下来，执行如下 SQL 语句，继续进行测试： 123456-- 插入数据insert into my_foreign3 values(null,&apos;Jobs&apos;,1),(null,&apos;Bill&apos;,1),(null,&apos;Mark&apos;,1),(null,&apos;Swift&apos;,2),(null,&apos;Sellen&apos;,1); 如上图所示，我们向表my_foreign3中插入了 5 条记录。接下来，我们就可以测试外键的级联模式和置空模式啦！呃，对啦，前提是我们需要把与父表class相关联的除my_foreign3之外的其他子表，也就是my_foreign1和my_foreign2的外键删除掉，否则的话，由于这两个子表的外键使用了严格模式，会干扰我们接下来的测试。 在我们删除表my_foreign1和my_foreign2的外键之后，执行如下 SQL 语句，测试级联模式： 12-- 更新父表主键update class set id = 8 where id = 1; 执行如下 SQL 语句，测试置空模式： 12-- 删除父表主键delete from class where id = 2; 通过以上测试，我们已经验证了级联模式和置空模式的效果。其实，在我们进行删除置空操作的时候，有一个前提，那就是：子表的外键字段必须允许为空，否则的话，操作是无法成功的。 至此，我们已经把外键的相关操作都演示了一遍。在这里，我们会发现外键的功能非常强大，能够进行各种的约束，也正是由于外键这种约束的强大，其降低了开发语言对数据的可控性，因此在实际的开发中，很少使用外键来处理数据。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十二）「联合查询」联合查询：union，将多次查询（多条select语句）的结果，在字段数相同的情况下，在记录的层次上进行拼接。 基本语法联合查询由多条select语句构成，每条select语句获取的字段数相同，但与字段类型无关。 基本语法：select 语句1 + union + [union选项] + select 语句2 + ...; union 选项：与select选项一样有两种 all：无论重复与否，保留所有记录； distinct：表示去重，为默认选项。 执行如下 SQL 语句，进行测试： 123456789-- 联合查询，默认去重select * from classunion distinctselect * from class;-- 联合查询，保留所有记录select * from classunion allselect * from class; 如上图所示，展示了联合查询的两种形式。特别地，联合查询只要求字段数相同，而跟类型无关。执行如下 SQL 语句，进行测试： 1234-- 联合查询，字段数相同，类型不同select id, grade, room from classunion distinctselect name, age, id from student; 如上图所示，联合查询只保留了第一张表的字段，而不保留第二张表的字段。 意义联合查询的意义有两种，分别为： 查询同一张表，按时需要不同，例如查询学生信息，要求男生按年龄升序排序，女生按年龄降序排序； 多表查询，多张表的结构是完全一样的，保持的数据结构也是一样的。 此外，如果数据量非常的大，就要进行分表（垂直分表和水平分表），而分表的依据无外乎数据多不多和常不常用。 排序首先，让我们看看student表中的数据： 接下来，给出一个需求：在student表中，让男生按年龄升序排序，让女生按年龄降序排序。根据我们刚刚学到的联合查询，貌似很容易啊！执行如下 SQL 语句，进行测试： 1234-- 在 student 表中，按年龄，男升女降select * from student where gender = &quot;boy&quot; order by age ascunionselect * from student where gender = &quot;girl&quot; order by age desc; 如上图所示，呃，好吧，貌似出错啦！这是因为要想在联合查询中使用order by，我们必须将select语句用括号括起来。执行如下 SQL 语句，进行测试： 1234-- 在 student 表中，按年龄，男升女降(select * from student where gender = &quot;boy&quot; order by age asc)union(select * from student where gender = &quot;girl&quot; order by age desc); 如上图所示，啊，我们都已经将select语句用括号括起来了，但是男生和女生也没有按我们的目的实现啊！好吧，这是因为要想在联合查询中使order by生效，我们必须将其与limit搭配使用，而limit的限定数，我们设置为一个非常大的数即可。执行如下 SQL 语句，进行测试： 1234-- 在 student 表中，按年龄，男升女降(select * from student where gender = &quot;boy&quot; order by age asc limit 666)union(select * from student where gender = &quot;girl&quot; order by age desc limit 666); 如上图所示，显然，这次咱们的目的实现啦！ 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十三）「子查询」子查询：sub query，查询是在某个查询结果之上进行的，一条select语句内部包含了另外一条select语句。 分类子查询有两种分类方式，分别为：按按结果分类和位置分类。 按结果分类，即根据子查询得到的数据进行分类（理论上，任何一个查询结果都可以理解为一个二维表），分别为： 标量子查询：子查询得到的结果是一行一列，出现的位置在where之后； 列子查询：子查询得到的结果是一列多行，出现的位置在where之后； 行子查询：子查询得到的结果是多行一列（多行多列），出现的位置在where之后； 表子查询：子查询得到的结果是多行多列，出现的位置在from之后。 按位置分类，即根据子查询（select语句）在外部查询（select语句）中出现的位置进行分类，分别为： from子查询：子查询出现在from之后； where子查询：子查询出现在where条件之中； exists子查询：子查询出现在exists里面。 标量子查询需求：现知道班级名称为PM3.1，想要获取该班的全部学生。 思路： 先确定数据源，学生表。 select * from student where c_id = ?; 然后获取班级 ID，可以通过（班级表）班级名称来确定。 select id from class where grade = &quot;PM3.1&quot;; 执行如下 SQL 语句，进行测试： 12-- 标量子查询select * from student where c_id = (select id from class where grade = &quot;PM3.1&quot;); 列子查询需求：查询所有在读班级（学生表中存在的班级）的学生。 思路： 先确定数据源，学生表。 select * from student where c_id in ?; 然后确定全部有效的班级 ID。 select id from class; 执行如下 SQL 语句，进行测试： 12-- 列子查询select * from student where c_id in (select id from class); 如上图所示，我们完成了列子查询。在列子查询的结果为一行多列时，我们需要使用in作为条件进行匹配；此外，在 MySQL 中还有三个类似的条件，分别为：all、some和any。 any等价于in，表示其中一个； any等价于smoe，而any和some用于否定时却有些区别； all表示等于全部。 值得注意的是，在我们使用上面三个关键字中任何一个的时候，都需要搭配=使用，例如： 123456-- 列子查询select * from student where c_id = any (select id from class);select * from student where c_id = some (select id from class);select * from student where c_id = all (select id from class); 如上图所示，为any、some和all的肯定用法，下面我们来测试其否定用法： 123456-- 列子查询select * from student where c_id != any (select id from class);select * from student where c_id != some (select id from class);select * from student where c_id != all (select id from class); 观察上图，我们会发现any、some和all在用于否定时，其会将null值排除掉。实际上，在真正的开发中，这三个关键字并不常用。 行子查询行子查询，返回的结果可以使一行多列或者多行多列。 需求：查询学生表中，年龄最大且身高最高的学生。 思路： 先确定数据源，学生表。 select * from student where age = ? and height = ?; 然后确定最大年龄和最大身高。 select max(age), max(height) from student; 执行如下 SQL 语句，进行测试： 1234-- 列子查询select * from student where-- 其中，(age, height) 称之为行元素(age, height) = (select max(age), max(height) from student); 表子查询表子查询，返回的结果是多行多列二维表（将子查询的结果当做二维表来使用），实际上，任何查询返回的结果都可以称之为二维表。 需求：找出每个班身高最高的学生。 思路： 先确定数据源，将学生按身高进行降序排序。 select * from student order by height desc; 从每个班级选出第一个学生。 select * from student group by c_id; 在这里，我们可能会有些疑问：为什么要将学生表降序排序？为什么从每个班级选出第一个学生就可以？这是因为group by（分组）只会取表中分组字段的第一条记录，而当我们将学生表按身高降序排序时，（每组）身高最高的学生就会出现在第一位。 执行如下 SQL 语句，进行测试： 123456-- 表子查询select * from -- 关键字 from 后面接表名(select * from student order by height desc) as student -- 按 c_id 进行分组group by c_id; 由上面的 SQL 语句可知，表子查询也是from子查询，即有select语句位于from之后。 exists子查询exists：表示是否存在的意思，因此exists子查询就是用来判断某些条件是否满足（跨表），exists是接在where之后，其返回的结果为1或0，满足条件为1，反之为0. 需求：在班级存在的前提下，查询所有的学生。 思路： 先确定数据源。 select * from student where ?; 然后确定条件是否满足。 exists(select * from class); 执行如下 SQL 语句，进行测试： 1234567891011-- exists 子查询select * from student whereexists(select * from class);-- 添加限定条件，满足条件select * from student whereexists(select * from class where id = 3);-- 添加限定条件，不满足条件select * from student whereexists(select * from class where id = 100); 至此，我们已经将子查询学习完啦！也许大家还会有些疑惑，那就是到底在什么时候用什么子查询？对于这个问题，我们不用过于纠结，因为这根本就是我们要用什么子查询的问题，而是根据实际需求，我们将查询返回的结果按形式命名的称呼而已。 查询class表： 查询student表： 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十四）「视图（上）」视图：view，是一种有结构（有行有列），但没有结果（结构中不真实存放数据）的虚拟表，虚拟表的结构来源不是自己定义的，而是从对应的基表（视图的数据来源）中产生的。 创建视图首先，给出创建视图的基本语法， 基本语法：create view + 视图名 + as + select语句; 其中，select语句可以是普通查询，也可以是连接查询、联合查询、子查询等。 此外，视图根据数据的来源，可以分为单表视图和多表视图： 单表视图：基表只有一个； 多表视图：基表至少两个。 执行如下 SQL 语句，进行测试： 12345678-- 单表视图create view my_v1 as select * from student;create view my_v2 as select * from class;-- 多表视图create view my_v3 asselect * from student as s left join class c on s.c_id = c.id; 如上图所示，在我们创建多表视图的时候，由于表student和class中都含有id字段，因此导致出现错误“重复列名”。修改上述创建多表视图的 SQL 语句，继续进行测试： 1234-- 多表视图create view my_v3 asselect s.*, c.grade, c.room from student as s left join class c on s.c_id = c.id; 如上图所示，当我们去掉表class中的id字段之后，成功创建多表视图。这是因为，当视图的基表有多张的时候，字段名不能重复。 查询视图在这里，查询视图是指查看视图的结构，而不是查看视图的结果。 由于视图是一张虚拟表，因此表的所用查询语句，都适用于视图，例如： desc + 视图名; show tables + 视图名; show create table + 视图名; 执行如下 SQL 语句，进行测试： 123-- 查询视图desc my_v1;show create table my_v1; 虽然视图是虚拟表，但它和真正的表，至少在关键字上还是有区别的，因此在查询视图创建语句的时候，可以使用如下 SQL 语句： 12-- 查询视图创建语句show create view my_v1; 此外，视图一旦创建，系统就会在视图对应的数据库文件夹下创建一个对应的frm结构文件，以保证结构的完整性。 使用视图在操作数据库表的过程中，使用视图，主要就是为了查询，因此将视图当做表一样查询即可。 在这里需要注意的是，虽然我们说视图是一个虚拟表，它不保存数据，但是它却可以获取数据。 执行如下 SQL 语句，进行测试： 1234-- 使用视图select * from my_v1;select * from my_v2;select * from my_v3; 如上图所示，我们查询视图的结果和查询创建视图时as后面连接的select语句的结果完全相同。 因此，我们也可以认为：创建视图，就是给一条select语句起别名，或者说是封装select语句。 修改视图视图本身不可修改，但是视图的来源（select）语句是可以修改的。因此，修改视图，就是修改视图的来源（select）语句。 基本语法：alter view + 视图名 + as + 新的select语句; 执行如下 SQL 语句，进行测试： 123-- 修改视图alter view my_v1 asselect id, name, gender, age, c_id from student; 删除视图与视图的其他操作相比，删除视图比较简单， 基本语法：drop view + 视图名; 执行如下 SQL 语句，进行测试： 12345-- 删除视图drop table my_v4;-- 删除视图drop view my_v4; 如上图所示，我们不能用 drop table + 视图名; 来删除视图，因为table包含真实的数据，而view说到底就是封装的select语句，并不包含真实的数据。虽然删除视图并不会影响数据，但在实际工作中，建议还是不要乱删别人建立的视图，因为视图封装的select语句很有可能包含复杂的业务逻辑。 视图意义 视图可以节省 SQL 语句，将一条复杂的查询语句用视图来进行封装，以后可以直接对视图进行操作； 数据安全，视图操作主要是针对查询的，如果对视图结构进行处理，例如删除，并不会影响基表的数据； 视图往往在大型项目中使用，而且是多系统使用，可以对外提供有用的数据，但是隐藏关键（或无用）的数据； 视图是对外提供友好型的，不同的视图提供不同的数据，就如专门对外设计的一样； 视图可以更好（或者说，容易）的进行权限控制。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十五）「视图（下）」视图数据操作：虽然我们说视图可以称之为select语句的别名，但实际上，它和别名并不一样，因为视图是可以进行数据写操作的，只不过有很多限制而已。 新增数据在这里，新增数据就是指通过视图直接对基表进行数据的新增操作。 限制 1：多表视图不能进行新增数据。 执行如下 SQL 语句，进行测试： 12345-- 查询视图 my_v3 结构desc my_v3;-- 多表视图新增数据insert into my_v3 values(7,&apos;Gates&apos;,&apos;boy&apos;,2,170,&apos;PM3.5&apos;,&apos;A315&apos;); 限制 2：可以向单表视图新增数据，但视图中包含的字段必须有基表中所有不能为空的字段。 执行如下 SQL 语句，进行测试： 123456789-- 查询 student 表结构desc student;-- 创建视图 my_v4create view my_v4 asselect id,name,age,c_id from student;-- 单表视图新增数据insert into my_v4 values(7,&apos;Gates&apos;,25,2); 如上图所示，在我们新建的视图my_v4中，没有包含不能为空的字段gender，因此在我们向my_v4中新增数据的时候，报错。其实，这也很好理解，试想，在 MySQL 尝试将视图中新增的数据（一条记录）插入到基表的时候，忽然发现一个本不能为null的字段的值为默认值null，自然就会报错啦！反之，如果单表视图中包含了基表中的全部非空字段，自然可以插入成功。执行如下 SQL 语句，进行测试： 123456789101112-- 查询 class 表数据select * from class;-- 创建视图 my_v5create view my_v5 asselect * from class;-- 单表视图新增数据insert into my_v5 values(2,&apos;PM2016&apos;,&apos;A315&apos;);-- 查询 class 表数据select * from class; 如上图所示，显然我们通过单表视图向基表中插入数据成功啦！ 删除数据与新增数据类似， 多表视图不能删除数据； 单表视图可以删除数据。 执行如下 SQL 语句，进行测试： 1234567891011121314-- 查询多表视图 my_v3select * from my_v3;-- 删除多表视图 my_v3 中记录delete from my_v3 where id = 2;-- 查询单表视图 my_v5select * from my_v5;-- 删除单表视图 my_v5 中记录delete from my_v5 where id = 2;-- 查询单表视图 my_v5select * from my_v5; 更新数据理论上，无论多表视图还是单表视图，都可以进行数据的更新。 执行如下 SQL 语句，进行测试： 123456789101112131415-- 查询单表视图 my_v5select * from my_v5;-- 更新单表视图 my_v5update my_v5 set grade = &apos;PM2014&apos; where id = 5;-- 查询单表视图 my_v5select * from my_v5;-- 查询单表视图 my_v5select * from my_v5;-- 更新单表视图 my_v5update my_v5 set grade = &apos;PM2014&apos; where id = 5;-- 查询单表视图 my_v5select * from my_v5; 此外，更新视图数据并不总是成功的，这是因为有更新限制的存在。那么何为更新限制呢？ 更新限制：with check option，如果创建视图的时候，设置了某个字段的限制，那么对视图进行更新操作的时候，系统就会进行验证，要保证更新之后，数据依然可以被查出来，否则不让更新。 执行如下 SQL 语句，进行测试： 123456789-- 创建单表视图 my_v6create view my_v6 asselect * from student where height &gt; 170 with check option;-- 查询单表视图 my_v6select * from my_v6;-- 更新单表视图 my_v6update my_v6 set height = 165 where id = 6; 如上图所示，在更新视图的时候，更新失败，这是因为其违反了我们设置的更新限制。那么，视图之外的数据，我们能不能修改呢？执行如下 SQL 语句，进行测试： 12345678-- 查询单表视图 my_v6select * from my_v6;-- 更新单表视图 my_v6update my_v6 set height = 188 where id = 4;-- 查询单表视图 my_v6select * from my_v6; 如上图所示，更新视图my_v6之外数据的时候，显示成功。但是，待我们重新查询视图my_v6数据的时候，发现并没有真正更新成功。这是为什么呢？原因就在于我们不能通过视图去操作视图之外的数据。举一个不太恰当的例子，我们不能用自己手去操作别人兜里的钱啊！ 视图算法视图算法，即系统对视图以及外部查询视图的select语句的一种解析方式。视图算法有三种，分别为： undefined：未定义（默认的），这不是一种实际使用的算法，而是一个“推卸责任”的算法。在未定义的情况下，告诉系统，视图没有定义算法，请自己选择。 temptable：临时表算法，系统先执行视图的select语句，后执行外部查询语句。 merge：合并算法，系统先将视图对应的select语句与外部查询视图的select语句进行合并，然后再执行。此算法比较高效，且在未定义算法的时候，经常会默认选择此算法。 对于视图的算法，我们需要在创建视图的时候指定， 基本语法：create + [algorithm = temptable/merge/undefined] + view + 视图名 + as + select语句; 执行如下 SQL 语句，进行测试： 123456789-- 查看视图 my_v2 的默认算法show create view my_v2;-- 指定视图 my_v7 算法为 temptablecreate algorithm = temptable view my_v7 asselect * from student;-- 查看视图 my_v7 的指定算法show create view my_v7; 如上图所示，我们指定了视图my_v7的算法为temptable，但是对于算法的选择，我们该如何判断呢？答案是：如果视图的select语句中包含一个查询子句（五子句，包括where、group by、order by 、having和limit），而且很有可能查询子句的顺序比外部的查询语句的顺序要靠后（五子句的顺序），那么一定要使用temptable算法，其他情况可以不用指定，默认即可。 至此，我们已经将视图的内容大致讲完了。有一点需要我们特别注意，那就是：视图最重要的功能就是查询，其他如增、删、改的操作一般不会使用，也不建议通过视图来操作基表的数据。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十六）「数据备份与还原」基础概念： 备份，将当前已有的数据或记录另存一份； 还原，将数据恢复到备份时的状态。 为什么要进行数据的备份与还原？ 防止数据丢失； 保护数据记录。 数据备份与还原的方式有很多种，具体可以分为：数据表备份、单表数据备份、SQL备份和增量备份。 数据表备份数据表备份，不需要通过 SQL 来备份，我们可以直接进入到数据库文件夹复制对应的表结构以及数据；在需要还原数据的时候，直接将备份（复制）的内容放回去即可。 不过想要进行数据表备份是有前提条件的，因为不同的存储引擎之间是有区别的。 对于存储引擎，MySQL 主要使用两种，分别为：InnoDB 和 Myisam，两者均免费。在这里，咱们可以顺便科普一下存储引擎的知识： 特点 Myisam InnoDB BDB Memory Archive 批量插入的速度 高 低 高 高 非常高 事务安全 —— 支持 支持 —— —— 全文索引 支持 5.5版本支持 —— —— —— 锁机制 表锁 行锁 页锁 表锁 行锁 存储限制 没有 64TB 没有 有 没有 B树索引 支持 支持 支持 支持 —— 哈希索引 —— 支持 —— 支持 —— 集群索引 —— 支持 —— —— —— 数据缓存 —— 支持 —— 支持 —— 索引缓存 支持 支持 —— 支持 —— 数据可压缩 支持 —— —— —— 支持 空间使用 低 高 低 N/A 非常低 内存使用 低 高 低 中等 低 外键支持 —— 支持 —— —— —— 其中，Myisam 和 InnoDB 的数据存储方法也有所区别： Myisam：表、数据和索引全部单独分开存储； InnoDB：只有表结构，数据全部存储到ibd文件中。 执行如下 SQL 语句，测试 Myisam 的数据存储方式： 12345678910111213-- 创建 Myisam 表create table my_myisam( id int)charset utf8 engine = myisam;-- 显示表结构show create table my_myisam;-- 插入数据insert into my_myisam values(1),(2),(3);-- 显示数据select * from my_myisam; 如上图所示，我们创建了名为my_myisam，存储引擎为 Myisam 的数据表。为了验证 Myisam 的存储特性，我们可以到data文件夹查看具体的数据存储情况： 如上图所示，我们仅仅创建了一个表my_myisam，但是 Myisam 对于会生成三个存储文件，分别为： my_myisam.frm：存储表的结构； my_myisam.MYD：存储表的数据； my_myisam.MYI：存储表的索引。 现在，我们将这三个文件复制到testoo数据库（至于如何找到 MySQL 数据文件的存储位置，可以参考详述查看 MySQL 数据文件存储位置的方法）： 执行如下 SQL 语句，进行测试： 12345678-- 切换数据库use testoo;-- 查看 testoo 数据库中的表show tables;-- 查看表 my_myisamselect * from my_myisam; 如上图所示，显然我们已经通过复制文件的方式，完成了数据表的备份工作。 在这里，有一点需要我们注意，那就是：我们可以将通过 InnoDB 存储引擎产生的.frm和.idb文件复制到另一个数据库，也可以通过show tables命令查看复制过来的表名称，但是却无法获得数据。 执行如下 SQL 语句，进行测试： 12345-- 查看 testoo 数据库中的表show tables;-- 查看表 my_classselect * from my_class; 通过以上测试，显然数据表备份这种备份方式更适用于 Myisam 存储引擎，而且备份的方式也很简单，直接复制 Myisam 存储引擎产生的.frm、.MYD和.MYI三个存储文件到新的数据库即可。 单表数据备份单表数据备份，每次只能备份一张表，而且只能备份数据，不能备份表结构。 通常的使用场景为：将表中的数据导出到文件。 备份方法：从表中选出一部分数据保存到外部的文件中， select */字段列表 + into outfile + &#39;文件存储路径&#39; + from 数据源; 在这里，使用单表数据备份有一个前提，那就是：导出的外部文件不存在，即文件存储路径下的文件不存在。 执行如下 SQL 语句，进行测试： 12-- 单表数据备份select * into outfile &apos;D:/CoderLife/testMySQL/class.txt&apos; from class; 如上图所示，SQL 语句已经执行成功。在这里，如果我们遇到： ERROR 1290 (HY000): The MySQL server is running with the –secure-file-priv option so it cannot execute this statement. 这个错误，可以通过查看「详述 MySQL 导出数据遇到 secure-file-priv 的问题」进行解决。 为了验证是否真的将class表中的数据导出到指定位置，我们可以到该路径下进行确认： 如上图所示，显然我们已经将class表中的数据导出到本地啦！不过在这里，有一点需要我们特别注意，那就是：对于从数据库导出的文件，我们最好用EditPlus等编辑工具打开，防止乱码。 此外，对于上述用于导出表中数据的 SQL 语法，其实我们可以颠倒书写顺序，也没有问题，例如： select */字段列表 + from 数据源 + into outfile + &#39;文件存储路径&#39;; 执行如下 SQL 语句，进行测试： 12-- 单表数据备份select * from class into outfile &apos;D:/CoderLife/testMySQL/class2.txt&apos;; 接下来，我们学习一些用于单表数据备份的高级操作，即自己指定字段和行的处理方式。 基本语法：select */字段列表 + into outfile + &#39;文件存储路径&#39; + fields + 字段处理 + lines + 行处理 + from 数据源; 字段处理： enclosed by：指定字段用什么内容包裹，默认是，空字符串； terminated by：指定字段以什么结束，默认是\t，Tab键； escaped by：指定特殊符号用什么方式处理，默认是\\，反斜线转义。 行处理： starting by：指定每行以什么开始，默认是，空字符串； terminated by：指定每行以什么结束，默认是\r\n，换行符。 执行如下 SQL 语句，进行测试： 123456789-- 指定单表数据备份处理方式select * into outfile &apos;D:/CoderLife/testMySQL/class3.txt&apos;-- 字段处理fieldsenclosed by &apos;&quot;&apos;terminated by &apos;|&apos;linesstarting by &apos;START:&apos;from class ; 如上图所示，显然导出文件class3.txt按照我们指定的格式进行输出啦！在前面，我们已经测试了各种单表数据备份的方式，现在我们删除数据，并尝试还原数据，即将保持在外部的数据重新恢复到数据表中。But，由于单表数据备份仅能备份数据，因此如果表结构不存在，则不能进行还原。 基本语法：load data infile + &#39;文件存储路径&#39; + into table + 表名 + [字段列表] + fields + 字段处理 + lines + 行处理; 执行如下 SQL 语句，进行测试： 123456789101112131415161718-- 删除表 class 中的数据delete from class;-- 查看表 class 中的数据select * from class;-- 还原表 class 中的数据load data infile &apos;D:/CoderLife/testMySQL/class3.txt&apos;into table class-- 字段处理fieldsenclosed by &apos;&quot;&apos;terminated by &apos;|&apos;linesstarting by &apos;START:&apos;;-- 查看表 class 中的数据select * from class; 如上图所示，显然在我们删除表class中的数据之后，还原数据成功。 SQL 备份SQL 备份，备份的是 SQL 语句。在进行 SQL 备份的时候，系统会对表结构以及数据进行处理，变成相应的 SQL 语句，然后执行备份。在还原的时候，只要执行备份的 SQL 语句即可，此种备份方式主要是针对表结构。 不过，MySQL 并没有提供 SQL 备份的指令，如果我们想要进行 SQL 备份，则需要利用 MySQL 提供的软件mysqldump.exe，而且mysqldump.exe也是一种客户端，因此在操作服务器的时候，必须进行认证。 基本语法：mysqldump.exe -hPup + 数据库名字 + [表名1 + [表名2]] &gt; 备份文件目录 其中，-hPup分别表示 h：IP 或者localhost； P：端口号； u：用户名； p：密码。 由于mysqldump.exe也是客户端，因此想执行上述命令，我们需要先退出 MySQL 客户端，然后在命令行窗口执行如下命令： 1mysqldump.exe -uroot -pbin.guo test class &gt; D:/CoderLife/testMySQL/classSQL.sql 如上图所示，虽然mysqldump给出了警告（在命令行中输入密码是不安全的），但是我们输入的命令已经成功执行啦！在这里，如果执行上述命令不成功的话，很有可能是我们没有配置环境变量的问题。 如上图所示，在testMySQL目录下，已经生产了对表class的 SQL 备份，至于 SQL 备份的内容到底是什么，我们可以打开classSQL.sql文件进行查看： 如上图所示，通过 SQL 备份的文件，包含了各种 SQL 语句，如创建表的语句以及插入数据的语句等等。 此外，在上面给出的执行 SQL 备份的基本语法中，我们可以看到表名都用[]括了起来，这表示可选项，如果不输入表名，则默认备份整个数据库。执行过程和上面一样，因此我们就不予演示啦！ 接下来，我们演示通过 SQL 备份的文件还原数据，有两种方式： 方式 1：使用mysql.exe客户端还原数据 基本语法mysql.exe/mysql -hPup 数据库名称 + 数据库名字 + [表名1 + [表名2]] &lt; 备份文件目录 在命令行窗口执行如下命令，进行测试： 1234567891011121314-- 登录 MySQL 客户端mysql -uroot -p-- 输入密码，切换数据库use test;-- 删除表 class 中的数据delete from class;-- 退出数据库\q-- 通过 SQL 备份的文件还原数据mysql -uroot -pbin.guo test &lt; D:/CoderLife/testMySQL/classSQL.sql 如上图所示，上述命令全部执行成功。下面，我们检查还原结果， 如上图所示，显然表class的数据在删除之后，我们通过 SQL 备份的文件还原了数据。 方式 2：使用 SQL 命令还原数据 基本语法source + 备份文件目录; 执行如上 SQL 语句，进行测试： 1234567891011121314-- 查看表 class 数据select * from class;-- 删除表 class 数据delete from class;-- 查看表 class 数据select * from class;-- 通过 SQL 备份的文件还原数据source D:/CoderLife/testMySQL/classSQL.sql;-- 查看表 class 数据select * from class; 如上图所示，显然表class的数据在删除之后，我们通过 SQL 备份的文件利用第二种方式还原了数据。 通过上面的学习及测试，我们可以知道 SQL 备份的优缺点： 优点：可以备份表结构； 缺点：增加额外的 SQL 命令，会浪费磁盘空间。 增量备份增量备份，不是针对数据或者 SQL 进行备份，而是针对 MySQL 服务器的日志进行备份，其日志内容包括了我们对数据库的各种操作的历史记录，如增删改查等。此外，增量备份是指定时间段进行备份，因此备份的数据一般不会出现重复的情况，常用于大型项目的数据备份。在此，我们就不详细的进行介绍了，至于这部分的内容，以后会单独写一篇关于如何进行增量备份的博文。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十七）「事务（上）」 案例：银行的数据库里面存储着用户的账户信息表，当用户 A 想用户 B 转账的时候，正常情况下，A 账户的余额减少，B 账户的余额增加；但是由于某种原因（例如突然断电），当 A 账户的余额减少之后，B 账户的余额并没有增加，这就造成了数据库数据的安全隐患。 解决方案：当 A 账户的余额减少之后，不要立即修改数据表，而是在确认 B 账户的余额增加之后，同时修改数据表。 事务通过前面的案例及解决方案，我们就引出了一个全新的概念，那就是：事务，即 一系列将要发生或正在发生的连续操作。 而事务安全，是一种保护连续操作同时实现（完成）的机制。事务安全的意义就是，保证数据操作的完整性。 首先，执行如下 SQL 语句，创建银行账户表并插入数据： 123456789101112-- 创建银行账户表create table bank_account( id int primary key auto_increment, cardno varchar(16) not null unique comment &apos;bank card number&apos;, name varchar(20) not null, money decimal(10,2) default 0.0 comment &apos;account balance&apos; )charset utf8;-- 插入数据insert into bank_account values(null, &apos;0000000000000001&apos;, &apos;Charies&apos;, 8000),(null, &apos;0000000000000002&apos;, &apos;Gavin&apos;, 6000); 接下来，让我们一起了解事务的操作。 事务操作事务操作，分为两种：自动事务（默认的），手动事务。 在这里，以银行账户的余额增减为例，我们来了解手动事务的操作流程。 第 1 步：开启事务，告诉系统以下所有操作，不要直接写入数据库，先存到事务日志。 基本语法：start transaction; 执行如上 SQL 语句，开启事务： 12-- 开启事务start transaction; 第 2 步：减少 Charies 账户的余额 1234-- 更新 Charies 账户余额update bank_account set money = money - 1000 where id = 1;-- 查询 bank_account 表数据select * from bank_account; 如上图所示，Charies 账户的余额显示减少1000，但实际上，由于我们开启了事务，数据表真实的数据，并没有同步更新。为了验证这个论断，我们重新打开一个数据库客户端，查询bank_account表的数据： 如上图所示，显然数据库的事务安全机制起了作用，当我们开启（手动）事务之后，其后一系列操作并没有直接写入数据库，而是存入了事务日志。在这里，我们并没有打开数据库事务的日志进行验证，因为事务日志存储的是经过编译之后的字节码文件。 第 3 步：增加 Gavin 账户的余额 1234-- 更新 Gavin 账户余额update bank_account set money = money + 1000 where id = 2;-- 查询 bank_account 表数据select * from bank_account; 如上图所示，Gavin 账户的余额显示增加1000，但是，由于我们开启了事务，数据表真实的数据，仍然没有同步更新。 第 4 步：提交事务或回滚事务 提交事务基本语法：commit; 回滚事务基本语法：rollback; 如果我们选择提交事务，则将事务日志存储的记录直接更新到数据库，并清除事务日志；如果我们选择回滚事务，则直接将事务日志清除，所有在开启事务至回滚事务之间的操作失效，保持原有的数据库记录不变。在这里，我们以提交事务为例： 1234-- 提交事务commit;-- 查询 bank_account 表数据select * from bank_account; 如上图所示，当我们提交事务之后，数据库的真实记录更新，两个客户端的数据一致。 在此，值得我们注意的是：当我们提交事务之后，在进行回滚事务是不起作用的，因为事务日志在提交事务的同时已经被清除啦！ 此外，我们还要知道：现阶段，只有 InnoDB 和 BDB 两个存储引擎是支持事务安全机制的，其中 InnoDB 免费，BDB 收费。因此，InnoDB 使用的最为广泛。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十八）「事务（下）」 温馨提示：在「事务（上）」中，我们已经了解了如何在 MySQL 中开启事务，以及事务的一些基本操作。在本文中，我们将进一步学习事务的知识，包括事务原理、自动事务、回滚点和事务特性等。 事务原理事务原理：在事务开启之后，所有的操作都会被临时存储到事务日志，事务日志只有在收到commit命令之后，才会将操作同步到数据表，其他任何情况都会清空事务日志，例如突然断开连接、收到rollback命令等。 接下来，我们简单分析一下 MySQL 的操作过程： Step 1：客户端与服务端建立连接，同时开启一个临时的事务日志，此事务日志只作用于当前用户的当次连接； Step 2：在客户端用 SQL 语句执行写操作，客户端收到 SQL 语句，执行，将结果直接写入到数据表，并将数据表同步到数据库； Step 3：我们在客户端开启事务，则服务端原来的操作机制被改变，后续所有操作都会被先写入到临时日志文件； Step 4：在客户端执行 SQL 语句（例如写操作），服务端收到 SQL 语句，执行，将结果写入到临时日志文件，并不将结果同步到数据库； Step 5：在客户端执行查询操作，服务端直接从临时日志文件中捞取数据，返回给客户端； Step 6：在客户端执行commit或者rollback命令，清空临时日志文件，如果是commit命令，则将结果同步到数据库；如果是rollback命令，则不同步。 通过上面的分析，我们就知道了为什么在我们同时开启两个 MySQL 客户端窗口（两次连接）时，当一个窗口开启事务并执行 SQL 操作之后，另一个窗口在查询时并不会收到同步数据。原因就在于，当我们开启事务之后，服务端会将后续的操作都写入到临时日志文件，而另一个窗口在查询的时候，则是直接从数据库捞取数据，并会不走前一个的临时日志文件。 回滚点回滚点：在某个操作成功完成之后，后续的操作有可能成功也有可能失败，但无论后续操作的结果如何，前一次操作都已经成功了，因此我们可以在当前成功的位置，设置一个操作点，其可以供后续操作返回该位置，而不是返回所有操作，这个点称之为回滚点。关于回滚点的基本语法为， 设置回滚点：savepoint + 回滚点名称; 返回回滚点：rollback to + 回滚点名称; 执行如下 SQL 语句，进行测试： 123456789101112131415161718-- 测试回滚点-- 查询 bank_account 表数据select * from bank_account;-- 开启事务start transaction;-- 事务操作 1：给 Charies 发工资 1000 元update bank_account set money = money + 10000 where id = 1;-- 设置回滚点savepoint spone;-- 银行扣税：错误update bank_account set money = money - 10000 * 0.05 where id = 2;-- 查询 bank_account 表数据select * from bank_account; 执行如下 SQL 语句，继续进行测试： 123456789101112-- 测试回滚点-- 返回回滚点rollback to spone;-- 银行扣税：正确update bank_account set money = money - 10000 * 0.05 where id = 1;-- 查询 bank_account 表数据select * from bank_account;-- 提交事务commit; 如上图所示，显然在执行返回回滚点的操作之后，我们之前的错误操作得到了修正。 自动事务在 MySQL 中，默认的都是自动事务处理，即用户在操作完成之后，其操作结果会立即被同步到数据库中。 自动事务是通过autocommit变量控制的，我们可以通过如下 SQL 语句，进行查看： 12-- 查询自动事务show variables like &apos;autocommit&apos;; 如上图所示，此为 MySQL 的默认设置。实际上，我们可以自己选择是否开启自动事务处理，其基本语法为， 开启自动事务处理：set autocommit = on / 1; 关闭自动事务处理：set autocommit = off / 0; 在此，我们以关闭自动事务处理为例，进行演示： 1234567891011121314-- 关闭自动事务处理set autocommit = 0;-- 查看自动事务处理show variables like &apos;autocommit&apos;;-- 查看 bank_account 表数据select * from bank_account;-- 修改 bank_account 表数据update bank_account set money = money + 1000 where id = 1;-- 查看 bank_account 表数据select * from bank_account; 如上图所示，我们并没有开启事务，仅是关闭了自动事务处理，但是我们发现，在我们修改了bank_account表中数据之后，其结果并不会立即同步到数据库。实际上，这就是关闭了自动事务处理的正常现象。在我们执行commit命令之后，上述操作的结果即可进行同步： 12345-- 提交commit;-- 查看 bank_account 表数据select * from bank_account; 当然，如果我们不执行commit命令，而是执行rollback命令，那么之前的所用操作都会回滚到初始的状态。在此，我们需要注意的是：通常情况下，我们是应该开启自动事务处理的，否则的话，每次操作完成之后都需要我们手动提交，那岂不是要被累死了？ 事务特性事务的特性，可以简单的概括为ACID，具体为： 原子性：Atomic，表示事务的整个操作是一个整体，是不可分割的，要么全部成功，要么全部失败； 一致性：Consistency，表示事务操作的前后，数据表中的数据处于一致状态； 隔离性：Isolation，表示不同的事务操作之间是相互隔离的，互不影响； 持久性：Durability，表示事务一旦提交，将不可修改，永久性的改变数据表中的数据。 对于上述事务的四个特性，其中原子性、一致性、持久性比较容易理解，但是隔离性却需要格外注意。例如，开启两个客户端窗口，分别执行如下 SQL 语句，进行测试： 123456789101112131415161718192021-- 演示隔离性操作：窗口 1-- 开始事务start transaction;-- 修改 id 为 1 的数据update bank_account set money = money + 666 where id = 1;-- 查看 bank_account 表数据select * from bank_account;--------- 万人迷分割线 ----------- 演示隔离性操作：窗口 2-- 开始事务start transaction;-- 修改 id 为 2 的数据update bank_account set money = money + 666 where id = 2;-- 查看 bank_account 表数据select * from bank_account; 如上图所示，其完美的展示了事务隔离性的效果，即窗口 1 的中的事务操作，没有影响到窗口 2 的事务操作；窗口 2 的中的事务操作，也没有影响到窗口 1 的事务操作。But，在我们执行下面的 SQL 语句之后，我们将会看到不同的效果： 123456789101112131415161718192021-- 演示隔离性操作：窗口 1-- 开始事务start transaction;-- 修改 name 为 Charies 的数据update bank_account set money = money + 666 where name = &apos;Charies&apos;;-- 查看 bank_account 表数据select * from bank_account;--------- 万人迷分割线 ----------- 演示隔离性操作：窗口 2-- 开始事务start transaction;-- 修改 name 为 Gavin 的数据update bank_account set money = money + 666 where name = &apos;Gavin&apos;;-- 查看 bank_account 表数据select * from bank_account; 如上图所示，窗口 1 的事务可以正常执行，但是窗口 2 的事务开启成功，但是在修改数据的时候被“卡”住了，并且在持续一段时间之后，报出了一个 Lock wait timeout exceeded的错误： 那么到底是什么原因导致了上述错误的发生呢？这就是涉及到了数据库的另外一个知识点 锁机制 啦！ 实际上，MySQL 使用的默认存储引擎是 InnoDB，而 InnoDB 默认使用的锁机制是 行锁（锁住操作的当前行），但是如果在事务操作的过程中，我们没有使用索引字段，那么系统就会自动进行全表检索，也就是其自动将行锁升级为 表锁（锁住操作的当前表）。 现在回想一下，我们在第一次测试的时候，使用的条件id为主键索引，所以两个事务可以表示出很好的隔离性，互不影响；在第二次测试的时候，我们将条件换为name，而name并不是索引字段，因此在第二次测试的时候，窗口 1 的事务使用了表锁，锁住了整张表，而在事务提交或回滚之前，其并不释放锁，所以所有试图修改被锁住表的数据的操作，都会陷入等待状态。等待超时，自然就报错啦！ 对于锁机制，在「基础教程」篇，我们并不做过多的介绍，在后续的「性能优化」篇中在详细的进行讨论。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （二十九）「数据库变量」变量在 MySQL 数据库中，变量有两种，分别为：系统变量和自定义变量。 根据变量的作用范围，又分为： 会话级别变量：仅对当前客户端当次连接有效； 全局级别变量：对所有客户端的任一次连接都有效。 系统变量系统变量，顾名思义，是系统设置好的变量（皆为全局级别变量），也是用来控制服务器表现的，如autocommit、wait_timeout等。 大多数的时候，我们并不需要使用系统变量，但我们仍然需要了解有这么回事，在必须要的时候，它可以帮助我们完成特殊的需求。 首先，查看系统变量，语法为： 基本语法：show variables; 执行如下 SQL 语句，进行测试： 12-- 查看系统变量show variables; 如上图所示，显示了 MySQL 在本服务器上共含有 506 个系统变量。更近一步，我们可以查看具体的系统变量的值，语法为： 基本语法：select + @@变量名 + [, @@变量名, ... , @@变量名]; 执行如下 SQL 语句，进行测试： 12-- 查看具体的系统变量的值select @@autocommit,@@version,@@version_compile_os,@@wait_timeout; 如上图所示，我们查到了具体的变量的值。此外，任何一个有内容返回的查询操作都是用select来完成的。 接下来，我们尝试修改系统变量，先修改会话级别变量，再修改全局级别变量。 对于修改会话级别变量，有两种方法，语法分别为： 基本语法 1：set 变量名 = 值; 基本语法 2：set @@变量名 = 值; 执行如下 SQL 语句，进行测试： 123456-- 设置会话级别变量set autocommit = 0;set @@wait_timeout = 20000;-- 查看系统变量select @@autocommit, @@wait_timeout; 如上图所示，我们修改了autocommit和wait_timeout的值，但仅作用于会话级别，即只有当前当次连接有效，当再次打开一个新窗口的时候，我们会发现所有的变量值都恢复如初。 对于修改全局级别变量，语法为： 基本语法：set global 变量名 = 值; 执行如下 SQL 语句，进行测试： 12345-- 设置全局级别变量set global autocommit = 0;-- 查看系统变量select @@autocommit; 如上图所示，当我们修改全局变量的时候，其效果对所有客户端的任一次连接都有效。But，如果某一个客户端在我们修改全局变量之前已经连上了服务器并且没有退出的话，那么我们的修改对其当前当次连接无效，需要重新登录才能生效。 自定义变量自定义变量，顾名思义，是用户自己定义的变量，并且都是会话级别的变量。 系统为了区别系统变量与自定义变量，规定用户自定义的变量必须使用一个@符号。设置自定义变量的语法为： 基本语法：set @变量名 = 值; 执行如下 SQL 语句，进行测试： 12345-- 设置自定义变量set @name = &apos;binguo&apos;;-- 查看自定义变量select @name; 观察上图，我们会发现查看自定义变量和系统变量有些细微的区别，那就是：查看系统变量时，select后面是跟着@@的，而查看自定义变量时，select后面是跟着@的。在这里，我们需要注意：在 MySQL 中，很多地方会默认将=处理为比较符号，因此 MySQL 还提供了另外一种赋值符号:=，即冒号与等号拼接而成的符号。 此外，MySQL 允许我们从数据表中获取数据，然后直接赋值给变量，共有两种方式，分别为： 第 1 种：边赋值，边查看结果。语法为 基本语法：select @变量名 := 字段名 from 表名; 执行如下 SQL 语句，进行测试： 12345-- 从数据表中获取数据，然后直接为自定义变量赋值select @name = name from student;-- 查看自定义变量select @name; 如上图所示，呃，这是什么鬼？好吧，细心的同学估计已经发现了，在上面的select语句中，我们误将:=写为=啦，然后 MySQL 将=处理为比较符号，并且在student表中没有发现与binguo匹配的名字，因此显示的结果皆为0，如果匹配成功，则会显示1。下面，我们修改赋值符号，重新进行测试： 12345-- 从数据表中获取数据，然后直接为自定义变量赋值select @name := name from student;-- 查看自定义变量select @name; 如上图所示，我们会发现上述select语句的作用为：从student表读取数据，然后依次赋值给自定义变量@name，并且先赋的值会被覆盖，仅保留最后一个赋值结果。 第 2 种：只赋值，不查看结果。语法为 基本语法：select + 字段列表 + from + 表名 + into + 变量列表; 执行如下 SQL 语句，进行测试： 12345678-- 从数据表中获取数据，然后直接为自定义变量赋值select name from student into @name;-- 查看自定义变量select @name;-- 查看 student 表数据select * from student; 如上图所示，显然EEROR，内容为：返回结果包含的内容超过一列。实际上，在未加限制条件的情况下，我们直接从表中捞取数据，是捞取全部数据，因此忽略上述 SQL 语句中的into @name，其返回的结果为表中的全部name值，自然是超过一个了。在这种情况下，系统会报错，却将捞取数据的第一个值赋值给了@name，也就是说，在捞取数据超过一条记录的时候，系统会默认将第一个值赋值给自定义变量。 虽然上述 SQL 语句修改了@name的值，但却是一种错误的赋值方式，也是不可控的，其结果往往并不是我们想要的。对于上述的赋值方式，MySQL 的要求比较严格，规定每次只能获取一条记录。因此正确的做法是，加上一个where条件，将查询的结果限制为一条，例如 12345-- 从数据表中获取数据，然后直接为自定义变量赋值select name from student where id = 2 into @name;-- 查看自定义变量select @name; 如上图所示，我们获取数据并赋值成功。 最后，在强调一点：自定义变量都是会话级别，只要是当前用户当次连接，都会受到影响，不区分数据库。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （三十）「触发器」 案例：网上购物，根据生产订单的类型，商品的库存量对应的进行增和减。此案例涉及两张表，分别为订单表和商品表，下单时，商品表库存减少；退单时，商品表库存增加。如何实现？ 触发器触发器：trigger，是指事先为某张表绑定一段代码，当表中的某些内容发生改变（增、删、改）的时候，系统会自动触发代码并执行。 触发器包含三个要素，分别为 事件类型：增删改，即insert、delete和update； 触发时间：事件类型前和后，即before和after； 触发对象：表中的每一条记录（行），即整张表。 每张表只能拥有一种触发时间的一种事件类型的触发器，即每张表最多可以拥有 6 种触发器。 创建触发器12345678-- 创建触发器基本语法delimiter 自定义符号 -- 临时修改语句结束符，在后续语句中只有遇到自定义符号才会结束语句create trigger + 触发器名称 + 触发器时间 + 事件类型 on 表名 for each rowbegin -- 代表触发器内容开始-- 触发器内容主体，每行用分号结尾end -- 代表触发器内容结束自定义符号 -- 用于结束语句delimiter ; -- 恢复语句结束符 根据上述案例的需求，我们先来创建两张表，分别为商品表goods和订单表orders，SQL 语句如下： 1234567891011121314151617-- 创建商品表create table goods( id int primary key auto_increment, name varchar(20) not null, price decimal(10, 2) default 0, inventory int comment &apos;商品库存量&apos;)charset utf8;-- 插入两条数据insert into goods values(null, &apos;iPhone8&apos;, 5088, 1000), (null, &apos;iPhoneX&apos;, 8088, 1000);-- 创建订单表create table orders( id int primary key auto_increment, goods_id int not null, goods_number int default 1)charset utf8; 接下来，执行如下 SQL 语句，创建触发器： 123456789-- 创建触发器delimiter $$ -- 临时修改语句结束符create trigger after_order after insert on orders for each rowbegin -- 触发器内容开始 -- 触发器内容主体，每行用分号结尾 update goods set inventory = inventory - 1 where id = 1;end -- 触发器内容结束$$ -- 结束语句delimiter ; -- 恢复语句结束符 查询触发器查询所有触发器或模糊匹配， 基本语法：show triggers + [like &#39;pattern&#39;]; 执行如下 SQL 语句，进行测试： 12-- 查询所有触发器，\G 表示旋转show triggers\G; 当然，我们也可以查询创建触发器的语句 基本语法：show create trigger + 触发器名称; 执行如下 SQL 语句，进行测试： 12-- 查询触发器创建语句，\G 表示旋转show create trigger after_order\G; 此外，所有的触发器都会被系统保持到information_schema.triggers这张表中，执行如下 SQL，进行测试：12-- 查询触发器，\G 表示旋转select * from information_schema.triggers\G; 使用触发器实际上，触发器不是我们手动触发的，而是在某种情况发生的时候自动触发，例如我们上面创建的after_order触发器，当我们insert订单表的时候，该触发器自动执行。执行如下 SQL 语句，进行测试： 12345678910-- 查看商品表select * from goods;-- 查看订单表select * from orders;-- 插入订单表insert into orders values(null, 2, 10);-- 查看订单表select * from orders;-- 查看商品表select * from goods; 观察上图，我们会发现：触发器确实生效了，在我们向orders表insert数据的时候，goods表发生了变化；但是其并没有如我们期望那样执行，就算我们将goods_id设置为2，goods_number设置为10，触发器操作的仍然是goods表中id为 1的记录且库存量只减1。且先不提这个问题，在创建触发器的时候，我们要特别注意：触发器的触发对象和事件类型，决不能同触发器主体的内容相同，防止发生死循环。 修改触发器 &amp; 删除触发器触发器不能修改，只能删除。因此，当我们需要修改触发器的时候，唯一的方法就是：先删除，后新增。 基本语法：drop trigger + 触发器名称; 执行如下 SQL 语句，进行测试： 1234-- 删除触发器drop trigger after_order;-- 查询触发器show triggers; 触发器记录触发器记录：无论触发器是否触发，只要当某种操作准备执行，系统就会将当前操作的记录的当前状态和即将执行之后的状态分别记录下来，供触发器使用。其中，当前状态被保存到old中，操作之后的状态被保存到new中。至于old和new是什么鬼？不知道大家是否还记得查看表information_schema.triggers的时候，标红的两个字段： ACTION_REFERENCE_OLD_ROW：OLD ACTION_REFERENCE_NEW_ROW：NEW 其中， OLD，代表是旧记录，也就是当前记录的状态，插入时没有OLD； NEW，代表是新记录，也就是假设操作发生之后记录的状态，删除时没有NEW。 无论OLD还是 NEW，都代表记录本身，而且任何一条记录除了有数据，还有字段名。因此，使用OLD和 NEW的方法就是： 基本语法：OLD/NEW + . + 字段名 在这里，我们就能够通过触发器记录解决刚才after_order触发器的问题了。依次执行如下 SQL 语句，进行测试： 123456789101112-- 创建新触发器delimiter $$ -- 临时修改语句结束符create trigger after_order_new after insert on orders for each rowbegin -- 触发器内容开始 -- 触发器内容主体，每行用分号结尾 update goods set inventory = inventory - NEW.goods_number where id = NEW.goods_id;end -- 触发器内容结束$$ -- 结束语句delimiter ; -- 恢复语句结束符-- 查看新触发器show triggers\G; 12345678910-- 查看商品表select * from goods;-- 查看订单表select * from orders;-- 插入订单表insert into orders values(null, 2, 10);-- 查看订单表select * from orders;-- 查看商品表select * from goods; 如上图所示，显然after_order_new触发器按我们预期那样正确的工作啦！ 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （三十一）「代码执行结构」代码执行结构在 MySQL 编程中，代码的执行结构有三种，分别为： 顺序结构； 分支结构； 循环结构。 顺序结构，自不必多说，在本文中，我们着重了解分支结构和循环结构。 分支结构分支结构：事先准备多个代码块，通过判断条件是否满足，执行对应的代码。 在 MySQL 中，只有if分支结构，其基本语法为： 12345if 条件判断 then -- 满足条件时，要执行的代码else -- 可以没有 else 语句 -- 不满足条件时，要执行的代码end if; 接下来，我们利用触发器和if分支，完成这样的需求： 在生成订单前，判断商品的库存是否满足，如果满足，则插入订单；否则，插入失败。 依次执行如下 SQL 语句，进行测试： 123456789101112131415161718192021-- 查看商品表select * from goods;-- 查看订单表select * from orders;-- 修改语句结束符delimiter $$-- 创建触发器create trigger before_order before insert on orders for each rowbegin -- 判断商品库存是否满足订单 -- 通过商品表获取商品库存量 select inventory from goods where id = NEW.goods_id into @inventory; -- 比较库存 if @inventory &lt; NEW.goods_number then -- 库存不够，由于触发器不能阻止事件发生，因此我们只能暴力报错 insert into XXX values(XXX); end if;end$$-- 恢复语句结束符delimiter ; 123456-- 插入订单insert into orders values(null, 1, 1000);-- 查看商品表select * from goods;-- 查看订单表select * from orders; 123456-- 插入订单insert into orders values(null, 1, 100);-- 查看商品表select * from goods;-- 查看订单表select * from orders; 如上图所示，虽然在报错的时候，没有给出友好的提示信息，但我们已经实现了该需求。 循环结构循环结构：表示某段代码在指定条件下进行重复执行动作。 在 MySQL 中，没有for循环，仅有while循环、loop循环和repeat循环，呃，还有一种非标准的goto循环，在此我们仅介绍while循环，其基本语法为： 1234while 条件判断 do -- 满足条件时要执行的代码 -- 变更循环条件end while; 在使用循环结构的时候，我们经常需要对循环进行控制，即在循环结构内部进行判断和控制。虽然在 MySQL 中没有continue和break，但是有其替代关键字： iterate：迭代，类似于continue，表示结束本次循环，不执行后续步骤，直接开始下一次循环； leave：离开，类似于break，直接结束整个循环。 上述两个关键字的使用方法为， 基本语法：iterate/leave + 循环名称; 因此，在我们定义循环结构的时候，就需要进行略微的修改了，具体形式如下： 12345循环名称: while 条件判断 do -- 满足条件时要执行的代码 -- 变更循环条件 iterate/leave 循环名称; -- 控制循环语句end while; 由于触发器只能执行简单的一次触发动作，因此不适合演示循环结构。循环结构需要结合函数进行使用，所以在介绍函数的时候，我们再来体验循环结构的魅力。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （三十二）「函数」函数函数，就是将一段代码封装到一个结构中，在需要执行该段代码的时候，直接调用该结构（函数）执行即可。此操作，实现了代码的复用。在 MySQL 中，函数有两种，分别为：系统函数和自定义函数。 系统函数顾名思义，系统函数就是系统定义好的函数，在需要的时候，我们直接调用即可。 任何函数都有返回值（对于空函数，我们就认为其返回值为空），而且在 MySQL 中任何有返回值的操作都是通过select来操作的，因此 MySQL 的函数调用就是通过select来实现的。 在 MySQL 中，字符是字符串操作中最常见的基本单位。此外，如果对中文的截取是按字节进行的话，很容易造成乱码的问题。 下面，我们介绍一些常见的、对字符进行操作的系统函数：首先，执行如下语句，定义一些变量， 1234567set @cn = &apos;你好世界&apos;;set @en = &apos;hello world&apos;;set @one = &apos;charies&apos;;set @two = &apos;gavin&apos;;set @three = &apos;Gavin&apos;;select @cn, @en, @one, @two, @three; 然后，调用系统函数进行测试： substring，截取字符串，单位为字符； 如上图所示，在 MySQL 中字符串的位置是从1开始，0含有特殊的意义。 char_length，获取字符长度； length，获取字节长度； instr，判断字符串中某个子串是否存在，存在则返回具体的位置，不存在则返回0； lpad，左填充，将字符串按照某个指定的填充方式，填充到指定（字符）长度； 如上图所示，在对@en进行填充的时候，填充结果为hellohellhello world，其中第二个hello并没有填充全，这是因为系统函数lpad的第二个参数限定的了变量@en的具体长度，如示例中我们设置其为20，而原@en的长度为11，因此只能向@en中在填充9个字符。 insert，找到目标位置，将指定长度的字符串替换为目标字符串； 如上图所示，insert函数并没有修改变量自身的值，只是对变量的值进行加工而已。 strcmp，比较字符串的大小； 如上图所示，在用strcmp函数对字符串进行比较的时候不区分大小写（默认校对集），并用0表示两个字符串相等；用-1表示第一个参数的字符串小于第二个参数的字符串；用1表示第一个参数的字符串大于第二个参数的字符串。 自定义函数对于任意一个函数，其都包含如下要素： 函数名； 参数类别（可以为空）； 返回值； 函数体（作用域）。 根据上面这些函数要素，我们就来尝试创建自定义函数。 创建函数123456-- 基本语法create function 函数名([参数列表]) returns 数据类型begin -- 函数体 -- 返回值，类型为 returns 指定的数据类型end 如果我们定义的函数的函数体内仅含有返回值，则可以省略begin和end。此外，自定义函数和系统函数的调用方式相同。执行如下语句，进行测试： 12345-- 自定义函数create function showLove() returns intreturn 521;-- 调用自定义函数select showLove(); 查看函数查看函数，基本语法为： show function status + [like &#39;pattern&#39;]; 如上图所示，我们可以看到showLove函数是属于test数据库的，这引出了函数的一个性质，即函数是属于具体数据库的，在一个数据库定义的函数不能在其定义的数据库外使用，但是可以查看。 查看函数的创建语句，基本语法为： show create function + 函数名; 修改函数 &amp; 删除函数函数只能先删除后新增，不能修改。删除函数的基本语法为： drop function + 函数名; 执行如下语句，进行测试： 1234-- 删除函数drop function showLove;-- 查看函数show function status like &apos;showLove&apos;\G; 函数参数对于函数的参数，一共有两种，分别为形参和实参，其中，形参可以理解为定义函数时使用的参数，且形参必须指定数据类型；实参可以理解为在调用函数时传入的值或变量。因此，函数定义的具体形式应该为： function 函数名(形参名字 形参类型) returns 返回数据类型 下面，我们定义一个函数，完成一个简单的需求，即求1到指定数值的和。代码如下： 123456789101112131415161718delimiter $$create function addAll(num int) returns intbegin -- 定义条件变量 set @i = 1; set @res = 0; -- 保存求和结果 -- 循环求和 while @i &lt;= num do -- 任何变量想要修改值都必须使用 set 关键字，且 MySQL 中没有 += 或者 ++ 运算符 set @res = @res + @i; -- 修改循环变量 set @i = @i + 1; end while; -- 返回求和结果 return @res;end$$delimiter ; 如上图所示，函数已经定义成功。接下来，执行如下语句，进行测试： 12345-- 调用函数求和select addAll(100);-- 查询自定义变量 @res 和 @iselect @res, @i; 如上图所示，求和函数addAll已经正确执行。此外，我们发现在函数内部使用@符号定义的变量@res和@i在函数外部也是可以查看使用的，这说明：使用@符号定义的变量为全局变量。 变量作用域在 MySQL 中，变量的作用域有两种，分别为全局和局部，其中，全局变量可以在任何地方使用；局部变量只能在函数内部使用。 全局变量：使用set关键字定义，用@符号标识； 局部变量：使用declare关键字声明，且所用的局部变量必须在函数体开始之前进行声明。 接下来，我们利用局部变量定义一个函数，完成一个简单的需求，即求1到指定数值的和，要求10的倍数不加。代码如下： 12345678910111213141516171819202122232425delimiter $$create function addAll2(num int) returns intbegin -- 声明变量，包含循环变量和结果变量 declare i int default 1; -- 定义局部变量可以含有属性 declare res int default 0; -- 循环求和 mywhile:while i &lt;= num do -- 条件判断 if i % 10 = 0 then -- 修改循环变量 set i = i + 1; -- 重新循环 iterate mywhile; end if; -- 修改结果变量 set res = res + i; -- 修改循环变量 set i = i + 1; end while; -- 返回求和结果 return res;end$$delimiter ; 如上图所示，函数已经定义成功。接下来，执行如下语句，进行测试： 12-- 调用函数求和select addAll(100), addAll2(100); 如上图所示，函数已经正确执行。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 （三十三）「存储过程」存储过程存储过程简称过程，procedure，是一种用来处理数据（增删改）的方式。简单点，我们也可以将其理解为没有返回值的函数。 创建过程12345-- 基本语法create procedure 过程名([参数列表])begin -- 过程体end 如果我们定义的过程的过程体内仅含有一条语句，则可以省略begin和end。执行如下语句，进行测试： 123-- 创建过程create procedure pro()select * from student; 如上图所示，我们创建了一个名为pro()的过程，其目的就是为了查询student表中的数据。但实际上，过程多用于处理数据，查询并不多用。 查看过程查看过程，基本语法为： show procedure status + [like &#39;pattern&#39;]; 查看过程的创建语句，基本语法为： show create procedure + 过程名; 调用过程由于函数有返回值，因此我们可以用select来调用函数。但是存储过程没有返回值，怎么办？实际上，对于存储过程，有一个专门的调用关键字call，调用过程的基本语法为： call + 过程名; 修改过程 &amp; 删除过程过程只能先删除后新增，不能修改。删除过程的基本语法为： drop procedure + 过程名; 执行如下语句，进行测试： 1234-- 删除过程drop procedure pro;-- 查看过程show procedure status like &apos;pro&apos;\G; 过程参数函数的参数需要指定数据类型，过程比函数更加严格。过程有三种自己的参数类型，分别为： in，数据只是从过程外部传入给过程内部使用，可以是数值也可以是变量； out，此参数只能传递变量，且变量指向的数据需要先清空然后才能进入过程内部，该引用供过程内部使用，过程结束后可以将变量的值传递给过程外部使用； inout，此参数只能传递变量，该变量的值可以给过程内部使用，过程结束后可以变量的值传递给过程外部使用。 因此，过程定义的具体形式应该为： procedure 过程名(in 参数名字 参数类型, out 参数名字 参数类型, inout 参数名字 参数类型) 下面，我们定义一个简单的过程，并调用过程。代码如下： 1234567891011delimiter $$create procedure pro2(in var1 int, out var2 int, inout var3 int)begin -- 查看该过程传入的三个变量 select var1, var2, var3;end$$delimiter ;-- 调用过程call pro2(1,2,3); 如上图所示，过程pro2创建成功。但是，在调用过程的时候出现错误，造成该错误的原因为：过程的out和inout两个参数只能接受变量，而我们传递了具体的数值，报错也就在情理之中啦！接下来，执行如下语句，进行测试： 123456789-- 设置全局变量set @var1 = 1;set @var2 = 2;set @var3 = 3;-- 调用过程call pro2(@var1, @var2, @var3);-- 查看变量select @var1, @var2, @var3; 如上图所示，在我们将变量传递给过程的时候，过程正常执行。此外，通过select语句我们可以看到传递给out类型参数的@var2的值在经过过程处理之后，被置为null值啦，这也是符合out类型参数的先清空后使用原则的。而且，由于out和inout只能接受变量作为参数，因此在过程内部对out和inout传入的变量的修改会影响到过程外部。在这里，值得我们注意是：存储过程对变量的操作是滞后的，即只有在过程结束的时候，才会将过程内部修改的值赋值给外部传入的对应的全局变量。执行如下语句，进行测试： 12345678910111213141516171819202122delimiter $$create procedure pro3(in var1 int, out var2 int, inout var3 int)begin -- 查看该过程传入的三个变量 select var1, var2, var3; -- 修改局部变量 set var1 = 10; set var2 = 20; set var3 = 30; -- 查看局部变量 select var1, var2, var3; -- 查看全局变量 select @var1, @var2, @var3; -- 修改全局变量 set @var1 = &apos;a&apos;; set @var2 = &apos;b&apos;; set @var3 = &apos;c&apos;; -- 查看全局变量 select @var1, @var2, @var3; end$$delimiter ; 1234-- 调用过程call pro3(@var1, @var2, @var3);-- 在过程结束后，查看全局变量select @var1, @var2, @var3; 如上图所示，存储过程执行成功，且验证了我们结论，即：在存储过程没有结束的时候，对传入变量的修改并不会影响到对应的全局变量；只有在存储过程结束后，才会将对应的变量值赋值给out和inout类型的变量，而in类型的变量不受影响。 温馨提示：符号[]括起来的内容，表示可选项；符号+，则表示连接的意思。 原文：guobinhit/mysql-tutorial: 🌱 This is a tutorial of MySQL. In this tutorial, you can leran how to use MySQL and optimize SQL.https://github.com/guobinhit/mysql-tutorial#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库和mysql 学习规划]]></title>
    <url>%2F2018%2F04%2F09%2F2018-04-09-2%2F</url>
    <content type="text"><![CDATA[先学习基础知识概念后再学习mysql 参考书籍：《数据库系统概念》(原书第六版）《高性能mysql》第三版 参考博客：CodingAlarm的专栏 - CSDN博客https://blog.csdn.net/codingalarm/article/category/2450007史上最简单的 MySQL 教程 - CSDN博客https://blog.csdn.net/qq_35246620/article/details/70823903专栏：MySQL进阶 - CSDN博客https://blog.csdn.net/column/details/mysqlcentury.html解释一下关系数据库的第一第二第三范式？ - 知乎https://www.zhihu.com/question/24696366]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中用到的设计模式]]></title>
    <url>%2F2018%2F04%2F09%2F2018-04-09-1%2F</url>
    <content type="text"><![CDATA[应该说设计模式是我们在写代码时候的一种被承认的较好的模式。好的设计模式就像是给代码造了一个很好的骨架，在这个骨架里，你可以知道心在哪里，肺在哪里，因为大多数人都认识这样的骨架，就有了很好的传播性。这是从易读和易传播来感知设计模式的好处。当然设计模式本身更重要的是设计原则的一种实现，比如开闭原则，依赖倒置原则，这些是在代码的修改和扩展上说事。说到底就是人类和代码发生关系的四种场合：阅读，修改，增加，删除。让每一种场合都比较舒服的话，就需要用设计模式。 下面来简单列举 Spring 中的设计模式： 1. 简单工厂又叫做静态工厂方法（StaticFactory Method）模式，但不属于 23 种 GOF 设计模式之一。 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 Spring 中的 BeanFactory 就是简单工厂模式的体现，根据传入一个唯一的标识来获得 Bean 对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。 2. 工厂方法（Factory Method）定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。 Spring 中的 FactoryBean 就是典型的工厂方法模式。如下图： 3. 单例（Singleton）保证一个类仅有一个实例，并提供一个访问它的全局访问点。 Spring 中的单例模式完成了后半句话，即提供了全局的访问点 BeanFactory。但没有从构造器级别去控制单例，这是因为 Spring 管理的是是任意的 Java 对象。 4. 适配器（Adapter）将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Spring 中在对于 AOP 的处理中有 Adapter 模式的例子，见如下图： 由于 Advisor 链需要的是 MethodInterceptor 对象，所以每一个 Advisor 中的 Advice 都要适配成对应的 MethodInterceptor 对象。 5. 包装器（Decorator）动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。 Spring 中用到的包装器模式在类名上有两种表现：一种是类名中含有 Wrapper，另一种是类名中含有 Decorator。基本上都是动态地给一个对象添加一些额外的职责。 6. 代理（Proxy）为其他对象提供一种代理以控制对这个对象的访问。 从结构上来看和 Decorator 模式类似，但 Proxy 是控制，更像是一种对功能的限制，而 Decorator 是增加职责。 Spring 的 Proxy 模式在 aop 中有体现，比如 JdkDynamicAopProxy 和 Cglib2AopProxy。 7. 观察者（Observer）定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 Spring 中 Observer 模式常用的地方是 listener 的实现。如 ApplicationListener。 8. 策略（Strategy）定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 Spring 中在实例化对象的时候用到 Strategy 模式，见如下图： 在 SimpleInstantiationStrategy 中有如下代码说明了策略模式的使用情况： 还有，第一个地方，加载资源文件的方式，使用了不同的方法，比如：ClassPathResourece，FileSystemResource，ServletContextResource，UrlResource 但他们都有共同的借口 Resource； 第二个地方就是在 Aop 的实现中，采用了两种不同的方式，JDK 动态代理和 CGLIB 代理； 第三个地方就是 Spring 的事务管理，PlatformTransactionManager 代表事务管理接口，但是它不知道底层如何管理事务，它只要求事务管理 提供开始事务 (getTransaction(),commit(),rollback() 三个方法，但是如何实现则交给具体实现类来完成 – 不同的实现类代表不同的事务管理策略。 一般来说，spring 事务管理下面主要针对 1) JDBC(org.springframework.jdbc.datasource.DataSourceTransactionManager), 2) Hibernate (org.springframework.orm.hibernate3.HibernateTransactionManager)， 3) JTA (org.springframework.transaction.jta.JtaTransactionManager) 和 4) JPA(org.springframework.orm.jpa.JpaTransactionManager) 四种具体的底层事务控制来包装的。 9. 模板方法（Template Method）定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。Template Method 模式一般是需要继承的。这里想要探讨另一种对 Template Method 的理解。Spring 中的 JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到 JdbcTemplate 已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入 JdbcTemplate 的方法中。但是变化的东西是一段代码，而且这段代码会用到 JdbcTemplate 中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵 JdbcTemplate 中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到 JdbcTemplate，从而完成了调用。这可能是 Template Method 不需要继承的另一种实现方式吧。 以下是一个具体的例子： JdbcTemplate 中的 execute 方法： JdbcTemplate 执行 execute 方法： 在各种 BeanFactory 以及 ApplicationContext 实现中也都用到了。另外还有命令模式，职责链模式，抽象工厂模式。 参考：Spring中的用到的设计模式大全 - CSDN博客https://blog.csdn.net/bigtree_3721/article/details/51037547]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Mac 终端导入 & 导出. sql 文件]]></title>
    <url>%2F2018%2F04%2F09%2F2018-04-09%2F</url>
    <content type="text"><![CDATA[导入 打开终端输入：（前提是已经配置过 MySQL 环境变量） mysql -u root -p create database name; use name; source 『将.sql文件直接拖拽至终端，自动补全其文件目录』 导出 打开『终端』输入： cd 『打开要将.sql文件生成的文件位置』 mysqldump -u root -p database_name>sql_name.sql 另外，Unix 的一些终端命令 终端登录 mysql（相对路径） 终端中输入命令： 查看路径中有没有需要的路径： 终端中输入命令：echo $PATH 没有，继续 添加需要路径：PATH=”$PATH”:/usr/local/mysql/bin 以后 终端中需输入命令：mysql -u root -p 即可 参考:【MySQL for Mac】在Mac终端导入&amp;导出.sql文件 - 郑州的文武 - 博客园http://www.cnblogs.com/zhengbin/p/4749938.html]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring技术内幕：Spring-AOP的实现:源码分析总结]]></title>
    <url>%2F2018%2F04%2F08%2F2018-04-08-1%2F</url>
    <content type="text"><![CDATA[一.建立AopProxy代理对象时序图如下： 1. ProxyFactoryBean的getObject方法作为入口获取FactoryBean中的对象getObject 方法中的initializeAdvisorChain首先对通知器链进行初始化 然后SingleTon和prototype的类型进行区分，生成对应的proxy：生成 SingleTon 代理对象在 getSingleTonInstance 方法中完成，这个方法是ProxyFactoryBean 生成 AopProxy 对象的入口。代理对象会封装对 target 目标对象的调用，也就是说针对 target 对象的方法调用行为会被这里生成的代理对象所拦截。 2.ProxyFactoryBean的createAopProxy()调用接口ProxyCreatorSupport 中createAopProxy通过AopProxyFactory取得AopProxy，这个AopProxyFactory是在初始化函数中定义的，使用的是DefaultAopProxyFactory 3.DefaultAopProxyFactory生成 AopProxy 目标代理对象AopProxy 代理对象的生成有两种方式，如果目标对象是接口类使用 JDK 来生成，否则 Spring 会使用 CGLIB 来生成目标的代理对象。 一般而言，默认方式是使用 JDK 来产生 AopProxy 代理对象，但如果配置的目标对象不是接口类的实现，会使用 CGLIB 来产生 AopProxy 代理对象；在使用 CGLIB 来产生 AopProxy 代理对象时，因为 CGLIB 是第三方类库，本身不在 JDK 基类库中，所有需要在 classPath 中正确配置，以便能够加载和利用。在 Spring 中，使用 JDK 和 CGLIB 来生成 AopProxy 代理对象的工作，是由 JdkDynamicAopProxy 和 CglibProxyFactory 来完成。下面看下类图： getProxy()拦截器的实例化：根据目标对象的不同，AopProxy 代理对象的有两种生成方式： 分别是步骤3或者步骤4 4.JDK 生成 AopProxy 对象（接口实现类）调用JDK生成Proxy 5.CGLIB 生成 AopProxy 对象（非接口实现类）CGLIB 是第三方类库，本身不在 JDK 基类库中CGLIB 生成 AopProxy 对象（非接口实现类）是通过createCglibProxy()设置DynamicAdvisedInterceptor拦截器来完成AOP功能。 二.Spring AOP 拦截器调用的实现在 Spring AOP 通过 JDK 的 Proxy 方式或 CGLIB 方式生成代理对象的时候，相关的拦截器已经配置到代理对象中去了，拦截器在代理对象中起作用是通过对这些方法的回调来完成的。如果使用 JDK 的 Proxy 来生成代理对象，那么需要 InvocationHandler 来设置拦截器回调，而如果使用 CGLIB 来生成代理对象，通过 DynamicAdvisedInterceptor 来完成回调。 1、JdkDynamicAopProxy 的 invoke 拦截 在 JDKDynamicAopProxy 生成代理对象时，他的 AopProxy 代理对象生成调用： this 指的是 InvocationHandler 对象，InvocationHandler 是 JDK 定义反射类的一个接口，这个接口定义了 invoke 方法，此方法为回调方法。通过 invoke 的具体实现，来完成对目标对象方法调用的拦截器或者功能增强工作。在这个方法中，包含一个完整的拦截器链对目标对象的拦截过程，比如获取拦截器链中的拦截器进行配置，逐个运行拦截器链里的拦截器增强，知道最后的目标对象方法的运行。 2. CglibAopProxy 的 intercept 拦截 使用 CglibAopProxy 生成 AopProxy 对象时候，对于 AOP 拦截器调用，回调的是 DynamicAdvisedInterceptor 对象生成的。回调的方法是 intercept。 三.AOP 拦截器链的调用及配置通知器 1、AOP 拦截器链的调用下面进入 AOP 的核心部分，Aop 是怎样完成对目标的增强的。这些都封装在 Aop 拦截器链中，由一个具体的拦截器完成。无论是使用 JDKDynamicAopProxy 还是使用 CglibAopProxy 创建代理对象最终对 AOP 拦截链的调用都是在 ReflectiveMethodInvocation 中通过 proceed 方法实现的。在 proceed 方法中逐个运行拦截器的拦截方法。在运行拦截器的拦截方法之前需要对代理方法完成一个匹配，通过这个匹配判断来决定拦截器是否满足切面增强的要求。 这时我们会有疑问，这些 advisor 是怎样从配置文件中获得并配置到 proxy 的拦截器链中，我们使用的 advisor 通知时怎样起作用的，让我们带着这些问题继续往下看。 2.配置通知器在整个 AopProxy 代理对象拦截回调过程中，先回到 ReflectionMethodInvocation 类的 proceed 方法，在这个方法里，可以看到得到了配置的 interceptorOrInterceptionAdvice interceptorOrInterceptionAdvice 是获得的拦截器，他通过拦截器机制对目标对象进行增强。这个拦截器来自 interceptorsAndDynamicMethodMatchers。具体来说，他是 interceptorsAndDynamicMathers 持有的 List 中的一个元素。关于如何配置拦截器的问题就转化为了 List 中的拦截器元素是从哪里来的，在哪里配置的问题。接着对 invoke 调用进行回放，回到 JDKDynamicAopProxy 中的 invoke 方法中，可以看到这个 List 中的 interceptors 是从哪个调用中获取的。对于 CglibAopProxy，也有类似过程，只不过这个过程是在 DynamicAdvisedInterceptor 的 intercept 回调中实现的，如下所示： 从上面的代码可以看出，获取 intercptors 的操作是由 advised 对象完成的，这个 advised 是一个 AdvisedSupport 对象，从 AdvisedSupport 类中可以看到 getInterceptorsAndDynamicInterceptionAdvice 的实现。在这个方法中取得了拦截器链，再取得拦截器链的时候，为了提高拦截器链的效率，还为这个拦截器链这是了缓存。 在 DefaultAdvisorChainFactory 中实现了 interceptor 链的获取过程，在这个过程中，首先设置了一个 List，其长度是配置的通知器的个数来决定的，这个配置时在 XML 中对 ProxyFactoryBean 做的 interceptNames 属性的配置，然后，DefaultAdvisorChainFactory 会通过一个 AdvisorAdapterRegistry 来实现拦截器的注册。AdvisorAdapterRegistry 对 advice 通知的织入功能起了很大作用。有了 AdvisorAdapterRegistry 注册器，利用他来对 ProxyFactoryBean 配置中得到的通知进行适配，从而得到相应的拦截器，再把他前面设置好的 List 中去，完成所谓的拦截器注册过程。在拦截器适配和注册过程完成以后，List 中的拦截器会被 JDK 生成的 AopProxy 代理对象的 invoke 方法或者 CGLIB 代理对象的 intercept 拦截方法获得，并启动拦截器的 invoke 方法调用，最终触发通知的切面增强。下面看看 DefaultAdvisorChainFactory 是怎样生成拦截器链的： 在 ProxyFactoryBean 的 getObject 方法中对 adviosr 进行初始化，从 XML 配置中获取了 advisor 通知器。下面看下在 ProxyFactoryBean 拦截器链的初始化中获取 advisor 通知器 advisor 通知器的取得时委托给 IOC 容器完成的，但是在 ProxyFactoryBean 中是如何获得 IOC 容器，然后通过回调 IOC 容器的 getBean 方法来得到需要的通知 advisor？在这里大家可以回顾下 IOC 容器的原理。 四.Advice 通知的实现 AopProxy 代理对象生成时，其拦截器也一并生成。下面我们来分析下 Aop 是如何对目标对象进行增强的。在为 AopProxy 配置拦截器的实现中，有一个取得拦截器配置过程，这个过程由 DefaultAvisorChainFactory 实现的，而这个工厂类负责生成拦截器链，在它的 getInterceptorsAndDynamicInterceptionA-dvice 方法中，有一个适配器的注册过程，通过配置 Spring 预先设计好的拦截器，Spring 加入了它对 Aop 实现的处理。为详细了解这个过程，先从 Defau-ltAdvisorChainFactory 的实现开始，通过以下代码可以看到，在 DefaultAdvisorChainFactory 实现中，首先构造了一个 GlobalAdvisorAdapterRegistry 单例，然后对配置的 Advisor 通知器进行逐个遍历，这些通知链都是配置在 interceptorNames 中的，从 getInterceptorsAndDynamicInterceptionAdvice 传递进来的 advised 参数对象中，可以方便的取得配置的通知器，有了这些通知器，接着就是一个由GlobalAdvisorAdapterRegistry 来完成的拦截器的适配和注册。 GlobalAdvisorAdapterRegistry 的 getInterceptors 方法为 AOP 的实现做出了很大的贡献，这个方法封装着 advice 织入实现的入口，我们先从 GlobalAdvisorAdapterRegistry 的实现入手，他基本起一个适配器的作用，但同时也是单例模式 到这里，我们知道在 DefaultAdvisorAdapterRegistry 中，设置了一系列的 adapter 适配器，这是这些适配器的实现，为 Spring 的 advice 提供了编织能力，下面我们看看 DefaultAdvisorAdapterRegistry 究竟发生了什么？adapter 的作用具体分为两个：1、调用 adapter 的 support 方法，通过这个方法来判断取得的 advice 属于什么类型的 advice 通知，从而根据不同的 advice 类型来注册不同的 AdviceInterceptor，也就是前面我们看到的拦截器2、这些 AdviceInterceptor 都是 Spring AOP 框架设计好的，是为实现不同的 advice 功能提供服务的。有了这些 AdviceInterceptor，可以方便的使用由 Spring 提供的各种不同的 advice 来设计 AOP 应用。也就是说，正是这些 AdviceInterceptor 最终实现了 advice 通知在 AopProxy 对象中的织入功能。 剥茧抽丝，继续看 adapter，在 DefaultAdvisorRegistry 的 getInterceptors 调用中，从 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdaper 这几个通知适配器的名字上可以看出和 Advice 一一对应，在这里，他们作为适配器被加入到 adapter 的 List 中，他们都是实现 AdvisorAdapter 接口的同一层次的类，只是各自承担着不同的适配的任务，一对一的服务于不同的 advice 实现。以 MethodBeforeAdviceAdapter 为例 到这里就非常清楚了，Spring AOP 为了实现 advice 的织入，设计了特定拦截器对这些功能进行了封装。虽然应用不会直接用到这些拦截器，但却是 advice 发挥作用不可缺少的准备。还是以 MethodBeforeAdviceInterceptor 为例，我们看看 advice 是如何封装的。在 invoke 回调方法中，看到首先触发了 advice 的 before 的回调，然后才是 MethodInvocation 的 proceed 方法的调用。看到这里，就已经和前面的在 ReflectionMethodInvocation 的 Proceed 分析中联系起来。回忆了一下，在 AopProxy 代理对象触发的 ReflectionMethodInvocation 的 proceed 方法中，在取得拦截器以后，启动了对拦截器 invoke 方法的调用。按照 AOP 的规则，ReflectiveMethodInvocation 触发的拦截器 invoke 方法，最终会根据不同的 advice 类型，触发 Spring 对不同的 advice 的拦截器封装，比如对 MethodBeforeAdvice, 最终会根据不同的 advice 类型触发 Spring 对不同的 advice 的拦截器封装。比如对 MethodBeforeAdvice，最终会触发 MethodBeforeAdviceInterceptor 的 invoke 方法。在 MethodBeforeAdviceInterceptor 方法中，会调用 advice 的 before 方法，这就是 MethodBeforeAdvice 所需要的对目标对象的增强效果：在方法调用之前通知增强。 完成 MethodBeforeAdviceInterceptor 的调用，然后启动 advice 通知的 afterReturning 回调]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring技术内幕：Spring-AOP的实现:源码分析总结]]></title>
    <url>%2F2018%2F04%2F08%2F2018-04-08%2F</url>
    <content type="text"><![CDATA[3.1、SpringAOP 的概述3.1.1、AOP 概念AOP 是 Aspect-Oriented Programming（面向切面编程）的简称。维基百科的解释如下：Aspect 是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点 (crosscutting concern)。从关注点中分离出横切关注点是面向切面的程序设计的核心。分离关注点使解决特定领域问题的代码从业务逻辑代码中独立出来，业务逻辑的代码中不再含有针对特定领用问题代码的调用，业务逻辑同特定领域问题的关系通过切面来封装、维护，这样原本分散在整个应用程序中的变动就可以很好的管理起来。 3.1.2、Advice 通知Advice 定义在连接点为切面增强提供织入接口。在 Spring AOP 中，他主要描述 Spring AOP 围绕方法调用而注入的切面行为。Advice 是定义在 org.aopalliance.aop.Advice 中的接口。在 Spring AOP 使用这个统一接口，并通过这个接口为 AOP 切面增强的织入功能做了更多的细节和扩展，比如提供了更具体的通知类型，如 BeforeAdvice,AfterAdvice,ThrowsAdvice 等。 3.1.2.1 BeforeAdvice首先我们从 BeforeAdvice 开始：在 BeforeAdvice 的继承关系中，定义了为待增强的目标方法设置的前置增强接口 MethodBeforeAdvice，使用这个前置接口需要实现一个回调函数： 1void before(Method method,Object[] args,Object target) throws Throwable; 作为回调函数，before 方法的实现在 Advice 中被配置到目标方法后，会在调用目标方法时被回调。具体的参数有：Method 对象，这个参数是目标方法的反射对象；Object[] 对象数组，这个对象数组中包含目标方法的输入参数。以 CountingBeforeAdvice 为例来说明 BeforeAdvice 的具体使用，CountBeforeAdvice 是接口 MethodBeforeAdvice 的具体实现，他只是统计被调用方法的次数，作为切面增强实现，他会根据调用方法的方法名进行统计，把统计结果根据方法名和调用次数作为键值对放入一个 map 中。代码如下： 1234567public class CountingBeforeAdvice extends MethodCounter implements MethodBeforeAdvice &#123; //实现方法前置通知MethodBeforeAdvice接口的方法 public void before(Method m, Object[] args, Object target) throws Throwable &#123; //以目标对象方法作为参数，调用父类MethodCounter的count方法统计方法调用次数 count(m); &#125;&#125; CountingBeforeAdvice的父类MethodCounter的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738public class MethodCounter implements Serializable &#123; //方法名—&gt;方法调用次数的map集合，存储方法的调用次数 private HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); //所有方法的总调用次数 private int allCount; //统计方法调用次数，CountingBeforeAdvice的调用入口 protected void count(Method m) &#123; count(m.getName()); &#125; //统计指定名称方法的调用次数 protected void count(String methodName) &#123; //从方法名—&gt;方法调用次数集合中获取指定名称方法的调用次数 Integer i = map.get(methodName);//如果调用次数不为null，则将调用次数加1，如果调用次数为null，则设置调用次数为1 i = (i != null) ? new Integer(i.intValue() + 1) : new Integer(1); //重新设置集合中保存的方法调用次数 map.put(methodName, i); //所有方法总调用次数加1 ++allCount; &#125; //获取指定名称方法的调用次数 public int getCalls(String methodName) &#123; Integer i = map.get(methodName); return (i != null ? i.intValue() : 0); &#125; //获取所有方法的总调用次数 public int getCalls() &#123; return allCount; &#125; public boolean equals(Object other) &#123; return (other != null &amp;&amp; other.getClass() == this.getClass()); &#125; public int hashCode() &#123; return getClass().hashCode(); &#125;&#125; 3.1.2.2 AfterAdvice在 Advice 的实现体系中，Spring 还提供了 AfterAdvice 这种通知类型，这里以 AfterReturningAdvice 通知的实现为例，代码如下： 123456public interface AfterReturningAdvice extends AfterAdvice &#123;//后置通知的回调方法，在目标方法对象调用结束并成功返回之后调用// returnValue参数为目标方法对象的返回值，method参数为目标方法对象，args为 //目标方法对象的输入参数 void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable;&#125; afterReturning 方法也是一个回调函数，AOP 应用需要在这个接口实现中提供切面增强的具体设计，在这个 Advice 通知被正确配置以后，在目标方法调用结束并成功返回的时候，接口会被 SpringAOP 调用。与前面分析的一样，在 Spring AOP 包中，同样可以看到 CountingAfterReturningAdvice，实现基本一致： 1234567public class CountingAfterReturningAdvice extends MethodCounter implements AfterReturningAdvice &#123; //实现后置通知AfterReturningAdvice的回调方法 public void afterReturning(Object o, Method m, Object[] args, Object target) throws Throwable &#123; //调用父类MethodCounter的count方法，统计方法的调用次数 count(m); &#125;&#125; 在实现 AfterReturningAdvice 的接口方法 afterReturning 中，可以调用 MethodCounter 的 count 方法，从而完成根据方法名对目标方法调用次数的统计。 3.1.2.3 ThrowsAdvice下面我们来看一下 Advice 通知的另一种类型 ThrowsAdvice。对于 ThrowsAdvice，并没有制定需要实现的接口方法，他在抛出异常时被回调，这个回调是 AOP 使用反射机制来完成的。可以通过 CountingThrowsAdvice 来了解 ThrowsAdvice 的使用方法： 12345678910public static class CountingThrowsAdvice extends MethodCounter implements ThrowsAdvice &#123; //当抛出IO类型的异常时的回调方法，统计异常被调用的次数 public void afterThrowing(IOException ex) throws Throwable &#123; count(IOException.class.getName()); &#125; //当抛出UncheckedException类型异常时的回调方法，统计异常被调用的次数 public void afterThrowing(UncheckedException ex) throws Throwable &#123; count(UncheckedException.class.getName()); &#125; &#125; 3.1.3、Pointcut 切点决定 Advice 通知应该作用于哪个连接点，也就是说通过 Pointcut 来定义需要增强的方法的集合，这些集合的选取可以按照一定的规则来完成。Pointcut 通常意味着标识方法，例如，这些需要增强的地方可以由某个正则表达式进行标识，或根据某个方法名进行匹配。源码如下： 12345678public interface Pointcut &#123; //获取类过滤器 ClassFilter getClassFilter(); //获取匹配切入点的方法 MethodMatcher getMethodMatcher(); //总匹配的标准切入点实例 Pointcut TRUE = TruePointcut.INSTANCE;&#125; 查看 Pointcut 切入点的继承体系，发现 Pointcut 切入点的实现类非常的多，如针对注解配置的 AnnotationMatchingPointcut、针对正则表达式的 JdkRegexpMethodPointcut 等等，我们以 JdkRegexpMethodPointcut 为例，分析切入点匹配的具体实现，源码如下： 1234567891011121314151617181920212223242526272829303132public class JdkRegexpMethodPointcut extends AbstractRegexpMethodPointcut &#123; //要编译的正则表达式模式 private Pattern[] compiledPatterns = new Pattern[0]; //编译时要排除的正则表达式模式 private Pattern[] compiledExclusionPatterns = new Pattern[0]; //将给定的模式字符串数组初始化为编译的正则表达式模式 protected void initPatternRepresentation(String[] patterns) throws PatternSyntaxException &#123; this.compiledPatterns = compilePatterns(patterns); &#125; //将给定的模式字符串数组初始化为编译时要排除的正则表达式模式 protected void initExcludedPatternRepresentation(String[] excludedPatterns) throws PatternSyntaxException &#123; this.compiledExclusionPatterns = compilePatterns(excludedPatterns); &#125; //使用正则表达式匹配给定的名称 protected boolean matches(String pattern, int patternIndex) &#123; Matcher matcher = this.compiledPatterns[patternIndex].matcher(pattern); return matcher.matches(); &#125; //使用要排除的正则表达式匹配给定的名称 protected boolean matchesExclusion(String candidate, int patternIndex) &#123; Matcher matcher = this.compiledExclusionPatterns[patternIndex].matcher(candidate); return matcher.matches(); &#125; //将给定的字符串数组编译为正则表达的模式 private Pattern[] compilePatterns(String[] source) throws PatternSyntaxException &#123; Pattern[] destination = new Pattern[source.length]; for (int i = 0; i &lt; source.length; i++) &#123; destination[i] = Pattern.compile(source[i]); &#125; return destination; &#125;&#125; 3.1.4、Advisor 通知器完成对目标方法的切面增强设计（Advice）和关注点的设计 (Pointcut) 以后，需要一个对象把他们结合起来，完成这个作用的就是 Advisor。通过他可以定义应该使用哪个通知并在哪个关注点使用它。在 DefaultPointcutAdvisor 中有两个属性，分别是 advice 和 Pointcut。通过这两个属性，可以分别配置 Advice 和 Pointcut。源码如下： 12345678910111213141516171819202122232425262728public class DefaultPointcutAdvisor extends AbstractGenericPointcutAdvisor implements Serializable &#123; //默认切入点 //Pointcut.TRUE在切入点中的定义为：Pointcut TRUE = TruePointcut.INSTANCE; private Pointcut pointcut = Pointcut.TRUE; //无参构造方法，创建一个空的通知器 public DefaultPointcutAdvisor() &#123; &#125; //创建一个匹配所有方法的通知器 public DefaultPointcutAdvisor(Advice advice) &#123; this(Pointcut.TRUE, advice); &#125; //创建一个指定切入点和通知的通知器 public DefaultPointcutAdvisor(Pointcut pointcut, Advice advice) &#123; this.pointcut = pointcut; setAdvice(advice); &#125; //为通知设置切入点 public void setPointcut(Pointcut pointcut) &#123; this.pointcut = (pointcut != null ? pointcut : Pointcut.TRUE); &#125; //获取切入点 public Pointcut getPointcut() &#123; return this.pointcut; &#125; public String toString() &#123; return getClass().getName() + ": pointcut [" + getPointcut() + "]; advice [" + getAdvice() + "]"; &#125;&#125; 上述源码中，通知器的默认切入点是 Pointcut.TRUE，Pointcut.TRUE 在切入点中的定义为：Pointcut TRUE = TruePointcut.INSTANCETruePointcut 的 INSTANCE 是一个单例，比如使用 static 类变量来持有单例实例，使用 private 私有构造函数来确保除了在当前单例实现中，单例不会被再次创建和实例化。TruePointcut 和 TrueMethodMatcher 的实现如代码如下： 1234567891011121314151617181920212223242526272829303132333435/** * Canonical Pointcut instance that always matches. * * @author Rod Johnson */@SuppressWarnings("serial")class TruePointcut implements Pointcut, Serializable &#123; public static final TruePointcut INSTANCE = new TruePointcut(); /** * Enforce Singleton pattern. * 这里是单例模式的实现特点，设置私有构造函数，使其不能直接被实例化 * 并设置一个静态类变量来保证该实例是唯一的 */ private TruePointcut() &#123; &#125; public ClassFilter getClassFilter() &#123; return ClassFilter.TRUE; &#125; public MethodMatcher getMethodMatcher() &#123; return MethodMatcher.TRUE; &#125; /** * Required to support serialization. Replaces with canonical * instance on deserialization, protecting Singleton pattern. * Alternative to overriding &#123;@code equals()&#125;. */ private Object readResolve() &#123; return INSTANCE; &#125; @Override public String toString() &#123; return "Pointcut.TRUE"; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * Canonical MethodMatcher instance that matches all methods. * * @author Rod Johnson */@SuppressWarnings("serial")class TrueMethodMatcher implements MethodMatcher, Serializable &#123; public static final TrueMethodMatcher INSTANCE = new TrueMethodMatcher(); /** * Enforce Singleton pattern. */ private TrueMethodMatcher() &#123; &#125; public boolean isRuntime() &#123; return false; &#125; public boolean matches(Method method, Class targetClass) &#123; return true; &#125; public boolean matches(Method method, Class targetClass, Object[] args) &#123; // Should never be invoked as isRuntime returns false. throw new UnsupportedOperationException(); &#125; /** * Required to support serialization. Replaces with canonical * instance on deserialization, protecting Singleton pattern. * Alternative to overriding &#123;@code equals()&#125;. */ private Object readResolve() &#123; return INSTANCE; &#125; @Override public String toString() &#123; return "MethodMatcher.TRUE"; &#125;&#125; 3.2、AOP 的设计与实现3.2.1、JVM 的动态代理特性在 Spring AOP 实现中， 使用的核心技术时动态代理，而这种动态代理实际上是 JDK 的一个特性。通过 JDK 的动态代理特性，可以为任意 Java 对象创建代理对象，对于具体使用来说，这个特性使通过 Java Reflection API 来完成的。在此之前先简要复习一下 Proxy 模式，其静态类图如下：我们可以看到有一个 RealSubject，这个对象是目标对象，而在代理模式的设计中，会设计一个接口和目标对象一致的代理对象 Proxy，它们都实现了接口 Subject 的 request 方法。在这种情况下，对目标对象的 request 调用，往往就被代理对象 “浑水摸鱼” 给拦截了。通过这种拦截，为目标对象的方法操作做了铺垫。在 Proxy 的调用过程中，如果客户调用 Proxy 的 request 方法，会在调用目标对象的 request 方法，会在调用目标对象的 request 方法的前后调用一系列的处理，而这一系列的处理相当于对目标对象来说是透明的，目标对象对这些处理可以毫不知情，这就是 proxy 模式。我们知道 JDK 中已经实现了这个 Proxy 模式，在基于 Java 虚拟机设计应用程序时，只需要直接使用这个特性就可以了。具体来说，可以再 Java 的 Reflection 包中看到 proxy 对象，这个对象生成后，所起的作用就类似于 Proxy 模式中的 Proxy 对象。在使用时，还需要为代理对象设计一个回调方法，这个回调方法起到的作用是，在其中假如了作为代理需要额外处理的动作。这个回调方法，如果在 JDK 中实现，需要实现下面所示的 InvocationHandler 接口： 123public interface InvocationHandler&#123; public Object invoke(Object proxy,Method method,Object[] args) throws Throwable;&#125; 至于 invoke 方法和 Proxy 挂上钩，熟悉 proxy 用法的读者都知道，只要在实现通过调用 Proxy.newInstance 方法生成具体的 Proxy 对象时，把 InvocationHandler 设置到参数里面就可以了，剩下的由 Java 虚拟机来完成。 3.2.2、Spring AOP 的设计分析Spring AOP 以动态代理技术为基础，设计出了一系列 AOP 的横切实现，比如前置通知、返回通知、异常通知等。同时 SpringAOP 还提供了一系列的 Pointcut 来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关的 Pointcut 方法来切入需求。在 Spring AOP 中，虽然对于 AOP 的使用者来说，只需要配置相关的 Bean 定义即可，但仔细分析 Spring AOP 内部设计可以看到，为了让 AOP 起作用，需要完成一系列过程，比如，需要为目标对象建立代理对象，这个代理对象可以通过使用 JDK 的 Proxy 来完成，也可以通过第三方的类生成器 CGLIB 来完成。然后，还需要启动代理对象的拦截器来完成各种横切面的织入，这一系列的织入设计是通过一系列 Adapter 来实现的。通过 Adapter 的设计，可以把 AOP 的横切面设计和 Proxy 模式有机结合起来，从而实现在 AOP 中定义好的各种织入方式。 3.2.3、Spring AOP 的应用场景SpringAOP 把跨越应用程序多个模块的功能抽象出俩，并通过简单的 AOP 的使用，灵活的编制到模块中，比如可以通过 AOP 实现应用程序中的日志功能。另一方面，在 Spring 内部，一些支持模块也是通过 Spring AOP 来实现的，比如后面将要介绍的事务处理。下面以 ProxyFactoryBean 的实现为例，和大家一起来了解 Spring AOP 的具体设计和实现 3.3、建立 AOPProxy 代理对象3.3.1、设计原理在 Spring 的 AOP 模块中，一个主要的部分是代理对象的生成，而对于 Spring 应用，可以看到，是通过配置和调用 Spring 的 ProxyFactoryBean 来完成这个任务的。在 ProxyFactoryBean 中，封装了主要代理对象的生成过程。在这个过程中，可以使用 JDK 的 Proxy 和 CGLIB 两种方式。以 ProxyFactoryBean 的设计为中心，可以看到相关类的继承关系： 3.3.2、配置 ProxyFactoryBean我们开始进入到 Spring AOP 的实现部分，在分析 Spring AOP 的实现原理中，主要以 ProxyFactoryBean 的实现作为例子和实现的基本线索进行分析。这是因为 ProxyFactoryBean 是在 Spring IOC 环境中创建 AOP 应用的底层方法，也是最灵活的方法，Spring 通过他完成了对 AOP 使用分封装。以 ProxyFactoryBean 的实现为入口，逐层深入，是一条帮助我们快速理解 Spring AOP 实现的学习路径。在了解 ProxyFactoryBean 的实现之前，先简要介绍下 ProxyFactoryBean 的配置和使用，在基于 XML 配置 Spring 的 Bean 时，往往需要一系列的配置补助来使用 ProxyFactoryBean 和 AOP。1）定义使用的通知器 Advisor，这个通知器应该作为一个 Bean 来定义。这个通知器的实现定义了需要对目标对象进行增强的切面行为，也就是 Advice 通知。2）定义 ProxyFactoryBean，把他作为另一个 Bean 来定义，他是封装 AOP 功能的主要类。3）定义 target 属性，作为 target 属性注入的 Bean，是需要用 AOP 通知器中的切面应用来增强的对象，也就是前面提到的 base 对象。有了这些配置，就可以使用 ProxyFactoryBean 完成 AOP 的基本功能了，例如： 1234567891011&lt;bean id="testAdvisor" class="com.jader.TestAdvisor" /&gt;&lt;bean id="testAOP" class="org.springframework.aop.ProxyFactoryBean"&gt; &lt;property &gt; &lt;value&gt;com.jader.AbcInterface&lt;/value&gt; &lt;/property&gt; &lt;property &gt; &lt;list&gt; &lt;value&gt;testAdvisor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 掌握这些配置信息后，就可以具体看一看这些 AOP 是如何实现的，也就是说，切面应用是怎样通过 ProxyFactoryBean 对 target 对象起作用的，下面详细分析。 3.3.3、ProxyFactoryBean 生成 AOPProxy 代理对象（aop核心代码）在 Spring AOP 的使用中，我们已经知道，可以通过 ProxyFactoryBean 来配置目标对象和切面行为。这个 ProxyFactoryBean 是一个 FactoryBean。在 ProxyFactoryBean 中，通过 interceptorNames 属性来配置已经定义好的通知器 Advisor。虽然名字为 interceptorNames 但实际上却是供 AOP 应用配置通知器的地方。在 ProxyFactoryBean 中，需要为 target 目标对象生成 Proxy 代理对象，从而为 AOP 横切面的编织做好准备工作。ProxyFactoryBean 的 AOP 实现需要依赖 JDK 或者 CGLIB 提供的 Proxy 特性。从 FactoryBean 中获取对象，是以 getObject 方法作为入口完成的；ProxyFactoryBean 实现中的 getObject 方法，是 FactoryBean 需要实现的接口。对 ProxyFactoryBean 来说，把需要对 target 目标对象增加的增强处理都通过 getObject 方法进行封装了。这些增强处理是为 AOP 功能的实现提供服务的。getObject 方法首先对通知器链进行初始化，通知器链封装了一系列的拦截器，这些拦截器从配置中读取，然后为代理对象的生成做好准备。在生成代理对象时，因为 Spring 中有 SingleTon 类型和 prototype 类似这两种不同的 Bean，所以要对代理对象的生成做一个区分。getObject 的代码如下： 1234567891011121314151617181920212223/** * Return a proxy. Invoked when clients obtain beans from this factory bean. * Create an instance of the AOP proxy to be returned by this factory. * The instance will be cached for a singleton, and create on each call to * &#123;@code getObject()&#125; for a proxy. * @return a fresh AOP proxy reflecting the current state of this factory */public Object getObject() throws BeansException &#123; // 这里初始化通知器链 initializeAdvisorChain(); // 这里对SingleTon和prototype的类型进行区分，生成对应的proxy if (isSingleton()) &#123; return getSingletonInstance(); &#125; else &#123; if (this.targetName == null) &#123; logger.warn("Using non-singleton proxies with singleton targets is often undesirable. " + "Enable prototype proxies by setting the 'targetName' property."); &#125; return newPrototypeInstance(); &#125;&#125; 为 Proxy 代理对象配置 Advisor 链是在 initializeAdvisorChain 方法中实现的。这个初始化过程中有一个标志位 AdvisorChainInitialized，这个标志用来表示通知器是否已经初始化。如果已经初始化，那么这里就会在初始化，而是直接返回。也就说，这个初始化的工作发生在应用第一次通过 ProxyFactoryBean 去获取代理对象的时候。在完成这个初始化之后，接着读取配置中出现的所有通知器，这个取得通知器的过程也比较简单，把通知器的名字交给容器的 getBean 方法就可以了，这是通过对 IOC 容器实现的一个回调完成的。然后把从 IOC 容器中取得的通知器加入到拦截器链中，这个动作是由 addAdvisorOnChainCreation 方法来实现的。下面看看对 Advisor 配置链的初始化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Create the advisor (interceptor) chain. Aadvisors that are sourced * from a BeanFactory will be refreshed each time a new prototype instance * is added. Interceptors added programmatically through the factory API * are unaffected by such changes. */ private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException &#123; if (this.advisorChainInitialized) &#123; return; &#125; if (!ObjectUtils.isEmpty(this.interceptorNames)) &#123; if (this.beanFactory == null) &#123; throw new IllegalStateException("No BeanFactory available anymore (probably due to serialization) " + "- cannot resolve interceptor names " + Arrays.asList(this.interceptorNames)); &#125; // Globals can't be last unless we specified a targetSource using the property... if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(GLOBAL_SUFFIX) &amp;&amp; this.targetName == null &amp;&amp; this.targetSource == EMPTY_TARGET_SOURCE) &#123; throw new AopConfigException("Target required after globals"); &#125; // Materialize interceptor chain from bean names. // 这里是添加Advisor链的调用，是通过interceptorNames属性进行配置 for (String name : this.interceptorNames) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Configuring advisor or advice '" + name + "'"); &#125; if (name.endsWith(GLOBAL_SUFFIX)) &#123; if (!(this.beanFactory instanceof ListableBeanFactory)) &#123; throw new AopConfigException( "Can only use global advisors or interceptors with a ListableBeanFactory"); &#125; addGlobalAdvisor((ListableBeanFactory) this.beanFactory, name.substring(0, name.length() - GLOBAL_SUFFIX.length())); &#125; else &#123; // If we get here, we need to add a named interceptor. // We must check if it's a singleton or prototype. // 如果程序在这里被调用，那么需要加入命名的拦截器advice，并且需要检查这个Bean是SingleTon还是prototype类型 Object advice; if (this.singleton || this.beanFactory.isSingleton(name)) &#123; // Add the real Advisor/Advice to the chain. advice = this.beanFactory.getBean(name); &#125; else &#123; // It's a prototype Advice or Advisor: replace with a prototype. // Avoid unnecessary creation of prototype bean just for advisor chain initialization. advice = new PrototypePlaceholderAdvisor(name); &#125; addAdvisorOnChainCreation(advice, name); &#125; &#125; &#125; this.advisorChainInitialized = true; &#125; 生成 SingleTon 代理对象在 getSingleTonInstance 方法中完成，这个方法时 ProxyFactoryBean 生成 AopProxy 对象的入口。代理对象会封装对 target 目标对象的调用，也就是说针对 target 对象的方法调用行为会被这里生成的代理对象所拦截。具体的生成过程是首先读取 ProxyFactoryBean 配置，为生成代理对象做好准备。Spring 通过 AopProxy 类来具体生成代理对象。对于 getSingleTonInstance 方法中生成代理对象的过程如下： 12345678910111213141516171819202122232425/** * Return the singleton instance of this class's proxy object, * lazily creating it if it hasn't been created already. * @return the shared singleton proxy */ private synchronized Object getSingletonInstance() &#123; if (this.singletonInstance == null) &#123; this.targetSource = freshTargetSource(); if (this.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == 0 &amp;&amp; !isProxyTargetClass()) &#123; // Rely on AOP infrastructure to tell us what interfaces to proxy. // 根据AOP框架来判断需要代理的接口 Class targetClass = getTargetClass(); if (targetClass == null) &#123; throw new FactoryBeanNotInitializedException("Cannot determine target class for proxy"); &#125; // 这里设置代理对象的接口 setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader)); &#125; // Initialize the shared singleton instance. super.setFrozen(this.freezeProxy); // 这里会使用ProxyFactoryBean来生成需要的proxy对象 this.singletonInstance = getProxy(createAopProxy()); &#125; return this.singletonInstance; &#125; 123456789101112/** * Return the proxy object to expose. * &lt;p&gt;The default implementation uses a &#123;@code getProxy&#125; call with * the factory's bean class loader. Can be overridden to specify a * custom class loader. * @param aopProxy the prepared AopProxy instance to get the proxy from * @return the proxy object to expose * @see AopProxy#getProxy(ClassLoader) */ protected Object getProxy(AopProxy aopProxy) &#123; return aopProxy.getProxy(this.proxyClassLoader); &#125; 这里出现了 AopProxy 对象类型，Spring 利用 AOPProxy 接口类把 AOP 代理对象的实现与框架其他部分有效隔离开来。AopProxy 接口有两个子类实现，一个 Cglib2AopProxy，另一个是 JdkDynamicProxy。具体代理对象的生成是在 ProxyFactoryBean 的基类 AdvisedSupport 中实现，借助 AopProxyFactory 完成，这个对象要么从 JDK 中生成，要么借助 CGLIB 获得。下面看看 ProxyCreatorSupport 中是如何生成代理对象的。 1234567891011/** * Subclasses should call this to get a new AOP proxy. They should &lt;b&gt;not&lt;/b&gt; * create an AOP proxy with &#123;@code this&#125; as an argument. */protected final synchronized AopProxy createAopProxy() &#123; if (!this.active) &#123; activate(); &#125; // 通过AopProxyFactory取得AopProxy，这个AopProxyFactory是在初始化函数中定义的，使用的是DefaultAopProxyFactory return getAopProxyFactory().createAopProxy(this);&#125; AopProxy 代理对象的生成有两种方式，如果目标对象是接口类使用 JDK 来生成，否则 Spring 会使用 CGLIB 来生成目标的代理对象。下面看看在 DefaultAopProxyFactory 是如何生成 AopProxy 目标代理对象的： 12345678910111213141516public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class targetClass = config.getTargetClass(); if (targetClass == null) &#123; throw new AopConfigException("TargetSource cannot determine target class: " + "Either an interface or a target is required for proxy creation."); &#125; if (targetClass.isInterface()) &#123; return new JdkDynamicAopProxy(config); &#125; return CglibProxyFactory.createCglibProxy(config); &#125; else &#123; return new JdkDynamicAopProxy(config); &#125;&#125; 在 AopProxy 代理对象的生成过程中，首先要从 AdviseSupport 对象中取得配置的目标对象，AOP 完成的是切面应用对目标应用对象的增强。如果这里没有配置目标对象会直接抛出异常。一般而言，默认方式是使用 JDK 来产生 AopProxy 代理对象，但如果配置的目标对象不是接口类的实现，会使用 CGLIB 来产生 AopProxy 代理对象；在使用 CGLIB 来产生 AopProxy 代理对象时，因为 CGLIB 是第三方类库，本身不在 JDK 基类库中，所有需要在 classPath 中正确配置，以便能够加载和利用。在 Spring 中，使用 JDK 和 CGLIB 来生成 AopProxy 代理对象的工作，是由 JdkDynamicAopProxy 和 CglibProxyFactory 来完成。 3.3.4、JDK 生成 AopProxy 对象（接口实现类）通过上面我们已经知道生成 AopProxy 对象有两种方式，下面看下类图：我们先看下 JdkDynamicAopProxy 是如何生成 AopProxy 对象的： 123456789public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Creating JDK dynamic proxy: target source is " + this.advised.getTargetSource()); &#125; Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); // 调用JDK生成Proxy return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 3.3.5、CGLIB 生成 AopProxy 对象（非接口实现类）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Creating CGLIB proxy: target source is " + this.advised.getTargetSource()); &#125; try &#123; Class&lt;?&gt; rootClass = this.advised.getTargetClass(); Assert.state(rootClass != null, "Target class must be available for creating a CGLIB proxy"); Class&lt;?&gt; proxySuperClass = rootClass; if (ClassUtils.isCglibProxyClass(rootClass)) &#123; proxySuperClass = rootClass.getSuperclass(); Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces(); for (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123; this.advised.addInterface(additionalInterface); &#125; &#125; // Validate the class, writing log messages as necessary. validateClassIfNecessary(proxySuperClass); // Configure CGLIB Enhancer... // 来自advised的IOC配置，比如使用AOP的DynamicAdvisedInterceptor Enhancer enhancer = createEnhancer(); if (classLoader != null) &#123; enhancer.setClassLoader(classLoader); if (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123; enhancer.setUseCache(false); &#125; &#125; enhancer.setSuperclass(proxySuperClass); enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised)); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new MemorySafeUndeclaredThrowableStrategy(UndeclaredThrowableException.class)); enhancer.setInterceptDuringConstruction(false); // 通过设置DynamicAdvisedInterceptor拦截器来完成AOP功能，getCallBacks方法如下： // Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised) Callback[] callbacks = getCallbacks(rootClass); Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length]; for (int x = 0; x &lt; types.length; x++) &#123; types[x] = callbacks[x].getClass(); &#125; enhancer.setCallbackFilter(new ProxyCallbackFilter( this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset)); enhancer.setCallbackTypes(types); enhancer.setCallbacks(callbacks); // Generate the proxy class and create a proxy instance. Object proxy; if (this.constructorArgs != null) &#123; proxy = enhancer.create(this.constructorArgTypes, this.constructorArgs); &#125; else &#123; proxy = enhancer.create(); &#125; return proxy; &#125; catch (CodeGenerationException ex) &#123; throw new AopConfigException("Could not generate CGLIB subclass of class [" + this.advised.getTargetClass() + "]: " + "Common causes of this problem include using a final class or a non-visible class", ex); &#125; catch (IllegalArgumentException ex) &#123; throw new AopConfigException("Could not generate CGLIB subclass of class [" + this.advised.getTargetClass() + "]: " + "Common causes of this problem include using a final class or a non-visible class", ex); &#125; catch (Exception ex) &#123; // TargetSource.getTarget() failed throw new AopConfigException("Unexpected AOP exception", ex); &#125;&#125; 3.4、Spring AOP 拦截器调用的实现3.4.1、设计原理在 Spring AOP 通过 JDK 的 Proxy 方式或 CGLIB 方式生成代理对象的时候，相关的拦截器已经配置到代理对象中去了，拦截器在代理对象中起作用是通过对这些方法的回调来完成的。如果使用 JDK 的 Proxy 来生成代理对象，那么需要 InvocationHandler 来设置拦截器回调，而如果使用 CGLIB 来生成代理对象，通过 DynamicAdvisedInterceptor 来完成回调。 3.4.2、JdkDynamicAopProxy 的 invoke 拦截在 JDKDynamicAopProxy 生成代理对象时，他的 AopProxy 代理对象生成调用： 1Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); this 指的是 InvocationHandler 对象，InvocationHandler 是 JDK 定义反射类的一个接口，这个接口定义了 invoke 方法，此方法为回调方法。通过 invoke 的具体实现，来完成对目标对象方法调用的拦截器或者功能增强工作。在这个方法中，包含一个完整的拦截器链对目标对象的拦截过程，比如获取拦截器链中的拦截器进行配置，逐个运行拦截器链里的拦截器增强，知道最后的目标对象方法的运行。下面看下 invoke 的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Implementation of &#123;@code InvocationHandler.invoke&#125;. * &lt;p&gt;Callers will see exactly the exception thrown by the target, * unless a hook method throws an exception. */public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; MethodInvocation invocation; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Class&lt;?&gt; targetClass = null; Object target = null; try &#123; if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123; // The target does not implement the equals(Object) method itself. return equals(args[0]); &#125; if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123; // The target does not implement the hashCode() method itself. return hashCode(); &#125; if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123; // Service invocations on ProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args); &#125; Object retVal; if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; // May be null. Get as late as possible to minimize the time we "own" the target, // in case it comes from a pool. target = targetSource.getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; // Get the interception chain for this method. // 获得定义好的拦截器 List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // Check whether we have any advice. If we don't, we can fallback on direct // reflective invocation of the target, and avoid creating a MethodInvocation. // 如果没有拦截器直接调用target的对应方法 if (chain.isEmpty()) &#123; // We can skip creating a MethodInvocation: just invoke the target directly // Note that the final invoker must be an InvokerInterceptor so we know it does // nothing but a reflective operation on the target, and no hot swapping or fancy proxying. // 如果有拦截器设定，那么需要调用拦截器之后才调用目标对象相应的方法 retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args); &#125; else &#123; // We need to create a method invocation... invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. retVal = invocation.proceed(); &#125; // Massage return value if necessary. Class&lt;?&gt; returnType = method.getReturnType(); if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123; // Special case: it returned "this" and the return type of the method // is type-compatible. Note that we can't help if the target sets // a reference to itself in another returned object. retVal = proxy; &#125; else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123; throw new AopInvocationException("Null return value from advice does not match primitive return type for: " + method); &#125; return retVal; &#125; finally &#123; if (target != null &amp;&amp; !targetSource.isStatic()) &#123; // Must have come from TargetSource. targetSource.releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 3.4.3、CglibAopProxy 的 intercept 拦截器使用 CglibAopProxy 生成 AopProxy 对象时候，对于 AOP 拦截器调用，回调的是 DynamicAdvisedInterceptor 对象生成的。回调的方法时 intercept，下面看看回调方法的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object oldProxy = null; boolean setProxyContext = false; Class&lt;?&gt; targetClass = null; Object target = null; try &#123; if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; // May be null. Get as late as possible to minimize the time we // "own" the target, in case it comes from a pool... target = getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); Object retVal; // Check whether we only have one InvokerInterceptor: that is, // no real advice, but just reflective invocation of the target. if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; // We can skip creating a MethodInvocation: just invoke the target directly. // Note that the final invoker must be an InvokerInterceptor, so we know // it does nothing but a reflective operation on the target, and no hot // swapping or fancy proxying. retVal = methodProxy.invoke(target, args); &#125; else &#123; // We need to create a method invocation... retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed(); &#125; retVal = processReturnType(proxy, target, method, retVal); return retVal; &#125; finally &#123; if (target != null) &#123; releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 3.4.4、目标方法的调用如果没有拦截器会对目标对象方法直接调用。对于 JDKDynamicAopProxy 代理对象是通过 AopUtils 使用反射机制实现的。在这个调用方法中首先得到调用方法的反射对象，然后使用 invoke 启动对方法反射对象的调用。源码如下： 123456789101112131415161718192021222324252627282930 /** * Invoke the given target via reflection, as part of an AOP method invocation. * @param target the target object * @param method the method to invoke * @param args the arguments for the method * @return the invocation result, if any * @throws Throwable if thrown by the target method * @throws org.springframework.aop.AopInvocationException in case of a reflection error */ public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable &#123; // Use reflection to invoke the method. try &#123; ReflectionUtils.makeAccessible(method); return method.invoke(target, args); &#125; catch (InvocationTargetException ex) &#123; // Invoked method threw a checked exception. // We must rethrow it. The client won't see the interceptor. throw ex.getTargetException(); &#125; catch (IllegalArgumentException ex) &#123; throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" + method + "] on target [" + target + "]", ex); &#125; catch (IllegalAccessException ex) &#123; throw new AopInvocationException("Could not access method [" + method + "]", ex); &#125; &#125;&#125; 3.4.5、AOP 拦截器的调用下面进入 AOP 的核心部分，Aop 是怎样完成对目标的增强的。这些都封装在 Aop 拦截器链中，由一个具体的拦截器完成。无论是使用 JDKDynamicAopProxy 还是使用 CglibAopProxy 创建代理对象最终对 AOP 拦截链的调用都是在 ReflectiveMethodInvocation 中通过 proceed 方法实现的。在 proceed 方法中逐个运行拦截器的拦截方法。在运行拦截器的拦截方法之前需要对代理方法完成一个匹配，通过这个匹配判断来决定拦截器是否满足切面增强的要求。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435public Object proceed() throws Throwable &#123; // We start with an index of -1 and increment early. // 从索引为-1的拦截器开始调用，并按序递增 // 如果拦截器链里的拦截器迭代调用完毕，这里开始调用target函数，这个函数是通过反射机制完成 // 具体在AopUtils.invokeJoinpointUsingReflection方法中完成 if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123; return invokeJoinpoint(); &#125; // 这里沿着定义好的interceptorOrInterceptionAdvice链进行处理 Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); // 这里对拦截器进行动态匹配判断 if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123; // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. // 前面分析的Pointcut，这里是触发匹配的地方，如果定义的Pointcut匹配，那么这个advice将会得到执行 InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123; return dm.interceptor.invoke(this); &#125; else &#123; // Dynamic matching failed. // Skip this interceptor and invoke the next in the chain. // 如果不匹配，proceed会递归调用，知道所有的拦截器被运行 return proceed(); &#125; &#125; else &#123; // It's an interceptor, so we just invoke it: The pointcut will have // been evaluated statically before this object was constructed. // 如果是一个拦截器，直接调用这个interceptor对应的方法 return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125; 这时我们会有疑问，这些 advisor 是怎样从配置文件中获得并配置到 proxy 的拦截器链中，我们使用的 advisor 通知时怎样起作用的，让我们带着这些问题继续往下看。 3.4.6、配置通知器在整个 AopProxy 代理对象拦截回调过程中，先回到 ReflectionMethodInvocation 类的 proceed 方法，在这个方法里，可以看到得到了配置的 interceptorOrInterceptionAdvice，如下所示： 12Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); interceptorOrInterceptionAdvice 是获得的拦截器，他通过拦截器机制对目标对象进行增强。这个拦截器来自 interceptorsAndDynamicMethodMatchers。具体来说，他是 interceptorsAndDynamicMathers 持有的 List 中的一个元素。关于如何配置拦截器的问题就转化为了 List 中的拦截器元素是从哪里来的，在哪里配置的问题。接着对 invoke 调用进行回放，回到 JDKDynamicAopProxy 中的 invoke 方法中，可以看到这个 List 中的 interceptors 是从哪个调用中获取的。对于 CglibAopProxy，也有类似过程，只不过这个过程是在 DynamicAdvisedInterceptor 的 intercept 回调中实现的，如下所示： 1List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass); 从上面的代码可以看出，获取 intercptors 的操作是由 advised 对象完成的，这个 advised 是一个 AdvisedSupport 对象，从 AdvisedSupport 类中可以看到 getInterceptorsAndDynamicInterceptionAdvice 的实现。在这个方法中取得了拦截器链，再取得拦截器链的时候，为了提高拦截器链的效率，还为这个拦截器链这是了缓存。 12345678910111213141516171819/** * Determine a list of &#123;@link org.aopalliance.intercept.MethodInterceptor&#125; objects * for the given method, based on this configuration. * @param method the proxied method * @param targetClass the target class * @return List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers) */public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123; // 这里使用cache，利用cache去获取已有的inteceptor链，但是第一次还是需要自己动手生成的。这个inteceptor链的生成 // 是由advisorChainFactory完成的，在这里使用的是DefaultAdvisorChainFactory MethodCacheKey cacheKey = new MethodCacheKey(method); List&lt;Object&gt; cached = this.methodCache.get(cacheKey); if (cached == null) &#123; cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice( this, method, targetClass); this.methodCache.put(cacheKey, cached); &#125; return cached;&#125; 在 DefaultAdvisorChainFactory 中实现了 interceptor 链的获取过程，在这个过程中，首先设置了一个 List，其长度是配置的通知器的个数来决定的，这个配置时在 XML 中对 ProxyFactoryBean 做的 interceptNames 属性的配置，然后，DefaultAdvisorChainFactory 会通过一个 AdvisorAdapterRegistry 来实现拦截器的注册。AdvisorAdapterRegistry 对 advice 通知的织入功能起了很大作用。有了 AdvisorAdapterRegistry 注册器，利用他来对 ProxyFactoryBean 配置中得到的通知进行适配，从而得到相应的拦截器，再把他前面设置好的 List 中去，完成所谓的拦截器注册过程。在拦截器适配和注册过程完成以后，List 中的拦截器会被 JDK 生成的 AopProxy 代理对象的 invoke 方法或者 CGLIB 代理对象的 intercept 拦截方法获得，并启动拦截器的 invoke 方法调用，最终触发通知的切面增强。下面看看 DefaultAdvisorChainFactory 是怎样生成拦截器链的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * A simple but definitive way of working out an advice chain for a Method, * given an &#123;@link Advised&#125; object. Always rebuilds each advice chain; * caching can be provided by subclasses. * * @author Juergen Hoeller * @author Rod Johnson * @author Adrian Colyer * @since 2.0.3 */@SuppressWarnings("serial")public class DefaultAdvisorChainFactory implements AdvisorChainFactory, Serializable &#123; public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, Class targetClass) &#123; // This is somewhat tricky... we have to process introductions first, // but we need to preserve order in the ultimate list. // advisor链已经在config中持有了，这里可以直接使用 List&lt;Object&gt; interceptorList = new ArrayList&lt;Object&gt;(config.getAdvisors().length); boolean hasIntroductions = hasMatchingIntroductions(config, targetClass); AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); for (Advisor advisor : config.getAdvisors()) &#123; if (advisor instanceof PointcutAdvisor) &#123; // Add it conditionally. PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123; // 拦截器链是通过AdvisorAdapterRegistry来加入的，这个AdvisorAdapterRegistry MethodInterceptor[] interceptors = registry.getInterceptors(advisor); MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); if (MethodMatchers.matches(mm, method, targetClass, hasIntroductions)) &#123; if (mm.isRuntime()) &#123; // Creating a new object instance in the getInterceptors() method // isn't a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) &#123; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); &#125; &#125; else &#123; interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; &#125; &#125; else if (advisor instanceof IntroductionAdvisor) &#123; IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123; Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; else &#123; Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; return interceptorList; &#125;&#125; 12345678910111213141516/** * Determine whether the Advisors contain matching introductions. */// 判断Advisors是否符合要求private static boolean hasMatchingIntroductions(Advised config, Class targetClass) &#123; for (int i = 0; i &lt; config.getAdvisors().length; i++) &#123; Advisor advisor = config.getAdvisors()[i]; if (advisor instanceof IntroductionAdvisor) &#123; IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (ia.getClassFilter().matches(targetClass)) &#123; return true; &#125; &#125; &#125; return false;&#125; 在 ProxyFactoryBean 的 getObject 方法中对 adviosr 进行初始化，从 XML 配置中获取了 advisor 通知器。下面看下在 ProxyFactoryBean 拦截器链的初始化中获取 advisor 通知器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Create the advisor (interceptor) chain. Aadvisors that are sourced * from a BeanFactory will be refreshed each time a new prototype instance * is added. Interceptors added programmatically through the factory API * are unaffected by such changes. */private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException &#123; if (this.advisorChainInitialized) &#123; return; &#125; if (!ObjectUtils.isEmpty(this.interceptorNames)) &#123; if (this.beanFactory == null) &#123; throw new IllegalStateException("No BeanFactory available anymore (probably due to serialization) " + "- cannot resolve interceptor names " + Arrays.asList(this.interceptorNames)); &#125; // Globals can't be last unless we specified a targetSource using the property... if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(GLOBAL_SUFFIX) &amp;&amp; this.targetName == null &amp;&amp; this.targetSource == EMPTY_TARGET_SOURCE) &#123; throw new AopConfigException("Target required after globals"); &#125; // Materialize interceptor chain from bean names. for (String name : this.interceptorNames) &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Configuring advisor or advice '" + name + "'"); &#125; if (name.endsWith(GLOBAL_SUFFIX)) &#123; if (!(this.beanFactory instanceof ListableBeanFactory)) &#123; throw new AopConfigException( "Can only use global advisors or interceptors with a ListableBeanFactory"); &#125; addGlobalAdvisor((ListableBeanFactory) this.beanFactory, name.substring(0, name.length() - GLOBAL_SUFFIX.length())); &#125; else &#123; // If we get here, we need to add a named interceptor. // We must check if it's a singleton or prototype. Object advice; if (this.singleton || this.beanFactory.isSingleton(name)) &#123; // Add the real Advisor/Advice to the chain. // 这里是取得advisor的地方，是通过BeanFactory取得的 // 把interceptorNames这个List中interceptor名字交给 // BeanFactory，然后通过调用BeanFactory的getBean去获取 advice = this.beanFactory.getBean(name); &#125; else &#123; // It's a prototype Advice or Advisor: replace with a prototype. // Avoid unnecessary creation of prototype bean just for advisor chain initialization. advice = new PrototypePlaceholderAdvisor(name); &#125; addAdvisorOnChainCreation(advice, name); &#125; &#125; &#125; this.advisorChainInitialized = true;&#125; advisor 通知器的取得时委托给 IOC 容器完成的，但是在 ProxyFactoryBean 中是如何获得 IOC 容器，然后通过回调 IOC 容器的 getBean 方法来得到需要的通知 advisor？在这里大家可以回顾下 IOC 容器的原理。 3.4.7、Advice 通知的实现AopProxy 代理对象生成时，其拦截器也一并生成。下面我们来分析下 Aop 是如何对目标对象进行增强的。在为 AopProxy 配置拦截器的实现中，有一个取得拦截器配置过程，这个过程由 DefaultAvisorChainFactory 实现的，而这个工厂类负责生成拦截器链，在它的 getInterceptorsAndDynamicInterceptionA-dvice 方法中，有一个适配器的注册过程，通过配置 Spring 预先设计好的拦截器，Spring 加入了它对 Aop 实现的处理。为详细了解这个过程，先从 Defau-ltAdvisorChainFactory 的实现开始，通过以下代码可以看到，在 DefaultAdvisorChainFactory 实现中，首先构造了一个 GlobalAdvisorAdapterRegistry 单例，然后对配置的 Advisor 通知器进行逐个遍历，这些通知链都是配置在 interceptorNames 中的，从 getInterceptorsAndDynamicInterceptionAdvice 传递进来的 advised 参数对象中，可以方便的取得配置的通知器，有了这些通知器，接着就是一个由GlobalAdvisorAdapterRegistry 来完成的拦截器的适配和注册。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * A simple but definitive way of working out an advice chain for a Method, * given an &#123;@link Advised&#125; object. Always rebuilds each advice chain; * caching can be provided by subclasses. * @author Juergen Hoeller * @author Rod Johnson * @author Adrian Colyer * @since 2.0.3 */@SuppressWarnings("serial")public class DefaultAdvisorChainFactory implements AdvisorChainFactory, Serializable &#123; public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, Class targetClass) &#123; // This is somewhat tricky... we have to process introductions first, // but we need to preserve order in the ultimate list. List&lt;Object&gt; interceptorList = new ArrayList&lt;Object&gt;(config.getAdvisors().length); boolean hasIntroductions = hasMatchingIntroductions(config, targetClass); // 得到注册器GlobalAdvisorAdapterRegistry，这是一个单例模式的实现 AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); for (Advisor advisor : config.getAdvisors()) &#123; if (advisor instanceof PointcutAdvisor) &#123; // Add it conditionally. PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123; MethodInterceptor[] interceptors = registry.getInterceptors(advisor); MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); if (MethodMatchers.matches(mm, method, targetClass, hasIntroductions)) &#123; if (mm.isRuntime()) &#123; // Creating a new object instance in the getInterceptors() method // isn't a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) &#123; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); &#125; &#125; else &#123; interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; &#125; &#125; else if (advisor instanceof IntroductionAdvisor) &#123; IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123; Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; else &#123; Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; return interceptorList; &#125; GlobalAdvisorAdapterRegistry 的 getInterceptors 方法为 AOP 的实现做出了很大的贡献，这个方法封装着 advice 织入实现的入口，我们先从 GlobalAdvisorAdapterRegistry 的实现入手，他基本起一个适配器的作用，但同时也是单例模式，代码如下： 1234567891011 /** * Keep track of a single instance so we can return it to classes that request it. */// 使用静态变量来保持一个唯一实例private static AdvisorAdapterRegistry instance = new DefaultAdvisorAdapterRegistry();/** * Return the singleton &#123;@link DefaultAdvisorAdapterRegistry&#125; instance. */public static AdvisorAdapterRegistry getInstance() &#123; return instance;&#125; 到这里，我们知道在 DefaultAdvisorAdapterRegistry 中，设置了一系列的 adapter 适配器，这是这些适配器的实现，为 Spring 的 advice 提供了编织能力，下面我们看看 DefaultAdvisorAdapterRegistry 究竟发生了什么？adapter 的作用具体分为两个：1、调用 adapter 的 support 方法，通过这个方法来判断取得的 advice 属于什么类型的 advice 通知，从而根据不同的 advice 类型来注册不同的 AdviceInterceptor，也就是前面我们看到的拦截器2、这些 AdviceInterceptor 都是 Spring AOP 框架设计好的，是为实现不同的 advice 功能提供服务的。有了这些 AdviceInterceptor，可以方便的使用由 Spring 提供的各种不同的 advice 来设计 AOP 应用。也就是说，正是这些 AdviceInterceptor 最终实现了 advice 通知在 AopProxy 对象中的织入功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Default implementation of the &#123;@link AdvisorAdapterRegistry&#125; interface. * Supports &#123;@link org.aopalliance.intercept.MethodInterceptor&#125;, * &#123;@link org.springframework.aop.MethodBeforeAdvice&#125;, * &#123;@link org.springframework.aop.AfterReturningAdvice&#125;, * &#123;@link org.springframework.aop.ThrowsAdvice&#125;. * * @author Rod Johnson * @author Rob Harrop * @author Juergen Hoeller */@SuppressWarnings("serial")public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable &#123; private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;AdvisorAdapter&gt;(3); /** * Create a new DefaultAdvisorAdapterRegistry, registering well-known adapters. */ public DefaultAdvisorAdapterRegistry() &#123; registerAdvisorAdapter(new MethodBeforeAdviceAdapter()); registerAdvisorAdapter(new AfterReturningAdviceAdapter()); registerAdvisorAdapter(new ThrowsAdviceAdapter()); &#125; public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException &#123; if (adviceObject instanceof Advisor) &#123; return (Advisor) adviceObject; &#125; if (!(adviceObject instanceof Advice)) &#123; throw new UnknownAdviceTypeException(adviceObject); &#125; Advice advice = (Advice) adviceObject; if (advice instanceof MethodInterceptor) &#123; // So well-known it doesn't even need an adapter. return new DefaultPointcutAdvisor(advice); &#125; for (AdvisorAdapter adapter : this.adapters) &#123; // Check that it is supported. if (adapter.supportsAdvice(advice)) &#123; return new DefaultPointcutAdvisor(advice); &#125; &#125; throw new UnknownAdviceTypeException(advice); &#125; public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123; List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3); Advice advice = advisor.getAdvice(); if (advice instanceof MethodInterceptor) &#123; interceptors.add((MethodInterceptor) advice); &#125; for (AdvisorAdapter adapter : this.adapters) &#123; if (adapter.supportsAdvice(advice)) &#123; interceptors.add(adapter.getInterceptor(advisor)); &#125; &#125; if (interceptors.isEmpty()) &#123; throw new UnknownAdviceTypeException(advisor.getAdvice()); &#125; return interceptors.toArray(new MethodInterceptor[interceptors.size()]); &#125; public void registerAdvisorAdapter(AdvisorAdapter adapter) &#123; this.adapters.add(adapter); &#125;&#125; 剥茧抽丝，继续看 adapter，在 DefaultAdvisorRegistry 的 getInterceptors 调用中，从 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdaper 这几个通知适配器的名字上可以看出和 Advice 一一对应，在这里，他们作为适配器被加入到 adapter 的 List 中，他们都是实现 AdvisorAdapter 接口的同一层次的类，只是各自承担着不同的适配的任务，一对一的服务于不同的 advice 实现。以 MethodBeforeAdviceAdapter 为例，代码如下： 1234567891011class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123; public boolean supportsAdvice(Advice advice) &#123; return (advice instanceof MethodBeforeAdvice); &#125; // 把advice从通知器中取出 public MethodInterceptor getInterceptor(Advisor advisor) &#123; MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice(); return new MethodBeforeAdviceInterceptor(advice); &#125;&#125; 到这里就非常清楚了，Spring AOP 为了实现 advice 的织入，设计了特定拦截器对这些功能进行了封装。虽然应用不会直接用到这些拦截器，但却是 advice 发挥作用不可缺少的准备。还是以 MethodBeforeAdviceInterceptor 为例，我们看看 advice 是如何封装的。在 invoke 回调方法中，看到首先触发了 advice 的 before 的回调，然后才是 MethodInvocation 的 proceed 方法的调用。看到这里，就已经和前面的在 ReflectionMethodInvocation 的 Proceed 分析中联系起来。回忆了一下，在 AopProxy 代理对象触发的 ReflectionMethodInvocation 的 proceed 方法中，在取得拦截器以后，启动了对拦截器 invoke 方法的调用。按照 AOP 的规则，ReflectiveMethodInvocation 触发的拦截器 invoke 方法，最终会根据不同的 advice 类型，触发 Spring 对不同的 advice 的拦截器封装，比如对 MethodBeforeAdvice, 最终会根据不同的 advice 类型触发 Spring 对不同的 advice 的拦截器封装。比如对 MethodBeforeAdvice，最终会触发 MethodBeforeAdviceInterceptor 的 invoke 方法。在 MethodBeforeAdviceInterceptor 方法中，会调用 advice 的 before 方法，这就是 MethodBeforeAdvice 所需要的对目标对象的增强效果：在方法调用之前通知增强。 123456789101112131415161718public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123; private MethodBeforeAdvice advice; /** * Create a new MethodBeforeAdviceInterceptor for the given advice. * @param advice the MethodBeforeAdvice to wrap */ // 为指定的Advice创建对应的MethodBeforeAdviceInterceptor对象 public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123; Assert.notNull(advice, "Advice must not be null"); this.advice = advice; &#125; // 这个invoke方法是拦截器的回调方法，会在代理对象的方法被调用时触发回调 public Object invoke(MethodInvocation mi) throws Throwable &#123; this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() ); return mi.proceed(); &#125;&#125; 完成 MethodBeforeAdviceInterceptor 的调用，然后启动 advice 通知的 afterReturning 回调，代码如下： 12345678910111213/** * Create a new AfterReturningAdviceInterceptor for the given advice. * @param advice the AfterReturningAdvice to wrap */ public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123; Assert.notNull(advice, "Advice must not be null"); this.advice = advice; &#125; public Object invoke(MethodInvocation mi) throws Throwable &#123; Object retVal = mi.proceed(); this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis()); return retVal; &#125; ThrowsAdvice 的实现和上面类似，也是封装在对应的 AdviceInterceptor 中，ThrowsAdvice 的回调方法要复杂一些，他维护了一个 exceptionHandlerMap 来对应不同的方法调用场景，这个 exceptionHandlerMap 中的 handler 的取得时与触发 ThrowsAdvice 增强的异常相关的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * Interceptor to wrap an after-throwing advice. * * &lt;p&gt;The signatures on handler methods on the &#123;@code ThrowsAdvice&#125; * implementation method argument must be of the form:&lt;br&gt; * * &#123;@code void afterThrowing([Method, args, target], ThrowableSubclass);&#125; * * &lt;p&gt;Only the last argument is required. * * &lt;p&gt;Some examples of valid methods would be: * * &lt;pre class="code"&gt;public void afterThrowing(Exception ex)&lt;/pre&gt; * &lt;pre class="code"&gt;public void afterThrowing(RemoteException)&lt;/pre&gt; * &lt;pre class="code"&gt;public void afterThrowing(Method method, Object[] args, Object target, Exception ex)&lt;/pre&gt; * &lt;pre class="code"&gt;public void afterThrowing(Method method, Object[] args, Object target, ServletException ex)&lt;/pre&gt; * * &lt;p&gt;This is a framework class that need not be used directly by Spring users. * * @author Rod Johnson * @author Juergen Hoeller */public class ThrowsAdviceInterceptor implements MethodInterceptor, AfterAdvice &#123; private static final String AFTER_THROWING = "afterThrowing"; private static final Log logger = LogFactory.getLog(ThrowsAdviceInterceptor.class); private final Object throwsAdvice; /** Methods on throws advice, keyed by exception class */ private final Map&lt;Class, Method&gt; exceptionHandlerMap = new HashMap&lt;Class, Method&gt;(); /** * Create a new ThrowsAdviceInterceptor for the given ThrowsAdvice. * @param throwsAdvice the advice object that defines the exception * handler methods (usually a &#123;@link org.springframework.aop.ThrowsAdvice&#125; * implementation) */ public ThrowsAdviceInterceptor(Object throwsAdvice) &#123; Assert.notNull(throwsAdvice, "Advice must not be null"); this.throwsAdvice = throwsAdvice; // 配置ThrowsAdvice回调方法 Method[] methods = throwsAdvice.getClass().getMethods(); for (Method method : methods) &#123; if (method.getName().equals(AFTER_THROWING) &amp;&amp; (method.getParameterTypes().length == 1 || method.getParameterTypes().length == 4) &amp;&amp; Throwable.class.isAssignableFrom(method.getParameterTypes()[method.getParameterTypes().length - 1]) ) &#123; // Have an exception handler // 配置异常处理 this.exceptionHandlerMap.put(method.getParameterTypes()[method.getParameterTypes().length - 1], method); if (logger.isDebugEnabled()) &#123; logger.debug("Found exception handler method: " + method); &#125; &#125; &#125; if (this.exceptionHandlerMap.isEmpty()) &#123; throw new IllegalArgumentException( "At least one handler method must be found in class [" + throwsAdvice.getClass() + "]"); &#125; &#125; public int getHandlerMethodCount() &#123; return this.exceptionHandlerMap.size(); &#125; /** * Determine the exception handle method. Can return null if not found. * @param exception the exception thrown * @return a handler for the given exception type */ private Method getExceptionHandler(Throwable exception) &#123; Class exceptionClass = exception.getClass(); if (logger.isTraceEnabled()) &#123; logger.trace("Trying to find handler for exception of type [" + exceptionClass.getName() + "]"); &#125; Method handler = this.exceptionHandlerMap.get(exceptionClass); while (handler == null &amp;&amp; !exceptionClass.equals(Throwable.class)) &#123; exceptionClass = exceptionClass.getSuperclass(); handler = this.exceptionHandlerMap.get(exceptionClass); &#125; if (handler != null &amp;&amp; logger.isDebugEnabled()) &#123; logger.debug("Found handler for exception of type [" + exceptionClass.getName() + "]: " + handler); &#125; return handler; &#125; public Object invoke(MethodInvocation mi) throws Throwable &#123; try &#123; // 把目标对象方法调用放在try catch中，并在catch中触发， // ThrowsAdvice的回调，把异常接着向外抛出，不做过多的处理 return mi.proceed(); &#125; catch (Throwable ex) &#123; Method handlerMethod = getExceptionHandler(ex); if (handlerMethod != null) &#123; invokeHandlerMethod(mi, ex, handlerMethod); &#125; throw ex; &#125; &#125; // 通过反射启动对ThrowsAdvice回调方法的调用 private void invokeHandlerMethod(MethodInvocation mi, Throwable ex, Method method) throws Throwable &#123; Object[] handlerArgs; if (method.getParameterTypes().length == 1) &#123; handlerArgs = new Object[] &#123; ex &#125;; &#125; else &#123; handlerArgs = new Object[] &#123;mi.getMethod(), mi.getArguments(), mi.getThis(), ex&#125;; &#125; try &#123; method.invoke(this.throwsAdvice, handlerArgs); &#125; catch (InvocationTargetException targetEx) &#123; throw targetEx.getTargetException(); &#125; &#125;&#125; 参考：《spring技术内幕》路漫漫，水迢迢 - CSDN博客https://blog.csdn.net/fuyuwei2015/article/category/2930635]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring技术内幕：Spring-AOP的实现:概要分析]]></title>
    <url>%2F2018%2F04%2F07%2F2018-04-07-2%2F</url>
    <content type="text"><![CDATA[路漫漫，水迢迢 - CSDN博客https://blog.csdn.net/fuyuwei2015/article/category/2930635 一，概述 1. 原理：面向切面编程从关注点中分离出横切关注点，通俗点讲，即将解决特定领域问题的代码从业务逻辑中脱离出来。举个栗子，简单的增删改中一般有事务管理，但事务管理与业务逻辑无关，是一个特定重复的操作，这个时候，我们就可以把事务管理从增删改的业务逻辑中脱离出来。在这里，我们的关注点就是增删改等业务逻辑，横切关注点就是事务管理。 2.1 Advice 通知 作用： 描述 Spring AOP 围绕方法调用而注入的切面行为。 类型（这里只列举三种） BeforeAdvice：在目标实例的方法 (即，JoinPoint：连接点) 执行前嵌入执行额外功能。 AfterAdvice：在目标实例的方法执行后嵌入执行额外功能。 ThrowAdvice：在目标实例的方法抛出异常时执行 Advice。 2.2 Pointcut 切点决定 Advice 通知应该作用于哪个连接点。 2.3 Advisor 通知器用来结合 Advice 和 Pointcut 二，Spring AOP 实现的核心技术 动态代理这里以 JVM 的动态代理模式举例 图解代理模式： 如图 3-9，代理对象 Proxy 与目标对象 RealSubject 实现了同一个接口 Subject。当调用目标对象的 request() 方法时，往往会被代理对象拦截。通过这种拦截， 为目标对象的方法操作做了铺垫，所以称之为代理模式。 三，建立 AopProxy 代理对象 1. 设计原理ProxyFactory 相关的类继承关系： ProxyConfig：数据基类，为子类提供配置属性 AdvisedSupport：封装了 AOP 对通知和通知器的相关操作 ProxyCreatorSupport：子类创建 AOP 代理对象的辅助类，继承以上提到的基类的功能实现 AspectJProxyFactory：具体的 AOP 代理对象的生成。集成 Spring 和 AspectJ。 ProxyFactory：具体的 AOP 代理对象的生成。为使用 Spring AOP 的应用提供 AOP 功能的封装。需要编程式使用 Spring AOP 功能。 ProxyFactoryBean：具体的 AOP 代理对象的生成。为使用 Spring AOP 的应用提供 AOP 功能的封装。可以在 IOC 容器中完成声明式配置。 2. 配置 ProxyFactoryBean12345678910111213141516&lt;!--配置ProxyFactoryBean--&gt; &lt;!--1，定义使用的通知器Advisor--&gt; &lt;bean id=&quot;testAdvisor&quot; class=&quot;com.abc.TestAdvisor&quot;/&gt; &lt;!--2，定义ProxyFactoryBean--&gt; &lt;bean id=&quot;testAOP&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;/&gt; &lt;!--3，设定与AOP实现相关的重要属性--&gt; &lt;!--3.1，proxyInterface--&gt; &lt;property &gt;&lt;value&gt;com.test.AbcInterface&lt;/value&gt;&lt;/property&gt; &lt;!--3.2，target（目标对象）--&gt; &lt;property &gt; &lt;bean class=&quot;com.abc.TestTarget&quot;/&gt; &lt;/property&gt; &lt;!--3.3，interceptorNames（需要定义的通知器）--&gt; &lt;property &gt; &lt;list&gt;&lt;value&gt;testAdvisor&lt;/value&gt;&lt;/list&gt; &lt;/property&gt; 3. ProxyFactoryBean 生成 AopProxy 代理对象AopProxy 的生成过程：两种方式，依赖 JDK 或者 CGLIB 提供的 Proxy 特性。 initializeAdvisorChain()：初始化通知器链，通知器链中封装了一系列从配置中读取的拦截器，为代理对象的生成做好准备。 getSingletonInstance()：生成 Singleton 类型的 Proxy DefaultAopProxyFactory：AopProxy 接口类，AopProxy 有两个子类实现，一个是 JdkDynamicAopProxy，一个是 CglibProxyFactory 4. JDK 生成 AopProxy 代理对象123456789101112// JdkDynamicAopProxy生成Proxy代理对象 @Override public Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource()); &#125; // 1，从advised对象中取得代理对象的代理接口配置 Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); // 2，调用JDK生成Proxy return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this); &#125; newProxyInstance 方法：需要指明 3 个参数，类装载器，代理接口，Proxy 回调方法所在的对象，这个对象要实现 InvocationHandler 接口 InvocationHandler 接口： 反射类接口，定义了 invoke 方法，提供代理对象的回调入口。 5. CGLIB 生成 AopProxy 代理对象Cglib2AopProxy 生成 AopProxy 代理对象 配置 Enhancer 对象，通过 Enhancer 对象的 callback 回调设置生成代理对象。其中通过设置 DynamicAdvisedInterceptor 拦截器来完成 AOP 功能的。 四，Spring AOP 拦截器调用的实现 1. 设计原理 在 Spring AOP 通过 JDK 的 Proxy 方式或者 CGLIB 方式生成代理对象的时候，相关的拦截器已经配置到代理对象中去了。 设置拦截器回调 通过 JDK 的 Proxy 方式生成代理对象：通过 InvocationHandler 设置拦截器回调 通过 CGLIB 方式生成代理对象：根据 CGLIB 使用要求，通过 DynamicAdvisedInterceptor 来完成回调。 2. JdkDynamicAopProxy 的 invoke 拦截 通过实现 InvocationHandler 接口中的 invoke 方法，来完成对目标对象方法调用的拦截或者说功能增强的工作。 创建 ReflectiveMethodInvocation 对象来完成对 AOP 功能实现的封装 invoke 方法中对拦截器进行配置的代码： 3. Cglib2AopProxy 的 intercept 拦截 在对于 AOP 的拦截调用，回调在 DynamicAdvisedInterceptor 对象中实现，具体实现是在 DynamicAdvisedInterceptor 中的 intercept 方法中 创建 CglibMethodInvocation 对象来完成拦截器链的调用（JdkDynamicAopProxy 通过构造 ReflectiveMethodInvocation 对象来完成这个功能） DynamicAdvisedInterceptor 的 intercept 部分代码： 4. 目标对象方法的调用 使用 JdkDynamicAopProxy 的代理对象：通过 AopUtils 使用反射机制在 AopUtils.invokejoinpointUsingReflection 的方法中实现 使用 Cglib2AopProxy 的代理对象：通过 CGLIB 的 MethodProxy 对象直接完成 5. AOP 拦截器链的调用 两种方式对拦截器的调用都是在 ReflectiveMethodInvocation 中通过 proceed 方法实现。在 proceed 方法中逐个实现拦截器的拦截方法。每个拦截器在执行之前，需要对代理方法完成一个匹配判断（即 Pointcut 切点中需要进行 matches 匹配过程）。 6. 配置通知器 proceed 方法中 interceptorOrInterceptionAdvice 链来自 interceptorsAndDynamicMethodMatchers 持有的 List 的一个元素 而 List 中的拦截器元素在 JDKDynamicAopProxy 中的 invoke 方法或 Cglib2AopProxy 中 DynamicAdvisedInterceptor 的 intercept 回调中实现，并且我们可以从中看出获取 interceptors 的操作在 advised 对象完成。 这个 advised 是一个 AdvisedSupport 对象 DefaultAdvisorChainFactory：生成通知器链的工厂，实现了 interceptor 链的获取过程 先设置一个 List，长度为配置的通知器的个数。该配置即为 XML 中对 ProxyFactory 做的 interceptNames 属性的配置 AdvisorAdapterRegistry：实现拦截器的注册，对从 ProxyFactoryBean 配置中得到的同志进行适配，从而获得相应的拦截器 拦截器适配和注册过程完成以后，List 中的拦截器会被 JDK 生成的 AopProxy 代理对象的 invoke 方法或者 CGLIB 代理对象的 intercept 拦截方法取得，并启动拦截器的 invoke 调用，最终触发通知的切面增强 在 ProxyFactoryBean 的 getObject 方法中对 advisor 进行初始化 通过对 IOC 容器的一个 getBean 回调，得到配置好的 advisor 通知器 以 DefaultListableBeanFactory 作为 IOC 容器时，基类 AbstractAutowireCapableBeanFactory 有一个对 Bean 进行初始化的 initializeBean 方法。在这个方法中，判断 Bean 类型是否实现 BeanFactoryAware 接口 实现一个接口方法 setBeanFactory，设置的 this 对象表示 Bean 所在 IOC 容器，一般指 DefaultListableBeanFactory 对象。 得到这个设置好的 BeanFactory 以后，ProxyFactoryBean 就可以通过回调容器的 getBean 去获取配置在 Bean 定义文件中的通知器，获取通知器就是向 IOC 容器回调 getBean（依赖注入）的过程。 在调用时，ProxyFactoryBean 给出通知器的名字，这些名字都是在 interceptorNames 的 List 中配置好的，在 IOC 对 FactoryBean 进行依赖注入时，会直接注入到 FactoryBean 的 interceptorNames 属性中。完成这个过程后，ProxyFactoryBean 就获得了配置的通知器，为完成切面增强做好了准备。 7. Advice 通知的实现 DefaultAdvisorChainFactory（负责生成拦截器链）使用 GlobalAdvisorAdapterRegistry 得到 AOP 拦截器 GlobalAdvisorAdapterRegistry 的实现：单件设计模式，保证所要生成对象的唯一性 配置一个静态的 final 变量 instance，使得对象在加载类的时候就生成了 抽象类，不能被实例化，保证 instance 对象的唯一性 使用 instance 对象时，通过静态方法 getInstance 方法完成，保证 instance 唯一对象的获取 DefaultAdvisorAdapterRegistry 设置了一系列 adapter 适配器，为 Spring AOP 的 advice 提供编织能力。 以 MethodBeforeAdviceAdapter 为例，把 advice 通知从通知器中取出，通过 MethodBeforeAdviceInterceptor 对象把取得的 advice 通知包装起来。在 MethodBeforeAdviceInterceptor 方法中，会先调用 advice 的 before 方法，在方法调用之前完成通知增强。 8. ProxyFactory 实现 AOP上面的分析着重讲解了以 ProxyFactoryBean 为例 Spring AOP 的实现原理，除此之外，ProxyFactory 也可以实现 Spring AOP，而且原理也差不多，只不过后者需要编程式地完成 AOP 应用的设置。 参考资料：Spring 技术内幕（第 2 版） 计文柯Spring技术内幕(二)：AOP(一) - 简书https://www.jianshu.com/p/4cb4b47ba16b]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 中查看方法之间调用关系的方法]]></title>
    <url>%2F2018%2F04%2F07%2F2018-04-07-1%2F</url>
    <content type="text"><![CDATA[Eclipse的”Call Hierarchy”可以查看一个Java方法或类成员变量的调用树（caller和callee两个方向），非常方便。 在IDEA中类似功能被划分到了三个命令。 IntelliJ IDEA中可以在主菜单中选择Navigate | Call Hierarchy命令查看一个Java方法调用树（caller和callee两个方向），但是不像Eclipse那样可以查看类成员变量的调用树。 IntelliJ IDEA中可以在主菜单中选择Analyze | Dataflow from/to Here两个命令查看表达式、变量和方法参数的传递关系树。 Analyze | Data Flow to Here Analyze | Data Flow from Here IntelliJ IDEA的” edit/Find Usage”可以查看一个Java类、方法或变量的直接使用情况。]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-IoC容器的高级特性:源码分析总结]]></title>
    <url>%2F2018%2F04%2F07%2F2018-04-07%2F</url>
    <content type="text"><![CDATA[Spring-IoC容器的高级特性:源码分析总结Spring IoC 容器还有一些高级特性，如使用 lazy-init 属性对 Bean 预初始化、FactoryBean 产生或者修饰 Bean 对象的生成、IoC 容器初始化 Bean 过程中使用 BeanPostProcessor 后置处理器对 Bean 声明周期事件管理和 IoC 容器的 autowiring 自动装配功能等。 1、容器初始化和关闭过程 介绍 2、Spring IoC 容器的 lazy-init 属性实现预实例化：当 Bean 定义资源的 &lt;Bean&gt; 元素中配置了 lazy-init 属性时，容器将会在初始化的时候对所配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化的时候就已经完成（而不像一般的依赖注入一样发生在IoC容器初始化完成以后，第一次向容器执行getBean时）。这样，当应用程序第一次向容器索取被管理的 Bean 时，就不用再初始化和对 Bean 进行依赖注入了，直接从容器中获取已经完成依赖注入的现成 Bean，可以提高应用第一次向容器获取 Bean 的性能。 (1)AbstractApplicationContext 类的 refresh() IoC 容器读入已经定位的 Bean 定义资源是从 AbstractApplicationContext 类的 refresh 在 refresh 方法中 ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory(); 启动了 Bean 定义资源的载入、注册过程。 finishBeanFactoryInitialization 方法是对注册后的Bean定义中的预实例化(lazy-init=false，Spring 默认就是预实例化，即为 true) 的 Bean 进行处理的地方。 (2)AbstractApplicationContext 类的.finishBeanFactoryInitialization 处理预实例化 Bean：当 Bean 定义资源被载入 IoC 容器之后，容器将 Bean 定义资源解析为容器内部的数据结构 BeanDefinition 注册到容器中，AbstractApplicationContext 类中的 finishBeanFactoryInitialization 方法对配置了预实例化属性的 Bean 进行预初始化过程 ConfigurableListableBeanFactory 是一个接口，其 preInstantiateSingletons 方法由其子类 DefaultListableBeanFactory 提供。 (3)、DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化：如果设置了 lazy-init 属性，则容器在完成 Bean 定义的注册之后，会通过 getBean 方法，触发对指定 Bean 的初始化和依赖注入过程 3、FactoryBean 的实现：使用了设计模式中的工厂模式 时序图如下： (1)DefaultListableBeanFactory的 getBean 方法调用 AbstractBeanFactory：getBean 方法触发容器实例化 Bean 的时候会调用 AbstractBeanFactory 的 doGetBean 方法来进行实例化的过程 (2)AbstractBeanFactory 调用getObjectForBeanInstance 方法在上面获取给定 Bean 的实例对象的 getObjectForBeanInstance 方法中，会调用 FactoryBeanRegistrySupport 类的 getObjectFromFactoryBean 方法，该方法实现了 Bean 工厂生产 Bean 实例对象。 (3)、FactoryBeanRegistrySupport 生产 Bean 实例对象：BeanFactory 接口调用其实现类FactoryBeanRegistrySupport的 getObject 方法来实现创建 Bean 实例对象的功能。 4.BeanPostProcessor 后置处理器的实现：BeanPostProcessor 后置处理器是 Spring IoC 容器经常使用到的一个特性，这个 Bean 后置处理器是一个监听器，可以监听容器触发的 Bean 声明周期事件。后置处理器向容器注册以后，容器中管理的 Bean 就具备了接收 IoC 容器事件回调的能力。 (1)AbstractAutowireCapableBeanFactory 的doCreateBean真正实现创建 Bean 对象并进行依赖注入：(2)AbstractAutowireCapableBeanFactory.initializeBean 方法为容器产生的 Bean 实例对象添加 BeanPostProcessor 后置处理器：(3)AdvisorAdapterRegistrationManager 在 Bean 对象初始化后注册通知适配器：5.Spring IoC 容器 autowiring 实现原理： (1). AbstractAutoWireCapableBeanFactory的populateBean方法 对 Bean 实例进行属性依赖注入：应用第一次通过 getBean 方法 (配置了 lazy-init 预实例化属性的除外) 向 IoC 容器索取 Bean 时，容器创建 Bean 实例对象，并且对 Bean 实例对象进行属性依赖注入，AbstractAutoWireCapableBeanFactory 的 populateBean 方法就是实现 Bean 属性依赖注入的功能。 详见之前的博客：依赖注入全过程总结 (2).AbstractAutoWireCapableBeanFactory的autowireByName方法 对 Bean 实例进行属性依赖注入根据 Bean 名称或者类型进行 autowiring 自动依赖注入： (3).DefaultSingletonBeanRegistry 的 registerDependentBean 方法真正实现属性注入：]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-IoC容器的依赖注入:源码分析总结]]></title>
    <url>%2F2018%2F04%2F06%2F2018-04-06%2F</url>
    <content type="text"><![CDATA[具体实现流程以DefaultListableBeanFactory容器为例 整个过程的图示为： 从图上看，getBean 是依赖注入的起点，之后会调用 createBean，下面从 DefaultListableBeanFactory 的基类 AbstractBeanFactory 中的 getBean 的实现来了解这个过程。 DefaultListableBeanFactory 容器的 getBean 整个过程步骤如下： 1. 从缓存获取当前 beanName，看当前类型的 bean 是否已经被创建过, 如果没有创建过，就创建一个 bean。 2. 如果创建过，就从当前 BeanFactory 中获取 bean, 如果当前工厂取不到，就从双亲 beanFactory 中取，一直进行迭代查找。 3. 如果是需要标记，并且还没有创建过，就进行标记。 4. 获取当前 bean 的所有依赖的 bean, 需要对当依赖的 bean 进行 getBean 递归调用, 知道依赖的 bean 都创建为止。 5. 根据 protype 调用 createBean 创建单例, 原型模式实例，或者根据自定义 scope 创建实例 6. 对创建的 bean 进行类型检查，如果没问题就返回． 1、依赖注入发生的时间当 Spring IoC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IoC 容器中已经管理类 Bean 定义的相关数据，但是此时 IoC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生： (1). 用户第一次通过 getBean 方法向 IoC 容索要 Bean 时，IoC 容器触发依赖注入。 (2). 当用户在 Bean 定义资源中为 &lt; Bean &gt; 元素配置了 lazy-init 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。 2、AbstractBeanFactory 通过 getBean 向 IoC 容器获取被管理的 Bean：如果 Bean 定义的单态模式 (Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。 如果 Bean 定义的是原型模式 (Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以扩展为指定其生命周期范围。 上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean 实例对象的创建过程由实现了 ObejctFactory 接口的匿名内部类的 createBean 方法完成，ObejctFactory 使用委派模式，具体的 Bean 实例创建过程交由其实现类 AbstractAutowireCapableBeanFactory 完成 3、AbstractAutowireCapableBeanFactory 创建 Bean 实例对象：AbstractAutowireCapableBeanFactory 类实现了 ObejctFactory 接口，创建容器指定的 Bean 实例对象，同时还对创建的 Bean 实例对象进行初始化处理。 通过对方法源码的分析，我们看到具体的依赖注入实现在以下两个方法中： (1).createBeanInstance：生成 Bean 所包含的 java 对象实例。 (2).populateBean ：对 Bean 属性的依赖注入进行处理。 下面继续分析这两个方法的代码实现。 4、createBeanInstance 方法创建 Bean 的 java 实例对象：在 createBeanInstance 方法中，根据指定的初始化策略，使用静态工厂、工厂方法或者容器的自动装配特性生成 java 实例对象 5、SimpleInstantiationStrategy 类使用默认的无参构造方法创建 Bean 实例化对象：在使用默认的无参构造方法创建 Bean 的实例化对象时，方法 getInstantiationStrategy().instantiate 调用了 SimpleInstantiationStrategy 类中的实例化 Bean 的方法 我们看到了如果 Bean 有方法被覆盖了，则使用 JDK 的反射机制进行实例化，否则，使用 CGLIB 进行实例化。 CGLIB 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 java 字节码的生成和转换功能。我们在学习 JDK 的动态代理时都知道，JDK 的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用 CGLIB。 6、populateBean 方法对 Bean 属性的依赖注入：对属性的注入过程分以下两种情况： (1). 属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入。 (2). 属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。 7、BeanDefinitionValueResolver 解析属性值：当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean 实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary 方法实现 依赖注入的过程就是 Bean 对象实例设置到它所依赖的 Bean 对象属性上去，在第 7 步中我们已经说过，依赖注入是通过 bw.setPropertyValues 方法实现的，该方法也使用了委托模式，在 BeanWrapper 接口中至少定义了方法声明，依赖注入的具体实现交由其实现类 BeanWrapperImpl 来完成，下面我们就分析依 BeanWrapperImpl 中赖注入相关的源码。 8、BeanWrapperImpl 对 Bean 属性的依赖注入：BeanWrapperImpl 类主要是对容器中完成初始化的 Bean 实例对象进行属性的依赖注入，即把 Bean 对象设置到它所依赖的另一个 Bean 的属性中去 (1). 对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。 (2). 对于非集合类型的属性，大量使用了 JDK 的反射和内省机制，通过属性的 getter 方法 (reader method) 获取指定属性注入以前的值，同时调用属性的 setter 方法 (writer method) 为属性设置注入后的值。看到这里相信很多人都明白了 Spring 的 setter 注入原理。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-IoC容器的初始化全过程：源码分析总结]]></title>
    <url>%2F2018%2F04%2F05%2F2018-04-05%2F</url>
    <content type="text"><![CDATA[IOC设计精髓：主要实用了设计模式中的委托模式通过某类的子类来实现该类的功能，以达到功能实现类与该类之间的解耦。 IoC 容器的初始化包括 BeanDefinition 的 Resource 定位、载入和解析和注册这三个基本的过程。 这三个过程是分开进行的，也是解耦的一个体现。 IOC容器用来管理对象依赖关系的，对IOC容器来说 BeanDefinition就是对依赖关反转模式中管理的对象依赖关系的数据抽象，也是容器实现依赖反转的核心数据结构，依赖反转功能都是围绕这个BeanDefinition的处理完成的。这些BeanDefinition就像是容器里装的水。 具体实现流程整个过程就如同一句广告词：”我们不生产水，我们只是大自然的搬运工。“ ApplicationContext （高富帅IOC）提供了供不同Resource类型的读入功能的类，如FileSystemXmlApplicationContext ，ClassPathXmlApplicationContext，XmlWebApplicationContext等等 这里以FileSystemXmlApplicationContext为例。 一.设置资源加载器和BeanDefinition 的 Resource 定位这个定位过程类似于容器寻找数据的过程，就像”拿着水桶去找水源“。 该过程中涉及的类和方法时序图调用如下： 1.设置资源加载器：FileSystemXmlApplicationContext的初始化这里要完成创建“水桶”的过程。 在FileSystemXmlApplicationContext的构造函数中通过refresh方法来启动IOC容器的初始化 调用父类容器的构造方法 (super(parent) 方法)为容器设置好 Bean 资源加载器。 2.资源定位：AbstractRefreshableConfigApplicationContext确定资源路径这里要完成“确定水源”的过程。 调用父类 AbstractRefreshableConfigApplicationContext 的 setConfigLocations(configLocations) 方法设置 Bean 定义资源文件的定位路径。 可以使用两种方式匹配资源文件路径：1).一个字符串来配置多个 Spring Bean 定义资源文件2).使用字符串数组 二.BeanDefinition 的载入接下来需要进行的就是“将水装入水桶”的过程。 该过程中涉及的类和方法调用的时序图如下： 3.AbstractApplicationContext 的 refresh 函数载入Bean定义refresh() 函数：开始 Spring IoC 容器对 Bean 定义资源的载入 refresh() 方法的作用是：在创建 IoC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在 refresh 之后使用的是新建立起来的 IoC 容器。refresh 的作用类似于对 IoC 容器的重启，在新建立好的容器中对容器进行初始化，对 Bean 定义资源进行载入 4、AbstractApplicationContext 子类的 refreshBeanFactory() 方法：使用了委派模式：在当前类中只定义了抽象的loadBeanDefinitions方法，具体是调用其子类AbstractRefreshableApplicationContext 实现的 refreshBeanFactory() 方法 子类的具体实现功能： 先判断 BeanFactory 是否存在，如果存在则先销毁 beans 并关闭 beanFactory，接着创建 DefaultListableBeanFactory，并调用 loadBeanDefinitions(beanFactory) 装载 bean定义。 5、AbstractRefreshableApplicationContext 子类的 loadBeanDefinitions 方法：使用了委派模式：当前类AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调用的是其子类 AbstractXmlApplicationContext 对该方法的实现。 子类的具体实现功能： Xml Bean 读取器 (XmlBeanDefinitionReader) 调用其父类 AbstractBeanDefinitionReader 的 reader.loadBeanDefinitions 方法读取 Bean 定义资源。 6、AbstractBeanDefinitionReader 读取 Bean 定义资源（只是一个接口类）：该方法做了以下两件事： 1.调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。 2.真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions 方法。 7、资源加载器获取要读入的资源：XmlBeanDefinitionReader 通过调用其父类 DefaultResourceLoader 的 getResource 方法获取要加载的资源 通过资源路径来获取Resource的具体实现方法分为以下三种情况： 1.如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象2.如果是URL 方式，使用UrlResource 作为bean 文件的资源对象3.如果既不是classpath标识，又不是URL标识的Resource定位，则调用容器本身的getResourceByPath方法获取Resource 8、XmlBeanDefinitionReader 加载 Bean 定义资源：（整体是加载过程，其中有一个转换过程）XmlBeanDefinitionReader加载资源的入口方法：分为以下几步： 1.将读入的XML资源进行特殊编码处理2.将资源文件转为InputStream的IO流3.从InputStream中得到XML的解析源4.将XML文件转换为DOM对象，解析过程由documentLoader实现5.关闭从Resource中得到的IO流 三.BeanDefinition 的解析接下来需要进行的就是“将水中的杂质逐一过滤掉变成饮用水”的过程。 该过程中涉及的类和方法时序图调用如下： 9、DocumentLoader 将 Bean 定义资源转换为 Document 对象：使用 JavaEE标准的JAXP将载入的Bean定义资源转换成document对象 10、XmlBeanDefinitionReader 解析载入的 Bean 定义资源文件：Bean 定义资源的载入解析分为以下两个过程： 首先，通过调用 XML 解析器将 Bean 定义资源文件转换得到 Document 对象，但是这些 Document 对象并没有按照 Spring 的 Bean 规则进行解析。这一步是载入的过程 其次，在完成通用的 XML 解析之后，按照 Spring 的 Bean 规则对 Document 对象进行解析。 11、DefaultBeanDefinitionDocumentReader 对 Bean 定义的 Document 对象解析：对 Bean 定义的 Document 对象解析不同标签来导入 IoC 容器所需要的其他资源，分为三种情况： 使用&lt;Import&gt; 元素：Spring IoC 容器在解析时会首先将指定导入的资源加载进容器中。 使用&lt; Ailas &gt;别名时：Spring IoC 容器首先将别名元素所定义的别名注册到容器中。 对于既不是 &lt;Import&gt;元素，又不是 &lt; Alias &gt;元素的元素：即 Spring 配置文件中普通的 &lt; Bean &gt; 元素的解析由 BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement 方法来实现。 12、BeanDefinitionParserDelegate 解析 Bean 定义资源文件中的 &lt;Bean&gt; 元素：注意：在解析 &lt;Bean&gt; 元素过程中没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类 BeanDefinition，将 &lt; Bean &gt; 元素中的配置信息设置到 BeanDefinition 中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的 Bean 对象。 13、BeanDefinitionParserDelegate 解析 &lt;property&gt; 元素：我们在使用 Spring 的 &lt; Bean &gt; 元素时，配置最多的是 &lt; property &gt; 属性。在 Spring 配置文件中，&lt;Bean&gt;元素中 &lt; property &gt; 元素的相关配置是按照如下处理的： ref 被封装为指向依赖对象一个引用。 value 配置都会封装成一个字符串类型的对象。 ref 和 value 都通过 “解析的数据类型属性值. setSource(extractSource(ele));” 方法将属性值 / 引用与所引用的属性关联起来。 14、解析 &lt;property&gt; 元素的子元素：在 BeanDefinitionParserDelegate 类中的 parsePropertySubElement 方法对 &lt;property&gt;中的子元素解析 在 Spring 配置文件中，对 &lt;property&gt; 元素中配置的 Array、List、Set、Map、Prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如 ManagedList、ManagedArray、ManagedSet 等，这些 Managed 类是 Spring 对象 BeanDefiniton 的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然。 15、解析 &lt;list&gt;子元素：在 BeanDefinitionParserDelegate 类中的 parseListElement 方法就是具体实现解析 &lt;property&gt;元素中的 &lt; list &gt;集合子元素 解析过程如下： 获取&lt;list&gt;元素中的value-type属性，即获取集合元素的数据类型 获取集合元素中的所有子节点 Spring中将List封装为ManagedList 设置集合目标数据类型 具体解析集合元素，、和都使用该方法解析 四.BeanDefinition 的注册接下来需要进行的就是“将水桶中的饮用水封装好”的过程。 该过程中涉及的类和方法时序图调用如下： 16、解析过后的 BeanDefinition 在 IoC 容器中的注册：通过 Spring IoC 容器对 Bean 定义资源的解析后，IoC 容器大致完成了管理 Bean 对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在 IoC 容器中 BeanDefinition 存储的只是一些静态信息，接下来需要向容器注册 Bean 定义信息才能全部完成 IoC 容器的初始化过程 具体过程如下： 获取解析的BeanDefinition的名称 向IoC容器注册BeanDefinition 如果解析的BeanDefinition有别名，向容器为其注册别名 17、DefaultListableBeanFactory 向 IoC 容器注册解析后的 BeanDefinition：当调用 BeanDefinitionReaderUtils 向 IoC 容器注册解析的 BeanDefinition 时，真正完成注册功能的是 DefaultListableBeanFactory，它使用一个 HashMap 的集合对象存放 IoC 容器中注册解析的 BeanDefinition 至此，Bean 定义资源文件中配置的 Bean 被解析过后，已经注册到 IoC 容器中，被容器管理起来，真正完成了 IoC 容器初始化所做的全部工作。现 在 IoC 容器中已经建立了整个 Bean 的配置信息，这些 BeanDefinition 信息已经可以使用，并且可以被检索，IoC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护。这些的注册的 Bean 定义信息是 IoC 容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。 总结： 现在通过上面的代码，总结一下 IOC 容器初始化的基本步骤： 初始化的入口在容器实现中的 refresh() 调用来完成 对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition, 其中的大致过程如下： 通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定位资源位置。 如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader 来完成定义信息的解析和 Bean 信息的注册, 往往使用的是 XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到 loadBeanDefinition,RegisterBeanDefinition 这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的， 容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。 注册过程就是在 IOC 容器内部维护的一个 HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个 HashMap 来实现的. 然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了。 在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。 Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文, 并将其存储在 ServletContext 中的框架实现。具体可以参见以后的文章 在使用 Spring IOC 容器的时候我们还需要区别两个概念: Beanfactory 和 Factory bean，其中 BeanFactory 指的是 IOC 容器的编程抽象，比如 ApplicationContext， XmlBeanFactory 等，这些都是 IOC 容器的具体表现，需要使用什么样的容器由客户决定, 但 Spring 为我们提供了丰富的选择。 FactoryBean 只是一个可以在 IOC 而容器中被管理的一个 bean, 是对各种处理过程和资源使用的抽象, Factory bean 在需要时产生另一个对象，而不返回 FactoryBean 本身, 我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean 都实现特殊的 org.springframework.beans.factory.FactoryBean 接口，当使用容器中 factory bean 的时候，该容器不会返回 factory bean 本身, 而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 Factory bean 的实现，其中包括: 对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等，这些我们都可以看成是具体的工厂, 看成是 SPRING 为我们建立好的工厂。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象, 免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了 参考：《spring技术内幕》]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANTLR4 学习]]></title>
    <url>%2F2018%2F04%2F04%2F2018-04-04%2F</url>
    <content type="text"><![CDATA[自述 · ANTLR 4简明教程https://dohkoos.gitbooks.io/antlr4-short-course/content/ 123vim ~/.bash_profilesource ~/.bash_profileantlr4]]></content>
      <tags>
        <tag>ANTLR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring技术内幕-IOC 笔记]]></title>
    <url>%2F2018%2F04%2F03%2F2018-04-03%2F</url>
    <content type="text"><![CDATA[一、什么是 Ioc/DI？IoC 容器：最主要是完成了完成对象的创建和依赖的管理注入等等。 先从我们自己设计这样一个视角来考虑： 所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。 对象和对象关系怎么表示？ 可以用 xml ， properties 文件等语义化配置文件表示。 描述对象关系的文件存放在哪里？ 可能是 classpath ， filesystem ，或者是 URL 网络资源， servletContext 等。 回到正题，有了配置文件，还需要对配置文件解析。 不同的配置文件对对象的描述不一样，如标准的，自定义声明式的，如何统一？ 在内部需要有一个统一的关于对象的定义，所有外部的描述都必须转化成统一的描述定义。 如何对不同的配置文件进行解析？需要对不同的配置文件语法，采用不同的解析器 二、 Spring IOC 体系结构？(1) BeanFactorySpring Bean 的创建是典型的工厂模式，这一系列的 Bean 工厂，也即 IOC 容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用，其相互关系如下： 其中 BeanFactory 作为最顶层的一个接口类，它定义了 IOC 容器的基本功能规范，BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这四个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为. 最基本的 IOC 容器接口 BeanFactory 12345678910111213141516171819202122232425public interface BeanFactory &#123; //对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象， //如果需要得到工厂本身，需要转义 String FACTORY_BEAN_PREFIX = "&amp;"; //根据bean的名字，获取在IOC容器中得到bean实例 Object getBean(String name) throws BeansException; //根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。 Object getBean(String name, Class requiredType) throws BeansException; //提供对bean的检索，看看是否在IOC容器有这个名字的bean boolean containsBean(String name); //根据bean名字得到bean实例，并同时判断这个bean是不是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; //得到bean实例的Class类型 Class getType(String name) throws NoSuchBeanDefinitionException; //得到bean的别名，如果根据别名检索，那么其原名也会被检索出来 String[] getAliases(String name); &#125; 在 BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心你的 bean 是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。 而要知道工厂是如何产生对象的，我们需要看具体的 IOC 容器实现，spring 提供了许多 IOC 容器的实现。比如 XmlBeanFactory，ClasspathXmlApplicationContext 等。其中 XmlBeanFactory 就是针对最基本的 ioc 容器的实现，这个 IOC 容器可以读取 XML 文件定义的 BeanDefinition（XML 文件中对 bean 的描述）, 如果说 XmlBeanFactory 是容器中的屌丝，ApplicationContext 应该算容器中的高帅富. ApplicationContext 是 Spring 提供的一个高级的 IoC 容器，它除了能够提供 IoC 容器的基本功能外，还为用户提供了以下的附加服务。 从 ApplicationContext 接口的实现，我们看出其特点： 支持信息源，可以实现国际化。（实现 MessageSource 接口） 访问资源。(实现 ResourcePatternResolver 接口，这个后面要讲) 支持应用事件。(实现 ApplicationEventPublisher 接口) (2) BeanDefinitionSpringIOC 容器管理了我们定义的各种 Bean 对象及其相互的关系，Bean 对象在 Spring 实现中是以 BeanDefinition 来描述的，其继承体系如下： Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下图中的类完成： 三、IoC 容器的初始化？IoC 容器的初始化包括 BeanDefinition 的 Resource 定位、载入和注册这三个基本的过程。我们以 ApplicationContext 为例讲解，ApplicationContext 系列容器也许是我们最熟悉的，因为 web 项目中使用的 XmlWebApplicationContext 就属于这个继承体系，还有 ClasspathXmlApplicationContext 等，其继承体系如下图所示： ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于 bean 的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的 Spring 应用提供了一个共享的 bean 定义环境。 下面我们分别简单地演示一下两种 ioc 容器的创建过程 1、XmlBeanFactory(屌丝 IOC) 的整个流程通过 XmlBeanFactory 的源码，我们可以发现: 123456789101112131415161718public class XmlBeanFactory extends DefaultListableBeanFactory&#123; private final XmlBeanDefinitionReader reader; public XmlBeanFactory(Resource resource)throws BeansException&#123; this(resource, null); &#125; public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException&#123; super(parentBeanFactory); this.reader = new XmlBeanDefinitionReader(this); this.reader.loadBeanDefinitions(resource); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息 ClassPathResource resource =new ClassPathResource("application-context.xml");//创建DefaultListableBeanFactory DefaultListableBeanFactory factory =new DefaultListableBeanFactory();//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(factory);//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用 reader.loadBeanDefinitions(resource);``` 通过前面的源码，this.reader = new XmlBeanDefinitionReader(this); 中其中 this 传的是 factory 对象## 2、FileSystemXmlApplicationContext （高富帅IOC）的 IOC 容器流程ApplicationContext 提供了供不同Resource类型的读入功能的类，如FileSystemXmlApplicationContext ，ClassPathXmlApplicationContext，XmlWebApplicationContext等等这里以FileSystemXmlApplicationContext为例。### 1、FileSystemXmlApplicationContext的初始化 ApplicationContext =new FileSystemXmlApplicationContext(xmlPath);先看其构造函数： 调用构造函数：```java/*** Create a new FileSystemXmlApplicationContext, loading the definitions* from the given XML files and automatically refreshing the context.* @param configLocations array of file paths* @throws BeansException if context creation failed */ public FileSystemXmlApplicationContext(String... configLocations) throws BeansException &#123; this(configLocations, true, null); &#125; 实际调用 123456789public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; //设置 Bean 资源加载器 super(parent); //设置 Bean 定义资源文件的定位路径 setConfigLocations(configLocations); if (refresh) &#123; refresh(); &#125; &#125; 2、设置资源加载器和资源定位通过分析 FileSystemXmlApplicationContext 的源代码可以知道，在创建 FileSystemXmlApplicationContext 容器时，构造方法做以下两项重要工作： 首先，调用父类容器的构造方法 (super(parent) 方法)为容器设置好 Bean 资源加载器。 然后，再调用父类 AbstractRefreshableConfigApplicationContext 的 setConfigLocations(configLocations) 方法设置 Bean 定义资源文件的定位路径。 通过追踪 FileSystemXmlApplicationContext 的继承体系，发现其父类的父类 AbstractApplicationContext 中初始化 IoC 容器所做的主要源码如下： 123456789101112131415161718192021public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext, DisposableBean &#123; //静态初始化块，在整个容器创建过程中只执行一次 static &#123; //为了避免应用程序在Weblogic8.1关闭时出现类加载异常加载问题，加载IoC容 //器关闭事件(ContextClosedEvent)类 ContextClosedEvent.class.getName(); &#125; //FileSystemXmlApplicationContext调用父类构造方法调用的就是该方法 public AbstractApplicationContext(ApplicationContext parent) &#123; this.parent = parent; this.resourcePatternResolver = getResourcePatternResolver(); &#125; //获取一个Spring Source的加载器用于读入Spring Bean定义资源文件 protected ResourcePatternResolver getResourcePatternResolver() &#123; // AbstractApplicationContext继承DefaultResourceLoader，也是一个S //Spring资源加载器，其getResource(String location)方法用于载入资源 return new PathMatchingResourcePatternResolver(this); &#125; …… &#125; AbstractApplicationContext 构造方法中调用 PathMatchingResourcePatternResolver 的构造方法创建 Spring 资源加载器： 12345public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) &#123; Assert.notNull(resourceLoader, "ResourceLoader must not be null"); //设置Spring的资源加载器 this.resourceLoader = resourceLoader; &#125; 在设置容器的资源加载器之后，接下来 FileSystemXmlApplicationContet 执行 setConfigLocations 方法通过调用其父类 AbstractRefreshableConfigApplicationContext 的方法进行对 Bean 定义资源文件的定位，该方法的源码如下： 123456789101112131415161718192021//处理单个资源文件路径为一个字符串的情况 public void setConfigLocation(String location) &#123; //String CONFIG_LOCATION_DELIMITERS = ",; /t/n"; //即多个资源文件路径之间用” ,; /t/n”分隔，解析成数组形式 setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS)); &#125; //解析Bean定义资源文件的路径，处理多个资源文件字符串数组 public void setConfigLocations(String[] locations) &#123; if (locations != null) &#123; Assert.noNullElements(locations, "Config locations must not be null"); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) &#123; // resolvePath为同一个类中将字符串解析为路径的方法 this.configLocations[i] = resolvePath(locations[i]).trim(); &#125; &#125; else &#123; this.configLocations = null; &#125; &#125; 通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个 Spring Bean 定义资源文件，也可以使用字符串数组，即下面两种方式都是可以的： a. ClasspathResource res = new ClasspathResource(“a.xml,b.xml,……”); 多个资源文件路径之间可以是用” ,; /t/n” 等分隔。 b. ClasspathResource res = new ClasspathResource(newString[]{“a.xml”,”b.xml”,……}); 至此，Spring IoC 容器在初始化时将配置的 Bean 定义资源文件定位为 Spring 封装的 Resource。 3、AbstractApplicationContext 的 refresh 函数载入 Bean 定义过程：Spring IoC 容器对 Bean 定义资源的载入是从 refresh() 函数开始的，refresh() 是一个模板方法，refresh() 方法的作用是：在创建 IoC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在 refresh 之后使用的是新建立起来的 IoC 容器。refresh 的作用类似于对 IoC 容器的重启，在新建立好的容器中对容器进行初始化，对 Bean 定义资源进行载入 FileSystemXmlApplicationContext 通过调用其父类 AbstractApplicationContext 的 refresh() 函数启动整个 IoC 容器对 Bean 定义的载入过程： 123456789101112131415161718192021222324252627282930313233343536373839public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识 prepareRefresh(); //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); //为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try &#123; //为容器的某些子类指定特殊的BeanPost事件处理器 postProcessBeanFactory(beanFactory); //调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); //为BeanFactory注册BeanPost事件处理器. //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件 registerBeanPostProcessors(beanFactory); //初始化信息源，和国际化相关. initMessageSource(); //初始化容器事件传播器. initApplicationEventMulticaster(); //调用子类的某些特殊Bean初始化方法 onRefresh(); //为事件传播器注册事件监听器. registerListeners(); //初始化所有剩余的单态Bean. finishBeanFactoryInitialization(beanFactory); //初始化容器的生命周期事件处理器，并发布容器的生命周期事件 finishRefresh(); &#125; catch (BeansException ex) &#123; //销毁以创建的单态Bean destroyBeans(); //取消refresh操作，重置容器的同步标识. cancelRefresh(ex); throw ex; &#125; &#125; &#125; refresh()方法主要为 IoC 容器 Bean 的生命周期管理提供条件，Spring IoC 容器载入 Bean 定义资源文件从其子类容器的 refreshBeanFactory()方法启动，所以整个 refresh()中 “ConfigurableListableBeanFactory beanFactory =obtainFreshBeanFactory();” 这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。 refresh() 方法的作用是：在创建 IoC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在 refresh 之后使用的是新建立起来的 IoC 容器。refresh 的作用类似于对 IoC 容器的重启，在新建立好的容器中对容器进行初始化，对 Bean 定义资源进行载入 AbstractApplicationContext 的 obtainFreshBeanFactory() 方法调用子类容器的 refreshBeanFactory() 方法，启动容器载入 Bean 定义资源文件的过程，代码如下： 123456789protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; //这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法 refreshBeanFactory(); ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) &#123; logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory); &#125; return beanFactory; &#125; 4、AbstractApplicationContext 子类的 refreshBeanFactory() 方法： AbstractApplicationContext 类中只抽象定义了 refreshBeanFactory() 方法，容器真正调用的是其子类 AbstractRefreshableApplicationContext 实现的 refreshBeanFactory() 方法，方法的源码如下： 123456789101112131415161718192021protected final void refreshBeanFactory() throws BeansException &#123; if (hasBeanFactory()) &#123;//如果已经有容器，销毁容器中的bean，关闭容器 destroyBeans(); closeBeanFactory(); &#125; try &#123; //创建IoC容器 DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); //对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等 customizeBeanFactory(beanFactory); //调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex); &#125; &#125; 在这个方法中，先判断 BeanFactory 是否存在，如果存在则先销毁 beans 并关闭 beanFactory，接着创建 DefaultListableBeanFactory，并调用 loadBeanDefinitions(beanFactory) 装载 bean定义。 5、AbstractRefreshableApplicationContext 子类的 loadBeanDefinitions 方法：AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调用的是其子类 AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext 的主要源码如下： loadBeanDefinitions 方法同样是抽象方法，是由其子类实现的，也即在 AbstractXmlApplicationContext 中。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext &#123; …… //实现父类抽象的载入Bean定义方法 @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; //创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容 器使用该读取器读取Bean定义资源 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); //为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的 //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器 beanDefinitionReader.setResourceLoader(this); //为Bean读取器设置SAX xml解析器 beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); //当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制 initBeanDefinitionReader(beanDefinitionReader); //Bean读取器真正实现加载的方法 loadBeanDefinitions(beanDefinitionReader); &#125; //Xml Bean读取器加载Bean定义资源 protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; //获取Bean定义资源的定位 Resource[] configResources = getConfigResources(); if (configResources != null) &#123; //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位 //的Bean定义资源 reader.loadBeanDefinitions(configResources); &#125; //如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源 String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; //Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位 //的Bean定义资源 reader.loadBeanDefinitions(configLocations); &#125; &#125; //这里又使用了一个委托模式，调用子类的获取Bean定义资源定位的方法 //该方法在ClassPathXmlApplicationContext中进行实现，对于我们 //举例分析源码的FileSystemXmlApplicationContext没有使用该方法 protected Resource[] getConfigResources() &#123; return null; &#125; …… 41&#125; Xml Bean 读取器 (XmlBeanDefinitionReader) 调用其父类 AbstractBeanDefinitionReader 的 reader.loadBeanDefinitions 方法读取 Bean 定义资源。 由于我们使用 FileSystemXmlApplicationContext 作为例子分析，因此 getConfigResources 的返回值为 null，因此程序执行 reader.loadBeanDefinitions(configLocations) 分支。 6、AbstractBeanDefinitionReader 读取 Bean 定义资源：AbstractBeanDefinitionReader 的 loadBeanDefinitions 方法源码如下： 可以到 org.springframework.beans.factory.support 看一下 BeanDefinitionReader 的结构 在其抽象父类 AbstractBeanDefinitionReader 中定义了载入过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//重载方法，调用下面的loadBeanDefinitions(String, Set&lt;Resource&gt;);方法 public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException &#123; return loadBeanDefinitions(location, null); &#125; public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123; //获取在IoC容器初始化过程中设置的资源加载器 ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) &#123; throw new BeanDefinitionStoreException( "Cannot import bean definitions from location [" + location + "]: no ResourceLoader available"); &#125; if (resourceLoader instanceof ResourcePatternResolver) &#123; try &#123; //将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源 //加载多个指定位置的Bean定义资源文件 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能 int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Loaded " + loadCount + " bean definitions from location pattern [" + location + "]"); &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( "Could not resolve bean definition resource pattern [" + location + "]", ex); &#125; &#125; else &#123; //将指定位置的Bean定义资源文件解析为Spring IoC容器封装的资源 //加载单个指定位置的Bean定义资源文件 Resource resource = resourceLoader.getResource(location); //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能 int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Loaded " + loadCount + " bean definitions from location [" + location + "]"); &#125; return loadCount; &#125; &#125; //重载方法，调用loadBeanDefinitions(String); public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException &#123; Assert.notNull(locations, "Location array must not be null"); int counter = 0; for (String location : locations) &#123; counter += loadBeanDefinitions(location); &#125; return counter; &#125; loadBeanDefinitions(Resource…resources) 方法和上面分析的 3 个方法类似，同样也是调用 XmlBeanDefinitionReader 的 loadBeanDefinitions 方法。 从对 AbstractBeanDefinitionReader 的 loadBeanDefinitions 方法源码分析可以看出该方法做了以下两件事： 首先，调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。 其次，真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions 方法。 看到第 8、16 行，结合上面的 ResourceLoader 与 ApplicationContext 的继承关系图，可以知道此时调用的是 DefaultResourceLoader 中的 getSource() 方法定位 Resource，因为 FileSystemXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了 FileSystemXmlApplicationContext 中来。 7、资源加载器获取要读入的资源：XmlBeanDefinitionReader 通过调用其父类 DefaultResourceLoader 的 getResource 方法获取要加载的资源，其源码如下 12345678910111213141516171819//获取Resource的具体实现方法 public Resource getResource(String location) &#123; Assert.notNull(location, "Location must not be null"); //如果是类路径的方式，那需要使用ClassPathResource 来得到bean 文件的资源对象 if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123; return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); &#125; try &#123; // 如果是URL 方式，使用UrlResource 作为bean 文件的资源对象 URL url = new URL(location); return new UrlResource(url); &#125; catch (MalformedURLException ex) &#123; &#125; //如果既不是classpath标识，又不是URL标识的Resource定位，则调用 //容器本身的getResourceByPath方法获取Resource return getResourceByPath(location); &#125; FileSystemXmlApplicationContext 容器提供了 getResourceByPath 方法的实现，就是为了处理既不是 classpath 标识，又不是 URL 标识的 Resource 定位这种情况。 1234567protected Resource getResourceByPath(String path) &#123; if (path != null &amp;&amp; path.startsWith("/")) &#123; path = path.substring(1); &#125; //这里使用文件系统资源对象来定义bean 文件 return new FileSystemResource(path); &#125; 这样代码就回到了 FileSystemXmlApplicationContext 中来，他提供了 FileSystemResource 来完成从文件系统得到配置文件的资源定义。 这样，就可以从文件系统路径上对 IOC 配置文件进行加载 - 当然我们可以按照这个逻辑从任何地方加载，在 Spring 中我们看到它提供 的各种资源抽象，比如 ClassPathResource, URLResource,FileSystemResource 等来供我们使用。上面我们看到的是定位 Resource 的一个过程，而这只是加载过程的一部分. 8、XmlBeanDefinitionReader 加载 Bean 定义资源：Bean 定义的 Resource 得到了 继续回到 XmlBeanDefinitionReader 的 loadBeanDefinitions(Resource …) 方法看到代表 bean 文件的资源定义以后的载入过程。 12345678910111213141516171819202122232425262728293031323334353637383940//XmlBeanDefinitionReader加载资源的入口方法 public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; //将读入的XML资源进行特殊编码处理 return loadBeanDefinitions(new EncodedResource(resource)); &#125; //这里是载入XML形式Bean定义资源文件方法 public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; ....... try &#123; //将资源文件转为InputStream的IO流 InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; //从InputStream中得到XML的解析源 InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; //这里是具体的读取过程 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; //关闭从Resource中得到的IO流 inputStream.close(); &#125; &#125; ......... 26&#125; //从特定XML文件中实际载入Bean定义资源的方法 protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; int validationMode = getValidationModeForResource(resource); //将XML文件转换为DOM对象，解析过程由documentLoader实现 Document doc = this.documentLoader.loadDocument( inputSource, this.entityResolver, this.errorHandler, validationMode, this.namespaceAware); //这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则 return registerBeanDefinitions(doc, resource); &#125; ....... &#125; 通过源码分析，载入 Bean 定义资源文件的最后一步是将 Bean 定义资源转换为 Document 对象，该过程由 documentLoader 实现 9、DocumentLoader 将 Bean 定义资源转换为 Document 对象：DocumentLoader 将 Bean 定义资源转换成 Document 对象的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738//使用标准的JAXP将载入的Bean定义资源转换成document对象 public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123; //创建文件解析器工厂 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isDebugEnabled()) &#123; logger.debug("Using JAXP provider [" + factory.getClass().getName() + "]"); &#125; //创建文档解析器 DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); //解析Spring的Bean定义资源 return builder.parse(inputSource); &#125; protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware) throws ParserConfigurationException &#123; //创建文档解析工厂 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(namespaceAware); //设置解析XML的校验 if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123; factory.setValidating(true); if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123; factory.setNamespaceAware(true); try &#123; factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE); &#125; catch (IllegalArgumentException ex) &#123; ParserConfigurationException pcex = new ParserConfigurationException( "Unable to validate using XSD: Your JAXP provider [" + factory + "] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? " + "Upgrade to Apache Xerces (or Java 1.5) for full XSD support."); pcex.initCause(ex); throw pcex; &#125; &#125; &#125; return factory; &#125; 该解析过程调用 JavaEE 标准的 JAXP 标准进行处理。 至此 Spring IoC 容器根据定位的 Bean 定义资源文件，将其加载读入并转换成为 Document 对象过程完成。 接下来我们要继续分析 Spring IoC 容器将载入的 Bean 定义资源文件转换为 Document 对象之后，是如何将其解析为 Spring IoC 管理的 Bean 对象并将其注册到容器中的。 10、XmlBeanDefinitionReader 解析载入的 Bean 定义资源文件： XmlBeanDefinitionReader 类中的 doLoadBeanDefinitions 方法是从特定 XML 文件中实际载入 Bean 定义资源的方法，该方法在载入 Bean 定义资源之后将其转换为 Document 对象，接下来调用 registerBeanDefinitions 启动 Spring IoC 容器对 Bean 定义的解析过程，registerBeanDefinitions 方法源码如下： 123456789101112131415//按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; //得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); //获得容器中注册的Bean数量 int countBefore = getRegistry().getBeanDefinitionCount(); //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); //统计解析的Bean数量 return getRegistry().getBeanDefinitionCount() - countBefore; &#125; //创建BeanDefinitionDocumentReader对象，解析Document对象 protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123; return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass)); &#125; Bean 定义资源的载入解析分为以下两个过程： 首先，通过调用 XML 解析器将 Bean 定义资源文件转换得到 Document 对象，但是这些 Document 对象并没有按照 Spring 的 Bean 规则进行解析。这一步是载入的过程 其次，在完成通用的 XML 解析之后，按照 Spring 的 Bean 规则对 Document 对象进行解析。 按照 Spring 的 Bean 规则对 Document 对象解析的过程是在接口 BeanDefinitionDocumentReader 的实现类 DefaultBeanDefinitionDocumentReader 中实现的。 11、DefaultBeanDefinitionDocumentReader 对 Bean 定义的 Document 对象解析：BeanDefinitionDocumentReader 接口通过 registerBeanDefinitions 方法调用其实现类 DefaultBeanDefinitionDocumentReader 对 Document 对象进行解析，解析的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188//根据Spring DTD对Bean的定义规则解析Bean定义Document对象 public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; //获得XML描述符 this.readerContext = readerContext; logger.debug("Loading bean definitions"); //获得Document的根元素 Element root = doc.getDocumentElement(); //具体的解析过程由BeanDefinitionParserDelegate实现， //BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素 BeanDefinitionParserDelegate delegate = createHelper(readerContext, root); //在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性 preProcessXml(root); //从Document的根元素开始进行Bean定义的Document对象 parseBeanDefinitions(root, delegate); //在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性 postProcessXml(root); &#125; //创建BeanDefinitionParserDelegate，用于完成真正的解析过程 protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root) &#123; BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext); //BeanDefinitionParserDelegate初始化Document根元素 delegate.initDefaults(root); return delegate; &#125; //使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象 protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; //Bean定义的Document对象使用了Spring默认的XML命名空间 if (delegate.isDefaultNamespace(root)) &#123; //获取Bean定义的Document对象根元素的所有子节点 NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); //获得Document节点是XML元素节点 if (node instanceof Element) &#123; Element ele = (Element) node; //Bean定义的Document的元素节点使用的是Spring默认的XML命名空间 if (delegate.isDefaultNamespace(ele)) &#123; //使用Spring的Bean规则解析元素节点 parseDefaultElement(ele, delegate); &#125; else &#123; //没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; //Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的 //解析规则解析Document根节点 delegate.parseCustomElement(root); &#125; &#125; //使用Spring的Bean规则解析Document元素节点 private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //如果元素节点是&lt;Import&gt;导入元素，进行导入解析 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; //如果元素节点是&lt;Alias&gt;别名元素，进行别名解析 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; //元素节点既不是导入元素，也不是别名元素，即普通的&lt;Bean&gt;元素， //按照Spring的Bean规则解析元素 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; &#125; //解析&lt;Import&gt;导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中 protected void importBeanDefinitionResource(Element ele) &#123; //获取给定的导入元素的location属性 String location = ele.getAttribute(RESOURCE_ATTRIBUTE); //如果导入元素的location属性值为空，则没有导入任何资源，直接返回 if (!StringUtils.hasText(location)) &#123; getReaderContext().error("Resource location must not be empty", ele); return; &#125; //使用系统变量值解析location属性值 location = SystemPropertyUtils.resolvePlaceholders(location); Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;Resource&gt;(4); //标识给定的导入元素的location是否是绝对路径 boolean absoluteLocation = false; try &#123; absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute(); &#125; catch (URISyntaxException ex) &#123; //给定的导入元素的location不是绝对路径 &#125; //给定的导入元素的location是绝对路径 if (absoluteLocation) &#123; try &#123; //使用资源读入器加载给定路径的Bean定义资源 int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources); if (logger.isDebugEnabled()) &#123; logger.debug("Imported " + importCount + " bean definitions from URL location [" + location + "]"); &#125; &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error( "Failed to import bean definitions from URL location [" + location + "]", ele, ex); &#125; &#125; else &#123; //给定的导入元素的location是相对路径 try &#123; int importCount; //将给定导入元素的location封装为相对路径资源 Resource relativeResource = getReaderContext().getResource().createRelative(location); //封装的相对路径资源存在 if (relativeResource.exists()) &#123; //使用资源读入器加载Bean定义资源 importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource); actualResources.add(relativeResource); &#125; //封装的相对路径资源不存在 else &#123; //获取Spring IoC容器资源读入器的基本路径 String baseLocation = getReaderContext().getResource().getURL().toString(); //根据Spring IoC容器资源读入器的基本路径加载给定导入 //路径的资源 importCount = getReaderContext().getReader().loadBeanDefinitions( StringUtils.applyRelativePath(baseLocation, location), actualResources); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Imported " + importCount + " bean definitions from relative location [" + location + "]"); &#125; &#125; catch (IOException ex) &#123; getReaderContext().error("Failed to resolve current resource location", ele, ex); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error("Failed to import bean definitions from relative location [" + location + "]", ele, ex); &#125; &#125; Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]); //在解析完&lt;Import&gt;元素之后，发送容器导入其他资源处理完成事件 getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele)); &#125; //解析&lt;Alias&gt;别名元素，为Bean向Spring IoC容器注册别名 protected void processAliasRegistration(Element ele) &#123; //获取&lt;Alias&gt;别名元素中name的属性值 String name = ele.getAttribute(NAME_ATTRIBUTE); //获取&lt;Alias&gt;别名元素中alias的属性值 String alias = ele.getAttribute(ALIAS_ATTRIBUTE); boolean valid = true; //&lt;alias&gt;别名元素的name属性值为空 if (!StringUtils.hasText(name)) &#123; getReaderContext().error("Name must not be empty", ele); valid = false; &#125; //&lt;alias&gt;别名元素的alias属性值为空 if (!StringUtils.hasText(alias)) &#123; getReaderContext().error("Alias must not be empty", ele); valid = false; &#125; if (valid) &#123; try &#123; //向容器的资源读入器注册别名 getReaderContext().getRegistry().registerAlias(name, alias); &#125; catch (Exception ex) &#123; getReaderContext().error("Failed to register alias '" + alias + "' for bean with name '" + name + "'", ele, ex); &#125; //在解析完&lt;Alias&gt;元素之后，发送容器别名处理完成事件 getReaderContext().fireAliasRegistered(name, alias, extractSource(ele)); &#125; &#125; //解析Bean定义资源Document对象的普通元素 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; // BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类 //对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; //向Spring IoC容器注册解析得到的Bean定义，这是Bean定义向IoC容器注册的入口 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error("Failed to register bean definition with name '" + bdHolder.getBeanName() + "'", ele, ex); &#125; //在完成向Spring IoC容器注册解析得到的Bean定义之后，发送注册事件 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125; &#125; 通过上述 Spring IoC 容器对载入的 Bean 定义 Document 解析可以看出，我们使用 Spring 时，在 Spring 配置文件中可以使用 &lt;Import&gt; 元素来导入 IoC 容器所需要的其他资源，Spring IoC 容器在解析时会首先将指定导入的资源加载进容器中。使用&lt; Ailas &gt;别名时，Spring IoC 容器首先将别名元素所定义的别名注册到容器中。 对于既不是 &lt;Import&gt;元素，又不是 &lt; Alias &gt;元素的元素，即 Spring 配置文件中普通的 &lt; Bean &gt; 元素的解析由 BeanDefinitionParserDelegate 类的 parseBeanDefinitionElement 方法来实现。 12、BeanDefinitionParserDelegate 解析 Bean 定义资源文件中的 &lt;Bean&gt; 元素：Bean 定义资源文件中的 &lt;Import&gt; 和&lt; Alias &gt;元素解析在 DefaultBeanDefinitionDocumentReader 中已经完成，对 Bean 定义资源文件中使用最多的&lt; Bean &gt;元素交由 BeanDefinitionParserDelegate 来解析，其解析实现的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//解析&lt;Bean&gt;元素的入口 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123; return parseBeanDefinitionElement(ele, null); &#125; //解析Bean定义资源文件中的&lt;Bean&gt;元素，这个方法中主要处理&lt;Bean&gt;元素的id，name //和别名属性 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; //获取&lt;Bean&gt;元素中的id属性值 String id = ele.getAttribute(ID_ATTRIBUTE); //获取&lt;Bean&gt;元素中的name属性值 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); ////获取&lt;Bean&gt;元素中的alias属性值 List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); //将&lt;Bean&gt;元素中的所有name属性值存放到别名中 if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; //如果&lt;Bean&gt;元素中没有配置id属性时，将别名中的第一个值赋值给beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug("No XML 'id' specified - using '" + beanName + "' as bean name and " + aliases + " as aliases"); &#125; &#125; //检查&lt;Bean&gt;元素所配置的id或者name的唯一性，containingBean标识&lt;Bean&gt; //元素中是否包含子&lt;Bean&gt;元素 if (containingBean == null) &#123; //检查&lt;Bean&gt;元素所配置的id、name或者别名是否重复 checkNameUniqueness(beanName, aliases, ele); &#125; //详细对&lt;Bean&gt;元素中配置的Bean定义进行解析的地方 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; //如果&lt;Bean&gt;元素中没有配置id、别名或者name，且没有包含子//&lt;Bean&gt;元素，为解析的Bean生成一个唯一beanName并注册 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; //如果&lt;Bean&gt;元素中没有配置id、别名或者name，且包含了子//&lt;Bean&gt;元素，为解析的Bean使用别名向IoC容器注册 beanName = this.readerContext.generateBeanName(beanDefinition); //为解析的Bean使用别名注册时，为了向后兼容 //Spring1.2/2.0，给别名添加类名后缀 String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Neither XML 'id' nor 'name' specified - " + "using generated bean name [" + beanName + "]"); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; //当解析出错时，返回null return null; &#125; //详细对&lt;Bean&gt;元素中配置的Bean定义其他属性进行解析，由于上面的方法中已经对//Bean的id、name和别名等属性进行了处理，该方法中主要处理除这三个以外的其他属性数据 public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; //记录解析的&lt;Bean&gt; this.parseState.push(new BeanEntry(beanName)); //这里只读取&lt;Bean&gt;元素中配置的class名字，然后载入到BeanDefinition中去 //只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; String parent = null; //如果&lt;Bean&gt;元素中配置了parent属性，则获取parent属性的值 if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; //根据&lt;Bean&gt;元素配置的class名称和parent属性值创建BeanDefinition //为载入Bean定义信息做准备 AbstractBeanDefinition bd = createBeanDefinition(className, parent); //对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //为&lt;Bean&gt;元素解析的Bean设置description信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //对&lt;Bean&gt;元素的meta(元信息)属性解析 parseMetaElements(ele, bd); //对&lt;Bean&gt;元素的lookup-method属性解析 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //对&lt;Bean&gt;元素的replaced-method属性解析 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //解析&lt;Bean&gt;元素的构造方法设置 parseConstructorArgElements(ele, bd); //解析&lt;Bean&gt;元素的&lt;property&gt;设置 parsePropertyElements(ele, bd); //解析&lt;Bean&gt;元素的qualifier属性 parseQualifierElements(ele, bd); //为当前解析的Bean设置所需的资源和依赖对象 bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error("Bean class [" + className + "] not found", ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error("Class that bean class [" + className + "] depends on not found", ele, err); &#125; catch (Throwable ex) &#123; error("Unexpected failure during bean definition parsing", ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; //解析&lt;Bean&gt;元素出错时，返回null return null; &#125; 只要使用过 Spring，对 Spring 配置文件比较熟悉的人，通过对上述源码的分析，就会明白我们在 Spring 配置文件中 &lt;Bean&gt; 元素的中配置的属性就是通过该方法解析和设置到 Bean 中去的。 注意：在解析 &lt;Bean&gt; 元素过程中没有创建和实例化 Bean 对象，只是创建了 Bean 对象的定义类 BeanDefinition，将 &lt; Bean &gt; 元素中的配置信息设置到 BeanDefinition 中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的 Bean 对象。 上面方法中一些对一些配置如元信息 (meta)、qualifier 等的解析，我们在 Spring 中配置时使用的也不多，我们在使用 Spring 的 &lt; Bean &gt; 元素时，配置最多的是 &lt; property &gt; 属性，因此我们下面继续分析源码，了解 Bean 的属性在解析时是如何设置的。 13、BeanDefinitionParserDelegate 解析 &lt;property&gt; 元素：BeanDefinitionParserDelegate 在解析 &lt;Bean&gt; 调用 parsePropertyElements 方法解析 &lt; Bean &gt; 元素中的&lt; property &gt;属性子元素，解析源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素 public void parsePropertyElements(Element beanEle, BeanDefinition bd) &#123; //获取&lt;Bean&gt;元素中所有的子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); //如果子元素是&lt;property&gt;子元素，则调用解析&lt;property&gt;子元素方法解析 if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123; parsePropertyElement((Element) node, bd); &#125; &#125; &#125; //解析&lt;property&gt;元素 public void parsePropertyElement(Element ele, BeanDefinition bd) &#123; //获取&lt;property&gt;元素的名字 String propertyName = ele.getAttribute(NAME_ATTRIBUTE); if (!StringUtils.hasLength(propertyName)) &#123; error("Tag 'property' must have a 'name' attribute", ele); return; &#125; this.parseState.push(new PropertyEntry(propertyName)); try &#123; //如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。 //即如果在同一个Bean中配置同名的property，则只有第一个起作用 if (bd.getPropertyValues().contains(propertyName)) &#123; error("Multiple 'property' definitions for property '" + propertyName + "'", ele); return; &#125; //解析获取property的值 Object val = parsePropertyValue(ele, bd, propertyName); //根据property的名字和值创建property实例 PropertyValue pv = new PropertyValue(propertyName, val); //解析&lt;property&gt;元素中的属性 parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); bd.getPropertyValues().addPropertyValue(pv); &#125; finally &#123; this.parseState.pop(); &#125; &#125; //解析获取property值 public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) &#123; String elementName = (propertyName != null) ? "&lt;property&gt; element for property '" + propertyName + "'" : "&lt;constructor-arg&gt; element"; //获取&lt;property&gt;的所有子元素，只能是其中一种类型:ref,value,list等 NodeList nl = ele.getChildNodes(); Element subElement = null; for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); //子元素不是description和meta属性 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp; !nodeNameEquals(node, META_ELEMENT)) &#123; if (subElement != null) &#123; error(elementName + " must not contain more than one sub-element", ele); &#125; else &#123;//当前&lt;property&gt;元素包含有子元素 subElement = (Element) node; &#125; &#125; &#125; //判断property的属性值是ref还是value，不允许既是ref又是value boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE); boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE); if ((hasRefAttribute &amp;&amp; hasValueAttribute) || ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) &#123; error(elementName + " is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element", ele); &#125; //如果属性是ref，创建一个ref的数据对象RuntimeBeanReference，这个对象 //封装了ref信息 if (hasRefAttribute) &#123; String refName = ele.getAttribute(REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) &#123; error(elementName + " contains empty 'ref' attribute", ele); &#125; //一个指向运行时所依赖对象的引用 RuntimeBeanReference ref = new RuntimeBeanReference(refName); //设置这个ref的数据对象是被当前的property对象所引用 ref.setSource(extractSource(ele)); return ref; &#125; //如果属性是value，创建一个value的数据对象TypedStringValue，这个对象 //封装了value信息 else if (hasValueAttribute) &#123; //一个持有String类型值的对象 TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE)); //设置这个value数据对象是被当前的property对象所引用 valueHolder.setSource(extractSource(ele)); return valueHolder; &#125; //如果当前&lt;property&gt;元素还有子元素 else if (subElement != null) &#123; //解析&lt;property&gt;的子元素 return parsePropertySubElement(subElement, bd); &#125; else &#123; //propery属性中既不是ref，也不是value属性，解析出错返回null error(elementName + " must specify a ref or value", ele); return null; &#125; &#125; 通过对上述源码的分析，我们可以了解在 Spring 配置文件中，&lt;Bean&gt;元素中 &lt; property &gt; 元素的相关配置是如何处理的： a. ref 被封装为指向依赖对象一个引用。 b.value 配置都会封装成一个字符串类型的对象。 c.ref 和 value 都通过 “解析的数据类型属性值. setSource(extractSource(ele));” 方法将属性值 / 引用与所引用的属性关联起来。 在方法的最后对于 &lt;property&gt;元素的子元素通过 parsePropertySubElement 方法解析，我们继续分析该方法的源码，了解其解析过程。 14、解析 &lt;property&gt; 元素的子元素：在 BeanDefinitionParserDelegate 类中的 parsePropertySubElement 方法对 &lt;property&gt;中的子元素解析，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//解析&lt;property&gt;元素中ref,value或者集合等子元素 public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) &#123; //如果&lt;property&gt;没有使用Spring默认的命名空间，则使用用户自定义的规则解析//内嵌元素 if (!isDefaultNamespace(ele)) &#123; return parseNestedCustomElement(ele, bd); &#125; //如果子元素是bean，则使用解析&lt;Bean&gt;元素的方法解析 else if (nodeNameEquals(ele, BEAN_ELEMENT)) &#123; BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) &#123; nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); &#125; return nestedBd; &#125; //如果子元素是ref，ref中只能有以下3个属性：bean、local、parent else if (nodeNameEquals(ele, REF_ELEMENT)) &#123; //获取&lt;property&gt;元素中的bean属性值，引用其他解析的Bean的名称 //可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; if (!StringUtils.hasLength(refName)) &#123; //获取&lt;property&gt;元素中的local属性值，引用同一个Xml文件中配置 //的Bean的id，local和ref不同，local只能引用同一个配置文件中的Bean refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE); if (!StringUtils.hasLength(refName)) &#123; //获取&lt;property&gt;元素中parent属性值，引用父级容器中的Bean refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; if (!StringUtils.hasLength(refName)) &#123; error("'bean', 'local' or 'parent' is required for &lt;ref&gt; element", ele); return null; &#125; &#125; &#125; //没有配置ref的目标属性值 if (!StringUtils.hasText(refName)) &#123; error("&lt;ref&gt; element contains empty target attribute", ele); return null; &#125; //创建ref类型数据，指向被引用的对象 RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); //设置引用类型值是被当前子元素所引用 ref.setSource(extractSource(ele)); return ref; &#125; //如果子元素是&lt;idref&gt;，使用解析ref元素的方法解析 else if (nodeNameEquals(ele, IDREF_ELEMENT)) &#123; return parseIdRefElement(ele); &#125; //如果子元素是&lt;value&gt;，使用解析value元素的方法解析 else if (nodeNameEquals(ele, VALUE_ELEMENT)) &#123; return parseValueElement(ele, defaultValueType); &#125; //如果子元素是null，为&lt;property&gt;设置一个封装null值的字符串数据 else if (nodeNameEquals(ele, NULL_ELEMENT)) &#123; TypedStringValue nullHolder = new TypedStringValue(null); nullHolder.setSource(extractSource(ele)); return nullHolder; &#125; //如果子元素是&lt;array&gt;，使用解析array集合子元素的方法解析 else if (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123; return parseArrayElement(ele, bd); &#125; //如果子元素是&lt;list&gt;，使用解析list集合子元素的方法解析 else if (nodeNameEquals(ele, LIST_ELEMENT)) &#123; return parseListElement(ele, bd); &#125; //如果子元素是&lt;set&gt;，使用解析set集合子元素的方法解析 else if (nodeNameEquals(ele, SET_ELEMENT)) &#123; return parseSetElement(ele, bd); &#125; //如果子元素是&lt;map&gt;，使用解析map集合子元素的方法解析 else if (nodeNameEquals(ele, MAP_ELEMENT)) &#123; return parseMapElement(ele, bd); &#125; //如果子元素是&lt;props&gt;，使用解析props集合子元素的方法解析 else if (nodeNameEquals(ele, PROPS_ELEMENT)) &#123; return parsePropsElement(ele); &#125; //既不是ref，又不是value，也不是集合，则子元素配置错误，返回null else &#123; error("Unknown property sub-element: [" + ele.getNodeName() + "]", ele); return null; &#125; &#125; 通过上述源码分析，我们明白了在 Spring 配置文件中，对 &lt;property&gt; 元素中配置的 Array、List、Set、Map、Prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如 ManagedList、ManagedArray、ManagedSet 等，这些 Managed 类是 Spring 对象 BeanDefiniton 的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对 &lt; list &gt;集合元素的解析方法进行源码分析，了解其实现过程。 15、解析 &lt;list&gt;子元素：在 BeanDefinitionParserDelegate 类中的 parseListElement 方法就是具体实现解析 &lt;property&gt;元素中的 &lt; list &gt;集合子元素，源码如下： 1234567891011121314151617181920212223242526272829//解析&lt;list&gt;集合子元素 public List parseListElement(Element collectionEle, BeanDefinition bd) &#123; //获取&lt;list&gt;元素中的value-type属性，即获取集合元素的数据类型 String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE); //获取&lt;list&gt;集合元素中的所有子节点 NodeList nl = collectionEle.getChildNodes(); //Spring中将List封装为ManagedList ManagedList&lt;Object&gt; target = new ManagedList&lt;Object&gt;(nl.getLength()); target.setSource(extractSource(collectionEle)); //设置集合目标数据类型 target.setElementTypeName(defaultElementType); target.setMergeEnabled(parseMergeAttribute(collectionEle)); //具体的&lt;list&gt;元素解析 parseCollectionElements(nl, target, bd, defaultElementType); return target; &#125; //具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析 protected void parseCollectionElements( NodeList elementNodes, Collection&lt;Object&gt; target, BeanDefinition bd, String defaultElementType) &#123; //遍历集合所有节点 for (int i = 0; i &lt; elementNodes.getLength(); i++) &#123; Node node = elementNodes.item(i); //节点不是description节点 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) &#123; //将解析的元素加入集合中，递归调用下一个子元素 target.add(parsePropertySubElement((Element) node, bd, defaultElementType)); &#125; &#125; &#125; 经过对 Spring Bean 定义资源文件转换的 Document 对象中的元素层层解析，Spring IoC 现在已经将 XML 形式定义的 Bean 定义资源文件转换为 Spring IoC 所识别的数据结构——BeanDefinition，它是 Bean 定义资源文件中配置的 POJO 对象在 Spring IoC 容器中的映射，我们可以通过 AbstractBeanDefinition 为入口，荣 IoC 容器进行索引、查询和操作。 通过 Spring IoC 容器对 Bean 定义资源的解析后，IoC 容器大致完成了管理 Bean 对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在 IoC 容器中 BeanDefinition 存储的只是一些静态信息，接下来需要向容器注册 Bean 定义信息才能全部完成 IoC 容器的初始化过程 16、解析过后的 BeanDefinition 在 IoC 容器中的注册：让我们继续跟踪程序的执行顺序，接下来会到我们第 3 步中分析 DefaultBeanDefinitionDocumentReader 对 Bean 定义转换的 Document 对象解析的流程中，在其 parseDefaultElement 方法中完成对 Document 对象的解析后得到封装 BeanDefinition 的 BeanDefinitionHold 对象，然后调用 BeanDefinitionReaderUtils 的 registerBeanDefinition 方法向 IoC 容器注册解析的 Bean，BeanDefinitionReaderUtils 的注册的源码如下： 123456789101112131415//将解析的BeanDefinitionHold注册到容器中 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; //获取解析的BeanDefinition的名称 String beanName = definitionHolder.getBeanName(); //向IoC容器注册BeanDefinition registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); //如果解析的BeanDefinition有别名，向容器为其注册别名 String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String aliase : aliases) &#123; registry.registerAlias(beanName, aliase); &#125; &#125; &#125; 当调用 BeanDefinitionReaderUtils 向 IoC 容器注册解析的 BeanDefinition 时，真正完成注册功能的是 DefaultListableBeanFactory。 17、DefaultListableBeanFactory 向 IoC 容器注册解析后的 BeanDefinition：DefaultListableBeanFactory 中使用一个 HashMap 的集合对象存放 IoC 容器中注册解析的 BeanDefinition，向 IoC 容器注册的主要源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//存储注册的俄BeanDefinition private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;(); //向IoC容器注册解析的BeanDefiniton public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; Assert.hasText(beanName, "Bean name must not be empty"); Assert.notNull(beanDefinition, "BeanDefinition must not be null"); //校验解析的BeanDefiniton if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, "Validation of bean definition failed", ex); &#125; &#125; //注册的过程中需要线程同步，以保证数据的一致性 synchronized (this.beanDefinitionMap) &#123; Object oldBeanDefinition = this.beanDefinitionMap.get(beanName); //检查是否有同名的BeanDefinition已经在IoC容器中注册，如果已经注册， //并且不允许覆盖已注册的Bean，则抛出注册失败异常 if (oldBeanDefinition != null) &#123; if (!this.allowBeanDefinitionOverriding) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, "Cannot register bean definition [" + beanDefinition + "] for bean '" + beanName + "': There is already [" + oldBeanDefinition + "] bound."); &#125; else &#123;//如果允许覆盖，则同名的Bean，后注册的覆盖先注册的 if (this.logger.isInfoEnabled()) &#123; this.logger.info("Overriding bean definition for bean '" + beanName + "': replacing [" + oldBeanDefinition + "] with [" + beanDefinition + "]"); &#125; &#125; &#125; //IoC容器中没有已经注册同名的Bean，按正常注册流程注册 else &#123; this.beanDefinitionNames.add(beanName); this.frozenBeanDefinitionNames = null; &#125; this.beanDefinitionMap.put(beanName, beanDefinition); //重置所有已经注册过的BeanDefinition的缓存 resetBeanDefinition(beanName); &#125; &#125; 至此，Bean 定义资源文件中配置的 Bean 被解析过后，已经注册到 IoC 容器中，被容器管理起来，真正完成了 IoC 容器初始化所做的全部工作。现 在 IoC 容器中已经建立了整个 Bean 的配置信息，这些 BeanDefinition 信息已经可以使用，并且可以被检索，IoC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护。这些的注册的 Bean 定义信息是 IoC 容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。 总结：现在通过上面的代码，总结一下 IOC 容器初始化的基本步骤： 初始化的入口在容器实现中的 refresh() 调用来完成 对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition, 其中的大致过程如下： 通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置。 如果是 XmlBeanFactory 作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的，容器通过 BeanDefinitionReader 来完成定义信息的解析和 Bean 信息的注册, 往往使用的是 XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到 loadBeanDefinition,RegisterBeanDefinition 这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的， 容器解析得到 BeanDefinitionIoC 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。 注册过程就是在 IOC 容器内部维护的一个 HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个 HashMap 来实现的. 然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了。 在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。 Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文, 并将其存储在 ServletContext 中的框架实现。具体可以参见以后的文章 在使用 Spring IOC 容器的时候我们还需要区别两个概念: Beanfactory 和 Factory bean，其中 BeanFactory 指的是 IOC 容器的编程抽象，比如 ApplicationContext， XmlBeanFactory 等，这些都是 IOC 容器的具体表现，需要使用什么样的容器由客户决定, 但 Spring 为我们提供了丰富的选择。 FactoryBean 只是一个可以在 IOC 而容器中被管理的一个 bean, 是对各种处理过程和资源使用的抽象, Factory bean 在需要时产生另一个对象，而不返回 FactoryBean 本身, 我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的 Factory bean 都实现特殊的 org.springframework.beans.factory.FactoryBean 接口，当使用容器中 factory bean 的时候，该容器不会返回 factory bean 本身, 而是返回其生成的对象。Spring 包括了大部分的通用资源和服务访问抽象的 Factory bean 的实现，其中包括: 对 JNDI 查询的处理，对代理对象的处理，对事务性代理的处理，对 RMI 代理的处理等，这些我们都可以看成是具体的工厂, 看成是 SPRING 为我们建立好的工厂。也就是说 Spring 通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象, 免除我们手工重复的工作，我们要使用时只需要在 IOC 容器里配置好就能很方便的使用了 四、IOC 容器的依赖注入1、依赖注入发生的时间当 Spring IoC 容器完成了 Bean 定义资源的定位、载入和解析注册以后，IoC 容器中已经管理类 Bean 定义的相关数据，但是此时 IoC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生： (1). 用户第一次通过 getBean 方法向 IoC 容索要 Bean 时，IoC 容器触发依赖注入。 (2). 当用户在 Bean 定义资源中为 &lt; Bean &gt; 元素配置了 lazy-init 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。 BeanFactory 接口定义了 Spring IoC 容器的基本功能规范，是 Spring IoC 容器所应遵守的最底层和最基本的编程规范。BeanFactory 接口中定义了几个 getBean 方法，就是用户向 IoC 容器索取管理的 Bean 的方法，我们通过分析其子类的具体实现，理解 Spring IoC 容器在用户索取 Bean 时如何完成依赖注入。 在 BeanFactory 中我们看到 getBean（String…）函数，它的具体实现在 AbstractBeanFactory 中 2、AbstractBeanFactory 通过 getBean 向 IoC 容器获取被管理的 Bean：AbstractBeanFactory 的 getBean 相关方法的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169//获取IoC容器中指定名称的Bean public Object getBean(String name) throws BeansException &#123; //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, null, null, false); &#125; //获取IoC容器中指定名称和类型的Bean public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123; //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, requiredType, null, false); &#125; //获取IoC容器中指定名称和参数的Bean public Object getBean(String name, Object... args) throws BeansException &#123; //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, null, args, false); &#125; //获取IoC容器中指定名称、类型和参数的Bean public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType, Object... args) throws BeansException &#123; //doGetBean才是真正向IoC容器获取被管理Bean的过程 return doGetBean(name, requiredType, args, false); &#125; //真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方 @SuppressWarnings("unchecked") protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖 //如果指定的是别名，将别名转换为规范的Bean名称 final String beanName = transformedBeanName(name); Object bean; //先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整 //个IoC容器中只创建一次，不需要重复创建 Object sharedInstance = getSingleton(beanName); //IoC容器创建单态模式Bean实例对象 if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; //如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回 //已经创建的Bean if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference"); &#125; else &#123; logger.debug("Returning cached instance of singleton bean '" + beanName + "'"); &#125; &#125; //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理 //注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是 //创建创建对象的工厂Bean，两者之间有区别 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123;//缓存没有正在创建的单态模式Bean //缓存中已经有已经创建的原型模式Bean，但是由于循环引用的问题导致实 //例化对象失败 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; //对IoC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否 //能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器 //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找 BeanFactory parentBeanFactory = getParentBeanFactory(); //当前容器的父级容器存在，且当前容器中不存在指定名称的Bean if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; //解析指定Bean名称的原始名称 String nameToLookup = originalBeanName(name); if (args != null) &#123; //委派父级容器根据指定名称和显式的参数查找 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; //委派父级容器根据指定名称和类型查找 return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; //创建的Bean是否需要进行类型验证，一般不需要 if (!typeCheckOnly) &#123; //向容器标记指定的Bean已经被创建 markBeanAsCreated(beanName); &#125; //根据指定Bean名称获取其父级的Bean定义，主要解决Bean继承时子类 //合并父类公共属性问题 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); //获取当前Bean所有依赖Bean的名称 String[] dependsOn = mbd.getDependsOn(); //如果当前Bean有依赖Bean if (dependsOn != null) &#123; for (String dependsOnBean : dependsOn) &#123; //递归调用getBean方法，获取当前Bean的依赖Bean getBean(dependsOnBean); //把被依赖Bean注册给当前依赖的Bean registerDependentBean(dependsOnBean, beanName); &#125; &#125; //创建单态模式Bean的实例对象 if (mbd.isSingleton()) &#123; //这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象 sharedInstance = getSingleton(beanName, new ObjectFactory() &#123; public Object getObject() throws BeansException &#123; try &#123; //创建一个指定Bean实例对象，如果有父级继承，则合并子//类和父类的定义 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; //显式地从容器单态模式Bean缓存中清除实例对象 destroySingleton(beanName); throw ex; &#125; &#125; &#125;); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; //IoC容器创建原型模式Bean实例对象 else if (mbd.isPrototype()) &#123; //原型模式(Prototype)是每次都会创建一个新的对象 Object prototypeInstance = null; try &#123; //回调beforePrototypeCreation方法，默认的功能是注册当前创//建的原型对象 beforePrototypeCreation(beanName); //创建指定Bean对象实例 prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; //回调afterPrototypeCreation方法，默认的功能告诉IoC容器指//定Bean的原型对象不再创建了 afterPrototypeCreation(beanName); &#125; //获取给定Bean的实例对象 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; //要创建的Bean既不是单态模式，也不是原型模式，则根据Bean定义资源中 //配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中 //比较常用，如：request、session、application等生命周期 else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); //Bean定义资源中没有配置生命周期范围，则Bean定义不合法 if (scope == null) &#123; throw new IllegalStateException("No Scope registered for scope '" + scopeName + "'"); &#125; try &#123; //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例 Object scopedInstance = scope.get(beanName, new ObjectFactory() &#123; public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); //获取给定Bean的实例对象 bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, "Scope '" + scopeName + "' is not active for the current thread; " + "consider defining a scoped proxy for this bean if you intend to refer to it from a singleton", ex); &#125; &#125; &#125; //对创建的Bean实例对象进行类型检查 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; return (T) bean; &#125; 通过上面对向 IoC 容器获取 Bean 方法的分析，我们可以看到在 Spring 中，如果 Bean 定义的单态模式 (Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean 定义的是原型模式 (Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以扩展为指定其生命周期范围。 上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean 实例对象的创建过程由实现了 ObejctFactory 接口的匿名内部类的 createBean 方法完成，ObejctFactory 使用委派模式，具体的 Bean 实例创建过程交由其实现类 AbstractAutowireCapableBeanFactory 完成，我们继续分析 AbstractAutowireCapableBeanFactory 的 createBean 方法的源码，理解其创建 Bean 实例的具体实现过程。 3、AbstractAutowireCapableBeanFactory 创建 Bean 实例对象：AbstractAutowireCapableBeanFactory 类实现了 ObejctFactory 接口，创建容器指定的 Bean 实例对象，同时还对创建的 Bean 实例对象进行初始化处理。其创建 Bean 实例对象的方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//创建Bean实例对象 protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Creating instance of bean '" + beanName + "'"); &#125; //判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载 resolveBeanClass(mbd, beanName); //校验和准备Bean中的方法覆盖 try &#123; mbd.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, "Validation of method overrides failed", ex); &#125; try &#123; //如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建//Bean的代理对象 Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", ex); &#125; //创建Bean的入口 Object beanInstance = doCreateBean(beanName, mbd, args); if (logger.isDebugEnabled()) &#123; logger.debug("Finished creating instance of bean '" + beanName + "'"); &#125; return beanInstance; &#125; //真正创建Bean的方法 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; //封装被创建的Bean对象 BeanWrapper instanceWrapper = null; if (mbd.isSingleton())&#123;//单态模式的Bean，先从容器中缓存中获取同名Bean instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; //创建实例对象 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); //获取实例化对象的类型 Class beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); //调用PostProcessor后置处理器 synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references //向容器中缓存单态模式的Bean对象，以防循环引用 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); &#125; //这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用 addSingletonFactory(beanName, new ObjectFactory() &#123; public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; //Bean对象的初始化，依赖注入在此触发 //这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean Object exposedObject = bean; try &#123; //将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; //初始化Bean对象 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex); &#125; &#125; if (earlySingletonExposure) &#123; //获取指定名称的已注册的单态模式Bean对象 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; //根据名称获取的以注册的Bean和正在实例化的Bean是同一个 if (exposedObject == bean) &#123; //当前实例化的Bean初始化完成 exposedObject = earlySingletonReference; &#125; //当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); //获取当前Bean所依赖的其他Bean for (String dependentBean : dependentBeans) &#123; //对依赖Bean进行类型检查 if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been " + "wrapped. This means that said other beans do not use the final version of the " + "bean. This is often the result of over-eager type matching - consider using " + "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."); &#125; &#125; &#125; &#125; //注册完成依赖注入的Bean try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex); &#125; return exposedObject; &#125; 通过对方法源码的分析，我们看到具体的依赖注入实现在以下两个方法中： (1).createBeanInstance：生成 Bean 所包含的 java 对象实例。 (2).populateBean ：对 Bean 属性的依赖注入进行处理。 下面继续分析这两个方法的代码实现。 4、createBeanInstance 方法创建 Bean 的 java 实例对象：在 createBeanInstance 方法中，根据指定的初始化策略，使用静态工厂、工厂方法或者容器的自动装配特性生成 java 实例对象，创建对象的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//创建Bean的实例对象 protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123; //检查确认Bean是可实例化的 Class beanClass = resolveBeanClass(mbd, beanName); //使用工厂方法对Bean进行实例化 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Bean class isn't public, and non-public access not allowed: " + beanClass.getName()); &#125; if (mbd.getFactoryMethodName() != null) &#123; //调用工厂方法实例化 return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; //使用容器的自动装配方法进行实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; //配置了自动装配属性，使用容器的自动装配实例化 //容器的自动装配是根据参数类型匹配Bean的构造方法 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; //使用默认的无参构造方法实例化 return instantiateBean(beanName, mbd); &#125; &#125; //使用Bean的构造方法进行实例化 Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; //使用容器的自动装配特性，调用匹配的构造方法实例化 return autowireConstructor(beanName, mbd, ctors, args); &#125; //使用默认的无参构造方法实例化 return instantiateBean(beanName, mbd); &#125; //使用默认的无参构造方法实例化Bean对象 protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123; try &#123; Object beanInstance; final BeanFactory parent = this; //获取系统的安全管理接口，JDK标准的安全管理API if (System.getSecurityManager() != null) &#123; //这里是一个匿名内置类，根据实例化策略创建实例对象 beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; return getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; &#125;, getAccessControlContext()); &#125; else &#123; //将实例化的对象封装起来 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex); &#125; &#125; 经过对上面的代码分析，我们可以看出，对使用工厂方法和自动装配特性的 Bean 的实例化比较清楚，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于我们最常使用的默认无参构造方法就需要使用相应的初始化策略 (JDK 的反射机制或者 CGLIB) 来进行初始化了，在方法 getInstantiationStrategy().instantiate 中就具体实现类使用初始策略实例化对象。 5、SimpleInstantiationStrategy 类使用默认的无参构造方法创建 Bean 实例化对象：在使用默认的无参构造方法创建 Bean 的实例化对象时，方法 getInstantiationStrategy().instantiate 调用了 SimpleInstantiationStrategy 类中的实例化 Bean 的方法，其源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//使用初始化策略实例化Bean对象 public Object instantiate(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner) &#123; //如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法 if (beanDefinition.getMethodOverrides().isEmpty()) &#123; Constructor&lt;?&gt; constructorToUse; synchronized (beanDefinition.constructorArgumentLock) &#123; //获取对象的构造方法或工厂方法 constructorToUse = (Constructor&lt;?&gt;) beanDefinition.resolvedConstructorOrFactoryMethod; //如果没有构造方法且没有工厂方法 if (constructorToUse == null) &#123; //使用JDK的反射机制，判断要实例化的Bean是否是接口 final Class clazz = beanDefinition.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, "Specified class is an interface"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; //这里是一个匿名内置类，使用反射机制获取Bean的构造方法 constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&gt;() &#123; public Constructor run() throws Exception &#123; return clazz.getDeclaredConstructor((Class[]) null); &#125; &#125;); &#125; else &#123; constructorToUse = clazz.getDeclaredConstructor((Class[]) null); &#125; beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; catch (Exception ex) &#123; throw new BeanInstantiationException(clazz, "No default constructor found", ex); &#125; &#125; &#125; //使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化 return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; //使用CGLIB来实例化对象 return instantiateWithMethodInjection(beanDefinition, beanName, owner); &#125; &#125; 通过上面的代码分析，我们看到了如果 Bean 有方法被覆盖了，则使用 JDK 的反射机制进行实例化，否则，使用 CGLIB 进行实例化。 instantiateWithMethodInjection 方法调用 SimpleInstantiationStrategy 的子类 CglibSubclassingInstantiationStrategy 使用 CGLIB 来进行初始化，其源码如下： 1234567891011121314151617//使用CGLIB进行Bean对象实例化 public Object instantiate(Constructor ctor, Object[] args) &#123; //CGLIB中的类 Enhancer enhancer = new Enhancer(); //将Bean本身作为其基类 enhancer.setSuperclass(this.beanDefinition.getBeanClass()); enhancer.setCallbackFilter(new CallbackFilterImpl()); enhancer.setCallbacks(new Callback[] &#123; NoOp.INSTANCE, new LookupOverrideMethodInterceptor(), new ReplaceOverrideMethodInterceptor() &#125;); //使用CGLIB的create方法生成实例对象 return (ctor == null) ? enhancer.create() : enhancer.create(ctor.getParameterTypes(), args); &#125; CGLIB 是一个常用的字节码生成器的类库，它提供了一系列 API 实现 java 字节码的生成和转换功能。我们在学习 JDK 的动态代理时都知道，JDK 的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用 CGLIB。 6、populateBean 方法对 Bean 属性的依赖注入：在第 3 步的分析中我们已经了解到 Bean 的依赖注入分为以下两个过程： (1).createBeanInstance：生成 Bean 所包含的 java 对象实例。 (2).populateBean ：对 Bean 属性的依赖注入进行处理。 第 4、5 步中我们已经分析了容器初始化生成 Bean 所包含的 Java 实例对象的过程，现在我们继续分析生成对象后，Spring IoC 容器是如何将 Bean 的属性依赖关系注入 Bean 实例对象中并设置好的，属性依赖注入的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175//将Bean属性设置到生成的实例对象上 protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) &#123; //获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值 PropertyValues pvs = mbd.getPropertyValues(); //实例对象为null if (bw == null) &#123; //属性值不为空 if (!pvs.isEmpty()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance"); &#125; else &#123; //实例对象为null，属性值也为空，不需要设置属性值，直接返回 return; &#125; &#125; //在设置属性之前调用Bean的PostProcessor后置处理器 boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (!continueWithPropertyPopulation) &#123; return; &#125; //依赖注入开始，首先处理autowire自动装配的注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); //对autowire自动装配的处理，根据Bean名称自动装配注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; //根据Bean类型自动装配注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; //检查容器是否持有用于处理单态模式Bean关闭时的后置处理器 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); //Bean实例对象没有依赖，即没有继承基类 boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) &#123; //从实例对象中提取属性描述符 PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw); if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; //使用BeanPostProcessor处理器处理属性值 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; //为要设置的属性进行依赖检查 checkDependencies(beanName, mbd, filteredPds, pvs); &#125; &#125; //对属性进行注入 applyPropertyValues(beanName, mbd, bw, pvs); &#125; //解析并注入依赖属性的过程 protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) &#123; if (pvs == null || pvs.isEmpty()) &#123; return; &#125; //封装属性值 MutablePropertyValues mpvs = null; List&lt;PropertyValue&gt; original; if (System.getSecurityManager()!= null) &#123; if (bw instanceof BeanWrapperImpl) &#123; //设置安全上下文，JDK安全机制 ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext()); &#125; &#125; if (pvs instanceof MutablePropertyValues) &#123; mpvs = (MutablePropertyValues) pvs; //属性值已经转换 if (mpvs.isConverted()) &#123; try &#123; //为实例化对象设置属性值 bw.setPropertyValues(mpvs); return; &#125; catch (BeansException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Error setting property values", ex); &#125; &#125; //获取属性值对象的原始类型值 original = mpvs.getPropertyValueList(); &#125; else &#123; original = Arrays.asList(pvs.getPropertyValues()); &#125; //获取用户自定义的类型转换 TypeConverter converter = getCustomTypeConverter(); if (converter == null) &#123; converter = bw; &#125; //创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象 //的实际值 BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter); //为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中 List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;PropertyValue&gt;(original.size()); boolean resolveNecessary = false; for (PropertyValue pv : original) &#123; //属性值不需要转换 if (pv.isConverted()) &#123; deepCopy.add(pv); &#125; //属性值需要转换 else &#123; String propertyName = pv.getName(); //原始的属性值，即转换之前的属性值 Object originalValue = pv.getValue(); //转换属性值，例如将引用转换为IoC容器中实例化对象引用 Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue); //转换之后的属性值 Object convertedValue = resolvedValue; //属性值是否可以转换 boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp; !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName); if (convertible) &#123; //使用用户自定义的类型转换器转换属性值 convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter); &#125; //存储转换后的属性值，避免每次属性注入时的转换工作 if (resolvedValue == originalValue) &#123; if (convertible) &#123; //设置属性转换之后的值 pv.setConvertedValue(convertedValue); &#125; deepCopy.add(pv); &#125; //属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是 //动态生成的字符串，且属性的原始值不是集合或者数组类型 else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp; !((TypedStringValue) originalValue).isDynamic() &amp;&amp; !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) &#123; pv.setConvertedValue(convertedValue); deepCopy.add(pv); &#125; else &#123; resolveNecessary = true; //重新封装属性的值 deepCopy.add(new PropertyValue(pv, convertedValue)); &#125; &#125; &#125; if (mpvs != null &amp;&amp; !resolveNecessary) &#123; //标记属性值已经转换过 mpvs.setConverted(); &#125; //进行属性依赖注入 try &#123; bw.setPropertyValues(new MutablePropertyValues(deepCopy)); &#125; catch (BeansException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Error setting property values", ex); &#125; &#125; 分析上述代码，我们可以看出，对属性的注入过程分以下两种情况： (1). 属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入。 (2). 属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。 对属性值的解析是在 BeanDefinitionValueResolver 类中的 resolveValueIfNecessary 方法中进行的，对属性值的依赖注入是通过 bw.setPropertyValues 方法实现的，在分析属性值的依赖注入之前，我们先分析一下对属性值的解析过程。 7、BeanDefinitionResolver 解析属性值：当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个 Bean 实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由 resolveValueIfNecessary 方法实现，其源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188//解析属性值，对注入类型进行转换 public Object resolveValueIfNecessary(Object argName, Object value) &#123; //对引用类型的属性进行解析 if (value instanceof RuntimeBeanReference) &#123; RuntimeBeanReference ref = (RuntimeBeanReference) value; //调用引用类型属性的解析方法 return resolveReference(argName, ref); &#125; //对属性值是引用容器中另一个Bean名称的解析 else if (value instanceof RuntimeBeanNameReference) &#123; String refName = ((RuntimeBeanNameReference) value).getBeanName(); refName = String.valueOf(evaluate(refName)); //从容器中获取指定名称的Bean if (!this.beanFactory.containsBean(refName)) &#123; throw new BeanDefinitionStoreException( "Invalid bean name '" + refName + "' in bean reference for " + argName); &#125; return refName; &#125; //对Bean类型属性的解析，主要是Bean中的内部类 else if (value instanceof BeanDefinitionHolder) &#123; BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value; return resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition()); &#125; else if (value instanceof BeanDefinition) &#123; BeanDefinition bd = (BeanDefinition) value; return resolveInnerBean(argName, "(inner bean)", bd); &#125; //对集合数组类型的属性解析 else if (value instanceof ManagedArray) &#123; ManagedArray array = (ManagedArray) value; //获取数组的类型 Class elementType = array.resolvedElementType; if (elementType == null) &#123; //获取数组元素的类型 String elementTypeName = array.getElementTypeName(); if (StringUtils.hasText(elementTypeName)) &#123; try &#123; //使用反射机制创建指定类型的对象 elementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader()); array.resolvedElementType = elementType; &#125; catch (Throwable ex) &#123; throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, "Error resolving array type for " + argName, ex); &#125; &#125; //没有获取到数组的类型，也没有获取到数组元素的类型，则直接设置数 //组的类型为Object else &#123; elementType = Object.class; &#125; &#125; //创建指定类型的数组 return resolveManagedArray(argName, (List&lt;?&gt;) value, elementType); &#125; //解析list类型的属性值 else if (value instanceof ManagedList) &#123; return resolveManagedList(argName, (List&lt;?&gt;) value); &#125; //解析set类型的属性值 else if (value instanceof ManagedSet) &#123; return resolveManagedSet(argName, (Set&lt;?&gt;) value); &#125; //解析map类型的属性值 else if (value instanceof ManagedMap) &#123; return resolveManagedMap(argName, (Map&lt;?, ?&gt;) value); &#125; //解析props类型的属性值，props其实就是key和value均为字符串的map else if (value instanceof ManagedProperties) &#123; Properties original = (Properties) value; //创建一个拷贝，用于作为解析后的返回值 Properties copy = new Properties(); for (Map.Entry propEntry : original.entrySet()) &#123; Object propKey = propEntry.getKey(); Object propValue = propEntry.getValue(); if (propKey instanceof TypedStringValue) &#123; propKey = evaluate((TypedStringValue) propKey); &#125; if (propValue instanceof TypedStringValue) &#123; propValue = evaluate((TypedStringValue) propValue); &#125; copy.put(propKey, propValue); &#125; return copy; &#125; //解析字符串类型的属性值 else if (value instanceof TypedStringValue) &#123; TypedStringValue typedStringValue = (TypedStringValue) value; Object valueObject = evaluate(typedStringValue); try &#123; //获取属性的目标类型 Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue); if (resolvedTargetType != null) &#123; //对目标类型的属性进行解析，递归调用 return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType); &#125; //没有获取到属性的目标对象，则按Object类型返回 else &#123; return valueObject; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, "Error converting typed String value for " + argName, ex); &#125; &#125; else &#123; return evaluate(value); &#125; &#125; //解析引用类型的属性值 private Object resolveReference(Object argName, RuntimeBeanReference ref) &#123; try &#123; //获取引用的Bean名称 String refName = ref.getBeanName(); refName = String.valueOf(evaluate(refName)); //如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象 if (ref.isToParent()) &#123; if (this.beanFactory.getParentBeanFactory() == null) &#123; throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, "Can't resolve reference to bean '" + refName + "' in parent factory: no parent factory available"); &#125; return this.beanFactory.getParentBeanFactory().getBean(refName); &#125; //从当前的容器中获取指定的引用Bean对象，如果指定的Bean没有被实例化 //则会递归触发引用Bean的初始化和依赖注入 else &#123; Object bean = this.beanFactory.getBean(refName); //将当前实例化对象的依赖引用对象 this.beanFactory.registerDependentBean(refName, this.beanName); return bean; &#125; &#125; catch (BeansException ex) &#123; throw new BeanCreationException( this.beanDefinition.getResourceDescription(), this.beanName, "Cannot resolve reference to bean '" + ref.getBeanName() + "' while setting " + argName, ex); &#125; &#125; //解析array类型的属性 private Object resolveManagedArray(Object argName, List&lt;?&gt; ml, Class elementType) &#123; //创建一个指定类型的数组，用于存放和返回解析后的数组 Object resolved = Array.newInstance(elementType, ml.size()); for (int i = 0; i &lt; ml.size(); i++) &#123; //递归解析array的每一个元素，并将解析后的值设置到resolved数组中，索引为i Array.set(resolved, i, resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i))); &#125; return resolved; &#125; //解析list类型的属性 private List resolveManagedList(Object argName, List&lt;?&gt; ml) &#123; List&lt;Object&gt; resolved = new ArrayList&lt;Object&gt;(ml.size()); for (int i = 0; i &lt; ml.size(); i++) &#123; //递归解析list的每一个元素 resolved.add( resolveValueIfNecessary(new KeyedArgName(argName, i), ml.get(i))); &#125; return resolved; &#125; //解析set类型的属性 private Set resolveManagedSet(Object argName, Set&lt;?&gt; ms) &#123; Set&lt;Object&gt; resolved = new LinkedHashSet&lt;Object&gt;(ms.size()); int i = 0; //递归解析set的每一个元素 for (Object m : ms) &#123; resolved.add(resolveValueIfNecessary(new KeyedArgName(argName, i), m)); i++; &#125; return resolved; &#125; //解析map类型的属性 private Map resolveManagedMap(Object argName, Map&lt;?, ?&gt; mm) &#123; Map&lt;Object, Object&gt; resolved = new LinkedHashMap&lt;Object, Object&gt;(mm.size()); //递归解析map中每一个元素的key和value for (Map.Entry entry : mm.entrySet()) &#123; Object resolvedKey = resolveValueIfNecessary(argName, entry.getKey()); Object resolvedValue = resolveValueIfNecessary( new KeyedArgName(argName, entry.getKey()), entry.getValue()); resolved.put(resolvedKey, resolvedValue); &#125; return resolved; &#125; 通过上面的代码分析，我们明白了 Spring 是如何将引用类型，内部类以及集合类型等属性进行解析的，属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是 Bean 对象实例设置到它所依赖的 Bean 对象属性上去，在第 7 步中我们已经说过，依赖注入是通过 bw.setPropertyValues 方法实现的，该方法也使用了委托模式，在 BeanWrapper 接口中至少定义了方法声明，依赖注入的具体实现交由其实现类 BeanWrapperImpl 来完成，下面我们就分析依 BeanWrapperImpl 中赖注入相关的源码。 8、BeanWrapperImpl 对 Bean 属性的依赖注入：BeanWrapperImpl 类主要是对容器中完成初始化的 Bean 实例对象进行属性的依赖注入，即把 Bean 对象设置到它所依赖的另一个 Bean 的属性中去，依赖注入的相关源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259//实现属性依赖注入功能 private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException &#123; //PropertyTokenHolder主要保存属性的名称、路径，以及集合的size等信息 String propertyName = tokens.canonicalName; String actualName = tokens.actualName; //keys是用来保存集合类型属性的size if (tokens.keys != null) &#123; //将属性信息拷贝 PropertyTokenHolder getterTokens = new PropertyTokenHolder(); getterTokens.canonicalName = tokens.canonicalName; getterTokens.actualName = tokens.actualName; getterTokens.keys = new String[tokens.keys.length - 1]; System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1); Object propValue; try &#123; //获取属性值，该方法内部使用JDK的内省( Introspector)机制，调用属性//的getter(readerMethod)方法，获取属性的值 propValue = getPropertyValue(getterTokens); &#125; catch (NotReadablePropertyException ex) &#123; throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, "Cannot access indexed value in property referenced " + "in indexed property path '" + propertyName + "'", ex); &#125; //获取集合类型属性的长度 String key = tokens.keys[tokens.keys.length - 1]; if (propValue == null) &#123; throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, "Cannot access indexed value in property referenced " + "in indexed property path '" + propertyName + "': returned null"); &#125; //注入array类型的属性值 else if (propValue.getClass().isArray()) &#123; //获取属性的描述符 PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName); //获取数组的类型 Class requiredType = propValue.getClass().getComponentType(); //获取数组的长度 int arrayIndex = Integer.parseInt(key); Object oldValue = null; try &#123; //获取数组以前初始化的值 if (isExtractOldValueForEditor()) &#123; oldValue = Array.get(propValue, arrayIndex); &#125; //将属性的值赋值给数组中的元素 Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType)); Array.set(propValue, arrayIndex, convertedValue); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, "Invalid array index in property path '" + propertyName + "'", ex); &#125; &#125; //注入list类型的属性值 else if (propValue instanceof List) &#123; PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName); //获取list集合的类型 Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType( pd.getReadMethod(), tokens.keys.length); List list = (List) propValue; //获取list集合的size int index = Integer.parseInt(key); Object oldValue = null; if (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123; oldValue = list.get(index); &#125; //获取list解析后的属性值 Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType)); if (index &lt; list.size()) &#123; //为list属性赋值 list.set(index, convertedValue); &#125; //如果list的长度大于属性值的长度，则多余的元素赋值为null else if (index &gt;= list.size()) &#123; for (int i = list.size(); i &lt; index; i++) &#123; try &#123; list.add(null); &#125; catch (NullPointerException ex) &#123; throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, "Cannot set element with index " + index + " in List of size " + list.size() + ", accessed using property path '" + propertyName + "': List does not support filling up gaps with null elements"); &#125; &#125; list.add(convertedValue); &#125; &#125; //注入map类型的属性值 else if (propValue instanceof Map) &#123; PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName); //获取map集合key的类型 Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType( pd.getReadMethod(), tokens.keys.length); //获取map集合value的类型 Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType( pd.getReadMethod(), tokens.keys.length); Map map = (Map) propValue; //解析map类型属性key值 Object convertedMapKey = convertIfNecessary(null, null, key, mapKeyType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType)); Object oldValue = null; if (isExtractOldValueForEditor()) &#123; oldValue = map.get(convertedMapKey); &#125; //解析map类型属性value值 Object convertedMapValue = convertIfNecessary( propertyName, oldValue, pv.getValue(), mapValueType, new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1))); //将解析后的key和value值赋值给map集合属性 map.put(convertedMapKey, convertedMapValue); &#125; else &#123; throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, "Property referenced in indexed property path '" + propertyName + "' is neither an array nor a List nor a Map; returned value was [" + pv.getValue() + "]"); &#125; &#125; //对非集合类型的属性注入 else &#123; PropertyDescriptor pd = pv.resolvedDescriptor; if (pd == null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) &#123; pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName); //无法获取到属性名或者属性没有提供setter(写方法)方法 if (pd == null || pd.getWriteMethod() == null) &#123; //如果属性值是可选的，即不是必须的，则忽略该属性值 if (pv.isOptional()) &#123; logger.debug("Ignoring optional value for property '" + actualName + "' - property not found on bean class [" + getRootClass().getName() + "]"); return; &#125; //如果属性值是必须的，则抛出无法给属性赋值，因为每天提供setter方法异常 else &#123; PropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass()); throw new NotWritablePropertyException( getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches()); &#125; &#125; pv.getOriginalPropertyValue().resolvedDescriptor = pd; &#125; Object oldValue = null; try &#123; Object originalValue = pv.getValue(); Object valueToApply = originalValue; if (!Boolean.FALSE.equals(pv.conversionNecessary)) &#123; if (pv.isConverted()) &#123; valueToApply = pv.getConvertedValue(); &#125; else &#123; if (isExtractOldValueForEditor() &amp;&amp; pd.getReadMethod() != null) &#123; //获取属性的getter方法(读方法)，JDK内省机制 final Method readMethod = pd.getReadMethod(); //如果属性的getter方法不是public访问控制权限的，即访问控制权限比较严格， //则使用JDK的反射机制强行访问非public的方法(暴力读取属性值) if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &amp;&amp; !readMethod.isAccessible()) &#123; if (System.getSecurityManager()!= null) &#123; //匿名内部类，根据权限修改属性的读取控制限制 AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; readMethod.setAccessible(true); return null; &#125; &#125;); &#125; else &#123; readMethod.setAccessible(true); &#125; &#125; try &#123; //属性没有提供getter方法时，调用潜在的读取属性值//的方法，获取属性值 if (System.getSecurityManager() != null) &#123; oldValue = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; public Object run() throws Exception &#123; return readMethod.invoke(object); &#125; &#125;, acc); &#125; else &#123; oldValue = readMethod.invoke(object); &#125; &#125; catch (Exception ex) &#123; if (ex instanceof PrivilegedActionException) &#123; ex = ((PrivilegedActionException) ex).getException(); &#125; if (logger.isDebugEnabled()) &#123; logger.debug("Could not read previous value of property '" + this.nestedPath + propertyName + "'", ex); &#125; &#125; &#125; //设置属性的注入值 valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd); &#125; pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue); &#125; //根据JDK的内省机制，获取属性的setter(写方法)方法 final Method writeMethod = (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod()); //如果属性的setter方法是非public，即访问控制权限比较严格，则使用JDK的反射机制， //强行设置setter方法可访问(暴力为属性赋值) if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) &amp;&amp; !writeMethod.isAccessible()) &#123; //如果使用了JDK的安全机制，则需要权限验证 if (System.getSecurityManager()!= null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; writeMethod.setAccessible(true); return null; &#125; &#125;); &#125; else &#123; writeMethod.setAccessible(true); &#125; &#125; final Object value = valueToApply; if (System.getSecurityManager() != null) &#123; try &#123; //将属性值设置到属性上去 AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; public Object run() throws Exception &#123; writeMethod.invoke(object, value); return null; &#125; &#125;, acc); &#125; catch (PrivilegedActionException ex) &#123; throw ex.getException(); &#125; &#125; else &#123; writeMethod.invoke(this.object, value); &#125; &#125; catch (TypeMismatchException ex) &#123; throw ex; &#125; catch (InvocationTargetException ex) &#123; PropertyChangeEvent propertyChangeEvent = new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue()); if (ex.getTargetException() instanceof ClassCastException) &#123; throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException()); &#125; else &#123; throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException()); &#125; &#125; catch (Exception ex) &#123; PropertyChangeEvent pce = new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue()); throw new MethodInvocationException(pce, ex); &#125; &#125; &#125; 通过对上面注入依赖代码的分析，我们已经明白了 Spring IoC 容器是如何将属性的值注入到 Bean 实例对象中去的： (1). 对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。 (2). 对于非集合类型的属性，大量使用了 JDK 的反射和内省机制，通过属性的 getter 方法 (reader method) 获取指定属性注入以前的值，同时调用属性的 setter 方法 (writer method) 为属性设置注入后的值。看到这里相信很多人都明白了 Spring 的 setter 注入原理。 至此 Spring IoC 容器对 Bean 定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在 Spring IoC 容器中管理了一系列靠依赖关系联系起来的 Bean，程序不需要应用自己手动创建所需的对象，Spring IoC 容器会在我们使用的时候自动为我们创建，并且为我们注入好相关的依赖，这就是 Spring 核心功能的控制反转和依赖注入的相关功能。 五、IoC 容器的高级特性1、介绍通过前面 4 篇文章对 Spring IoC 容器的源码分析，我们已经基本上了解了 Spring IoC 容器对 Bean 定义资源的定位、读入和解析过程，同时也清楚了当用户通过 getBean 方法向 IoC 容器获取被管理的 Bean 时，IoC 容器对 Bean 进行的初始化和依赖注入过程，这些是 Spring IoC 容器的基本功能特性。Spring IoC 容器还有一些高级特性，如使用 lazy-init 属性对 Bean 预初始化、FactoryBean 产生或者修饰 Bean 对象的生成、IoC 容器初始化 Bean 过程中使用 BeanPostProcessor 后置处理器对 Bean 声明周期事件管理和 IoC 容器的 autowiring 自动装配功能等。 2、Spring IoC 容器的 lazy-init 属性实现预实例化：通过前面我们对 IoC 容器的实现和工作原理分析，我们知道 IoC 容器的初始化过程就是对 Bean 定义资源的定位、载入和注册，此时容器对 Bean 的依赖注入并没有发生，依赖注入主要是在应用程序第一次向容器索取 Bean 时，通过 getBean 方法的调用完成。 当 Bean 定义资源的 &lt;Bean&gt; 元素中配置了 lazy-init 属性时，容器将会在初始化的时候对所配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化的时候就已经完成。这样，当应用程序第一次向容器索取被管理的 Bean 时，就不用再初始化和对 Bean 进行依赖注入了，直接从容器中获取已经完成依赖注入的现成 Bean，可以提高应用第一次向容器获取 Bean 的性能。 下面我们通过代码分析容器预实例化的实现过程： (1).refresh()先从 IoC 容器的初始会过程开始，通过前面文章分析，我们知道 IoC 容器读入已经定位的 Bean 定义资源是从 refresh 方法开始的，我们首先从 AbstractApplicationContext 类的 refresh 方法入手分析，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940//容器初始化的过程，读入Bean定义资源，并解析注册 public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识 prepareRefresh(); //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); //为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try &#123; //为容器的某些子类指定特殊的BeanPost事件处理器 postProcessBeanFactory(beanFactory); //调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); //为BeanFactory注册BeanPost事件处理器. //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件 registerBeanPostProcessors(beanFactory); //初始化信息源，和国际化相关. initMessageSource(); //初始化容器事件传播器. initApplicationEventMulticaster(); //调用子类的某些特殊Bean初始化方法 onRefresh(); //为事件传播器注册事件监听器. registerListeners(); //这里是对容器lazy-init属性进行处理的入口方法 finishBeanFactoryInitialization(beanFactory); //初始化容器的生命周期事件处理器，并发布容器的生命周期事件 finishRefresh(); &#125; catch (BeansException ex) &#123; //销毁以创建的单态Bean destroyBeans(); //取消refresh操作，重置容器的同步标识. cancelRefresh(ex); throw ex; &#125; &#125; &#125; 在 refresh 方法中 ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory(); 启动了 Bean 定义资源的载入、注册过程，而 finishBeanFactoryInitialization 方法是对注册后的 Bean 定义中的预实例化 (lazy-init=false，Spring 默认就是预实例化，即为 true) 的 Bean 进行处理的地方。 (2).finishBeanFactoryInitialization 处理预实例化 Bean：当 Bean 定义资源被载入 IoC 容器之后，容器将 Bean 定义资源解析为容器内部的数据结构 BeanDefinition 注册到容器中，AbstractApplicationContext 类中的 finishBeanFactoryInitialization 方法对配置了预实例化属性的 Bean 进行预初始化过程，源码如下： 12345678910111213141516//对配置了lazy-init属性的Bean进行预实例化处理 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; //这是Spring3以后新加的代码，为容器指定一个转换服务(ConversionService) //在对某些Bean属性进行转换时使用 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; //为了类型匹配，停止使用临时的类加载器 beanFactory.setTempClassLoader(null); //缓存容器中所有注册的BeanDefinition元数据，以防被修改 beanFactory.freezeConfiguration(); //对配置了lazy-init属性的单态模式Bean进行预实例化处理 beanFactory.preInstantiateSingletons(); &#125; ConfigurableListableBeanFactory 是一个接口，其 preInstantiateSingletons 方法由其子类 DefaultListableBeanFactory 提供。 (3)、DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化：1234567891011121314151617181920212223242526272829303132333435363738394041424344//对配置lazy-init属性单态Bean的预实例化 public void preInstantiateSingletons() throws BeansException &#123; if (this.logger.isInfoEnabled()) &#123; this.logger.info("Pre-instantiating singletons in " + this); &#125; //在对配置lazy-init属性单态Bean的预实例化过程中，必须多线程同步，以确保数据一致性 synchronized (this.beanDefinitionMap) &#123; for (String beanName : this.beanDefinitionNames) &#123; //获取指定名称的Bean定义 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); //Bean不是抽象的，是单态模式的，且lazy-init属性配置为false if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; //如果指定名称的bean是创建容器的Bean if (isFactoryBean(beanName)) &#123; //FACTORY_BEAN_PREFIX=”&amp;”，当Bean名称前面加”&amp;”符号 //时，获取的是产生容器对象本身，而不是容器产生的Bean. //调用getBean方法，触发容器对Bean实例化和依赖注入过程 final FactoryBean factory = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName); //标识是否需要预实例化 boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; //一个匿名内部类 isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return ((SmartFactoryBean) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean) factory).isEagerInit(); &#125; if (isEagerInit) &#123; //调用getBean方法，触发容器对Bean实例化和依赖注入过程 getBean(beanName); &#125; &#125; else &#123; //调用getBean方法，触发容器对Bean实例化和依赖注入过程 getBean(beanName); &#125; &#125; &#125; &#125; &#125; 通过对 lazy-init 处理源码的分析，我们可以看出，如果设置了 lazy-init 属性，则容器在完成 Bean 定义的注册之后，会通过 getBean 方法，触发对指定 Bean 的初始化和依赖注入过程，这样当应用第一次向容器索取所需的 Bean 时，容器不再需要对 Bean 进行初始化和依赖注入，直接从已经完成实例化和依赖注入的 Bean 中取一个线程的 Bean，这样就提高了第一次获取 Bean 的性能。 3、FactoryBean 的实现：在 Spring 中，有两个很容易混淆的类：BeanFactory 和 FactoryBean。BeanFactory：Bean 工厂，是一个工厂 (Factory)，我们 Spring IoC 容器的最顶层接口就是这个 BeanFactory，它的作用是管理 Bean，即实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 FactoryBean：工厂 Bean，是一个 Bean，作用是产生其他 bean 实例。通常情况下，这种 bean 没有什么特别的要求，仅需要提供一个工厂方法，该方法用来返回其他 bean 实例。通常情况下，bean 无须自己实现工厂模式，Spring 容器担任工厂角色；但少数情况下，容器中的 bean 本身就是工厂，其作用是产生其它 bean 实例。 当用户使用容器本身时，可以使用转义字符”&amp;” 来得到 FactoryBean 本身，以区别通过 FactoryBean 产生的实例对象和 FactoryBean 对象本身。在 BeanFactory 中通过如下代码定义了该转义字符： StringFACTORY_BEAN_PREFIX = “&amp;”; 如果 myJndiObject 是一个 FactoryBean，则使用 &amp; myJndiObject 得到的是 myJndiObject 对象，而不是 myJndiObject 产生出来的对象。 FactoryBean 的源码如下： 12345678910//工厂Bean，用于产生其他对象 public interface FactoryBean&lt;T&gt; &#123; //获取容器管理的对象实例 T getObject() throws Exception; //获取Bean工厂创建的对象的类型 Class&lt;?&gt; getObjectType(); //Bean工厂创建的对象是否是单态模式，如果是单态模式，则整个容器中只有一个实例 //对象，每次请求都返回同一个实例对象 boolean isSingleton(); &#125; (1)DefaultListableBeanFactory的 getBean 方法调用 AbstractBeanFactory：在前面我们分析 Spring Ioc 容器实例化 Bean 并进行依赖注入过程的源码时，提到在 getBean 方法触发容器实例化 Bean 的时候会调用 AbstractBeanFactory 的 doGetBean 方法来进行实例化的过程，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方 @SuppressWarnings("unchecked") protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖 //如果指定的是别名，将别名转换为规范的Bean名称 final String beanName = transformedBeanName(name); Object bean; //先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整 //个IoC容器中只创建一次，不需要重复创建 Object sharedInstance = getSingleton(beanName); //IoC容器创建单态模式Bean实例对象 if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; //如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回 //已经创建的Bean if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference"); &#125; else &#123; logger.debug("Returning cached instance of singleton bean '" + beanName + "'"); &#125; &#125; //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; …… &#125; //获取给定Bean的实例对象，主要是完成FactoryBean的相关处理 protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123; //容器已经得到了Bean实例对象，这个实例对象可能是一个普通的Bean，也可能是 //一个工厂Bean，如果是一个工厂Bean，则使用它创建一个Bean实例对象，如果 //调用本身就想获得一个容器的引用，则指定返回这个工厂Bean实例对象 //如果指定的名称是容器的解引用(dereference，即是对象本身而非内存地址)， //且Bean实例也不是创建Bean实例对象的工厂Bean if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; //如果Bean实例不是工厂Bean，或者指定名称是容器的解引用，调用者向获取对 //容器的引用，则直接返回当前的Bean实例 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; //处理指定名称不是容器的解引用，或者根据名称获取的Bean实例对象是一个工厂Bean //使用工厂Bean创建一个Bean的实例对象 Object object = null; if (mbd == null) &#123; //从Bean工厂缓存中获取给定名称的Bean实例对象 object = getCachedObjectForFactoryBean(beanName); &#125; //让Bean工厂生产给定名称的Bean对象实例 if (object == null) &#123; FactoryBean factory = (FactoryBean) beanInstance; //如果从Bean工厂生产的Bean是单态模式的，则缓存 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; //从容器中获取指定名称的Bean定义，如果继承基类，则合并基类相关属性 mbd = getMergedLocalBeanDefinition(beanName); &#125; //如果从容器得到Bean定义信息，并且Bean定义信息不是虚构的，则让工厂 //Bean生产Bean实例对象 boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); //调用FactoryBeanRegistrySupport类的getObjectFromFactoryBean //方法，实现工厂Bean生产Bean对象实例的过程 object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object; &#125; 在上面获取给定 Bean 的实例对象的 getObjectForBeanInstance 方法中，会调用 FactoryBeanRegistrySupport 类的 getObjectFromFactoryBean 方法，该方法实现了 Bean 工厂生产 Bean 实例对象。 Dereference(解引用)：一个在 C/C++ 中应用比较多的术语，在 C++ 中，”*” 是解引用符号，而”&amp;” 是引用符号，解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址。 (2)AbstractBeanFactory 调用getObjectForBeanInstance 方法AbstractBeanFactory 类中生产 Bean 实例对象的主要源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//Bean工厂生产Bean实例对象 protected Object getObjectFromFactoryBean(FactoryBean factory, String beanName, boolean shouldPostProcess) &#123; //Bean工厂是单态模式，并且Bean工厂缓存中存在指定名称的Bean实例对象 if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123; //多线程同步，以防止数据不一致 synchronized (getSingletonMutex()) &#123; //直接从Bean工厂缓存中获取指定名称的Bean实例对象 Object object = this.factoryBeanObjectCache.get(beanName); //Bean工厂缓存中没有指定名称的实例对象，则生产该实例对象 if (object == null) &#123; //调用Bean工厂的getObject方法生产指定Bean的实例对象 object = doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess); //将生产的实例对象添加到Bean工厂缓存中 this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT)); &#125; return (object != NULL_OBJECT ? object : null); &#125; &#125; //调用Bean工厂的getObject方法生产指定Bean的实例对象 else &#123; return doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess); &#125; &#125; //调用Bean工厂的getObject方法生产指定Bean的实例对象 private Object doGetObjectFromFactoryBean( final FactoryBean factory, final String beanName, final boolean shouldPostProcess) throws BeanCreationException &#123; Object object; try &#123; if (System.getSecurityManager() != null) &#123; AccessControlContext acc = getAccessControlContext(); try &#123; //实现PrivilegedExceptionAction接口的匿名内置类 //根据JVM检查权限，然后决定BeanFactory创建实例对象 object = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; public Object run() throws Exception &#123; //调用BeanFactory接口实现类的创建对象方法 return factory.getObject(); &#125; &#125;, acc); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; //调用BeanFactory接口实现类的创建对象方法 object = factory.getObject(); &#125; &#125; catch (FactoryBeanNotInitializedException ex) &#123; throw new BeanCurrentlyInCreationException(beanName, ex.toString()); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, "FactoryBean threw exception on object creation", ex); &#125; //创建出来的实例对象为null，或者因为单态对象正在创建而返回null if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException( beanName, "FactoryBean which is currently in creation returned null from getObject"); &#125; //为创建出来的Bean实例对象添加BeanPostProcessor后置处理器 if (object != null &amp;&amp; shouldPostProcess) &#123; try &#123; object = postProcessObjectFromFactoryBean(object, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, "Post-processing of the FactoryBean's object failed", ex); &#125; &#125; return object; &#125; 从上面的源码分析中，我们可以看出，BeanFactory 接口调用其实现类的 getObject 方法来实现创建 Bean 实例对象的功能。 (3)、FactoryBeanRegistrySupport 生产 Bean 实例对象：FactoryBean 的实现类有非常多，比如：Proxy、RMI、JNDI、ServletContextFactoryBean 等等，FactoryBean 接口为 Spring 容器提供了一个很好的封装机制，具体的 getObject 有不同的实现类根据不同的实现策略来具体提供，我们分析一个最简单的 AnnotationTestFactoryBean 的实现源码： 12345678910111213141516public class AnnotationTestBeanFactory implements FactoryBean&lt;IJmxTestBean&gt; &#123; private final FactoryCreatedAnnotationTestBean instance = new FactoryCreatedAnnotationTestBean(); public AnnotationTestBeanFactory() &#123; this.instance.setName("FACTORY"); &#125; //AnnotationTestBeanFactory产生Bean实例对象的实现 public IJmxTestBean getObject() throws Exception &#123; return this.instance; &#125; public Class&lt;? extends IJmxTestBean&gt; getObjectType() &#123; return FactoryCreatedAnnotationTestBean.class; &#125; public boolean isSingleton() &#123; return true; &#125; &#125; 其他的 Proxy，RMI，JNDI 等等，都是根据相应的策略提供 getObject 的实现。这里不做一一分析，这已经不是 Spring 的核心功能，有需要的时候再去深入研究。 4.BeanPostProcessor 后置处理器的实现：BeanPostProcessor 后置处理器是 Spring IoC 容器经常使用到的一个特性，这个 Bean 后置处理器是一个监听器，可以监听容器触发的 Bean 声明周期事件。后置处理器向容器注册以后，容器中管理的 Bean 就具备了接收 IoC 容器事件回调的能力。 BeanPostProcessor 的使用非常简单，只需要提供一个实现接口 BeanPostProcessor 的实现类，然后在 Bean 的配置文件中设置即可。 BeanPostProcessor 的源码如下： 12345678package org.springframework.beans.factory.config; import org.springframework.beans.BeansException; public interface BeanPostProcessor &#123; //为在Bean的初始化前提供回调入口 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; //为在Bean的初始化之后提供回调入口 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; &#125; 这两个回调的入口都是和容器管理的 Bean 的生命周期事件紧密相关，可以为用户提供在 Spring IoC 容器初始化 Bean 过程中自定义的处理操作。 (1)AbstractAutowireCapableBeanFactory 的doCreateBean真正实现创建 Bean 对象并进行依赖注入：BeanPostProcessor 后置处理器的调用发生在 Spring IoC 容器完成对 Bean 实例对象的创建和属性的依赖注入完成之后，在对 Spring 依赖注入的源码分析过程中我们知道，当应用程序第一次调用 getBean 方法 (lazy-init 预实例化除外) 向 Spring IoC 容器索取指定 Bean 时触发 Spring IoC 容器创建 Bean 实例对象并进行依赖注入的过程，其中真正实现创建 Bean 对象并进行依赖注入的方法是 AbstractAutowireCapableBeanFactory 类的 doCreateBean 方法，主要源码如下： 123456789101112131415161718192021//真正创建Bean的方法 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; //创建Bean实例对象 …… try &#123; //对Bean属性进行依赖注入 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; //在对Bean实例对象生成和依赖注入完成以后，开始对Bean实例对象 //进行初始化 ，为Bean实例对象应用BeanPostProcessor后置处理器 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; …… //为应用返回所需要的实例对象 return exposedObject; &#125; 从上面的代码中我们知道，为 Bean 实例对象添加 BeanPostProcessor 后置处理器的入口的是 initializeBean 方法。 (2)AbstractAutowireCapableBeanFactory.initializeBean 方法为容器产生的 Bean 实例对象添加 BeanPostProcessor 后置处理器：同样在 AbstractAutowireCapableBeanFactory 类中，initializeBean 方法实现为容器创建的 Bean 实例对象添加 BeanPostProcessor 后置处理器，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//初始容器创建的Bean实例对象，为其添加BeanPostProcessor后置处理器 protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; //JDK的安全机制验证权限 if (System.getSecurityManager() != null) &#123; //实现PrivilegedAction接口的匿名内部类 AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; //为Bean实例对象包装相关属性，如名称，类加载器，所属容器等信息 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; //对BeanPostProcessor后置处理器的postProcessBeforeInitialization //回调方法的调用，为Bean实例初始化前做一些处理 if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; //调用Bean实例对象初始化的方法，这个初始化方法是在Spring Bean定义配置 //文件中通过init-method属性指定的 try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; //对BeanPostProcessor后置处理器的postProcessAfterInitialization //回调方法的调用，为Bean实例初始化之后做一些处理 if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; //调用BeanPostProcessor后置处理器实例对象初始化之前的处理方法 public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; //遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; //调用Bean实例所有的后置处理中的初始化前处理方法，为Bean实例对象在 //初始化之前做一些自定义的处理操作 result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result; &#125; //调用BeanPostProcessor后置处理器实例对象初始化之后的处理方法 public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; //遍历容器为所创建的Bean添加的所有BeanPostProcessor后置处理器 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; //调用Bean实例所有的后置处理中的初始化后处理方法，为Bean实例对象在 //初始化之后做一些自定义的处理操作 result = beanProcessor.postProcessAfterInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result; &#125; BeanPostProcessor 是一个接口，其初始化前的操作方法和初始化后的操作方法均委托其实现子类来实现，在 Spring 中，BeanPostProcessor 的实现子类非常的多，分别完成不同的操作，如：AOP 面向切面编程的注册通知适配器、Bean 对象的数据校验、Bean 继承属性 / 方法的合并等等，我们以最简单的 AOP 切面织入来简单了解其主要的功能。 (3)AdvisorAdapterRegistrationManager 在 Bean 对象初始化后注册通知适配器：AdvisorAdapterRegistrationManager 是 BeanPostProcessor 的一个实现类，其主要的作用为容器中管理的 Bean 注册一个面向切面编程的通知适配器，以便在 Spring 容器为所管理的 Bean 进行面向切面编程时提供方便，其源码如下： 123456789101112131415161718192021//为容器中管理的Bean注册一个面向切面编程的通知适配器 public class AdvisorAdapterRegistrationManager implements BeanPostProcessor &#123; //容器中负责管理切面通知适配器注册的对象 private AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance(); public void setAdvisorAdapterRegistry(AdvisorAdapterRegistry advisorAdapterRegistry) &#123; this.advisorAdapterRegistry = advisorAdapterRegistry; &#125; //BeanPostProcessor在Bean对象初始化前的操作 public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //没有做任何操作，直接返回容器创建的Bean对象 return bean; &#125; //BeanPostProcessor在Bean对象初始化后的操作 public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof AdvisorAdapter)&#123; //如果容器创建的Bean实例对象是一个切面通知适配器，则向容器的注册 this.advisorAdapterRegistry.registerAdvisorAdapter((AdvisorAdapter) bean); &#125; return bean; &#125; &#125; 其他的 BeanPostProcessor 接口实现类的也类似，都是对 Bean 对象使用到的一些特性进行处理，或者向 IoC 容器中注册，为创建的 Bean 实例对象做一些自定义的功能增加，这些操作是容器初始化 Bean 时自动触发的，不需要认为的干预。 5.Spring IoC 容器 autowiring 实现原理：Spring IoC 容器提供了两种管理 Bean 依赖关系的方式： a. 显式管理：通过 BeanDefinition 的属性值和构造方法实现 Bean 依赖关系管理。 b． autowiring：Spring IoC 容器的依赖自动装配功能，不需要对 Bean 属性的依赖关系做显式的声明，只需要在配置好 autowiring 属性，IoC 容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动匹配容器中管理的 Bean，从而自动地完成依赖注入。 通过对 autowiring 自动装配特性的理解，我们知道容器对 Bean 的自动装配发生在容器对 Bean 依赖注入的过程中。在前面对 Spring IoC 容器的依赖注入过程源码分析中，我们已经知道了容器对 Bean 实例对象的属性注入的处理发生在 AbstractAutoWireCapableBeanFactory 类中的 populateBean 方法中，我们通过程序流程分析 autowiring 的实现原理： (1). AbstractAutoWireCapableBeanFactory的populateBean方法 对 Bean 实例进行属性依赖注入：应用第一次通过 getBean 方法 (配置了 lazy-init 预实例化属性的除外) 向 IoC 容器索取 Bean 时，容器创建 Bean 实例对象，并且对 Bean 实例对象进行属性依赖注入，AbstractAutoWireCapableBeanFactory 的 populateBean 方法就是实现 Bean 属性依赖注入的功能，其主要源码如下： 1234567891011121314151617181920protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) &#123; //获取Bean定义的属性值，并对属性值进行处理 PropertyValues pvs = mbd.getPropertyValues(); …… //对依赖注入处理，首先处理autowiring自动装配的依赖注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); //根据Bean名称进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; //根据Bean类型进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; &#125; //对非autowiring的属性进行依赖注入处理 …… &#125; (2).AbstractAutoWireCapableBeanFactory的autowireByName方法 对 Bean 实例进行属性依赖注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//根据名称对属性进行自动依赖注入 protected void autowireByName( String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123; //对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符串，URL等//都是简单属性)进行处理 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw); for (String propertyName : propertyNames) &#123; //如果Spring IoC容器中包含指定名称的Bean if (containsBean(propertyName)) &#123; //调用getBean方法向IoC容器索取指定名称的Bean实例，迭代触发属性的//初始化和依赖注入 Object bean = getBean(propertyName); //为指定名称的属性赋予属性值 pvs.add(propertyName, bean); //指定名称属性注册依赖Bean名称，进行属性依赖注入 registerDependentBean(propertyName, beanName); if (logger.isDebugEnabled()) &#123; logger.debug("Added autowiring by name from bean name '" + beanName + "' via property '" + propertyName + "' to bean named '" + propertyName + "'"); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace("Not autowiring property '" + propertyName + "' of bean '" + beanName + "' by name: no matching bean found"); &#125; &#125; &#125; &#125; //根据类型对属性进行自动依赖注入 protected void autowireByType( String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123; //获取用户定义的类型转换器 TypeConverter converter = getCustomTypeConverter(); if (converter == null) &#123; converter = bw; &#125; //存放解析的要注入的属性 Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;String&gt;(4); //对Bean对象中非简单属性(不是简单继承的对象，如8中原始类型，字符 //URL等都是简单属性)进行处理 String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw); for (String propertyName : propertyNames) &#123; try &#123; //获取指定属性名称的属性描述器 PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName); //不对Object类型的属性进行autowiring自动依赖注入 if (!Object.class.equals(pd.getPropertyType())) &#123; //获取属性的setter方法 MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd); //检查指定类型是否可以被转换为目标对象的类型 boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass()); //创建一个要被注入的依赖描述 DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager); //根据容器的Bean定义解析依赖关系，返回所有要被注入的Bean对象 Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter); if (autowiredArgument != null) &#123; //为属性赋值所引用的对象 pvs.add(propertyName, autowiredArgument); &#125; for (String autowiredBeanName : autowiredBeanNames) &#123; //指定名称属性注册依赖Bean名称，进行属性依赖注入 registerDependentBean(autowiredBeanName, beanName); if (logger.isDebugEnabled()) &#123; logger.debug("Autowiring by type from bean name '" + beanName + "' via property '" + propertyName + "' to bean named '" + autowiredBeanName + "'"); &#125; &#125; //释放已自动注入的属性 autowiredBeanNames.clear(); &#125; &#125; catch (BeansException ex) &#123; throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex); &#125; &#125; &#125; 通过上面的源码分析，我们可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依赖注入要稍微简单一些，但是真正实现属性注入的是 DefaultSingletonBeanRegistry 类的 registerDependentBean 方法。 (3).DefaultSingletonBeanRegistry 的 registerDependentBean 方法对属性注入：12345678910111213141516171819202122232425262728293031//为指定的Bean注入依赖的Bean public void registerDependentBean(String beanName, String dependentBeanName) &#123; //处理Bean名称，将别名转换为规范的Bean名称 String canonicalName = canonicalName(beanName); //多线程同步，保证容器内数据的一致性 //先从容器中：bean名称--&gt;全部依赖Bean名称集合找查找给定名称Bean的依赖Bean synchronized (this.dependentBeanMap) &#123; //获取给定名称Bean的所有依赖Bean名称 Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName); if (dependentBeans == null) &#123; //为Bean设置依赖Bean信息 dependentBeans = new LinkedHashSet&lt;String&gt;(8); this.dependentBeanMap.put(canonicalName, dependentBeans); &#125; //向容器中：bean名称--&gt;全部依赖Bean名称集合添加Bean的依赖信息 //即，将Bean所依赖的Bean添加到容器的集合中 dependentBeans.add(dependentBeanName); &#125; //从容器中：bean名称--&gt;指定名称Bean的依赖Bean集合找查找给定名称 //Bean的依赖Bean synchronized (this.dependenciesForBeanMap) &#123; Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName); if (dependenciesForBean == null) &#123; dependenciesForBean = new LinkedHashSet&lt;String&gt;(8); this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean); &#125; //向容器中：bean名称--&gt;指定Bean的依赖Bean名称集合添加Bean的依赖信息 //即，将Bean所依赖的Bean添加到容器的集合中 dependenciesForBean.add(canonicalName); &#125; &#125; 通过对 autowiring 的源码分析，我们可以看出，autowiring 的实现过程： a. 对 Bean 的属性迭代调用 getBean 方法，完成依赖 Bean 的初始化和依赖注入。 b. 将依赖 Bean 的属性引用设置到被依赖的 Bean 属性上。 c. 将依赖 Bean 的名称和被依赖 Bean 的名称存储在 IoC 容器的集合中。 Spring IoC 容器的 autowiring 属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但是凡是都有两面性，自动属性依赖注入也有不足，首先，Bean 的依赖关系在配置文件中无法很清楚地看出来，对于维护造成一定困难。其次，由于自动依赖注入是 Spring 容器自动执行的，容器是不会智能判断的，如果配置不当，将会带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑。 参考：《Spring 技术内幕》Spring：源码解读Spring IOC原理 - ^TONY^ - 博客园https://www.cnblogs.com/ITtangtang/p/3978349.html#a4]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 源码学习流程]]></title>
    <url>%2F2018%2F04%2F02%2F2018-04-02-1%2F</url>
    <content type="text"><![CDATA[要想快速了解一门技术的大概，先看官方文档： spring4的文档： Introduction · Spring Framework 4.x参考文档http://blog.didispace.com/books/spring-framework-4-reference/guoxiaoxu/SpringInActionPractice: Spring实战练习coding和笔记https://github.com/guoxiaoxu/SpringInActionPractice 看系列文章，从设计模式入手，从整体到局部，一点点剥离Spring的源码 知秋z - 知乎https://www.zhihu.com/people/zhi-qiu-z/posts?page=2spring 源码 - 搜索 - 掘金https://juejin.im/search?query=spring%20%E6%BA%90%E7%A0%81Spring思维导图，让spring不再难懂（一） - java思维导图https://my.oschina.net/u/3080373/blog/891918Spring思维导图，让Spring不再难懂（ioc篇） - java思维导图https://my.oschina.net/u/3080373/blog/903341Spring思维导图，让Spring不再难懂（aop篇） - java思维导图https://my.oschina.net/u/3080373/blog/1503693Spring思维导图，让Spring不再难懂（mvc篇） - java思维导图https://my.oschina.net/u/3080373/blog/1438733 查看相关源码的书籍，大致了解spring的架构 Spring实战（第4版） (豆瓣)https://book.douban.com/subject/26767354/精通Spring 4.x (豆瓣)https://book.douban.com/subject/26952826/Spring源码深度解析 (豆瓣)https://book.douban.com/subject/25866350/Spring技术内幕（第2版） (豆瓣)https://book.douban.com/subject/10470970/架构探险――从零开始写Java Web框架 (豆瓣)https://book.douban.com/subject/26593466/优秀的博客：Spring 源码分析(一) —— 迈向Spring之路 - 水门-kay的个人页面https://my.oschina.net/kaywu123/blog/610825spring源码学习笔记 - CSDN博客https://blog.csdn.net/chengzhezhijian/article/details/16982243 调试源码:IOC和AOP 一、找到spring容器初始化的入口：二、然后在了解Spring的主要功能IOC和AOP的实现三、然后在一个一个组件进行了解。 边看边画类图和时序图，还有写笔记记录一些核心类的作用，第二遍就清晰多了。 Spring源码解析——如何阅读源码 - xingoo - 博客园http://www.cnblogs.com/xing901022/p/4178963.htmlSpring的精简版.https://github.com/code4craft/tiny-springwenbo2018/mini-springframework: 一个mini Spring IOC实现https://github.com/wenbo2018/mini-springframework 找一个感兴趣的模块，查明白这个模块是什么作用 然后导入工程，编译不报错后，一个一个调试testcase. 基本就能把实现原理搞明白了。比读读码效率高。 写一个精简版的该框架 参考：]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能mysql 学习]]></title>
    <url>%2F2018%2F04%2F02%2F2018-04-02%2F</url>
    <content type="text"><![CDATA[参考：]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式 学习]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-13%2F</url>
    <content type="text"><![CDATA[专栏：设计模式 - CSDN博客https://blog.csdn.net/column/details/pattern.html 参考：【框架设计】—设计模式 - 随笔分类 - chenssy - 博客园http://www.cnblogs.com/chenssy/category/482229.html]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 总结]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-12%2F</url>
    <content type="text"><![CDATA[通过对软工视频的学习，已了解软工视频大致是在为写文档做预习，一个软件工程必不可少的一部分就是文档的编辑，文档亦难亦不难。不难在我们都能理解每一份文档，并且知道每份文档主要内容有什么，而难亦在怎么将文档的主要内容写出来，用什么表示主要内容，可以让读者更清晰的了解你需要表达什么内容。 通过一次文档的验收，暴露了我们很多问题，即使写的再详细，由于我们缺少经验，总是或多或少的存在某些问题。 比如，对于可行性研究报告主要给要看这份文档的人指出项目开发的实际效益，主要从技术与经济方面，而我的文档中掺杂着一些详细到具体功能的描述，这个是需求或者详细设计文档中的内容，从而使可行性研究报告过于赘余，其他文档也都存在这样的一些问题。 下面我来好好的总结下每份文档中都主要该有什么内容吧。 1. 对于可行性研究报告简单说来就是个老板看的，要让老板看到有利益，才会同意开发这个项目，说白了就是别人投资需要让人看到未来。所以，要对与能创造利益有关的一切因素谈起。这需要从经济、技术、生产、供销直到社会各种环境、法律等各种因素进行具体调查、研究、分析，确定有利和不利的因素、项目是否可行，估计成功率大小、经济效益和社会效果程度，从而为决策者和主管机关同意开发项目提供依据。 2. 项目开发计划是创建一个项目开发过程的总体计划，为项目负责人提供一个框架，使之能合理地估算软件项目开发所需的资源、经费和开发进度，并为项目配置提供信息辅助，也控制软件项目开发过程按此计划进行。在项目开发计划书中，最主要的是必须要有相关表示项目计划的图例（主要有甘特图、工程网络图、时标网络图），以便项目负责人能把控项目进度，了解什么时间段做好什么工作。 3. 软件需求说明书通俗一点，就是指出软件有什么优点（或功能），此优点（或功能）是用户与开发人员都认可的。官方定义是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。包含硬件、功能、性能、输入输出、接口界面、警示信息、保密安全、数据与数据库、文档和法规的要求。实际上，对于需求，达到用户需求的才可以，因而要从输入 / 输出和它们的关系入手，也方便软件开发人员了解需要什么功能的编程。对于功能，没有什么比让用户看到一个系统功能的模型图更有效的了，于是就用到了用例图或者原型图。 用例图是静态的系统模型，如 原型图（原型设计）就如一个完整的系统，应有的功能都可以操作，就像一个实际系统的虚拟（动态）模型 输入 / 输出即可用 IPO 图表示： 而他们之间的具体关系，可以用 ER 图表示： 4. 概要设计说明书简单点就是指模块之间及模块内大功能的说明，详细的要说明对程序 系统的设计考虑，包括程序系统的基本处理流程、程序系统的组织结构、模块划分、功能分配、接口设计、运行设计、数据结构设计和出错处理设计等，为程序的详细设计提供基础。本文档中需要有类图、界面、原型图（也与功能的实现有关）。 5. 详细设计说明书是概要设计说明书的细致化，将各个功能都详细的设计出来，方便编程人员更好地编程出符合需求的程序。本文档描述的是关于项目最基层的工作内容，只根据概要设计说明书设计，只说明程序设计，而其他可以不编写。本文档需要包括构架图、类图、时序图、及定义代码规范等内容。 6. 数据库设计说明书指所见项目需要创建什么样的数据库，数据库表结构的设计、字段详细说明、视图说明，及其相对应的 SQL 语句说明。通俗一点，就是数据库的设计规范。 7. 测试计划就是对编程好的软件进行测试。测试计划需要包括测试用例（从输入 / 输出举例说明），测试方法有黑 / 白盒测试法等，禁忌最好不要测试人员和开发人员同一人。 测试计划编写的六要素： 1）why——为什么要进行这些测试； 2) what—测试哪些方面，不同阶段的工作内容； 3) when——测试不同阶段的起止时间； 4) where——相应文档，缺陷的存放位置，测试环境等； 5) who——项目有关人员组成，安排哪些测试人员进行测试； 6) how——如何去做，使用哪些测试工具以及测试方法进行测试。 8. 测试分析报告就是将测试结果记录下来，并通过专业人士的分析（即评估），然后整合起来交给。 9. 质量保证计划书指在整个工程执行过程中，如何保证工程的质量满足合同和标书规定的有关质量保证方面的文件，包括设计、生产、施工、培训等过程中的质量保证，每项内容的质量保证措施，如何设立质量控制点，如何进行质量控制的操作等。 质量保证计划应包含编制依据、适用范围和时限、管理职责、合同评审、文件和资料控制、采购控制、施工过程控制、检验和试验、工程项目的不合格品控制和预防纠正措施、物资搬运和储存管理、标识与可追溯性、用工制度与培训、质量记录和记录表格以及质量计划的修订等内容。说得简单些，质量保证计划就是监督和控制影响软件开发质量有关的因素。 10. 操作手册了解操作手册需要了解操作的含义。操作指人活动的一种行为，是一种技能。操作也是按照一定的规范和要领操纵动作，故而操作手册就是指对软件可以按照一定规范和要领进行操作。所以，这一文档需要编写的就是对软件操作的规范。 11. 用户使用手册同上，需要了解使用的含义。使用即利用某种工具而实现某个目的。故而用户使用手册就是利用软件得到结果。这部分主要是描述怎么利用该软件达到目的，即了解软件的功能。 用户使用手册与操作手册的区别之一就是用户使用手册有 “帮助” 的内容。 12. 项目开发进度月报主要记录实际每月工作进度，用表格形式记录下来，以便相关人员可以调控项目开发进度，从而实现资源的合理利用。 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 笔记八:相关文档]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-11%2F</url>
    <content type="text"><![CDATA[经过长达 10 天左右的时间，软件工程文档基本完成，只差师傅验收了，虽然这个期间，一直都是借鉴的好多人的文档以及从网上找对各个文档的相关理解，但终究还是有自己的收获的。 说起来感觉比较羡慕的是，在网上查相关文档的时候，第一条永远都是那一个人的。感觉被所有人承认，那肯定非常的了不起。 软件工程是一个整体的，组织全面的工程，需要有配套的完整方案实行，这就需要文档来解决。 文档，就是在软件工程开发过程中每个阶段需要的实行依据。比如建立初期，需要有研究报告；开发时需要开发计划；设计中需要有软件需求、详细设计、数据库设计说明书等相关文档；而在设计完成后，就需要测试了，测试之前要有测试计划，测试过程中需要有测试记录，测试完成也要有测试分析报告；项目研究成功，可以投入使用时，也要有总结报告、操作手册和用户手册；还有一个就是在各个阶段都需要有的开发进度月报（或者周报也可以）。 文档，不仅仅提供的是软件工程开发依据，还是以后修改和维护的重要依据，也是文档初级编写者学习的依据。随着每次写文档，看着以前的文档都会有不同的感受，感觉这里不好，可以修改，感觉那里不好，也可以修改，久而久之，文档会写的越来越好。 下面就介绍各个文档的主要内容： 1. 可行性研究报告 目的是在某个方面的进步性；评述为了合理地达到开发目标而可能选择的各种方案等等。 在开始一个项目时，需要完成可行性研究报告，研究此开发项目是否能够完成，解理由。例如分析软件的投资和收益可行性、技术可行性、人员可行性、其他影响，开发软件的要求等等。 2. 项目开发计划 主要是为了给开发项目做整体的规划，在开发过程中起引导作用，并给项目开发和设计者提供简单说明，例如项目概述、实施计划、支持条件和专题计划（如分合同计划、开发人员培训计划、测试计划、安全保密计划、质量保证计划、配置管理计划、用户培训计划、系统安装计划等）要点 项目开发计划是为项目组长查看，此项目的开发计划以及多长时间可以完成，是查工作进度最直接的证据。 3. 软件需求说明书 本文档的目的：就是对软件应该具备什么功能、性能和运行环境的规定 1. 方便用户、分析人员和软件设计人员进行理解和交流。用户通过需求规格说明书在分析阶段即可初步判定目标软件能否满足其原来的期望，但是本文档主要是作为设计人员的软件开发的基本出发点和系统维护人员发现和添加新功能需求的基础，也是维护人员的技术支持文档之一。 2. 支持目标系统的确认。软件开发目标是否完成不应由系统测试阶段的人为因素决定，而应根据需求规格说明书确立的可测试标准决定。 3. 控制系统进化过程。在需求分析完成后，如果用户追加需求，那么需求规格说明书将用于确定追加需求是否为新需求。如果是，开发人员必须针对新需求进行需求分析，扩充需求规格说明书，进行软件再设计。 4. 详细设计说明书 本文档的编写为了系统软件的开发途径和应用方法，以求开发者在最短的时间高效的开发并完成该系统。对项目所有程序分别进行详细的设计，如功能、性能、输入和输出、算法、流程、接口、存储、限制、测试、问题等的设计说明。 5. 数据库设计说明书 软件工程一般离不开数据，因而数据库的设计也很有必要。而本文档就是对描述数据库设计、结构情况，用于开发人员进行项目设计，同时也为后续的数据库维护工作提供了良好的使用说明。 6. 测试计划 根据测试计划报告，对软件进行测试，详细记录测试过程，以对软件的食量进行评价，对软件设计人员提供错误依据。 测试计划是在项目开发的过程中制定的，为测试提供各种测试方案，可以方便更加查找项目中的错误问题。 测试计划需要对分别对某项程序或功能做详细计划。 7. 测试分析报告 根据测试计划进行各种测试，记录测试结果，并详细的将测试结果详细的解释清楚。 8. 项目开发总结报告 为了总结本项目开发工作的经验，说明实际取得的开发结果以及对整个开发工作的各个方面的评价，说明本项目的工作流程，工程开发中状况，最终结果，经验教训等。 9. 操作手册和用户手册 目的是为了给用户提供帮助，对于没有接触过本系统的用户能够学会使用本系统。通过本文档，能够让用户熟练使用本系统。就像平常生活中的各种说明书，虽然我们没哟接触过某一个商品，但是通过使用说明书可以在最短的时间内掌握，并灵活运用。 10. 开发进度月报 为项目组长掌握开发进度提供最可靠的依据，可以督促和监督项目进度，以便可以高效的完成软件的开发，并为项目的开发总结报告提供各项依据。 曾看多过这样一句话 “软件工程是编程的基础，文档就是程序员的助手，文档至关重要。” 做好文档，我们可以高效率地完成某个软件工程，也可以有更充足的时间学习其他知识或休息。 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 笔记七:项目管理]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-10%2F</url>
    <content type="text"><![CDATA[软件工程中必须有的一项就是项目，故而项目管理也是必要的。软件项目分为项目管理过程、软件生产率和质量的度量、软件项目的估算、软件项目计划的目标、软件开发成本估算。 软件项目管理过程，又称项目管理流程，IT 行业的项目管理流程一般包括五部分：项目的启动、项目的计划、项目的实施及控制过程、项目的收尾和项目的后续维护。 项目管理的对象是软件过程项目，关键问题是必须对软件开发项目的工作范围、科可能风险、需要资源（人、硬件 / 软件）、要实现的任务、经理的里程碑、花费工作量（成本）、进度安排等做到心中有数。 项目启动：在制定软件项目计划之前，必须要明确项目的目标和范围，考虑候选的解决方案，标明技术和管理上的要求。 在项目启动过程中，需要对以下内容做了解： 度量：对项目本身做度量，作用是为了了解产品开发的技术过程和产品本身，为了有效地定量地进行管理。 估算：关键活动是制定项目计划，必须就需要的人力（以人月为单位）、项目持续时间（以年份或月份为单位）、成本（以元为单位）做出估算 风险分析：对于软件项目管理是决定性的因素，现今很多项目不考虑风险就着手进行。风险分析实际上是一系列风险管理步骤，其中包括风险识别、估计、优化、管理策略、解决和监督。 进度安排：启动项目时就要考虑一个合理的进度安排，需要考虑预先对进度如何计划、工作怎样就位、如何识别定义好的任务等问题，并设计好验收标准。 追踪和控制：就是跟随项目进度，监督和控制项目。这不仅可以对资源定位，还可以对任务重新安排，修改交付日期以调整已经暴露的问题等等。 项目计划：是项目实施的基础。通过所有项目干系人认可的项目计划形成文件，便于本企业高层领导、相关管理部门领导、相关参与部门领导、项目组成员、客户、协作单位、分包单位等所有项目干系人之间的交流沟通。项目计划是项目组为实现项目目标而科学地预测并确定项目生命周期的行动方案。任何项目计划都是为了解决 3 个问题： ① 确定项目目标； ② 确定为了达成项目目标的各项行动的顺序和时间； ③ 确定项目中每项行动所需要的资源。 项目计划的目标： (1) 项目计划的第一个目标：建立估计值，即建立和维护项目计划因素的估计值。为此应该确定项目范围，即通过建立高层工作分解结构来估计项目范围；监理工作产品和任务属性的规模与复杂度；确定项目的生命周期阶段，以此来限定计划范围；基于估算的原理进行对工作产品和任务的项目工作量和成本的估算。 (2) 项目计划的第二个目标：开发项目计划文档，即文档化项目计划、维护项目计划，并以此作为项目管理的基线。为此应该建立和维护项目的预算和进度表；要识别和分析项目风险；确定如何采集和管理项目数据；确定实施计划所需要的各种资源；确定项目实施所必需的知识和技能；确定各项任务或活动的承担人；编写项目计划文档。 (3) 项目计划的第三个目标：获得并维持所有项目干系人对项目的承诺。为此应当评审影响项目的所有计划，使所有项目干系人理解项目承诺；必要时调整项目计划以适应有效的和已经估计的资源；获取所有项目干系人特别是项目任务或活动的承担人对项目计划的承诺。 项目实施与控制：必须按照计划阶段定制的计划采取必要的活动，来完成计划阶段定制的任务。 项目收尾：即一个项目研发过程完成，并且所有可交付成果的完成，如项目各阶段产生的文档、项目管理过程中的文档、与项目有关的各种记录等。在项目的收尾阶段中的主要活动是，整理所有产生出的文档提交给项目建设单位。收尾阶段的结束标志是《项目总结报告》，收尾阶段完成后项目将进入维护期。 项目维护：在项目收尾阶段结束后，项目将进入到后续的维护期。项目的后续维护期的工作，将是保证信息技术能够为企业中的重要业务提供服务的基础，也是使项目产生效益的阶段。在项目的维护期内，整个项目的产品都在运转，特别是时间较长后，系统中的软件或硬件有可能出现损坏，这时需要维护期的工程师对系统进行正常的日常维护。维护期的工作是长久的，他将一直持续到整个这个项目的结束。也就是说，什么时候本项目的硬件及其上运行的系统退出，那时将是项目后续的维护期的结止日。 软件生产率和质量的度量：是以投入工作量为依据的软件开发活动的度量和开发成果质量的度量。内容包含对软件进行度量的原因、面向规模的度量、面向功能的度量、软件质量的度量和在软件工程过程中使用度量。 对软件进行度量： 1. 标明软件产品的质量； 2. 弄清楚软件开发人员的生产率； 3. 给出使用了新的软件过程方法和工具所得到的效益 4. 建立项目估算的 “基线”； 5. 帮助调整对新的工具和附加培训的要求 度量方式有物理度量和软件度量。因此度量域可以分为： 面向规模的度量：是对软件开发过程的直接度量，建立一个面向规模的数据表格记录项目信息。 面向规模的度量的缺点：源程序仅仅是软件配置的一部分，相差还是较大的，不适用于非过程语言的度量 面向功能的度量 是对软件和软件开发过程的间接度量 主要考虑程序的 “功能性” 和“实用性”，而不是对 LOC 技术（FP：功能点） 面向功能的数据表格： 功能点的计算： 确定五个信息域的特征，并各处相应计数：用户输入数、用户输出数、用户查询数、文件数和外部接口数。 收集到数据，可计算与每一个计数相关的复杂性值 计算功能点：FP = 总计数 （0.65+0.01 SUM（Fi）） 计算数是所有加权计数项的和 复杂性校正值 Fi： 系统是否需要可靠的备份和恢复？ 是否需要数据通信？ 是否有分布处理的功能？ 是否性能成为关键？ 系统是否运行在既存的高度实用化的操作环境中？ 系统是否需要联机数据项？ 联机数据项是否需要建立多重窗口显示和操作，以处理输入处理。 主文件是否联机更新？ 输入、输出、文件、查询时候复杂？ 内部处理过程是否复杂？ 程序代码是否可复用？ 设计中是否包括了转移和安装？ 系统是否设计成可以重复安装在不同机构中？ 系统是否设计成易修改和易使用？ 软件质量的度量：贯穿软件工程的全过程中及软件交付用户使用之后；交付之前的度量可作为判断设计和测试质量好坏的依据；交付之后的度量则把注意力集中于还未发现的错差数和系统可维护性方面；使用得最广泛软件质量的事后度量包括正确性、可维护性、完整性和可使用性。 正确性是指一个程序必须正确地运行，并为它的用户提供某些输出，要求软件执行所要求的功能。 可维护性即软件可以维护，而软件没有一种方法可以直接度量，必须采取简介度量。 完整性度量一个系统抗拒对它的安全性攻击（事故的和人为的）的能力。 可使用性：如果一个程序不具有 “用户友好性”，即使它所执行的功能很有价值，也常常会失败。 项目估算： 对完成该软件项目所需的资源进行估算 每一种资源，一般都应说明四个特性： 1. 资源的描述； 2. 资源的有效性说明； 3. 资源在何时开始需要； 4. 使用资源的持续时间。 例如人力资源： 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 笔记六:软件工程管理]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-9%2F</url>
    <content type="text"><![CDATA[一个好的工程需要配套的管理体系，软件工程也不列外。软件工程就我的理解就是对软件工程的各个阶段都一定规范，俗话说 “不以规矩，不能成方圆”，而这个规矩就由管理来充当。一个软件工程管理需要软件项目计划、成本估算、进度计划、风险分析和人员的组织形式（或调动）。 一、在软件项目计划中，项目的任务是研究项目的性能、功能及系统界面，和估算经费、进度和资源，一般情况下，估算允许有误差，在 10%~20% 之内。有了目标，就要有实际行动，而实际行动不是盲目的，需要有合理的计划安排，这包括范围、资源（人力、硬件、软件）、进度、成本估算和培训计划等内容。计划的内容调整，需要根据项目的类型做出，而项目的分类根据下图划分： 二、对于成本的估算，有着较科学的理论体系，估算方法有自顶向下和自底向上两种。自顶上下，是估算总开发时间、总工作量估算，按各阶段、步骤和工作单元分配。自底向上是分别估算各工作单元所需工作量和开发时间，然后相加得总量，分：专家估算法、类推估算法、算式算法。估算模型有 SLIM 模型（动态变量模型）、COMOMO 模型（基本、中级、详细）和代码行（自底向上）的估算模型。这里只介绍最后一种模型，其它两种可以读者自行查询。 代码行的估算模型步骤： ①确定功能：极好、正常、较差三种情况下源代码的估算行数，用 a,m,b 标示 ②求期望值 le 和偏差 ld ③根据经验，确定各个子功能的代码成本 ④计算子功能的成本和工作量，计算总成本和工作量 ⑤计算开发时间 ⑥分析结果 三、在实际操作中还需要有相应的进度计划，方便适时调整，避免突发情况，以作应对。常用方法：甘特图（条形图），工程网络图，时标网络图【都表示进度安排】 甘特图： 横坐标表示时间，纵坐标表示不同的子任务的分段。起点和终点分别对应子任务的开工时间和完成时间，线长表示所需时间。 工程网络图： 也称计划评审技术，是一种有向图；起点是箭尾，表示任务开始；终点是箭头，表示是任务结束，或下个任务开头；箭上数字称为权，表示子任务的持续时间。 绘制方法： 1. 从左到右，一个起点，一个终点，保证连同 2. 无编号相同节点 3. 无循环回路 4. 作业的合并 绘制步骤： 1. 先根据子模块估算工作量及标准生产率 C，再估算每个子模块花费时间 2. 画出网络图，确定关键路径 3. 确定整体进度安排，标识每个节点的机动时间 4. 平衡优化资源，可用规矩法，表算法、图解法 时标网络图： 是前两种方法的结合以纵轴为任务和资源（人员）坐标；以横轴为时间坐标；以主关键路径为主画，非关键路径分别画在关键路径的上下；有作业相互依赖关系，也有作业时序关系。 四、一个项目的研发，需要对风险的分析，即风险分析。风险分析包含项目风险、技术风险和商业风险。项目风险就是危及项目计划的风险；技术风险有设计实现借口、验证、维护等；商业风险则是来自与商业有关的风险，例如市场风险、策略风险、推销风险、管理风险、预算风险等等。这些风险的发生可能性不同，发生以后造成的损失也不尽相同，所以就需要对风险作出估算。风险因素一般有：性能、成本、支持和进度四项组成。所以估算要从这四项着手，从三方面考虑风险的可能性和损失：风险的性质、范围和时间。当估算完成后，需要对所估算的记过作出评价，而评价步骤为： 1. 定义各种风险的参考水准 2. 找出每组 [ri , pi , ei] 和各参考水准的关系（ri 是风险类别，pi 是风险发生的可能性，ei 是风险造成的影响或损失） 3. 预测一组临界点以定义项目的终止区 4. 预测怎样的风险组合会影响参考水平值 即使对风险有了一定的防范，依旧不能避免风险的发生，所以就需要对风险作出管理和监控，跟随进度同步进行。 五、对于人员的组织形式，是针对具体项目及人员素质：责任到人、组织合理和责权均衡。组织形式分为层级模式（层级管理）和矩阵模式（矩阵式管理）。其中成本的估算、风险分析和人员的组织形式有促进进度计划的完善！ 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 笔记五:面向对象技术]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-8%2F</url>
    <content type="text"><![CDATA[面向对象：Coad 和 Yourdon 给出定义是：“面向对象 = 对象 + 类 + 继承 + 通信” 对象（object）：面向对象开发模式的基本成份；每个对象可用它本身的一组属性和它可以执行的一组操作来定义；属性一般只能通过执行对象的操作来改变；操作又称方法或服务，它描述了对象执行的功能，若通过消息传递，还可以为其他对象使用 消息（Message）：是一个对象与另一个对象的通信单元，是要求某个对象执行类中定义的某个操作的规格说明 类（class）：具有相同数据结构和相同操作的对象的集合；其定义包括一组数据属性和在数据上的一组合法操作。 继承（Inheritance）：是使用已存在的定义做为基础简历新定义的技术；新类的定义可以是既存类所声明的数据和新类所增加的生命的组合 类的继承层次： 面向对象方法的开发过程： 对各个类的信息进行细化，分为分析、设计和实现的基本单元。 分析方面，包括论域分析和应用分析。论域分析，开发问题论域的模型；考察问题论域内的一个较宽的范围，分析覆盖的范围应比直接要解决的问题更多；简历大致的系统实现环境。应用分析，根据特定应用的需求进行论域分析，应用（或系统）分析细化在论域分析阶段所开发出来的信息，把注意力集中于当前要解决的问题 类生存期： 类的定义： 一旦标识了一个类，就给出了他的规格说明，其中包括类的实例可执行的操作和它们的数据表示 对每一个，无论实在那个阶段标识的类都是如此 累的规格说明定义了施加于对象的数据存储上的一组操作 类的实现： 通过变量的声明、操作界面的实现及支持界面操作的函数的实现，可实现一个类的预期行为何状态 实现是与语言有关的，一个好的面向对象语言应当分离共有界面与其内部实现 类的测试： 如果类的定义提供的界面比较狭窄，那么穷举测试就有可能实现 类的测试在最抽象的层次开始，沿继承关系继续向下进行（自顶向下） 已经测试过的部分不需要从新测试（重点在新类或组装的类） 求精和维护： 这是一个在软件生存期中最花费时间的部分 传统的维护是针对应用，而 求精是针对类，针对把类继承在一起的结构 可标识抽象的抽象，使得继承结构通过一般化增加新的层次，即在既存的根类之上增加新的层次 对象模型化技术 OMT 把分析时的信息构造在三类模型中，即对象模型、功能模型和动态模型 对象模型：最关键的，作用是描述系统的静态结构，包括构成系统的类和对象，它们的属性和操作，及它们之间的关系 OMT 中，类与类之间的关系叫做关联。聚合，代表整体与部分的关系，特殊形式关联；限定，用以对关联的含义做某种约束；角色，用力说明两名关联的一端，由于多数关联具有两个端点，因而涉及到两个角色 动态模型：着重于系统的控制逻辑；包括两个图：状态图和事件追踪图。状态图，是一个转态和时间的网络，侧重于描述每一类对象的动态行为。状态是对某一时刻中属性特征的概括，而状态图迁移表示这一类对象在合适对系统内外发生的哪些事件做出了何种响应。操作是一个伴随状态迁移的瞬时发生的行为，与出发事件一起表示在有关的状态迁移之上。动态模型由多个状态图组成。各个状态图并发地执行，并可以独立地改变状态。事件：一个事件发生在某一时刻，每个事件都是单独发生，建立事件类，并给每个事件一个名字，以知名共同结构和行为，事件从一个对象向另一个对象传递信息。事件追踪图，侧重于说明发生于系统执行过程中的一个特定 “场景”。场景也叫脚本，是完成系统某个功能的一个事件序列 状态图于事件追踪图的关系：状态图叙述一个对象的个体行为，事件追踪图则给出多个对象所表现出来的集体行为 功能模型：表明，通过计算，从输入数据能得到什么样的输出数据，不考虑参加计算的数据按什么时序执行（只看结果，不看过程）；由多个数据流图组成，它们知名从外部输入，通过操作和内部存储，知道外部输出，这整个的数据流情况；数据流图中允许加入控制流，但这样做将于动态模型重复，不提倡夹带控制流（控制流用虚线表示）。功能模型着重于系统内部数据的传送和处理。 三个模型的分析：功能模型定义 “做什么”，动态模型定义 “何时做”，对象模式定义 “对谁做。 Coad 与 Yourdon 面向对象分析（OOA**）** OOA 两个任务 1. 形式地说明我们所面对的应用问题，最终成为软件系统基本构成的对象，还有系统所必须遵从的，由应用环境所决定的规则和约束 2. 明确地规定构成系统的对象如何协同合作，完成指定的功能 构造 OOA 概念模型的层次： 构造和评审 OOA 概念模型的顺序和由五个层次组成，这五个层次是分析过程中的层次，每个层次的工作都为系统的规格说明国内增加了一个组成部分，层次：类与对象、属性、服务、结构和主题 （若类与对象层在一起，外层为实例【对象】的边界，内层为类的边界） 对象——类层 1. 表示待开发系统的基本构造块，这一层是整个 OOA 模型的基础，问题在于如何建立 “实现世界中事物” 的抽象表示，也就是如何建立基本块“ 2. 信息建模，指从现实世界中捕捉并抽象出应用论域的基本结构的过程，这是 OOA 过程中最基本和最关键的活动之一 3. 应用论域非常重要，同一概念在不同论域中抽象出来的基本构造块是不同的 属性层: 由对象的属性和实例链接共同组成。 服务层: 对象的服务，加上对象实例之间的消息通信，共同组成了 OOA 模型的服务层，消息链接用有向箭头表示。 结构层: 负责捕捉特定应用论域中的结构关系。 1. 结构层的一种类型，描述除了该系统的整体结构。 2. 另一种类型称为一般——特殊机构或泛化——特化结构，泛化——特化结构表明了类的继承性。 主题层:OOA 模型结构庞大而复杂，可以将对象归类到各个主题中，把有关的对象用一个主题边框框起来。 识别类和对象: 类和对象是对与应用有关的概念的抽象, 这层工作是整个分析模型的基础。 选择类和对象的原则：目标系统必须记住类和对象的某些事情；类 和对象应当提供某些服务或处理；多属性；所有属性对于类中所有实例都应有意义 面向对象设计（OOD**）** 继续面向对象分析阶段的工作，建立软件的结构。主要工作阶段：高层设计，开发系统结构，即构造应用软件的总体模型。标识在计算机环境中进行问题解决工作所需要的概念，并增加一批需要的类 高层设计特点：可以表征为标致和定义模块的过程，定义工程师职责驱动的 高层设计遵循原则：各个高层部件之间的通信量达到最小； 子系统应当把那些成组的类打包，形成高度内聚； 逻辑功能分组，提供一个个单元，识别并定位问题事件。 高层设计方法： 设计问题论域部分，包括与应用问题直接有关的所有类和对象，继承机制有单继承和多继承； 人机交互部分，用户界面部分的设计； 任务管理部分，定义各个任务（工作包括：什么任务、如何协调、如何通信和建立一个模板）； 数据管理部分，提供在数据管理系统中存储和检索对象的基本结构，包括对永久性数据的访问和管理。 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 笔记四:用户界面设计]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-7%2F</url>
    <content type="text"><![CDATA[用户界面 (UserInterface，简称 UI) 是直接面对用户的界面，是系统与用户之间的媒介，一个软件的好坏，UI 起着重要因素。UI 是软件的人机交互界面、操作逻辑、界面美观的整体设计。好的 UI 设计不仅仅使得软件有个性有品位，还让软件的操作变得舒适、简单、自由、充分体现软件的定位和特点 没有好的界面，就算你的软件设计的再好，功能再全，设计的技术再高，再用户眼中都是一文不值。当然，没有好的界面设计，实际上这个软件的含金量也不会很高的。 设计 UI，就需要从它的特点着手。作为一个人机交互界面，UI 具有的特点：可使用性、灵活性、复杂性和可靠性。 根据特点，需要进行 UI 设计的软件分析，既然作为人机交互界面，就要考虑用户的特性，适应人的需要建立，就要弄清用户习惯（用户类型，如外行型、初学型、熟练型及专家型），和用户特性度量： 然后，需要考虑用户在什么情况下使用该系统（即用户工作分析） 要根据用户工作环境建立相应类型。例如，可以建立用户模型：理论认知模型、用户知识模型、用户任务模型、用户观点和任务模型等 理论认知模型由心理学家建立，目的了解人的思维过程；用户知识模型，描述一定范畴内的知识以及类型之间的联系，借助各个用户的知识来建立；用户特性模型，主要依据用户特性分析所描述的技能和能力对用户进行分类，也称用户外观；用户任务模型，根据用户要求提出的任务的功能和操作次序；用户观点，指系统结构的用户模型，是用户描述和摄像现行系统结构的方法；任务模型，分静态和动态，静态是对象——关系模型，用于展示界面的结构设计，动态是对系统操作或与绘画设计有关的对象的动态行为的描述。 分析了界面设计，就需要实际建立 UI 了，包括任务分配、分配步骤、工作设计和工作方式。 其中，工作设计的目的是使任务需求与操作员的能力向匹配；工作方式分两种情况，一种是一个人单独完成一个系统的目标，另一种是任务进展跟踪（拖延或延迟时间及原因）。 将这些都做好了，开始考虑 UI 的基本类型了。UI 的类型分：使用的难易程度、学习的难易程度、操作速度、复杂程度、控制、开发的难易程度等 注意：通常，一个界面的设计使用了一种以上的设计类型，每种类型与一个或一组任务相匹配 界面类型确定好了，就要考虑界面上详细的内容了，比如菜单。菜单是由系统预先设置好的，显示于屏幕上的一组或几组可供用户选用的命令。 菜单的分类：按照现实的形象或样式来分类，正文菜单、图标菜单、正文和图标混合菜单；按屏幕位置和操作风格来分类，固定位置菜单（0 层——主菜单、1 层——子系统层、2 层）；按浮动菜单（对话）分类，有必须回答式、无需回答式和警告式。 将菜单设计好了，就该具体的问题描述了，设计问题描述语言 PDL（problem Oriented Language），包含语义层（具体对象、消息、链接），语法层（语义层的进一步细化），交互层。 下一个需要设计的窗口，这方面大家都有了解，我就不细说了。 作为人机交互界面，数据输入时必然的，就需要规定输入规则： 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 笔记三:软件测试]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-6%2F</url>
    <content type="text"><![CDATA[这几天刚刚刚接触了软件测试，感觉内容挺简单的，无非就是该怎么测试一个软件能否正确运行。其中主要讲述了测试的方法与原则。实际上测试都是要依据各种测试方法协调完成测试工作，而这个过程不是在很大程度上决定了一个软件的成功与否。所以，软件测试很重要！ 下面就让我们来接触它吧： 上面这幅图是我对与软件测试的初步认识总结的思维导图（仅供参考）。 软件测试主要讲述了软件测试的目标和原则、软件测试的用例设计、软件测试的策略、软件测试的种类和程序的调试五个大方面。 一、软件测试的目的和原则 目的： 1. 测试时程序的执行过程，目的在于发现错误2. 一个好的测试用例在于能发现至今未发现的错误3. 一个成功的测试时发现了至今未发现的错误原则： 1. 应当把 “尽早地和不断地进行软件测试” 做为软件开发者的座右铭 2. 测试用例应由测试输入数据和对应的预期输出结果这两部分组成 程序员应避免检查自己的程序（开发和测试人员两套） 4. 在设计测试用例时，应当包括合理的输入条件和不合理的输入条件 二、测试信息流 (**输入：**) 软件配置： 测试配置： 测试工具： (**输出：**) 测试结果分析： 排错（调试）： 修正后的文档再测试： 三、测试与软件开发各阶段的关系 开发过程是自顶向下，逐步细化的过程 测试过程相反顺序安排的自底向上，逐步集成的过程 四、测试用例设计两种方法：黑盒测试（功能测试或数据驱动测试）把测试对象看做一个黑盒测试，检查程序的功能是否符合他的功能说明 重点：程序接口是否遗漏或不完整；白盒测试（结构测试或逻辑驱动测试） 测试对象看做一个透明的盒子，对程序所有逻辑路径进行测试重点：独立路径至少要测试一遍；被测的所有逻辑（成立和不成立两个方向）都要测试大的程序都不可能测试完全（**所以**需要测试员一般高于开发人员）逻辑覆盖：以程序内部的逻辑结构为基础的设计测试用例的技术（属白盒测试）语句判定、判定覆盖、条件覆盖（存在缺陷）判定—条件覆盖、条件组合覆盖、路径覆盖（比较严格）语句覆盖：设计若干个测试用例，运行被测程序，使得每一条执行语句至少执行一次判断覆盖：设计若干个测试用例，运行被测程序，使得每个判断的取真分支和取假分支至少精力一次条件覆盖：设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次判断—条件覆盖：设计足够测试用例，使得判断中每个条件的所有可能取值至少执行一次，同时每个判断中的每个条件的可能取值至少执行一次 例： 路径测试: 设计足够的测试用例, 覆盖程序中所有可能的路径 条件测试路径选择当程序中判定多于一个时, 形成的分支结构可以分为两类: 嵌套型分支结构和连锁型分支结构 循环测试路径选择循环分为: 简单循环、嵌套循环、连锁循环、非结构循环 黑盒测试的测试用例设计等价类划分把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据做为测试用例划分情况：有效等价类、无效等价类划分原则：1. 如果输入条件规定了取值范围，或值得个数，则可以确立一个有效等价类和无效等价类2. 如果输入条件规定了输入值得集合，或者是规定了 “必须如何” 的条件，这时可确立一个有效等价类和一个无效等价类3. 如果输入条件是一个布尔型，则可以确定一个有效等价类和一个无效等价类4. 如果规定了输入数据的一组值，而且程序要对每个输入值分别进行处理5. 如果规定了输入数据必需遵守的规则，则可以确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）确定测试用例：列出所有划分出的等价类边界值分析测试用例时，主要考虑边界处。使用时，首先要确定边界情况。应当选取正好等于，刚刚大于或刚刚小于边界值做测试数据遵循原则：1. 如果输入条件规定了取值范围，则应对该范围的边界内附近，恰好在边界和在边界外附近（无效等价类中）设计测试用例2. 如果输入条件规定了数据的个数，则应对最小个数，最大个数，比最少个数少 1，比最大个数大 1 等情况设计测试用例3. 针对规格说明中的每个输出条件使用前面的 1 和 2 原则4. 如果程序规格说明中提到的输入或输出域是个有效的集合（如顺序文件，线性表等）。应选有序续集的第一个和最后一个元素做为测试用例 错误推测法基本想法：列举出程序中所有可能有的错误和容易发生错误的特殊情况一般作补充的测试用例因果法如果在测试时必须考虑输入条件的各种组合，可使用一种适合于描述对于多种条件的组合，形影产生多个动作的形式来设计测试用例，这就需要利用因果图。最终生成的是判定表。生成测试用例的基本步骤：1. 分析软件规格说明描述中，哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符2. 分析软件规格说明描述中的语义，找出原因与结果之间，原因与原因之间的对应关系，根据这些关系画出因果图3. 由于语法或环境限制，右斜原因与原因之间，原因与结果之间的组合情况不可能出现，为表明这些特殊情况，在因果图上用一些几号表明约束或限制条件4. 把因果图转换成判定表5. 判定表的每一列拿出来做为依据，设计测试用例图中的基本符号：Ci 表示原因，Ei 表示结果，结点表示状态（0 表示状态不出现，1 表示状态出现）主要原因和结果之间的关系有（恒等、非、或、与） 表示约束条件的符号： 五、软件测试的策略 步骤：单元测试、组装测试、确认测试和系统测试 单元测试（Unit Testion）又称模块测试，针对软件设计的最小单位——程序模块，进行正确性检验的测试工作内容：模块接口、局部数据结构、边界条件、独立路径、出错处理 步骤：同时考虑它和外界的联系，用一些辅助模块去模拟与被测模块相联系的其他模块（驱动模块 driver、桩模块 stub） 常见错误清单：（一）模块接口检查表1. 模块接受的输入参数个数与模块的变元个数是否一致2. 参数与变元的属性是否匹配3. 参数与变元所用的单位是否一致4. 传递给被调用模块的变元的数目是否等于那个模块的参数的数目5. 传递给被调用模块的变元属性和参数的属性是否一致6. 传递给被调用模块的变元的单位和该模块参数的单位是否一致7. 传递给内部函数的变元属性、数目和次序时否正确8. 是否修改了只是做为输入用的变元9. 全程变量的定义在各个模块中是否一致10. 有没有把常数当做变量来传递（二）完成外部输入 / 输出时的检查表1. 文件属性是否正确2. OPEN 语句是否正确3. 格式说明与输入 / 输出语句给出的信息是否一致4. 缓冲区容量与记录长度是否匹配5. 在进行读写操作之前是否打开了文件6. 对结束文件条件的判断和处理是否正确7. 对输入 / 输出错误的处理是否正确8. 有没有输出信息中有正文错误（三）模块局部数据结构检查表1. 不正确或不一致说明2. 错误的初始值或错误的缺省值3. 变量名拼写错或缩写错4. 不相容的数据类型5. 下溢、上溢或是地址错误组装测试（Integrated Testing）把模块组装成为系统的方式有：一次性组装方式和增殖式组装方式（常用） 一次性组装方式（big bang） 增殖式组装方式 自顶向下的增殖方式自底向下的增殖方式混合增殖测试确认测试（Validation Testing）又称有效性测试。任务：验证软件的功能和性能及其它特性是否与用户的要求一致 进行有效性测试是在模拟的环境（可能就是开发的环境）下，运行黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求软件配置复查目的：1. 保证软件配置的所有成分都齐全2. 保证各方面的质量 都符合要求3. 保证具有维护阶段所必需的细节4. 保证已经编排好分类的目录验收测试（Acceptance Testing）是以用户为主的测试。软件开发人员和 QA（质量保证）人员也应参加由用户参加设计测试用例，使用生产中的实际数据进行测试 系统测试（System Testing）将通过确认测试的软件做为整个基于计算机胸膛的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行环境下，对计算机系统进行一系列的组装测试和确认测试α测试和β测试α测试是由一个用户在开发环境下进行测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试β测试是由软件的多个用户在实际使用环境下进行的测试。这些用户返回有关错误信息给开发者测试种类功能测试、可靠性测试、强度测试、性能测试、恢复测试、启动 / 停止测试、配置测试、安全性测试、可使用性测试、可支持性测试、过程测试、互连测试、兼容性测试、容量测试、文档测试 六、调试（Debug）在成功测试后开始工作，进一步诊断和改正程序中潜在的错误步骤：i. 从错误的外部表现形式入手，确定程序中错误位置ii. 研究有关部分的程序，找出错误的内在原因iii. 修改设计和代码，以排除这个错误iv. 重复进行暴露了这个错误的原始测试或某些有关测试方法：强行排错（使用多，效率低）、回溯法调试（适用小程序）、归纳法调试（基本思想：从一些线索即错误征兆着手）、演绎法调试（从一般原理或前提触发) 原则：许多原则本质是心理学方面的问题，分为：确定错误的性质和位置的原则：1. 用头脑去分析思考与错误征兆有关的信息2. 避开死胡同3. 只把调试工具当做辅助手段来使用4. 避免用试探法，最多只能把它当做最后手段修改错误的原则：1. 在出现错误的地方，很可能还有别的错误2. 当心修正一个错误的同时有可能会引入新的错误 七、测试分析报告 测试时程序的执行过程，目的在于发现错误 一个好的测试用例在于能发现至今未发现的错误 一个成功的测试时发现了至今未发现的错误 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 笔记二:软件分析]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-5%2F</url>
    <content type="text"><![CDATA[软件工程（Software Engineering，简称 SE），是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科，就是和软件有关的工程，而软件是什么，软件是系统中与硬件相互依存的另一部分，包括程序、数据、及其相关文档的完整集合。 那么，问题又来了，程序、数据、文档又是啥？ 程序：按设计的功能和性能要求的指令序列。数据：正常操作信息的数据结构。文档：程序开发、维护和使用有关的额图文材料 什么特点？ 1. 逻辑实体，非物理实体（抽象性） 2. 生产与硬件不同，开发过程中无明显制造过程 3. 运行和使用期间，没有硬件的机械磨损，老化问题 4. 开发和运行手系统限制，有不同程度的依赖性 5. 至今未完全摆脱手工操作 6. 本身复杂（实际问题，逻辑结构） 7. 成本昂贵 8. 很多设计社会因素（知识产权等） 其他方面了解： 分类情况有很多种。依据功能划分分为系统软件、支撑软件、应用软件；按规模划分，有微型、小型、中型、大型、甚大型、计大型之分；还有按工作方式、服务对象、使用频率、失效影响等区分。 软件工程基本原理： 1. 用分阶段的生存周期计划严格管理 2. 坚持进行阶段评审 3. 实行严格的产品控制 4. 采用现代程序设计技术 5. 结果应能清楚地审查 6. 合理安排软件开发小组的人（少而精） 7. 承认不断改进软件工程实践的必要性 软件工程的项目基本目标是： 付出较低的开发成本 达到要求的软件功能 取得较好的软件性能 开发的软件易于移植 需要较低的维护费用 能按时完成开发工作，即时交付使用 软件工程原则：分解性、独立性、一致性、确定性 生存周期（六个阶段）： （从开发至被废弃）问题定义、可行性研究、需求分析、设计、编码、测试、运行与维护；三大阶段：软件计划阶段、开发阶段和维护阶段 软件开发模型，例如瀑布模型、B 模型、快速原型模型（RapidPrototyping Model）、演化模型、渐增模型、螺旋模型等。 通过上面了解了软件工程，那么我们可能会认为做个软件有啥的，做出来不就行了，那么我们看看具体怎么做吧。 如果直接就开始软件创建，那为啥还要叫软件工程，直接叫编程不就完了。其实软件工程师工程化的，需要考虑方方面面，不仅要创建软件，还要为软件作说明，以及维护，让非专业的人知道怎么使用和维护软件，这才是重点。那么让非专业人士了解，就需要多种文档的建立啦。由于视频我还没有看完，所以只能先介绍我了解的文档了。 文档也就是软件规格说明书，用来规定软件的功能与运行环境，满足规格的条件和完成客户需求。软件规格说明书的特点：易理解性、可见性、可支持性、可接受性、可靠性、健壮性、可维护性、速度。 首先，第二章介绍的是可行性研究报告。 可行性研究步骤： 复查系统规模和目标 研究当前正在使用的系统 到处新系统的高层逻辑模型 向用户推荐建议方法 推荐行动方针，做出关键性的决定 草拟开发计划，写出可行性论证报告 提交上级和专家审查 软件计划内容 软件功能规模，软件能力对硬件的要求，接口界面的性质和复杂性等 环境资源： 人力资源，在不同的阶段对不同的人员的要求 硬件，包括目标机器，及其他机器 软件，包括职支撑软件和使用软件 制定进度表，包括交付日期，如何组织分配力量 软件成本，只要双方都能接受即可（估算） 资源性能描述：要什么样水平的人，什么样的功能性能的硬件和软件 价格评估 影响因素：人口、产品、工程、资源 1. 参数化算法 C=f（Vi);C 是软件价格，Vi 所选取的影响软件价格的独立参数 2. 代码行（LOC）价格估算技术 有关参数：源代码行，是软件产品计量单位，不包括注释，作业命令…… 劳动量，一个人参加劳动时间的长短 软件生产率，单位劳动时间完成软件的数量 LOC 计算方法，对设计的系统进行功能分解，根据历史数据和经验选择每个软件功能块的 LOC 价格 3. 任务分解方法 思想：首先把软件开发工程分解为若干个相对独立的任务，再分别估计每个开发任务的成本，最后累加得出总成本 4. 自动估计成本方法 减轻人的劳动但要有大量的经验数据做基础，要有狼嚎数据库系统支持 成本 / 效益分析 成本估计方法：自顶向下估价、自底向上估价 成本 / 效益分析法： 运行费：取决与系统的操作费用和维护费用 系统的经济效益：因新系统而增加的收入 + 新系统节省的运行费；系统经济效益一般在整个生存周期内都存在 项目开发计划 引言：编写目的、项目背景、定义、参考资料 项目描述：工作内容、条件与限制、产品、运行环境、服务、验收标准 实施计划：任务分解、进度、预算、关键问题 人员组织及分工 交付期限 专题计划要点 第三章介绍的是软件需求 任务: 深入描述软件的功能和性能 确定软件设计的约束和软甲同其他系统元素的接口细节 定义软件的其他有效性需求（借助于当前系统的逻辑模型到处目标系统的逻辑模型，解决目标系统的 “做什么” 的问题） 需求包括：功能需求、性能需求、环境需求、可靠性需求、安全保密要求、用户界面需求、资料使用需求、成本消耗需求、开发进度需求、预先估计以后系统可能达到的目标 方法共性： 支持数据域分析的机制 功能表示的方法 接口的定义 问题分解的机制以及对抽象的支持 逻辑视图和物理视图 系统抽象模型 软件需求分析的原则 需要能够表达和理解问题的信息域和功能域 要能以层次化得方式对问题进行分解和不断细化 软件需求规格说明的原则 从现实中分离功能描述要 “做什么” 而不是“怎么实现” 要求使用面向处理的规格说明语言（或称系统定义语言） 软件需求方法 由对软件问题的信息域和功能域的系统分析过程及其表示方法 大多是由信息驱动（信息流即数据流，不包括控制） 结构化分析方法 面向数据流 使用数据处理类型软件 数据流图（DFD）：通过数据流向表达软件需求 数据流图的作用： 1. 系统分析员用这种工具可以自顶向下分析系统信息流程 2. 可在图上画出需要计算机处理的部分 3. 根据数据存贮（zhu），进一步作数据分析，向数据库设计过渡 4. 根据数据流向，定出存取方式 5. 对应一个处理过程，用相应的语言、判定表等工具表达出处理方法 数据流图的优缺点： 1. 总体概念强，每一层都明确强调 “干什么”，“需要什么”，“给什么” 2. 可以反映出数据的流向和处理过程 3. 由于自顶向下分析，容易及早发现系统各部分的逻辑错误，也容易修正 4. 容易与计算机处理相对照 5. 不直观，一般都要在作业流程分析的基础上加以概括、抽象、修正来得到 6. 如果没有计算机系统帮助的话，人工绘制太麻烦，工作量较大 检查和修改数据流图的原则 1. 数据流图上所有图形符号只限于前述四种基本图形元素 2. 数据流图的主图必需包括前述四种基本元素，缺一不可 3. 每个加工至少有一个输入数据流和一个输出数据流 4. 在数据流图中，需按层给加工框编号。编号表明该加工所处层次及上下层的亲子关系 5. 规定任何一个数据流子图必需与它上一层的一个加工对应，两者的输入数据流和输出数据流必需一致 6. 图上每个元素都必须有名字 7. 数据流图中不可夹带控制流 8. 初画图时可以忽略琐碎的细节，以集中精力于主要数据流 9. 不许有交叉层叠的情况 数据词典 配合数据流图，清楚地表达数据处理的要求 （主）词条描述——对图形元素定义（名字，别名或编号，分类，描述，定义，位置，其它等） 用于写加工逻辑说明的工具： 结构化英语，是一种介于自然语言和形式化语言之间的语言，由英语命令动词，数据词典中定义的名字，有限的自定义词，逻辑关系词 IF_THEN_ELSE、CASE_OF、WHILE_DO、REPEAT_UNTIL 等组成；语言的正文用基本控制结构进行分割，加工的操作用自然语言短语来表示；其基本控制结构有三种：简单陈述句结构；重复结构；判定结构 判定表（将各种逻辑通过列表的方式列举出来） 先条件后动作最后优化；优化先从动作开始。 描述加工的基本说明，适用多个逻辑的，清晰描述复杂的条件组合与应该做的动作对应关系；但不能表述不确定的加工处理，重复循环的加工处理 判定树（通过树状图表示逻辑组合） 用来表达加工逻辑的一种工具，有时比判定表更直观 优点：形式简单，直观，判定表的数据源数多余两个的时候，判定表写起来别较多，判定树比较形象 不足：简洁度不如判定表，越接近树叶的地方越多 其它还有 I/P/O 图、层次方框图、PHA 图等，不做详细介绍。 工具的选择方式： 从机器的可读性来讲：结构化英语、判定表优于判定树 从描述的直观性来讲：判定树较好 对于逻辑验证和优化能力：判定表较好（所有的可能性都列出来） 原型化方法 开发初期，完整准确的规格说明不易得到，用户往往对系统仅一个模糊想法，难完全准确表达系统全面要求 软件原型的分类： 最常用的动态分析方法 状态迁移图是描述系统的状态如何相应外部的信号进行推移的一种图形表示，圆圈 “○” 表示可得到的系统状态，箭头 “→” 表示从一种状态向另一种状态的迁移，“？”表示转移即系统的事件。优点：单纯性，机械地分析许多情况，易机那里分析工具，如可转换为状态迁移表，处理功能强；状态之间的关系描述直观（不能有交叉不清） 时序图（Sequence Diagram），亦称为序列图或循序图或顺序图，是一种 UML 交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，时序图中的每条消息对应了一个类操作或状态机中引起转换的触发事件。 Petri 网简称 PNG（Petri Net Graph），广泛应用于硬件与软件系统的开发中，适用于描述与分析相互独立、协同操作的处理系统，即并发执行的处理系统；标记，或称令牌（token），是表明系统当前处于什么状态的标志 第四章介绍的是软件概要设计说明书和详细设计说明书 即第四章描述的是软件的设计。 概要设计的过程步骤： S1: 设计系统方案 S2：选取一组合理的方案 S3：推荐最佳实施方案 S4：功能分解 S5： 软件结构设计 S6：数据库设计、文件结构的设计 S7：制定测试计划 S8：编写概要设计文档 S9：审查与复审概要设计文档 软件设计的概念与原则 将软件划分成若干独立成分的依据 怎样表示不同的成分内的功能细节和数据结构 怎样同一衡量软件的技术质量 软件设计的目标和任务 根据用信息域表示的软件需求，以及功能和性能需求，进行 数据设计 系统结构设计 过程设计 注意：一般先概念设计，后详细设计 软件设计的过程： 制定规范 软件系统结构的总体设计 处理方式设计 数据结构设计 可靠性设计（质量设计） 编写概要设计阶段的文档（概要设计说明书和数据库的说明书、完善用户手册） 概要设计评审 软件设计基础： 自顶向下，逐步细化 体系结构自顶向下方式，各个层次过程细节和数据细节逐层细化 软件结构 模块结构和数据的结构 把一个问题分解为多个子问题，然后非别解决子问题（子问题开发工作量之和小于原问题开发工作量【数学问题】） 程序结构，分为两种 树状结构（层次结构）： 层次分明，只有一个节点，没有副节点，多个子节点（兄弟之间没有什么联系，只与父节点有关）；纵向叫深度，横向叫快读，每个节点输入叫扇入，输出叫扇出 网状结构： 任何两个节点可以建立联系，层次模糊，不易看出根节点 结构图（S/C 图） 反映程序中模块之间的层次调用关系和联系 模块化 能够把一个大而复杂的软件系统划分成易于理解的比较单纯的模块结构 1. 模块 矩形框表示，模块名，各个模块名不能相同 模块名（以功能、功能缩写、已定义模块、子程序或过程），一般以功能命名，功能非单一以主要功能命名 2. 模块的调用关系和接口 3. 模块间的信息传递 传入和传出信息必不可少，要表明信息名称和特征 传递信息较多时要描写主要信息 4. 表示模块 A 有条件地调用另一个模块 B 菱形框表示，标记点一定要在上一模块，尽量也要写上条件 弧形的表示循环调用，右箭头的表明循环调用的方向（顺序） 程序的系统结构图 小的结构图深度大概 5-7 层，中型十几层或 10 层，复杂型几十层，反映问题的复杂性 宽度指任意一层的模块书，宽度越大，复杂度越高 扇出太多表明受其他模块影响较大，扇出不要太多，一般 2-5，不要超过 9-10，减小扇出，势必要增加深度 扇入表示驱动模块（上一个模块）有多少，扇入一般 1-5，要控制数量 一个好的系统结构图应该呈现 “瓮” 型 抽象化 软件系统进行模块设计时，可有不同的抽象层次，即分解系统； 控制分解速度 过程：分层抽象，逐渐细化； 根据任务需求进一步细化； 程序过程抽象（编程阶段）； 数据抽象，在不同层次上描述数据对象的细节，定义与该数据对象相关的操作 信息隐蔽 划分模块的时候（定义层次），模块内的数据发生变化的时候，尽量不要影响其他相关模块或少影响，即不允许其他的模块使用本模块 模块的独立性 模块的基本属性： 功能：描述该模块实现什么功能 逻辑：描述模块内部怎么做 状态：该模块使用时的环境和条件 独立性是指软件系统中每个模块只涉及软件要求的具体的子功能 一般采用两个准则度量模块独立性，即模块间耦合和模块内聚 模块间的耦合 独立性越强，耦合性越低 非直接耦合（Nondirect Coupling） 两模块之间没有直接关系 数据耦合（Data Coupling） 如果一个模块模块访问另一个模块时，彼此之间是通过简单数据参数（不是控制参数、公共数据结构或外部变量来交换输入、输入信息的） 标记耦合（Stamp Coupling） 如果一组模块通过参数表传递记录信息，就是标记耦合 控制耦合（Control Coupling）（中耦合） 如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能 外部耦合（External Coupling） 一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，较强耦合 公共耦合（Common Coupling） 若一组模块都访问同一个公共数据环境，较强耦合有两种情况：松散公共耦合和紧密公共耦 （a）A 模块写入的数据（B 模块不需要的）可能导入到 B 模块 （b）两个模块都能修改数据，容易造成混乱，尽量避免 合理使用公用耦合，可减少使用内存量 内容耦合（Content Coupling） 模块内聚 内聚性越高，模块独立性越强。内聚是可以互相转换的。 功能内聚（Functional Cohesion） 一个模块中各个部分都是完成某一具体功能必不可少的组成部分，是不可分割的，最理想的模块内聚 信息内聚（Informational Cohesion） 也称（顺序内聚），模块完成多个功能，各个功能都在统一数据结构上操作，每一项功能有一个唯一的入口点，较强内聚 通信内聚（Communication Cohesion） 如果一个模块内各功能部分都使用了相同的输入数据，或产生相同的输出数据 过程内聚（Procedural Cohesion） 使用流程图做为工具设计程序时，把流程图中的某一部分划出来组成模块 时间内聚（Classical Cohesion） 也叫瞬间内聚 1. 各个模块的执行与时间有关 2. 通常要求所有功能必须在同一时间段内执行； 3. 动作仅执行一次，往往影响其他模块； 4. 模块内各部分内聚的时间关系反映了某些实质问题 逻辑内聚（Logical Cohesion） 把集中相关的功能组合在一起 巧合内聚（Coincidental Cohesion） 各部分之间没有联系，或者即使有联系，这种联系也很松散 结构化设计方法 首先研究、分析和审查数据流图；然后根据数据流图决定问题的类型，典型类型：变换型和事务型 系统结构图中的模块 传入模块 输入物理数据流，传出逻辑数据流，左斜 传出模块 传出逻辑输出数据流（一般），右斜 变换模块 从上级模块取得数据，经过变换后在返还上级模块 协调模块 对所有下属模块进行协调与管理 变换型系统结构图（一条线）, 过程大致分为三步：取得数据，变换数据和给出数据 事务型系统结构图（有分支）, 接受一项事务，根据事务处理的特点和性质，选择分派一个适当的处理单元，然后给出结果 变换分析 方法四步组成： 1. 重画数据流图 2. 区分有效（逻辑）输入、有效（逻辑）输出和中心变换部分 3. 进行一级分解，设计上层模块 4. 进行二级分析，设计输入、输出和中心变换部分的中、下层模块 中心交换就是主模块位置 在选择木块设计的次序时，须对一个木块的全部直接下属模块都设计完成 在设计下层模块时，应考虑模块的耦合和内聚问题 使用 “黑箱” 技术：在设计当前模块时，先把这个模块的所有下层模块定义成“黑箱” 在模块划分时，一个模块的直接下属模块一般在 5 个左右（调用的模块） 如果出现以下情况，就停止模块的功能分解： 当木块不能再细分为明显的子任务时； 的那个分解成用户提供的模块或程序库的子程序时 当模块的界面是输入 / 输出设备传送的信息时 当模块不宜再分解得过小时 事务分析也是从分析数据流图开始，自顶向下，逐步分解，建立系统到结构图 事务处理过程： 识别事务源 规定适当的事务型结构 识别各种事务和他们定义的操作 注意利用公用模块 对每一事务，或对联系密切的一组事务，建立一个事务处理模块 对事务处理模块规定他们全部的下层操作模块 对操作模块规定他们的全部细节模块 软件模块结构的改进 模块功能的完善化, 一个完整的模块应当有一下几部分： 执行规定的功能的部分 2. 出错处理的部分 3. 给它的调用者返回一个结束状态标志 模块的作用范围应在控制范围之内 模块的控制范围包括它本身及其所有的从属模块 模块的作用范围是指模块内一个判定的作用范围，凡是收这个判定影响的所有模块都属于这个判定的作用范围。 当违反了作用域和控制域的关系时，解决方法：判定点的上移（判定模块的功能上移）；受控制的模块下移到控制模块 尽可能减少高扇出结构，随着深度增大扇入 扇出一般 2-5，不超 9；扇入一般 3-4 好处：是每个模块内部结构不太复杂 避免或减少使用病态联接，如： 直接病态联接 公共数据域病态联接 通信模块联接 模块的大小要适中 通常规定其语句行数在 50~100 左右，保持在一页纸之内，最多不超过 500 行 一般按功能划分，防止模块功能太多，要是修改很麻烦 设计功能可预测的模块，但要避免过分受限制的模块（受约束条件过多） 对非法和合法的输入都应有相应的输出 软件包应满足设计约束和可移植性 设计的后处理 为每一个模块写一份处理说明 为每一个模块提供一份接口说明 确保全局数据结构和局部数据结构 之处所有的设计约束和限制 进行给药设计的评审 数据设计及文件设计 数据设计的原则 （总）在需求分析阶段所确定的数据对象选择逻辑表示，需要对不同的结构进行算法分析，以便选择一个最有效的设计方案； 确定对逻辑数据结构所必需的操作的程序模块，以便限制各个数据决策的影响范围 （分） 用于软件的系统化方法也是用于数据 确定所有的数据结构和在美中数据结构上施加的操作 应当建立一个数据词典并用它来定义数据和软件的设计 底层数据设计的决策应推迟到设计过程的后期进行 数据结构的表示只限于那些必须直接使用该数据结构内数据的模块才能知道 应当建立一个存放有效数据结构及相关操作的库 软件设计和程序设计语言应当支持抽象数据类型的定义和实现 文件设计 文件逻辑设计，在概要设计阶段 整理必须的数据元素 分析数据间的关系 确定文件的逻辑设计 理解文件的特性 确定文件的组织方式 确定文件的存储介质 确定文件的记录格式 估算存取时间和存存储容量 过程设计 对所采用算法的逻辑关系进行分析，设计出全部必要的过程细节，并给予清晰的表达 决定各个模块的实现算法，并精确地表达这些算法，表达过程规格说明的工具叫做详细设计工具：图形工具、表格工具、语言工具 程序流程图 亦程序框图，五种基本控制结构：顺序型、选择型、先判定型循环、后判定型循环、多情况选择型 程序流程图的优点： （a）采用简单规范的符号，画法简单； （b）结构清晰，逻辑性强； （c）便于描述，容易理解。 缺点：诱惑程序员过早的考虑控制流，建议少用 N-S 图（盒图） 整个方框，看不到控制流。五种图形构件：、顺序型、选择型、WHILE 重复型、UNTIL 重复型、多分支选择型（CASE）型 问题分析图（PAD） 二维树形结构数据流来表示控制流，直接得出。其基本控制结构：顺序型、选择型、WHILE 重复型、UNTIL 重复型和多分支选择型（CASE 型） 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程 笔记一:绪论]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-4%2F</url>
    <content type="text"><![CDATA[什么是软件工程？ 软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。 软件工程过程是指为获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动。 软件工程有什么作用？ 在现代社会中，软件应用于多个方面。典型的软件有电子邮件、嵌入式系统、人机界面、办公套件、操作系统、编译器、数据库、游戏等。同时，各个行业几乎都有计算机软件的应用，如工业、农业、银行、航空、政府部门等。这些应用促进了经济和社会的发展，也提高了工作效率和生活效率 。 软件工程的过程。 三个阶段：定义阶段：可行性研究初步项目计划、需求分析；开发阶段：概要设计、详细设计、实现、测试；运行和维护阶段：运行、维护、废弃 原则：1、抽象；2、信息隐蔽；3、模块化；4、局部化；5、确定性；6，一致性；7、完备性；8、可验证性 软件工程的基本原理？ （1）用分阶段的生存周期计划进行严格的管理。 （2）坚持进行阶段评审。 （3）实行严格的产品控制。 （4）采用现代程序设计技术。 （5）软件工程结果应能清楚地审查。 （6）开发小组的人员应该少而精。 （7）承认不断改进软件工程实践的必要性。 软件工程的目标是什么？ 在给定成本、进度的前提下，开发出具有适用性、有效性、可修改性、可靠性、可理解性、可维护性、可重用性、可移植性、可追踪性、可互操作性和满足用户需求的软件产品。追求这些目标有助于提高软件产品的质量和开发效率，减少维护的困难。 软件工程有哪些特点？ （1）适用性：软件在不同的系统约束条件下，使用户需求得到满足的难易程度。 （2）有效性：软件系统能最有效的利用计算机的时间和空间资源。各种软件无不把系统的时 / 空开销作为衡量软件质量的一项重要技术指标。很多场合，在追求时间有效性和空间有效性时会发生矛盾，这时不得不牺牲时间有效性换取空间有效性或牺牲空间有效性换取时间有效性。时 / 空折衷是经常采用的技巧。 （3）可修改性：允许对系统进行修改而不增加原系统的复杂性。它支持软件的调试和维护，是一个难以达到的目标。 （4）可靠性：能防止因概念、设计和结构等方面的不完善造成的软件系统失效，具有挽回因操作不当造成软件系统失效的能力。 （5）可理解性：系统具有清晰的结构，能直接反映问题的需求。可理解性有助于控制系统软件复杂性，并支持软件的维护、移植或重用。 （6）可维护性：软件交付使用后，能够对它进行修改，以改正潜伏的错误，改进性能和其它属性，使软件产品适应环境的变化等。软件维护费用在软件开发费用中占有很大的比重。可维护性是软件工程中一项十分重要的目标。 （7）可重用性：把概念或功能相对独立的一个或一组相关模块定义为一个软部件。可组装在系统的任何位置，降低工作量。 （8）可移植性：软件从一个计算机系统或环境搬到另一个计算机系统或环境的难易程度。 （9）可追踪性：根据软件需求对软件设计、程序进行正向追踪，或根据软件设计、程序对软件需求的逆向追踪的能力。 （10）可互操作性：多个软件元素相互通信并协同完成任务的能力。 对于相对专业及需要的人员，需要了解下面的内容。 软件体系结构是具有一定形式的结构化元素，即构件的集合，包括处理构件、数据构件和连接构件。处理构件负责对数据进行加工，数据构件是被加工的信息，连接构件把体系结构的不同部分组组合连接起来。这一定义注重区分处理构件、数据构件和连接构件，这一方法在其他的定义和方法中基本上得到保持。[1] 软件体系结构表示了一个软件系统的高层结构，主要特点有： 1）软件系统结构是一个高层次上的抽象，它并不涉及具体的系统结构（比如 B/S 还是 C/S），也不关心具体的实现。 2）软件体系结构必须支持系统所要求的功能，在设计软件体系结构的时候，必须考虑系统的动态行为。 3）在设计软件体系结构的时候，必须考虑有现有系统的兼容性、安全性和可靠性。同时还要考虑系统以后的扩展性和伸缩性。所以有时候必须在多个不同方向的目标中进行决策。 软件体系结构贯穿于软件研发的整个生命周期内，具有重要的影响。这主要从以下三个方面来进行考察：利益相关人员之间的交流，系统设计的前期决策，可传递的系统级抽象。 当前已经有一些关于规范化软件体系结构，比如：ISO 的开放系统互联模型、X Window 系统等等。 软件需求包括 3 个不同的层次――业务需求、用户需求和功能需求。 业务需求（Businessrequirement）： 表示组织或客户高层次的目标。业务需求通常来自项目投资人、购买产品的客户、实际用户的管理者、市场营销部门或产品策划部门。业务需求描述了组织为什么要开发一个系统，即组织希望达到的目标。使用前景和范围（ vision and scope ）文档来记录业务需求，这份文档有时也被称作项目轮廓图或市场需求（project charter 或 market requirement ）文档。 用户需求（userrequirement）： 描述的是用户的目标，或用户要求系统必须能完成的任务。用例、场景描述和事件――响应表都是表达用户需求的有效途径。也就是说用户需求描述了用户能使用系统来做些什么。 功能需求（functionalrequirement）： 规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。功能需求有时也被称作行为需求（ behavioral requirement ），因为习惯上总是用 “应该” 对其进行描述：“系统应该发送电子邮件来通知用户已接受其预定”。功能需求描述是开发人员需要实现什么。 除此之外，每个系统还有各种非功能需求： 系统需求（systemrequirement）： 用于描述包含多个子系统的产品（即系统）的顶级需求。系统可以只包含软件系统，也可以既包含软件又包含硬件子系统。人也可以是系统的一部分，因此某些系统功能可能要由人来承担。 行业需求： 企业在招聘软件测试人员时主要看中应聘者的项目经验、逻辑思维能力、一定的技术能力和综合素质，而对学历、年龄、性别、工作经验等的要求较低，相对于 IT 行业其他职位而言，软件测试的入行更加容易。 就业岗位 Java 方向：JAVA 初级程序员、JAVA 计算程序员 、 JAVA 工程师 、J2EE 系统工程师等。 .Net 方向： .Net 程序员网站开发工程师 .Net 工程师等。 其它方向： 简单的管理信息系统开发和维护人员 、网页制作和客户端脚本程序编写人员 、初级数据库管理和维护人员 、数据库开发工程师 、系统分析设计工程 、软件项目配置管理员 、文档编写工程师。 软件工程就业前景分析 软件工程（服务外包）专业： 随着世界产业转移的加速，欧美、日本等发达国家将大量的软件开发业务转移到中国、印度等国家。据统计，目前全球软件外包市场规模超过 1000 亿元，我国软件服务外包产业总收入在未来三年将达 260 多亿美元，随之而来的是对软件服务外包人才的巨大需求，未来 5 年，国内服务外包产业人才需求量至少要达到 100 万。目前软件外包从业人员的薪资水平普遍高于一般软件开发人员，就业前景广阔。 Java 开发工程师： 据有关数据显示，目前，我国对软件人才的需求已达 20 万，并且以每年 20% 左右的速度增长。在未来几年，合格软件人才的需求将远大于供给。2010 年，我国软件人才的缺口已达 43.5 万，其中尤以 JAVA 人才最为缺乏。当前世界各地持有 Java Programmer 证书的人员供需差距极大，迫使企业不得不用高薪聘请 Java 程序员。因此，Java Programmer的含金量比一般的技术人员要高出很大一块。在美国、加拿大、澳大利亚、新加坡等发达国家和中等发达国家，持有 Java Programmer 认证证书的人年薪均在 4-10 万美金，而在国内持有 Java Programmer 认证的程序员也有极好的工作机会和很高的薪水。要想有个好的专业技术，首先得有扎实的技术作为基础，其次, 要经常了解专业方面的最新信息, 学习最新的技术; 再次实践经验必不可少, 在校期间通过多种渠道积累了实践经验, 如暑期有针对性的打工, 或通过熟人关系积累实践经验, 也可有目的性地参加见习培训, 学校安排的实习等等，了解行业有哪些职位, 以及这些职位需要什么技术, 有针对性地做好就业准备。 参考：专栏：软件工程 - CSDN博客https://blog.csdn.net/column/details/dongle-se.html]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS协议]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-3%2F</url>
    <content type="text"><![CDATA[HTTPS(一): HTTPS 协议概述、功能介绍一、前言1&gt; 随着互联网、特别是移动互联网的爆炸式发展，我们的生活已经和网络有了千丝万缕的关系，于是’网络安全问题’就越来越受到人们的关注。2&gt; 我们已知，百度已经上线了全站’HTTPS’ 的安全搜索，默认情况下，就会将 HTTP请求 转成 HTTPS请求。3&gt; 在 iOS 开发中，从 iOS 9.0 开始，苹果也引入了 ATS (App Transport Security 应用传输安全)，App Transport Security 的目标是提高 Apple 操作系统的安全性以及在此操作系统上运行的任何应用的安全性。4&gt; ATS要求应用程序在进行网络传输的时候，自动通过 HTTPS 传输而不是 HTTP。 二、HTTPS 协议概述2.1 简述1&gt; ‘两个名词’: ‘SSL’(Secure Sockets Layer 安全套接层) 和 ‘TLS’(Transport Layer Security 传输层安全)。2&gt; HTTPS 可以认为是 HTTP + SSL/TLS。3&gt; TLS 是 ‘传输层’ 加密协议，它的前身是 SSL 协议，SSL协议最早是由NetScape(网景)公司于1995年发布，1999年经过IETF(（The Internet Engineering Task Force 国际互联网工程任务组)讨论和规范后，改名为 TLS。4&gt; 若没有特别说明，SSL 和 TLS 说的都是同一个协议。5&gt; iOS 中，ATS 要求至少是 ‘TLS1.2’版本。 2.2 HTTP 和 TLS 在协议层的位置以及 TLS 协议的组成 1&gt; TLS 协议主要包含5个部分: ‘应用数据层协议’、’握手协议’、’报警协议’、’加密消息确认协议’、’心跳协议’。2&gt; TLS 协议本身又是由 record 协议传输的，record 协议的格式如上图最右所示。3&gt; 目前常用的 HTTP 协议是 ‘HTTP1.1’。4&gt; 常用的 TLS 协议版本有: ‘TLS1.2’、’TLS1.1’、’TLS1.0’ 和 ‘SSL3.0’。5&gt; ‘SSL3.0’ 和 ‘TLS1.0’ 都已经被证明不安全。6&gt; ‘TLS1.2’ 和 ‘TLS1.1’ 暂时没有已知的安全漏洞，比较安全，同时有大量扩展提升速度和性能，推荐使用这两个版本。7&gt; 需要关注一下 ‘TLS1.3’，将会是 TLS 协议的一次重大改革。不管是安全性还是用户访问速度都会有质的提升，不过目前还没有明确发布时间。8&gt; ‘HTTP2.0’ 已经正式定稿，这个由SPDY协议演化而来的协议相比 ‘HTTP1.1’ 又是一个非常重大的变动，能够明显提升应用层数据的传输效率。 ‘SPDY’: 2012年，Google推出了基于TCP的应用层协议SPDY（取speedy谐音，意谓更快）,目的是为了取代’HTTP1.1’。不过’HTTP2.0’定稿后，’SPDY’退出了历史舞台。 三、HTTPS 功能介绍百度使用 HTTPS 协议主要是为了保护用户隐私、防止流量劫持。 HTTP 本身是’明文传输’的，没有经过任何安全处理。 例如: 1&gt; 用户在百度搜索『葵花』，中间者完全能够查看到这个信息，并且有可能来骚扰用户。 2&gt; 也有用户投诉百度，发现首页或结果页有一个很大很大的广告，这也是中间者往页面插的广告。 3&gt; 如果劫持技术比较低劣，用户甚至无法访问百度。 常见「中间者」主要指一些 『网络节点』，是用户数据在浏览器和百度服务器中间传输必须要经过的节点。 常见网络节点: WIFI热点、路由器、防火墙、反向代理、缓存服务器等。 HTTPS 协议提供了三大功能来对抗『中间者』的劫持行为1&gt; ‘内容加密’ 浏览器到百度服务器的内容都是以加密形式传输，中间者无法直接查看原始内容。2&gt; ‘身份认证’ 保证用户访问的是百度服务器，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问百度服务器，有可能被劫持。3&gt; ‘数据完整性’ 防止内容被第三方冒充或者篡改。 HTTPS(二)：HTTPS 原理 - 内容加密 HTTPS 是如何做到『内容加密』、『身份认证』、『内容完整性』的？ 下面从原理角度看一下 HTTPS 原理介绍之内容加密TLS 握手过程中的 RSA 密钥协商以 TLS1.2 为例简单描述以下，省略跟密钥交换无关的握手消息。过程如下： 1. 客户端发送 client_hello, 包含一个随机数 random1。2. 服务器回复 server_hello，包含一个随机数 random2，同时回复 certificate，携带了证书公钥P。3. 客户端收到random2之后，就能够生成 premaster_secrect 以及 master_secrect。 其中，premaster_secrect 长度为48个字节，前两个字节是协议版本号，剩下的46个字节填充一个随机数。结构如下： 12345678 Struct &#123;byte Version[2]; bute random[46];&#125; ** master_secrect 的生成算法简述如下 Master_key = PRF(premaster_secrect, &quot;master secrect&quot;, 随机数1+随机数2) ``` 其中，PRF是一个随机函数，定义如下:```plain PRF(secrect, label, seed) = P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed) 而 master secrect 包含了6部分内容，分别是用于校验内容一致性的密钥，用于对称内容加解密的密钥，以及初始化向量(用于CBC模式)，客户端和服务器各一份，从上式可以看出，把premaster_key 赋值给 secrect，master key 赋值给 label，客户端和服务器的两个随机数做种子就能确定地求出一个 48位长的随机数。4. 客户端使用证书公钥P将 premaster_secrect加密后发送给服务器。5. 服务器使用私钥解密得到 premaster_secrect，又由于服务端之前就接收了随机数1，所以服务器根据相同的生成算法，在相同的输入参数下，求出了相同了 master secrect。 可以看出，密钥协商过程需要 2 个 RT(Route Trip)，这也是 HTTPS 慢的一个重要原因。而 RSA 发挥的关键作用就是对 premaster_secrect 进行了加密和解密。中间者不可能破解 RSA 算法，也就不可能知道 premaster_secrect，从而保证了密钥协商过程的安全性。 参考：HTTPS(一): HTTPS协议概述、功能介绍 - 简书https://www.jianshu.com/p/2e53c83a19ffHTTPS(二)：HTTPS原理-内容加密 - 简书https://www.jianshu.com/p/67bcb140d804]]></content>
      <tags>
        <tag>加密</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 加密算法 原理]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-2%2F</url>
    <content type="text"><![CDATA[密码学算法分类：123456789消息编码：Base64消息摘要：MD类，SHA类，MAC对称加密：DES，3DES，AES非对称加密：RSA，DH密钥交换数字签名：RSA signature，DSA signature 消息编码：Base64 原理开发者对 Base64 编码肯定很熟悉，是否对它有很清晰的认识就不一定了。实际上 Base64 已经简单到不能再简单了，如果对它的理解还是模棱两可实在不应该。大概介绍一下 Base64 的相关内容，花几分钟时间就可以彻底理解它。 一. Base64 编码由来 为什么会有 Base64 编码呢？因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像 ASCII 码的控制字符就不能通过邮件传送。这样用途就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情况下，做一种扩展方案来支持二进制文件的传送。把不可打印的字符也能用可打印字符来表示，问题就解决了。Base64 编码应运而生，Base64 就是一种基于 64 个可打印字符来表示二进制数据的表示方法。 二. Base64 编码原理 看一下 Base64 的索引表，字符选用了 “A-Z、a-z、0-9、+、/“ 64 个可打印字符。数值代表字符的索引，这个是标准 Base64 协议规定的，不能更改。64 个字符用 6 个 bit 位就可以全部表示，一个字节有 8 个 bit 位，剩下两个 bit 就浪费掉了，这样就不得不牺牲一部分空间了。这里需要弄明白的就是一个 Base64 字符是 8 个 bit，但是有效部分只有右边的 6 个 bit，左边两个永远是 0。 那么怎么用 6 个有效 bit 来表示传统字符的 8 个 bit 呢？8 和 6 的最小公倍数是 24，也就是说 3 个传统字节可以由 4 个 Base64 字符来表示，保证有效位数是一样的，这样就多了 1/3 的字节数来弥补 Base64 只有 6 个有效 bit 的不足。你也可以说用两个 Base64 字符也能表示一个传统字符，但是采用最小公倍数的方案其实是最减少浪费的。结合下边的图比较容易理解。Man 是三个字符，一共 24 个有效 bit，只好用 4 个 Base64 字符来凑齐 24 个有效位。红框表示的是对应的 Base64，6 个有效位转化成相应的索引值再对应 Base64 字符表，查出 “Man” 对应的 Base64 字符是 “TWFU”。说到这里有个原则不知道你发现了没有，要转换成 Base64 的最小单位就是三个字节，对一个字符串来说每次都是三个字节三个字节的转换，对应的是 Base64 的四个字节。这个搞清楚了其实就差不多了。 但是转换到最后你发现不够三个字节了怎么办呢？愿望终于实现了，我们可以用两个 Base64 来表示一个字符或用三个 Base64 表示两个字符，像下图的 A 对应的第二个 Base64 的二进制位只有两个，把后边的四个补 0 就是了。所以 A 对应的 Base64 字符就是1565730756@QQ.COM。上边已经说过了，原则是 Base64 字符的最小单位是四个字符一组，那这才两个字符，后边补两个 “=” 吧。其实不用 “=” 也不耽误解码，之所以用 “=”，可能是考虑到多段编码后的 Base64 字符串拼起来也不会引起混淆。由此可见 Base64 字符串只可能最后出现一个或两个 “=”，中间是不可能出现 “=” 的。下图中字符 “BC” 的编码过程也是一样的。 三. 总结 说起 Base64 编码可能有些奇怪，因为大多数的编码都是由字符转化成二进制的过程，而从二进制转成字符的过程称为解码。而 Base64 的概念就恰好反了，由二进制转到字符称为编码，由字符到二进制称为解码。 Base64 编码主要用在传输、存储、表示二进制等领域，还可以用来加密，但是这种加密比较简单，只是一眼看上去不知道什么内容罢了，当然也可以对 Base64 的字符序列进行定制来进行加密。 Base64 编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二进制时，产生的二进制是不一样的，所以最终产生的 Base64 字符也不一样。例如 “上网” 对应 utf-8 格式的 Base64 编码是 “5LiK572R”，对应 GB2312 格式的 Base64 编码是 “yc/N+A==”。 文章参考自 “ 维基百科 - Base64“ 消息摘要：MD类，SHA类，MAC 原理MD5 原理什么是 MD5 算法 MD5 讯息摘要演算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码杂凑函数，可以产生出一个 128 位元（16 位元组）的散列值（hash value），用于确保信息传输完整一致。 MD5 功能 输入任意长度的信息，经过处理，输出为 128 位的信息（数字指纹）；不同的输入得到的不同的结果（唯一性）； MD5 属不属于加密算法 认为不属于的人是因为他们觉得不能从密文（散列值）反过来得到原文，即没有解密算法，所以这部分人认为 MD5 只能属于算法，不能称为加密算法；认为属于的人是因为他们觉得经过 MD5 处理后看不到原文，即已经将原文加密，所以认为 MD5 属于加密算法；我个人支持前者，正如认为 BASE64 算法只能算编码一样。 MD5 算法是否可逆？ MD5 不可逆的原因是其是一种散列函数，使用的是 hash 算法，在计算过程中原文的部分信息是丢失了的。 不过有个地方值得指出的是，一个 MD5 理论上的确是可能对应无数多个原文的，因为 MD5 是有限多个的而原文可以是无数多个。比如主流使用的 MD5 将任意长度的 “字节串映射为一个 128bit 的大整数。也就是一共有 2^128 种可能，大概是 3.4*10^38，这个数字是有限多个的，而但是世界上可以被用来加密的原文则会有无数的可能性。 不过需要注意的一点是，尽量这是一个理论上的有限对无限，不过问题是这个无限在现实生活中并不完全成立，因为一方面现实中原文的长度往往是有限的（以常用的密码为例，一般人都在 20 位以内），另一方面目前想要发现两段原文对应同一个 MD5（专业的说这叫杂凑冲撞）值非常困难，因此某种意义上来说，在一定范围内想构建 MD5 值与原文的一一对应关系是完全有可能的。所以对于 MD5 目前最有效的攻击方式就是彩虹表，具体详情你可以通过谷歌了解。 MD5 相当于超损压缩。 MD5 用途 1. 防止被篡改：1）比如发送一个电子文档，发送前，我先得到 MD5 的输出结果 a。然后在对方收到电子文档后，对方也得到一个 MD5 的输出结果 b。如果 a 与 b 一样就代表中途未被篡改。2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的 MD5 输出结果。3）SVN 在检测文件是否在 CheckOut 后被修改过，也是用到了 MD5. 2. 防止直接看到明文：现在很多网站在数据库存储用户的密码的时候都是存储用户密码的 MD5 值。这样就算不法分子得到数据库的用户密码的 MD5 值，也无法知道用户的密码。（比如在 UNIX 系统中用户的密码就是以 MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成 MD5 值，然后再去和保存在文件系统中的 MD5 值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。） 3. 防止抵赖（数字签名）：这需要一个第三方认证机构。例如 A 写了一个文件，认证机构对此文件用 MD5 算法产生摘要信息并做好记录。若以后 A 说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是 A 写的了。这就是所谓的 “数字签名”。 MD5 安全性 普遍认为 MD5 是很安全，因为暴力破解的时间是一般人无法接受的。实际上如果把用户的密码 MD5 处理后再存储到数据库，其实是很不安全的。因为用户的密码是比较短的，而且很多用户的密码都使用生日，手机号码，身份证号码，电话号码等等。或者使用常用的一些吉利的数字，或者某个英文单词。如果我把常用的密码先 MD5 处理，把数据存储起来，然后再跟你的 MD5 结果匹配，这时我就有可能得到明文。比如某个 MD5 破解网站 http://www.cmd5.com/default.aspx，所以现在大多数网站密码的策略是强制要求用户使用数字大小写字母的组合的方式提高用户密码的安全度。 MD5 算法过程 对 MD5 算法简要的叙述可以为：MD5 以 512 位分组来处理输入的信息，且每一分组又被划分为 16 个 32 位子分组，经过了一系列的处理后，算法的输出由四个 32 位分组组成，将这四个 32 位分组级联后将生成一个 128 位散列值。 第一步、填充：如果输入信息的长度 (bit) 对 512 求余的结果不等于 448，就需要填充使得对 512 求余的结果等于 448。填充的方法是填充一个 1 和 n 个 0。填充完后，信息的长度就为 N*512+448(bit)； 第二步、记录信息长度：用 64 位来存储填充前信息长度。这 64 位加在第一步结果的后面，这样信息长度就变为 N512+448+64=(N+1)512 位。 第三步、装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是:（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L）。 第四步、四轮循环运算：循环的次数是分组的个数（N+1） 1）将每一 512 字节细分成 16 个小组，每个小组 64 位（8 个字节） 2）先认识四个线性函数 (&amp; 是与,| 是或,~ 是非,^ 是异或) 1234F(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z)G(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z))H(X,Y,Z)=X^Y^ZI(X,Y,Z)=Y^(X|(~Z)) 3）设 Mj 表示消息的第 j 个子分组（从 0 到 15），&lt;&lt; 1234FF(a,b,c,d,Mj,s,ti)表示a=b+((a+F(b,c,d)+Mj+ti)&lt;&lt;&lt;s)GG(a,b,c,d,Mj,s,ti)表示a=b+((a+G(b,c,d)+Mj+ti)&lt;&lt;&lt;s)HH(a,b,c,d,Mj,s,ti)表示a=b+((a+H(b,c,d)+Mj+ti)&lt;&lt;&lt;s)II(a,b,c,d,Mj,s,ti)表示a=b+((a+I(b,c,d)+Mj+ti)&lt;&lt;&lt;s) 4）四轮运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 第一轮a=FF(a,b,c,d,M0,7,0xd76aa478)b=FF(d,a,b,c,M1,12,0xe8c7b756)c=FF(c,d,a,b,M2,17,0x242070db)d=FF(b,c,d,a,M3,22,0xc1bdceee)a=FF(a,b,c,d,M4,7,0xf57c0faf)b=FF(d,a,b,c,M5,12,0x4787c62a)c=FF(c,d,a,b,M6,17,0xa8304613)d=FF(b,c,d,a,M7,22,0xfd469501)a=FF(a,b,c,d,M8,7,0x698098d8)b=FF(d,a,b,c,M9,12,0x8b44f7af)c=FF(c,d,a,b,M10,17,0xffff5bb1)d=FF(b,c,d,a,M11,22,0x895cd7be)a=FF(a,b,c,d,M12,7,0x6b901122)b=FF(d,a,b,c,M13,12,0xfd987193)c=FF(c,d,a,b,M14,17,0xa679438e)d=FF(b,c,d,a,M15,22,0x49b40821)第二轮a=GG(a,b,c,d,M1,5,0xf61e2562)b=GG(d,a,b,c,M6,9,0xc040b340)c=GG(c,d,a,b,M11,14,0x265e5a51)d=GG(b,c,d,a,M0,20,0xe9b6c7aa)a=GG(a,b,c,d,M5,5,0xd62f105d)b=GG(d,a,b,c,M10,9,0x02441453)c=GG(c,d,a,b,M15,14,0xd8a1e681)d=GG(b,c,d,a,M4,20,0xe7d3fbc8)a=GG(a,b,c,d,M9,5,0x21e1cde6)b=GG(d,a,b,c,M14,9,0xc33707d6)c=GG(c,d,a,b,M3,14,0xf4d50d87)d=GG(b,c,d,a,M8,20,0x455a14ed)a=GG(a,b,c,d,M13,5,0xa9e3e905)b=GG(d,a,b,c,M2,9,0xfcefa3f8)c=GG(c,d,a,b,M7,14,0x676f02d9)d=GG(b,c,d,a,M12,20,0x8d2a4c8a)第三轮a=HH(a,b,c,d,M5,4,0xfffa3942)b=HH(d,a,b,c,M8,11,0x8771f681)c=HH(c,d,a,b,M11,16,0x6d9d6122)d=HH(b,c,d,a,M14,23,0xfde5380c)a=HH(a,b,c,d,M1,4,0xa4beea44)b=HH(d,a,b,c,M4,11,0x4bdecfa9)c=HH(c,d,a,b,M7,16,0xf6bb4b60)d=HH(b,c,d,a,M10,23,0xbebfbc70)a=HH(a,b,c,d,M13,4,0x289b7ec6)b=HH(d,a,b,c,M0,11,0xeaa127fa)c=HH(c,d,a,b,M3,16,0xd4ef3085)d=HH(b,c,d,a,M6,23,0x04881d05)a=HH(a,b,c,d,M9,4,0xd9d4d039)b=HH(d,a,b,c,M12,11,0xe6db99e5)c=HH(c,d,a,b,M15,16,0x1fa27cf8)d=HH(b,c,d,a,M2,23,0xc4ac5665)第四轮a=II(a,b,c,d,M0,6,0xf4292244)b=II(d,a,b,c,M7,10,0x432aff97)c=II(c,d,a,b,M14,15,0xab9423a7)d=II(b,c,d,a,M5,21,0xfc93a039)a=II(a,b,c,d,M12,6,0x655b59c3)b=II(d,a,b,c,M3,10,0x8f0ccc92)c=II(c,d,a,b,M10,15,0xffeff47d)d=II(b,c,d,a,M1,21,0x85845dd1)a=II(a,b,c,d,M8,6,0x6fa87e4f)b=II(d,a,b,c,M15,10,0xfe2ce6e0)c=II(c,d,a,b,M6,15,0xa3014314)d=II(b,c,d,a,M13,21,0x4e0811a1)a=II(a,b,c,d,M4,6,0xf7537e82)b=II(d,a,b,c,M11,10,0xbd3af235)c=II(c,d,a,b,M2,15,0x2ad7d2bb)d=II(b,c,d,a,M9,21,0xeb86d391) 5）每轮循环后，将 A，B，C，D 分别加上 a，b，c，d，然后进入下一循环。 SHA 算法正文 本文主要讲述使用 SHA1 算法计算信息摘要的过程。 为保证传输信息的安全，除了对信息加密外，还需要对信息进行认证。认证的目的有两：一是验证信息的发送者是合法的，二是验证信息的完整性。Hash 函数就是进行信息认证的一种有效手段。 1.Hash 函数和消息完整性 Hash 函数也称为杂凑函数或散列函数，函数输入为一可变长度 x，输出为一固定长度串，该串被称为输入 x 的 Hash 值或数字指纹。 因为 Hash 函数是多对一函数，不同的输入对应着相同的输出，求其逆是比较难，通过给定的输入计算 Hash 值必须是很容易，但从 Hash 值逆推输入则很难，因此也称 Hash 函数为单向 Hash 函数。 Hash 函数一般满足以下几个基本需求： 1). 输入 x 可以任意长度 2). 输出数据长度固定 3). 容易计算，给定任何 x，容易计算出 x 的 Hash 值 4). 单向函数，即给出一个 Hash 值，很难反向计算出原始输入的 x 5). 唯一性，即难以找出两个不同的输入会得到相同的 Hash 输出值 Hash 值得长度由算法的类型决定，与输入的消息大小无关，一般为 128bit 或者 160bit，即使两个消息的差别很小，如仅差别一两位，其 Hash 函数的运算结果也会截然不同，用同一个算法对某一消息进行 Hash 运算只能获得唯一确定的 Hash 值。 一个安全的单向迭代函数是构造安全消息 Hash 值得核心和基础，有了好的单向迭代函数，就可以用合适的迭代方法来构造迭代 Hash 函数，Hash 函数的安全设计的理论主要有以下两点：一是函数的单向性，二是函数影射的随机性。常见的 Hash 算法有 MD-5、SHA 等。 2.SHA1 算法简介 SHA(Security Hash Algorithm) 是美国的 NIST 和 NSA 设计的一种标准的 Hash 算法，最初的版本于 93 年发表，称为 SHA-0，因为很快就被发现存在安全隐患，于是在 95 年就发布第二个版本 SHA-1。02 年，NIST 分别发布了 SHA-256、SHA-384、SHA-512，这些算法统称 SHA-2。08 年又新增了 SHA-224。目前 SHA-2 各版本已成为主流。 这里以 SHA1 为例来进行 SHA 算法的讲解，其他系列原理类似。SHA1 的特性有： 1). 不能使用消息摘要复原信息； 2). 不同的消息产生不同的消息摘要。 3. 术语和概念3.1 位 (Bit)**，字节（Byte）和字（Word）** SHA1 把消息当做位（bit）字符串进行处理。最小单位称为位，8 位组成一个字节，两个字节组成一个字。 例如，字符串 “abc” 转换成位字符串是 01100001 01100010 01100011，转换成 16 进制字符串是 0x616263。 3.2 **运算符和符号** 下面的逻辑运算符作用于 “字” X^Y = X， Y 逻辑与 X \/ Y = X， Y 逻辑或 X XOR Y= X， Y 逻辑异或 ~X = X 逻辑取反 X+Y 的定义：字 X 和 Y 代表两个整数 x 和 y, 其中 0 &lt;= x &lt; 2^32 且 0 &lt;= y &lt; 2^32. 令整数 z = (x + y) mod 2^32. 这时候 0 &lt;= z &lt; 2^32. 将 z 转换成字 Z, 那么就是 Z = X + Y. 循环左移位操作符 Sn(X)：X 是一个字，n 是一个整数，0&lt;=n&lt;=32。Sn(X) = (X&lt;&lt;n)OR(X&gt;&gt;32-n)。这个很容易理解了，比如 X=11111111 00000001 00000001 00000000，n=5，则 Sn(X)=111 00000001 00000001 00000000 11111。 X&lt;&lt;n 定义：抛弃最左边的 n 位数字，将各个位依次向左移动 n 位，然后用 0 填补右边的 n 位（最后结果还是 32 位）。 X&gt;&gt;n 定义：抛弃右边的 n 位，将各个位依次向右移动 n 位，然后在左边的 n 位填 0。 4.SHA1 算法4.1. 把消息转换为位字符串 因为 SHA1 算法只接受位作为输入，所以进行计算前必须把原始消息（比如字符串、文件等）转换成位字符串。 比如，对字符串 “abc” 产生消息摘要，‘a’=97 ‘b’=98 ‘c’=99，先转换成 24 位的字符串：01100001 01100010 01100011 4.2. 对转换得到的位字符串进行补位操作 消息必须进行补位，使其长度在对 512 取模以后的余数是 448，即（补位后的消息长度）%512 = 448。 对消息进行补位时，先在后面补一个 1，如果不满足要求，再补 0 直到满足对 512 取模余数为 448。这就意味着，补位至少补一位（原消息位数为 512n+447），最多补 512 位（原消息位数为 512n+448）。 还是以前面的 “abc” 为例显示补位的过程： 原始信息： 01100001 01100010 01100011 补位第一步，首先补一个 1：01100001 01100010 01100011 1 可以确定的是，如果用一个字节来表示一个字符，补 1 之后肯定不满足条件，仍需继续补位。 补位第二步，后面补 0 直到总长度对 512 取模余数为 448，这里补 423 个 0，使总长度达到为 448： 01100001 01100010 01100011 1000…..00 补位完成后的数据转换为 16 进制： 61626380 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 从 16 进制数据里可以看到，我们也可以直接采用 16 进制的方式进行补位，我们先补 80，看是否满足长度对 64 取余的结果为 56，不满足则继续补 0。 大家可以自己考虑一下为什么可以补 80。 4.3 附加长度信息 这一步中，要将原始消息（没有进行补位操作之前）的长度（二进制位数）附加到已经补位的消息之后。 通常用一个 64 位的数据来表示原始消息的长度。如果消息长度不大于 2^64，那么第一个字就是 0。 补长度的操作以后，整个消息（16 进制）如下： 61626380 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000018 然后，将整个消息拆分为一个一个的 512 位的数据块 M1，M2，…,Mn，然后分别对每一个数据块 Mi (1≤i≤n) 做处理，得到消息摘要。 注意，这里是 64 位，上一步补位后的长度是 512k+448,k≥0，这样，512k+448+64=512(k+1)，恰好可以被 512 整除。 在我们举得例子里，一共只有 512 位，因此做为一个数据块进行处理。 4.4 使用的常量和函数 一系列的常量字 K(0), K(1), … , K(79)，如果以 16 进制给出，它们如下： Kt = 0x5A827999 (0 &lt;= t &lt;= 19) Kt = 0x6ED9EBA1 (20 &lt;= t &lt;= 39) Kt = 0x8F1BBCDC (40 &lt;= t &lt;= 59) Kt = 0xCA62C1D6 (60 &lt;= t &lt;= 79) 在 SHA1 中我们需要一系列的函数。每个函数 ft (0 &lt;= t &lt;= 79) 都操作 32 位字 B，C，D 并且产生 32 位字作为输出。ft(B,C,D) 可以如下定义 ft(B,C,D) = (B AND C) OR ((NOT B) AND D) ( 0 &lt;= t &lt;= 19) ft(B,C,D) = B XOR C XOR D (20 &lt;= t &lt;= 39) ft(B,C,D) = (B AND C) OR (B AND D) OR (C AND D) (40 &lt;= t &lt;= 59) ft(B,C,D) = B XOR C XOR D (60 &lt;= t &lt;= 79) 4.5 计算消息摘要 使用进行了补位和补长度后的消息来计算消息摘要。 计算需要的缓冲区： 1). 两个都由 5 个 32 位的字组成缓冲区 BUF1 和 BUF2， BUF1 的 5 个 32 位缓冲区被标识为 A,B,C,D,E，BUF2 的 5 个 32 位缓冲区被标识为 H0,H1,H2,H3,H4。 2). 一个 80 个 32 位字的缓冲区 BUF3，按照 32 位划分，依次被标识为 W0, W1,…, W79。 3). 一个 1 个字的 TEMP 缓冲区。 计算消息摘要： 在 3.2 中，我们把补位之后的数据附加了长度信息，然后划分为一个一个的 512 位（16 个字）的数据块 M1,M2,…,Mn，这里会依次对每个数据块 Mi (1≤i≤n) 做处理。 在处理每个数据块 Mi (1≤i≤n) 之前，先将缓冲区 H0,H1,H2,H3,H4 初始化为下面的值（16 进制）： H0 = 0x67452301 H1 = 0xEFCDAB89 H2 = 0x98BADCFE H3 = 0x10325476 H4 = 0xC3D2E1F0. 接下来处理 Mi(1≤i≤n)，步骤如下： 1). 将每个 Mi 分成 16 个字（每个字 32 位） W0, W1, … , W15, W0 是最左边的字； n 个 Mi 就划分之后，就变成 W0,W1,…,W15,W16,…,W31,W32,…W79； 2). 对于 t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8 XOR Wt- 14 XOR Wt-16)； 3). 令 A = H0, B = H1, C = H2, D = H3, E = H4； 4) 对于 t = 0 到 79，执行下面的循环 TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt; E = D; D = C; C = S30(B); B = A; A = TEMP; 5). 令 H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. 在处理完所有的 Mi(1≤i≤n) 后，会得到一个 160 位（5 个 32 位字）的字符串消息摘要 H0 H1 H2 H3 H4。 对称加密：DES，3DES，AES 原理对称加密也称为常规加密、单钥加密，在非对称加密 (公钥加密) 开发之前是唯一使用的加密类型，直到现在，它也仍然是使用最广泛的加密类型之一。最常见对称加密算法是：DES、3DES、AES、RC4。 对称加密算法基本原理先上图，对称加密工作过程在整个工作过程中涉及到以下几个概念 明文：也就是原始信息或者说原始数据。也就是上图中的 A。 加密算法：对明文进行各种替换或转换操作的一种算法。也就是①过程执行的算法。 密钥：密钥也是加密算法的输入，加密算法进行替换或转换的具体操作依赖于这个密钥。也就是上图中描述的密钥 Key。 密文：经过加密算法打乱的消息输出。密文的输出取决于明文与密钥，对于相同的明文，不同的密钥会产生不同的密文。也就是上图中的 B。 解密算法：本质上来说就是加密算法的逆过程，算法输入的是密文和加密时使用的同一密钥。 对称加密的分类：流加密与分组加密 流加密每次加密数据流的一位 (bit) 或者一个字节(byte)。如 RC4。 分组加密 (通常也成为块加密) 是将明文进行分组，加密算法对每个分组分别加密，通常明文分组和加密后得到的密文分组等长。典型的分组大小是 64bit 或 128bit。如 DES，3DES，AES。 DESData Encryption Standard 数据加密标准，该标准中的数据加密算法 (Data Encryption Algorithm)，简称 DEA，国内对 DES 和 DEA 两个术语的使用有点混乱。DES 是 IBM 公司发明的，在 1977 年应征作为美国国家密码标准方案。随着 CPU 计算速度的提升，以及硬件成本的下降，1999 年美国国家标准技术研究所颁布新标准，规定 DES 只能用于历史遗留系统以及 3DES 中。DES 采用 64bit 分组长度和 56bit 密钥长度，经过一系列变换得到 64bit 的密文输出。解密使用相同的密钥对密文进行解密运算。 3DES 密钥大小 (bit) 密钥个数 每微秒执行一次解密所需要的时间 每微妙执行一百万次解密所需要的时间 56 256 = 7.2*1016 255μs=1142 年 10.01 小时 随着软硬件技术的发展，多核 CPU、分布式计算、量子计算等理论的实现，DES 在穷举方式的暴力攻击下还是相当脆弱的，因此很多人想办法用某种算法替代它，面对这种需求广泛被采用的有两种方案：1. 设计一套全新的算法，例如 AES，这个在后面会说到。2. 为了保护已有软硬件的投资，仍使用 DES，但使用多个密钥进行多次加密，这就是多重 DES 加密。 双重加密双重加密是多重加密最简单的形式，使用两个密钥。使用表达式叙述如下： 12345678910C： 代表加密后的密文(crypted)E： 代表加密算法(encrypt)D： 代表解密算法(decrypt)K1,K2： 代表两个密钥(key)P： 代表明文(proclaimed) 加密过程： C = E( K2, E( K1, P ) ) 解密过程： P = D( K1, D( K2, C) ) 双重 DES 加密表面上进行了两次加密，从而密钥长度为 56×2=112bit，密码强度增加了，但是在 1992 年在一篇论文中被证实存在下面的情况： 1E(K2, E(K1, P)) = E(K3, P) 也就是说存在密钥 K3 能解密经过 K1，K2 进行双重加密的密文，这意味着双重 DES 退化成了单重 DES 了。显然这种方式是不安全的。 使用两个密钥的三重加密1234加密过程: C = E( K1, D( K2, E( K1, P ) )解密过程: P = D( K1, E( K2, D( K1, C ) ) 这个加密方式就有意思了，先用 K1 进行加密，然后对加密的密文用 K2 进行解密，解密后的密文再用 K1 进行加密；解密过程就与之相反，并且该算法当 k1==k2 时能与单重 DES 兼容。这个奇特的想法最后也成为了美国的加密标准之一 X9.17。 使用三个密钥的三重加密1234加密过程: C = E( K3, D( K2, E( K1, P ) )解密过程: P = D( K3, E( K2, D( K1, C ) ) 这种加密方式 1998 年被列为美国加密标准 X9.52，并且已经广泛地替代了 DES。过程很好理解。如果需要与 DES 进行兼容，只需设置 K3=K2 或 K2=K1；如果需要与前面的双重密钥的三重加密兼容只需 k1=k3。 知道了 3DES 与 DES 的关系，那我们就可以推出 3DES 的密钥长度应该为 DES 的三倍也就是 168bit，输入的明文块和输出的密文块仍然是 64bit 的。 更多 3DES 的信息可以查看 wiki AES3DES 缺点是算法运行相对较慢。因为原来 DEA 是为 70 年代的硬件设计的，算法代码并不是很高效，而 3DES 是 DEA 算法的 3 轮迭代，因此更慢。而且 DEA 和 3DES 的分组大小都是 64bit，3DES 密钥长度却是 168bit，处于加密效率和安全的考虑，需要更大的分组长度。于是 AES 应运而生。 Advanced Encryption Standard 高级加密标准，该标准是美国国家标准技术研究所于 2001 年颁布的。AES 旨在取代 DES 成为广泛使用的标准，2006 年 AES 已成为最流行的对称加密算法。 AES 使用的分组大小为 128bit，密钥长度可以为 128、192、256 bit。最简单最常用的也就是 128 bit 的密钥。 AES 的详细内容可以查看 wiki 下面列个表，大致的总结一下分组加密算法。 分组 (块) 加密标准 分组大小 密钥长度 DES 64 bit = 8 byte 56 bit = 7 byte 3DES 64 bit = 8 byte 168 bit = 21 byte AES 128 bit = 16 byte 128 192 256 bit =16 24 32 byte 流加密实现原理真随机数，伪随机数因为随机数在加密算法中相当重要，而且 RC4 中就使用了伪随机数生成算法。所以有必要理解什么是伪随机数，什么事真随机数。看一下 Wiki 中对真随机数和伪随机数的界定。 根据密码学原理，随机数的随机性检验可以分为三个标准： 统计学伪随机性。统计学伪随机性指的是：在给定的随机比特流样本中，1 的数量大致等于 0 的数量，同理，“10”“01”“00”“11”四者数量大致相等。类似的标准被称为统计学随机性。满足这类要求的数字在人类 “一眼看上去” 是随机的。 密码学安全伪随机性。其定义为：给定随机样本的一部分和随机算法 (RNG,Random number generator)，不能有效的演算出随机样本的剩余部分。 真随机性。其定义为：随机样本不可重现。实际上只要给定边界条件，真随机数并不存在，可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉（比如计算机本身的辐射波动值），可以认为用这个方法演算出来了真随机数。 相应的，随机数也分为三类： 伪随机数：满足第一个条件的随机数。 密码学安全的伪随机数：同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出。 真随机数：同时满足三个条件的随机数。 真正的随机数是使用物理现象产生的：比如掷钱币、骰子、使用电子元件的噪音、核裂变等等。这样的随机数生成器叫做物理性随机数生成器，它们的缺点是技术要求比较高。 在实际应用中往往使用伪随机数就足够了。这些数列是 “似乎” 随机的数，实际上它们是通过一个固定的、可以重复的算法产生的(只是重复的周期比较大)。它们不真正地随机，因为它们实际上是可以计算出来的，但是它们具有类似于随机数的统计特征(分布均匀)。这样的生成器叫做伪随机数生成器(PRNG, pseudo-random number generator)。 流加密的基本原理流加密的原理很简单，用前面提到的伪随机数生成器 (PRNG) 根据秘钥来生成一个与明文长度一样的密钥流，然后将密钥流与明文流进行异或运算从而得到加密后的密文。解密时用同样的算法，根据密钥通过 PRNG 得到密钥流，将密钥流与密文进行异或运算即可。这里面遵循了一个很简单的原则：对一个数据进行两次相同的异或运算得到的还是原来的数据。 流加密的优缺点优点： 实现简单。流加密生成密钥流后，只要进行一次异或运算即可；而像 DES 这样的分组加密需要经过 Feistel 加密网络 (16 轮的置换操作)。 速度更快。因为流加密的简单操作少，所以速度也比分组加密块。 变长密钥。密钥只负责生成密钥流，密钥流的生成与密钥长度关系不大，这就使得流加密可以使用变长密钥。 RC4Rivest Cipher 4是 RSA 公司的成员 Ron Rivest 于 1987 年设计的 (RSA 是三个麻省理工大学的学生创立的，著名的非对称公钥加密算法 RSA 就是该公司发明的)。起初该算法是商业机密，直到 1994 年，才被公之于众。由于 RC4 具有算法简单，运算速度快，软硬件实现都十分容易等优点，使其在一些协议和标准里得到了广泛应用。比如：SSL/TLS(Secure Sockets Layer/Transport Layer Security)，无线局域网 WEP(Wired Equivalent Privacy) 协议和 WPA(Wi-Fi Protected Access) 中都有 RC4 的应用。 Ron Rivest 共设计了六套加密算法，都以 RC 命名，其中 RC4 是流加密方式实现的，RC2 是一种分组加密算法实现，RC6 更是 AES 算法征集的入围者，更多内容点击这里 非对称加密：RSA，DH密钥交换 原理 非对称加密算法 在日常的工作生产中， 我们经常需要进行数据的通讯，开发人员经常需要对数据进行加解密操作，以保证数据的安全。数据的加密算法非为对称加密和非对称加密两种，常用的 DES、三重DES、AES 等都属于对称加密，即通过一个密钥可以进行数据的加解密，密钥一旦泄漏，传输的数据则不安全。 非对称加密算法的核心源于数学问题，它存在公钥和私钥的概念，要完成加解密操作，需要两个密钥同时参与。我们常说的 “公钥加密，私钥加密” 或“私钥加密，公钥解密”都属于非对称加密的范畴，后文中讲到的RSA算法也一种典型的非对称加密算法。公钥加密的数据必须使用私钥才可以解密，同样，私钥加密的数据也只能通过公钥进行解密。相比对称加密，非对称加密的安全性得到了提升，但是也存在明显的缺点，非对称加解密的效率要远远小于对称加解密。所以非对称加密往往被用在一些安全性要求比较高的应用或领域中。 典型的 RSA 非对称加密 RSA加密算法是一种典型的非对称加密算法，它基于大数的因式分解数学难题，它也是应用最广泛的非对称加密算法，于 1978 年由美国麻省理工学院（MIT）的三位学着：Ron Rivest、Adi Shamir 和 Leonard Adleman 共同提出。 它的原理较为简单，我们假设有消息发送方 A 和消息接收方 B，通过下面的几个步骤，我们就可以完成消息的加密传递： 消息发送方 A 在本地构建密钥对，公钥和私钥； 消息发送方 A 将产生的公钥发送给消息接收方 B； B 向 A 发送数据时，通过公钥进行加密，A 接收到数据后通过私钥进行解密，完成一次通信； 反之，A 向 B 发送数据时，通过私钥对数据进行加密，B 接收到数据后通过公钥进行解密。 由于公钥是消息发送方 A 暴露给消息接收方 B 的，所以这种方式也存在一定的安全隐患，如果公钥在数据传输过程中泄漏，则 A 通过私钥加密的数据就可能被解密。 如果要建立更安全的加密消息传递模型，需要消息发送方和消息接收方各构建一套密钥对，并分别将各自的公钥暴露给对方，在进行消息传递时，A 通过 B 的公钥对数据加密，B 接收到消息通过 B 的私钥进行解密，反之，B 通过 A 的公钥进行加密，A 接收到消息后通过 A 的私钥进行解密。 当然，这种方式可能存在数据传递被模拟的隐患，我们可以通过数字签名等技术进行安全性的进一步提升。由于存在多次的非对称加解密，这种方式带来的效率问题也更加严重。 SSH 加密原理 在 SSH 安全协议的原理中， 是一种非对称加密与对称加密算法的结合，先看下图： 这里进行一下说明： 首先服务端会通过非对称加密，产生一个公钥和私钥； 在客户端发起请求时，服务端将公钥暴露给客户端，这个公钥可以被任意暴露； 客户端在获取公钥后，会先产生一个由 256 位随机数字组成的会话密钥，这里称为口令； 客户端通过公钥将这个口令加密，发送给服务器端； 服务器端通过私钥进行解密，获取到通讯口令； 之后，客户端和服务端的信息传递，都通过这个口令进行对称的加密。 个人感觉，这样的设计在一定程度上提高了加解密的效率，不过，与客户端服务端各构建一套密钥对的加解密方式相比，在安全性上可能有所下降。在上面所述的通过口令进行加密的过程中，数据也是可以被窃听的，不过由于密钥是 256 个随机数字，有 10 的 256 次方种组合方式，所以破解难度也很大。相对还是比较安全的。服务端和客户端都提前知道了密钥，SSH 的这种方式，服务端是通过解密获取到了密钥。 DH 密钥交换算法SSH 的原理，是基于 RSA 非对称加密，RSA 是基于大数的因式分解数学难题，下面要提到的 DH 密钥交换算法则是基于有限域上的离散对数难题。 DH 算法是一种密钥协商算法，只用于密钥的分配，不用于消息的加解密。它提供了一种安全的交换密钥的方式，通过交换的密钥进行数据的加解密。就像 SSH 原理中，口令的交换，不过 DH 算法更安全。 我们举个例子来进行说明，假设有 A、B 两方，A 作为发送者，B 作为接收者。通过下面的几个步骤就可以构建出一个只属于双方的密钥口令，如下： 首先 A、B 双方，在通信前构建专属于自己的密钥对，假设分别是公钥 A，私钥 A，公钥 B，私钥 B； A 将自己的公钥 A 暴露给 B，B 通过私钥 B和公钥 A 经过一定的运算产生出本地的密钥 B； 同样，B 将自己的公钥 B暴露给 A，A 通过私钥 A 和公钥 B 经过一定的运算产生出本地的密钥 A； 最后，这个算法有意思的一点就是，密钥 A 和密钥 B 是一致的，这样 A、B 双方就拥有了一个属于双方的 “秘密” 口令； DH 算法的产生是，对称加密向非对称加密的过渡，为后续非对称加密的产生和发展奠定了基础。 数字签名：RSA signature，DSA signature 原理数字签名流程（1）生成签名：对源文件的「数字摘要」，使用私钥加密，生成「加密数字摘要」； （2）验证签名：对「加密数字摘要」通过公钥进行解密，生成「数字摘要 2」，比较「数字摘要」与「数字摘要 2」，结果相同则签名验证通过。 概念：带有「公钥」和「私钥」的「消息摘要」算法，是「非对称加密算法」和「消息摘要」算法的结合体 私钥签名，公钥验证 常用签名算法 RSASignature DSASignature ECDSASignature（需 Bouncy Castle） 数字签名作用 验证数据完整性 认证数据来源 抗否认 场景如 Android App 开发者签名 参考：从原理上搞定编码（四）– Base64编码 - luguo3000 - 博客园http://www.cnblogs.com/luguo3000/p/3940197.htmlMD5算法原理及其实现 - CSDN博客https://blog.csdn.net/u012611878/article/details/54000607安全体系（三）——SHA1算法详解 - songoo - 博客园http://www.cnblogs.com/songwenlong/p/6528025.html密码学安全算法–对称加密算法 - CSDN博客https://blog.csdn.net/holmofy/article/details/72861821]]></content>
      <tags>
        <tag>Java</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 加密算法 实战]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-1%2F</url>
    <content type="text"><![CDATA[JAVA 加密算法（1）- 密码学概述及 BASE64 算法使用密码学基本功能机密性、鉴别、报文完整性、不可否认性 基本模型sender–&gt; 加密算法 –&gt; 密文 –&gt; 解密算法 –&gt; receiver 密钥源 密码学算法分类：123456789消息编码：Base64消息摘要：MD类，SHA类，MAC对称加密：DES，3DES，AES非对称加密：RSA，DH密钥交换数字签名：RSA signature，DSA signature 密码学五元组明文、密文、加密算法、解密算法、密钥 加密解密算法都要使用公开算法（经过验证） Java 编程中的常用类（1）消息编码 1BASE64Encoder，BASE64Decoder （2）消息摘要 1MessageDigest （3）对称密码 1KeyGenerator、SecretKey、Cipher （4）非对称密码 1KeyPairGenerator、KeyFactory、KeyPair、PublicKey、PrivateKey、Cipher （5）数字签名 1Signature JDK 提供的 Base64 编码操作12345678910111213141516171819202122232425import java.io.IOException;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;public class Base64Util &#123; public static String encrypt(byte[] data) &#123; return new BASE64Encoder().encode(data); &#125; public static String decrypt(String data) throws IOException &#123; return new String(new BASE64Decoder().decodeBuffer(data)); &#125; public static void main(String[] args) throws IOException &#123; String data = &quot;1234567890&quot;; String result = Base64Util.encrypt(data.getBytes()); System.out.println(data +&quot; 使用Base64编码的结果： &quot;+result); String result2 = Base64Util.decrypt(result); System.out.println(result + &quot;使用Base64解码的结果：&quot; +result2); &#125;&#125; 运行结果： 121234567890 使用Base64编码的结果： MTIzNDU2Nzg5MA==MTIzNDU2Nzg5MA==使用Base64解码的结果：1234567890 PS1:Eclipse 中找不到 sun.misc.BASE64Encoder 包的解决方法：在工程的 build path 中先移除 JRE System Library，再添加库 JRE System Library，重新编译后就一切正常了。 PS2:其他提供 Base64 操作的 jar 包，Apache Commons Codec（简称 CC），Bouncy Castle（BC） JAVA 加密算法（2）- 消息摘要算法（MD5、SHA、HMAC）消息摘要的概念 对消息通过一个单向 Hash 算法进行计算，得到一个唯一的结果。每个消息对应一个唯一结果，所有结果的长度固定。 消息摘要的分类（1）MD5（Message Digest）消息摘要算法（2）SHA（Secure Hash Algorithm）安全散列算法（3）MAC（Message Authentication Code）消息认证码算法，结合了 MD5 和 SHA 的优势，同时用密钥对摘要进行加密，是一种更为安全的消息摘要算法。 日常应用 校验数据的完整性，防止在传输途中被篡改 编程使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.io.File;import java.io.FileInputStream;import java.security.DigestInputStream;import java.security.MessageDigest;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;public class MessageDigestUtil &#123; /** * 计算MD5值 */ public static String encryptMD5(byte[] data) throws Exception &#123; MessageDigest messageDigest = MessageDigest.getInstance(&quot;MD5&quot;);//MD5,MD2 messageDigest.update(data); return BytesToHex.fromBytesToHex(messageDigest.digest()); &#125; /** * 计算文件的MD5值（指纹签名） */ public static String getFileMD5(String path) throws Exception &#123; FileInputStream fis = new FileInputStream(new File(path)); DigestInputStream dis = new DigestInputStream(fis, MessageDigest.getInstance(&quot;MD5&quot;)); try &#123; byte[] buffer = new byte[1024]; int read = dis.read(buffer, 0, 1024); while (read != -1) &#123; read = dis.read(buffer, 0, 1024); &#125; MessageDigest md = dis.getMessageDigest(); return BytesToHex.fromBytesToHex(md.digest()); &#125; finally &#123; dis.close(); fis.close(); &#125; &#125; /** * 计算SHA值 */ public static String encryptSHA(byte[] data) throws Exception &#123; MessageDigest messageDigest = MessageDigest.getInstance(&quot;SHA&quot;);//SHA,SHA1,SHA-1,SHA-256,SHA-384,SHA-512 messageDigest.update(data); return BytesToHex.fromBytesToHex(messageDigest.digest()); &#125; /** * 初始化HMAC密钥 */ public static byte[] initHmacKey() throws Exception &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;HmacSHA512&quot;);//HmacMD5,HmacSHA1,HmacSHA256,HmacSHA384,HmacSHA512 return keyGenerator.generateKey().getEncoded(); &#125; /** * 使用Hmac生成的密钥对数据进行加密 */ public static String encryptHmac(byte[] data, byte[] key) throws Exception &#123; SecretKey secretKey = new SecretKeySpec(key, &quot;HmacSHA512&quot;); Mac mac = Mac.getInstance(&quot;HmacSHA512&quot;); mac.init(secretKey); return BytesToHex.fromBytesToHex(mac.doFinal(data)); &#125; public static void main(String[] args) throws Exception &#123; String data = &quot;123456&quot;; String path = &quot;/Users/admin/Downloads/httpd-2.4.20.tar.gz&quot;; System.out.println(data + &quot; 的MD5值： &quot; + MessageDigestUtil.encryptMD5(data.getBytes())); System.out.println(path + &quot; 的文件MD5签名： &quot; + MessageDigestUtil.getFileMD5(path)); System.out.println(data + &quot; 的SHA值： &quot; + MessageDigestUtil.encryptSHA(data.getBytes())); byte[] hmacKey = initHmacKey(); System.out.println(&quot;初始化Hmac密钥：&quot; + BytesToHex.fromBytesToHex(hmacKey)); System.out.println(data + &quot; 是的Hmac加密值为： &quot; + MessageDigestUtil.encryptHmac(data.getBytes(), hmacKey)); &#125;&#125; 字节码数组转成 16 进制字符串工具类12345678910111213141516public class BytesToHex &#123; public static String fromBytesToHex(byte[] resultBytes) &#123; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; resultBytes.length; i++) &#123; if (Integer.toHexString(0xFF &amp; resultBytes[i]).length() == 1) &#123; builder.append(&quot;0&quot;).append( Integer.toHexString(0xFF &amp; resultBytes[i])); &#125; else &#123; builder.append(Integer.toHexString(0xFF &amp; resultBytes[i])); &#125; &#125; return builder.toString(); &#125;&#125; JAVA加密算法（3）- 对称加密算法（DES、3DES、AES）对称加密算法概念 加密密钥和解密密钥相同，大部分算法加密揭秘过程互逆。 特点：算法公开、（相比非对称加密）计算量小、加密速度快、效率高。 弱点：双方都使用同样的密钥，安全性得不到保证。 常用对称加密算法 DES（Data Encryption Standard） 3DES（DES 加强版，使用 3 次 DES 计算，Triple DES，DESede） AES（Advanced Encryption Standard，3DES 加强版） JDK 版 DES/3DES/AES 算法调用模板1. 生成密钥1234567891011//KeyGenerator，密钥生成器KeyGenerator keyGen = KeyGenerator.getInstance(&quot;DES&quot;);//算法：DES,DESede,AES//初始化密钥生成器keyGen.init(56); //各算法密钥长度不同，参见说明//生成密钥SecretKey secretKey = keyGen.generateKey();//生产字节码数据byte[] key = secretKey.getEncoded(); 说明：1. 通过「KeyGenerator.getInstance(“DES”)」生成密钥，2. 参数为算法名称：分别对应 DES、DESede（即 3DES）、AES3. 每种算法密钥长度参数：DES（56），3DES（112，168），AES（192，256） 2. 加 / 解密12345678910//通过字节码数据key 恢复密钥SecretKey secretKey = new SecretKeySpec(key, &quot;DES&quot;);//Cipher完成加密/解密工作Cipher cipher = Cipher.getInstance(&quot;DES&quot;);//根据密钥，对Cipher初始化，并选择加密还是解密cipher.init(Cipher.ENCRYPT_MODE, secretKey);byte[] result = cipher.doFinal(data); 1. 加密或解密都通过 cipher.init() 设置，参数：ENCRYPT_MODE/DECRYPT_MODE2. 加密或解密都通过 cipher.doFinal() 执行，获得 byte[] 类型结果。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;public class DESUtil &#123; /* * 生成密钥 */ public static byte[] initKey() throws Exception&#123; KeyGenerator keyGen = KeyGenerator.getInstance(&quot;DES&quot;); keyGen.init(56); SecretKey secretKey = keyGen.generateKey(); return secretKey.getEncoded(); &#125; /* * DES 加密 */ public static byte[] encrypt(byte[] data, byte[] key) throws Exception&#123; SecretKey secretKey = new SecretKeySpec(key, &quot;DES&quot;); Cipher cipher = Cipher.getInstance(&quot;DES&quot;); cipher.init(Cipher.ENCRYPT_MODE, secretKey); byte[] cipherBytes = cipher.doFinal(data); return cipherBytes; &#125; /* * DES 解密 */ public static byte[] decrypt(byte[] data, byte[] key) throws Exception&#123; SecretKey secretKey = new SecretKeySpec(key, &quot;DES&quot;); Cipher cipher = Cipher.getInstance(&quot;DES&quot;); cipher.init(Cipher.DECRYPT_MODE, secretKey); byte[] plainBytes = cipher.doFinal(data); return plainBytes; &#125; //Test public static void main(String[] args) throws Exception &#123; byte[] desKey = DESUtil.initKey(); System.out.println(&quot;DES KEY : &quot; + BytesToHex.fromBytesToHex(desKey)); byte[] desResult = DESUtil.encrypt(DATA.getBytes(), desKey); System.out.println(DATA + &quot;&gt;&gt;&gt;DES 加密结果&gt;&gt;&gt;&quot; + BytesToHex.fromBytesToHex(desResult)); byte[] desPlain = DESUtil.decrypt(desResult, desKey); System.out.println(DATA + &quot;&gt;&gt;&gt;DES 解密结果&gt;&gt;&gt;&quot; + new String(desPlain)); &#125;&#125; JAVA加密算法（4）- 非对称加密算法（DH，RSA）非对称密码概念 发送者使用接收者的公钥加密，接收者使用自己的私钥解密。 需要两个密钥进行加密或解密，分为公钥和私钥 特点：安全性高，速度慢 常用算法 DH 密钥交换算法 RSA 算法 ElGamal 算法 用途 密钥交换（DH） 双方在没有确定共同密钥的情况下，生成密钥，不提供加密工作，加解密还需要其他对称加密算法实现 加密 / 解密（RSA） 数字签名（RSA） DH 算法示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import javax.crypto.KeyAgreement;import javax.crypto.interfaces.DHPrivateKey;import javax.crypto.interfaces.DHPublicKey;import javax.crypto.spec.DHParameterSpec;import java.security.*;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.HashMap;import java.util.Map;//1 生成源密钥//2 把源公钥交给目标，目标通过源公钥，生成目标公钥和私钥//3 把目标公钥交给源//4 双方使用对方的公钥和和自己的私钥，生成本地密钥//5 如果双方生成本地密钥相同则完成密钥交换public class DHUtil &#123; public static final String PUBLIC_KEY = &quot;DH_Public_Key&quot;; public static final String PRIVATE_KEY = &quot;DH_Private_key&quot;; /** * 生成源密钥对 * @return * @throws Exception */ public static Map&lt;String,Object&gt; initSourceKey() throws Exception&#123; //创建KeyPairGenerator的实例，选用DH算法 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;DH&quot;); //初始化密钥长度，默认1024，可选范围512-65536 &amp; 64的倍数 keyPairGenerator.initialize(1024); //生成密钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); DHPublicKey dhPublicKey = (DHPublicKey) keyPair.getPublic(); DHPrivateKey dhPrivateKey = (DHPrivateKey) keyPair.getPrivate(); //将密钥对放入Map Map&lt;String,Object&gt; keyMap = new HashMap&lt;String, Object&gt;(); keyMap.put(PUBLIC_KEY, dhPublicKey); keyMap.put(PRIVATE_KEY, dhPrivateKey); return keyMap; &#125; /** * 通过源公钥 生成 目标密钥对 * @param sourcePublicKey * @return * @throws Exception */ public static Map&lt;String,Object&gt; initTargetKey(byte[] sourcePublicKey) throws Exception &#123; KeyFactory keyFactory = KeyFactory.getInstance(&quot;DH&quot;); //通过源公钥，生成keySpec，使用KeyFactory生成源PublicKey相关信息 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(sourcePublicKey); DHPublicKey sourcePublic = (DHPublicKey) keyFactory.generatePublic(keySpec); DHParameterSpec dhPublicKeyParams = sourcePublic.getParams(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;DH&quot;); keyPairGenerator.initialize(dhPublicKeyParams); KeyPair keyPair = keyPairGenerator.generateKeyPair(); DHPublicKey dhPublicKey = (DHPublicKey) keyPair.getPublic(); DHPrivateKey dhPrivateKey = (DHPrivateKey) keyPair.getPrivate(); //将密钥对放入Map Map&lt;String,Object&gt; keyMap = new HashMap&lt;String, Object&gt;(); keyMap.put(PUBLIC_KEY, dhPublicKey); keyMap.put(PRIVATE_KEY, dhPrivateKey); return keyMap; &#125; /** * 使用一方的公钥和另一方的私钥，生成本地密钥 * @return */ public static byte[] generateLocalSecretKey(byte[] aPublicKey, byte[] bPrivateKey) throws Exception&#123; KeyFactory keyFactory = KeyFactory.getInstance(&quot;DH&quot;); //通过A公钥，生成keySpec，使用KeyFactory生成A PublicKey相关信息 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(aPublicKey); PublicKey publicKey = keyFactory.generatePublic(keySpec); //通过B私钥，生成B PrivateKey相关信息 PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(bPrivateKey); PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec); //通过KeyAgreement对A的PublicKey和B的PrivateKey进行加密 KeyAgreement keyAgreement = KeyAgreement.getInstance(&quot;DH&quot;); keyAgreement.init(privateKey); keyAgreement.doPhase(publicKey,true); return keyAgreement.generateSecret(&quot;AES&quot;).getEncoded();//算法使用对称加密算法（DES，DESede，AES） //return keyAgreement.generateSecret(); // 也可以不选择算法，使用默认方法计算 &#125; //获取公钥字节数组 public static byte[] getPublicKey(Map&lt;String,Object&gt; map)&#123; return ((DHPublicKey) map.get(PUBLIC_KEY)).getEncoded(); &#125; //获取私钥字节数组 public static byte[] getPrivateKey(Map&lt;String,Object&gt; map)&#123; return ((DHPrivateKey) map.get(PRIVATE_KEY)).getEncoded(); &#125; public static void main(String[] args) throws Exception &#123; byte[] source_public_key; byte[] source_private_key; byte[] source_local_key; byte[] target_public_key; byte[] target_private_key; byte[] target_local_key; Map&lt;String, Object&gt; sourceKey = initSourceKey(); source_public_key = getPublicKey(sourceKey); source_private_key = getPrivateKey(sourceKey); System.out.println(&quot;源公钥：&quot;+BytesToHex.fromBytesToHex(source_public_key)); System.out.println(&quot;源私钥：&quot;+BytesToHex.fromBytesToHex(source_private_key)); Map&lt;String, Object&gt; targetKey = initTargetKey(getPublicKey(sourceKey)); target_public_key = getPublicKey(targetKey); target_private_key = getPrivateKey(targetKey); System.out.println(&quot;目标公钥：&quot;+BytesToHex.fromBytesToHex(target_public_key)); System.out.println(&quot;目标私钥：&quot;+BytesToHex.fromBytesToHex(target_private_key)); source_local_key = generateLocalSecretKey(target_public_key, source_private_key); target_local_key = generateLocalSecretKey(source_public_key, target_private_key); System.out.println(&quot;源本地密钥：&quot;+BytesToHex.fromBytesToHex(source_local_key)); System.out.println(&quot;目标本地密钥：&quot;+BytesToHex.fromBytesToHex(target_local_key)); &#125;&#125; RSA 加密 / 解密 示例 公钥加密，私钥解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import javax.crypto.Cipher;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PublicKey;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.util.HashMap;import java.util.Map;/** * RSA加密工具 */public class RSAUtil &#123; public static final String PUBLIC_KEY = &quot;RSA_Public_Key&quot;; public static final String PRIVATE_KEY = &quot;RSA_Private_Key&quot;; /** * 初始化密钥 * @return * @throws Exception */ public static Map&lt;String,Object&gt; initKey() throws Exception&#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); keyPairGenerator.initialize(1024);//512-65536 &amp; 64的倍数 KeyPair keyPair = keyPairGenerator.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String,Object&gt; keyMap = new HashMap&lt;String, Object&gt;(); keyMap.put(PUBLIC_KEY, publicKey); keyMap.put(PRIVATE_KEY, privateKey); return keyMap; &#125; public static RSAPublicKey getPublicKey(Map&lt;String,Object&gt; keyMap) &#123; return (RSAPublicKey) keyMap.get(PUBLIC_KEY); &#125; public static RSAPrivateKey getPrivateKey(Map&lt;String,Object&gt; keyMap)&#123; return (RSAPrivateKey) keyMap.get(PRIVATE_KEY); &#125; /** * 使用公钥对数据进行加密 * @param data * @param publicKey * @return * @throws Exception */ public static byte[] encrypt(byte[] data, RSAPublicKey publicKey) throws Exception&#123; Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.ENCRYPT_MODE,publicKey); return cipher.doFinal(data); &#125; /** * 使用私钥解密 * @param data * @param privateKey * @return * @throws Exception */ public static byte[] decrypt(byte[] data, RSAPrivateKey privateKey) throws Exception&#123; Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.DECRYPT_MODE,privateKey); return cipher.doFinal(data); &#125; public static void main(String[] args) throws Exception &#123; String data = &quot;周杰伦-东风破&quot;; Map&lt;String, Object&gt; keyMap = initKey(); byte[] miwen = encrypt(data.getBytes(),getPublicKey(keyMap)); System.out.println(&quot;加密后的内容：&quot;+BytesToHex.fromBytesToHex(miwen)); byte[] plain = decrypt(miwen, getPrivateKey(keyMap)); System.out.println(&quot;解密后的内容：&quot;+new String(plain)); &#125;&#125; JAVA加密算法（5）- 数字签名算法（RSA、DSA）数字签名流程（1）生成签名：对源文件的「数字摘要」，使用私钥加密，生成「加密数字摘要」； （2）验证签名：对「加密数字摘要」通过公钥进行解密，生成「数字摘要 2」，比较「数字摘要」与「数字摘要 2」，结果相同则签名验证通过。 概念：带有「公钥」和「私钥」的「消息摘要」算法，是「非对称加密算法」和「消息摘要」算法的结合体 私钥签名，公钥验证 常用签名算法 RSASignature DSASignature ECDSASignature（需 Bouncy Castle） 数字签名作用 验证数据完整性 认证数据来源 抗否认 场景如 Android App 开发者签名 RSASignature 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.security.*;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;public class RSASignatureUtil &#123; public static final String KEY_ALGORITHM = &quot;RSA&quot;;//密钥算法 public static final String SIGN_ALGORITHM = &quot;MD5withRSA&quot;;//签名算法：MD2withRSA,SHA1WithRSA,SHA256withRSA,SHA384withRSA,SHA512withRSA /** * 初始化RSA公钥私钥 */ public static KeyPair initKey() throws Exception&#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KEY_ALGORITHM); keyPairGenerator.initialize(1024); return keyPairGenerator.generateKeyPair(); &#125; /** * 签名（原数据，私钥 2要素） */ public static byte[] sign(byte[] data, PrivateKey privateKey) throws Exception&#123; PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded()); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey priKey = keyFactory.generatePrivate(keySpec); Signature signature = Signature.getInstance(SIGN_ALGORITHM); signature.initSign(priKey); signature.update(data);//设置要计算的数据 return signature.sign(); &#125; /** * 校验签名（元数据，公钥，签名 三要素） */ public static boolean valid(byte[] data, byte[] publicKey, byte[] sign) throws Exception&#123; KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKey); PublicKey pubKey = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGN_ALGORITHM); signature.initVerify(pubKey); signature.update(data); return signature.verify(sign); &#125; public static void main(String[] args) throws Exception &#123; String data = &quot;123456&quot;; KeyPair keyPair = initKey(); byte[] sign = sign(data.getBytes(),keyPair.getPrivate()); boolean isValid = valid(data.getBytes(),keyPair.getPublic().getEncoded(),sign); System.out.println(isValid); &#125;&#125; 参考：我有切糕 的文章 - SegmentFault 思否https://segmentfault.com/u/woyouqiegao/articles?page=1]]></content>
      <tags>
        <tag>Java</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 远程调用（RPC）面试]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01%2F</url>
    <content type="text"><![CDATA[远程方法调用 (RMI)78. 什么是 RMI？ Java 远程方法调用 (Java RMI) 是 Java API 对远程过程调用 (RPC) 提供的面向对象的等价形式，支持直接传输序列化的 Java 对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI 对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下 RMI 的一些注意事项。 79.RMI 体系结构的基本原则是什么？ RMI 体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI 允许定义行为的代码和实现行为的代码相分离，并且运行在不同的 JVM 上。 80.RMI 体系结构分哪几层？ RMI 体系结构分以下几层： 存根和骨架层 (Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的 RMI 服务。 远程引用层 (Remote Reference Layer)：RMI 体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。 传输层 (Transport layer)：这一层负责连接参与服务的两个 JVM。这一层是建立在网络上机器间的 TCP/IP 连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。 81.RMI 中的远程接口 (Remote Interface) 扮演了什么样的角色？ 远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。 82.java.rmi.Naming 类扮演了什么样的角色？ java.rmi.Naming 类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming 类的每一个方法接收一个 URL 格式的 String 对象作为它的参数。 83.RMI 的绑定 (Binding) 是什么意思？ 绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用 Naming 类的 bind() 或者 rebind() 方法跟名称相关联。 84.Naming 类的 bind() 和 rebind() 方法有什么区别？ bind() 方法负责把指定名称绑定给远程对象，rebind() 方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。 85. 让 RMI 程序能正确运行有哪些步骤？ 为了让 RMI 程序能正确运行必须要包含以下几个步骤： 编译所有的源文件。 使用 rmic 生成 stub。 启动 rmiregistry。 启动 RMI 服务器。 运行客户端程序。 86.RMI 的 stub 扮演了什么样的角色？ 远程对象的 stub 扮演了远程对象的代表或者代理的角色。调用者在本地 stub 上调用方法，它负责在远程对象上执行方法。当 stub 的方法被调用的时候，会经历以下几个步骤： 初始化到包含了远程对象的 JVM 的连接。 序列化参数到远程的 JVM。 等待方法调用和执行的结果。 反序列化返回的值或者是方法没有执行成功情况下的异常。 把值返回给调用者。 87. 什么是分布式垃圾回收 (DGC)？它是如何工作的？ DGC 叫做分布式垃圾回收。RMI 使用 DGC 来做自动垃圾回收。因为 RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动内存管理。 88.RMI 中使用 RMI 安全管理器 (RMISecurityManager) 的目的是什么？ RMISecurityManager 使用下载好的代码提供可被 RMI 应用程序使用的安全管理器。如果没有设置安全管理器，RMI 的类加载器就不会从远程下载任何的类。 89. 解释下 Marshalling 和 demarshalling。 当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做 Marshalling，反之就是 demarshalling。 90. 解释下 Serialization 和 Deserialization。 Java 提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。 参考:115个Java面试题和答案——终极列表（下） - ImportNewhttp://www.importnew.com/11028.html]]></content>
      <tags>
        <tag>面试</tag>
        <tag>PRC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 远程调用（RPC）实战]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-7%2F</url>
    <content type="text"><![CDATA[你应该知道的 RPC 原理在学校期间大家都写过不少程序，比如写个 hello world 服务类，然后本地调用下，如下所示。这些程序的特点是服务消费方和服务提供方是本地调用关系。 而一旦踏入公司尤其是大型互联网公司就会发现，公司的系统都由成千上万大大小小的服务组成，各服务部署在不同的机器上，由不同的团队负责。这时就会遇到两个问题：1）要搭建一个新服务，免不了需要依赖他人的服务，而现在他人的服务都在远端，怎么调用？2）其它团队要使用我们的新服务，我们的服务该怎么发布以便他人调用？下文将对这两个问题展开探讨。 123public interface HelloWorldService &#123; String sayHello(String msg);&#125; 12345678public class HelloWorldServiceImpl implements HelloWorldService &#123; @Override public String sayHello(String msg) &#123; String result = "hello world " + msg; System.out.println(result); return result; &#125;&#125; 123456public class Test &#123; public static void main(String[] args) &#123; HelloWorldService helloWorldService = new HelloWorldServiceImpl(); helloWorldService.sayHello("test"); &#125;&#125; 1 如何调用他人的远程服务？ 由于各服务部署在不同机器，服务间的调用免不了网络通信过程，服务消费方每调用一个服务都要写一坨网络通信相关的代码，不仅复杂而且极易出错。 如果有一种方式能让我们像调用本地服务一样调用远程服务，而让调用者对网络通信这些细节透明，那么将大大提高生产力，比如服务消费方在执行 helloWorldService.sayHello(“test”) 时，实质上调用的是远端的服务。这种方式其实就是 RPC（Remote Procedure Call Protocol），在各大互联网公司中被广泛使用，如阿里巴巴的 hsf、dubbo（开源）、Facebook 的 thrift（开源）、Google grpc（开源）、Twitter 的 finagle（开源）等。 要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个 RPC 调用的流程涉及到哪些通信细节： 1）服务消费方（client）调用以本地调用方式调用服务； 2）client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； 3）client stub 找到服务地址，并将消息发送到服务端； 4）server stub 收到消息后进行解码； 5）server stub 根据解码结果调用本地的服务； 6）本地服务执行并将结果返回给 server stub； 7）server stub 将返回结果打包成消息并发送至消费方； 8）client stub 接收到消息，并进行解码； 9）服务消费方得到最终结果。 RPC 的目标就是要 2~8 这些步骤都封装起来，让用户对这些细节透明。 1.1 怎么做到透明化远程服务调用？ 怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对 java 来说就是使用代理！java 代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现 RPC 框架时还是选择动态代理方式。 下面简单介绍下动态代理怎么实现我们的需求。我们需要实现 RPCProxyClient 代理类，代理类的 invoke 方法中封装了与远端服务通信的细节，消费方首先从 RPCProxyClient 获得服务提供方的接口，当执行 helloWorldService.sayHello(“test”) 方法时就会调用 invoke 方法。 123456789101112131415161718192021222324252627public class RPCProxyClient implements java.lang.reflect.InvocationHandler&#123; private Object obj; public RPCProxyClient(Object obj)&#123; this.obj=obj; &#125; /** * 得到被代理对象; */ public static Object getProxy(Object obj)&#123; return java.lang.reflect.Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), new RPCProxyClient(obj)); &#125; /** * 调用此方法执行 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //结果参数; Object result = new Object(); // ...执行通信相关逻辑 // ... return result; &#125;&#125; 12345public class Test &#123; public static void main(String[] args) &#123; HelloWorldService helloWorldService = (HelloWorldService)RPCProxyClient.getProxy(HelloWorldService.class); helloWorldService.sayHello("test");5 &#125;&#125; 1.2 怎么对消息进行编码和解码？1.2.1 确定消息数据结构 上节讲了 invoke 里需要封装通信细节，而通信的第一步就是要确定客户端和服务端相互通信的消息结构。客户端的请求消息结构一般需要包括以下内容： 1）接口名称 在我们的例子里接口名是 “HelloWorldService”，如果不传，服务端就不知道调用哪个接口了； 2）方法名 一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法； 3）参数类型 &amp; 参数值 参数类型有很多，比如有 bool、int、long、double、string、map、list，甚至如 struct（class）； 以及相应的参数值； 4）超时时间 5）requestID，标识唯一请求 id，在下面一节会详细描述 requestID 的用处。 同理服务端返回的消息结构一般包括以下内容。 1）返回值 2）状态 code 3）requestID 1.2.2 序列化 一旦确定了消息的数据结构后，下一步就是要考虑序列化与反序列化了。 什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。 什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。 为什么需要序列化？转换为二进制串后才好进行网络传输嘛！ 为什么需要反序列化？将二进制转换为对象才好进行后续处理！ 现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从 RPC 的角度上看，主要看三点： 1）通用性，比如是否能支持 Map 等复杂的数据结构； 2）性能，包括时间复杂度和空间复杂度，由于 RPC 框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少； 3）可扩展性，对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。 目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案来搭建 RPC 框架，这些都是久经考验的解决方案。 1.3 通信 消息数据结构被序列化为二进制串后，下一步就要进行网络通信了。目前有两种常用 IO 通信模型：1）BIO；2）NIO。一般 RPC 框架需要支持这两种 IO 模型，原理可参考：一个故事讲清楚 NIO。 如何实现 RPC 的 IO 通信框架呢？1）使用 java nio 方式自研，这种方式较为复杂，而且很有可能出现隐藏 bug，但也见过一些互联网公司使用这种方式；2）基于 mina，mina 在早几年比较火热，不过这些年版本更新缓慢；3）基于 netty，现在很多 RPC 框架都直接基于 netty 这一 IO 通信框架，省力又省心，比如阿里巴巴的 HSF、dubbo，Twitter 的 finagle 等。 1.4 消息里为什么要有 requestID？如果使用 netty 的话，一般会用 channel.writeAndFlush() 方法来发送消息二进制串，这个方法调用后对于整个远程调用 (从发出请求到接收到结果) 来说是一个异步的，即对于当前线程来说，将请求发送出来后，线程就可以往后执行了，至于服务端的结果，是服务端处理完成后，再以消息的形式发送给客户端的。于是这里出现以下两个问题： 1）怎么让当前线程 “暂停”，等结果回来后，再向后执行？ 2）如果有多个线程同时进行远程方法调用，这时建立在 client server 之间的 socket 连接上会有很多双方发送的消息传递，前后顺序也可能是随机的，server 处理完结果后，将结果消息发送给 client，client 收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？ 如下图所示，线程 A 和线程 B 同时向 client socket 发送请求 requestA 和 requestB，socket 先后将 requestB 和 requestA 发送至 server，而 server 可能将 responseA 先返回，尽管 requestA 请求到达时间更晚。我们需要一种机制保证 responseA 丢给 ThreadA，responseB 丢给 ThreadB。 怎么解决呢？ 1）client 线程每次通过 socket 调用一次远程接口前，生成一个唯一的 ID，即 requestID（requestID 必需保证在一个 Socket 连接里面是唯一的），一般常常使用 AtomicLong 从 0 开始累计数字生成唯一 ID； 2）将处理结果的回调对象 callback，存放到全局 ConcurrentHashMap 里面 put(requestID, callback)； 3）当线程调用 channel.writeAndFlush() 发送消息后，紧接着执行 callback 的 get() 方法试图获取远程返回的结果。在 get() 内部，则使用 synchronized 获取回调对象 callback 的锁，再先检测是否已经获取到结果，如果没有，然后调用 callback 的 wait() 方法，释放 callback 上的锁，让当前线程处于等待状态。 4）服务端接收到请求并处理后，将 response 结果（此结果中包含了前面的 requestID）发送给客户端，客户端 socket 连接上专门监听消息的线程收到消息，分析结果，取到 requestID，再从前面的 ConcurrentHashMap 里面 get(requestID)，从而找到 callback 对象，再用 synchronized 获取 callback 上的锁，将方法调用结果设置到 callback 对象里，再调用 callback.notifyAll() 唤醒前面处于等待状态的线程。 1234567public Object get() &#123; synchronized (this) &#123; // 旋锁 while (!isDone) &#123; // 是否有结果了 wait(); //没结果是释放锁，让当前线程处于等待状态 &#125; &#125; &#125; 1234567private void setDone(Response res) &#123; this.res = res; isDone = true; synchronized (this) &#123; //获取锁，因为前面wait()已经释放了callback的锁了 notifyAll(); // 唤醒处于等待的线程 &#125; &#125; 2 如何发布自己的服务？ 如何让别人使用我们的服务呢？有同学说很简单嘛，告诉使用者服务的 IP 以及端口就可以了啊。确实是这样，这里问题的关键在于是自动告知还是人肉告知。 人肉告知的方式：如果你发现你的服务一台机器不够，要再添加一台，这个时候就要告诉调用者我现在有两个 ip 了，你们要轮询调用来实现负载均衡；调用者咬咬牙改了，结果某天一台机器挂了，调用者发现服务有一半不可用，他又只能手动修改代码来删除挂掉那台机器的 ip。现实生产环境当然不会使用人肉方式。 有没有一种方法能实现自动告知，即机器的增添、剔除对调用方透明，调用者不再需要写死服务提供方地址？当然可以，现如今 zookeeper 被广泛用于实现服务自动注册与发现功能！ 简单来讲，zookeeper 可以充当一个服务注册表（Service Registry），让多个服务提供者形成一个集群，让服务消费者通过服务注册表获取具体的服务访问地址（ip + 端口）去访问具体的服务提供者。如下图所示： 具体来说，zookeeper 就是个分布式文件系统，每当一个服务提供者部署后都要将自己的服务注册到 zookeeper 的某一路径上: /{service}/{version}/{ip:port}, 比如我们的 HelloWorldService 部署到两台机器，那么 zookeeper 上就会创建两条目录：分别为 / HelloWorldService/1.0.0/100.19.20.01:16888 /HelloWorldService/1.0.0/100.19.20.02:16888。 zookeeper 提供了 “心跳检测” 功能，它会定时向各个服务提供者发送一个请求（实际上建立的是一个 Socket 长连接），如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除，比如 100.19.20.02 这台机器如果宕机了，那么 zookeeper 上的路径就会只剩 / HelloWorldService/1.0.0/100.19.20.01:16888。 服务消费者会去监听相应路径（/HelloWorldService/1.0.0），一旦路径上的数据有任务变化（增加或减少），zookeeper 都会通知服务消费方服务提供者地址列表已经发生改变，从而进行更新。 更为重要的是 zookeeper 与生俱来的容错容灾能力（比如 leader 选举），可以确保服务注册表的高可用性。 3 小结 RPC 几乎是每一个从学校进入互联网公司的同学都要首先学习的框架，之前面试过一个在大型互联网公司工作过两年的同学，对 RPC 还是停留在使用层面，这是不应该的，希望大家不仅要会用而且要知道内部的原理。本文也仅是对 RPC 的一个比较粗糙的描述，希望对大家有所帮助，错误之处也请指出修正。 4 一些开源的 RPC 框架https://github.com/alibaba/dubbo http://thrift.apache.org/?cm_mc_uid=87762817217214314008006&amp;cm_mc_sid_50200000=1444181090 参考：你应该知道的RPC原理 - zhanlijun - 博客园https://www.cnblogs.com/LBSer/p/4853234.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>PRC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 远程调用（RPC）原理]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-6%2F</url>
    <content type="text"><![CDATA[近几年的项目中，服务化和微服务化渐渐成为中大型分布式系统架构的主流方式，而 RPC 在其中扮演着关键的作用。在平时的日常开发中我们都在隐式或显式的使用 RPC，一些刚入行的程序员会感觉 RPC 比较神秘，而一些有多年使用 RPC 经验的程序员虽然使用经验丰富，但有些对其原理也不甚了了。缺乏对原理层面的理解，往往也会造成开发中的一些误用。 RPC 是什么？RPC 的全称是 Remote Procedure Call (远程过程调用)是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。 RPC 起源RPC 这个概念术语在上世纪 80 年代由 Bruce Jay Nelson 提出。这里我们追溯下当初开发 RPC 的原动机是什么？在 Nelson 的论文 “Implementing Remote Procedure Calls” 中他提到了几点： 1. 简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。2. 高效：过程调用看起来十分简单而且高效。3. 通用：在单机计算中过程往往是不同算法部分间最重要的通信机制。 通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 作成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。Nelson 的论文发表于 30 年前，其观点今天看来确实高瞻远瞩，今天我们使用的 RPC 框架基本就是按这个目标来实现的。 RPC 结构Nelson 的论文中指出实现 RPC 的程序包括 5 个部分： 1. User2. User-stub3. RPCRuntime4. Server-stub5. Server 这 5 个部分的关系如下图所示这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。 RPC 实现Nelson 论文中给出的这个实现结构也成为后来大家参考的标准范本。大约 10 年前，我最早接触分布式计算时使用的 CORBAR 实现结构基本与此类似。CORBAR 为了解决异构平台的 RPC，使用了 IDL（Interface Definition Language）来定义远程接口，并将其映射到特定的平台语言中。后来大部分的跨语言平台 RPC 基本都采用了此类方式，比如我们熟悉的 Web Service（SOAP），近年开源的 Thrift 等。他们大部分都通过 IDL 定义，并提供工具来映射生成不同语言平台的 user-stub 和 server-stub，并通过框架库来提供 RPCRuntime 的支持。不过貌似每个不同的 RPC 框架都定义了各自不同的 IDL 格式，导致程序员的学习成本进一步上升（苦逼啊），Web Service 尝试建立业界标准，无赖标准规范复杂而效率偏低，否则 Thrift 等更高效的 RPC 框架就没必要出现了。 IDL 是为了跨平台语言实现 RPC 不得已的选择，要解决更广泛的问题自然导致了更复杂的方案。而对于同一平台内的 RPC 而言显然没必要搞个中间语言出来，例如 java 原生的 RMI，这样对于 java 程序员而言显得更直接简单，降低使用的学习成本。目前市面上提供的 RPC 框架已经可算是五花八门，百家争鸣了。需要根据实际使用场景谨慎选型，需要考虑的选型因素我觉得至少包括下面几点：1. 性能指标2. 是否需要跨语言平台3. 内网开放还是公网开放4. 开源 RPC 框架本身的质量、社区活跃度 总结《浅出篇》大概就到这里结束了，《深入篇》会具体深入讲解一个 RPC 框架需要实现哪里基本功能，达到什么目标，并以在 java 平台上去具体实现一个 RPC 框架为例，分析其需要考虑的实现因素。 《深入篇》我们主要围绕 RPC 的功能目标和实现考量去展开，一个基本的 RPC 框架应该提供什么功能，满足什么要求以及如何去实现它？ RPC 功能目标RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用，在前文《浅出篇》中给出了一种实现结构，基于 stub 的结构来实现。下面我们将具体细化 stub 结构的实现。 RPC 调用分类RPC 调用分以下两种： 123451. 同步调用 客户方等待调用执行完成并返回结果。2. 异步调用 客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。 若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。 异步和同步的区分在于是否等待服务端执行完成并返回结果。 RPC 结构拆解《浅出篇》给出了一个比较粗粒度的 RPC 实现概念结构，这里我们进一步细化它应该由哪些组件构成，如下图所示。 RPC 服务方通过 RpcServer 去导出（export）远程接口方法，而客户方通过 RpcClient 去引入（import）远程接口方法。客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理RpcProxy 。代理封装调用信息并将调用转交给RpcInvoker 去实际执行。在客户端的RpcInvoker 通过连接器RpcConnector 去维持与服务端的通道RpcChannel，并使用RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。 RPC 服务端接收器 RpcAcceptor 接收客户端的调用请求，同样使用RpcProtocol 执行协议解码（decode）。解码后的调用信息传递给RpcProcessor 去控制处理调用过程，最后再委托调用给RpcInvoker 去实际执行并返回调用结果。 RPC 组件职责上面我们进一步拆解了 RPC 实现结构的各个组件组成部分，下面我们详细说明下每个组件的职责划分。 123456789101112131415161718191. RpcServer 负责导出（export）远程接口2. RpcClient 负责导入（import）远程接口的代理实现3. RpcProxy 远程接口的代理实现4. RpcInvoker 客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回 服务方实现：负责调用服务端接口的具体实现并返回调用结果5. RpcProtocol 负责协议编/解码6. RpcConnector 负责维持客户方和服务方的连接通道和发送数据到服务方7. RpcAcceptor 负责接收客户方请求并返回请求结果8. RpcProcessor 负责在服务方控制调用过程，包括管理调用线程池、超时时间等9. RpcChannel 数据传输通道 RPC 实现分析在进一步拆解了组件并划分了职责之后，这里以在 java 平台实现该 RPC 框架概念模型为例，详细分析下实现中需要考虑的因素。 导出远程接口导出远程接口的意思是指只有导出的接口可以供远程调用，而未导出的接口则不能。在 java 中导出接口的代码片段可能如下： 123DemoService demo = new ...;RpcServer server = new ...;server.export(DemoService.class, demo, options); 我们可以导出整个接口，也可以更细粒度一点只导出接口中的某些方法，如： 12// 只导出 DemoService 中签名为 hi(String s) 的方法server.export(DemoService.class, demo, "hi", new Class&lt;?&gt;[] &#123; String.class &#125;, options); java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。如果前面DemoService 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现，如： 12345DemoService demo = new ...;DemoService demo2 = new ...;RpcServer server = new ...;server.export(DemoService.class, demo, options);server.export("demo2", DemoService.class, demo2, options); 上面 demo2 是另一个实现，我们标记为 “demo2” 来导出，那么远程调用时也需要传递该标记才能调用到正确的实现类，这样就解决了多态调用的语义。 导入远程接口与客户端代理导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码，这种方式下实际导入的过程就是通过代码生成器在编译期完成的。我所使用过的一些跨语言平台 RPC 框架如 CORBAR、WebService、ICE、Thrift 均是此类方式。 代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。在 java 中导入接口的代码片段可能如下： 123RpcClient client = new ...;DemoService demo = client.refer(DemoService.class);demo.hi("how are you?"); 在 java 中’import’ 是关键字，所以代码片段中我们用 refer 来表达导入接口的意思。这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。java 里至少提供了两种技术来提供动态代码生成，一种是 jdk 动态代理，另外一种是字节码生成。动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色于直接的字节码生成的，而字节码生成在代码可读性上要差很多。两者权衡起来，个人认为牺牲一些性能来获得代码可读性和可维护性显得更重要。 协议编解码客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。我们先看下需要编码些什么信息： 123456789101112131415-- 调用编码 --1. 接口方法 包括接口名、方法名2. 方法参数 包括参数类型、参数值3. 调用属性 包括调用属性信息，例如调用附件隐式参数、调用超时时间等-- 返回编码 --1. 返回结果 接口方法中定义的返回值2. 返回码 异常返回码3. 返回异常信息 调用异常信息 除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。下面给出一种概念上的 RPC 协议消息设计格式： 123456789101112131415161718-- 消息头 --magic : 协议魔数，为解码设计header size: 协议头长度，为扩展设计version : 协议版本，为兼容设计st : 消息体序列化类型hb : 心跳消息标记，为长连接传输层心跳设计ow : 单向消息标记，rp : 响应消息标记，不置位默认是请求消息status code: 响应消息状态码reserved : 为字节对齐保留message id : 消息 idbody size : 消息体长度-- 消息体 --采用序列化编码，常见有以下格式xml : 如 webservie soapjson : 如 JSON-RPCbinary: 如 thrift; hession; kryo 等 格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。序列化我们关心三个方面：1. 序列化和反序列化的效率，越快越好。2. 序列化后的字节长度，越小越好。3. 序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。上面这三点有时是鱼与熊掌不可兼得，这里面涉及到具体的序列化库实现细节，就不在本文进一步展开分析了。 传输服务协议编码之后，自然就是需要将编码后的 RPC 请求消息传输到服务方，服务方执行后返回结果消息或确认消息给客户方。RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义了每个消息的唯一 id，因此可以更容易的复用连接。 既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区，因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升，反而会增加连接管理的开销。 连接是由 client 端发起建立并维持。如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位，就是用来标记心跳消息的，它对业务应用透明。 执行调用client stub 所做的事情仅仅是编码消息并传输给服务方，而真正调用过程发生在服务方。server stub 从前文的结构拆解中我们细分了 RpcProcessor 和 RpcInvoker 两个组件，一个负责控制调用过程，一个负责真正调用。这里我们还是以 java 中实现这两个组件为例来分析下它们到底需要做什么？ java 中实现代码的动态接口调用目前一般通过反射调用。除了原生的 jdk 自带的反射，一些第三方库也提供了性能更优的反射调用，因此 RpcInvoker 就是封装了反射调用的实现细节。 调用过程的控制需要考虑哪些因素，RpcProcessor 需要提供什么样地调用控制服务呢？下面提出几点以启发思考： 1234561. 效率提升 每个请求应该尽快被执行，因此我们不能每请求来再创建线程去执行，需要提供线程池服务。2. 资源隔离 当我们导出多个远程接口时，如何避免单一接口调用占据所有线程资源，而引发其他接口执行阻塞。3. 超时控制 当某个接口执行缓慢，而 client 端已经超时放弃等待后，server 端的线程继续执行此时显得毫无意义。 RPC 异常处理无论 RPC 怎样努力把远程调用伪装的像本地调用，但它们依然有很大的不同点，而且有一些异常情况是在本地调用时绝对不会碰到的。在说异常处理之前，我们先比较下本地调用和 RPC 调用的一些差异：1. 本地调用一定会执行，而远程调用则不一定，调用消息可能因为网络原因并未发送到服务方。2. 本地调用只会抛出接口声明的异常，而远程调用还会跑出 RPC 框架运行时的其他异常。3. 本地调用和远程调用的性能可能差距很大，这取决于 RPC 固有消耗所占的比重。正是这些区别决定了使用 RPC 时需要更多考量。当调用远程接口抛出异常时，异常可能是一个业务异常，也可能是 RPC 框架抛出的运行时异常（如：网络中断等）。业务异常表明服务方已经执行了调用，可能因为某些原因导致未能正常执行，而 RPC 运行时异常则有可能服务方根本没有执行，对调用方而言的异常处理策略自然需要区分。 由于 RPC 固有的消耗相对本地调用高出几个数量级，本地调用的固有消耗是纳秒级，而 RPC 的固有消耗是在毫秒级。那么对于过于轻量的计算任务就并不合适导出远程接口由独立的进程提供服务，只有花在计算任务上时间远远高于 RPC 的固有消耗才值得导出为远程接口提供服务。 总结至此我们提出了一个 RPC 实现的概念框架，并详细分析了需要考虑的一些实现细节。无论 RPC 的概念是如何优雅，但是 “草丛中依然有几条蛇隐藏着”，只有深刻理解了 RPC 的本质，才能更好地应用。 参考：深入浅出 RPC - 浅出篇 - CSDN博客https://blog.csdn.net/mindfloating/article/details/39473807深入浅出 RPC - 深入篇 - CSDN博客https://blog.csdn.net/mindfloating/article/details/39474123]]></content>
      <tags>
        <tag>Java</tag>
        <tag>PRC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 序列化]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-5%2F</url>
    <content type="text"><![CDATA[序列化与反序列化序列化 (Serialization) 是将对象的状态信息转换为可以存储或传输的形式的过程。一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。在网络传输过程中，可以是字节或是 XML 等格式。而字节的或 XML 编码格式可以还原完全相等的对象。这个相反的过程又称为反序列化。 Java 对象的序列化与反序列化在 Java 中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用该对象。但是，我们创建出来的这些 Java 对象都是存在于 JVM 的堆内存中的。只有 JVM 处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。 但是在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java 的对象序列化可以帮助我们实现该功能。 对象序列化机制（object serialization）是 Java 语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式再转换成对象。对象序列化可以很容易的在 JVM 中的活动对象和字节数组（流）之间进行转换。 在 Java 中，对象的序列化与反序列化被广泛应用到 RMI(远程方法调用) 及网络传输中。 相关接口及类Java 为了方便开发人员将 Java 对象进行序列化及反序列化提供了一套方便的 API 来支持。其中包括以下接口和类： java.io.Serializable java.io.Externalizable ObjectOutput ObjectInput ObjectOutputStream ObjectInputStream Serializable 接口类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。 (该接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？) 当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出NotSerializableException。 如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成java.io.Serializable接口。 下面是一个实现了java.io.Serializable接口的类 1234567891011121314151617181920212223242526272829303132333435package com.hollischaung.serialization.SerializableDemos;import java.io.Serializable;/** * Created by hollis on 16/2/17. * 实现Serializable接口 */public class User1 implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 通过下面的代码进行序列化及反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hollischaung.serialization.SerializableDemos; import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils; import java.io.*;/** * Created by hollis on 16/2/17. * SerializableDemo1 结合SerializableDemo2说明 一个类要想被序列化必须实现Serializable接口 */public class SerializableDemo1 &#123; public static void main(String[] args) &#123; //Initializes The Object User1 user = new User1(); user.setName("hollis"); user.setAge(23); System.out.println(user); //Write Obj to File ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream("tempFile")); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(oos); &#125; //Read Obj from File File file = new File("tempFile"); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); User1 newUser = (User1) ois.readObject(); System.out.println(newUser); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(ois); try &#123; FileUtils.forceDelete(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; //OutPut://User&#123;name='hollis', age=23&#125;//User&#123;name='hollis', age=23&#125; 更多关于 Serializable 的使用，请参考代码实例 Externalizable 接口除了 Serializable 之外，java 中还提供了另一个序列化接口Externalizable 为了了解 Externalizable 接口和 Serializable 接口的区别，先来看代码，我们把上面的代码改成使用 Externalizable 的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hollischaung.serialization.ExternalizableDemos; import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput; /** * Created by hollis on 16/2/17. * 实现Externalizable接口 */public class User1 implements Externalizable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void writeExternal(ObjectOutput out) throws IOException &#123; &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 12345678910111213141516171819202122232425262728package com.hollischaung.serialization.ExternalizableDemos; import java.io.*; /** * Created by hollis on 16/2/17. */public class ExternalizableDemo1 &#123; //为了便于理解和节省篇幅，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记 //IOException直接抛出 public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //Write Obj to file ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile")); User1 user = new User1(); user.setName("hollis"); user.setAge(23); oos.writeObject(user); //Read Obj from file File file = new File("tempFile"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); User1 newInstance = (User1) ois.readObject(); //output System.out.println(newInstance); &#125;&#125;//OutPut://User&#123;name='null', age=0&#125; 通过上面的实例可以发现，对 User1 类进行序列化及反序列化之后得到的对象的所有属性的值都变成了默认值。也就是说，之前的那个对象的状态并没有被持久化下来。这就是 Externalizable 接口和 Serializable 接口的区别： Externalizable 继承了 Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用 Externalizable 接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。由于上面的代码中，并没有在这两个方法中定义序列化实现细节，所以输出的内容为空。还有一点值得注意：在使用 Externalizable 进行序列化的时候，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现 Externalizable 接口的类必须要提供一个 public 的无参的构造器。 按照要求修改之后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hollischaung.serialization.ExternalizableDemos; import java.io.Externalizable;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectOutput; /** * Created by hollis on 16/2/17. * 实现Externalizable接口,并实现writeExternal和readExternal方法 */public class User2 implements Externalizable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(name); out.writeInt(age); &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; name = (String) in.readObject(); age = in.readInt(); &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 12345678910111213141516171819202122232425262728package com.hollischaung.serialization.ExternalizableDemos; import java.io.*; /** * Created by hollis on 16/2/17. */public class ExternalizableDemo2 &#123; //为了便于理解和节省篇幅，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记 //IOException直接抛出 public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //Write Obj to file ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile")); User2 user = new User2(); user.setName("hollis"); user.setAge(23); oos.writeObject(user); //Read Obj from file File file = new File("tempFile"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); User2 newInstance = (User2) ois.readObject(); //output System.out.println(newInstance); &#125;&#125;//OutPut://User&#123;name='hollis', age=23&#125; 这次，就可以把之前的对象状态持久化下来了。 如果 User 类中没有无参数的构造函数，在运行时会抛出异常：java.io.InvalidClassException 更多 Externalizable 接口使用实例请参考代码实例 ObjectOutput 和 ObjectInput 接口ObjectInput 接口 扩展自 DataInput 接口以包含对象的读操作。 DataInput 接口用于从二进制流中读取字节，并根据所有 Java 基本类型数据进行重构。同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具。 对于此接口中的所有数据读取例程来说，如果在读取所需字节数之前已经到达文件末尾 (end of file)，则将抛出 EOFException（IOException 的一种）。如果因为到达文件末尾以外的其他原因无法读取字节，则将抛出 IOException 而不是 EOFException。尤其是，在输入流已关闭的情况下，将抛出 IOException。 ObjectOutput扩展 DataOutput 接口以包含对象的写入操作。 DataOutput 接口用于将数据从任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流。同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具。 对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException。 ObjectOutputStream 类和 ObjectInputStream 类通过前面的代码片段中我们也能知道，我们一般使用 ObjectOutputStream 的writeObject方法把一个对象进行持久化。再使用 ObjectInputStream 的readObject从持久化存储中把对象读取出来。 更多关于 ObjectInputStream 和 ObjectOutputStream 的相关知识欢迎阅读我的另外两篇博文：深入分析 Java 的序列化与反序列化、单例与序列化的那些事儿 Transient 关键字Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。关于 Transient 关键字的拓展知识欢迎阅读深入分析 Java 的序列化与反序列化 序列化 ID虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID) 序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。 参考资料维基百科 理解 Java 对象序列化 Java 序列化的高级认识 参考：Java对象的序列化与反序列化 - ImportNewhttp://www.importnew.com/17964.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO面试]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-4%2F</url>
    <content type="text"><![CDATA[1. 什么是比特 (Bit), 什么是字节 (Byte), 什么是字符 (Char), 它们长度是多少, 各有什么区别 答案 Bit 最小的二进制单位 ，是计算机的操作部分 取值 0 或者 1Byte 是计算机操作数据的最小单位由 8 位 bit 组成 取值（-128-127）Char 是用户的可读写的最小单位，在 Java里面由 16 位 bit 组成 取值（0-65535） Bit 是最小单位 计算机 只能认识 0 或者 1 8 个字节 是给计算机看的字符 是看到的东西 一个字符 = 二个字节 2. 什么是流, 按照传输的单位, 分成哪两种流, 并且他们的父类叫什么流是指数据的传输 答案 字节流，字符流字节流：InputStream OutputStream字符流：Reader Writer 3. 流按照传输的方向可以分为哪两种, 分别举例说明 答案 输入输出相对于程序输入流 InputStream，输出流 OutputStream 4. 按照实现功能分为哪两种, 分别举例说明 答案 节点流，处理流节点流：OutputStream处理流： OutputStreamWriter 5.BufferedReader 属于哪种流, 它主要是用来做什么的, 它里面有那些经典的方法 答案 属于处理流中的缓冲流，可以将读取的内容存在内存里面，有 readLine（）方法 6. 什么是节点流, 什么是处理流, 它们各有什么用处, 处理流的创建有什么特征 答案 节点流 直接与数据源相连，用于输入或者输出处理流：在节点流的基础上对之进行加工，进行一些功能的扩展处理流的构造器必须要 传入节点流的子类 7. 如果我要对字节流进行大量的从硬盘读取, 要用那个流, 为什么 答案 BufferedInputStream 使用缓冲流能够减少对硬盘的损伤 8. 如果我要打印出不同类型的数据到数据源, 那么最适合的流是那个流, 为什么 答案 Printwriter 可以打印各种数据类型 9. 怎么样把我们控制台的输出改成输出到一个文件里面, 这个技术叫什么 答案 SetOut（printWriter,printStream）重定向 11. 怎么样把输出字节流转换成输出字符流, 说出它的步骤 答案 使用 转换处理流 OutputStreamWriter 可以将字节流转为字符流New OutputStreamWriter（new FileOutputStream（File file））; 12. 把包括基本类型在内的数据和字符串按顺序输出到数据源，或者按照顺序从数据源读入，一般用哪两个流 答案 DataInputStream DataOutputStream 13. 把一个对象写入数据源或者从一个数据源读出来, 用哪两个流 答案 ObjectInputStream ObjectOutputStream 14. 什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作 答案 对象序列化，将对象以二进制的形式保存在硬盘上反序列化；将二进制的文件转化为对象读取实现 serializable 接口 不想让字段放在硬盘上就加 transient 15. 如果在对象序列化的时候不想给一个字段的数据保存在硬盘上面, 采用那个关键字? 答案 transient 关键字 16. 在实现序列化接口是时候一般要生成一个 serialVersionUID 字段, 它叫做什么, 一般有什么用 答案 是版本号，要保持版本号的一致 来进行序列化 为了防止序列化出错 17.InputStream 里的 read() 返回的是什么, read(byte[] data) 是什么意思, 返回的是什么值 答案 返回的是所读取的字节的 int 型（范围 0-255）read（byte [ ] data）将读取的字节储存在这个数组返回的就是传入数组参数个数 Read 字节读取字节 字符读取字符 18.OutputStream 里面的 write() 是什么意思, write(byte b[], int off, int len) 这个方法里面的三个参数分别是什么意思 答案 write 将指定字节传入数据源Byte b[ ] 是 byte 数组b[off] 是传入的第一个字符b[off+len-1] 是传入的最后的一个字符len 是实际长度 19. 流一般需要不需要关闭, 如果关闭的话在用什么方法, 一般要在那个代码块里面关闭比较好，处理流是怎么关闭的，如果有多个流互相调用传入是怎么关闭的？ 答案 流一旦打开就必须关闭，使用 close 方法放入 finally 语句块中（finally 语句一定会执行）调用的处理流就关闭处理流多个流互相调用只关闭最外层的流 20.Java 中的所有的流可以分为几大类, 它们的名字是什么, 各代表什么 答案 分为:字节输入流 InputStream字节输出流 OutputStream字符输入流 Reader字符输出流 Writer所有流都是这四个流的子类 说下常用的 io 流 Icon InputStream,OutputStream,FileInputStream,FileOutputStream,BufferedInputStream,BufferedOutputStreamReader,WriterBufferedReader,BufferedWriter 21 写一段代码读取一个序列化的对象一般使用哪种 Stream？ Icon A、InputStream B、FileReader C、DataInputStream D、ObjectStream 22 io 流怎样读取文件的？ Icon 使用 File 对象获取文件路径，通过字符流 Reader 加入文件，使用字符缓存流 BufferedReader 处理 Reader，再定义一个字符串，循环遍历出文件。代码如下：File file = new File(“d:/spring.txt”);try {Reader reader = new FileReader(file);BufferedReader buffered = new BufferedReader(reader);String data = null;while((data = buffered.readLine())!=null){System.out.println(data);}} catch (FileNotFoundException e) {e.printStackTrace();} catch (IOException e) {e.printStackTrace();} 23 说说你对 io 流的理解 Icon Io 流主要是用来处理输入输出问题，常用的 io 流有 InputStream，OutputStream，Reader，Writer 等 24 JAVA 的 IO 流和 readLine 方法 Icon Java 的 io 流用来处理输入输出问题，readLine 是 BufferedReader 里的一个方法，用来读取一行。 25 用什么把对象动态的写入磁盘中，写入要实现什么接口。 Icon ObjectInputStream，需要实现 Serializable 接口 26 FileInputStream 创建详情，就是怎样的创建不报错，它列出了几种形式! Icon FileInputStream 是 InputStream 的子类，通过接口定义，子类实现创建 FileInputStream, 27 用 io 流中的技术，指定一个文件夹的目录，获取此目录下的所有子文件夹路径28 请问你在什么情况下会在你得 java 代码中使用可序列化？ 如何实现 java 序列化？ Icon 把一个对象写入数据源或者从一个数据源读出来，使用可序列化，需要实现 Serializable 接口28 PrintStream、BufferedWriter、PrintWriter 的比较?PrintStream 类的输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成 PrintStream 后进行输出。它还提供其他两项功能。与其他输出流不同，PrintStream 永远不会抛出 IOException；而是，异常情况仅设置可通过 checkError 方法测试的内部标志。另外，为了自动刷新，可以创建一个 PrintStreamBufferedWriter: 将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过 write() 方法可以将获取到的字符输出，然后通过 newLine() 进行换行操作。BufferedWriter 中的字符流必须通过调用 flush 方法才能将其刷出去。并且 BufferedWriter 只能对字符流进行操作。如果要对字节流操作，则使用 BufferedInputStream。 PrintWriter 的 println 方法自动添加换行，不会抛异常，若关心异常，需要调用 checkError 方法看是否有异常发生，PrintWriter 构造方法可指定参数，实现自动刷新缓存（autoflush）； 1. 读写原始数据，一般采用什么流？（AC ）A InputStreamB DataInputStreamC OutputStreamD BufferedInputStream2. 为了提高读写性能，可以采用什么流？（ DF）A InputStreamB DataInputStreamC BufferedReaderD BufferedInputStreamE OutputStreamF BufferedOutputStream3. 对各种基本数据类型和 String 类型的读写，采用什么流？（ AD）A DataInputStreamB BufferedReaderC PrintWriterD DataOutputStreamE ObjectInputStreamF ObjectOutputStream4. 能指定字符编码的 I/O 流类型是：（BH ）A ReaderB InputStreamReaderC BufferedReaderD WriterE PrintWriterF ObjectInputStreamG ObjectOutputStreamH OutputStreamWriter5. File 类型中定义了什么方法来判断一个文件是否存在？（ D）A createNewFileB renameToC deleteD exists6. File 类型中定义了什么方法来创建一级目录？（ CD）A createNewFileB existsC mkdirsD mkdir File 类的 mkdir 方法根据抽象路径创建目录；File 类的 mkdirs 方法根据抽象路径创建目录，包括创建必需但不存在的父目录 7. 对文本文件操作用什么 I/O 流？（AD ）A FileReaderB FileInputStreamC RandomAccessFileD FileWriter8. 在 unix 服务器 www.openlab.com.cn 上提供了基于 TCP 的时间服务应用，该应用使用 port 为 13。创建连接到此服务器的语句是：（A ）A Socket s = new Socket(“www.openlab.com.cn”, 13);B Socket s = new Socket(“www.openlab.com.cn:13”);C Socket s = accept(“www.openlab.com.cn”, 13);9. 创建一个 TCP 客户程序的顺序是：（DACBE ）A 获得 I/O 流B 关闭 I/O 流C 对 I/O 流进行读写操作D 建立 socketE 关闭 socket10. 创建一个 TCP 服务程序的顺序是：（BCADEGF ）A 创建一个服务线程处理新的连接B 创建一个服务器 socketC 从服务器 socket 接受客户连接请求D 在服务线程中，从 socket 中获得 I/O 流E 对 I/O 流进行读写操作，完成与客户的交互F 关闭 socketG 关闭 I/O 流11. Java UDP 编程主要用到的两个类型是：（ BD）A UDPSocketB DatagramSocketC UDPPacketD DatagramPacket12. TCP/IP 是一种：（ B）A 标准B 协议C 语言D 算法 参考：java IO流面试总结 - CSDN博客https://blog.csdn.net/baidu_37107022/article/details/76890019]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO总结]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-3%2F</url>
    <content type="text"><![CDATA[字符流： Reader： 用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。 |—BufferedReader ：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 |—LineNumberReader ：跟踪行号的缓冲字符输入流。此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号。 |—InputStreamReader ：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 |—FileReader： ：用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。 |—CharArrayReade |—StringReader Writer： 写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。 |—BufferedWriter： ：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 |—OutputStreamWriter ：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 |—FileWriter： ：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。 |—PrintWrite |—CharArrayWriter |—StringWriter 字 节 流： InputStream： 是表示字节输入流的所有类的超类。 |— FileInputStream： ：从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。FileInputStream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。 |— FilterInputStream： ：包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。 |— BufferedInputStream ：该类实现缓冲的输入流。 |— Stream ： |— ObjectInputStream ： |— PipedInputStream OutputStream：此抽象类是表示输出字节流的所有类的超类。 |— FileOutputStream ：文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。 |— FilterOutputStream ：此类是过滤输出流的所有类的超类。 |— BufferedOutputStream ：该类实现缓冲的输出流。 |— PrintStream ： |— DataOutputStream ： |— ObjectOutputStream ： |— PipedOutputStream： 规律总结 IO 流中的对象：其实很简单，就是读取和写入。但是因为功能的不同，流的体系中提供 N 多的对象。那么开始时，到底该用哪个对象更为合适呢？这就需要明确流的操作规律。 1 ，明确源和目的。 数据源：就是需要读取，可以使用两个体系：InputStream、Reader； 数据汇：就是需要写入，可以使用两个体系：OutputStream、Writer； 2 ，操作的数据是否是纯文本数据？ 如果是：数据源：Reader 数据汇：Writer 如果不是：数据源：InputStream 数据汇：OutputStream 3 ，虽然确定了一个体系，但是该体系中有太多的对象，到底用哪个呢？明确操作的数据设备。 数据源对应的设备：硬盘 (File)，内存 (数组)，键盘 (System.in) 数据汇对应的设备：硬盘 (File)，内存 (数组)，控制台 (System.out)。 4 ，需要在基本操作上附加其他功能吗？比如缓冲。 如果需要就进行装饰。 根据规律实例化演示需求：读取键盘录入，将数据存储到一个文件中。规律分析1，明确体系： 源：InputStream ，Reader 目的：OutputStream ，Writer 2，明确数据： 源：是纯文本吗？是 Reader 目的；是纯文本吗？是 Writer 3，明确设备： 源：键盘，System.in 目的：硬盘，FileWriter InputStream in = System.in; FileWriter fw = new FileWriter(“a.txt”); 4，需要额外功能吗？ 需要，因为源明确的体系是 Reader。可是源的设备是 System.in。所以为了方便于操作文本数据，将源转成字符流。需要转换流。 1234InputStreamReader InputStreamReader isr = new InputStreamReader(System.in);FileWriter fw = new FileWriter(“a.txt”);BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));BufferedWriter bufw = new BufferedWriter(new FileWriter(“a.txt”)); 代码实现1234567891011121314151617181920212223242526272829303132333435/** * 通过键盘录入文字输出到文件 */public static void test3() &#123; BufferedWriter bufferedWriter = null; BufferedReader bufferedReader = null; try &#123; bufferedWriter = new BufferedWriter( new OutputStreamWriter( new FileOutputStream( "E:\\kejiang\\IdeaProjects\\JavaProjectTest\\src\\io\\SystemOut.txt"),"UTF-8")); bufferedReader = new BufferedReader(new InputStreamReader(System.in)); String s = ""; while ((s = bufferedReader.readLine()) != null) &#123; if ("over".equals(s)) &#123; break; &#125; bufferedWriter.write(s.toUpperCase()); bufferedWriter.newLine(); bufferedWriter.flush(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; bufferedWriter.close(); bufferedReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行效果 控制台 123456这是通过键盘录入的数据测试一下overProcess finished with exit code 0 输出的文件 参考：Java IO流之规律总结 - CSDN博客https://blog.csdn.net/linglongxin24/article/details/52840580]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO学习笔记]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-1%2F</url>
    <content type="text"><![CDATA[Java IO 学习笔记（一）：File 类在整个 IO 包里，唯一表示与文件本身有关的类就是 File 类。使用 File 类可以进行创建或删除文件等常用操作。要想使用 File 类。则首先要观察 File 类的构造方法，此类的常用构造方法如下所示： public File(String pathname) 实例化 File 类的时候，必须设置好路径 实例操作一：创建一个新文件在 D 盘创建一个 test.txt 文件 12345678910111213import java.io.File;import java.io.IOException;public class Test1 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator+"test.txt");//为增加可移植性，建议使用File.separator try &#123; f.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实例操作二：删除一个指定文件删除刚刚创建的 test.txt 文件 12345678910import java.io.File;public class Test2 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator+"test.txt"); if(f.exists())&#123;//判断文件存不存在，如不存在就不用删除了 f.delete(); &#125; &#125;&#125; 实例操作三：综合创建，删除文件的操作给定一个路径，如果此文件存在，则删除，如果不存在，则创建 1234567891011121314151617import java.io.File;import java.io.IOException;public class Test3 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator+"test.txt"); if(f.exists())&#123; f.delete(); &#125;else&#123; try &#123; f.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 实例操作五：列出指定目录的全部文件如果现在给出了一个目录，则可以直接列出目录中的内容。但是列出的方法在 File 类中存在两个： 以字符串数组的形式返回：public String[] list() 以 File 数组的形式返回：public File[] listFiles() 操作一：使用 list() 列出全部内容 1234567891011import java.io.File;public class Test5 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator); String[] str=f.list(); for(String s:str)&#123; System.out.println(s); &#125; &#125;&#125; 以上列出了全部的名字，包括文件夹得名字和文件的名字。 操作二：使用 listFiles() 列出 1234567891011import java.io.File;public class Test6 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator); File[] files=f.listFiles(); for(File file:files)&#123; System.out.println(file); &#125; &#125;&#125; 以上列出了完全路径。 实例操作六：判断一个给定的路径是否为目录给定路径，判断是否是目录 123456789101112import java.io.File;public class Test7 &#123; public static void main(String[] args) &#123; File f=new File("d:"+File.separator); if(f.isDirectory())&#123; System.out.println(f.getPath()+"是目录"); &#125;else&#123; System.out.println(f.getPath()+"不是目录"); &#125; &#125;&#125; 实例操作七：列出指定目录的全部内容如果给定了一个目录，则要求把此目录中的全部文件都列出来，包括子文件夹下的文件 12345678910111213141516171819202122import java.io.File;public class Test8 &#123; public static void main(String[] args) &#123; File f = new File("d:" + File.separator); print(f); &#125; public static void print(File f) &#123; if (f != null) &#123; if (f.isDirectory()) &#123; File[] files = f.listFiles(); if (files != null) &#123; for (File file : files) &#123; print(file); &#125; &#125; &#125; else &#123; System.out.println(f); &#125; &#125; &#125;&#125; 总结： File 类是在 java.io 包中唯一与文件本身有关的 可以使用 File 类创建、删除等常见的文件操作 在使用 File 类指定路径的时候一定要注意操作系统间的差异，尽量使用 separator 进行分割 Java IO学习笔记（二）：RandomAccessFile类之前的 File 类只是针对文件本身进行操作的，而如果相对文件内容进行操作，则可以使用 RandomAccessFile 类，此类属于随机读取类，可以随机的读取一个文件中指定位置的数据。 因为在文件中，所有得内容都是按照字节存放的，都有固定的保存位置。 构造函数： public RandomAccessFile(File file,String mode)throws FileNotFoundException 实例化此类的时候需要传递 File 类。告诉程序应该操作的是哪个文件，之后有个模式，文件的打开模式，常用的两种模式： r：读 w：写 rw：读写，如果使用此模式，如果文件不存在，则会自动创建 先写信息： 12345678910111213141516171819import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;public class Test9 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); RandomAccessFile raf=new RandomAccessFile(f,"rw");//读写模式，如果该路径不存在会自动创建 String name1="jim"; int age1 =20; String name2="Tom"; int age2=30; raf.writeBytes(name1); raf.writeInt(age1); raf.writeBytes(name2); raf.writeInt(age2); raf.close(); &#125;&#125; 然后读文件： 1234567891011121314151617181920212223242526import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;public class Test10 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); RandomAccessFile raf=new RandomAccessFile(f,"r");//以读模式打开 raf.skipBytes(7);//跳过第一个人的信息 byte[] bs=new byte[3]; for(int i=0;i&lt;bs.length;i++)&#123; bs[i]=raf.readByte(); &#125; String name2=new String(bs); int age2=raf.readInt(); System.out.println(name2+" "+age2); raf.seek(0);//指针回到文件开头，读取第二个人的信息 for(int i=0;i&lt;bs.length;i++)&#123; bs[i]=raf.readByte(); &#125; String name1=new String(bs); int age1=raf.readInt(); System.out.println(name1+" "+age1); &#125;&#125; 另外：可能有的同学输入的是中文，那么使用 getBytes() 转换，会占 3 个字节（取决你的本地编码，如果用 Eclipse 可设置成 UTF-8），咦？java 里面中文不是占两个字节吗？怎么会变成 3 个字节呢？其实这不是一个概念，java 默认字符编码的是 unicode，确实占两个字节，但是在 String 换转 byte[] 时用的 getBytes() 默认用的编码进行转换，那么就会占 3 个字节，unicode 和 UTF-8 不是一个概念，仔细观察的话会发现 getBytes() 方法有另外的重载 getBytes(“……”)，例如通过 getBytes(“gbk”)，这是转化的中文就会变成两字节了。 Java IO学习笔记（三）：字节流与字符流先来看一下流的概念： 在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。 程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。 字节流与字符流在 java.io 包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用 OutputStream 完成，输入使的是 InputStream，在字符流中输出主要是使用 Writer 类完成，输入流主要使用 Reader 类完成。（这四个都是抽象类） 操作流程在 Java 中 IO 操作也是有相应步骤的，以文件操作为例，主要的操作流程如下： 使用 File 类打开一个文件 通过字节流或字符流的子类，指定输出的位置 进行读 / 写操作 关闭输入 / 输出 IO 操作属于资源操作，一定要记得关闭 字节流字节流主要是操作 byte 类型数据，以 byte 数组为准，主要操作类就是 OutputStream、InputStream 字节输出流：OutputStream OutputStream 是整个 IO 包中字节输出流的最大父类，此类的定义如下： public abstract class OutputStream extends Object implements Closeable,Flushable 从以上的定义可以发现，此类是一个抽象类，如果想要使用此类的话，则首先必须通过子类实例化对象，那么如果现在要操作的是一个文件，则可以使用：FileOutputStream 类。通过向上转型之后，可以为 OutputStream 实例化 Closeable 表示可以关闭的操作，因为程序运行到最后肯定要关闭 Flushable：表示刷新，清空内存中的数据 FileOutputStream 类的构造方法如下： public FileOutputStream(File file)throws FileNotFoundException 写数据： 123456789101112131415import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建 String str="Hello World"; byte[] b=str.getBytes(); out.write(b);//因为是字节流，所以要转化成字节数组进行输出 out.close(); &#125;&#125; 也可以一个字节一个字节进行输出，如下： 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建 String str="Hello World"; byte[] b=str.getBytes(); for(int i=0;i&lt;b.length;i++)&#123; out.write(b[i]); &#125; out.close(); &#125;&#125; 以上输出只会进行覆盖，如果要追加的话，请看 FileOutputStream 类的另一个构造方法： public FileOutputStream(File file,boolean append)throws FileNotFoundException 在构造方法中，如果将 append 的值设置为 true，则表示在文件的末尾追加内容。 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); OutputStream out=new FileOutputStream(f,true);//追加内容 String str="\r\nHello World"; byte[] b=str.getBytes(); for(int i=0;i&lt;b.length;i++)&#123; out.write(b[i]); &#125; out.close(); &#125;&#125; 文件中换行为：\r\n 字节输入流：InputStream既然程序可以向文件中写入内容，则就可以通过 InputStream 从文件中把内容读取进来，首先来看 InputStream 类的定义： public abstract class InputStream extends Object implements Closeable 与 OutputStream 类一样，InputStream 本身也是一个抽象类，必须依靠其子类，如果现在是从文件中读取，就用 FileInputStream 来实现。 观察 FileInputStream 类的构造方法： public FileInputStream(File file)throws FileNotFoundException 读文件： 123456789101112131415import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test12 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); InputStream in=new FileInputStream(f); byte[] b=new byte[1024]; int len=in.read(b); in.close(); System.out.println(new String(b,0,len)); &#125;&#125; 但以上方法是有问题的，用不用开辟这么大的一个字节数组，明显是浪费嘛，我们可以根据文件的大小来定义字节数组的大小，File 类中的方法：public long length() 123456789101112131415import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test13 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); InputStream in=new FileInputStream(f); byte[] b=new byte[(int) f.length()]; in.read(b); in.close(); System.out.println(new String(b)); &#125;&#125; 我们换种方式，一个字节一个字节读入~ 1234567891011121314151617import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test14 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); InputStream in=new FileInputStream(f); byte[] b=new byte[(int) f.length()]; for(int i=0;i&lt;b.length;i++)&#123; b[i]=(byte) in.read(); &#125; in.close(); System.out.println(new String(b)); &#125;&#125; 但以上情况只适合知道输入文件的大小，不知道的话用如下方法： 1234567891011121314151617181920import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test15 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); InputStream in=new FileInputStream(f); byte[] b=new byte[1024]; int temp=0; int len=0; while((temp=in.read())!=-1)&#123;//-1为文件读完的标志 b[len]=(byte) temp; len++; &#125; in.close(); System.out.println(new String(b,0,len)); &#125;&#125; 字符流在程序中一个字符等于两个字节，那么 java 提供了 Reader、Writer 两个专门操作字符流的类。 字符输出流：WriterWriter 本身是一个字符流的输出类，此类的定义如下： public abstract class Writer extends Object implements Appendable，Closeable，Flushable 此类本身也是一个抽象类，如果要使用此类，则肯定要使用其子类，此时如果是向文件中写入内容，所以应该使用 FileWriter 的子类。 FileWriter 类的构造方法定义如下： public FileWriter(File file)throws IOException 字符流的操作比字节流操作好在一点，就是可以直接输出字符串了，不用再像之前那样进行转换操作了。 写文件： 1234567891011121314import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Test16 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Writer out=new FileWriter(f); String str="Hello World"; out.write(str); out.close(); &#125;&#125; 在默认情况下再次输出会覆盖，追加的方法也是在构造函数上加上追加标记 1234567891011121314import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Test17 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Writer out=new FileWriter(f,true);//追加 String str="\r\nHello World"; out.write(str); out.close(); &#125;&#125; 字符输入流：ReaderReader 是使用字符的方式从文件中取出数据，Reader 类的定义如下： public abstract class Reader extends Objects implements Readable，Closeable Reader 本身也是抽象类，如果现在要从文件中读取内容，则可以直接使用 FileReader 子类。 FileReader 的构造方法定义如下： public FileReader(File file)throws FileNotFoundException 以字符数组的形式读取出数据： 123456789101112131415import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class Test18 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Reader input=new FileReader(f); char[] c=new char[1024]; int len=input.read(c); input.close(); System.out.println(new String(c,0,len)); &#125;&#125; 也可以用循环方式，判断是否读到底： 1234567891011121314151617181920import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class Test19 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Reader input=new FileReader(f); char[] c=new char[1024]; int temp=0; int len=0; while((temp=input.read())!=-1)&#123; c[len]=(char) temp; len++; &#125; input.close(); System.out.println(new String(c,0,len)); &#125;&#125; 字节流与字符流的区别字节流和字符流使用是非常相似的，那么除了操作代码的不同之外，还有哪些不同呢？ 字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的 字节流在操作文件时，即使不关闭资源（close 方法），文件也能输出，但是如果字符流不使用 close 方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用 flush 方法强制进行刷新缓冲区，这时才能在不 close 的情况下输出内容 那开发中究竟用字节流好还是用字符流好呢？ 在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。 如果要 java 程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）。 Java IO学习笔记（四）：字节-字符转换流OutputStreamWriter 和 InputStreamReader在整个 IO 包中，实际上就是分为字节流和字符流，但是除了这两个流之外，还存在了一组字节流 - 字符流的转换类。 OutputStreamWriter：是 Writer 的子类，将输出的字符流变为字节流，即：将一个字符流的输出对象变成字节流的输出对象。 InputStreamReader: 是 Reader 的子类，将输入的字节流变为字符流，即：将一个字节流的输入对象变成字符流的输入对象。 一般在操作输入输出内容就需要使用字节或字符流，但是有些时候需要将字符流变成字节流的形式，或者将字节流变为字符流的形式，所以，就需要另外一组转换流的操作类。 看一下 OutputStreamWriter 的构造方法： public OutputStreamWriter(OutputStream out) 例如，将字节的文件输出流，以字符的形式输出 1234567891011121314import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;public class Test20 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Writer out=new OutputStreamWriter(new FileOutputStream(f)); out.write("Hello World!!!"); out.close(); &#125;&#125; 读得时候也可以用字符流形式读取字节流的对象 12345678910111213141516import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.Reader;public class Test21 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); Reader input=new InputStreamReader(new FileInputStream(f)); char[] c=new char[1024]; int len=input.read(c); input.close(); System.out.println(new String(c,0,len)); &#125;&#125; 以上操作只是以文件操作为例，OutputStreamWriter 中接受的类型是 OutputStream，只要是字节输出流都可以以使用字符的形式操作，InputStreamReader 一样。 FileWriter 和 FileReader 的说明从 JDK 文档中可以知道 FileOutputStream 是 OutputStream 的直接子类。FileInputStream 也是 InputStream 的直接子类，但是在字符流文件的两个操作类却有一些特殊，FileWriter 并不直接是 Writer 的子类，而是 OutputStreamWriter 的子类，而 FileReader 也不直接是 Reader 的子类，而是 InputStreamReader 的子类，那么从这两个类的继承关系就可以清楚的发现，不管是使用字节流还是字符流实际上最终都是以字节的形式操作输入输出流的。也就是说，传输或者从文件中读取数据的时候，文件里真正保存的数据永远是字节。 Java IO学习笔记（五）：内存操作流ByteArrayInputStream 和 ByteArrayOutputStream之前所讲解的程序中，输出和输入都是从文件中来得，当然，也可以将输出的位置设置在内存之上，此时就要使用 ByteArrayInputStream、ByteArrayOutputStream 来完成输入输出功能了 ByteArrayInputStream 的主要功能将内容输入到内存之中 ByteArrayOutputStream 的主要功能是将内存中的数据输出 此时应该把内存作为操作点 ByteArrayInputStream 类的定义： public class ByteArrayInputStream extends InputStream 构造方法： public ByteArrayInputStream(byte[] buf) 接受一个 byte 数组，实际上内存的输入就是在构造方法上将数据传入到内存中。 ByteArrayOutputStream：输出就是从内存中写出数据 public void write(int b) 以下是以内存操作流完成的一个大小写字母转换的程序： 1234567891011121314151617181920import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class Test22 &#123; public static void main(String[] args) throws IOException &#123; String str="HELLO WORlD!!!"; InputStream input=new ByteArrayInputStream(str.getBytes()); OutputStream output=new ByteArrayOutputStream(); int temp=0; while((temp=input.read())!=-1)&#123; output.write(Character.toLowerCase(temp)); &#125; input.close(); output.close(); System.out.println(output.toString()); &#125;&#125; Java IO学习笔记（六）：管道流管道流（线程通信流）管道流的主要作用是可以进行两个线程间的通讯，分为管道输出流 (PipedOutputStream)、管道输入流（PipedInputStream），如果想要进行管道输出，则必须要把输出流连在输入流之上，在 PipedOutputStream 类上有如下的一个方法用于连接管道： public void connect(PipedInputStream snk)throws IOException 例子：线程之间用管道流进行通讯 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;class Send implements Runnable&#123; private PipedOutputStream pos;//管道输出流 public Send()&#123; pos=new PipedOutputStream(); &#125; @Override public void run() &#123; String str="Hello World!"; try &#123; pos.write(str.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; pos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public PipedOutputStream getPos() &#123; return pos; &#125;&#125;class Receive implements Runnable&#123; private PipedInputStream pis;//管道输入流 public Receive()&#123; pis=new PipedInputStream(); &#125; @Override public void run() &#123; byte[] b=new byte[1024]; int len=0; try &#123; len=pis.read(b); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; pis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(new String(b,0,len)); &#125; public PipedInputStream getPis() &#123; return pis; &#125;&#125;public class Test23 &#123; public static void main(String[] args) &#123; Send send=new Send(); Receive receive=new Receive(); try &#123; send.getPos().connect(receive.getPis());//连接管道 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; new Thread(send).start();//启动线程 new Thread(receive).start();//启动线程 &#125;&#125; Java IO学习笔记（七）：打印流在整个 IO 包中，打印流是输出信息最方便的类，主要包含字节打印流（PrintStream）和字符打印流（PrintWrite）。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等。 看一下 PrintStream 的构造方法： public PrintStream(OutputStream out) 在 PrintStream 中定义的构造方法中可以清楚的发现有一个构造方法可以直接接收 OutputStream 类的实例，这是因为与 OutputStream 相比起来，PrintStream 可以更加方便的输出数据，这就好比将 OutputStream 类重新包装了一下，使之输出更加方便。 使用 PrintStream 输出信息： 1234567891011121314import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class Test24 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); PrintStream output=new PrintStream(new FileOutputStream(f)); output.println("Hello World!"); output.print("1+1="+2); output.close(); &#125;&#125; 也就是说此时，实际上是将 FileOutputStream 类的功能包装了一下，这样的设计在 java 中称为装饰设计。 但如果仅仅是上面的那些功能也未免太寒碜了吧，好吧，看绝招，大家学过 C 吧~： 1234567891011121314151617import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class Test25 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); PrintStream output=new PrintStream(new FileOutputStream(f)); String name="Jim"; int age=20; float score=90.5f; char sex='M'; output.printf("姓名：%s 年龄：%d 成绩：%f 性别：%c", name,age,score,sex); output.close(); &#125;&#125; 哈哈，竟然有 printf！~ 而且你要是觉得 %s %d %f %c 太麻烦，可以全用 %s 代替，比 C 的 printf 还好用 Java IO学习笔记（八）：System类对IO的支持System 类的常量System 表示系统类，此类也对 IO 给予了一定的支持。 public static final PrintStream out 对应系统标准输出，一般是显示器 public static final PrintStream err 错误信息输出 public static final InputStream in 对应着标准输入，一般是键盘 又是由于历史遗留问题 全局变量没有大写~ System.out使用 System.out 输出的时候就是将输出的位置定义在了显示器之中。 FileOutputStream 是定位在文件里，而 System.out 是定位在屏幕上。 使用 OutputStream 完成屏幕上输出（PrintStream 是 OutputStream 的子类） 12345678910 import java.io.IOException; import java.io.OutputStream; public class Test26 &#123; public static void main(String[] args) throws IOException &#123; OutputStream out=System.out; out.write("Hello World!".getBytes()); out.close(); &#125;&#125; 这其实就是多态的一种表现 System.errSystem.err 表示的错误的标准输出，如果程序中出现了错误的话，则直接使用 System.err 进行打印输出即可。 12345678910public class Test27 &#123; public static void main(String[] args) &#123; String str="Hello World"; try&#123; int a=Integer.parseInt(str); &#125;catch(Exception e)&#123; System.err.println(e); &#125; &#125;&#125; 但是有些人会问这跟 System.out 输出的结果完全一样的嘛，有什么区别啊？ System.out 与 System.err 的区别 System.out 和 System.err 都是 PrintStream 的实例化对象，而且通过实例代码可以发现，两者都可以输出错误信息，但是一般来讲 System.out 是将信息显示给用户看，是正常的信息显示，而 System.err 的信息正好相反是不希望用户看到，会直接在后台打印，是专门显示错误的 一般来讲，如果要想输出错误信息的时候最好不要使用 System.out 而是直接使用 System.err，这一点只能从其概念上划分。 System.inSystem.in 实际上是一个键盘的输入流，其本身是 InputStream 类型的对象。那么，此时就可以利用此方式完成从键盘读取数据的功能。 InputStream 对应的是输入流，输入流的话肯定可以从指定位置上读取，之前使用的是 FileInputStream 是从文件中读取的 1234567891011import java.io.IOException;import java.io.InputStream;public class Test28 &#123; public static void main(String[] args) throws IOException &#123; InputStream in=System.in; byte[] b=new byte[1024]; int len=in.read(b); System.out.println(new String(b,0,len)); &#125;&#125; 如果不使用 byte 数组指定长度呢： 1234567891011121314151617import java.io.IOException;import java.io.InputStream;public class Test29 &#123; public static void main(String[] args) throws IOException &#123; InputStream in=System.in; StringBuilder buf=new StringBuilder(); int temp=0; while((temp=in.read())!=-1)&#123; char c=(char) temp; if(c=='\n')break; buf.append(c); &#125; in.close(); System.out.println(buf.toString()); &#125;&#125; 但以上代码还是有很大问题的，输入中文的话~，所以最好的方法还是一次性把数据都放在内存了，再一次性全部拿出来，要实现这个功能的话，要用到 BufferedReader 类，下回介绍~ 输入输出重定向System.out、System.err、System.in 都有重定向功能，分别是 setOut、setErr、setIn 方法 System.out 重定向 123456789101112import java.io.File;import java.io.FileNotFoundException;import java.io.PrintStream;public class Test30 &#123; public static void main(String[] args) throws FileNotFoundException &#123; File f = new File("d:" + File.separator+"test.txt"); System.setOut(new PrintStream(f)); String str="This is a test!"; System.out.println(str); &#125;&#125; System.err 重定向 1234567891011import java.io.ByteArrayOutputStream;import java.io.PrintStream;public class Test31 &#123; public static void main(String[] args) &#123; ByteArrayOutputStream out=new ByteArrayOutputStream(); System.setErr(new PrintStream(out)); System.err.println("Test---------------"); System.out.println(out.toString()); &#125;&#125; 一般不建议修改 err 的重定向，因为这些信息都不太希望用户看到 System.in 重定向 12345678910111213141516import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test32 &#123; public static void main(String[] args) throws IOException &#123; File f = new File("d:" + File.separator+"test.txt"); System.setIn(new FileInputStream(f)); InputStream in=System.in; byte[] b=new byte[1024]; int len=in.read(b); in.close(); System.out.println(new String(b,0,len)); &#125;&#125; 一般，使用最多的还是 System.out 的重定向~ Java IO学习笔记（九）：BufferedReader和Scanner如果想要接收任意长度的数据，而且避免乱码产生，就可以使用 BufferedReader 类 public class BufferedReader extends Reader 因为输入的数据有可能出现中文，所以，此处使用字符流完成。BufferedReader 是从缓冲区之中读取内容，所有的输入的字节数据都将放在缓冲区之中。 System.in 本身表示的是 InputStream（字节流），现在要求接收的是一个字符流，需要将字节流变成字符流才可以，所以要用 InputStreamReader 1234567891011import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Test33 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader reader=new BufferedReader(new InputStreamReader(System.in)); String str=reader.readLine(); System.out.println(str); &#125;&#125; 在 JDK1.5 之后 Java 提供了专门的输入数据类，此类可以完成 BufferedReader 类的功能，也可以方便的对输入数据进行验证，此类存放在 java.util 包中 使用 Scanner 接收键盘的输入数据： 123456789import java.util.Scanner;public class Test34 &#123; public static void main(String[] args) &#123; Scanner s=new Scanner(System.in); String str=s.next(); System.out.println(str); &#125;&#125; 比直接使用 BufferedReader 更加方便，但是这个程序是有问题的，如果输入的字符串中存在空格，那么就会截止，如果我们要接收空格的下，将分隔符变成 “\n”。 12345678910import java.util.Scanner;public class Test34 &#123; public static void main(String[] args) &#123; Scanner s=new Scanner(System.in); s.useDelimiter("\n");//使用分隔符 String str=s.next(); System.out.println(str); &#125;&#125; 参考：java IO - 标签 - 一直在等 - 博客园http://www.cnblogs.com/lich/tag/java%20IO/]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 生成速度过慢]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-2%2F</url>
    <content type="text"><![CDATA[参考：Speed Up the Rendering Process of hexo 3 | HaHackhttp://www.hahack.com/codes/hexo-3-speed-up/hexo3中hexo g生成速度过慢 | SHANG Bloghttps://blog.xinshangshangxin.com/2015/06/29/hexo3%E4%B8%ADhexo-g%E7%94%9F%E6%88%90%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx实战]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31%2F</url>
    <content type="text"><![CDATA[使用理由 123456配置文件简单支持Rewrite重写规则内置健康检查功能节省带宽稳定性高支持热部署 平滑重启 1kill -HUP \`/usr/local/nginx/logs/nginx.pid\` 当Nginx接收到hup信号时，它会尝试先解析配置文件，如果 成功就应用新的配置谁的，之后，Nginx运行新的工作进程并从容关闭旧的工作进程 ，通知工作进程 关闭监听大套接字，但是继续为新的客户提供服务 ，所有客户端的服务完成后旧的工作进程 被关闭。如果 新的配置文件应用失败，Nginx继续使用旧的配置进行工作。 Nginx支持以下几种信号 TERM, INT 快速关闭; QUIT 从容关闭； HUP 平滑重启，重新加载配置文件； USR1 重新的打开日志文件，在切割日志时用途较大； USR2 平滑升级可执行程序 ； WINCH 从容关闭工作进程。 nginx配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#使用的用户和组user www www;#指定工作衍生进程数（一般等于CUP的总或总的两倍，例如两个 四核CUP，则总核数为8）worker_processes 8;#指定错误日志存放的路径，错误日志记录级别可选项为：【debug | info | notice | warn | error | crit 】error_log /data1/logs/nginx_error.log crit;#指定PID存放的路径pid /usr/local/nginx/nginx.pid;#指定文件描述符数量 worker_rlimit_nofile 51200;events &#123; #使用的网络I/O模型，Linux系统推荐采用epoll模型，FreeBSD系统采用kqueue模型use epoll;#允许的连接数worker_connections 51200;&#125;http &#123;include mime types;default_type application/octet-stream;#设置使用的字符集，如果 一个网站 有多种字符集，请不要随便设置，就让程序 员在html代码中通过meta标签设置#charset gb2312;server_names_hash_bucket_size 128;client_header_buffer_size 32k;large_client_header_buffers 4 32k;#设置客户端能够上传文件的大小client_max_body_size 8m;sendfile on;tcp_nopush on;keepalive_timeout 60;tcp_nodelay on;fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fasgcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;#开启gzip压缩gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_http_version 1.1;gzip_comp_level 2;gzip_types text/plain application/x-javascript text/css application/xml;gzip_vary on;#limit_zone crawler $binary_remote_addr 10m;server &#123;#监听的IP和端口 listen 80;#主机名称 server_name www.yourdomain.com yourdomain.com;#默认首页文件，顺序从左到右，如果 找不到index.html文件，则查找 index.htm文件作为首页文件index index.html index.htm index.php;root /data0/htdocs;#limit_conn crawler 20;location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$&#123; expires 30d;&#125; location ~ .*\.(js|css)?$&#123; expires 1h;&#125;log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos; $status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;$http_user_agent&quot; $http_x_forwarded_for&apos;;access_log /data1/logs/access.log access;&#125;&#125; 虚拟主机 虚拟主机使用的是特殊的软硬件技术，它把一台运行在因特网上的服务器主机分成一台台 “虚拟” 的主机，每台虚拟主机都可以是一个独立的网站，可以具有独立的域名，具有完整的 Internet 服务器功能（www、FTP、Email 等），同一台主机上的虚拟主机之间是完全独立的。从网站访问者来看，每一台虚拟主机和一台独立的主机完全一样。 利用虚拟主机，不用为每个要运行的网站 提供一台单独的 Nginx 服务 器或单独运行一级 nginx 进程 。虚拟主机提供了在同一台服务器、同一级 Nginx 进程 上运行多个网站 的功能。 跟 apache 一样，Nginx 也可以配置多种类型的虚拟主机; 一是基于 ip 的虚拟主机，二是基于域名的虚拟主机，三是基于端口的虚拟主机。 一段 server{……} 就是一个虚拟该机，如果要配置多个虚拟主机，建立多段 server{} 配置即可，非常方便，监听的 IP 商品也可以不写 IP 地址，只写端口，把它配置成 “listen 80”，则表示监听 该服务器所有 IP 的 80 端口，可通过 server_name 区分不同的虚拟主机。 反向代理后客户端 IP 问题 由于在客户端和 web 服务器之间增加了蹭层，因此 web 服务器无法直接拿到客户端的 IP, 通过 $remote_addr 变量拿到的是反向代理服务器的 ip 地址，但是，反射代理服务器在转发请求的 HTTP 头信息中，可以增加 X-Forwarded-For 信息，用以记录原有的客户端 IP 地址和原来客户端请求的服务器地址 日志切割 12345#!/bin/bashlogs_path = &quot;/data1/logs/&quot;mkdir -p $&#123;logs_path&#125;$(date -d &quot;yesterday&quot; + &quot;%Y&quot;)/$(date -d &quot;yesterday&quot; + &quot;%m&quot;)/mv $&#123;logs_path&#125;access.log $&#123;logs_path&#125;$(date -d &quot;yesterday&quot; + &quot;%Y&quot;)/$(date -d &quot;yesterday&quot; + &quot;%m&quot;)/access_$(date -d &quot;yesterday&quot; + &quot;%Y%m%d&quot;).logkill -USR1 `cat /usr/local/nginx/nginx.pid` 配置 crontab 每天凌晨 00：00 定时执行这个脚本：crontab -e Nginx 的压缩输出配置 gizp(GNU-ZIP) 是一种压缩技术。经过 gzip 压缩后页面的大小可以变为原来的 30% 甚至更小。这样，用户浏览页面时候会快很多。gzip 的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，浏览器端解压并解析。大多数浏览器都支持解析 gzip 过的页面。配置在 http{} 段中： 1234567gzip on;gzip_min_length 1k;gzip_buffers 4 16k;gzip_http_version 1.1;gzip_comp_level 2;gzip_types text/palin application/x-javascript text/css application/xml;gzip_vary on; 自动目录配置 前提：当前目录下不存在 index 指令设置的默认首页文件。 1234567location / &#123; autoindex on;&#125;相关指令#设定索引时文件大小的单位【B、KB、GB】autoindex_exact_xize [on|off]#开户本地时间来显示 文件时间的功能。默认为关(GMT时间) Nginx 的浏览器本地缓存设置 (Browser Cacging) 浏览器缓存是为了加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示 文档，这样就可以加速页面的浏览。缓存 的方式节约了网络的资源，提高网络的效率。 fastcgi FastCG 是语言无关的、可伸缩架构的 CGI 开放扩展，其主要行为是将 CGI 解释器进程保持在内存中并因此获得较高的性能，众所周知，CGI 解释器的反复加载是 CGI 性能低下的主要原因，如果 CGI 解释器保持在内存中并接受 FastCGI 进程 管理器调度，则可以提供良好的性能，伸缩性、Fail-Over 特性等。 fastcgi 原理和优点 mysql 管理 shell 脚本 vi /data0/mysql/3306/mysql 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/shmysql_port=3306mysql_usermysql_password=&quot;123456&quot;function_start_mysql() &#123; printf &quot;starting mysql...\n&quot; /bin/sh/usr/local/mysql/bin/mysqld_safe --defaults-file=/data0/mysql/$&#123;mysql_port&#125;/my.cnf 2&gt;&amp;1&gt;/dev/null &amp;&#125;function_stop_mysql() &#123; printf &quot;stoping mysql...\n&quot; /usr/local/mysql/bin/mysqladmin -u $&#123;mysql_username&#125; -p $&#123;mysql_password&#125; -S /tmp/mysql.sock shutdown&#125;function_restart_mysql()&#123; printf &quot;restarting mysql...\n&quot; function_stop_mysql sleep 5 function_start_mysql&#125;function_kill_mysql()&#123; kill -9 $(ps -ef | grep &apos;bin/mysqld_safe&apos; | grep $&#123;mysql_port&#125; | awk &apos;&#123;printf $2&#125;&apos;) kill -9 $(ps -ef | grep &apos;libexec/mysqld&apos; | grep $&#123;mysql_port&#125; | awk &apos;&#123;printf $2&#125;&apos;)&#125;if [ &quot;$1&quot; = &quot;start&quot;]; then function_start_mysqlelif [ &quot;$1&quot; = &quot;stop&quot; ]; then function_stop_mysqlelif [&quot;$1&quot; = &quot;restart&quot; ]; then function_restart_mysqlelif [ &quot;$1&quot; = &quot;kill&quot; ]; then function_kill_mysqlelse printf &quot;Usage:/data0/mysql/$&#123;mysql_prot&#125;/mysql &#123;start|stop|restart|kill&#125;\n&quot;fi chmod +x /data0/mysql/3306/mysql 启动 mysql: /data0/mysql/3306/mysql start /usr/local/mysql/bin/mysql -u -root -p -S /tmp/mysql.sock 创建一个具有 root 权限的用户和密码 12GRANT ALL PRIVILEGES ON *.* TO &apos;admin&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;GRANT ALL PRIVILEGES ON *.* TO &apos;admin&apos;@&apos;127.0.01&apos; IDENTIFIED BY &apos;123456&apos;; 为什么使用负载 均衡 随着网站 访问量的快速增长，单台服务器已经无法承担大量用户的并发访问，必须采用多台服务器协同工作，以提高计算机系统的处理能力和计算强度，满足当前业务量的需求。而如何 在完成同样功能的多个网络设备之间实现合理的业务量分配，使之不会出现一台设备过忙，而其它设备却没有充分使用的情况。要解决这一问题，可以采用负载 均衡的方法 负载均衡 负载均衡是由多台服务器以对称的方式组成 一个服务器集合，每台服务器具有等价的地位，都可以单独对提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部送来请求均匀分配到对称的某一台服务器上，而接收到请求的服务器独立 地回应客户的请求。均衡负载 能够平均分配 客户请求到服务器阵列，藉此快速获取重要数据，解决大量并发访问服务问题。这种集群技术可以用最少 的投资获得接近于大型主机的性能 。 反向代理 反向代理是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 负载均衡实现方式 用户手动选择 DNS 轮询方式（可靠性低，负载分配 不均衡） upstream 中的 ip_hash 会使相同的用户访问后端同一个服务器但是会影响负载均衡 如果后端有时候要从 Nginx 负载均衡（已使用 ip_hash）中摘除一段时间，你必须将其标记为 “down”，而不是直接从配置文件中删掉或注释掉该后端服务器信息 1234567upstream bakcend&#123; ip_hash; server backend1.example.com; server backend2.example.com; server bakcend3.example.com down; server backend4.example.com;&#125; rewrite 规则的用处 通过 Rewrite 规则，可以实现规范的 URL，根据变量来做 URL 转向及选择配置。例如，一些使用 MVC 框架的程序只有一个入口，可以通过 Rewrite 来实现 ，一些动态 URL 地址需要伪装成静态 HTML，全球搜索引擎攫取，也需要 Rwrite 来处理，一些由于目录结构、域名变化的旧 URL 需要跳转到新的 URL 上，也可以通过 Rwrite 来处理 if 中的条件 rewrite 该指令根据表达试来重定向 URI, 或者修改字符串，指令根据配置文件中的顺序来执行。重写表达式只对相对路径有效，如果你想配对主机名，需要使用 if 语句： 1234if ($host ~* www\.(.*)) &#123; set $host_without_www $1; rewrite ^(.*)$ http://$host_without_www$1 permanent;&#125; 如果字符串以http://开头，将会采用 301 或 302 跳转进行 URL 重定向。 rewrite 指命的 flag last 和 break 标记的实现功能类似 ，但二者之间有细微的差别，使用 alias 指令时必须用 last 标记，使用 proxy_pass 指令时要使用 break 标记，lat 标记在本条 rewrite 规则执行完毕后，终止匹配，不再匹配后面的规则。一般在根 location 中（即 location / {}) 或直接在 server 标签中编写 rewrite 规则，推荐使用 last 标记，在非根 location 中 （例如 location /cms/ {}）, 则使用 break 标记。 如果被替换的 URI 中含有参数（妈类似 / app/test.php?id=5 之类的 URI），默认情况下参数 会被自动加到替换串上，可以在末尾加上? 来解决这个问题。如rewrite ^/users/(.*)$ /show?user=$1? last; 对花括号来说，它们既能用在重定向的正规表达式里，也能用在配置文件里分割代码块，为了避免冲突，正则表达式里如果 带花括号，应该用双引号或单引号包围如：/photos/123456 =&gt; /path/to/photos/12/1234/123456.png rewrite &quot;/photos/([0-9]{2})([0-9]{2})([0-9]{2})&quot; /path/to/photos/$1/$1$2/$1$2$3.png; Nginx 的 Rwrite 规则编写实例 123456789if (!-e $request_filename) &#123; rewrite ^/(.*)$ /index.php last;&#125;多目录转成参数 abc.domain.com/sort/2 =&gt; abc.domain.com/index.php?act=sort&amp;name=abc&amp;id=2;if ($host ~* (.*)\.domain\.com) &#123; set $sub_name $1; rewrite ^/sort\/(\d)\/?$ /index.php?act=sort&amp;name=$sub_name&amp;id=$1 last;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647目录对换/123456/xxxx =&gt; /xxxx?id=1234565:rewrite ^/(\d+)/(.+)/ /$2?id=$1 last;如果 客户端 使用IE浏览器，则重定向到/nginx-ie目录下if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /nginx-ie/$1 break;&#125;禁止访问多个目录:location ~ ^/(cron|templates)/ &#123; deny all; break;&#125;禁止访问以/data/开头的文件:location ~ ^/data &#123; deny all;&#125;设置某些类型文件的浏览器缓存时间：location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 30d;&#125;location ~ .*\.(js|css)$ &#123; expires 1h;&#125;将多级目录下的文件转换成一个文件/job-123-456-789.html 指向/job/123/456/789.htmlrewrite ^/job-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /job/$1/$2/jobshow_$3.html last;禁止访问以.sh、.flv、.mp4为文件后缀的URL地址：location ~ .*\.(sh|flv|mp4)?$ &#123; return 403;&#125;适用于Zend Framework重写规则:if ($request_uri ~* &quot;^/pay(.*)&quot;) &#123; set $var_pay_public &apos;1&apos;;&#125;if ($request_uri ~* &quot;.&quot;\.(js|ico|gif|jpg|png|css)$&quot;) &#123; set $var_pay_public &apos;0&apos;;&#125;if ($request_pay_public ~ &apos;1&apos;) &#123; rewirte ^(.*)$ /pay/index.php last;&#125; 12345678910111213141516171819202122232425Bo-blog开源PHP博客系统伪静态重写规则if (! -x $request_filename) &#123; rewrite ^/post/([0-9]+)/?([0-9+])/?([0-9]?/?$) /read.php/entryid=$1&amp;page=$2&amp;part=$3 lastrewrite ^/page/([0-9]+)/([0-9]+)?/?$ /index.php?mode=$1&amp;page=$2 last;rewrite ^/started/([0-9]+)/?([0-9]+)?/?$ /star.php?mode=$1&amp;page=$2 last;rewrite ^/category/([^/]+)/?([0-9]+)?/?([0-9]+)?/?$ /index.php?go=category_$1&amp;mode=$2&amp;page=$3 lastrewrite ^/archiver/([0-9]+)/([0-9]+)/?([0-9]+)?/?([0-9]+)?/?$ /index.php?go=archive&amp;cm=$1&amp;cy=$2&amp;mode=$3&amp;page=$4 last;rewrite ^/date/([0-9]+)/([0-9]+)/([0-9]+)/?([0-9]+)?([0-9]+)?/?([0-9]+)?/?$ /index.php?go=showday_$1-$2-$3&amp;mode=$4&amp;page=$5 last;rewrite ^/user/([0-9]+)/?$ /view.php?go=user_$1 last;rewrite ^/tags/([^/]+)/?([0-9]+)?/?([0-9]+)?/?$ /tag.php?tag=$1&amp;mode=$2&amp;page=$3 last;rewrite ^/compnent/id/([0-9]+)/?$ /page.php?pageid=$1 last;rewrite ^/component/([^/]+)/?$ /page.php?pagealias=$1 last;rewrite ^/read\.php/([0-9]+)/([0-9]+)\.htm$ http://$host/post/$1/ permanent;rewrite ^/post/([0-9]+)\_([0-9]+)\.htm$ http://$host/post/$1/$2/ permanent;rewrite ^/post/([0-9]+)\_([0-9]+)\_([0-9])\.htm$ http://$host/post/$1/$2/$3/ permanent;rewrite ^/index\_([0-9]+)\_([0-9]+)\.htm$ http://$host/page/$1/$2/ permanent;rewrite ^/star\_([0-9]+)\_([0-9]+)\.htm$ http://$host/starred/$1/$2/ permanent;rewrite ^/category\_([0-9]+)\.htm$ http://$host/category/$1/ permanent;rewrite ^/category\_([0-9]+)\_([0-9]+)\.htm$ http://$host/category/$1/$2/$3/ permanent;rewrite ^archive\_([0-9]+)\_([0-9]+)\.htm$ http://$host/archiver/$1/$2/ permanent;rewrite ^/archive\_([0-9]+)\_([0-9]+)\_([0-9]+)\_([0-9]+)\.htm$ http://$host/archiver/$1/$2/$3/$4/ permanent;rewrite ^/showday\_([0-9]+)\_([0-9]+)\_([0-9]+)\.htm$ http://$host/date/$1/$2/$3/ permanent;rewrite ^/showday\_([0-9]+)\_([0-9]+)\_([0-9]+)\_([0-9]+)\_([0-9])\.htm http://$host/date/$1/$2/$3/$4/$5 permanent;&#125;rewrite ^/([a-zA-Z0-9_-]+)/?([0-9]+)?/?$ /read.php?biogalias=$1&amp;page=$2&amp;part=$3 last; 根据 referer 信息防盗链 123456location ~* \.(gif|jpg|jpeg|png|swf|flv)$ &#123; valid_referers none blocked www.youdomain.com *.youdomain.com; if ($invalid_referer) &#123; rewrite ^/(.*) http://www.yourdomain.com/blocked.html; &#125;&#125; Nginx 与 Apache 的 Rewrite 规则 Apache: 1RewriteRule ^/(mianshi|xianjing)/$ /z1/index.php?name=$1 [L] Apache 的 RewriteRule 指令换成 Nginx 的 rewrite 指令，Apache 的 [L] 标记换成 Nginx 的 last 标记，中间的内容不变。 Nginx 与 apache 的各种区别 nginx 模块 要编写一个 Nginx 模块，你要熟悉 Nginx 的配置文件。Nginx 配置文件主要分成 4 部分：main（全局配置）、server（虚拟主机配置）、upstream（主要为反向代理、负载均衡相关配置）和 location（目录匹配配置), 每部分包含若干个指令。main 部分的指令将影响其他所有部分; server 部分的指令主要用于指定虚拟主机域名、IP 端口; upstream 的指令用于设置反向代理及后端服务器的负载均衡; location 部分用于匹配网页位置（例如，根目录 “/“、”/images”, 等等）。location 部分会继承 server 部分的指令，而 server 会继承 main 部分的指令: upstream 既不会继承指令也不会影响其他 部分。它有自己的特殊指令，不需要在其他地方应用。 Nginx 的模块不能够像 Apache 那样动态添加，所有的模块要预先编译进 Nginx 二进制可执行文件中。 Nginx 模块的三种角色 Handlers（处理模块） 用于处理 HTTP 请求并输出内容 Filters（过滤模块） 用于过滤 Handler 输出的内容 Load-balancers （负载均衡模块）当有多于一台的后端服务器供选择时，选择一台后端服务器并将 HTTP 请求转发到该服务器。 Nginx 模块的处理流程 客户端改善 HTTP 请求到 Nginx 服务器 -&gt;Nginx 基于配置文件中的位置选择一个合适的处理模块 -&gt; 负载均衡模块选择一台后端服务器（反向代理情况下）-&gt; 处理模块进行处理并把输出缓冲放到第一个过滤模块上 -&gt; 第一个过滤模块处理后输出 给第二个过滤模块 -&gt; 第 n 个过滤模块 -&gt; 最后把处理结果发送给客户端 。 实战参考：实战nginx笔记 - 简书https://www.jianshu.com/p/dff2c0497840nginx - 标签 - 黄棣-dee - 博客园http://www.cnblogs.com/dee0912/tag/nginx/Nginx日常笔记 – 萌马笔记 – 因为记性差，所以记笔记http://git.malu.me/Nginx%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 面试 总结]]></title>
    <url>%2F2018%2F03%2F30%2F2018-03-30%2F</url>
    <content type="text"><![CDATA[Nginx的并发能力在同类型网页服务器中的表现，相对而言是比较好的，因此受到了很多企业的青睐，我国使用Nginx网站的知名用户包括腾讯、淘宝、百度、京东、新浪、网易等等。Nginx是网页服务器运维人员必备技能之一，下面为大家整理了一些比较常见的Nginx相关面试题，仅供参考： 1、请解释一下什么是Nginx?Nginx 是一个 web 服务器和反向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议。 2、请列举Nginx的一些特性。Nginx服务器的特性包括： 反向代理 / L7 负载均衡器 嵌入式 Perl 解释器 动态二进制升级 可用于重新编写 URL，具有非常好的 PCRE 支持 3、请列举Nginx和Apache 之间的不同点。 4、请解释Nginx如何处理HTTP请求。Nginx使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。 5、在Nginx中，如何使用未定义的服务器名称来阻止处理请求?只需将请求删除的服务器就可以定义为： 123456789Server &#123;listen 80;server_name “ “ ;return 444;&#125; 这里，服务器名被保留为一个空字符串，它将在没有 “主机” 头字段的情况下匹配请求，而一个特殊的Nginx的非标准代码444被返回，从而终止连接。 6、 使用 “反向代理服务器” 的优点是什么?反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。 7、请列举Nginx服务器的最佳用途。Nginx服务器的最佳用法是在网络上部署动态HTTP内容，使用SCGI、WSGI应用程序服务器、用于脚本的FastCGI处理程序。它还可以作为负载均衡器。 8、请解释Nginx服务器上的Master和Worker进程分别是什么?Master进程：读取及评估配置和维持 Worker进程：处理请求 9、请解释你如何通过不同于80 的端口开启 Nginx?为了通过一个不同的端口开启Nginx，你必须进入/etc/Nginx/sites-enabled/，如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放置在你想要的端口： 1Like server &#123; listen 81; &#125; 10、请解释是否有可能将Nginx的错误替换为502错误、503?502 = 错误网关 503 = 服务器超载 有可能，但是您可以确保fastcgi_intercept_errors被设置为ON，并使用错误页面指令。 123456Location / &#123;fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors on;error_page 502 =503/error_page.html;#…&#125; 11、在Nginx中，解释如何在URL中保留双斜线?要在URL中保留双斜线，就必须使用merge_slashes_off; 语法:merge_slashes [on/off] 默认值: merge_slashes on 环境: http，server 12、请解释ngx_http_upstream_module的作用是什么?ngx_http_upstream_module用于定义可通过fastcgi传递、proxy传递、uwsgi传递、memcached传递和 scgi 传递指令来引用的服务器组。 13、请解释什么是C10K问题?C10K问题是指无法同时处理大量客户端 (10,000) 的网络套接字。 14、请陈述stub_status和sub_filter指令的作用是什么?Stub_status指令：该指令用于了解Nginx当前状态的当前状态，如当前的活动连接，接受和处理当前读 / 写 / 等待连接的总数 Sub_filter指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据 15、解释Nginx是否支持将请求压缩到上游?您可以使用Nginx模块gunzip将请求压缩到上游。gunzip模块是一个过滤器，它可以对不支持 “gzip” 编码方法的客户机或服务器使用 “内容编码: gzip” 来解压缩响应。 16、解释如何在Nginx中获得当前的时间?要获得 Nginx 的当前时间，必须使用SSI模块、$date_gmt和$date_local的变量。 Proxy_set_header THE-TIME $date_gmt; 17、用Nginx服务器解释-s的目的是什么?用于运行Nginx -s参数的可执行文件。 18、解释如何在Nginx服务器上添加模块?在编译过程中，必须选择Nginx模块，因为Nginx不支持模块的运行时间选择。 什么是 Nginx？ Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 服务器 Nginx 是一款轻量级的 Web 服务器 / 反向代理服务器及电子邮件（IMAP/POP3）代理服务器 目前使用的最多的 web 服务器或者代理服务器，像淘宝、新浪、网易、迅雷等都在使用为什么要用 Nginx？ 优点： 跨平台、配置简单 非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发 内存消耗小：开启 10 个 nginx 才占 150M 内存 成本低廉：开源 内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。 节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存 稳定性高：宕机的概率非常小 master/worker 结构：一个 master 进程，生成一个或者多个 worker 进程 接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力 一边接收 web 服务器的返回数据，一边发送给浏览器客户端 网络依赖性比较低，只要 ping 通就可以负载均衡 可以有多台 nginx 服务器 事件驱动：通信机制采用 epoll 模型为什么 Nginx 性能这么高？ 得益于它的事件处理机制： 异步非阻塞事件处理机制：运用了 epoll 模型，提供了一个队列，排队解决为什么不使用多线程？ 因为线程创建和上下文的切换非常消耗资源，线程占用内存大，上下文切换占用 cpu 也很高，采用 epoll 模型避免了这个缺点Nginx 是如何处理一个请求的呢？ 首先，nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面 先初始化好这个监控的 socket(创建 socket，设置 addrreuse 等选项，绑定到指定的 ip 地址端口，再 listen) 然后再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程) 出多个子进程出来 然后子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与 nginx 进行三次握手，与 nginx 建立好一个连接后 此时，某一个子进程会 accept 成功，得到这个建立好的连接的 socket，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体 接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了正向代理 一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器) 然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理 正向代理总结就一句话：代理端代理的是客户端反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求，发给内部网络上的服务器 并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器 反向代理总结就一句话：代理端代理的是服务端动态资源、静态资源分离 动态资源、静态资源分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后 我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路 动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离为什么要做动、静分离？ 在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js 等等文件） 这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗 当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决 动、静分离将网站静态资源（HTML，JavaScript，CSS，img 等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问 这里我们将静态资源放到 nginx 中，动态资源转发到 tomcat 服务器中负载均衡 负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中 负载均衡主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器大并发压力 首先列出一些面试题目包括 nginx 和 redis 的。 1.、nginx 框架是怎样的 2. nginx 负载均衡的算法怎么实现的，懵逼，说没看过 。 nginx 的 upstream 目前支持 4 种方式的分配1)、轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。2)、weight 指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。2)、ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。3)、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。4)、url_hash（第三方） nginx 内置策略包含加权轮询和 ip hash 加权轮询算法分为先深搜索和先广搜索，那么 nginx 采用的是先深搜索算法，即将首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器； 3. redis 主从是怎么选取的 4、redis 插槽的分配 5、redis 复制的过程 6、redis 主节点宕机了怎么办，还有没有同步的数据怎么办 ….. 反正一大堆 redis 的问题 7、重入锁是怎么计数的 8、如何解决惊群现象？ 惊群是多个子进程在同一时刻监听同一个端口引起的； Nginx 解决方法：同一个时刻只能有唯一一个 worker 子进程监听 web 端口，此时新连接事件只能唤醒唯一正在监听端口的 worker 子进程。 采用锁，互斥量实现！！ 一、Nginx 优秀模块 模块设计： 高度模块化设计，除了少量核心代码，其他一切接模块。官方 Nginx 共有五大类型模块：核心模块、配置模块、事件模块、HTTP 模块、mail 模块。 要注意的是：nginx 的模块是静态的，添加和删除模块都要对 nginx 进行重新编译，这一点与 Apache 的动态模块完全不同。 二、事件驱动框架： nginx 事件驱动框架（书本 p254）：所谓事件驱动架构，简单来说，就是由一些事件发生源来产生事件，由一个或多个事件收集器（epolld 等）来收集、分发事件，然后许多事件处理器会注册自己感兴趣的事件，同时会 “消费” 这些事件。nginx 不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。 传统 web 服务器（如 Apache）的，所谓事件局限在 TCP 连接建立、关闭上，其他读写都不在是事件驱动，这时会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu 等资源。并且把一个进程或线程作为事件消费者。 传统 web 服务器与 Nginx 间重要差别： 前者每个事件消费者独占一个进程资源，后者只是被事件分发者进程短期调用而已。 三、请求的多阶段异步处理请求的多阶段异步处理只能基于事件驱动框架实现，就是把一个请求的处理过程按照事件的触发方式分为多个阶段，每个阶段都可以有事件收集、分发器（epoll 等）来触发。比如一个 http 请求可以分为七个阶段 四、一个 master 进程（管理），多个 work（工作）进程。 master 对 work 进程采用信号进行控制 五、平台无关的代码实现： 在核心代码都使用了与操作系统无关的代码实现，在与操作系统相关的系统调用上则分别针对各个操作系统都有独立实现，这最终造就了 Nginx 的可移植性。 六、内存池的设计 为了减少避免出现内存碎片、减少向操作系统申请内存的次数、降低各个模块的开发复杂度，Nginx 采用了简单的内存池（统一申请，统一释放）。比如为每个 http 请求分配一个内存池，请求结束时销毁整个内存池。 1、什么是 Nginx？ Nginx 是一个高性能的 HTTP 和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡。 多进程异步非阻塞事件处理机制：运用了 epoll 模型 2、为什么要用 Nginx？ 优点： 跨平台、配置简单 非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发 内存消耗小：开启 10 个 nginx 才占 150M 内存，Nginx 采取了分阶段资源分配技术 nginx 处理静态文件好, 耗费内存少 内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。 节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存 稳定性高：宕机的概率非常小 master/worker 结构：一个 master 进程，生成一个或者多个 worker 进程 接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力 一边接收 web 服务器的返回数据，一边发送给浏览器客户端 网络依赖性比较低，只要 ping 通就可以负载均衡 可以有多台 nginx 服务器 事件驱动：通信机制采用 epoll 模型 3、为什么 Nginx 性能这么高？ 得益于它的事件处理机制： 异步非阻塞事件处理机制：运用了 epoll 模型，提供了一个队列，排队解决 4、为什么不使用多线程？ Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。 Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。 5、Nginx 是如何处理一个请求的呢？ 首先，nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面 先初始化好这个监控的 socket，再进行 listen 然后再 fork 出多个子进程出来, 子进程会竞争 accept 新的连接。 此时，客户端就可以向 nginx 发起连接了。当客户端与 nginx 进行三次握手，与 nginx 建立好一个连接后 此时，某一个子进程会 accept 成功，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体 接着，根据事件调用相应的事件处理模块，如 http 模块与客户端进行数据的交换。 最后，nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了 6、正向代理 一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理 正向代理总结就一句话：代理端代理的是客户端 7、反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求，发给内部网络上的服务器 并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器 反向代理总结就一句话：代理端代理的是服务端 8、动态资源、静态资源分离 动态资源、静态资源分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路 动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离 9、为什么要做动、静分离？ 在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js 等等文件） 这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗 当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决 动、静分离将网站静态资源（HTML，JavaScript，CSS，img 等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问 这里我们将静态资源放到 nginx 中，动态资源转发到 tomcat 服务器中 10、负载均衡 负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中 负载均衡主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器大并发压力 参考：Nginx面试中最常见的18道题https://segmentfault.com/a/1190000010677483Nginx常见面试题 - Gibbons的个人空间https://my.oschina.net/gibbons/blog/900493nginx面试要点–持续更新中 - CSDN博客https://blog.csdn.net/watson2016/article/details/77938678]]></content>
      <tags>
        <tag>面试</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx理论]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-3%2F</url>
    <content type="text"><![CDATA[1 反向代理1.1 概念反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 举个例子，比如我想访问 http://www.test.com/readme，但www.test.com上并不存在 readme 页面，于是他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。这里所提到的 www.test.com 这个域名对应的服务器就设置了反向代理功能。 结论就是，反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间 (name-space) 中的内容发送普通请求，接着反向代理服务器将判断向何处 (原始服务器) 转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 正向代理，既然有反向代理，就肯定有正向代理。什么叫正向代理呢？ 正向代理（Forward Proxy）通常都被简称为代理，就是在用户无法正常访问外部资源，比方说受到 GFW 的影响无法访问 twitter 的时候，我们可以通过代理的方式，让用户绕过防火墙，从而连接到目标网络或者服务。 正向代理的工作原理就像一个跳板，比如：我访问不了 google.com，但是我能访问一个代理服务器 A，A 能访问 google.com，于是我先连上代理服务器 A，告诉他我需要 google.com 的内容，A 就去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。 结论就是，正向代理是一个位于客户端和原始服务器 (origin server) 之间的服务器。为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 反向代理 VS 正向代理： 1.2 工作流程 用户通过域名发出访问 Web 服务器的请求，该域名被 DNS 服务器解析为反向代理服务器的 IP 地址； 反向代理服务器接受用户的请求； 反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户； 如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中。 1.3 优点 保护了真实的 web 服务器，保证了 web 服务器的资源安全 通常的代理服务器，只用于代理内部网络对 Internet 外部网络的连接请求，客户机必须指定代理服务器，并将本来要直接发送到 Web 服务器上的 http 请求发送到代理服务器中。不支持外部网络对内部网络的连接请求，因为内部网络对外部网络是不可见的。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个 Web 服务器，外部网络就可以简单把它当作一个标准的 Web 服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者 CGI 程序，都保存在内部的 Web 服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了 Web 服务器的安全性。 节约了有限的 IP 地址资源 企业内所有的网站共享一个在 internet 中注册的 IP 地址，这些服务器分配私有地址，采用虚拟主机的方式对外提供服务。 减少 WEB 服务器压力，提高响应速度 反向代理就是通常所说的 web 服务器加速，它是一种通过在繁忙的 web 服务器和外部网络之间增加一个高速的 web 缓冲服务器来降低实际的 web 服务器的负载的一种技术。反向代理是针对 web 服务器提高加速功能，作为代理缓存，它并不是针对浏览器用户，而针对一台或多台特定的 web 服务器，它可以代理外部网络对内部网络的访问请求。 反向代理服务器会强制将外部网络对要代理的服务器的访问经过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存到本地，以便日后再收到同样的信息请求时，它会把本地缓存里的内容直接发给用户，以减少后端 web 服务器的压力，提高响应速度。因此 Nginx 还具有缓存功能。 其他优点 （1）请求的统一控制，包括设置权限、过滤规则等； （2）区分动态和静态可缓存内容； （3）实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问； （4）解决 Ajax 跨域问题； （5）作为真实服务器的缓冲，解决瞬间负载量大的问题； 2 Nginx 模块Nginx 有五大优点：模块化、事件驱动、异步、非阻塞、多进程单线程。由内核和模块组成的，其中内核完成的工作比较简单，仅仅通过查找配置文件将客户端请求映射到一个 location block，然后又将这个 location block 中所配置的每个指令将会启动不同的模块去完成相应的工作。 2.1 模块划分Nginx 的模块从结构上分为核心模块、基础模块和第三方模块： 核心模块：HTTP 模块、EVENT 模块和 MAIL 模块 基础模块：HTTP Access 模块、HTTP FastCGI 模块、HTTP Proxy 模块和 HTTP Rewrite 模块， 第三方模块：HTTP Upstream Request Hash 模块、Notice 模块和 HTTP Access Key 模块。 Nginx 的模块从功能上分为如下四类： Core(核心模块)：构建 nginx 基础服务、管理其他模块。 Handlers（处理器模块）：此类模块直接处理请求，并进行输出内容和修改 headers 信息等操作。 Filters （过滤器模块）：此类模块主要对其他处理器模块输出的内容进行修改操作，最后由 Nginx 输出。 Proxies （代理类模块）：此类模块是 Nginx 的 HTTP Upstream 之类的模块，这些模块主要与后端一些服务比如 FastCGI 等进行交互，实现服务代理和负载均衡等功能。 Nginx 的核心模块主要负责建立 nginx 服务模型、管理网络层和应用层协议、以及启动针对特定应用的一系列候选模块。其他模块负责分配给 web 服务器的实际工作： (1) 当 Nginx 发送文件或者转发请求到其他服务器，由 Handlers(处理模块) 或 Proxies（代理类模块）提供服务； (2) 当需要 Nginx 把输出压缩或者在服务端加一些东西，由 Filters(过滤模块) 提供服务。 2.2 模块处理 当服务器启动，每个handlers(处理模块)都有机会映射到配置文件中定义的特定位置（location）；如果有多个 handlers(处理模块) 映射到特定位置时，只有一个会 “赢”（说明配置文件有冲突项，应该避免发生）。 处理模块以三种形式返回： OK ERROR 或者放弃处理这个请求而让默认处理模块来处理（主要是用来处理一些静态文件，事实上如果是位置正确而真实的静态文件，默认的处理模块会抢先处理）。 如果handlers(处理模块)把请求反向代理到后端的服务器，就变成另外一类的模块：load-balancers（负载均衡模块）。负载均衡模块的配置中有一组后端服务器，当一个 HTTP 请求过来时，它决定哪台服务器应当获得这个请求。 Nginx 的负载均衡模块采用两种方法： 轮转法，它处理请求就像纸牌游戏一样从头到尾分发； IP 哈希法，在众多请求的情况下，它确保来自同一个 IP 的请求会分发到相同的后端服务器。 如果handlers(处理模块)没有产生错误，filters（过滤模块）将被调用。多个 filters（过滤模块）能映射到每个位置，所以（比如）每个请求都可以被压缩成块。它们的执行顺序在编译时决定。 filters（过滤模块）是经典的“接力链表（CHAIN OF RESPONSIBILITY）”模型：一个 filters（过滤模块）被调用，完成其工作，然后调用下一个 filters（过滤模块），直到最后一个 filters（过滤模块）。 过滤模块链的特别之处在于： 每个 filters（过滤模块）不会等上一个 filters（过滤模块）全部完成； 它能把前一个过滤模块的输出作为其处理内容；有点像 Unix 中的流水线； 过滤模块能以buffer（缓冲区）为单位进行操作，这些buffer一般都是一页（4K）大小，当然你也可以在nginx.conf文件中进行配置。这意味着，比如，模块可以压缩来自后端服务器的响应，然后像流一样的到达客户端，直到整个响应发送完成。 总之，过滤模块链以流水线的方式高效率地向客户端发送响应信息。 所以总结下上面的内容，一个典型的 HTTP 处理周期是这样的： 客户端发送 HTTP 请求 –&gt; Nginx 基于配置文件中的位置选择一个合适的处理模块 -&gt; (如果有) 负载均衡模块选择一台后端服务器 –&gt; 处理模块进行处理并把输出缓冲放到第一个过滤模块上 –&gt; 第一个过滤模块处理后输出给第二个过滤模块 –&gt; 然后第二个过滤模块又到第三个 –&gt; 依此类推 –&gt; 最后把响应发给客户端。 下图展示了 Nginx 模块处理流程： Nginx 本身做的工作实际很少，当它接到一个 HTTP 请求时，它仅仅是通过查找配置文件将此次请求映射到一个 location block，而此 location 中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做 Nginx 真正的劳动工作者。通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。 3 Nginx 请求处理Nginx 在启动时会以 daemon 形式在后台运行，采用多进程 + 异步非阻塞 IO 事件模型来处理各种连接请求。多进程模型包括一个 master 进程，多个 worker 进程，一般 worker 进程个数是根据服务器 CPU 核数来决定的。master 进程负责管理 Nginx 本身和其他 worker 进程。如下图： 从上图中可以很明显地看到，4 个 worker 进程的父进程都是 master 进程，表明 worker 进程都是从父进程 fork 出来的，并且父进程的 ppid 为 1，表示其为 daemon 进程。 需要说明的是，在 nginx 多进程中，每个 worker 都是平等的，因此每个进程处理外部请求的机会权重都是一致的。 Master 进程的作用是？ 读取并验证配置文件 nginx.conf；管理 worker 进程； Worker 进程的作用是？ 每一个 Worker 进程都维护一个线程（避免线程切换），处理连接和请求；注意 Worker 进程的个数由配置文件决定，一般和 CPU 个数相关（有利于进程切换），配置几个就有几个 Worker 进程。 Nginx 如何做到热部署？ 所谓热部署，就是配置文件 nginx.conf 修改后，不需要 stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载 / nginx -t 检查配置 / nginx -s stop） 通过上文我们已经知道 worker 进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象： 方案一： 修改配置文件 nginx.conf 后，主进程 master 负责推送给 woker 进程更新配置信息，woker 进程收到信息后，更新进程内部的线程信息。 方案二： 修改配置文件 nginx.conf 后，重新生成新的 worker 进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的 worker 进程，至于老的 worker 进程，等把那些以前的请求处理完毕后，kill 掉即可。 Nginx 采用的就是方案二来达到热部署的！ Nginx 如何做到高并发下的高效处理？ 上文已经提及 Nginx 的 worker 进程个数与 CPU 绑定、worker 进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。 作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步 / 同步、阻塞 / 非阻塞… 要同时处理那么多的请求，要知道，有的请求需要发生 IO，可能需要很长时间，如果等着它，就会拖慢 worker 的处理速度。 Nginx 采用了 Linux 的 epoll 模型，epoll 模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果 OK，那么放入 epoll 队列中，这个过程是异步的。worker 只需要从 epoll 队列循环处理即可。 Nginx 挂了怎么办？ Nginx 既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。 答案是：Keepalived+Nginx 实现高可用。 Keepalived 是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和 Nginx 配合来实现 Web 服务的高可用。（其实，Keepalived 不仅仅可以和 Nginx 配合，还可以和很多其他服务配合） Keepalived+Nginx 实现高可用的思路： 第一：请求不要直接打到 Nginx 上，应该先通过 Keepalived（这就是所谓虚拟 IP，VIP） 第二：Keepalived 应该能监控 Nginx 的生命状态（提供一个用户自定义的脚本，定期检查 Nginx 进程状态，进行权重变化,，从而实现 Nginx 故障切换） Nginx 架构及工作流程图： Nginx 真正处理请求业务的是 Worker 之下的线程。_worker进程中有一个ngx_worker_process_cycle()函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理_，直到整个 Nginx 服务被停止。 worker 进程中，ngx_worker_process_cycle() 函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下： 操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。 接收和处理这些事件，如是接收到数据，则产生更高层的 request 对象。 处理 request 的 header 和 body。 产生响应，并发送回客户端。 完成 request 的处理。 重新初始化定时器及其他事件。 3.1 多进程处理模型下面来介绍一个请求进来，多进程模型的处理方式： 首先，master 进程一开始就会根据我们的配置，来建立需要listen的网络socket fd，然后 fork 出多个 worker 进程。 其次，根据进程的特性，新建立的 worker 进程，也会和 master 进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。 然后，这个时候有多个 worker 进程都在监听同样设置的 socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的“惊群现象”。为了保证只会有一个进程成功注册到 listenfd 的读事件，_nginx中实现了一个“accept_mutex”类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件_。其他进程全部 accept 失败。 最后，监听成功的 worker 进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个 request 请求，只需要 worker 进程就可以完成。 进程模型的处理方式带来的一些好处就是：进程之间是独立的，也就是一个 worker 进程出现异常退出，其他 worker 进程是不会受到影响的；此外，独立进程也会避免一些不需要的锁操作，这样会提高处理效率，并且开发调试也更容易。 如前文所述，多进程模型+异步非阻塞模型才是胜出的方案。单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题；并且还因此避免的多线程的上下文切换导致的性能损失。 worker 进程会竞争监听客户端的连接请求：这种方式可能会带来一个问题，就是可能所有的请求都被一个worker进程给竞争获取了，导致其他进程都比较空闲，而某一个进程会处于忙碌的状态，这种状态可能还会导致无法及时响应连接而丢弃discard掉本有能力处理的请求。这种不公平的现象，是需要避免的，尤其是在高可靠 web 服务器环境下。 针对这种现象，Nginx 采用了一个是否打开 accept_mutex 选项的值，_ngx_accept_disabled标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件_。 ngx_accept_disabled 值：nginx 单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个 ngx_accept_disabled。 当 ngx_accept_disabled 大于 0 时，不会去尝试获取 accept_mutex 锁，并且将 ngx_accept_disabled 减 1，于是，每次执行到此处时，都会去减 1，直到小于 0。不去获取 accept_mutex 锁，就是等于让出获取连接的机会，很显然可以看出，_当空闲连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大_。不去 accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx 就控制了多进程间连接的平衡了。 3.2 一个简单的 HTTP 请求从 Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段： 初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。 处理请求头。 处理请求体。 如果有的话，调用与此请求（URL 或者 Location）关联的 handler。 依次调用各 phase handler 进行处理。 在建立连接过程中，_对于nginx监听到的每个客户端连接，都会将它的读事件的handler设置为ngx_http_init_request函数，这个函数就是请求处理的入口_。在处理请求时，主要就是要解析 http 请求，比如：uri，请求行等，然后再根据请求生成响应。下面看一下 nginx 处理的具体过程： 在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。所以 phase handlers 也就好理解了，就是包含若干个处理阶段的一些 handler。 在每一个阶段，包含有若干个 handler，再处理到某个阶段的时候，依次调用该阶段的 handler 对 HTTP Request 进行处理。 通常情况下，一个 phase handler 对这个 request 进行处理，并产生一些输出。通常 phase handler 是与定义在配置文件中的某个 location 相关联的。 一个 phase handler 通常执行以下几项任务： 获取 location 配置。 产生适当的响应。 发送 response header。 发送 response body。 当 Nginx 读取到一个 HTTP Request 的 header 的时候，Nginx 首先查找与这个请求关联的虚拟主机的配置。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase handlers）： NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段 NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段 NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段 NGX_HTTP_REWRITE_PHASE: Location 请求地址重写阶段 NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段 NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段 NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段 NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段 NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段 NGX_HTTP_CONTENT_PHASE: 内容产生阶段 NGX_HTTP_LOG_PHASE: 日志模块处理阶段 在内容产生阶段，为了给一个 request 产生正确的响应，Nginx 必须把这个 request 交给一个合适的 content handler 去处理。如果这个 request 对应的 location 在配置文件中被明确指定了一个 content handler，那么 Nginx 就可以通过对 location 的匹配，直接找到这个对应的 handler，并把这个 request 交给这个 content handler 去处理。这样的配置指令包括像，perl，flv，proxy_pass，mp4 等。 如果一个 request 对应的 location 并没有直接有配置的 content handler，那么 Nginx 依次尝试： 如果一个 location 里面有配置 random_index on，那么随机选择一个文件，发送给客户端。 如果一个 location 里面有配置 index 指令，那么发送 index 指令指明的文件，给客户端。 如果一个 location 里面有配置 autoindex on，那么就发送请求地址对应的服务端路径下的文件列表给客户端。 如果这个 request 对应的 location 上有设置 gzip_static on，那么就查找是否有对应的. gz 文件存在，有的话，就发送这个给客户端（客户端支持 gzip 的情况下）。 请求的 URI 如果对应一个静态文件，static module 就发送静态文件的内容到客户端。 内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理。filter 模块也是与 location 相关的。所有的 filter 模块都被组织成一条链。输出会依次穿越所有的 filter，直到有一个 filter 模块的返回值表明已经处理完成。 这里列举几个常见的 filter 模块，例如： server-side includes。 XSLT filtering。 图像缩放之类的。 gzip 压缩。 在所有的 filter 中，有几个 filter 模块需要关注一下。按照调用的顺序依次说明如下： copy: 将一些需要复制的 buf(文件或者内存) 重新复制一份然后交给剩余的 body filter 处理。 postpone: 这个 filter 是负责 subrequest 的，也就是子请求的。 write: 写输出到客户端，实际上是写到连接对应的 socket 上。 3.3 请求完整处理过程根据以上请求步骤所述，请求完整的处理过程如下图所示： 3.4 keepalive 长连接当然，在 nginx 中，对于 http1.0 与 http1.1 也是支持长连接的。 什么是长连接呢？我们知道，http 请求是基于 TCP 协议之上的，那么，当客户端在发起请求前，需要先与服务端建立 TCP 连接，而每一次的 TCP 连接是需要三次握手来确定的，如果客户端与服务端之间网络差一点，这三次交互消费的时间会比较多，而且三次交互也会带来网络流量。当然，当连接断开后，也会有四次的交互，当然对用户体验来说就不重要了。而 http 请求是请求应答式的，如果我们能知道每个请求头与响应体的长度，那么我们是可以在一个连接上面执行多个请求的，这就是所谓的长连接，但前提条件是我们先得确定请求头与响应体的长度。 对于请求来说，如果当前请求需要有 body，如 POST 请求，那么 nginx 就需要客户端在请求头中指定 content-length 来表明 body 的大小，否则返回 400 错误。也就是说，请求体的长度是确定的，那么响应体的长度呢？先来看看 http 协议中关于响应 body 长度的确定： 对于 http1.0 协议来说，如果响应头中有 content-length 头，则以 content-length 的长度就可以知道 body 的长度了，客户端在接收 body 时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有 content-length 头，则客户端会一直接收数据，直到服务端主动断开连接，才表示 body 接收完了。 而对于 http1.1 协议来说，如果响应头中的 Transfer-encoding 为 chunked 传输，则表示 body 是流式输出，body 会被分成多个块，每块的开始会标识出当前块的长度，此时，body 不需要通过长度来指定。如果是非 chunked 传输，而且有 content-length，则按照 content-length 来接收数据。否则，如果是非 chunked，并且没有 content-length，则客户端接收数据，直到服务端主动断开连接。 从上面，我们可以看到，除了 http1.0 不带 content-length 以及 http1.1 非 chunked 不带 content-length 外，body 的长度是可知的。此时，当服务端在输出完 body 之后，会可以考虑使用长连接。能否使用长连接，也是有条件限制的。如果客户端的请求头中的 connection 为 close，则表示客户端需要关掉长连接，如果为 keep-alive，则客户端需要打开长连接，如果客户端的请求中没有 connection 这个头，那么根据协议，如果是 http1.0，则默认为 close，如果是 http1.1，则默认为 keep-alive。如果结果为 keepalive，那么，nginx 在输出完响应体后，会设置当前连接的 keepalive 属性，然后等待客户端下一次请求。 当然，nginx 不可能一直等待下去，如果客户端一直不发数据过来，岂不是一直占用这个连接？所以当 nginx 设置了 keepalive 等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项 keepalive_timeout 来配置的，如果配置为 0，则表示关掉 keepalive，此时，http 版本无论是 1.1 还是 1.0，客户端的 connection 不管是 close 还是 keepalive，都会强制为 close。 如果服务端最后的决定是 keepalive 打开，那么在响应的 http 头里面，也会包含有 connection 头域，其值是”Keep-Alive”，否则就是”Close”。如果 connection 值为 close，那么在 nginx 响应完数据后，会主动关掉连接。所以，对于请求量比较大的 nginx 来说，关掉 keepalive 最后会产生比较多的 time-wait 状态的 socket。一般来说，当客户端的一次访问，需要多次访问同一个 server 时，打开 keepalive 的优势非常大，比如图片服务器，通常一个网页会包含很多个图片。打开 keepalive 也会大量减少 time-wait 的数量。 参考 WEB 请求处理二：Nginx 请求反向代理 Nginx 开发从入门到精通 深入浅出 Nginx 原理参考：理解Nginx工作原理 - 简书https://www.jianshu.com/p/6215e5d24553Nginx工作原理和优化、漏洞。 - CSDN博客https://blog.csdn.net/hguisu/article/details/8930668]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-2%2F</url>
    <content type="text"><![CDATA[使用 ^\#\#\#(注意正则表达式结尾是一个空格)正则表达式进行替换查找博客中的三级标题，]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP面试总结]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-1%2F</url>
    <content type="text"><![CDATA[下面是我整理下来的 JSP 知识点: 图上的知识点都可以在我其他的文章内找到相应内容。 JSP 常见面试题jsp 静态包含和动态包含的区别 jsp 静态包含和动态包含的区别 在讲解 request 对象的时候，我们曾经使用过 request.getRequestDispatcher(String url).include(request,response) 来对页头和页尾面进行包含 inclue 指令也是做这样的事情，我们来试验一下吧！ 这是页头 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是页头 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 这是页尾 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页尾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;我是页尾&lt;/body&gt;&lt;/html&gt; 在 1.jsp 中把页头和页尾包含进来 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;包含页头和页尾进来&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%@include file=&quot;head.jsp&quot; %&gt;&lt;%@include file=&quot;foot.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 访问 1.jsp include 指令是静态包含。静态包含的意思就是：把文件的代码内容都包含进来，再编译！，看一下 jsp 的源代码就知道了！ 上面已经提及到了，include 指令是静态包含，include 行为是动态包含。其实 include 行为就是封装了 request.getRequestDispatcher(String url).include(request,response) include 行为语法是这个样子的 12&lt;jsp:include page=&quot;&quot;/&gt; 我们先来使用一下把，在 1.jsp 页面中也将页头和页尾包含进来。 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;包含页头和页尾进来&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:include page=&quot;head.jsp&quot;/&gt; &lt;jsp:include page=&quot;foot.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 访问 1.jsp 页面看一下效果： 使用 jsp 行为来包含文件，jsp 源文件是这样子的： jsp 行为包含文件就是先编译被包含的页面，再将页面的结果写入到包含的页面中（1.jsp) 当然了，现在有静态包含和动态包含，使用哪一个更好呢？答案是：动态包含。 动态包含可以向被包含的页面传递参数（用处不大），并且是分别处理包含页面的（将被包含页面编译后得出的结果再写进包含页面）【如果有相同名称的参数，使用静态包含就会报错！】！ 模拟一下场景吧，现在我的头页面有个名为 s 的字符串变量 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% String s = &quot;zhongfucheng&quot;; %&gt; 我是页头呀 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 我的页尾也有个名为 s 的字符串变量 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页尾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% String s = &quot;zhongfucheng&quot;;%&gt;我是页尾呀&lt;/body&gt;&lt;/html&gt; 现在我使用静态包含看看会发生什么，出现异常了。 出现异常的原因很简单，就是同一个文件中有两个相同的变量 s 使用动态包含就可以避免这种情况 总结 &lt;%@include file=&quot;xxx.jsp&quot;%&gt;为 jsp 中的编译指令，其文件的包含是发生在 jsp 向 servlet 转换的时期，而&lt;jsp:include page=&quot;xxx.jsp&quot;&gt;是 jsp 中的动作指令，其文件的包含是发生在编译时期，也就是将 java 文件编译为 class 文件的时期 使用静态包含只会产生一个 class 文件，而使用动态包含会产生多个 class 文件 使用静态包含，包含页面和被包含页面的 request 对象为同一对象，因为静态包含只是将被包含的页面的内容复制到包含的页面中去；而动态包含包含页面和被包含页面不是同一个页面，被包含的页面的 request 对象可以取到的参数范围要相对大些，不仅可以取到传递到包含页面的参数，同样也能取得在包含页面向下传递的参数 jsp 有哪些内置对象? 作用分别是什么? jsp 有哪些内置对象? 作用分别是什么? 九个内置对象： pageContext page config request response session application exception out 其中，request、response、session、application、config 这五个对象和 Servlet 的 API 是一样的。这 5 个对象我就不解释了。 在 JSP 中，尤其重要的是 pageContext 对象。 pageContext 是内置对象中最重要的一个对象，它代表着 JSP 页面编译后的内容（也就是 JSP 页面的运行环境）！ pageContext 对象 既然它代表了 JSP 页面编译后的内容，理所当然的：它封装了对其他 8 大内置对象的引用！，也就是说，通过 pageContext 可以获取到其他的 8 个内置对象！ 123456789101112131415161718192021222324&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;获取八大内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(pageContext.getSession()); System.out.println(pageContext.getRequest()); System.out.println(pageContext.getResponse()); System.out.println(pageContext.getException()); System.out.println(pageContext.getPage()); System.out.println(pageContext.getServletConfig()); System.out.println(pageContext.getServletContext()); System.out.println(pageContext.getOut());%&gt;&lt;/body&gt;&lt;/html&gt; 看下效果： pageContext 作为域对象 类似于 request，session，ServletContext 作为域对象而言都有以下三个方法： setAttribute(String name,Objcet o) getAttribute(String name) removeAttribute(String name) 当然了，pageContext 也不例外，pageContext 也有这三个方法！ pageContext 本质上代表的是当前 JSP 页面编译后的内容，作为域对象而言，它就代表着当前 JSP 页面（也就是 page）！也就是说：pageContext 域对象只在 page 范围内有效，超出了 page 范围就无效了！ 首先来看看在 page 范围内能不能使用 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用page域对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;zhongfucheng&quot;);%&gt;&lt;% String value = (String) pageContext.getAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 我们现在来试验一下是不是超出了 page 范围就无效了！ 在 2.jsp 中 request 域对象设置属性 123456789101112131415161718&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request域对象设置属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //这是request域对象保存的内容 request.setAttribute(&quot;name&quot;,&quot;zhongfucheng&quot;);%&gt;&lt;%--跳转到1.jsp中--%&gt;&lt;jsp:forward page=&quot;1.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 企图在 1.jsp 中 pageContext 取出 request 存进去的属性 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在page域对象获取属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //企图获取request域对象存进的属性 String value = (String) pageContext.getAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： pageContext 本质上代表着编译后 JSP 的内容，pageContext 还可以封装了访问其他域的方法！ 上面的 pageContext 默认是 page 范围的，但 pageContext 对象重载了 set、get、removeAttribute 这三个方法 getAttribute(String name,int scope) setAttribute(String name,Object value,int scope) removeAttribute(String name,int scope) 多了一个设置域范围的一个参数，如果不指定默认就是 page。当然了，pageContext 把 request、session、application、page 这几个域对象封装着了静态变量供我们使用。 PageContext.APPLICATION_SCOPE PageContext.SESSION_SCOPE PageContext.REQUEST_SCOPE PageContext.PAGE_SCOPE 刚才我们没有使用重载方法的时候，使用 pageContext 是无法获取到 request 域对象设置的属性的。现在我们使用重载后的方法看一下能不能获取得到！ 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在page域对象获取request域对象的属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //使用重载的方法获取request域对象的属性 String value = (String) pageContext.getAttribute(&quot;name&quot;,pageContext.REQUEST_SCOPE); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果： pageContexst 还有这么一个方法： findAttribute(String name) 该方法会查找各个域的属性，从小到大开始寻找！也就是 page—&gt;request-&gt;session-&gt;application。 我们用此方法看能不能查找出 request 域对象的属性吧！ 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用findAttribute&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //使用findAttribute查找2.jsp中request域对象的属性 String value = (String) pageContext.findAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： out 对象： out 对象用于向浏览器输出数据，与之对应的是 Servlet 的 PrintWriter 对象。然而这个 out 对象的类型并不是 PrintWriter，是 JspWriter 我们可以简单理解为：JspWriter 就是带缓存的 PrintWrieter。 out 对象的原理如下： 只有向 out 对象中写入了内容，且满足如下任何一个条件时，out 对象才去调用 ServletResponse.getWriter 方法，并通过该方法返回的 PrintWriter 对象将 out 对象的缓冲区中的内容真正写入到 Servlet 引擎提供的缓冲区中： 设置 page 指令的 buffer 属性关闭了 out 对象的缓存功能 out 对象的缓冲区已满 整个 JSP 页面结束 一般我们在 JSP 页面输出都是用表达式（&lt;%=%&gt;)，所以 out 对象用得并不是很多！ page 对象 内置对象 page 是 HttpJasPage 对象，其实 page 对象代表的就是当前 JSP 页面，是当前 JSP 编译后的 Servlet 类的对象。也就是说：page 对象相当于普通 java 类的 this exception 对象 内置对象 exception 是 java.lang.Exception 类的对象，exception 封装了 JSP 页面抛出的异常信息。exception 经常被用来处理错误页面 前面我们已经讲过了怎么设置错误页面了，下面我们就来简单使用一下 exception 对象吧 1.jsp 页面 1234&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; errorPage=&quot;error.jsp&quot; %&gt;&lt;%--模拟空指针异常的错误--%&gt;&lt;% String sss = null; sss.length();%&gt; error.jsp 页面 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isErrorPage=&quot;true&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% out.println(&quot;程序抛出了异常：&quot; + exception);%&gt;&lt;/body&gt;&lt;/html&gt; 效果： 总结 request 用户端请求，此请求会包含来自 GET/POST 请求的参数 response 网页传回用户端的回应 pageContext 网页的属性是在这里管理，代表的编译后 JSP 内容 session 与请求有关的会话期 application servlet 正在执行的内容 out 用来传送回应的输出 config servlet 的构架部件 page JSP 网页本身 exception 针对错误网页，未捕捉的例外 jsp 和 servlet 的区别、共同点、各自应用的范围？ jsp 和 servlet 的区别、共同点、各自应用的范围？ JSP 是 Servlet 技术的扩展，本质上就是 Servlet 的简易方式。JSP 编译后是 “类 servlet”。 Servlet 和 JSP 最主要的不同点在于：Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为. jsp 的文件。 JSP 侧重于视图，Servlet 主要用于控制逻辑。 属性作用域范围 属性作用域范围 page【只在一个页面中保存属性，跳转页面无效】 requet【只在一次请求中保存属性，服务器跳转有效，浏览器跳转无效】 session【在一个会话范围中保存属性，无论何种跳转均有效，关闭浏览器后无效】 application【在整个服务器中保存，所有用户都可以使用】 应用场景： request：如果客户向服务器发请求，产生的数据，用户看完就没用了，像这样的数据就存在 request 域, 像新闻数据，属于用户看完就没用的 session：如果客户向服务器发请求，产生的数据，用户用完了等一会儿还有用，像这样的数据就存在 session 域中，像购物数据，用户需要看到自己购物信息，并且等一会儿，还要用这个购物数据结帐 servletContext：如果客户向服务器发请求，产生的数据，用户用完了，还要给其它用户用，像这样的数据就存在 servletContext 域中，像聊天数据 写出 5 种 JSTL 常用标签 写出 5 种 JSTL 常用标签 12&lt;c:if&gt;，&lt;c:item&gt;，&lt;c:foreach&gt;，&lt;c:out&gt;，&lt;c:set&gt; 写一个自定义标签要继承什么类 写一个自定义标签要继承什么类 我们可以有两种方式来实现自定义标签： 传统方式，实现 Tag 接口 (老方法) 简单方式，继承 SimpleTagSupport 类 SimpleTagSupport 类的执行顺序 (原理)： ①WEB 容器调用标签处理器对象的 setJspContext 方法，将代表 JSP 页面的 pageContext 对象传递给标签处理器对象 ②WEB 容器调用标签处理器对象的 setParent 方法，将父标签处理器对象传递给这个标签处理器对象。【注意，只有在标签存在父标签的情况下，WEB 容器才会调用这个方法】 ③如果调用标签时设置了属性，容器将调用每个属性对应的 setter 方法把属性值传递给标签处理器对象。如果标签的属性值是 EL 表达式或脚本表达式，则 WEB 容器首先计算表达式的值，然后把值传递给标签处理器对象。 ④如果简单标签有标签体，容器将调用 setJspBody 方法把代表标签体的 JspFragment 对象传递进来 ⑤执行标签时：容器调用标签处理器的 doTag() 方法，开发人员在方法体内通过操作 JspFragment 对象，就可以实现是否执行、迭代、修改标签体的目的。 总结SimpleTagSupport，一般调用 doTag 方法或者实现 SimpleTag 接口 JSP 是如何被执行的？执行效率比 SERVLET 低吗？ JSP 是如何被执行的？执行效率比 SERVLET 低吗？ 当客户端向一个 jsp 页面发送请求时，Web Container 将 jsp 转化成 servlet 的源代码（只在第一次请求时），然后编译转化后的 servlet 并加载到内存中执行，执行的结果 response 到客户端 jsp 只在第一次执行的时候会转化成 servlet，以后每次执行，web 容器都是直接执行编译后的 servlet，所以 jsp 和 servlet 只是在第一次执行的时候不一样，jsp 慢一点，以后的执行都是相同的 如何避免 jsp 页面自动生成 session 对象？为什么要这么做？ 如何避免 jsp 页面自动生成 session 对象？为什么要这么做？ 可以使用页面指令显式关掉，代码如下： &lt;%@ page session=&quot;false&quot; %&gt; jsp 的缺点？ jsp 的缺点？ 1）不好调试 2）与其他脚本语言的交互 (可读性差) 说出 Servlet 和 CGI 的区别？ 说出 Servlet 和 CGI 的区别？ Servlet 处于服务器进程中，只会有一个 servlet 实例，每个请求都会产生一个新的线程，而且 servlet 实例一般不会销毁 CGI：来一个请求就创建一个进程，用完就销毁，效率低于 servlet 简述 JSP 的设计模式。 简述 JSP 的设计模式。 在 Web 开发模式中，有两个主要的开发结构，称为模式一（Mode I）和模式二（Mode II） 首先我们来理清一些概念吧： DAO(Data Access Object)：主要对数据的操作，增加、修改、删除等原子性操作。 Web 层：界面 + 控制器，也就是说 JSP【界面】+Servlet【控制器】 Service 业务层：将多个原子性的 DAO 操作进行组合，组合成一个完整的业务逻辑 控制层：主要使用 Servlet 进行控制 数据访问层：使用 DAO、Hibernate、JDBC 技术实现对数据的增删改查 JavaBean 用于封装数据，处理部分核心逻辑，每一层中都用到！ 模式一指的就是在开发中将显示层、控制层、数据层的操作统一交给 JSP 或者 JavaBean 来进行处理！ 模式一有两种情况： 完全使用 JSP 做开发: 优点： 开发速度贼快，只要写 JSP 就行了，JavaBean 和 Servlet 都不用设计！ 小幅度修改代码方便，直接修改 JSP 页面交给 WEB 容器就行了，不像 Servlet 还要编译成. class 文件再交给服务器！【当然了，在 ide 下开发这个也不算是事】 缺点： 程序的可读性差、复用性低、代码复杂！什么 jsp 代码、html 代码都往上面写，这肯定很难阅读，很难重用！ 使用 JSP+JavaBean 做开发: 优点： 程序的可读性较高，大部分的代码都写在 JavaBean 上，不会和 HTML 代码混合在一起，可读性还行的。 可重复利用高，核心的代码都由 JavaBean 开发了，JavaBean 的设计就是用来重用、封装，大大减少编写重复代码的工作！ 缺点： 没有流程控制，程序中的 JSP 页面都需要检查请求的参数是否正确，异常发生时的处理。显示操作和业务逻辑代码工作会紧密耦合在一起的！日后维护会困难 Mode II 中所有的开发都是以 Servlet 为主体展开的，由 Servlet 接收所有的客户端请求，然后根据请求调用相对应的 JavaBean，并所有的显示结果交给 JSP 完成！，也就是俗称的 MVC 设计模式！ MVC 设计模式： 显示层（View）：主要负责接受 Servlet 传递的内容，调用 JavaBean，将内容显示给用户 控制层（Controller）：主要负责所有用户的请求参数，判断请求参数是否合法，根据请求的类型调用 JavaBean，将最终的处理结果交给显示层显示！ 模型层（Mode）：模型层包括了业务层，DAO 层。 总结 （1）ModelI，JSP+JavaBean 设计模式。 （2）ModelII，MVC 设计模式。 参考：Servlet+JSP - 文集 - 简书https://www.jianshu.com/nb/21926044]]></content>
      <tags>
        <tag>面试</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP 学习]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29%2F</url>
    <content type="text"><![CDATA[JSP 第一篇【JSP 介绍、工作原理、生命周期、语法、指令、行为】什么是 JSPJSP 全名为 Java Server Pages，java 服务器页面。JSP 是一种基于文本的程序，其特点就是 HTML 和 Java 代码共同存在！ 为什么需要 JSPJSP 是为了简化 Servlet 的工作出现的替代品，Servlet 输出 HTML 非常困难，JSP 就是替代 Servlet 输出 HTML 的。 简单使用一下 JSP 在 idea 下生成一个 JSP，我们来看一下 JSP 长什么样子 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;简单使用JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 看起来就像一个 HTML 页面，前面也说了：JSP 的特点就是 HTML 和 Java 代码共同存在 我们向浏览器输出一句 HelloWorld，至于 &lt;%%&gt; 这个东西，我先不解释！ 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;简单使用JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% String s = &quot;HelloWorld&quot;; out.println(s);%&gt;&lt;/body&gt;&lt;/html&gt; JSP 的工作原理 在 Tomcat 博客中我提到过：Tomcat 访问任何的资源都是在访问 Servlet！，当然了，JSP 也不例外！JSP 本身就是一种 Servlet。为什么我说 JSP 本身就是一种 Servlet 呢？其实 JSP 在第一次被访问的时候会被编译为 HttpJspPage 类（该类是 HttpServlet 的一个子类） 刚才我简单使用了一下 JSP，它被编译成了这么一个 Servlet: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;import java.util.Date;public final class _1_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent &#123; private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory(); private static java.util.List&lt;String&gt; _jspx_dependants; private javax.el.ExpressionFactory _el_expressionfactory; private org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.List&lt;String&gt; getDependants() &#123; return _jspx_dependants; &#125; public void _jspInit() &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); &#125; public void _jspDestroy() &#123; &#125; public void _jspService(final HttpServletRequest request, final HttpServletResponse response) throws java.io.IOException, ServletException &#123; final PageContext pageContext; HttpSession session = null; final ServletContext application; final ServletConfig config; JspWriter out = null; final Object page = this; JspWriter _jspx_out = null; PageContext _jspx_page_context = null; try &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(&quot;\r\n&quot;); out.write(&quot;\r\n&quot;); out.write(&quot;&lt;html&gt;\r\n&quot;); out.write(&quot;&lt;head&gt;\r\n&quot;); out.write(&quot; &lt;title&gt;简单使用JSP&lt;/title&gt;\r\n&quot;); out.write(&quot;&lt;/head&gt;\r\n&quot;); out.write(&quot;&lt;body&gt;\r\n&quot;); String s = &quot;HelloWorda&quot;; out.println(s); out.write(&quot;\r\n&quot;); out.write(&quot;&lt;/body&gt;\r\n&quot;); out.write(&quot;&lt;/html&gt;\r\n&quot;); &#125; catch (Throwable t) &#123; if (!(t instanceof SkipPageException))&#123; out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125; if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); &#125; &#125; finally &#123; _jspxFactory.releasePageContext(_jspx_page_context); &#125; &#125;&#125; 编译过程是这样子的：浏览器第一次请求 1.jsp 时，Tomcat 会将 1.jsp 转化成 1_jsp.java 这么一个类，并将该文件编译成 class 文件。编译完毕后再运行 class 文件来响应浏览器的请求。 以后访问 1.jsp 就不再重新编译 jsp 文件了，直接调用 class 文件来响应浏览器。当然了，如果 Tomcat 检测到 JSP 页面改动了的话，会重新编译的。 既然 JSP 是一个 Servlet，那 JSP 页面中的 HTML 排版标签是怎么样被发送到浏览器的？我们来看下上面 1_jsp.java 的源码就知道了。原来就是用 write() 出去的罢了。说到底，JSP 就是封装了 Servlet 的 java 程序罢了。 12345678out.write(&quot;\r\n&quot;);out.write(&quot;\r\n&quot;);out.write(&quot;&lt;html&gt;\r\n&quot;);out.write(&quot;&lt;head&gt;\r\n&quot;);out.write(&quot; &lt;title&gt;简单使用JSP&lt;/title&gt;\r\n&quot;);out.write(&quot;&lt;/head&gt;\r\n&quot;);out.write(&quot;&lt;body&gt;\r\n&quot;); 有人可能也会问：JSP 页面的代码服务器是怎么执行的？再看回 1_jsp.java 文件，java 代码就直接在类中的 service() 中。 123String s = &quot;HelloWorda&quot;;out.println(s); JSP 比 Servlet 更方便更简单的一个重要原因就是：内置了 9 个对象！内置对象有：out、session、response、request、config、page、application、pageContext、exception，这几个内置对象不在这里讲。现在先知道一下即可！ JSP 生命周期JSP 也是 Servlet，运行时只有一个实例，JSP 初始化和销毁时也会调用 Servlet 的 init() 和 destroy() 方法。另外，JSP 还有自己初始化和销毁的方法 12345678public void _jspInit() &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());&#125;public void _jspDestroy() &#123;&#125; JSP 的语法JSP 代码可以分为两部分： 模板数据：就是 HTML 代码 元素：JSP 页面中的 java 代码、JSP 指令、JSP 标签 JSP 脚本 JSP 的脚本就是 JSP 页面中的 java 代码，也叫做 scriptlet。JSP 的脚本必须使用 &lt;%%&gt; 括起来，不然会被当成是模板数据的！ JSP 脚本有三种方式： &lt;%%&gt;【定义局部变量，编写语句】 &lt;%!%&gt;【定义类或方法，但是没人这样用！】 &lt;%=%&gt;（也称之为表达式输出）【输出各种类型的变量，int、double、String、Object 等】 如果过多地使用 &lt;%%&gt; 会导致代码混乱，JSP 还提供了一种 scriptlet 标签，使用此标签和 &lt;%%&gt; 有相同的功能，只不过它更美观了一些 1234567&lt;jsp:scriptlet&gt; String s = &quot;HelloWorld&quot;; out.println(s);&lt;/jsp:scriptlet&gt; JSP 注释123456789&lt;%--这是JSP注释--%&gt;&lt;%--%&gt;//这是java的当行注释///*这是java的多行注释*//**/ JSP 指令JSP 指令用来声明 JSP 页面的相关属性，例如编码方式、文档类型等等 JSP 指令的语法： 12&lt;%@指令 属性名=&quot;值&quot; %&gt; page 指令 我在 idea 生成的 JSP 页面就有 page 指令了。 12&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; page 指令常见属性： language=”java” extends=”package.class” import=”{package.class | package.*}, …” session=”true | false” buffer=”none | 8kb | sizekb” autoFlush=”true | false” isThreadSafe=”true | false” info=”text” errorPage=”relative_url” isErrorPage=”true | false” contentType=”mimeType ;charset=characterSet” | “text/html ; charset=ISO-8859-1” pageEncoding=”characterSet | ISO-8859-1” isELIgnored=”true | false” 一般地，在 eclipse 或 idea 这些高级开发工具上开发，我们只需要在 page 指令中指定 contentType=”text/html;charset=UTF-8”，就不会出现中文乱码问题！ 当然了 contentType 不仅仅可以指定以 text/html 的方式显示，还可以使用其他的形式显示出来。在 conf/web.xml 文件中可以查询出来 比如，我以 doc 形式显示 jsp 的数据 1234567891011&lt;%@ page contentType=&quot;application/msword;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;简单使用JSP&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1111&lt;/body&gt;&lt;/html&gt; 效果是这样子的： 我们上网的时候，如果我们操作不当，或者服务器出错了，页面都是会出现友好提示的！这个也能通过 page 指令来实现跳转到友好提示页面上！ page 指令 errorPage = 和 isErrorPage 这两个属性，下面我们来看一下怎么使用！ 1.jsp 出现了错误，通过 page 指令的 errorPage 属性跳转到 error.jsp 页面上 1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; errorPage=&quot;error.jsp&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;该页面出错了！&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--模拟页面出错了！！！--%&gt; &lt;% int result = 2 / 0; %&gt; 你好呀&lt;/body&gt;&lt;/html&gt; error.jsp 页面要通过 page 指令的 isErrorPage 属性设置页面就是错误页面 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isErrorPage=&quot;true&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;友好提示页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 服务器正忙着呢！ &lt;/body&gt;&lt;/html&gt; 下面是效果： 当然了，细心的朋友可以发现地址栏是没有变化的，所以属于是服务器跳转。以上的做法是单个页面设置的，如果我会有很多错误（JSP 多的情况下，错误就会多），单个设置太麻烦了！ 我们可以在 web.xml 文件中全局设置错误页，只要发生了 404 错误或者空指针异常的错误都会跳转到 error.jsp 页面上 12345678910&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;exception-type&gt;java.lang.NullPointerException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt; 随便输个资源进行，会发生发 404 错误的，跳转到错误页面。下面是效果： include 指令 在讲解 request 对象的时候，我们曾经使用过 request.getRequestDispatcher(String url).include(request,response) 来对页头和页尾面进行包含 inclue 指令也是做这样的事情，我们来试验一下吧！ 这是页头 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我是页头 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 这是页尾 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页尾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;我是页尾&lt;/body&gt;&lt;/html&gt; 在 1.jsp 中把页头和页尾包含进来 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;包含页头和页尾进来&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%@include file=&quot;head.jsp&quot; %&gt;&lt;%@include file=&quot;foot.jsp&quot; %&gt;&lt;/body&gt;&lt;/html&gt; 访问 1.jsp include 指令是静态包含。静态包含的意思就是：把文件的代码内容都包含进来，再编译！，看一下 jsp 的源代码就知道了！ jsp 还提供另一种包含文件的方式：JSP 行为 — 动态包含。jsp 行为在下面会讲到！ taglib 指令 JSP 支持标签技术，要使用标签技术就先得声明标签库和标签前缀。taglib 指令就是用来指明 JSP 页面内使用标签库技术。 这里就不详细说明了，等到学习 JSP 标签的时候再使用吧！现在记住有这个指令即可。 JSP 行为 JSP 行为（JSP Actions）是一组 JSP 内置的标签，只书写少量的标记代码就能够使用 JSP 提供丰富的功能，JSP 行为是对常用的 JSP 功能的抽象和封装。 为什么我不把它直接称为 JSP 标签呢？我把这些 JSP 内置的标签称之为 JSP 行为，能够和 JSTL 标签区分开来。当然了，你也可以把它称之为 JSP 标签，你不要搞混就行了。我个人喜欢把这些 JSP 内置标签称之为 JSP 行为。 include 行为 上面已经提及到了，include 指令是静态包含，include 行为是动态包含。其实 include 行为就是封装了 request.getRequestDispatcher(String url).include(request,response) include 行为语法是这个样子的 12&lt;jsp:include page=&quot;&quot;/&gt; 我们先来使用一下把，在 1.jsp 页面中也将页头和页尾包含进来。 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;包含页头和页尾进来&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:include page=&quot;head.jsp&quot;/&gt; &lt;jsp:include page=&quot;foot.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 访问 1.jsp 页面看一下效果： 使用 jsp 行为来包含文件，jsp 源文件是这样子的： jsp 行为包含文件就是先编译被包含的页面，再将页面的结果写入到包含的页面中（1.jsp) 当然了，现在有静态包含和动态包含，使用哪一个更好呢？答案是：动态包含。 动态包含可以向被包含的页面传递参数（用处不大），并且是分别处理包含页面的（将被包含页面编译后得出的结果再写进包含页面）【如果有相同名称的参数，使用静态包含就会报错！】！ 模拟一下场景吧，现在我的头页面有个名为 s 的字符串变量 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% String s = &quot;zhongfucheng&quot;; %&gt; 我是页头呀 &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 我的页尾也有个名为 s 的字符串变量 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;页尾&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% String s = &quot;zhongfucheng&quot;;%&gt;我是页尾呀&lt;/body&gt;&lt;/html&gt; 现在我使用静态包含看看会发生什么，出现异常了。 出现异常的原因很简单，就是同一个文件中有两个相同的变量 s 使用动态包含就可以避免这种情况 param 行为 当使用 forward 行为 在讲解 request 对象的时候，我们使用 request.getRequestDispatcher(String url).forward(request,response) 进行跳转。其实 forward 行为就是对其封装！ 我们来看一下 forward 的语法： 1&lt;jsp:forward page=&quot;&quot;/&gt; 好的，我们来使用一下吧。访问 1.jsp 页面就跳转到 head.jsp 页面中 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;访问1.jsp就跳转到head.jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;jsp:forward page=&quot;head.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 看一下效果 如果我要传递参数，就要在 forward 行为嵌套 param 行为 在跳转到 head.jsp 时传入参数 username 值为 zhongfucheng 123&lt;jsp:forward page=&quot;head.jsp&quot;&gt; &lt;jsp:param /&gt;&lt;/jsp:forward&gt; 在 head.jsp 页面中获取到传递过来的参数 1234567&lt;% String ss = request.getParameter(&quot;username&quot;);%&gt;获取到的参数是：&lt;%=ss%&gt; 效果如下图所示 directive 行为 directive 的中文意思就是指令。该行为就是替代指令 %@% 的语法的 我们来试一下能不能用的 123&lt;jsp:directive.include file=&quot;head.jsp&quot;&gt;&lt;/jsp:directive.include&gt;&lt;jsp:directive.include file=&quot;foot.jsp&quot;&gt;&lt;/jsp:directive.include&gt; 看下效果，正常可以包含页面： 使用该指令可以让 JSP 页面更加美观！ 使用 scriptlet 行为&lt;jsp:scriptlet&gt;替代 &lt;%%&gt; 是同样一个道理 javaBean 行为 JSP 还提供了操作 javaBean 对象的行为，在这里就不详细说明了，后面会讲到的！现在记住 JSP 提供了 javaBean 行为来操作简单类即可！ &lt;jsp:useBean id=&quot;&quot;/&gt; &lt;jsp:setProperty /&gt; &lt;jsp:getProperty /&gt; JSP 第二篇【内置对象的介绍、4 种属性范围、应用场景】什么是 JSP 内置对象 JSP 引擎在调用 JSP 对应的 jspServlet 时，会传递或创建 9 个与 web 开发相关的对象供 jspServlet 使用。JSP 技术的设计者为便于开发人员在编写 JSP 页面时获得这些 web 对象的引用，特意定义了 9 个相应的变量，开发人员在 JSP 页面中通过这些变量就可以快速获得这 9 大对象的引用 细心的朋友会发现，我们没有在 JSP 页面上定义过 out 对象，却可以直接使用！其实 out 对象就是 JSP 内置对象之一。 九个内置对象： pageContext page config request response session application exception out out 对象out 对象的 API int getBufferSize()【得到缓存大小】 int getRemaining()【得到未使用缓存的大小】 boolean isAutoFlush() void println() void flush() void close() void clearBuffer() void clear() out 对象用于向浏览器输出数据，与之对应的是 Servlet 的 PrintWriter 对象。然而这个 out 对象的类型并不是 PrintWriter，是 JspWriter 我们可以简单理解为：JspWriter 就是带缓存的 PrintWrieter。 out 对象的原理如下： 只有向 out 对象中写入了内容，且满足如下任何一个条件时，out 对象才去调用 ServletResponse.getWriter 方法，并通过该方法返回的 PrintWriter 对象将 out 对象的缓冲区中的内容真正写入到 Servlet 引擎提供的缓冲区中： 设置 page 指令的 buffer 属性关闭了 out 对象的缓存功能 out 对象的缓冲区已满 整个 JSP 页面结束 一般我们在 JSP 页面输出都是用表达式（&lt;%=%&gt;)，所以 out 对象用得并不是很多！ request 内置对象 request 其实就是 HttpServletRequest，在 Servlet 讲解的时候已经详细说明了，没什么好说的 response 内置对象 response 其实就是 HttpServletResponse，在 Servlet 讲解的时候已经详细说明了，没什么好说的 config 内置对象 config 其实就是 ServletConfig，在 Servlet 讲解的时候已经详细说明了，没什么好说的 session 内置对象 session 其实就是 HttpSession。，在 Servlet 讲解的时候已经详细说明了，没什么好说的 注意：在 page 指令配置如下信息，session 将不可使用 12&lt;%@page session=&quot;false&quot; %&gt; application 内置对象 application 其实就是 ServletContext 对象，在 Servlet 讲解的时候已经详细说明了，没什么好说的 page 内置对象 page 是 HttpJasPage 对象，其实 page 对象代表的就是当前 JSP 页面，是当前 JSP 编译后的 Servlet 类的对象。也就是说：page 对象相当于普通 java 类的 this exception 内置对象 exception 是 java.lang.Exception 类的对象，exception 封装了 JSP 页面抛出的异常信息。exception 经常被用来处理错误页面 前面我们已经讲过了怎么设置错误页面了，下面我们就来简单使用一下 exception 对象吧 1.jsp 页面 1234&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; errorPage=&quot;error.jsp&quot; %&gt;&lt;%--模拟空指针异常的错误--%&gt;&lt;% String sss = null; sss.length();%&gt; 12* error.jsp页面 1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isErrorPage=&quot;true&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% out.println(&quot;程序抛出了异常：&quot; + exception);%&gt;&lt;/body&gt;&lt;/html&gt; 效果： pageContextpageContext是内置对象中最重要的一个对象，它代表着JSP页面编译后的内容（也就是JSP页面的运行环境）！ pageContext获取8个内置对象 既然它代表了JSP页面编译后的内容，理所当然的：它封装了对其他8大内置对象的引用！，也就是说，通过pageContext可以获取到其他的8个内置对象！ 1234567891011121314151617181920212223&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;获取八大内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(pageContext.getSession()); System.out.println(pageContext.getRequest()); System.out.println(pageContext.getResponse()); System.out.println(pageContext.getException()); System.out.println(pageContext.getPage()); System.out.println(pageContext.getServletConfig()); System.out.println(pageContext.getServletContext()); System.out.println(pageContext.getOut());%&gt;&lt;/body&gt;&lt;/html&gt; pageContext作为域对象 类似于request，session，ServletContext作为域对象而言都有以下三个方法： setAttribute(String name,Objcet o) getAttribute(String name) removeAttribute(String name) 当然了，pageContext也不例外，pageContext也有这三个方法！ pageContext本质上代表的是当前JSP页面编译后的内容，作为域对象而言，它就代表着当前JSP页面（也就是page）！也就是说：pageContext域对象只在page范围内有效，超出了page范围就无效了！ 首先来看看在page范围内能不能使用 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用page域对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;zhongfucheng&quot;);%&gt;&lt;% String value = (String) pageContext.getAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 我们现在来试验一下是不是超出了page范围就无效了！ 在2.jsp中request域对象设置属性 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;request域对象设置属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //这是request域对象保存的内容 request.setAttribute(&quot;name&quot;,&quot;zhongfucheng&quot;);%&gt;&lt;%--跳转到1.jsp中--%&gt;&lt;jsp:forward page=&quot;1.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 企图在1.jsp中pageContext取出request存进去的属性 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在page域对象获取属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //企图获取request域对象存进的属性 String value = (String) pageContext.getAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： pageContext本质上代表着编译后JSP的内容，pageContext还可以封装了访问其他域的方法！ 上面的pageContext默认是page范围的，但pageContext对象重载了set、get、removeAttribute这三个方法 getAttribute(String name,int scope) setAttribute(String name,Object value,int scope) removeAttribute(String name,int scope) 多了一个设置域范围的一个参数，如果不指定默认就是page。当然了，pageContext把request、session、application、page这几个域对象封装着了静态变量供我们使用。 PageContext.APPLICATION_SCOPE PageContext.SESSION_SCOPE PageContext.REQUEST_SCOPE PageContext.PAGE_SCOPE 刚才我们没有使用重载方法的时候，使用pageContext是无法获取到request域对象设置的属性的。现在我们使用重载后的方法看一下能不能获取得到！ 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;在page域对象获取request域对象的属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //使用重载的方法获取request域对象的属性 String value = (String) pageContext.getAttribute(&quot;name&quot;,pageContext.REQUEST_SCOPE); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果： pageContexst还有这么一个方法： findAttribute(String name) 该方法会查找各个域的属性，从小到大开始寻找！也就是page—&gt;request-&gt;session-&gt;application。这个是EL表达式的原理！，EL表达式后面会讲到！ 我们用此方法看能不能查找出request域对象的属性吧！ 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用findAttribute&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //使用findAttribute查找2.jsp中request域对象的属性 String value = (String) pageContext.findAttribute(&quot;name&quot;); System.out.println(value);%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 引入和跳转PageContext类中定义了一个forward方法和两个include方法来分别简化和替代RequestDispatcher.forward方法和include方法。 pageContext.forward(String url) pageContext.include(String url) 4种属性范围到目前为止，我们已经学了4种属性范围了。 1. page【只在一个页面中保存属性，跳转页面无效】2. requet【只在一次请求中保存属性，服务器跳转有效，浏览器跳转无效】3. session【在一个会话范围中保存属性，无论何种跳转均有效，关闭浏览器后无效】4. application【在整个服务器中保存，所有用户都可以使用】 4个内置对象都支持以下的方法： 1. setAttribute(String name, Object o )2. getAttribute(String name)3. removeAttribute(String name) 应用场景1. request：如果客户向服务器发请求，产生的数据，用户看完就没用了，像这样的数据就存在request域,像新闻数据，属于用户看完就没用的2. session：如果客户向服务器发请求，产生的数据，用户用完了等一会儿还有用，像这样的数据就存在session域中，像购物数据，用户需要看到自己购物信息，并且等一会儿，还要用这个购物数据结帐3. servletContext：如果客户向服务器发请求，产生的数据，用户用完了，还要给其它用户用，像这样的数据就存在servletContext域中，像聊天数据 JSP 第三篇【JavaBean 的介绍、JSP 的行为 –JavaBean】什么是 javaBean JavaBean 就是一个普通的 java 类，也称之为简单 java 对象 –POJO（Plain Ordinary Java Object），是 Java 程序设计中一种设计模式，是一种基于 Java 平台的软件组件思想 JavaBean 遵循着特定的写法，通常有以下的规则： 有无参的构造函数 成员属性私有化 封装的属性如果需要被外所操作，必须编写 public 类型的 setter、getter 方法 上面的文字看起来好像很高大上，javaBean 其实非常简单，下面的代码就是按照特定写法、规则编写的一个 JavaBean 对象 12345678910111213141516171819202122232425public class Person &#123; private String username ; private int age; public Person() &#123; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 为什么需要使用 Javabean 使用 javaBean 的好处就是：封装，重用, 可读！ 下面引用知乎一段回答： JaveBean 你可以理解为一辆货车，在你的 java 端和 web 页面进行数据传递的载体，你当然可以每个变量单独传递，或者使用集合传递，但是 javabean 可以使你的数据更有可读性，方便开发时明确变量的意义，也使其他阅读你代码的人能直接你的意图 如果把 bean 类与数据库联合使用，一张表使用 bean 类，可以使你的代码更加简洁高效，易于理解，现在大多数框架都会使用这种机制。 JSP 行为 –JavaBean JSP 技术提供了三个关于 JavaBean 组件的动作元素，即 JSP 行为（标签），它们分别为： &lt;jsp:useBean&gt;【在 JSP 页面中查找 javaBean 对象或者实例化 javaBean 对象】 &lt;jsp:setProperty&gt;【设置 javaBean 的属性】 &lt;jsp:getProperty&gt;【获取 javaBean 的属性】 jsp:useBean &lt;jsp:useBean&gt;标签用于在指定的域范围内查找指定名称的 JavaBean 对象： 存在则直接返回该 JavaBean 对象的引用。 不存在则实例化一个新的 JavaBean 对象并将它以指定的名称存储到指定的域范围中。 语法： 12&lt;jsp:useBean id=&quot;实例化对象的名称&quot; class=&quot;类的全名&quot; scope=&quot;保存范围&quot;/&gt; 如果 JSP 不支持&lt;jsp:useBean&gt;这个行为，我们要使用 Person 类是这样使用的 123456789101112131415161718192021&lt;%--这里需要导入Person类--%&gt;&lt;%@ page import=&quot;domain.Person&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //new出对象 Person person = new Person(); person.setName(&quot;zhongfucheng&quot;); System.out.println(person.getName());%&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 我们使用&lt;jsp:useBean&gt;就显得非常简洁，不用导包，不用 new 出对象 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;&lt;% person.setName(&quot;zhongfucheng&quot;); System.out.println(person.getName());%&gt;&lt;/body&gt;&lt;/html&gt; 也可以实现同样的效果： 有人可能会想，凭什么写一个&lt;jsp:useBean&gt;这样的代码就可以创建出一个对象出来。 现在我把 JavaBean 中无参的构造函数改成有参的，我们看看会出现什么情况，出现异常了！ 1234public Person(int age) &#123; this.age = age; &#125; &lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;内部原理是这样子的： 通过上面的代码我们也知道了为什么要有一个无参的构造函数！内部在 new 对象的时候是没有传递参数进去的！ jsp:setProperty 语法： 12&lt;jsp:setProerty &gt; 在语法上可分为 4 种模式 当我们没有学习到&lt;jsp:setProperty&gt;时，我们获取表单的信息，然后导入到 javaBean 对象中是这样的一种情况： 这是表单的页面代码： 123456&lt;form action=&quot;/zhongfucheng/1.jsp&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt; 年龄：&lt;input type=&quot;text &quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 这是处理表单提交过来数据的 jsp 的代码 12345678910&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;&lt;% int age = Integer.parseInt(request.getParameter(&quot;age&quot;)); person.setAge(age); System.out.println(person.getAge());%&gt; 这是可以完成的，但是相对来说，比较麻烦！ 我们来使用 12345678&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;&lt;%--指定属性名称为age--%&gt;&lt;jsp:setProperty /&gt;&lt;% System.out.println(person.getAge());%&gt; 也可以完成，并且代码更少，功能更强大！ 代码更少可以直观看出来，为什么我说它功能更加强大呢？表单提交过来的数据都是字符串，在我们没有用！但是 我们再来使用一下自动匹配来感受它的强大之处吧 123456789&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;page&quot;/&gt;&lt;%--property的值设置为*就代表自动匹配--%&gt;&lt;jsp:setProperty /&gt;&lt;% System.out.println(person.getAge()); System.out.println(person.getName());%&gt; 我们再来看一下效果： 看到这里，有人可能会觉得好神奇：只要设置 property 的值就可以将表单传递过来的数据封装到 JavaBean 对象中了！这究竟是这样做到的？？？ 细心的朋友会发现，JavaBean 的属性名称和表单的 name 属性设置的名称是一模一样的！ 123456private String username ;private int age;用户名：&lt;input type=&quot;text&quot; &gt;年龄：&lt;input type=&quot;text &quot; &gt; 如果我设置不一样还能不能用？我们试试：表单 name 属性的 username 改成是 user 12用户名：&lt;input type=&quot;text&quot; &gt; 我们再来看看还能不能把表单的数据完整地封装 JavaBean 对象中 我们可以发现：要想能够把表单带过来的数据成功封装到 JavaBean 对象上，名字要一致！也就是说：JavaBean 属性名要和表单的 name 的名称一致 至于原理，它是通过反射来做的, 调用了内省的方法！，我们看编译后的 JSP 就明白了。 jsp:getProperty 语法： 该 jsp 行为十分简单，我们来使用一下就知道了。 1234&lt;%--使用&lt;jsp:getProperty&gt;输出--%&gt;&lt;jsp:getProperty /&gt;&lt;jsp:getProperty /&gt; 效果： 原理如下 JSP 第四篇【EL 表达式介绍、获取各类数据、11 个内置对象、执行运算、回显数据、自定义函数、fn 方法库】什么是 EL 表达式？表达式语言（Expression Language，EL）,EL 表达式是用 “${}” 括起来的脚本，用来更方便的读取对象！ EL 表达式主要用来读取数据，进行内容的显示！ 为什么要使用 EL 表达式？ 为什么要使用 EL 表达式，我们先来看一下没有 EL 表达式是怎么样读取对象数据的吧！ 在 1.jsp 中设置了 Session 属性 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;向session设置一个属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //向session设置一个属性 session.setAttribute(&quot;name&quot;, &quot;aaa&quot;); System.out.println(&quot;向session设置了一个属性&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; 在 2.jsp 中获取 Session 设置的属性 1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% String value = (String) session.getAttribute(&quot;name&quot;); out.write(value);%&gt;&lt;/body&gt;&lt;/html&gt; 上面看起来，也没有多复杂呀，那我们试试 EL 表达式的！ 在 2.jsp 中读取 Session 设置的属性 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;name&#125;&lt;/body&gt;&lt;/html&gt; 只用了简简单单的几个字母就能输出 Session 设置的属性了！并且输出在浏览器上！ 使用 EL 表达式可以方便地读取对象中的属性、提交的参数、JavaBean、甚至集合！ EL 表达式的作用 首先来看一下 EL 表达式的语法吧： 12$&#123;标识符&#125; EL 表达式如果找不到相应的对象属性，返回的的空白字符串 “”，而不是 null，这是 EL 表达式最大的特点！ 获取各类数据获取域对象的数据 上面在例子中，我们已经体验到了获取 Session 域对象的数据是多么地方便！其实 EL 表达式可以让我们获取各个域范围的数据 在 1.jsp 中设置 ServeltContext 属性（也就是 application） 123456&lt;% //向ServletContext设置一个属性 application.setAttribute(&quot;name&quot;, &quot;aaa&quot;); System.out.println(&quot;向application设置了一个属性&quot;);%&gt; 在 2.jsp 中获取 application 的属性 12345&lt;% $&#123;name&#125;%&gt; 和 Session 一样，也能获取得到！ 之前我们来讲 ServletContext 对象的时候讲过一个方法 findAttribute(String name),EL 表达式语句在执行的时候会调用该方法，用标识符作为关键字分别从 page、request、session、application 四个域中查找相应的对象。这也解释了为什么 EL 表达式可以仅仅通过标识符就能够获取到存进域对象的数据！ findAttribute() 的查找顺序：从小到大，也就是 page-&gt;request-&gt;session-&gt;application 获取 JavaBean 的属性 以前在 JSP 页面获取 JavaBean 的数据是这样子的： 1.jsp 页面 Session 存进一个 Person 对象，设置 age 的属性为 22 123&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;session&quot;/&gt;&lt;jsp:setProperty /&gt; 在 2.jsp 中取出 Session 的属性 1234567&lt;% Person person = (Person) session.getAttribute(&quot;person&quot;); System.out.println(person.getAge());%&gt; 现在我使用了 EL 表达式读取数据又会非常方便了 123//等同于person.getAge()$&#123;person.age&#125; 上面的代码 等同于调用对象的 getter 方法，内部是通过反射机制完成的！ 获取集合的数据 集合操作在开发中被广泛地采用，在 EL 表达式中也很好地支持了集合的操作！可以非常方便地读取 Collection 和 Map 集合的内容 为了更好地看出 EL 表达式的强大之处，我们也来对比一下使用 EL 表达式和不使用 EL 表达式的区别 下面不使用 EL 表达式输出集合的元素 在 1.jsp 页面中设置 session 的属性，session 属性的值是 List 集合，List 集合装载的又是 Person 对象 123456789101112131415&lt;% List&lt;Person&gt; list = new ArrayList(); Person person1 = new Person(); person1.setUsername(&quot;zhongfucheng&quot;); Person person2 = new Person(); person2.setUsername(&quot;ouzicheng&quot;); list.add(person1); list.add(person2); session.setAttribute(&quot;list&quot;,list);%&gt; 在 2.jsp 中获取到 session 的属性，并输出到页面上 123456789&lt;% List&lt;Person&gt; list = (List) session.getAttribute(&quot;list&quot;); out.write(list.get(0).getUsername()+&quot;&lt;br&gt;&quot;); out.write(list.get(1).getUsername());%&gt; 使用 EL 表达式又是怎么样的效果呢？我们来看看！ 12345&lt;%--取出list集合的第1个元素（下标从0开始），获取username属性--%&gt;$&#123;list[0].username&#125;&lt;br&gt;&lt;%--取出list集合的第2个元素，获取username属性--%&gt;$&#123;list[1].username&#125; 我们再来使用一下 Map 集合 在 1.jsp 中 session 属性存储了 Map 集合，Map 集合的关键字是字符串，值是 Person 对象 12345678910111213141516&lt;% Map&lt;String, Person&gt; map = new HashMap&lt;&gt;(); Person person1 = new Person(); person1.setUsername(&quot;zhongfucheng1&quot;); Person person2 = new Person(); person2.setUsername(&quot;ouzicheng1&quot;); map.put(&quot;aa&quot;,person1); map.put(&quot;bb&quot;,person2); session.setAttribute(&quot;map&quot;,map);%&gt; 看起来好像取出数据的时候是会有点复杂，但是有了 EL 表达式也是非常轻松的！ 1234$&#123;map.aa.username&#125;&lt;br&gt;$&#123;map.bb.username&#125; 效果： 如果 Map 集合存储的关键字是一个数字，就不能使用 “.” 号运算符了，如下所示 对于这种情况，我们可以使用 “[]” 的形式读取 Map 集合的数据 1234$&#123;map[&quot;1&quot;].username&#125;&lt;br&gt;$&#123;map[&quot;2&quot;].username&#125; EL 表达式配合 JSTL 标签可以很方便的迭代集合，后面讲到 JSTL 标签的时候会用到! 这里就不详细说明了。 EL 运算符 EL 表达式支持简单的运算符：加减乘除取摸，逻辑运算符。empty 运算符（判断是否为 null)，三目运算符 empty 运算符可以判断对象是否为 null，用作于流程控制！ 三目运算符简化了 if 和 else 语句，简化代码书写 123456&lt;% List&lt;Person&gt; list = null;%&gt;$&#123;list==null?&quot;list集合为空&quot;:&quot;list集合不为空&quot;&#125; EL 表达式 11 个内置对象EL 表达式主要是来对内容的显示，为了显示的方便，EL 表达式提供了 11 个内置对象。 pageContext 对应于 JSP 页面中的 pageContext 对象（注意：取的是 pageContext 对象） pageScope 代表 page 域中用于保存属性的 Map 对象 requestScope 代表 request 域中用于保存属性的 Map 对象 sessionScope 代表 session 域中用于保存属性的 Map 对象 applicationScope 代表 application 域中用于保存属性的 Map 对象 param 表示一个保存了所有请求参数的 Map 对象 paramValues 表示一个保存了所有请求参数的 Map 对象，它对于某个请求参数，返回的是一个 string[] header 表示一个保存了所有 http 请求头字段的 Map 对象 headerValues 同上，返回 string[] 数组。 cookie 表示一个保存了所有 cookie 的 Map 对象 initParam 表示一个保存了所有 web 应用初始化参数的 map 对象 下面测试各个内置对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%--pageContext内置对象--%&gt;&lt;% pageContext.setAttribute(&quot;pageContext1&quot;, &quot;pageContext&quot;);%&gt;pageContext内置对象：$&#123;pageContext.getAttribute(&quot;pageContext1&quot;)&#125;&lt;br&gt;&lt;%--pageScope内置对象--%&gt;&lt;% pageContext.setAttribute(&quot;pageScope1&quot;,&quot;pageScope&quot;);%&gt;pageScope内置对象:$&#123;pageScope.pageScope1&#125;&lt;br&gt;&lt;%--requestScope内置对象--%&gt;&lt;% request.setAttribute(&quot;request1&quot;,&quot;reqeust&quot;);%&gt;requestScope内置对象:$&#123;requestScope.request1&#125;&lt;br&gt;&lt;%--sessionScope内置对象--%&gt;&lt;% session.setAttribute(&quot;session1&quot;, &quot;session&quot;);%&gt;sessionScope内置对象：$&#123;sessionScope.session1&#125;&lt;br&gt;&lt;%--applicationScope内置对象--%&gt;&lt;% application.setAttribute(&quot;application1&quot;,&quot;application&quot;);%&gt;applicationScopt内置对象：$&#123;applicationScope.application1&#125;&lt;br&gt;&lt;%--header内置对象--%&gt;header内置对象：$&#123;header.Host&#125;&lt;br&gt;&lt;%--headerValues内置对象,取出第一个Cookie--%&gt;headerValues内置对象：$&#123;headerValues.Cookie[0]&#125;&lt;br&gt;&lt;%--Cookie内置对象--%&gt;&lt;% Cookie cookie = new Cookie(&quot;Cookie1&quot;, &quot;cookie&quot;);%&gt;Cookie内置对象：$&#123;cookie.JSESSIONID.value&#125;&lt;br&gt;&lt;%--initParam内置对象，需要为该Context配置参数才能看出效果【jsp配置的无效！亲测】--%&gt;initParam内置对象:$&#123;initParam.name&#125;&lt;br&gt; 注意事项： 测试 headerValues 时，如果头里面有 “-” ，例 Accept-Encoding，则要 headerValues[“Accept-Encoding”] 测试 cookie 时，例${cookie.key}取的是 cookie 对象，如访问 cookie 的名称和值，须${cookie.key.name}或${cookie.key.value} 测试 initParam 时，初始化参数要的 web.xml 中的配置 Context 的，仅仅是 jsp 的参数是获取不到的 上面已经测过了 9 个内置对象了，至于 param 和 parmaValues 内置对象一般都是别的页面带数据过来的（表单、地址栏）！ 表单页面 12345678910&lt;form action=&quot;/zhongfucheng/1.jsp&quot; method=&quot;post&quot;&gt;用户名：&lt;input type=&quot;text&quot; &gt;&lt;br&gt;年龄：&lt;input type=&quot;text &quot; &gt;&lt;br&gt;爱好：&lt;input type=&quot;checkbox&quot; &gt;足球&lt;input type=&quot;checkbox&quot; &gt;篮球&lt;input type=&quot;checkbox&quot; &gt;兵乓球&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 处理表单页面： 123456789101112131415$&#123;param.username&#125;&lt;br&gt;$&#123;param.age&#125;&lt;br&gt;//没有学习jstl之前就一个一个写吧。$&#123;paramValues.hobbies[0]&#125;&lt;br&gt;$&#123;paramValues.hobbies[1]&#125;&lt;br&gt;$&#123;paramValues.hobbies[2]&#125;&lt;br&gt; 当然了，使用地址栏方式提交数据给处理页面也是用 param 内置对象去获取数据的！ EL 表达式回显数据EL 表达式最大的特点就是：如果获取到的数据为 null，输出空白字符串 “”！这个特点可以让我们数据回显 在 1.jsp 中模拟场景 123456789101112&lt;%--模拟数据回显场景--%&gt;&lt;% User user = new User(); user.setGender(&quot;male&quot;); //数据回显 request.setAttribute(&quot;user&quot;,user);%&gt;&lt;input type=&quot;radio&quot; $&#123;user.gender==&apos;male&apos;?&apos;checked&apos;:&apos;&apos; &#125;&gt;男&lt;input type=&quot;radio&quot; $&#123;user.gender==&apos;female&apos;?&apos;checked&apos;:&apos;&apos; &#125;&gt;女 EL 自定义函数EL 自定义函数用于扩展 EL 表达式的功能，可以让 EL 表达式完成普通 Java 程序代码所能完成的功能 开发 HTML 转义的 EL 函数 我们有时候想在 JSP 页面中输出 JSP 代码，但是 JSP 引擎会自动把 HTML 代码解析，输出给浏览器。此时我们就要对 HTML 代码转义。 步骤： 编写一个包含静态方法的类（EL 表达式只能调用静态方法），该方法很常用，Tomcat 都有此方法，可在 \ webapps\examples\WEB-INF\classes\util 中找到 123456789101112131415161718192021222324252627282930public static String filter(String message) &#123; if (message == null) return (null); char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuilder result = new StringBuilder(content.length + 50); for (int i = 0; i &lt; content.length; i++) &#123; switch (content[i]) &#123; case &apos;&lt;&apos;: result.append(&quot;&amp;lt;&quot;); break; case &apos;&gt;&apos;: result.append(&quot;&amp;gt;&quot;); break; case &apos;&amp;&apos;: result.append(&quot;&amp;amp;&quot;); break; case &apos;&quot;&apos;: result.append(&quot;&amp;quot;&quot;); break; default: result.append(content[i]); &#125; &#125; return (result.toString());&#125; 在 WEB/INF 下创建 tld（taglib description）文件，在 tld 文件中描述自定义函数 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot; version=&quot;2.1&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;myshortname&lt;/short-name&gt; &lt;uri&gt;/zhongfucheng&lt;/uri&gt; &lt;!--函数的描述--&gt; &lt;function&gt; &lt;!--函数的名字--&gt; &lt;name&gt;filter&lt;/name&gt; &lt;!--函数位置--&gt; &lt;function-class&gt;utils.HTMLFilter&lt;/function-class&gt; &lt;!--函数的方法声明--&gt; &lt;function-signature&gt;java.lang.String filter(java.lang.String)&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 在 JSP 页面中导入和使用自定义函数，EL 自定义的函数一般前缀为 “fn”，uri 是 “/WEB-INF/tld 文件名称” 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@taglib prefix=&quot;fn&quot; uri=&quot;/WEB-INF/zhongfucheng.tld&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;//完成了HTML转义的功能$&#123;fn:filter(&quot;&lt;a href=&apos;#&apos;&gt;点我&lt;/a&gt;&quot;)&#125;&lt;/body&gt;&lt;/html&gt; 效果： [图片上传中…(image-1fc61b-1517900786708-3)] EL 函数库（fn 方法库） 由于在 JSP 页面中显示数据时，经常需要对显示的字符串进行处理，SUN 公司针对于一些常见处理定义了一套 EL 函数库供开发者使用。 其实 EL 函数库就是 fn 方法库，是 JSTL 标签库中的一个库，也有人称之为 fn 标签库，但是该库长得不像是标签，所以称之为 fn 方法库 既然作为 JSTL 标签库中的一个库，要使用 fn 方法库就需要导入 JSTL 标签！要想使用 JSTL 标签库就要导入 jstl.jar 和 standard.jar 包！ 所以，要对 fn 方法库做测试，首先导入开发包（jstl.jar、standard.jar) 在 JSP 页面中指明使用标签库 12&lt;%@taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt; fn 方法库全都是跟字符串有关的（可以把它想成是 String 的方法） fn:toLowerCase fn:toUpperCase fn:trim fn:length fn:split fn:join 【接收字符数组，拼接字符串】 fn:indexOf fn:contains fn:startsWith fn:replace fn:substring fn:substringAfter fn:endsWith fn:escapeXml【忽略 XML 标记字符】 fn:substringBefore 测试代码： 1234567891011121314151617181920212223242526272829303132contains:$&#123;fn:contains(&quot;zhongfucheng&quot;,zhong )&#125;&lt;br&gt;containsIgnoreCase:$&#123;fn:containsIgnoreCase(&quot;zhongfucheng&quot;,ZHONG )&#125;&lt;br&gt;endsWith:$&#123;fn:endsWith(&quot;zhongfucheng&quot;,&quot;eng&quot; )&#125;&lt;br&gt;escapeXml:$&#123;fn:escapeXml(&quot;&lt;zhongfucheng&gt;你是谁呀&lt;/zhongfucheng&gt;&quot;)&#125;&lt;br&gt;indexOf:$&#123;fn:indexOf(&quot;zhongfucheng&quot;,&quot;g&quot; )&#125;&lt;br&gt;length:$&#123;fn:length(&quot;zhongfucheng&quot;)&#125;&lt;br&gt;replace:$&#123;fn:replace(&quot;zhongfucheng&quot;,&quot;zhong&quot; ,&quot;ou&quot; )&#125;&lt;br&gt;split:$&#123;fn:split(&quot;zhong,fu,cheng&quot;,&quot;,&quot; )&#125;&lt;br&gt;startsWith:$&#123;fn:startsWith(&quot;zhongfucheng&quot;,&quot;zho&quot; )&#125;&lt;br&gt;substring:$&#123;fn:substring(&quot;zhongfucheng&quot;,&quot;2&quot; , fn:length(&quot;zhongfucheng&quot;))&#125;&lt;br&gt;substringAfter:$&#123;fn:substringAfter(&quot;zhongfucheng&quot;,&quot;zhong&quot; )&#125;&lt;br&gt;substringBefore:$&#123;fn:substringBefore(&quot;zhongfucheng&quot;,&quot;fu&quot; )&#125;&lt;br&gt;toLowerCase:$&#123;fn:toLowerCase(&quot;zhonGFUcheng&quot;)&#125;&lt;br&gt;toUpperCase:$&#123;fn:toUpperCase(&quot;zhongFUcheng&quot;)&#125;&lt;br&gt;trim:$&#123;fn:trim(&quot; zhong fucheng &quot;)&#125;&lt;br&gt;&lt;%--将分割成的字符数组用&quot;.&quot;拼接成一个字符串--%&gt;join:$&#123;fn:join(fn:split(&quot;zhong,fu,cheng&quot;,&quot;,&quot; ),&quot;.&quot; )&#125;&lt;br&gt; 使用 fn 方法库数据回显 12345678910111213&lt;% User user = new User(); String likes[] = &#123;&quot;sing&quot;&#125;; user.setLikes(likes); //数据回显 request.setAttribute(&quot;user&quot;,user);%&gt;&lt;%--java的字符数组以&quot;,&quot;号分割开，首先拼接成一个字符串，再判读该字符串有没有包含关键字，如果有就checked--%&gt;&lt;input type=&quot;checkbox&quot;$&#123; fn:contains(fn:join(user.likes,&quot;,&quot;),&quot;sing&quot;)?&apos;checked&apos;:&apos;&apos; &#125;&gt;唱歌&lt;input type=&quot;checkbox&quot;$&#123; fn:contains(fn:join(user.likes,&quot;,&quot;),&quot;dance&quot;)?&apos;checked&apos;:&apos;&apos; &#125;&gt;跳舞 JSP 第五篇【JSTL 的介绍、core 标签库、fn 方法库、fmt 标签库】什么是 JSTLJSTL 全称为 JSP Standard Tag Library 即 JSP 标准标签库。 JSTL 作为最基本的标签库，提供了一系列的 JSP 标签，实现了基本的功能：集合的遍历、数据的输出、字符串的处理、数据的格式化等等！ 为什么要使用 JSTL EL 表达式不够完美，需要 JSTL 的支持！在 JSP 中，我们前面已经用到了 EL 表达式，体会到了 EL 表达式的强大功能：使用 EL 表达式可以很方便地引用一些 JavaBean 以及其属性，不会抛出 NullPointerException 之类的错误！但是，EL 表达式非常有限，它不能遍历集合，做逻辑的控制。这时，就需要 JSTL 的支持了！ Scriptlet 的可读性，维护性，重用性都十分差！JSTL 与 HTML 代码十分类似，遵循着 XML 标签语法，使用 JSTL 让 JSP 页面显得整洁，可读性非常好，重用性非常高，可以完成复杂的功能！ 在 JSP 中不推荐使用 scriptlet 输出，推荐使用 JSP 标签。 使用 JSTL 标签库步骤： 导入 jstl.jar 和 standard.jar 开发包 在 JSP 页面中用 tablib 指令引入需要用到的 JSTL 标签 core 标签库 core 标签库是 JSTL 的核心标签库，实现了最基本的功能：流程控制、迭代输出等操作！ core 标签库的前缀一般是 c c:out 简单使用一下 123456789&lt;% session.setAttribute(&quot;name&quot;, &quot;zhongfucheng&quot;);%&gt;//&lt;c:out/&gt;标签支持标签体，default属性上的数据可以写在标签体中//&lt;c:out value=&quot;$&#123;name&#125;&quot; escapeXml=&quot;true&quot;&gt;您要的数据找不着&lt;/c:out&gt;&lt;c:out value=&quot;$&#123;name&#125;&quot; default=&quot;您要的数据找不着&quot; escapeXml=&quot;true&quot;/&gt; 我们发现上面的代码实现的效果和 EL 表达式是一样的，它出色的地方就多了两个属性, default 和 escapeXml 属性。如果我们用到这两个属性，我们就使用该标签，如果没有用到这两个属性就用 EL 表达式就可以了。 c:set 该标签有 5 个属性，用起来有稍微有些复杂了！现在要记住的就是：var 属性操作的是 Integer、Double、Float、String 等类型的数据，target 属性操作的是 JavaBean 或 Map 对象的数据，scope 代表的是 Web 域，value 是值，property 是对象的属性！ 使用 var 属性 既然 var 属性只能操作 Integer、Double、String 等类型，那么存在 var 属性就一定没有 property 属性（property 代表的是对象的成员属性，Integer、String 这些类型哪来的成员变量呀） 下面的代码流程是这样的：创建了一个 name 的变量，设置的值为 zhongfucheng，范围是 page 1234&lt;c:set var=&quot;name&quot; value=&quot;fucheng&quot; scope=&quot;page&quot;/&gt;$&#123;name&#125; 效果： 当然了，set 标签也支持标签体，value 的值可以写在标签体里边 1234&lt;c:set var=&quot;name&quot; scope=&quot;page&quot;&gt; zhongfucheng&lt;/c:set&gt; 使用 var 属性和 scope 属性实现计数器 123456789&lt;%--由于下面变量需要做加法运算，所以要定义出来，不然服务器是不知道我的变量是Integer类型的--%&gt;&lt;% Integer sessionCount = 0; Integer applicationCount = 0;%&gt;&lt;c:set var=&quot;sessionCount&quot; value=&quot;$&#123;sessionCount+1&#125;&quot; scope=&quot;session&quot;/&gt;&lt;c:set var=&quot;applicationCount&quot; value=&quot;$&#123;applicationCount+1&#125;&quot; scope=&quot;application&quot;/&gt; 效果： 使用 target 属性 使用 target 属性与之配对的是 property 属性，target 属性只能操作 JavaBean 或 Map 对象，property 就是对应的成员变量或 key 了。。 既然 target 属性操作的是 JavaBean 或 Map 对象，那么一定是通过 EL 表达式来获取到对象了。taget 属性如果获取不到数据会抛出异常！使用 target 属性就一定没有 scope 属性（scope 属性代表的是保存范围，target 的值都是获取来的，难道你还能改变人家的范围？） 12345678&lt;%--创建出JavaBean对象，设置为session范围的属性--%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;session&quot;/&gt;&lt;%--获取到person对象，设置age属性的值为32--%&gt;&lt;c:set target=&quot;$&#123;person&#125;&quot; property=&quot;age&quot; value=&quot;32&quot;/&gt;$&#123;person.age&#125; 效果： c:removeremove 标签就相当简单了，只有 var 和 scope 属性，代表的是删除域范围的属性 下面简单来测试一下吧： 12345678910111213&lt;%--创建出JavaBean对象，设置为session范围的属性--%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;session&quot;/&gt;&lt;%--获取到person对象，设置age属性的值为32--%&gt;&lt;c:set target=&quot;$&#123;person&#125;&quot; property=&quot;age&quot; value=&quot;32&quot;/&gt;$&#123;person.age&#125;&lt;br&gt;&lt;%--删除session属性--%&gt;&lt;c:remove var=&quot;person&quot; scope=&quot;session&quot;&gt;&lt;/c:remove&gt;$&#123;person.age==null?&quot;存在session的person对象被删除了！&quot;:&quot;我还在呢！&quot;&#125; 效果： c:catch该标签主要用来处理程序中产生的异常。 catch 标签也十分简单，只有一个 var 属性，var 属性封装了异常的信息！ 123456789101112&lt;%--创建出JavaBean对象，设置为session范围的属性--%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;domain.Person&quot; scope=&quot;session&quot;/&gt;&lt;c:catch var=&quot;message&quot;&gt; &lt;%--target属性只能是EL表达式，现在我是字符串，获取不到对象，肯定会抛出异常的！--%&gt; &lt;c:set target=&quot;person&quot; property=&quot;age&quot; value=&quot;32&quot;/&gt;&lt;/c:catch&gt;$&#123;message&#125; 效果： c:if JSTL 提供了 if 标签完成分支语句的实现，test 属性是不可或缺的。 var 和 scope 属性我看来好像没什么用的（保存执行结果有什么用？） 根据传递过来的参数的不同显示不同的页面！ 1234567891011121314&lt;%--如果带过来的名字是zhongfucheng，那么可以登陆--%&gt;&lt;c:if test=&quot;$&#123;param.name==&apos;zhongfucheng&apos;&#125;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;&lt;/c:if&gt;&lt;%--如果带过来的名字是ouzicheng，那么就是注册--%&gt;&lt;c:if test=&quot;$&#123;param.name==&apos;ouzicheng&apos;&#125;&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/c:if&gt; 注意地址栏的参数！ c:chooseif 标签没有 else 的功能，如果需要类似于 java 中的 if else 流程就需要使用 choose 标签。 choose 标签需要联合 when 和 otherwise 标签一起使用！ 123456789101112&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;param.name==&apos;zhongfucheng&apos;&#125;&quot;&gt; 你好啊，zhongfucheng &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.name==&apos;ouzicheng&apos;&#125;&quot;&gt; 你好啊，ouzicheng &lt;/c:when&gt; &lt;c:otherwise&gt; 你是谁啊？别随便过来！ &lt;/c:otherwise&gt;&lt;/c:choose&gt; 效果： c:forEach forEach 为循环标签，相当于 Java 中的 while 和 for 之前我们在使用 EL 表达式获取到集合的数据，遍历集合都是用 scriptlet 代码循环，现在我们学了 forEach 标签就可以舍弃 scriptlet 代码了。 向 Session 中设置属性，属性的类型是 List 集合 123456789&lt;% List list = new ArrayList&lt;&gt;(); list.add(&quot;zhongfucheng&quot;); list.add(&quot;ouzicheng&quot;); list.add(&quot;xiaoming&quot;); session.setAttribute(&quot;list&quot;, list);%&gt; 遍历 session 属性中的 List 集合, items：即将要迭代的集合。var：当前迭代到的元素 1234&lt;c:forEach var=&quot;list&quot; items=&quot;$&#123;list&#125;&quot; &gt; $&#123;list&#125;&lt;br&gt;&lt;/c:forEach&gt; 效果： 遍历 Map 对象有稍微地不一样，我们来看一下，var 属性保存的不是每个迭代的对象，而是 Map.Entry。 123456789101112131415&lt;% Map map = new HashMap(); map.put(&quot;1&quot;, &quot;zhongfucheng&quot;); map.put(&quot;2&quot;, &quot;xiaohong&quot;); map.put(&quot;3&quot;, &quot;xiaoming&quot;); session.setAttribute(&quot;map&quot;,map);%&gt;&lt;c:forEach var=&quot;me&quot; items=&quot;$&#123;map&#125;&quot; &gt; $&#123;me.key&#125; $&#123;me.value&#125;&lt;br&gt;&lt;/c:forEach&gt; begin 默认从 0 开始、end 默认为集合的最后一个元素、step 默认为 1 varStatus 代表着当前对象被迭代的信息，它有以下的属性。 index【返回当前是第几个对象，从 0 开始计数】 count【已经遍历多少个对象了，从 1 开始计数】 first【是否是第一个】 last【是否是最后一个】 current【当前被迭代的对象】 begin【开始的位置】 end【最后的位置】 step【步长】 123456&lt;c:forEach var=&quot;list&quot; items=&quot;$&#123;list&#125;&quot; varStatus=&quot;varStatus&quot; &gt; $&#123;list&#125;您的下标是:$&#123;varStatus.index&#125;&lt;br&gt;&lt;/c:forEach&gt; 效果： c:forTokens该标签类似于 String 类的 split() 和 for 循环的一种集合 它与 forEach 标签非常相似，都有 begin、end、step、items、var、varStatus 属性，不同的是 forTokens 标签的 items 属性里面是字符串，这个字符串会被 delims 属性的内容分割成多个字符串！ 1234&lt;c:forTokens items=&quot;zhongfucheng,ouzicheng,xiaoming,xiaohong&quot; var=&quot;name&quot; delims=&quot;,&quot; &gt; $&#123;name&#125;&lt;/c:forTokens&gt; 效果图： c:importimport 标签类似于 JSP 行为&lt;jsp:include/&gt;和 JSP 指令&lt;%include&gt; import 标签的属性： url【指定要包含的路径，Internet 所有的 url 都可以】 context【访问同一个 web 容器的其他资源，以 “/“ 开头】 var【保存导入的文件的内容，以 String 类型存储】 socpe【保存的范围，默认是 page】 charEncoding【字符编码】 varReader【保存导入文件的内容，以 Reader 类型存储】 当然了，import 标签功能更加更大！强大在哪里呢？import 标签可以引入 Internet 网页上的内容，也就是说，csdn 也可以引入进来！ 我们来用一下把！ 12&lt;c:import url=&quot;http://www.csdn.net&quot; charEncoding=&quot;UTF-8&quot; /&gt; 我们一看，是没有样式的： 打印 csdn 的源代码： 12345&lt;c:import url=&quot;http://www.csdn.net&quot; charEncoding=&quot;UTF-8&quot; var=&quot;net&quot;/&gt;CSDN的源码是：&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;c:out value=&quot;$&#123;net&#125;&quot; escapeXml=&quot;true&quot;&gt;&lt;/c:out&gt; 效果： c:param 在 JSP 页面进行 URL 的相关操作时，经常要在 URL 地址后面附加一些参数。 c:urlurl 标签十分实用！在浏览器禁用 Cookie 的时候，我们之前学 Servlet 时解决办法是：response.encodeURL()。url 标签也可以实现这样的功能，再配合 param 标签使用，就十分实用了！ 我们配合 param 标签来使用一下吧！ 1234567&lt;c:url value=&quot;2.jsp&quot; var=&quot;url&quot;&gt; &lt;c:param 中国！&quot;&gt; &lt;/c:param&gt;&lt;/c:url&gt;&lt;a href=&quot;$&#123;url&#125;&quot;&gt;我经过了URL地址重写！&lt;/a&gt; 效果： c:redirectredirect 标签用于实现 Redirect 功能，当然了，此标签也能够配合 param 标签使用！ 简单使用一下，重定向到 2.jsp，带了一个参数： 12345&lt;c:redirect url=&quot;2.jsp&quot; &gt; &lt;c:param &gt; &lt;/c:param&gt;&lt;/c:redirect&gt; 在 2.jsp 中获取到参数 fmt 标签库fmt 标签库也叫做国际化标签库。这里就不详细说明了，等我讲到 Web 国际化的时候才讲吧！ fn 方法库fn 方法库也叫做 EL 函数库、fn 标签库。这个在讲解 EL 表达式的时候有详细的说明，可转移到我 EL 表达式的博文中！ JSP第六篇【自定义标签之传统标签】为什么要使用自定义标签？JSTL 标签库只提供了简单的输出等功能，没有实现任何的 HTML 代码封装，并且某些复杂类型转换，或者逻辑处理的时候，JSTL 标签库完成不了，需要自定义标签! 编写自定义标签的步骤： 编写一个实现 Tag 接口的 Java 类【标签处理器类】 在 WEB-INF 目录下创建 tld(Tag Library Descriptor) 文件，在 tld 文件中对标签处理类（实现 Tag 接口的 Java 类）进行描述 快速入门 目标：使用标签输出客户机的 IP 地址！ 按照步骤来：首先编写一个实现 Tag 接口的 Java 类 123456789101112131415161718192021222324252627282930313233public class showIp implements Tag &#123; @Override public void setPageContext(PageContext pageContext) &#123; &#125; @Override public void setParent(Tag tag) &#123; &#125; @Override public Tag getParent() &#123; return null; &#125; @Override public int doStartTag() throws JspException &#123; return 0; &#125; @Override public int doEndTag() throws JspException &#123; return 0; &#125; @Override public void release() &#123; &#125;&#125; 既然要获取到客户机的 IP 地址，那么 request 对象是必不可少的。现在问题来了，在 Tag 重写的方法好像不能直接获取到 request 对象啊。 经过我一番仔细的观察，发现了下面这个方法： 1234@Overridepublic void setPageContext(PageContext pageContext) &#123;&#125; 既然能获取到 pageContext 对象，那么其他 8 大内置对象还不是随随便便？于是乎，我就定义一个成员变量 pageContext，在 setPageContext() 方法中传递过来的 pageContext 赋值给我定义的成员变量即可！ 1234567private PageContext pageContext = null;@Overridepublic void setPageContext(PageContext pageContext) &#123; this.pageContext = pageContext;&#125; 好的，看回我们的需求：使用标签输出客户机的 IP 地址。在上面剩余 5 个方法中，最有可能就是在 doStartTag() 方法中编写代码！ 12345678910111213141516171819202122@Overridepublic int doStartTag() throws JspException &#123; //获取到request对象 HttpServletRequest httpServletRequest = (HttpServletRequest) pageContext.getRequest(); //获取到客户机的ip地址 String ip = httpServletRequest.getRemoteAddr(); //获取输出到浏览器的对象 JspWriter jspWriter = pageContext.getOut(); //下面的异常只能捕获，因为子类的异常不能比父类多 try &#123; jspWriter.write(ip); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return 0;&#125; 接着，编写tld文件，描述实现 Tag 接口的 Java 类【标签处理类】。 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot; version=&quot;2.1&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;zhongfucheng&lt;/short-name&gt; &lt;uri&gt;/zhongfucheng&lt;/uri&gt; &lt;!-- Invoke &apos;Generate&apos; action to add tags or functions --&gt; &lt;tag&gt; &lt;name&gt;viewIp&lt;/name&gt; &lt;tag-class&gt;tag.showIp&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 下面我们来测试一下看能不能用 标签处理类详细说明看完上面的程序，大部分人都是懵逼的。因为还不知道它具体是怎么用的，调用顺序是什么。 首先我们来看一下 Tag 接口的源码！ 12345678910111213141516171819public interface Tag extends JspTag &#123; int SKIP_BODY = 0; int EVAL_BODY_INCLUDE = 1; int SKIP_PAGE = 5; int EVAL_PAGE = 6; void setPageContext(PageContext var1); void setParent(Tag var1); Tag getParent(); int doStartTag() throws JspException; int doEndTag() throws JspException; void release();&#125; 上面程序的执行流程： JSP 引擎遇到自定义标签，首先创建标签处理器类的实例对象。 JSP 引擎实例化完标签处理器类后，调用 setPageContext() 方法，将 pageContext 对象传递给标签处理器类，使得标签处理器类可以通过 pageContext 对象与 JSP 页面进行通信！ setPageContext() 方法执行完后，调用 setParent() 方法，将当前标签的父标签传递给当前处理器类，如果当前标签没有父标签，则传入 null 当 WEB 容器执行到自定义标签的开始标记时，调用 doStartTag() 方法。 当 WEB 容器执行到自定义标签的结束标记时，调用 doEndTag() 方法。 一般来说，当 WEB 容器执行完自定义标签后，标签处理器类会驻留在内存中，直至停止 WEB 应用时，WEB 容器才会调用 release() 方法 我们现在已经清楚了方法的执行顺序了，可 Tag 接口的源码还有 4 个变量阿，它们是用来做什么的呢？我们在编写 JSP 页面时，经常需要在页面中引入一些逻辑，例如： 控制 JSP 页面某一部分（标签体）是否执行 控制整个 JSP 页面是否执行 控制 JSP 页面内容重复执行 修改 JSP 页面内容输出 再看回 4 个变量的名字，我们可以发现，这 4 个变量就是用来做逻辑判断的！ 我们来测试一下吧，在 doEndTag() 方法中，返回的是 SKIP_PAGE 变量，看下会怎么样！ 12345@Overridepublic int doEndTag() throws JspException &#123; return SKIP_PAGE;&#125; 我们再来看一看效果： 好像是没什么区别！我们再查看一下源代码，发现执行完标签后，后面的代码全都没有执行！ doStartTag() 方法使用的是 SKIP_BODY 和 EVAL_BODY_INCLUDE 这两个变量，判断是否执行标签体的内容。 doEndTag() 方法使用的是 SKIP_PAGE 和 EVAL_PAGE 这两个变量，判断是否执行剩下页面的内容 控制 JSP 页面内容重复执行和修改 JSP 页面内容输出后面会有！ tld 文件详细说明 首先我们来看一下 tld 文件当前用到的内容吧！ 12345678910&lt;tlib-version&gt;1.0&lt;/tlib-version&gt;&lt;short-name&gt;myshortname&lt;/short-name&gt;&lt;uri&gt;http://mycompany.com&lt;/uri&gt;&lt;tag&gt; &lt;name&gt;&lt;/name&gt; &lt;tag-class&gt;&lt;/tag-class&gt; &lt;body-content&gt;&lt;/body-content&gt;&lt;/tag&gt; 我们一个一个来看： shortname 推荐使用 prefix uri 就是引入这个标签库使用的 uri name 为标签名 tagclass 为实现类 bodycontent 为标签体的限制，它有 4 个值： EMPTY【不允许有标签体】，JSP【允许有 JSP 代码】 ，scriptless【不允许有脚本代码（也就是 &lt;%%&gt;），允许有 EL 表达式，文本，JSP 行为】 ， tagdepentend【标签体内的 JSP 代码不会被解析，直接输出文本】 TagSupport 类大部分时候我们都不需要实现 Tag 接口来编写自定义标签，TagSupport 是 Tag 的一个模板类，实现了 pageContext，parent 的 getter、setter 方法以及一些其他的功能。我们要做的就是重写 doStartTag() 和 doEndTag() 方法 下面我们就来简单使用一下吧： 继承 TagSupport 类，重写 doStartTag() 方法，比直接实现 Tag 接口简洁很多！ 12345678910111213141516171819202122public class Demo1 extends TagSupport &#123; @Override public int doStartTag() throws JspException &#123; //获取到request对象 HttpServletRequest httpServletRequest = (HttpServletRequest) pageContext.getRequest(); String method = httpServletRequest.getMethod(); JspWriter jspWriter = pageContext.getOut(); try &#123; jspWriter.write(method); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return 0; &#125;&#125; 在 tld 文件中描述一把： 123456&lt;tag&gt; &lt;name&gt;showMethod&lt;/name&gt; &lt;tag-class&gt;tag.Demo1&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt;&lt;/tag&gt; 效果： 带属性的标签上面我们编写的自定义标签都没有附带属性的，我们在使用 core 标签库的时候，标签一般都带有属性。 其实 JSTL 标签库的原理就是自定义标签，把自定义标签搞明白了，对 JSTL 标签库的使用就有更好的理解了！ 想要自定义标签带有属性也非常简单，只要在标签处理器类上加一个成员变量和 setter、getter()，再在 tld 文件中描述下该属性即可！它的原理是这样的：当标签使用到属性的时候，引擎就会调用它的 setter() 方法 下面我想要完成的功能是：使用标签的人，传入一个字符串格式就可以显示想要的格式日期 编写标签处理器类，增加一个成员变量以及对应的 setter、getter 方法 123456789101112131415161718192021222324252627282930public class Demo1 extends TagSupport &#123; //创建成员对象，对应的setter、getter方法 private String format = null; @Override public int doStartTag() throws JspException &#123; //创建日期格式化对象 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format); //格式化日期并向浏览器输出 try &#123; pageContext.getOut().write(simpleDateFormat.format(new Date())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return 0; &#125; public String getFormat() &#123; return format; &#125; public void setFormat(String format) &#123; this.format = format; &#125;&#125; 在 tld 文件中描述标签和属性，name 代表的是属性的名字，required 代表的是是否为必须，rtexprvalue 代表能否使用 EL 表达式 1234567891011&lt;tag&gt; &lt;name&gt;formatDate&lt;/name&gt; &lt;tag-class&gt;tag.Demo1&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;format&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt;&lt;/tag&gt; 我们来看一下效果： 标签的继承关系 在深入讲解之前，我们先来看一下各种 Tag 接口、类之间的关系，这样学习下去才不会晕！ IterationTag 说明 我们已经使用过了 Tag 接口和 TagSupport 类了。接下来我们看一下 IterationTag 是什么玩意。 123456public interface IterationTag extends Tag &#123; int EVAL_BODY_AGAIN = 2; int doAfterBody() throws JspException;&#125; 从关系图我们也可以看出，IterationTag 接口实现了 Tag 接口，InterationTag 接口和 Tag 接口最主要的区别就是多了个 doAfterBody() 方法和 EVAL_BODY_AGAIN 变量 理解起来也很简单：当 doAfterBody() 返回的是 EVAL_BODY_AGAIN 变量，那么标签体的内容就一直循环！当然了，TagSupport 也实现了 Iteration 接口，也就是说 TagSupport 类也能完成 Iteration 接口的事情！ 我们来使用一下吧： 123456789101112131415161718192021222324public class Demo1 extends TagSupport &#123; @Override public int doStartTag() throws JspException &#123; try &#123; pageContext.getOut().write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //执行标签体 return EVAL_BODY_INCLUDE; &#125; @Override public int doAfterBody() throws JspException &#123; //标签体不断循环，直到doAfterBody()返回的是SKIP_BODY return EVAL_BODY_AGAIN; &#125;&#125; tld 文件中描述，既然标签体有内容，就不能用 empty 了！ 123456&lt;tag&gt; &lt;name&gt;foreverEval&lt;/name&gt; &lt;tag-class&gt;tag.Demo1&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt;&lt;/tag&gt; 注意看横向的滑轮，已经死循环输出了： doAfterBody() 中只要返回的是 SKPI_BODY 就退出循环，执行 doEndTag() 方法 1234567891011121314151617181920212223242526272829//定义一个变量，规定标签体循环的次数int x = 0;@Overridepublic int doStartTag() throws JspException &#123; try &#123; pageContext.getOut().write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //执行标签体 return EVAL_BODY_INCLUDE;&#125;@Overridepublic int doAfterBody() throws JspException &#123; x++; if (x &gt;= 10) &#123; return SKIP_BODY; &#125; //标签体不断循环，直到doAfterBody()返回的是SKIP_BODY return EVAL_BODY_AGAIN;&#125; 现在我们已经能控制循环的次数了！ BodyTag 说明前面我们已经使用到了带标签体的自定义标签了，前面的都是只能直接输出而得不到标签体的内容，既然得不到标签体的内容，就更别说修改标签体了！ 此时，我们就需要 BodyTag 接口的支持了！它专门用来处理带标签体的标签，下面我们来看一下 BodyTag 的源码！ 1234567891011public interface BodyTag extends IterationTag &#123; /** @deprecated */ int EVAL_BODY_TAG = 2; int EVAL_BODY_BUFFERED = 2; void setBodyContent(BodyContent var1); void doInitBody() throws JspException;&#125; BodyTag 多了 EVAL_BODY_BUFFERED 变量【一个已经标识过时了】，多了 setBodyContent 和 doInitBody() 两个方法 其实使用 BodyTag 十分简单 如果 doStartTag() 方法返回的是 EVAL_BODY_BUFFERED，把标签体的内容缓存起来 接着调用 setBodyContent() 方法和 doInitBody() 方法，封装标签体的内容到 BodyContent 对象中 接着调用 doEndTag() 方法 对于标签体的内容，我们可以通过 getBodyContenet() 来获取！ 再看回上面的关系图，BodyTag 实现了 IterationTag 和 Tag 接口，如果直接实现 BodyTag 接口做开发，要实现的方法就太多了。一般我们使用继承 BodyTag 的 BodyTagSupport 来做开发 BodyTagSupport 说明 首先来看一下源代码吧： 123456789101112131415161718192021222324252627282930313233343536373839public class BodyTagSupport extends TagSupport implements BodyTag &#123; protected BodyContent bodyContent; public BodyTagSupport() &#123; &#125; public int doStartTag() throws JspException &#123; return 2; &#125; public int doEndTag() throws JspException &#123; return super.doEndTag(); &#125; public void setBodyContent(BodyContent b) &#123; this.bodyContent = b; &#125; public void doInitBody() throws JspException &#123; &#125; public int doAfterBody() throws JspException &#123; return 0; &#125; public void release() &#123; this.bodyContent = null; super.release(); &#125; public BodyContent getBodyContent() &#123; return this.bodyContent; &#125; public JspWriter getPreviousOut() &#123; return this.bodyContent.getEnclosingWriter(); &#125;&#125; 可以发现:BodyTagSupport 主要扩充了以下的内容: 把 BodyContent 直接定义为成员变量，在获取标签体内容的时候就不需要通过 getBodyContent() 获取了 提供获取 JspWriter 的方法，不需要从 pageConext 中获取了 以上的两个扩充都简化了我们的代码书写！ 123456protected BodyContent bodyContent;public JspWriter getPreviousOut() &#123; return this.bodyContent.getEnclosingWriter();&#125; 从 BodyTag 接口中，我就说到了：标签体的内容封装到了 BodyContent 类中，那么 BodyContent 类究竟是什么？我们来看一下源码： 12345678910111213141516171819202122232425262728293031public abstract class BodyContent extends JspWriter &#123; private JspWriter enclosingWriter; protected BodyContent(JspWriter e) &#123; super(-2, false); this.enclosingWriter = e; &#125; public void flush() throws IOException &#123; throw new IOException(&quot;Illegal to flush within a custom tag&quot;); &#125; public void clearBody() &#123; try &#123; this.clear(); &#125; catch (IOException var2) &#123; throw new Error(&quot;internal error!;&quot;); &#125; &#125; public abstract Reader getReader(); public abstract String getString(); public abstract void writeOut(Writer var1) throws IOException; public JspWriter getEnclosingWriter() &#123; return this.enclosingWriter; &#125;&#125; 原来 BodyContent 继承着 JspWriter，它与 JspWriter 最大的区别是：BodyContent 类的任何写入的内容并不自动地向页面输出！ 我们一般使用 BodyContent 都使用两个方法： 123456//将数据转变成Reader对象public abstract Reader getReader();//将数据转变成String对象public abstract String getString(); 再从关系图我们可以看初，BodyTagSupport 继承了 TagSupport 类实现了 BodyTag 接口，可以说：BodyTagSupport 有着前面讲的接口和类的所有功能！。 下面我们来使用下 BodyTagSupport 将标签体的内容转成是小写的： 标签处理器类 1234567891011121314151617181920212223242526272829public class Demo1 extends BodyTagSupport &#123; @Override public int doStartTag() throws JspException &#123; //想要获取到标签体的内容，就要返回EVAL_BODY_BUFFERED变量 return EVAL_BODY_BUFFERED; &#125; @Override public int doEndTag() throws JspException &#123; //获取到标签体的内容 String value = bodyContent.getString(); //将标签体的内容转成小写并输出 try &#123; this.getPreviousOut().write(value.toLowerCase()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.doEndTag(); &#125;&#125; tld 文件： 123456&lt;tag&gt; &lt;name&gt;BodyContentToLowerCase&lt;/name&gt; &lt;tag-class&gt;tag.Demo1&lt;/tag-class&gt; &lt;body-content&gt;tagdependent&lt;/body-content&gt;&lt;/tag&gt; 效果： 参考：Servlet+JSP - 文集 - 简书https://www.jianshu.com/nb/21926044]]></content>
      <tags>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat bio nio apr 模式性能测试]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-3%2F</url>
    <content type="text"><![CDATA[11.11 活动当天，服务器负载过大，导致部分页面出现了不可访问的状态、那后来主管就要求调优了，下面是 tomcat bio、nio、apr 模式以及后来自己测试的一些性能结果。 原理方面的资料都是从网上找的，并且把多个地方的整理到了一起，觉得很有意义。（后面对 tomcat 默认页面测试的数据是自己测出来的），tomcat 的三种模式如果用对了场合，性能绝对有大幅度的提升。当然调优也并不只在这一个方面，还有内存（堆内存、非堆内存、新生代内存）以及线程（最大线程、请求队列、备用线程、压缩、以及禁用 dns 轮询）等方面。 那在做 tomcat bio nio apr 模式之前，先来了解下 java 的一些特性吧。 Java BIO、NIO、AIO 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 IO 时，Java 自己处理 IO 读写）。 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步 IO 时，Java 将 IO 读写委托给 OS 处理，需要将数据缓冲区地址和大小传给 OS(银行卡和密码)，OS 需要支持异步 IO 操作 API）。 阻塞 ： ATM 排队取款，你只能等待（使用阻塞 IO 时，Java 调用会一直阻塞到读写完成才返回）。 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞 IO 时，如果不能读写 Java 调用会马上返回，当 IO 事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。 Java 对 BIO、NIO、AIO 的支持： Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。 Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理 BIO、NIO、AIO 适用场景分析: BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。 NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。 AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。 好，下面来看看 tomcat 的 bio、nio、apr 模式 biobio(blocking I/O)，顾名思义，即阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作 (即 java.io 包及其子包)。Tomcat 在默认情况下，就是以 bio 模式运行的。遗憾的是，就一般而言，bio 模式是三种运行模式中性能最低的一种。我们可以通过 Tomcat Manager 来查看服务器的当前状态。 nio是 Java SE 1.4 及后续版本提供的一种新的 I/O 操作方式 (即 java.nio 包及其子包)。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API，因此 nio 也被看成是 non-blocking I/O 的缩写。它拥有比传统 I/O 操作(bio) 更好的并发运行性能。 apr(Apache Portable Runtime/Apache 可移植运行库)，是 Apache HTTP 服务器的支持库。你可以简单地理解为，Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高 Tomcat 对静态文件的处理性能。 Tomcat apr 也是在 Tomcat 上运行高并发应用的首选模式。 在这之前，我们先把 tomcat 管理界面配置起来，以便等下能更方便的观察我们的 bio、nio、apr 模式 添加 manager/status 用户 123vim /usr/local/apache-tomcat-7.0.47/conf/tomcat-users.xml&lt;role role/&gt; &lt;user user/&gt; 配置完重启，通过 ip:port/manager/status 就可以看 tomcat 状态了，里面有服务器的信息及 tomcat 信息。 bio server.xml 配置 （重启生效） 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; nio server.xml 配置 （重启生效） 123&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; apr server.xml 配置 （重启生效） 123&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 当然，apr 模式还需要安装 apr 、 apr-utils 、tomcat-native 包 123456789101112131415apr 安装tar zxf apr-1.5.2.tar.gz -C /usr/local/src/cd /usr/local/src/apr-1.5.2/./configure --prefix=/usr/local/apr &amp;&amp; make &amp;&amp; make installapr-utils 安装tar zxf apr-util-1.5.4.tar.gz -C /usr/local/src/cd /usr/local/src/apr-util-1.5.4/./configure --with-apr=/usr/local/apr/ --prefix=/usr/local/apr-utils &amp;&amp; make &amp;&amp; make install tomcat-native安装cd /usr/local/apache-tomcat-7.0.65/bin/tar zxf tomcat-native.tar.gz cd tomcat-native-1.1.33-src/jni/native./configure --with-apr=/usr/local/apr --with-java-home=/usr/local/java/ &amp;&amp; make &amp;&amp; make install 安装完后记得在 /etc/profile 的 JAVA 变量后面多加一条 APR 的环境变量 设置环境变量 123456JAVA_HOME=/usr/local/javaJAVA_BIN=$JAVA_HOME/binPATH=$PATH:$JAVA_BINCLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME JAVA_BIN PATH CLASSPATHexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/apr/lib source /etc/profile 那下面来看看 apr 的页面 到这里大致的配置就结束了，建议在做实验之前，先了解清楚 java 的 bio 、nio 、aio 特性，在 web 服务器上阻塞 IO(BIO)与 NIO 一个比较重要的不同是，客户系统使用 BIO 的时候往往会为每一个 web 请求引入多线程，每个 web 请求一个单独的线程，所以并发量一旦上去了，线程数就上去了，CPU 就忙着线程切换，所以 BIO 不合适高吞吐量、高可伸缩的 web 服务器；而 NIO 则是使用单线程 (单个 CPU) 或者只使用少量的多线程 (多 CPU) 来接受 Socket，而由线程池来处理堵塞在 pipe 或者队列里的请求. 这样的话，只要 OS 可以接受 TCP 的连接，web 服务器就可以处理该请求。大大提高了 web 服务器的可伸缩性。 下面是我自己的一些性能测试表格，通过 jmeter 压测软件（jmeter 软件使用自行百度）在本地测试的（为了数据的有效以及准确性，我没测试 10 分钟，也就是进行一次测试，都会重启 linux 主机及重新打开 jmeter 软件。），当然你也可以选择通过 云主机、自己机房的服务器以及虚拟机等测试，测试当中会涉及到很多点，例如（磁盘 io、带宽、内存、cpu、以及内核配置中的 tcp 各种状态，甚至是各种打开文件限制，都会影响到我们的测试结果） 可以看到，随着线程的不断增多，bio 模式性能越来越差，就算是在本地，错误率和响应时间都在明显的增加、而吞吐量、样本数和每秒传输速率都在下降（当然，如果是生产环境，我们肯定通过 nginx web 软件进行反向代理，提供多个 tomcat 节点来提供更稳定的服务。） 而 bio 和 apr 模式基本上没有变化太多，都保持在一个稳定的状态。 而后来当我进行一些 service 后端程序的测试时，发现 tomcat 性能并没有大幅度的提升，甚至会有下降的趋势。（该接口不是在同网段测试，而是跨越路由器，在网络传输中会有损耗方面，性能跟本地测试也会有所差异） 总结：个人觉得在 tomcat bio、nio、apr 模式中，每种都会有各自适用的场合，也不能说哪个好那个不好，就像 tomcat 内存方面的配置，如果内存设置的过大，gc 垃圾回收机制就会变慢；如果内存设置的过小，tomcat 又会出现内存溢出的情况，所以设置在一个合适的范围很重要，不仅不会出错，并且 gc 回收频繁使性能达到一个最优的结果。当然，这也需要根据不同的场合进行不同的测试才能产生最优的结果！ 参考：tomcat bio nio apr 模式性能测试与个人看法 - CSDN博客https://blog.csdn.net/wanglei_storage/article/details/50225779]]></content>
      <tags>
        <tag>Java</tag>
        <tag>tomcat</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中BIO,NIO,AIO的理解]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-2%2F</url>
    <content type="text"><![CDATA[Java 中 BIO,NIO,AIO 的理解 在高性能的 IO 体系设计中，有几个名词概念常常会使我们感到迷惑不解。具体如下： 1 什么是同步？2 什么是异步？3 什么是阻塞？4 什么是非阻塞？5 什么是同步阻塞？6 什么是同步非阻塞？7 什么是异步阻塞？ 8 什么是异步非阻塞？ 先来举个实例生活中的例子： 如果你想吃一份宫保鸡丁盖饭： 同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！ 同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ 异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。 在弄清楚上面的几个问题之前，我们首先得明白什么是同步，异步，阻塞，非阻塞，只有这几个单个概念理解清楚了，然后在组合理解起来，就相对比较容易了。 1, 同步和异步是针对应用程序和内核的交互而言的。 2, 阻塞和非阻塞是针对于进程在访问数据的时候，根据 strong textIO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。 由上描述基本可以总结一句简短的话，同步和异步是目的，阻塞和非阻塞是实现方式。 1. 同步：指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪。自己上街买衣服，自己亲自干这件事，别的事干不了。2. 异步：异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知（异步的特点就是通知） 告诉朋友自己合适衣服的尺寸，大小，颜色，让朋友委托去卖，然后自己可以去干别的事。（使用异步 IO 时，Java 将 IO 读写委托给 OS 处理，需要将数据缓冲区地址和大小传给 OS）3. 阻塞：所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读, 或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止 去公交站充值，发现这个时候，充值员不在（可能上厕所去了），然后我们就在这里等待，一直等到充值员回来为止。（当然现实社会，可不是这样，但是在计算机里确实如此。）4. 非阻塞：非阻塞状态下, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待， 银行里取款办业务时，领取一张小票，领取完后我们自己可以玩玩手机，或者与别人聊聊天，当轮我们时，银行的喇叭会通知，这时候我们就可以去了。 一个 IO 操作其实分成了两个步骤：发起 IO 请求和实际的 IO 操作。 同步 IO 和异步 IO 的区别就在于第二个步骤是否阻塞，如果实际的 IO 读写阻塞请求进程，那么就是同步 IO。阻塞 IO 和非阻塞 IO 的区别在于第一步，发起 IO 请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞 IO，如果不阻塞，那么就是非阻塞 IO。 同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否就绪，而异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。所以, IO 操作可以分为 3 类：同步阻塞（即早期的 BIO 操作）、同步非阻塞（NIO）、异步非阻塞（AIO）。 同步阻塞 (BIO)：在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。JAVA 传统的 IO 模型属于此种方式。同步非阻塞 (NIO)：在此种方式下，用户进程发起一个 IO 操作以后便可返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO。异步非阻塞 (AIO)： 此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序。 同步阻塞 IO（JAVA BIO）： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 同步非阻塞 IO(Java NIO)：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。用户进程也需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问。 异步阻塞 IO（Java NIO）： 此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄（如果从 UNP 的角度看，select 属于同步操作。因为 select 之后，进程还需要读写数据），从而提高系统的并发性！ （Java AIO(NIO.2)）异步非阻塞 IO: 在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 读取或者写入操作已经由内核完成了。 BIO、NIO、AIO 适用场景分析: BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。 NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。 AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。 参考：Java中BIO,NIO,AIO的理解 - CSDN博客https://blog.csdn.net/itismelzp/article/details/50886009]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-1%2F</url>
    <content type="text"><![CDATA[Servlet第一篇【介绍Servlet、HTTP协议、WEB目录结构、编写入门Servlet程序、Servlet生命周期】什么是 Serlvet？Servlet 其实就是一个遵循 Servlet 开发的 java 类。Serlvet 是由服务器调用的，运行在服务器端。 为什么要用到 Serlvet？我们编写 java 程序想要在网上实现 聊天、发帖、这样一些的交互功能，普通的 java 技术是非常难完成的。sun 公司就提供了 Serlvet 这种技术供我们使用。 HTTP 协议什么是 HTPP 协议 超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。它是 TCP/IP 协议的一个应用层协议 简单来说，HTTP 协议就是客户端和服务器交互的一种通迅的格式。 例子: 在浏览器点击一个链接，浏览器就为我打开这个链接的网页。 原理：当在浏览器中点击这个链接的时候，浏览器会向服务器发送一段文本，告诉服务器请求打开的是哪一个网页。服务器收到请求后，就返回一段文本给浏览器，浏览器会将该文本解析，然后显示出来。这段文本就是遵循 HTTP 协议规范的。 HTTP1.0 和 HTTP1.1 的区别HTTP1.0 协议中，客户端与 web 服务器建立连接后，只能获得一个 web 资源【短连接，获取资源后就断开连接】 HTTP1.1 协议，允许客户端与 web 服务器建立连接后，在一个连接上获取多个 web 资源【保持连接】 HTTP 请求浏览器向服务器请求某个 web 资源时，称之为浏览器向服务器发送了一个 http 请求。 一个完整 http 请求应该包含三个部分： 请求行【描述客户端的请求方式、请求的资源名称，以及使用的 HTTP 协议版本号】 多个消息头【描述客户端请求哪台主机，以及客户端的一些环境信息等】 一个空行 请求行请求行：GET /java.html HTTP/1.1 请求行中的 GET 称之为请求方式，请求方式有：POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT。 常用的有：POST,GET 一般来说，当我们点击超链接，通过地址栏访问都是 get 请求方式。通过表单提交的数据一般是 post 方式。 可以简单理解 GET 方式用来查询数据,POST 方式用来提交数据，get 的提交速度比 post 快 GET 方式：在 URL 地址后附带的参数是有限制的，其数据容量通常不能超过 1K。 POST 方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。 请求头 Accept: text/html,image/* 【浏览器告诉服务器，它支持的数据类型】 Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它支持哪种字符集】 Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的压缩格式】 Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】 Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】 If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】 Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的 — 反盗链】 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】 Cookie【浏览器告诉服务器，带来的 Cookie 是什么】 Connection: close/Keep-Alive 【浏览器告诉服务器，请求完后是断开链接还是保持链接】 Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】 HTTP 响应一个 HTTP 响应代表着服务器向浏览器回送数据 一个完整的 HTTP 响应应该包含四个部分: 一个状态行【用于描述服务器对请求的处理结果。】 多个消息头【用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据】 一个空行 实体内容【服务器向客户端回送的数据】 状态行格式： HTTP 版本号 状态码 原因叙述 状态行：HTTP/1.1 200 OK 状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为 5 类 响应头 Location: http://www.it315.org/index.jsp 【服务器告诉浏览器要跳转到哪个页面】 Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】 Content-Encoding: gzip 【服务器告诉浏览器数据压缩的格式】 Content-Length: 80 【服务器告诉浏览器回送数据的长度】 Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】 Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，回送数据的类型】 Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】 Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要定时刷新】 Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器以下载方式打开数据】 Transfer-Encoding: chunked 【服务器告诉浏览器数据以分块方式回送】 Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要保存 Cookie】 Expires: -1【服务器告诉浏览器不要设置缓存】 Cache-Control: no-cache 【服务器告诉浏览器不要设置缓存】 Pragma: no-cache 【服务器告诉浏览器不要设置缓存】 Connection: close/Keep-Alive 【服务器告诉浏览器连接方式】 Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】 Servlet 的作用Servlet 带给我们最大的作用就是能够处理浏览器带来 HTTP 请求，并返回一个响应给浏览器，从而实现浏览器和服务器的交互。 JAVAWEB 目录结构 以上图说明： bbs 目录代表一个 web 应用 bbs 目录下的 html,jsp 文件可以直接被浏览器访问 WEB-INF 目录下的资源是不能直接被浏览器访问的 web.xml 文件是 web 程序的主要配置文件 所有的 classes 文件都放在 classes 目录下 jar 文件放在 lib 目录下 实现 Servlet 接口编写 Servlet 程序程序我都是由 idea 下写，首先要在 idea 上配置 Tomcat，在我别的博文中有教程！ 编写 Servlet 程序的步骤 创建一个自定义类，实现 Serlvet 接口 我们发现有 5 个方法需要重写，有 init【初始化】，destroy【销毁】,service【服务】,ServletConfig【Servlet 配置】,getServletInfo【Serlvet 信息】。 在此一看，发现 service() 方法是最有可能是写逻辑代码的地方。 首先写一个 hellword 入门先 调用 ServletResponse 对象的方法向浏览器输出 HelloWorld 配置 xml 文件，光写了 Servlet 是不行的，Tomcat 还要知道浏览器怎么访问这个 Servlet。 访问自己写的 Serlvet 程序 Serlvet 生命周期 下面我们看看 Servlet 的生命周期 第一次访问 Servlet，我们发现 init() 和 service() 都被调用了 第二次访问 Servlet，service() 被调用了 第三次访问 Servlet，还是 service() 被调用了 当我们关闭 Tomcat 服务器的时候，destroy() 被调用了！ Servlet 生命周期可分为 5 个步骤 加载 Servlet。当 Tomcat 第一次访问 Servlet 的时候，Tomcat 会负责创建 Servlet 的实例 初始化。当 Servlet 被实例化后，Tomcat 会调用 init() 方法初始化这个对象 处理服务。当浏览器访问 Servlet 的时候，Servlet 会调用 service() 方法处理请求 销毁。当 Tomcat 关闭时或者检测到 Servlet 要从 Tomcat 删除的时候会自动调用 destroy() 方法，让该实例释放掉所占的资源。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁 卸载。当 Servlet 调用完 destroy() 方法后，等待垃圾回收。如果有需要再次使用这个 Servlet，会重新调用 init() 方法进行初始化操作。 简单总结：只要访问 Servlet，service() 就会被调用。init() 只有第一次访问 Servlet 的时候才会被调用。destroy() 只有在 Tomcat 关闭的时候才会被调用。 继承 HttpServlet 编写 Servlet 程序在上面我们实现 Servlet 接口，要实现 5 个方法。这样太麻烦了！而 HttpServlet 类已经实现了 Servlet 接口的所有方法，编写 Servlet 时，只需要继承 HttpServlet，重写你需要的方法即可，并且它在原有 Servlet 接口上添加了一些与 HTTP 协议处理方法，它比 Servlet 接口的功能更为强大。 一般我们开发的时候，都是重写 doGet() 和 doPost() 方法的。对于 idea 而言，创建 Servlet 的时候已经帮你重写好了 Servlet 第二篇【Servlet 调用图、Servlet 细节、ServletConfig、ServletContext】Servlet 的调用图前面我们已经学过了 Servlet 的生命周期了，我们根据 Servlet 的生命周期画出 Servlet 的调用图加深理解 Servlet 的细节一个已经注册的 Servlet 可以被多次映射同一个 Servlet 可以被映射到多个 URL 上。 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/ouzicheng&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 无论我访问的是 http://localhost:8080/Demo1 还是 http://localhost:8080/ouzicheng。我访问的都是 Demo1。 Servlet 映射的 URL 可以使用通配符通配符有两种格式： *. 扩展名 正斜杠（/）开头并以 “/*” 结尾。 匹配所有 匹配扩展名为. jsp 的 如果. 扩展名和正斜杠（/）开头并以 “/” 结尾两种通配符同时出现，匹配的是哪一个呢？ 看谁的匹配度高，谁就被选择 *.扩展名的优先级最低 Servlet 映射的 URL 可以使用通配符和 Servlet 可以被映射到多个 URL 上的作用： 隐藏网站是用什么编程语言写的【.php,.net,.asp 实际上访问的都是同一个资源】 用特定的后缀声明版权【公司缩写】 123456789101112131415161718192021 &lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;*.net&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;*.asp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;*.php&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet 是单例的为什么 Servlet 是单例的浏览器多次对 Servlet 的请求，一般情况下，服务器只创建一个 Servlet 对象，也就是说，Servlet 对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。 每次访问请求对象和响应对象都是新的对于每次访问请求，Servlet 引擎都会创建一个新的 HttpServletRequest 请求对象和一个新的 HttpServletResponse 响应对象，然后将这两个对象作为参数传递给它调用的 Servlet 的 service() 方法，service 方法再根据请求方式分别调用 doXXX 方法。 线程安全问题当多个用户访问 Servlet 的时候，服务器会为每个用户创建一个线程。当多个用户并发访问 Servlet 共享资源的时候就会出现线程安全问题。 原则： 如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制 synchronized (对象){} 如果一个变量不需要共享，则直接在 doGet() 或者 doPost() 定义. 这样不会存在线程安全问题 load-on-startup如果在 作用： 为 web 应用写一个 InitServlet，这个 servlet 配置为启动时装载，为整个 web 应用创建必要的数据库表和数据 完成一些定时的任务【定时写日志，定时备份数据】 在 web 访问任何资源都是在访问 Servlet当你启动 Tomcat，你在网址上输入 http://localhost:8080。为什么会出现 Tomcat 小猫的页面？ 这是由缺省 Servlet 为你服务的！ 我们先看一下 web.xml 文件中的配置,web.xml 文件配置了一个缺省 Servlet 12345678910111213141516171819&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 什么叫做缺省 Servlet？凡是在 web.xml 文件中找不到匹配的，它们的访问请求都将交给缺省 Servlet 处理，也就是说，缺省 Servlet 用于处理所有其他 Servlet 都不处理的访问请求 既然我说了在 web 访问任何资源都是在访问 Servlet，那么我访问静态资源【本地图片，本地 HTML 文件】也是在访问这个缺省 Servlet【DefaultServlet】 证实一下：当我没有手工配置缺省 Servlet 的时候，访问本地图片是可以访问得到的 现在我自己配置一个缺省 Servlet,Demo1 就是我手工配置的缺省 Servlet，覆盖掉 web.xml 配置的缺省 Servlet 12345678910&lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 下面我继续访问一下刚才的图片，此时输出的是 Demo1 这个 Servlet 写上的内容了 总结：无论在 web 中访问什么资源【包括 JSP】，都是在访问 Servlet。没有手工配置缺省 Servlet 的时候，你访问静态图片，静态网页，缺省 Servlet 会在你 web 站点中寻找该图片或网页，如果有就返回给浏览器，没有就报 404 错误 ServletConfig 对象ServletConfig 对象有什么用？ 通过此对象可以读取 web.xml 中配置的初始化参数。 现在问题来了，为什么我们要把参数信息放到 web.xml 文件中呢？我们可以直接在程序中都可以定义参数信息，搞到 web.xml 文件中又有什么好处呢？ 好处就是：能够让你的程序更加灵活【更换需求，更改配置文件 web.xml 即可，程序代码不用改】 获取 web.xml 文件配置的参数信息 为 Demo1 这个 Servlet 配置一个参数，参数名是 name，值是 zhongfucheng 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;zhongfucheng&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在 Servlet 中获取 ServletConfig 对象，通过 ServletConfig 对象获取在 web.xml 文件配置的参数 ServletContext 对象什么是 ServletContext 对象？当 Tomcat 启动的时候，就会创建一个 ServletContext 对象。它代表着当前 web 站点 ServletContext 有什么用？ ServletContext 既然代表着当前 web 站点，那么所有 Servlet 都共享着一个 ServletContext 对象，所以 Servlet 之间可以通过 ServletContext 实现通讯。 ServletConfig 获取的是配置的是单个 Servlet 的参数信息，ServletContext 可以获取的是配置整个 web 站点的参数信息 利用 ServletContext 读取 web 站点的资源文件 实现 Servlet 的转发【用 ServletContext 转发不多，主要用 request 转发】 Servlet 之间实现通讯ServletContext 对象可以被称之为域对象 到这里可能有一个疑问，域对象是什么呢？其实域对象可以简单理解成一个容器【类似于 Map 集合】 实现 Servlet 之间通讯就要用到 ServletContext 的 setAttribute(String name,Object obj) 方法，第一个参数是关键字，第二个参数是你要存储的对象 这是 Demo2 的代码 12345678//获取到ServletContext对象ServletContext servletContext = this.getServletContext();String value = &quot;zhongfucheng&quot;;//MyName作为关键字，value作为值存进域对象【类型于Map集合】servletContext.setAttribute(&quot;MyName&quot;, value); 这是 Demo3 的代码 12345678//获取ServletContext对象ServletContext servletContext = this.getServletContext();//通过关键字获取存储在域对象的值String value = (String) servletContext.getAttribute(&quot;MyName&quot;);System.out.println(value); 访问 Demo3 可以获取 Demo2 存储的信息，从而实现多个 Servlet 之间通讯 获取 web 站点配置的信息如果我想要让所有的 Servlet 都能够获取到连接数据库的信息，不可能在 web.xml 文件中每个 Servlet 中都配置一下，这样代码量太大了！并且会显得非常啰嗦冗余。 web.xml 文件支持对整个站点进行配置参数信息【所有 Servlet 都可以取到该参数信息】 12345&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;zhongfucheng&lt;/param-value&gt;&lt;/context-param&gt; Demo4 代码 1234567//获取到ServletContext对象ServletContext servletContext = this.getServletContext();//通过名称获取值String value = servletContext.getInitParameter(&quot;name&quot;);System.out.println(value); 试一下 Demo3 是否能拿到，相同的代码 1234567//获取到ServletContext对象ServletContext servletContext = this.getServletContext();//通过名称获取值String value = servletContext.getInitParameter(&quot;name&quot;);System.out.println(value); 读取资源文件第一种方式： 现在我要通过 Servlet111 读取 1.png 图片 按我们以前的方式，代码应该是这样的。 123FileInputStream fileInputStream = new FileInputStream(&quot;1.png&quot;);System.out.println(fileInputStream); 当我们访问的时候，却出错了！说找不到 1.png 文件 这是为什么呢？我们以前读取文件的时候，如果程序和文件在同一包名，可以直接通过文件名称获取得到的！，原因很简单，以前我们写的程序都是通过 JVM 来运行的，而现在，我们是通过 Tomcat 来运行的 根据 web 的目录规范，Servlet 编译后的 class 文件是存放在 WEB-INF\classes 文件夹中的 看到这里，我们知道了要进入 classes 目录中读取文件，所以我们将代码改成以下方式 123FileInputStream fileInputStream = new FileInputStream(&quot;D:\\zhongfucheng\\web\\WEB-INF\\classes\\zhongfucheng\\web\\1.png&quot;);System.out.println(fileInputStream); 再去读取时，就发现可以获取到文件了。 但是现在问题又来了，我读取文件的时候都要写上绝对路径，这样太不灵活了。试想一下，如果我将该读取文件的模块移到其他的 web 站点上，我的代码就又要修改了【因为 web 站点的名字不一样】。 我们通过 ServletContext 读取就可以避免修改代码的情况，因为 ServletContext 对象是根据当前 web 站点而生成的 代码如下所示： 123456//获取到ServletContext对象ServletContext servletContext = this.getServletContext();//调用ServletContext方法获取到读取文件的流InputStream inputStream = servletContext.getResourceAsStream(&quot;/WEB-INF/classes/zhongfucheng/web/1.png&quot;); 第二种方式： 如果我的文件放在 web 目录下，那么就简单得多了！, 直接通过文件名称就能获取 代码如下所示 123456//获取到ServletContext对象ServletContext servletContext = this.getServletContext();//调用ServletContext方法获取到读取文件的流InputStream inputStream = servletContext.getResourceAsStream(&quot;2.png&quot;); 第三种方式： 通过类装载器读取资源文件。 我的文件放在了 src 目录下【也叫做类目录】 代码如下所示 123456//获取到类装载器ClassLoader classLoader = Servlet111.class.getClassLoader();//通过类装载器获取到读取文件流InputStream inputStream = classLoader.getResourceAsStream(&quot;3.png&quot;); 我的文件放在了 src 目录下的包下 代码如下，添加包名路径即可。 123456//获取到类装载器ClassLoader classLoader = Servlet111.class.getClassLoader();//通过类装载器获取到读取文件流InputStream inputStream = classLoader.getResourceAsStream(&quot;/zhongfucheng/web/1.png&quot;); 原则：如果文件太大，就不能用类装载器的方式去读取，会导致内存溢出 Servlet 第四篇【request 对象常用方法、应用】什么是 HttpServletRequest HttpServletRequest 对象代表客户端的请求，当客户端通过 HTTP 协议访问服务器时，HTTP 请求头中的所有信息都封装在这个对象中，开发人员通过这个对象的方法，可以获得客户这些信息。 简单来说，要得到浏览器信息，就找 HttpServletRequest 对象 HttpServletRequest 常用方法获得客户机【浏览器】信息 getRequestURL 方法返回客户端发出请求时的完整 URL。 getRequestURI 方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分。 getPathInfo 方法返回请求 URL 中的额外路径信息。额外路径信息是请求 URL 中的位于 Servlet 的路径之后和查询参数之前的内容，它以 “/” 开头。 getRemoteAddr 方法返回发出请求的客户机的 IP 地址 getRemoteHost 方法返回发出请求的客户机的完整主机名 getRemotePort 方法返回客户机所使用的网络端口号 getLocalAddr 方法返回 WEB 服务器的 IP 地址。 getLocalName 方法返回 WEB 服务器的主机名 获得客户机请求头 getHeader 方法 getHeaders 方法 getHeaderNames 方法 获得客户机请求参数 (客户端提交的数据) getParameter 方法 getParameterValues（String name）方法 getParameterNames 方法 getParameterMap 方法 HttpServletRequest 应用防盗链什么是防盗链呢？比如：我现在有海贼王最新的资源，想要看海贼王的要在我的网页上看。现在别的网站的人看到我有海贼王的资源，想要把我的资源粘贴在他自己的网站上。这样我独家的资源就被一个 CTRL+C 和 CTRL+V 抢走了？而反盗链就是不能被他们 CRTL+C 和 CRTL+V 下面我模拟一下场景。现在我首页先有一个超链接，指向着海贼王最新资源 当我点进去，就能看到海贼王最新资源了 其他的人可以通过复制粘贴我的地址，放到它们的网页上 这样我就划不来啦【我的广告你来没看呢！】。想要看我的资源，就必须经过我的首页点进去看。 想要实现这样的效果，就要获取 Referer 这个消息头，判断 Referer 是不是从我的首页来的。如果不是从我的首页来的，跳转回我的首页。 123456789101112131415//获取到网页是从哪里来的String referer = request.getHeader(&quot;Referer&quot;);//如果不是从我的首页来或者从地址栏直接访问的，if ( referer == null || !referer.contains(&quot;localhost:8080/zhongfucheng/index.jsp&quot;) ) &#123; //回到首页去 response.sendRedirect(&quot;/zhongfucheng/index.jsp&quot;); return;&#125;//能执行下面的语句，说明是从我的首页点击进来的，那没问题，照常显示response.setContentType(&quot;text/html;charset=UTF-8&quot;);response.getWriter().write(&quot;路飞做了XXXXxxxxxxxxxxxxxxxx&quot;); 首先按正常预想的，别人从首页点击我的资源，访问我海贼王最新的资源 \ 能够成功访问到资源 如果我在浏览器直接输入地址【此时 Referer 是为 null 的】，我们来看看 跳回到首页上，不能访问到海贼王资源 再试试，如果别人粘贴了我的资源 url，在它的网页上挂了一个网址呢。 在别人网页上点击的时候 又跳回到了我的首页了。 表单提交数据【通过 post 方式提交数据】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;form action=&quot;/zhongfucheng/Servlet111&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; &gt;男 &lt;input type=&quot;radio&quot; &gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; &gt;游泳 &lt;input type=&quot;checkbox&quot; &gt;跑步 &lt;input type=&quot;checkbox&quot; &gt;飞翔 &lt;/td&gt; &lt;/tr&gt; &lt;input type=&quot;hidden&quot; &gt; &lt;tr&gt; &lt;td&gt;你的来自于哪里&lt;/td&gt; &lt;td&gt; &lt;select &gt; &lt;option value=&quot;广州&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;详细说明:&lt;/td&gt; &lt;td&gt; &lt;textarea cols=&quot;30&quot; rows=&quot;2&quot; &gt;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 在 Servlet111 中获取到提交的数据，代码如下 1234567891011121314151617181920//设置request字符编码的格式request.setCharacterEncoding(&quot;UTF-8&quot;);//通过html的name属性，获取到值String username = request.getParameter(&quot;username&quot;);String password = request.getParameter(&quot;password&quot;);String gender = request.getParameter(&quot;gender&quot;);//复选框和下拉框有多个值，获取到多个值String[] hobbies = request.getParameterValues(&quot;hobbies&quot;);String[] address = request.getParameterValues(&quot;address&quot;);//获取到文本域的值String description = request.getParameter(&quot;textarea&quot;);//得到隐藏域的值String hiddenValue = request.getParameter(&quot;aaa&quot;);....各种System.out.println()....... 向表单输入数据 Servlet111 得到表单带过来的数据，最后的一个数据是隐藏域带过来的。 超链接方式提交数据常见的 get 方式提交数据有：使用超链接，sendRedirect() 格式如下： 12sendRedirect(&quot;servlet的地址?参数名=&quot;+参数值 &amp;&quot;参数名=&quot;+参数值); 我们来使用一下，通过超链接将数据带给浏览器 12&lt;a href=&quot;/zhongfucheng/Servlet111?user&gt;使用超链接将数据带给浏览器&lt;/a&gt; 在 Servlet111 接收数据 1234//接收以username为参数名带过来的值String username = request.getParameter(&quot;username&quot;);System.out.println(username); 注意看浏览器左下角 服务器成功接收到浏览器发送过来的数据 并且，传输数据明文的出现在浏览器的地址栏上 sendRedirect() 和超链接类似，在这里就不赘述了 解决中文乱码问题细心的朋友会发现，我在获取表单数据的时候，有这句代码request.setCharacterEncoding(&quot;UTF-8&quot;);，如果没有这句代码，会发生什么事呢？我们看看。 再重新填写数据 在服务器查看提交过来的数据，所有的中文数据都乱码了 来这里我们来分析一下乱码的原因，在前面的博客中我已经介绍了，Tomcat 服务器默认编码是 ISO 8859-1，而浏览器使用的是 UTF-8 编码。浏览器的中文数据提交给服务器，Tomcat 以 ISO 8859-1 编码对中文编码，当我在 Servlet 读取数据的时候，拿到的当然是乱码。而我设置 request 的编码为 UTF-8，乱码就解决了。 接下来使用 get 方式传递中文数据，把表单的方式改成 get 即可 当我们访问的时候，又出现乱码了！ 于是我按照上面的方式，把 request 对象设置编码为 UTF-8 试试 123request.setCharacterEncoding(&quot;UTF-8&quot;);String name = request.getParameter(&quot;name&quot;); 结果还是乱码。这是为什么呢？我明明已经把编码设置成 UTF-8 了，按照 post 方式，乱码问题已经解决了！。我们来看看 get 和 post 方式的区别在哪？为什么 post 方式设置了 request 编码就可以解决乱码问题，而 get 方式不能呢。 首先我们来看一下 post 方法是怎么进行参数传递的。当我们点击提交按钮的时候，数据封装进了 Form Data 中，http 请求中把实体主体带过去了【传输的数据称之为实体主体】，既然 request 对象封装了 http 请求，所以 request 对象可以解析到发送过来的数据，于是只要把编码设置成 UTF-8 就可以解决乱码问题了。 而 get 方式不同，它的数据是从消息行带过去的，没有封装到 request 对象里面，所以使用 request 设置编码是无效的。 要解决 get 方式乱码问题也不难，我们既然知道 Tomcat 默认的编码是 ISO 8859-1，那么 get 方式由消息体带过去给浏览器的时候肯定是用 ISO 8859-1 编码了。 123456789//此时得到的数据已经是被ISO 8859-1编码后的字符串了，这个是乱码String name = request.getParameter(&quot;username&quot;);//乱码通过反向查ISO 8859-1得到原始的数据byte[] bytes = name.getBytes(&quot;ISO8859-1&quot;);//通过原始的数据，设置正确的码表，构建字符串String value = new String(bytes, &quot;UTF-8&quot;); 上面的代码有些难理解，我画张图说明一下： 经过我们手工转换，再来访问一下 好的，成功解决掉乱码问题了。 除了手工转换，get 方式还可以改 Tomcat 服务器的配置来解决乱码，但是不推荐使用，这样不灵活。“ 我们都知道 Tomcat 默认的编码是 ISO 8859-1, 如果在 Tomcat 服务器的配置下改成是 UTF-8 的编码，那么就解决服务器在解析数据的时候造成乱码问题了 在 8080 端口的 Connector 上加入URIEncoding=&quot;utf-8&quot;，设置 Tomcat 的访问该端口时的编码为 utf-8，从而解决乱码，这种改法是固定使用 UTF-8 编码的 1234&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot;/&gt; 设置了编码后，没有做任何手工转换，成功拿到数据 、 当然也有另一种改服务器编码的方式。设置 Tomcat 的访问该端口时的编码为页面的编码，这种改法是随着页面的编码而变 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot; /&gt; 设置编码为 UTF-8 123request.setCharacterEncoding(&quot;UTF-8&quot;);String name = request.getParameter(&quot;name&quot;); 再次访问 手写超链接如果附带中文参数问题，要 URL 重写，在 JSP 博客中会讲到 总结： post 方式直接改 request 对象的编码 get 方式需要手工转换编码 get 方式也可以修改 Tomcat 服务器的编码，不推荐，因为会太依赖服务器了！ 提交数据能用 post 就用 post 实现转发之前讲过使用 response 的 sendRedirect() 可以实现重定向，做到的功能是页面跳转，使用 request 的 getRequestDispatcher.forward(request,response) 实现转发，做到的功能也是页面跳转，他们有什么区别呢？现在我先来说下转发 代码如下所示 123456//获取到requestDispatcher对象，跳转到index.jspRequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/index.jsp&quot;);//调用requestDispatcher对象的forward()实现转发,传入request和response方法requestDispatcher.forward(request, response); 访问 Servlet111 上面已经说了，可以通过 sendRedirect() 重定向可以在资源尾部添加参数提交数据给服务器。那么转发能不能提交数据给服务器呢？ 答案明显是可以的，并且使用这种方法非常频繁 在讲 ServletContext 的时候，曾经说过 Servlet 之间可以通过 ServletContext 实现通讯，ServletContext 也能称之为域对象。而 request 也可以称之为域对象，只不过 ServletContext 的域是整个 web 应用，而 request 的域仅仅代表一次 http 请求 下面我们来使用 request 实现 Servlet 之间的通讯，Servlet111 代码 123456789//以username为关键字存zhongfucheng值request.setAttribute(&quot;username&quot;, &quot;zhongfucheng&quot;);//获取到requestDispatcher对象RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/Servlet222&quot;);//调用requestDispatcher对象的forward()实现转发,传入request和response方法requestDispatcher.forward(request, response); Servlet222 代码 123456//获取到存进request对象的值String userName = (String) request.getAttribute(&quot;username&quot;);//在浏览器输出该值response.getWriter().write(&quot;i am :&quot;+userName); 访问 Servlet111 看下效果 如上图所示，Servlet222 成功拿到了 request 对象在 Servlet111 存进的数据。 现在问题又来了，我们可以使用 ServletContext 和 request 实现 Servlet 之间的通讯，那么我们用哪一种呢？一般的原则：可以使用 request 就尽可能使用 request。因为 ServletContext 代表着整个 web 应用，使用 ServletContext 会消耗大量的资源，而 request 对象会随着请求的结束而结束，资源会被回收。使用 request 域进行 Servlet 之间的通讯在开发中是非常频繁的。 转发的时序图 请求转发的细节 如果在调用 forward 方法之前，在 Servlet 程序中写入的部分内容已经被真正地传送到了客户端，forward 方法将抛出 IllegalStateException 异常。 也就是说：不要在转发之前写数据给浏览器 我们来试试是不是真的会出现异常。 123456789OutputStream outputStream = response.getOutputStream();outputStream.write(&quot;--------------------------------------------&quot;.getBytes());//关闭流，确保让数据到浏览器中outputStream.close();//跳转request.getRequestDispatcher(&quot;/Foot&quot;).forward(request, response); 访问的时候，看到浏览器可以输出数据，Tomcat 后台抛出了异常 如果在调用 forward 方法之前向 Servlet 引擎的缓冲区中写入了内容，只要写入到缓冲区中的内容还没有被真正输出到客户端，forward 方法就可以被正常执行，原来写入到输出缓冲区中的内容将被清空，但是，已写入到 HttpServletResponse 对象中的响应头字段信息保持有效。 转发和重定向的区别实际发生位置不同，地址栏不同 转发是发生在服务器的 转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问 Servlet111 的时候，即使跳转到了 Servlet222 的页面，浏览器的地址还是 Servlet111 的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的 http 请求，一次转发中 request 和 response 对象都是同一个。这也解释了，为什么可以使用 request 作为域对象进行 Servlet 之间的通讯。 重定向是发生在浏览器的 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。曾经介绍过：实现重定向的原理是由 response 的状态码和 Location 头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个 http 请求，request 域对象是无效的，因为它不是同一个 request 对象 用法不同很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则：给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 request.getRequestDispatcher(“/ 资源名 URI”).forward(request,response) 转发时 “/“ 代表的是本应用程序的根目录【zhongfucheng】 response.send(“/web 应用 / 资源名 URI”); 重定向时 “/“ 代表的是 webapps 目录 能够去往的 URL 的范围不一样 转发是服务器跳转只能去往当前 web 应用的资源 重定向是服务器跳转，可以去往任何的资源 传递数据的类型不同 转发的 request 对象可以传递各种类型的数据，包括对象 重定向只能传递字符串 跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 转发和重定向使用哪一个？根据上面说明了转发和重定向的区别也可以很容易概括出来。转发是带着转发前的请求的参数的。重定向是新的请求。 典型的应用场景： 转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变 重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了 RequestDispatcher 再说明RequestDispatcher 对象调用 forward() 可以实现转发上面已经说过了。RequestDispatcher 还有另外一个方法 include()，该方法可以实现包含，有什么用呢？ 我们在写网页的时候，一般网页的头部和尾部是不需要改变的。如果我们多个地方使用 Servlet 输出网头和网尾的话，需要把代码重新写一遍。而使用 RequestDispatcher 的 include() 方法就可以实现包含网头和网尾的效果了。 我们来操作吧！现在我有网头和网尾的 Servlet 使用 Servlet111 将网头和网尾包含 123456request.getRequestDispatcher(&quot;/Head&quot;).include(request, response);response.getWriter().write(&quot;--------------------------------------------&quot;);request.getRequestDispatcher(&quot;/Foot&quot;).include(request, response); 访问一下 Servlet111, 成功把网头和网尾包含了 Servlet 第五篇【介绍会话技术、Cookie 的 API、详解、应用】什么是会话技术 基本概念: 指用户开一个浏览器，访问一个网站, 只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话. 为什么我们要使用会话技术？会话跟踪技术可以解决我们很多很多问题。 在论坛登陆的时候，很多时候会有一个小框框问你是否要自动登陆，当你下次登陆的时候就不用输入密码了 根据我以前浏览过的商品，猜我喜欢什么商品 Cookie会话跟踪技术有 Cookie 和 Session，Cookie 技术是先出现的。我们先讲 Cookie 技术吧。 什么是 Cookie Cookie 是由 W3C 组织提出，最早由 netscape 社区发展的一种机制 网页之间的交互是通过 HTTP 协议传输数据的，而 Http 协议是无状态的协议。无状态的协议是什么意思呢？一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接。 服务器无法确认用户的信息，于是乎，W3C 就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是 Cookie Cookie 的流程：浏览器访问服务器，如果服务器需要记录该用户的状态，就使用 response 向浏览器发送一个 Cookie，浏览器会把 Cookie 保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址连同 Cookie 一同交给服务器。 Cookie API Cookie 类用于创建一个 Cookie 对象 response 接口中定义了一个 addCookie 方法，它用于在其响应头中增加一个相应的 Set-Cookie 头字段 request 接口中定义了一个 getCookies 方法，它用于获取客户端提交的 Cookie 常用的 Cookie 方法： public Cookie(String name,String value) setValue 与 getValue 方法 setMaxAge 与 getMaxAge 方法 setPath 与 getPath 方法 setDomain 与 getDomain 方法 getName 方法 简单使用 Cookie 创建 Cookie 对象，发送 Cookie 给浏览器、 1234567891011//设置response的编码response.setContentType(&quot;text/html;charset=UTF-8&quot;);//创建Cookie对象，指定名称和值Cookie cookie = new Cookie(&quot;username&quot;, &quot;zhongfucheng&quot;);//向浏览器给一个Cookieresponse.addCookie(cookie);response.getWriter().write(&quot;我已经向浏览器发送了一个Cookie&quot;); 浏览器本身没有任何 Cookie 访问 Servlet1，再回到文件夹中，还是没有发现 Cookie，这是为什么呢？我明明向浏览器发送了一个 Cookie 的。 原来发送 Cookie 给浏览器是需要设置 Cookie 的时间的。在给浏览器之前，设置一下 Cookie 的时间 123//设置Cookie的时间cookie.setMaxAge(1000); 再次访问，已经发现文件夹中多了个 Cookie 的文本了 Cookie 细节Cookie 不可跨域名性 很多人在初学的时候可能有一个疑问：在访问 Servlet 的时候浏览器是不是把所有的 Cookie 都带过去给服务器，会不会修改了别的网站的 Cookie 答案是否定的。Cookie 具有不可跨域名性。浏览器判断一个网站是否能操作另一个网站的 Cookie 的依据是域名。所以一般来说，当我访问 baidu 的时候，浏览器只会把 baidu 颁发的 Cookie 带过去，而不会带上 google 的 Cookie。 Cookie 保存中文 上面我们的例子保存的是英文字符，下面我们来看下保存中文字符会怎么样。 12345678910response.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter printWriter = response.getWriter();String name = &quot;中国&quot;;Cookie cookie = new Cookie(&quot;country&quot;, name);cookie.setMaxAge(2000);response.addCookie(cookie);printWriter.write(&quot;我颁发了一个Cookie，值保存的是中文数据&quot;); 访问 Servlet1，好吧。出异常了！ 中文属于 Unicode 字符，英文数据 ASCII 字符，中文占 4 个字符或者 3 个字符，英文占 2 个字符。 解决：Cookie 使用 Unicode 字符时需要对 Unicode 字符进行编码。 123//对Unicode字符进行编码Cookie cookie = new Cookie(&quot;country&quot;, URLEncoder.encode(name, &quot;UTF-8&quot;)); 再次访问 Servlet1，已经把 Cookie 成功颁发给浏览器了 我们发现 Cookie 保存在硬盘的中文数据是经过编码的，那么我们在取出 Cookie 的时候要对中文数据进行解码 12345678910Cookie[] cookies = request.getCookies();for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; String name = cookies[i].getName(); //经过URLEncoding就要URLDecoding String value = URLDecoder.decode(cookies[i].getValue(), &quot;UTF-8&quot;); printWriter.write(name + &quot;------&quot; + value);&#125; 取出存进 Cookie 的值 Cookie 的有效期Cookie 的有效期是通过 setMaxAge() 来设置的。 如果 MaxAge 为正数，浏览器会把 Cookie 写到硬盘中，只要还在 MaxAge 秒之前，登陆网站时该 Cookie 就有效【不论关闭了浏览器还是电脑】 如果 MaxAge 为负数，Cookie 是临时性的，仅在本浏览器内有效，关闭浏览器 Cookie 就失效了，Cookie 不会写到硬盘中。Cookie 默认值就是 - 1。这也就为什么在我第一个例子中，如果我没设置 Cookie 的有效期，在硬盘中就找不到对应的文件。 如果 MaxAge 为 0，则表示删除该 Cookie。Cookie 机制没有提供删除 Cookie 对应的方法，把 MaxAge 设置为 0 等同于删除 Cookie Cookie 的修改和删除 上面我们已经知道了 Cookie 机制没有提供删除 Cookie 的方法。其实细心点我们可以发现，Cookie 机制也没有提供修改 Cookie 的方法。那么我们怎么修改 Cookie 的值呢？ Cookie 存储的方式类似于 Map 集合，如下图所示 Cookie 的名称相同，通过 response 添加到浏览器中，会覆盖原来的 Cookie。 以 country 为名保存的是 %E4%B8%AD%E5%9B%BD，下面我再以 country 为名，把值改变一下。 12345String name = &quot;看完博客就点赞&quot;;//对Unicode字符进行编码Cookie cookie = new Cookie(&quot;country&quot;, URLEncoder.encode(name, &quot;UTF-8&quot;)); 再次查看 Cookie 的时候，值已经改变了，但是文件还是那一份 现在我要删除该 Cookie，把 MaxAge 设置为 0，并添加到浏览器中即可 1234567891011String name = &quot;看完博客就点赞&quot;;//对Unicode字符进行编码Cookie cookie = new Cookie(&quot;country&quot;, URLEncoder.encode(name, &quot;UTF-8&quot;));//一定不要忘记添加到浏览器中cookie.setMaxAge(0);response.addCookie(cookie);printWriter.write(&quot;我删除了该Cookie&quot;); 访问 Servlet，在硬盘已经找不到 Cookie 的文件了！ 注意：删除，修改 Cookie 时，新建的 Cookie 除了 value、maxAge 之外的所有属性都要与原 Cookie 相同。否则浏览器将视为不同的 Cookie，不予覆盖，导致删除修改失败！ 我们来试验一下把。 123456789String name = &quot;看完博客就点赞&quot;;//对Unicode字符进行编码Cookie cookie = new Cookie(&quot;country&quot;, URLEncoder.encode(name, &quot;UTF-8&quot;));//一定不要忘记添加到浏览器中cookie.setMaxAge(10000);response.addCookie(cookie); 上面新建了一个 Cookie，我修改下 Cookie 的其他属性，再删除，看能否把 Cookie 删除掉 12345678//一定不要忘记添加到浏览器中cookie.setPath(&quot;/ouzicheng&quot;);cookie.setMaxAge(0);response.addCookie(cookie);printWriter.write(&quot;删除一个Cookie&quot;); 结果 Cookie 还在硬盘中 Cookie 的域名Cookie 的 domain 属性决定运行访问 Cookie 的域名。domain 的值规定为 “. 域名” Cookie 的隐私安全机制决定 Cookie 是不可跨域名的。也就是说 www.baidu.com 和 www.google.com 之间的 Cookie 是互不交接的。即使是同一级域名，不同二级域名也不能交接，也就是说：www.goole.com 和 www.image.goole.com 的 Cookie 也不能访问 我在本地上配置了 3 个虚拟主机，localhost,www.zhongfucheng.com,www.image.zhongfucheng.com【如果不知道怎么配置，在我 Tomcat 的博客有】 我用 www.zhongfucheng.com 域名发送了一个 Cookie 给浏览器 123456Cookie cookie = new Cookie(&quot;name&quot;, &quot;zhongfucheng&quot;);cookie.setMaxAge(1000);response.addCookie(cookie);printWriter.write(&quot;使用www.zhongfucheng.com域名添加了一个Cookie&quot;); 首先，证明了 Cookie 不可跨名性，localhost 域名拿不到 www.zhongfucheng.com 颁发给浏览器的 Cookie 再使用 www.image.zhongfucheng.com 域名访问, 证明即使一级域名相同，二级域名不同，也不能获取到 Cookie 当然，使用 www.zhongfucheng.com 当然能获取到 Cookie，Cookie 通过请求头带给服务器 现在我希望一级域名相同的网页 Cookie 之间可以相互访问。也就是说 www.image.zhongfucheng.com 可以获取到 www.zhongfucheng.com 的 Cookie 就需要使用到 domain 方法。 1234567Cookie cookie = new Cookie(&quot;name&quot;, &quot;ouzicheng&quot;);cookie.setMaxAge(1000);cookie.setDomain(&quot;.zhongfucheng.com&quot;);response.addCookie(cookie);printWriter.write(&quot;使用www.zhongfucheng.com域名添加了一个Cookie,只要一级是zhongfucheng.com即可访问&quot;); 使用 www.zhongfucheng.com 发布一个 Cookie 使用 www.image.zhongfucheng.com 域名访问一下。发现可以获取到 Cookie 了 Cookie 的路径Cookie 的 path 属性决定允许访问 Cookie 的路径 一般地，Cookie 发布出来，整个网页的资源都可以使用。现在我只想 Servlet1 可以获取到 Cookie，其他的资源不能获取。 使用 Servlet2 颁发一个 Cookie 给浏览器, 设置路径为 “/Servlet1”。 1234567Cookie cookie = new Cookie(&quot;username&quot;, &quot;java&quot;);cookie.setPath(&quot;/Servlet1&quot;);cookie.setMaxAge(1000);response.addCookie(cookie);printWriter.write(&quot;该Cookie只有Servlet1获取得到&quot;); 使用 Servlet3 访问服务器，看看浏览器是否把 Cookie 带上。显然，浏览器访问 Servlet3 并没有把 Cookie 带上。 使用 Servlet1 访问服务器，看看浏览器是否把 Cookie 带上。答案是肯定的！ Cookie 的安全属性 HTTP 协议不仅仅是无状态的，而且是不安全的！如果不希望 Cookie 在非安全协议中传输，可以设置 Cookie 的 secure 属性为 true，浏览器只会在 HTTPS 和 SSL 等安全协议中传输该 Cookie。 当然了，设置 secure 属性不会将 Cookie 的内容加密。如果想要保证安全，最好使用 md5 算法加密【后面有】。 Cookie 的应用显示用户上次访问的时间 其实就是每次登陆的时候，取到 Cookie 保存的值，再更新下 Cookie 的值。 访问 Serlvet 有两种情况 第一次访问 已经访问过了 全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);response.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter printWriter = response.getWriter();//获取网页上所有的CookieCookie[] cookies = request.getCookies();//判断Cookie的值是否为空String cookieValue = null;for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; //获取到以time为名的Cookie if (cookies[i].getName().equals(&quot;time&quot;)) &#123; printWriter.write(&quot;您上次登陆的时间是：&quot;); cookieValue = cookies[i].getValue(); printWriter.write(cookieValue); cookies[i].setValue(simpleDateFormat.format(new Date())); response.addCookie(cookies[i]); //既然已经找到了就可以break循环了 break; &#125;&#125;//如果Cookie的值是空的，那么就是第一次访问if (cookieValue == null) &#123; //创建一个Cookie对象，日期为当前时间 Cookie cookie = new Cookie(&quot;time&quot;, simpleDateFormat.format(new Date())); //设置Cookie的生命期 cookie.setMaxAge(20000); //response对象回送Cookie给浏览器 response.addCookie(cookie); printWriter.write(&quot;您是第一次登陆啊！&quot;);&#125; 按照正常的逻辑来写，程序流程应该是这样子的。先创建 Cookie 对象，回送 Cookie 给浏览器。再遍历 Cookie，更新 Cookie 的值。 但是，按照上面的逻辑是做不到的！因为每次访问 Servlet 的时候都会覆盖原来的 Cookie，取到 Cookie 的值永远都是当前时间，而不是上次保存的时间。 我们换一个逻辑写：先检查（遍历）所有 Cookie 有没有我要的，如果得不到我想要的 Cookie，Cookie 的值是 null，那么就是第一次登陆，于是就有了上面的代码了。 我们来看下效果吧！当我第一次登陆的时候 Cookie 保存在硬盘中。 再次访问 Servlet。明显地，取到的就是 Cookie 的值 显示上次浏览过商品 我就以书籍为例子了！首先设计 Book 对象 123456789101112131415private String id ;private String name ;private String author;public Book() &#123;&#125;public Book(String id, String name, String author) &#123; this.id = id; this.name = name; this.author = author;&#125;...各种set、get方法 设计一个简单的数据库存储数据。就用 LinkedHashMap 集合【根据商品的 id 找书籍所以用 Map，删改较多所以用 Linked】 12345678910111213141516private static LinkedHashMap&lt;String, Book&gt; linkedHashMap = new LinkedHashMap();//简化开发复杂度，book的id和商品的id相同static &#123; linkedHashMap.put(&quot;1&quot;, new Book(&quot;1&quot;, &quot;javaweb&quot;, &quot;zhong&quot;)); linkedHashMap.put(&quot;2&quot;, new Book(&quot;2&quot;, &quot;java&quot;, &quot;fu&quot;)); linkedHashMap.put(&quot;3&quot;, new Book(&quot;3&quot;, &quot;oracle&quot;, &quot;cheng&quot;)); linkedHashMap.put(&quot;4&quot;, new Book(&quot;4&quot;, &quot;mysql&quot;, &quot;ou&quot;)); linkedHashMap.put(&quot;5&quot;, new Book(&quot;5&quot;, &quot;ajax&quot;, &quot;zi&quot;));&#125;//获取到所有书籍public static LinkedHashMap getAll() &#123; return linkedHashMap;&#125; 显示网页上所有的书籍【首页】 123456789101112printWriter.write(&quot;网页上所有的书籍：&quot;+&quot;&lt;br/&gt;&quot;);//拿到数据库所有的书LinkedHashMap&lt;String, Book&gt; linkedHashMap = DB.getAll();Set&lt;Map.Entry&lt;String, Book&gt;&gt; entry = linkedHashMap.entrySet();//显示所有的书到网页上for (Map.Entry&lt;String, Book&gt; stringBookEntry : entry) &#123; Book book = stringBookEntry.getValue(); printWriter.write(book.getId() +&quot; &quot;+ book.getName()+&quot;&lt;br/&gt;&quot;);&#125; 接着，我们要做的就是给显示的书籍挂上一个超链接，当用户点击想看的书籍时，就跳转到该书籍的详细信息页面 超链接应该把书的 id 传递过去，不然处理页面是不知道用户想看的是哪一本书的！ 1234567//显示所有的书到网页上for (Map.Entry&lt;String, Book&gt; stringBookEntry : entry) &#123; Book book = stringBookEntry.getValue(); printWriter.write(&quot;&lt;a href=&apos;/ouzicheng/Servlet2?id=&quot; + book.getId() + &quot;&apos;&apos;target=_blank&apos; +&quot; + book.getName() + &quot;&lt;/a&gt;&quot;); printWriter.write(&quot;&lt;br/&gt;&quot;);&#125; 接收 id，找到用户想要看哪一本书，输出该书的详细信息 12345678910String id = request.getParameter(&quot;id&quot;);//由于book的id和商品的id是一致的。获取到用户点击的书Book book = (Book) DB.getAll().get(id);//输出书的详细信息printWriter.write(&quot;书的编号是：&quot; + book.getId()+&quot;&lt;br/&gt;&quot;);printWriter.write(&quot;书的名称是：&quot; + book.getName()+&quot;&lt;br/&gt;&quot;);printWriter.write(&quot;书的作者是：&quot; + book.getAuthor()+&quot;&lt;br/&gt;&quot;); 点击想要的书籍。 得到书籍的详细信息 既然用户点击了书籍，那么服务器就应该颁发 Cookie 给浏览器，记住用户点击了该书籍 现在问题来了，Cookie 的值应该是什么呢？试想一下，待会还要把浏览过的书籍显示出来，所以用书籍的 id 是最好不过的。想到了用书籍的 id 作为 Cookie 的值，我们还要定义一些规则！ 我们可能有非常多的书籍，不可能把用户浏览过的书籍都显示出来。所以我们定义只能显示 3 本浏览过的书籍 书籍的 id 都是数字，如果不做任何修改，存到 Cookie 里边可能就是 231，345，123 此类的数字，这样取出某一个 id 的时候就十分费劲并且后面还要判断该书是否存在 Cookie 里边了，所以我们要把存储到 Cookie 的书籍 id 分割起来。所以我们定义”_“作为分隔符 按上面的应用，我们的逻辑应该是：先遍历下 Cookie，看下有没有我们想要的 Cookie。如果找到想要的 Cookie，那就取出 Cookie 的值 12345678String bookHistory = null;Cookie[] cookies = request.getCookies();for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; if (cookies[i].getName().equals(&quot;bookHistory&quot;)) &#123; bookHistory = cookies[i].getValue(); &#125;&#125; 取出了 Cookie 的值也分几种情况 Cookie 的值为 null【直接把传入进来的 id 当做是 Cookie 的值】 Cookie 的值长度有 3 个了【把排在最后的 id 去掉，把传进来的 id 排在最前边】 Cookie 的值已经包含有传递进来的 id 了【把已经包含的 id 先去掉，再把 id 排在最前面】 Cookie 的值就只有 1 个或 2 个，直接把 id 排在最前边 123456789101112131415161718192021222324if (bookHistory == null) &#123; return id;&#125;//如果Cookie的值不是null的，那么就分解Cookie的得到之前的id。String[] strings = bookHistory.split(&quot;\\_&quot;);//为了增删容易并且还要判断id是否存在于该字符串内-----我们使用LinkedList集合装载分解出来的idList list = Arrays.asList(strings);LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();linkedList.addAll(list);if (linkedList.contains(id)) &#123; linkedList.remove(id); linkedList.addFirst(id);&#125;else &#123; if (linkedList.size() &gt;= 3) &#123; linkedList.removeLast(); linkedList.addFirst(id); &#125; else &#123; linkedList.addFirst(id); &#125;&#125; 这么折腾完了，我们的 Cookie 值就在 LinkedList 集合里边了。接下来，我们要做的就是把集合中的值取出来，拼接成一个字符串 12345678910StringBuffer stringBuffer = new StringBuffer();//遍历LinkedList集合，添加个下划线“_”for (String s : linkedList) &#123; stringBuffer.append(s + &quot;_&quot;);&#125;//最后一个元素后面就不需要下划线了return stringBuffer.deleteCharAt(stringBuffer.length() - 1).toString(); 好的，我们现在已经完成了 Cookie 值了。接下来设置 Cookie 的生命周期，回送给浏览器即可 12345String bookHistory = makeHistory(request, id);Cookie cookie = new Cookie(&quot;bookHistory&quot;, bookHistory);cookie.setMaxAge(30000);response.addCookie(cookie); 既然我们已经把 Cookie 回送给浏览器了。那么接下来我们就在首页上获取 Cookie 的值，显示用户浏览过什么商品就行了！ 123456789101112131415161718192021222324252627282930printWriter.write(&quot;您曾经浏览过的商品：&quot;);printWriter.write(&quot;&lt;br/&gt;&quot;);//显示用户浏览过的商品Cookie[] cookies = request.getCookies();for (int i = 0; cookies != null &amp;&amp; i &lt; cookies.length; i++) &#123; if (cookies[i].getName().equals(&quot;bookHistory&quot;)) &#123; //获取到的bookHistory是2_3_1之类的 String bookHistory = cookies[i].getValue(); //拆解成每一个id值 String[] ids = bookHistory.split(&quot;\\_&quot;); //得到每一个id值 for (String id : ids) &#123; //通过id找到每一本书 Book book = linkedHashMap.get(id); printWriter.write(book.getName()); printWriter.write(&quot;&lt;br/&gt;&quot;); &#125; break; &#125;&#125; 好的，我们来试验一下吧！！，第一次访问首页，并没有浏览过的商品 当我点击 javaweb 书籍再访问首页的时候 再点击 ajax 然后访问首页 再点击 javaweb 然后访问首页 点击 oracle 然后访问首页 好的，经过测试，该程序应该没有什么问题了！ Servlet 第六篇【Session 介绍、API、生命周期、应用、与 Cookie 区别】什么是 Session Session 是另一种记录浏览器状态的机制。不同的是 Cookie 保存在浏览器中，Session 保存在服务器中。用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器，这就是 Session 如果说 Cookie 是检查用户身上的”通行证 “来确认用户的身份，那么 Session 就是通过检查服务器上的” 客户明细表“来确认用户的身份的。Session 相当于在服务器中建立了一份“客户明细表”。 为什么要使用 Session 技术？Session 比 Cookie 使用方便，Session 可以解决 Cookie 解决不了的事情【Session 可以存储对象，Cookie 只能存储字符串。】。 Session API long getCreationTime();【获取 Session 被创建时间】 String getId();【获取 Session 的 id】 long getLastAccessedTime();【返回 Session 最后活跃的时间】 ServletContext getServletContext();【获取 ServletContext 对象】 void setMaxInactiveInterval(int var1);【设置 Session 超时时间】 int getMaxInactiveInterval();【获取 Session 超时时间】 Object getAttribute(String var1);【获取 Session 属性】 Enumeration void setAttribute(String var1, Object var2);【设置 Session 属性】 void removeAttribute(String var1);【移除 Session 属性】 void invalidate();【销毁该 Session】 boolean isNew();【该 Session 是否为新的】 Session 作为域对象从上面的 API 看出，Session 有着 request 和 ServletContext 类似的方法。其实 Session 也是一个域对象。Session 作为一种记录浏览器状态的机制，只要 Session 对象没有被销毁，Servlet 之间就可以通过 Session 对象实现通讯 我们来试试吧，在 Servlet4 中设置 Session 属性 123456//得到Session对象HttpSession httpSession = request.getSession();//设置Session属性httpSession.setAttribute(&quot;name&quot;, &quot;看完博客就要点赞！！&quot;); 在 Servlet5 中获取到 Session 存进去的属性 12345//获取到从Servlet4的Session存进去的值HttpSession httpSession = request.getSession();String value = (String) httpSession.getAttribute(&quot;name&quot;);System.out.println(value); 访问 Servlet4，再访问 Servlet5 一般来讲，当我们要存进的是用户级别的数据就用 Session，那什么是用户级别呢？只要浏览器不关闭，希望数据还在，就使用 Session 来保存。 Session 的生命周期和有效期 Session 在用户第一次访问服务器 Servlet，jsp 等动态资源就会被自动创建，Session 对象保存在内存里，这也就为什么上面的例子可以直接使用 request 对象获取得到 Session 对象。 如果访问 HTML,IMAGE 等静态资源 Session 不会被创建。 Session 生成后，只要用户继续访问，服务器就会更新 Session 的最后访问时间，无论是否对 Session 进行读写，服务器都会认为 Session 活跃了一次。 由于会有越来越多的用户访问服务器，因此 Session 也会越来越多。为了防止内存溢出，服务器会把长时间没有活跃的 Session 从内存中删除，这个时间也就是 Session 的超时时间。 Session 的超时时间默认是 30 分钟，有三种方式可以对 Session 的超时时间进行修改 第一种方式：在 tomcat/conf/web.xml 文件中设置，时间值为 20 分钟，所有的 WEB 应用都有效 1234&lt;session-config&gt; &lt;session-timeout&gt;20&lt;/session-timeout&gt;&lt;/session-config&gt; 第二种方式：在单个的 web.xml 文件中设置，对单个 web 应用有效，如果有冲突，以自己的 web 应用为准。 1234&lt;session-config&gt; &lt;session-timeout&gt;20&lt;/session-timeout&gt;&lt;/session-config&gt; 第三种方式：通过 setMaxInactiveInterval() 方法设置 12345//设置Session最长超时时间为60秒，这里的单位是秒httpSession.setMaxInactiveInterval(60);System.out.println(httpSession.getMaxInactiveInterval()); Session 的有效期与 Cookie 的是不同的 使用 Session 完成简单的购物功能 我们还是以书籍为例，所以可以 copy“显示浏览过的商品 “例子部分的代码。 1234567891011121314151617181920response.setContentType(&quot;text/html;charset=UTF-8&quot;);PrintWriter printWriter = response.getWriter();printWriter.write(&quot;网页上所有的书籍：&quot; + &quot;&lt;br/&gt;&quot;);//拿到数据库所有的书LinkedHashMap&lt;String, Book&gt; linkedHashMap = DB.getAll();Set&lt;Map.Entry&lt;String, Book&gt;&gt; entry = linkedHashMap.entrySet();//显示所有的书到网页上for (Map.Entry&lt;String, Book&gt; stringBookEntry : entry) &#123; Book book = stringBookEntry.getValue(); String url = &quot;/ouzicheng/Servlet6?id=&quot; + book.getId(); printWriter.write(book.getName()); printWriter.write(&quot;&lt;a href=&apos;&quot; + url + &quot;&apos;&gt;购买&lt;/a&gt;&quot;); printWriter.write(&quot;&lt;br/&gt;&quot;);&#125; 在购物车页面上，获取到用户想买的书籍【用户可能不单想买一本书，于是乎，就用一个 List 容器装载书籍】，有了：先遍历 Cookie，再判断是否是第一次访问 Servlet 的逻辑思路，我们就可以先获取到 Session 的属性，如果 Session 的属性为 null，那么就是还没有该属性 123456789101112131415161718192021//得到用户想买书籍的idString id = request.getParameter(&quot;id&quot;);//根据书籍的id找到用户想买的书Book book = (Book) DB.getAll().get(id);//获取到Session对象HttpSession httpSession = request.getSession();//由于用户可能想买多本书的，所以我们用一个容器装着书籍List list = (List) httpSession.getAttribute(&quot;list&quot;);if (list == null) &#123; list = new ArrayList(); //设置Session属性 httpSession.setAttribute(&quot;list&quot;,list);&#125;//把书籍加入到list集合中list.add(book); 按我们正常的逻辑思路：先创建一个 ArrayList 对象，把书加到 list 集合中，然后设置 Session 的属性。这样是行不通的。每次 Servlet 被访问的时候都会创建一个 ArrayList 集合，书籍会被分发到不同的 ArrayList 中去。所以下面的代码是不行的！ 123456789101112131415//得到用户想买书籍的idString id = request.getParameter(&quot;id&quot;);//根据书籍的id找到用户想买的书Book book = (Book) DB.getAll().get(id);//获取到Session对象HttpSession httpSession = request.getSession();//创建List集合List list = new ArrayList();list.add(book);httpSession.setAttribute(&quot;list&quot;, list); 既然用户已经购买了书籍，那么也应该给提供页面显示用户购买过哪些书籍 123456789101112131415161718192021222324//得到用户想买书籍的idString id = request.getParameter(&quot;id&quot;);//根据书籍的id找到用户想买的书Book book = (Book) DB.getAll().get(id);//获取到Session对象HttpSession httpSession = request.getSession();//由于用户可能想买多本书的，所以我们用一个容器装着书籍List list = (List) httpSession.getAttribute(&quot;list&quot;);if (list == null) &#123; list = new ArrayList(); //设置Session属性 httpSession.setAttribute(&quot;list&quot;,list);&#125;//把书籍加入到list集合中list.add(book);String url = &quot;/ouzicheng/Servlet7&quot;;response.sendRedirect(url); 列出用户购买过的书籍 12345678910111213141516//要得到用户购买过哪些书籍，得到Session的属性遍历即可HttpSession httpSession = request.getSession();List&lt;Book&gt; list = (List) httpSession.getAttribute(&quot;list&quot;);if (list == null || list.size() == 0) &#123; printWriter.write(&quot;对不起，你还没有买过任何商品&quot;);&#125; else &#123; printWriter.write(&quot;您购买过以下商品：&quot;); printWriter.write(&quot;&lt;br/&gt;&quot;); for (Book book : list) &#123; printWriter.write(book.getName()); printWriter.write(&quot;&lt;br/&gt;&quot;); &#125;&#125; 效果如下 Session 的实现原理 用现象说明问题，我在 Servlet4 中的代码设置了 Session 的属性 123456//得到Session对象HttpSession httpSession = request.getSession();//设置Session属性httpSession.setAttribute(&quot;name&quot;, &quot;看完博客就要点赞！！&quot;); 接着在 Servlet7 把 Session 的属性取出来 1234String value = (String) request.getSession().getAttribute(&quot;name&quot;);printWriter.write(value); 自然地，我们能取到在 Servlet4 中 Session 设置的属性 接着，我在浏览器中新建一个会话，再次访问 Servlet7 发现报了空指针异常的错误 现在问题来了：服务器是如何实现一个 session 为一个用户浏览器服务的？换个说法：为什么服务器能够为不同的用户浏览器提供不同 session？ HTTP 协议是无状态的，Session 不能依据 HTTP 连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为 JESSIONID 的 Cookie，它的值是 Session 的 id 值。其实 Session 依据 Cookie 来识别是否是同一个用户。 简单来说：Session 之所以可以识别不同的用户，依靠的就是 Cookie 该 Cookie 是服务器自动颁发给浏览器的，不用我们手工创建的。该 Cookie 的 maxAge 值默认是 - 1，也就是说仅当前浏览器使用，不将该 Cookie 存在硬盘中 我们来捋一捋思路流程：当我们访问 Servlet4 的时候，服务器就会创建一个 Session 对象，执行我们的程序代码，并自动颁发个 Cookie 给用户浏览器 当我们用同一个浏览器访问 Servlet7 的时候，浏览器会把 Cookie 的值通过 http 协议带过去给服务器，服务器就知道用哪一 Session。 而当我们使用新会话的浏览器访问 Servlet7 的时候，该新浏览器并没有 Cookie，服务器无法辨认使用哪一个 Session，所以就获取不到值 浏览器禁用了 Cookie，Session 还能用吗？上面说了 Session 是依靠 Cookie 来识别用户浏览器的。如果我的用户浏览器禁用了 Cookie 了呢？绝大多数的手机浏览器都不支持 Cookie，那我的 Session 怎么办？ 好的，我们来看看情况是怎么样的。用户浏览器访问 Servlet4 的时候，服务器向用户浏览器颁发了一个 Cookie 但是呢，当用户浏览器访问 Servlet7 的时候，由于我们禁用了 Cookie，所以用户浏览器并没有把 Cookie 带过去给服务器。 一看，Session 好像不能用了。但是 Java Web 提供了解决方法：URL 地址重写 HttpServletResponse 类提供了两个 URL 地址重写的方法： encodeURL(String url) encodeRedirectURL(String url) 需要值得注意的是：这两个方法会自动判断该浏览器是否支持 Cookie，如果支持 Cookie，重写后的 URL 地址就不会带有 jsessionid 了【当然了，即使浏览器支持 Cookie，第一次输出 URL 地址的时候还是会出现 jsessionid（因为没有任何 Cookie 可带）】 下面我们就以上面 “购物” 的例子来做试验吧！首先我们来看看禁用掉 Cookie 对原来的小例子有什么影响。 访问 Servlet1，随便点击一本书籍购买 无论点击多少次，都会直接提示我们有买过任何商品 原因也非常简单，没有 Cookie 传递给服务器，服务器每次创建的时候都是新的 Session，导致最后获取到的 List 集合一定是空的。 不同 Servlet 获取到的 Session 的 id 号都是不同的。 下面我们就对 URL 进行重写，看看能不能恢复没有禁掉 Cookie 之前的效果。 原则：把 Session 的属性带过去【传递给】另外一个 Servlet，都要 URL 地址重写 在跳转到显示购买过商品的 Servlet 的时候，URL 地址重写。 1234String url = &quot;/ouzicheng/Servlet7&quot;;response.sendRedirect(response.encodeURL(url)); 再次访问 Servlet1，当我点击 javaweb 的时候，已经能够成功出现我买过的商品了。并且 Session 的 id 通过 URL 地址重写，使用的是同一个 Session URL 地址重写的原理：将 Session 的 id 信息重写到 URL 地址中。服务器解析重写后 URL，获取 Session 的 id。这样一来，即使浏览器禁用掉了 Cookie，但 Session 的 id 通过服务器端传递，还是可以使用 Session 来记录用户的状态。 Session 禁用 Cookie Java Web 规范支持通过配置禁用 Cookie 禁用自己项目的 Cookie 在 META-INF 文件夹下的 context.xml 文件中修改（没有则创建） 12345&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;Context path=&quot;/ouzicheng&quot; cookies=&quot;false&quot;&gt;&lt;/Context&gt; 禁用全部 web 应用的 Cookie 在 conf/context.xml 中修改 注意：该配置只是让服务器不能自动维护名为 jsessionid 的 Cookie，并不能阻止 Cookie 的读写。 Session 案例使用 Session 完成用户简单登陆 先创建 User 类 12345678910111213private String username = null;private String password = null;public User() &#123;&#125;public User(String username, String password) &#123; this.username = username; this.password = password;&#125;....各种set、get方法 使用简单的集合模拟一个数据库 1234567891011121314151617181920212223private static List&lt;User&gt; list = new ArrayList&lt;&gt;();//装载些数据进数据库static &#123; list.add(new User(&quot;aaa&quot;,&quot;111&quot;)); list.add(new User(&quot;bbb&quot;,&quot;222&quot;)); list.add(new User(&quot;ccc&quot;,&quot;333&quot;));&#125;//通过用户名和密码查找用户public static User find(String username, String password) &#123; for (User user : list) &#123; if (user.getUsername().equals(username) &amp;&amp; user.getPassword().equals(password)) &#123; return user; &#125; &#125; return null;&#125; 表单提交的工作我就在 jsp 写了，如果在 Servlet 写太麻烦了！ 1234567&lt;form action=&quot;/ouzicheng/LoginServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 获取到表单提交的数据，查找数据库是否有相对应的用户名和密码。如果没有就提示用户名或密码出错了，如果有就跳转到另外一个页面 123456789101112131415161718String username = request.getParameter(&quot;username&quot;);String password = request.getParameter(&quot;password&quot;);User user = UserDB.find(username, password);//如果找不到，就是用户名或密码出错了。if (user == null) &#123; response.getWriter().write(&quot;you can&apos;t login&quot;); return;&#125;//标记着该用户已经登陆了！HttpSession httpSession = request.getSession();httpSession.setAttribute(&quot;user&quot;, user);//跳转到其他页面，告诉用户成功登陆了。response.sendRedirect(response.encodeURL(&quot;index.jsp&quot;)); 我们来试试下数据库没有的用户名和密码，提示我不能登陆。 试试数据库存在的用户名和密码 利用 Session 防止表单重复提交 重复提交的危害： 在投票的网页上不停地提交，实现了刷票的效果。 注册多个用户，不断发帖子，扰乱正常发帖秩序。 首先我们来看一下常见的重复提交。 在处理表单的 Servlet 中刷新。 后退再提交 网络延迟，多次点击提交按钮 下面的 gif 是后退再提交，在处理提交请求的 Servlet 中刷新 下面的 gif 是网络延迟，多次点击提交按钮 对于网络延迟造成的多次提交数据给服务器，其实是客户端的问题。于是，我们可以使用 javaScript 来防止这种情况 要做的事情也非常简单：当用户第一次点击提交按钮时，把数据提交给服务器。当用户再次点击提交按钮时，就不把数据提交给服务器了。 监听用户提交事件。只能让用户提交一次表单！ 12345678910111213141516171819202122232425262728293031323334&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;表单提交&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //定义一个全局标识量：是否已经提交过表单数据 var isCommitted = false; function doSubmit() &#123; //false表示的是没有提交过，于是就可以让表单提交给Servlet if(isCommitted==false) &#123; isCommitted = true; return true; &#125;else &#123; return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/ouzicheng/Servlet7&quot; onsubmit=&quot;return doSubmit()&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 好的，我们来试一下是不是真的可以解决网络延迟所造成的多次提交表单数据，注意鼠标，我已经点击过很多次的了！ 由于网络延迟造成的多次提交数据给服务器，我们还可以使用 javaScript 代码这样解决：当我点击过一次提交按钮时，我就把提交的按钮隐藏起来。不能让用户点击了！ 想要让按钮隐藏起来，也很简单。只要获取到按钮的节点，就可以控制按钮的隐藏或显示了！ 12345678910&lt;script type=&quot;text/javascript&quot;&gt; function doSubmit() &#123; var button = document.getElementById(&quot;button&quot;); button.disabled = disabled; return true; &#125;&lt;/script&gt; 我们再来看一下效果 在处理表单的 Servlet 中刷新和后退再提交这两种方式不能只靠客户端来限制了。也就是说 javaScript 代码无法阻止这两种情况的发生。 于是乎，我们就想得用其他办法来阻止表单数据重复提交了。我们现在学了 Session，Session 可以用来标识一个用户是否登陆了。Session 的原理也说了：不同的用户浏览器会拥有不同的 Session。而 request 和 ServletContext 为什么就不行呢？request 的域对象只能是一次 http 请求，提交表单数据的时候 request 域对象的数据取不出来。ServletContext 代表整个 web 应用，如果有几个用户浏览器同时访问，ServletContext 域对象的数据会被多次覆盖掉，也就是说域对象的数据就毫无意义了。 可能到这里，我们会想到：在提交数据的时候，存进 Session 域对象的数据，在处理提交数据的 Servlet 中判断 Session 域对象数据????。究竟判断 Session 什么？判断 Session 域对象的数据不为 null？没用呀，既然已经提交过来了，那肯定不为 null。 此时，我们就想到了，在表单中还有一个隐藏域，可以通过隐藏域把数据交给服务器。 判断 Session 域对象的数据和 jsp 隐藏域提交的数据是否对应。 判断隐藏域的数据是否为空【如果为空，就是直接访问表单处理页面的 Servlet】 判断 Session 的数据是否为空【servlet 判断完是否重复提交，最好能立马移除 Session 的数据，不然还没有移除的时候，客户端那边儿的请求又来了，就又能匹配了，产生了重复提交。如果 Session 域对象数据为空，证明已经提交过数据了！】 我们向 Session 域对象的存入数据究竟是什么呢？简单的一个数字？好像也行啊。因为只要 Session 域对象的数据和 jsp 隐藏域带过去的数据对得上号就行了呀，反正在 Servlet 上判断完是否重复提交，会立马把 Session 的数据移除掉的。更专业的做法是：向 Session 域对象存入的数据是一个随机数【Token– 令牌】。 生成一个独一无二的随机数 123456789101112131415161718192021222324252627282930313233343536373839404142/** 产生随机数就应该用一个对象来生成，这样可以避免随机数的重复。* 所以设计成单例* */public class TokenProcessor &#123; private TokenProcessor() &#123; &#125; private final static TokenProcessor TOKEN_PROCESSOR = new TokenProcessor(); public static TokenProcessor getInstance() &#123; return TOKEN_PROCESSOR; &#125; public static String makeToken() &#123; //这个随机生成出来的Token的长度是不确定的 String token = String.valueOf(System.currentTimeMillis() + new Random().nextInt(99999999)); try &#123; //我们想要随机数的长度一致，就要获取到数据指纹 MessageDigest messageDigest = MessageDigest.getInstance(&quot;md5&quot;); byte[] md5 = messageDigest.digest(token.getBytes()); //如果我们直接 return new String(md5)出去，得到的随机数会乱码。 //因为随机数是任意的01010101010，在转换成字符串的时候，会查gb2312的码表，gb2312码表不一定支持该二进制数据，得到的就是乱码 //于是乎经过base64编码成了明文的数据 BASE64Encoder base64Encoder = new BASE64Encoder(); return base64Encoder.encode(md5); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 创建 Token 随机数，并跳转到 jsp 页面 12345678910//生出随机数TokenProcessor tokenProcessor = TokenProcessor.getInstance();String token = tokenProcessor.makeToken();//将随机数存进Session中request.getSession().setAttribute(&quot;token&quot;, token);//跳转到显示页面request.getRequestDispatcher(&quot;/login.jsp&quot;).forward(request, response); jsp 隐藏域获取到 Session 的值 12345678910&lt;form action=&quot;/ouzicheng/Servlet7&quot; &gt; 用户名：&lt;input type=&quot;text&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;button&quot;&gt; &lt;%--使用EL表达式取出session中的Token--%&gt; &lt;input type=&quot;hidden&quot; $&#123;token&#125;&quot; &gt;&lt;/form&gt; 在处理表单提交页面中判断：jsp 隐藏域是否有值带过来，Session 中的值是否为空，Session 中的值和 jsp 隐藏域带过来的值是否相等 123456789101112131415String serverValue = (String) request.getSession().getAttribute(&quot;token&quot;);String clientValue = request.getParameter(&quot;token&quot;);if (serverValue != null &amp;&amp; clientValue != null &amp;&amp; serverValue.equals(clientValue)) &#123; System.out.println(&quot;处理请求&quot;); //清除Session域对象数据 request.getSession().removeAttribute(&quot;token&quot;);&#125;else &#123; System.out.println(&quot;请不要重复提交数据！&quot;);&#125; 下面我们再来看一下, 已经可以解决表单重复提交的问题了！ 实现原理是非常简单的： 在 session 域中存储一个 token 然后前台页面的隐藏域获取得到这个 token 在第一次访问的时候，我们就判断 seesion 有没有值，如果有就比对。对比正确后我们就处理请求，接着就把 session 存储的数据给删除了 等到再次访问的时候，我们 session 就没有值了，就不受理前台的请求了！ 一次性校验码 一次性校验码其实就是为了防止暴力猜测密码 在讲 response 对象的时候，我们使用 response 对象输出过验证码，但是没有去验证！ 验证的原理也非常简单：生成验证码后，把验证码的数据存进 Session 域对象中，判断用户输入验证码是否和 Session 域对象的数据一致。 生成验证码图片，并将验证码存进 Session 域中 123456789101112131415161718192021222324252627282930313233//在内存中生成图片BufferedImage bufferedImage = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB);//获取到这张图片Graphics2D graphics2D = (Graphics2D) bufferedImage.getGraphics();//设置背景色为白色graphics2D.setColor(Color.white);graphics2D.fillRect(0, 0, 80, 20);//设置图片的字体和颜色graphics2D.setFont(new Font(null, Font.BOLD, 20));graphics2D.setColor(Color.BLUE);//生成随机数String randomNum = makeNum();//往这张图片上写数据,横坐标是0，纵坐标是20graphics2D.drawString(randomNum, 0, 20);//将随机数存进Session域中request.getSession().setAttribute(&quot;randomNum&quot;, randomNum);//控制浏览器不缓存该图片response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);//通知浏览器以图片的方式打开response.setHeader(&quot;Content-type&quot;, &quot;image/jpeg&quot;);//把图片写给浏览器ImageIO.write(bufferedImage, &quot;jpg&quot;, response.getOutputStream()); 生成随机数的方法： 1234567891011121314151617181920private String makeNum() &#123; Random random = new Random(); //生成0-6位的随机数 int num = random.nextInt(999999); //验证码的数位全都要6位数，于是将该随机数转换成字符串，不够位数就添加 String randomNum = String.valueOf(num); //使用StringBuffer来拼凑字符串 StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; 6 - randomNum.length(); i++) &#123; stringBuffer.append(&quot;0&quot;); &#125; return stringBuffer.append(randomNum).toString();&#125; jsp 显示页面 1234567891011&lt;form action=&quot;/ouzicheng/Login2Servlet&quot;&gt; 用户名：&lt;input type=&quot;text&quot; &gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br&gt; 验证码：&lt;input type=&quot;text&quot; &gt; &lt;img src=&quot;/ouzicheng/ImageServlet&quot; &gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 处理提交表单数据的 Servlet，判断用户带过来验证码的数据是否和 Session 的数据相同。 1234567891011121314//获取用户输入验证码的数据String client_randomNum = request.getParameter(&quot;randomNum&quot;);//获取Session中的数据String session_randomNum = (String) request.getSession().getAttribute(&quot;randomNum&quot;);//判断他俩数据是否相等，用户是否有输入验证码，Session中是否为空if (client_randomNum == null || session_randomNum == null || !client_randomNum.equals(session_randomNum)) &#123; System.out.println(&quot;验证码错误了！！！&quot;); return ;&#125;//下面就是验证用户名和密码................... 显示页面是这样子的 我们来看一下效果！ 对于校验码实现思路是这样子的： 使用 awt 语法来描写一张验证码，生成随机数保存在 seesion 域中，我们让验证码不能缓存起来【做到验证码都不一样】 页面直接访问 Servlet 来获取我们的验证码，于是我们验证码的值就会改变【同时 session 的值也会被改变】 当用户验证的时候，就是 session 内的值的验证了。 Session 和 Cookie 的区别 从存储方式上比较 Cookie 只能存储字符串，如果要存储非 ASCII 字符串还要对其编码。 Session 可以存储任何类型的数据，可以把 Session 看成是一个容器 从隐私安全上比较 Cookie 存储在浏览器中，对客户端是可见的。信息容易泄露出去。如果使用 Cookie，最好将 Cookie 加密 Session 存储在服务器上，对客户端是透明的。不存在敏感信息泄露问题。 从有效期上比较 Cookie 保存在硬盘中，只需要设置 maxAge 属性为比较大的正整数，即使关闭浏览器，Cookie 还是存在的 Session 的保存在服务器中，设置 maxInactiveInterval 属性值来确定 Session 的有效期。并且 Session 依赖于名为 JSESSIONID 的 Cookie，该 Cookie 默认的 maxAge 属性为 - 1。如果关闭了浏览器，该 Session 虽然没有从服务器中消亡，但也就失效了。 从对服务器的负担比较 Session 是保存在服务器的，每个用户都会产生一个 Session，如果是并发访问的用户非常多，是不能使用 Session 的，Session 会消耗大量的内存。 Cookie 是保存在客户端的。不占用服务器的资源。像 baidu、Sina 这样的大型网站，一般都是使用 Cookie 来进行会话跟踪。 从浏览器的支持上比较 如果浏览器禁用了 Cookie，那么 Cookie 是无用的了！ 如果浏览器禁用了 Cookie，Session 可以通过 URL 地址重写来进行会话跟踪。 从跨域名上比较 Cookie 可以设置 domain 属性来实现跨域名 Session 只在当前的域名内有效，不可夸域名 Cookie 和 Session 共同使用 如果仅仅使用 Cookie 或仅仅使用 Session 可能达不到理想的效果。这时应该尝试一下同时使用 Session 和 Cookie 那么，什么时候才需要同时使用 Cookie 和 Session 呢？ 在上一篇博客中，我们使用了 Session 来进行简单的购物，功能也的确实现了。现在有一个问题：我在购物的途中，不小心关闭了浏览器。当我再返回进去浏览器的时候，发现我购买过的商品记录都没了！！为什么会没了呢？原因也非常简单：服务器为 Session 自动维护的 Cookie 的 maxAge 属性默认是 - 1 的，当浏览器关闭掉了，该 Cookie 就自动消亡了。当用户再次访问的时候，已经不是原来的 Cookie 了。 我们现在想的是：即使我不小心关闭了浏览器了，我重新进去网站，我还能找到我的购买记录。 要实现该功能也十分简单，问题其实就在：服务器为 Session 自动维护的 Cookie 的 maxAge 属性是 - 1，Cookie 没有保存在硬盘中。我现在要做的就是：把 Cookie 保存在硬盘中，即使我关闭了浏览器，浏览器再次访问页面的时候，可以带上 Cookie，从而服务器识别出 Session。 第一种方式：只需要在处理购买页面上创建 Cookie，Cookie 的值是 Session 的 id 返回给浏览器即可 12345Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,session.getId());cookie.setMaxAge(30*60);cookie.setPath(&quot;/ouzicheng/&quot;);response.addCookie(cookie); 第二种方式： 在 server.xml 文件中配置，将每个用户的 Session 在服务器关闭的时候序列化到硬盘或数据库上保存。但此方法不常用，知道即可！ 下面看一下效果 参考：Servlet+JSP - 文集 - 简书https://www.jianshu.com/nb/21926044]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat+Servlet面试总结]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28%2F</url>
    <content type="text"><![CDATA[Servlet 知识点: 图上的知识点都可以在我其他的文章内找到相应内容。 Tomcat 常见面试题Tomcat 的缺省端口是多少，怎么修改 Tomcat 的缺省端口是多少，怎么修改 找到 Tomcat 目录下的 conf 文件夹 进入 conf 文件夹里面找到 server.xml 文件 打开 server.xml 文件 在 server.xml 文件里面找到下列信息 12345&lt;Service &gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 把 port=”8080″改成 port=”8888″，并且保存 启动 Tomcat，并且在 IE 浏览器里面的地址栏输入 http://127.0.0.1:8888/ 到 tomcat 主目录下的 conf/server.xml 文件中修改, 把 8080 端口改成是 8088 或者是其他的 Tomcat 有哪几种 Connector 运行模式 (优化)？ tomcat 有哪几种 Connector 运行模式 (优化)？ bio(blocking I/O) nio(non-blocking I/O) apr(Apache Portable Runtime/Apache 可移植运行库) 相关解释: bio: 传统的 Java I/O 操作，同步且阻塞 IO。 nio: JDK1.4 开始支持，同步阻塞或同步非阻塞 IO aio(nio.2): JDK7 开始支持，异步非阻塞 IO apr: Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高 Tomcat 对静态文件的处理性能 下面是配置 Tomcat 运行模式改成是 NIO 模式，并配置连接池相关参数来进行优化: 1234567891011121314151617181920&lt;!--&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;--&gt;&lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;&lt;!-- minProcessors最小空闲连接线程数--&gt;&lt;!-- maxProcessors最大连接线程数--&gt;&lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;&lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443 maxThreads=“500” minSpareThreads=“100” maxSpareThreads=“200” acceptCount=&quot;200&quot; enableLookups=&quot;false&quot; /&gt; apr 模式启动起来是比较复杂的，详情可参考:http://blog.csdn.net/wanglei_storage/article/details/50225779 对于 bio,nio,nio.2 的理解可参考:http://blog.csdn.net/itismelzp/article/details/50886009 Tomcat 有几种部署方式 直接把 Web 项目放在 webapps 下，Tomcat 会自动将其部署 在 server.xml 文件上配置&lt;Context&gt;节点，设置相关的属性即可 通过 Catalina 来进行配置: 进入到 conf\Catalina\localhost 文件下，创建一个 xml 文件，该文件的名字就是站点的名字。编写 XML 的方式来进行设置。 部署方式第二点： 在其他盘符下创建一个 web 站点目录，并创建 WEB-INF 目录和一个 html 文件。 找到 Tomcat 目录下 / conf/server.xml 文件 在 server.xml 中的节点下添加如下代码。path 表示的是访问时输入的 web 项目名，docBase 表示的是站点目录的绝对路径 12&lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt; 访问配置好的 web 站点 部署方式第三点： 进入到 conf\Catalina\localhost 文件下，创建一个 xml 文件，该文件的名字就是站点的名字。 xml 文件的代码如下，docBase 是你 web 站点的绝对路径 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Context docBase=&quot;D:\web1&quot; reloadable=&quot;true&quot;&gt; &lt;/Context&gt; 访问 web 站点下的 html 资源 Servlet 面试题Servlet 生命周期 Servlet 生命周期? 第一次访问 Servlet，我们发现 init() 和 service() 都被调用了 第二次访问 Servlet，service() 被调用了 第三次访问 Servlet，还是 service() 被调用了 当我们关闭 Tomcat 服务器的时候，destroy() 被调用了！ Servlet 生命周期可分为 5 个步骤 加载 Servlet。当 Tomcat 第一次访问 Servlet 的时候，Tomcat 会负责创建 Servlet 的实例 初始化。当 Servlet 被实例化后，Tomcat 会调用 init() 方法初始化这个对象 处理服务。当浏览器访问 Servlet 的时候，Servlet 会调用 service() 方法处理请求 销毁。当 Tomcat 关闭时或者检测到 Servlet 要从 Tomcat 删除的时候会自动调用 destroy() 方法，让该实例释放掉所占的资源。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁 卸载。当 Servlet 调用完 destroy() 方法后，等待垃圾回收。如果有需要再次使用这个 Servlet，会重新调用 init() 方法进行初始化操作。 简单总结：只要访问 Servlet，service() 就会被调用。init() 只有第一次访问 Servlet 的时候才会被调用。destroy() 只有在 Tomcat 关闭的时候才会被调用。 get 方式和 post 方式有何区别 get 方式和 post 方式有何区别 数据携带上: GET 方式：在 URL 地址后附带的参数是有限制的，其数据容量通常不能超过 1K。 POST 方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。 请求参数的位置上: GET 方式：请求参数放在 URL 地址后面，以? 的方式来进行拼接 POST 方式: 请求参数放在 HTTP 请求包中 用途上: GET 方式一般用来获取数据 POST 方式一般用来提交数据 原因: 首先是因为 GET 方式携带的数据量比较小，无法带过去很大的数量 POST 方式提交的参数后台更加容易解析 (使用 POST 方式提交的中文数据，后台也更加容易解决) GET 方式比 POST 方式要快GET 方式比 POST 方式要快，详情可看:https://www.cnblogs.com/strayling/p/3580048.html Servlet 相关 API doGet 与 doPost 方法的两个参数是什么 HttpServletRequest：封装了与请求相关的信息 HttpServletResponse：封装了与响应相关的信息 获取页面的元素的值有几种方式，分别说一下 request.getParameter() 返回客户端的请求参数的值 request.getParameterNames() 返回所有可用属性名的枚举 request.getParameterValues() 返回包含参数的所有值的数组 request.getAttribute() 和 request.getParameter() 区别 用途上: request.getAttribute()， 一般用于获取 request 域对象的数据 (在跳转之前把数据使用 setAttribute 来放到 request 对象上) request.getParameter()， 一般用于获取客户端提交的参数 存储数据上: request.getAttribute() 可以获取 Objcet 对象 request.getParameter() 只能获取字符串 (这也是为什么它一般用于获取客户端提交的参数) forward 和 redirect 的区别 forward 和 redirect 的区别 实际发生位置不同，地址栏不同 转发是发生在服务器的 转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问 Servlet111 的时候，即使跳转到了 Servlet222 的页面，浏览器的地址还是 Servlet111 的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的 http 请求，一次转发中 request 和 response 对象都是同一个。这也解释了，为什么可以使用 request 作为域对象进行 Servlet 之间的通讯。 重定向是发生在浏览器的 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。曾经介绍过：实现重定向的原理是由 response 的状态码和 Location 头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个 http 请求，request 域对象是无效的，因为它不是同一个 request 对象 用法不同: 很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 request.getRequestDispatcher(“/ 资源名 URI”).forward(request,response) 转发时”/” 代表的是本应用程序的根目录【zhongfucheng】 response.send(“/web 应用 / 资源名 URI”); 重定向时”/” 代表的是 webapps 目录 能够去往的 URL 的范围不一样: 转发是服务器跳转只能去往当前 web 应用的资源 重定向是服务器跳转，可以去往任何的资源 传递数据的类型不同 转发的 request 对象可以传递各种类型的数据，包括对象 重定向只能传递字符串 跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 那么转发 (forward) 和重定向 (redirect) 使用哪一个？ 根据上面说明了转发和重定向的区别也可以很容易概括出来。转发是带着转发前的请求的参数的。重定向是新的请求。 典型的应用场景： 转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变 重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了 tomcat 容器是如何创建 servlet 类实例？用到了什么原理？ tomcat 容器是如何创建 servlet 类实例？用到了什么原理 当容器启动时，会读取在 webapps 目录下所有的 web 应用中的 web.xml 文件，然后对 xml 文件进行解析，并读取 servlet 注册信息。然后，将每个应用中注册的 servlet 类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化） 在 servlet 注册时加上 1 如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。 什么是 cookie？Session 和 cookie 有什么区别？ 什么是 cookie？ Cookie 是由 W3C 组织提出，最早由 netscape 社区发展的一种机制 网页之间的交互是通过 HTTP 协议传输数据的，而 Http 协议是无状态的协议。无状态的协议是什么意思呢？一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接。 服务器无法确认用户的信息，于是乎，W3C 就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是 Cookie Session 和 cookie 有什么区别？ 从存储方式上比较 Cookie 只能存储字符串，如果要存储非 ASCII 字符串还要对其编码。 Session 可以存储任何类型的数据，可以把 Session 看成是一个容器 从隐私安全上比较 Cookie 存储在浏览器中，对客户端是可见的。信息容易泄露出去。如果使用 Cookie，最好将 Cookie 加密 Session 存储在服务器上，对客户端是透明的。不存在敏感信息泄露问题。 从有效期上比较 Cookie 保存在硬盘中，只需要设置 maxAge 属性为比较大的正整数，即使关闭浏览器，Cookie 还是存在的 Session 的保存在服务器中，设置 maxInactiveInterval 属性值来确定 Session 的有效期。并且 Session 依赖于名为 JSESSIONID 的 Cookie，该 Cookie 默认的 maxAge 属性为 - 1。如果关闭了浏览器，该 Session 虽然没有从服务器中消亡，但也就失效了。 从对服务器的负担比较 Session 是保存在服务器的，每个用户都会产生一个 Session，如果是并发访问的用户非常多，是不能使用 Session 的，Session 会消耗大量的内存。 Cookie 是保存在客户端的。不占用服务器的资源。像 baidu、Sina 这样的大型网站，一般都是使用 Cookie 来进行会话跟踪。 从浏览器的支持上比较 如果浏览器禁用了 Cookie，那么 Cookie 是无用的了！ 如果浏览器禁用了 Cookie，Session 可以通过 URL 地址重写来进行会话跟踪。 从跨域名上比较 Cookie 可以设置 domain 属性来实现跨域名 Session 只在当前的域名内有效，不可夸域名 Servlet 安全性问题由于 Servlet 是单例的，当多个用户访问 Servlet 的时候，服务器会为每个用户创建一个线程。当多个用户并发访问 Servlet 共享资源的时候就会出现线程安全问题。 原则： 如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制 synchronized (对象){} 如果一个变量不需要共享，则直接在 doGet() 或者 doPost() 定义. 这样不会存在线程安全问题 1)解释什么是Jasper? Jasper是Tomcat的JSP引擎 它解析JSP文件，将它们编译成JAVA代码作为servlet 在运行时，Jasper允许自动检测JSP文件的更改并重新编译它们 2)请说明select * from tab的输出结果是什么? 显示数据库中的默认表 3)请解释如何配置Tomcat来使用IIS和NTLM ? 必须遵循isapi_redirector.dll的标准指令 配置IIS使用“集成windows验证” 确保在服务器.xml中您已经禁用了tomcat身份验证 &lt;Connector port = “8009” enableLooksup = “false” redirect port = “8443” protocol = “AJP/1.3” tomcatAuthentication = “false” /&gt; 4)请解释一下什么时候可以使用“.”，什么时候可以使用“[]”? 如果正在运行bean属性，请使用“.”操作符，如果正在执行映射值或数组索引，则首选使用“[]”运算符。虽然两个运算符可以互换。 5)请解释Tomcat的默认端口是什么? Tomcat的默认端口是8080。在本地机器上初始化Tomcat之后，您可以验证Tomcat是否正在运行URL:http://localhost:8080 6)请解释Tomcat中使用的连接器是什么? 在Tomcat中，使用了两种类型的连接器： HTTP连接器:它有许多可以更改的属性，以确定它的工作方式和访问功能，如重定向和代理转发 AJP连接器:它以与HTTP连接器相同的方式工作，但是他们使用的是HTTP的AJP协议。AJP连接器通常通过插件技术mod_jk在Tomcat中实现 7)请阐述Catalina的配置文件有哪些? Catalina包含的配置文件有： ·policy ·properties ·properties ·xml ·xml ·Tomcat-users.xml ·xml 8)请解释将Tomcat作为一个Windows 服务运行会带来哪些好处? 运行Tomcat作为windows服务带来了以下的好处： 自动启动:对于需要在维护后远程重新启动系统的环境来说，这是至关重要的 启动无活动用户登录的服务器:Tomcat通常在刀片服务器上运行，这些服务器甚至可能没有一个活动监视器，Windows服务可以在没有活动用户的情况下启动 安全性:在Windows服务下的Tomcat可以让您在一个特殊的系统帐户下运行它，这个账户可以从其他用户帐户中得到保护 9)解释何时在Tomcat使用SSL ? 当你将Tomcat作为独立的web服务器运行时，需使用Tomcat来处理连接 10)解释如何使用WAR文件部署web应用程序? 在Tomcat的web应用程序目录下，jsp、servlet和它们的支持文件被放置在适当的子目录中。你可以将web应用程序目录下的所有文件压缩到一个压缩文件中，以.war文件扩展名结束。你可以通过在webapps目录中放置WAR文件来执行web应用程序。当一个web服务器开始执行时，它会将WAR文件的内容提取到适当的webapps子目录中。 11)解释什么是Tomcat Valve? Tomcat Valve——Tomcat 4引入的新技术，它允许您将Java类的实例链接到一个特定的Catalina容器。 12)说明Tomcat配置了多少个Valve? Tomcat配置了四种类型的Valve： ·访问日志 ·远程地址过滤 ·远程主机过滤器 ·客户请求记录器 13)解释servlet如何完成生命周期? 在Tomcat上运行的典型servlet生命周期如下： ·Tomcat通过它的其中一个连接器接收来自客户端的请求 ·进程请求Tomcat将此请求映射为适当的 ·一旦请求被定向到适当的servlet，Tomcat就会验证servlet类是否已经加载。如果不是Tomcat将servlet包装成Java字节码，这是由JVM执行的，并形成servlet的实例 ·Tomcat通过调用它的init来启动servlet，它包含能够筛选Tomcat配置文件并相应地采取行动的代码，并声明它可能需要的任何资源 ·一旦servlet启动，Tomcat就可以调用servlet的服务方法来进行请求 ·在servlet的生命周期中，Tomcat和servlet可以通过使用侦听器类来进行协调或通信，从而跟踪各种状态变化的servlet ·删除servlet，Tomcat调用servlet销毁方法 14)请说明NAT协议的目的是什么? NAT协议的目的是将私有IP地址从公共IP地址隐藏起来，并给组织提供一定的安全性。 15)请解释一下MAC代表什么? MAC意味着中访问控制- 16)请解释什么是Tomcat Coyote ? Tom coyote是基于HTTP / 1.1规范的HTTP连接器，通过监听TCP / IP端口并将请求发送回请求客户端，向Tomcat引擎接收和传输web请求。 参考：Tomcat+Servlet面试题都在这里 - 简书https://www.jianshu.com/p/fdee4e0c2a1dhttp://server.it168.com/a2017/0901/3168/000003168567.shtml]]></content>
      <tags>
        <tag>servlet</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat学习]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-4%2F</url>
    <content type="text"><![CDATA[什么是 TomcatTomcat 简单的说就是一个运行 JAVA 的网络服务器，底层是 Socket 的一个程序，它也是 JSP 和 Serlvet 的一个容器。 为什么我们需要用到 Tomcat如果你学过 html，css，你会知道你写的页面只能自己访问，别人不能远程访问你写的页面，Tomcat 就是提供能够让别人访问自己写的页面的一个程序 配置 Tomcat运行 Tomcat 需要 JDK 的支持【Tomcat 会通过 JAVA_HOME 找到所需要的 JDK】。 新建 JAVA_HOME 环境变量【路径是 JDK 的主目录】 进入 Tomcat 目录下的 bin 中启动 startup.bat，以下是成功启动 Tomcat 的页面。 在浏览器地址栏输入 http://localhost:8080, 如果能够出现 Tomcat 页面，说明配置成功了！ 注意：如果在使用 Tomcat 时出现了Error deploying web application directory web222, 很大原因就是 jdk 和 tomcat 的版本不匹配。目前，jdk8 不能匹配 tomcat7.0，所以要降低 jdk 版本【换成 JDK7】 当然也有可能不是一帆风顺能够直接启动 Tomcat，不能正常启动 Tomcat 会有以下情况 JAVA_HOME 配置错误 端口被占用了 第一种方法：在 cmd 输入 netstat -anb 查看谁占用了该端口【Tomcat 默认的是 8080】, 在进程中关闭它 第二种方法：主动改变 tomcat 的端口, 到 tomcat 主目录下的 conf/server.xml 文件中修改, 把 8080 端口改成是 8088 或者是其他的‘ 相关术语介绍 tomcat 结构目录 目录的简单介绍 bin：启动和关闭 tomcat 的 bat 文件 conf：配置文件 server.xml该文件用于配置 server 相关的信息，比如 tomcat 启动的端口号，配置主机 (Host) web.xml文件配置与 web 应用（web 应用相当于一个 web 站点） tomcat-user.xml配置用户名密码和相关权限. lib：该目录放置运行 tomcat 运行需要的 jar 包 logs：存放日志，当我们需要查看日志的时候，可以查询信息 webapps：放置我们的 web 应用 work 工作目录：该目录用于存放 jsp 被访问后生成对应的 server 文件和. class 文件 webapps 目录的详细说明在 webapps 中建立了 web1 目录，下面放置我们的 html 文件，jsp 文件，图片等等，则 web1 就被当做 web 应用管理起来【tomcat6.0 以后的版本才支持】 例子：在 webapps 下创建一个 web 站点，在 web 站点下创建一个 html 文件，访问 html 文件 web 站点的目录是有规范的 为什么要这样设置 web 站点目录呢？ 需求：我有多个 html 文件，想把其中的一个 html 文件作为我 web 站点的首页。 如果没有 WEB-INF 目录下的 web.xml 文件支持，是无法解决我的需求的 这个规范是约定熟成的。 下面将 web 站点下的 helloword2.xml 文件作为站点的首页 新建一个 WEB-INF 目录 在 WEB-INF 目录下创建一个 web.xml web.xml 我们不可能会写，所以可以在 webapps 目录下其他的站点中抄一份过来【复制 ROOT/WEB-INF/web.xml 的文件到自己的站点中】 在 web.xml 中添加以下代码 1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;helloword2.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 访问 web 站点【helloword2.html 已经是 web 站点的首页了，所以不需要指定资源访问了】 配置虚拟目录为什么需要配置虚拟目录？ 如果把所有 web 站点的目录都放在 webapps 下，可能导致磁盘空间不够用，也不利于对 web 站点目录的管理【如果存在非常多的 web 站点目录】 把 web 站点的目录分散到其他磁盘管理就需要配置虚拟目录【默认情况下，只有 webapps 下的目录才能被 Tomcat 自动管理成一个 web 站点】 把 web 应用所在目录交给 web 服务器管理，这个过程称之为虚拟目录的映射 配置虚拟目录方法一： 在其他盘符下创建一个 web 站点目录，并创建 WEB-INF 目录和一个 html 文件。 找到 Tomcat 目录下 / conf/server.xml 文件 在 server.xml 中的 12&lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt; 访问配置好的 web 站点 配置虚拟目录方法二： 进入到 conf\Catalina\localhost 文件下，创建一个 xml 文件，该文件的名字就是站点的名字。 xml 文件的代码如下，docBase 是你 web 站点的绝对路径 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Context docBase=&quot;D:\web1&quot; reloadable=&quot;true&quot;&gt; &lt;/Context&gt; 访问 web 站点下的 html 资源 配置临时域名访问 Tomcat 服务器有好几种方式 使用 localhost 域名访问【localhost 代表本机】 使用 ip 地址 127.0.0.1 访问【该 ip 地址也是本机】 使用机器名称访问【只限用于本机上或者局域网】 使用本机 IP 地址访问【在 cmd 中输入 ipconfig 可以查询到本机 IP 地址】 还可以为机器配置临时域名 配置临时域名步骤 打开到 C:\Windows\System32\drivers\etc 下，找到 hosts 文件 在 hosts 文件下配置临时域名 设置虚拟主机什么是虚拟主机？多个不同域名的网站共存于一个 Tomcat 中 为什么需要用到虚拟主机？例子：我现在开发了 4 个网站，有 4 个域名。如果我不配置虚拟主机，一个 Tomcat 服务器运行一个网站，我就需要 4 台电脑才能把 4 个网站运行起来。 配置虚拟主机的步骤 在 tomcat 的 server.xml 文件中添加主机名 1234&lt;Host D:\web1&quot;&gt; &lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt;&lt;/Host&gt; 访问虚拟主机下的 web 站点 Tomcat 体系结构 浏览器访问 WEB 资源的流程图 练习在浏览器输入 http//:zhongfucheng 直接显示到页面 分析： 需要配置虚拟主机 把 8080 端口改成 80 设置 web 站点首页 映射虚拟目录为 / Servlet+JSP - 文集 - 简书https://www.jianshu.com/nb/21926044 参考：专栏：How Tomcat Works笔记 - CSDN博客https://blog.csdn.net/column/details/howtomcatworks.html?&amp;page=2How Tomcat Works读书笔记 - 简书https://www.jianshu.com/p/b21520f4ed69]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - Servlet 完全教程]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-3%2F</url>
    <content type="text"><![CDATA[Servlet是一种允许响应请求的 Java 类。虽然Servlet可以响应任何类型的请求，但它们通常被用来响应网络请求。一个Servlet必须部署在 Java servlet 容器中，它才能成为可用的。虽然许多开发者利用Servlet框架如 Java Server Pages (JSP) 和 Java Server Faces (JSF)，但实际上这两种技术通过 servlet 容器在幕后将页面编译为 Java servlet。也就是说，Java servlet 技术的基本知识对任何 Java web 开发都很有用。 在本教程中，我们将涵盖以下主题，从而获得 Java servlet 技术的整体认识。 目录 编写第一个Servlet Servlet的生命周期方法 使用 @WebServlet 注解开发Servlet 打包并部署Servlet到 Tomcat 服务器 在Servlet响应中写入动态内容 Servlet接受参数处理并响应 监听Servlet容器事件 给Servlet传入初始化参数 给指定的请求增加Servlet过滤器 用Servlet下载二进制文件 用 RequestDispatcher.forward() 将请求内部转发到另一个Servlet 用 HttpServletResponse.sendRedirect() 将请求重定向到另一个Servlet 用Servlet读写 cookie 让我们开始一步一步学习Servlet。 编写第一个 Servlet下面是一个非常简单的Servlet，实际上你需要写的代码代码非常少 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.bill.servlets;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyFirstServlet extends HttpServlet &#123; private static final long serialVersionUID = -1915463532411657451L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); try &#123; // Write some content out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;MyFirstServlet&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h2&gt;Servlet MyFirstServlet at &quot; + request.getContextPath() + &quot;&lt;/h2&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125; finally &#123; out.close(); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //Do some other work &#125; @Override public String getServletInfo() &#123; return &quot;MyFirstServlet&quot;; &#125;&#125; 用一个 web.xml 文件将上面的MyFirstServlet注册在 web 容器中。 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/Javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/MyFirstServlet&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bill.servlets.MyFirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MyFirstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/MyFirstServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 你可能想知道上面MyFirstServlet的完成了哪些重要的事情。 MyFirstServlet继承自HttpServlet。这是强制性的，因为所有的Servlet必须继承javax.servlet.GenericServlet或javax.servlet.http. HttpServlet。 重写了 doGet() 和 doPos() 方法。这些方法定义在HttpServlet类中。每当 GET 或 POST 请求到来时，它被映射到其各自对应的方法（例如，如果您发送一个 HTTP GET 请求，然后 servlet 的 doGet() 方法被调用。 还有一些你可以重写的其他方法，被用来控制应用程序，比如 getServletInfo()。 HttpServletRequest和HttpServletResponse是 doxxx() 方的默认参数类型。我们将在以后的章节中更多地了解这两种类型对应的对象。 这就是了解一个简单Servlet需要知道的的全部内容。 Servlet 的生命周期方法在应用程序中，每当加载并使用Servlet时会发生一系列事件，如初始化和销毁。这些被称为Servlet的生命周期事件（或方法）。让我们多了解一些关于它们的故事。 init()，service()，和 destroy() 是三个在Servlet的生命周期中至关重要的方法。它们由每个Servlet实现，并在特定时间被调用。 1）在Servlet生命周期的初始阶段，web 容器通过调用 init() 方法初始化Servlet实例，同时传入一个实现javax.servlet.ServletConfig接口的对象。这个配置对象允许Servlet访问在 web.xml 文件中定义的键值对值初始化参数。这只在Servlet实例的生命周期中调用一次。init 方法定义如下所示： 123public void init() throws ServletException &#123; //custom initialization code&#125; 2）在初始化之后，Servlet实例可以为客户请求提供服务。web 容器调用Servlet的 service() 方法处理每个请求。service 方法判断请求的种类或者将请求转发到哪个方法里处理更加合适。Servlet的开发人员必须为这些方法提供一个实现。如果Servlet未实现这个方法，那么请求将调用父类的方法处理，通常会给请求者导致返回一个错误。 几乎没有必要重写此方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123;String method = req.getMethod();if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn&apos;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125;&#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp);&#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp);&#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp);&#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp);&#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp);&#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);&#125;&#125; 3）最后，web 容器调用 destroy() 方法终止Servlet的服务。如果希望在Servlet不可用之前关闭或销毁某些文件系统或网络资源，则应该调用此方法。destory() 方法和 init() 方法一样在Servlet整个生命周期中只被调用一次。 123public void destroy() &#123; //&#125; 通常情况下，你不需要重写Servlet的这些方法。 使用 @WebServlet 注解开发 servlet如果你不是很喜欢 xml 配置，而特别喜欢注释， Servlets API 也有这样的功能。您可以使用 @WebServlet ，如下的例子，那么你不需要在 web.xml 中做任何事情。在运行时会自动将Servlet注册到容器，并像往常一样处理它。 1234567891011121314151617181920212223242526272829package com.bill.servlets;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;MyFirstServlet&quot;, urlPatterns = &#123;&quot;/MyFirstServlet&quot;&#125;)public class MyFirstServlet extends HttpServlet &#123; private static final long serialVersionUID = -1915463532411657451L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //Do some work &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //Do some other work &#125;&#125; 打包并部署 servlet 到 Tomcat 服务器如果您使用的是任何 IDE（如 Eclipse），那么打包和部署应用程序非常简单。右键单击项目 &gt; Run As &gt; Run As Server。如果尚未完成，就配置服务器，然后就完成了。如果您不使用任何 IDE，那么您需要做一些额外的工作，例如从命令提示符编译应用程序，使用 Ant 创建 WAR 文件等，但我确信现在每个人都使用一些 IDE 进行开发，所以我不会在这里浪费更多的时间。当您在 Tomcat 中部署完我们写的第一个Servlet，然后在浏览器地址栏输入 http://localhost:8080/servletexamples/MyFirstServlet，回车，你将得到下面的响应。 在 Servlet 响应中写入动态内容Servlet之所以非常用用的原因是它允许给网页内容动态的加入一些内容。内容可以从服务器本身、数据库、另一个 web 站点或许多其他可访问的 web 资源。Servlet不是静态的网页，他们是动态的，这是它们最关键的地方。 让我们以Servlet为例，它负责向用户显示当前日期和时间，以及他的名字和一些自定义消息，代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.bill.servlets;import java.io.IOException;import java.io.PrintWriter;import java.util.Date;import java.util.HashMap;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = &quot;CalendarServlet&quot;, urlPatterns = &#123;&quot;/CalendarServlet&quot;&#125;)public class CalendarServlet extends HttpServlet &#123; private static final long serialVersionUID = -1915463532411657451L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Map&lt;String,String&gt; data = getData(); response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); try &#123; // Write some content out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;CalendarServlet&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h2&gt;Hello &quot; + data.get(&quot;username&quot;) + &quot;, &quot; + data.get(&quot;message&quot;) + &quot;&lt;/h2&gt;&quot;); out.println(&quot;&lt;h2&gt;The time right now is : &quot; + new Date() + &quot;&lt;/h2&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125; finally &#123; out.close(); &#125; &#125; //This method will access some external system as database to get user name, and his personalized message private Map&lt;String, String&gt; getData() &#123; Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); data.put(&quot;username&quot;, &quot;Guest&quot;); data.put(&quot;message&quot;, &quot;Welcome to my world !!&quot;); return data; &#125;&#125; 当你在 Tomcat 中运行上面的Servlet，然后在浏览器中请求 http://localhost:8080/servletexamples/CalendarServlet，你将得到下面的响应 Servlet 接受参数处理并响应Servlet可以很容易地创建 web 应用程序，给用户的请求返回响应。它们能够提供 HTTP 响应，并在同一代码体中处理业务逻辑。用于处理业务逻辑的能力使Servlet比标准的 HTML 代码更强大。 在实际应用程序中，HTML Web 表单包含发送给Servlet的参数。然后 servlet 以某种方式处理这些参数，并给客户端返回一个响应。在一个 HttpServlet 对象的情况下，客户端是一个 web 浏览器，响应是一个网页。表单的 action 属性标签指定了谁来处理表单中所包含的参数。 调用HttpServletRequest对象的 getparameter() 方法获取请求参数，通过 id 获得你想得到的参数。 12String value1 = req.getParameter(&quot;param1&quot;);String value1 = req.getParameter(&quot;param2&quot;); 一旦获得这些值，就可以根据需要进行处理。然后为客户机返回响应，正如我们在以上章节中讨论的那样，用HttpServletResponse类型的对象给客户端返回响应。 一个基本的请求 - 处理 - 响应的流程如下： 123456789101112131415161718192021222324252627282930313233@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); boolean success = validateUser(username, password); try &#123; // Write some content out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;LoginServlet&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); if(success) &#123; out.println(&quot;&lt;h2&gt;Welcome Friend&lt;/h2&gt;&quot;); &#125;else&#123; out.println(&quot;&lt;h2&gt;Validate your self again.&lt;/h2&gt;&quot;); &#125; out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125; finally &#123; out.close(); &#125;&#125; 你需要从HttpServletResponse对象获得PrintWriter对象，给客户端返回内容。任何写入它的内容将被写入OutputStream，然后数据将被发送回客户端。 监听 Servlet 容器事件有时候知道在容器中发生的某些事件是非常有用的。这个概念在许多不同的情况下都是有用的，但大多数情况下，它可能被用于在启动时初始化，关闭时清理。一个Servlet可以在容器注册Listener，以监听它何时启动或关闭。因此，通过侦听此类事件，Servlet有机会在发生某些事件时执行某些操作。 要创建一个基于容器的事件的监听器，你必须实现一个ServletContextListener接口的类。需要实现 contextInitialized() 和 contextDestroyed() 方法。这两种方法都接受一个ServletContextEvent作为参数，并分别在每次Servlet容器初始化或关闭时被自动调用。 用给容器注册监听器，可以使用以下技术之一： 利用 @WebListener 注解。 在 web.xml 中注册监听器。 使用ServletContext的 addListener() 方法。 请注意，ServletContextListener不是 Servlet API 中的唯一监听器。还有更多，比如 javax.servlet.servletrequestlistener javax.servlet.servletrequestattrbitelistener javax.servlet.servletcontextlistener javax.servlet.servletcontextattributelistener javax.servlet.httpsessionlistener javax.servlet.httpsessionattributelistener 根据你希望监听到的事件实现你自己的监听器类，如HttpSessionListener将监听每当户创建一个新的用户Session或者销毁时的事件。 给 Servlet 传入初始化参数今天大多数应用程序需要设置一些在应用程序 / 控制器启动时传给它们配置参数。Servlet也可以在它们被第一请求的时候接受初始化参数。 显然，你可以在Servlet本身硬编码的配置，但改变任何他们需要重新编译一次整个应用程序，没有人会喜欢这样做。 1234567891011121314&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bill.servlets.SimpleServlet&lt;/servlet-class&gt; &lt;!-- Servlet init param --&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;value&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt;&lt;/web-app&gt; 一旦设置，该参数通过调用 getServletConfig().getInitializationParameter() 和传递的参数的名称来得到并使用，如下面的代码行所示： 1String value = getServletConfig().getInitParameter(&quot;name&quot;); 给指定的请求增加 Servlet 过滤器Web 过滤器对于在访问给定 URL 求之前调用某些功能，它非常有用。相比通过一个固定的 URL 请求一个Servlet，过滤器匹配一个模式的 URL，在这些 URL 对应的Servlet调用之前被调用。这在许多情况下非常有用，如日志记录、身份验证或其他服务。 过滤器必须实现javax.servlet.Filter接口。方法包含 init ()，destroy()，和 dofilter() 方法。init () 和 destroy() 方法由容器调用。dofilter() 方法被用来定义过滤器类所要完成的任务。如果你想要过滤器链，或者对应一个 URL 有多个过滤器，在 web.xml 配置文件中按顺序配置即可。 在 web.xml 配置文件中配置一个过滤器，使用 XML 的 和 &lt; filter-mapping &gt; 元素以及与它们相关的子元素标签。 12345678&lt;filter&gt; &lt;filter-name&gt;LoggingFilter&lt;/filter-name&gt; &lt;filter-class&gt;LoggingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;LogingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 如果你想使用注释来配置特定的Servlet过滤器，你可以使用 @WebFilter 注释。 用 Servlet 下载二进制文件下载文件是几乎所有 web 应用程序的基本任务。要下载文件，Servlet必须提供与下载文件匹配的相同类型的响应，它还必须在响应标头中指出要包含附件，如下所示。 123String mimeType = context.getMimeType( fileToDownload );response.setContentType( mimeType != null ? mimeType : &quot;text/plain&quot; );response.setHeader( &quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + fileToDownload + &quot;\&quot;&quot; ); 你可以通过给ServletContext的 getResourceAsStream() 方法传一个路径，获得一个你需要下载 (被存在服务器的文件系统中) 的文件的引用。这将返回一个InputStream对象可以用来读取文件内容。然后创建一个字节缓冲区，用于读取文件时从文件中获取数据块。最后真正的任务是读取文件内容并将它们复制到输出流中。这是通过使用一个 while 循环，这将不断读取InputStream直到文件结束。使用循环将数据块读入并写入输出流。在这之后，ServletOutputStream 对象 flush 方法被调用，来清除内容和释放资源。 让我们看示例代码 1234567891011121314151617181920212223private void downloadFile(HttpServletRequest request, HttpServletResponse response, String fileToDownload) throws IOException &#123; final int BYTES = 1024; int length = 0; ServletOutputStream outStream = response.getOutputStream(); ServletContext context = getServletConfig().getServletContext(); String mimeType = context.getMimeType( fileToDownload ); response.setContentType( mimeType != null ? mimeType : &quot;text/plain&quot; ); response.setHeader( &quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + fileToDownload + &quot;\&quot;&quot; ); InputStream in = context.getResourceAsStream(&quot;/&quot; + fileToDownload); byte[] bbuf = new byte[BYTES]; while ((in != null) &amp;&amp; ((length = in.read(bbuf)) != -1)) &#123; outStream.write(bbuf, 0, length); &#125; outStream.flush(); outStream.close(); &#125; 用 RequestDispatcher.forward() 将请求内部转发到另一个 servlet有时，你的应用程序需要一个Servlet完成部分任务，然后让其他 servlet 完成剩下的任务。此外，请求应该在不将客户机重定向到另一个 URL 的情况下进行传递，即浏览器中的 URL 不应更改。 调用ServletContext对象 getRequestDispatcher () 方法获得RequestDispatcher对象，这个对象可以被用来内部转发。getRequestDispatcher () 调用方法时，传递一个字符串包含要把请求的Servlet的名字。通过将HttpServletRequest和HttpServletResponse传给RequestDispatcher的对象，然后调用 forword() 方法。然后内部转发到另一个Servlet 12RequestDispatcher rd = servletContext.getRequestDispatcher(&quot;/NextServlet&quot;);rd.forward(request, response); 用 HttpServletResponse.sendRedirect() 将请求转发到另一个 servlet尽管有时正如我们在上一节中看到的您不愿意通知用户，Servlet重定向已经发生，但在某些场景中，我们实际上希望用户知道。当访问应用程序中的特定 URL 时，您希望重定向浏览器到另一个 URL。 要做到这一点，你需要调用 HttpServletResponse 对象的 sendRedirect() 方法。这个简单的重定向不会把 HttpReuest 的对象在 servlet 链条中传递。 用 Servlet 读写 Cookie许多应用程序希望将用户浏览历史的当前状态存储在客户机中，以便当用户再次返回应用程序时，他从离开的位置开始。通常，对于这个要求，使用cookie。您可以将cookie视为存储在客户机上的键值对数据。当从浏览器中发出请求时，浏览器可以读取或写入这些值。 简单地实例化一个新的Javax.servlet.http.Cookie类创建一个cookie对象。一旦实例化了cookie，就可以设置属性，这将有助于配置cookie。在下面例子中，cookie的 setMaxAge() 和 setHttpOnly() 方法被调用，设置cookie的有效期并防止客户端脚本访问。 由于 Servlet 3.0 API, 将cookie标记为 HTTP。这使得cookie可以防止客户端脚本攻击，使cookie更加安全。 1234Cookie cookie = new Cookie(&quot;sessionId&quot;,&quot;123456789&quot;);cookie.setHttpOnly(true);cookie.setMaxAge(-30);response.addCookie(cookie); 这里的response对象是传给 doXXX() 方法中的参数。 要从服务端获得cookie信息，请使用以下代码： 123456Cookie[] cookies = request.getCookies();for(Cookie cookie : cookies)&#123; //cookie.getName(); //cookie.getValue()&#125; 这就是本教程关于Servlet的所有技术。欢迎评论 / 反馈。 Happy Learning !! 参考：Java - Servlet完全教程 - 简书https://www.jianshu.com/p/e0471ce1b106]]></content>
      <tags>
        <tag>Java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程总结]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-2%2F</url>
    <content type="text"><![CDATA[本文主要是自己在网络编程方面的学习总结，先主要介绍计算机网络方面的相关内容，包括计算机网络基础，OSI 参考模型，TCP/IP 协议簇，常见的网络协议等等，在此基础上，介绍 Java 中的网络编程。 123456789101112一、概述二、计算机网络 1.网络协议 2.网络体系结构三、OSI参考模型四、TCP/IP参考模型五、常见网络协议 1.TCP协议 2.UDP协议 3.HTTP协议六、计网常见问题七、Java网络编程 一、概述计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来，实现资源共享和数据传输的系统。网络编程就就是编写程序使联网的两个 (或多个) 设备 (例如计算机) 之间进行数据传输。Java 语言对网络编程提供了良好的支持，通过其提供的接口我们可以很方便地进行网络编程。下面先对网络编程的一些基础知识进行介绍，最后给出使用 Java 语言进行网络编程的实例。 二、计算机网络计算机网络 20 世纪 60 年代出现，经历了 20 世纪 70 年代、80 年代和 90 年代的发展，进入 21 世纪后，计算机网络已经成为信息社会的基础设施，深入到人类社会的方方面面，与人们的工作、学习和生活息息相关。 网络协议 如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间能够进行相互通信是因为它们都共同遵守一定的规则，即网络协议。 网络体系结构 计算机网络是个复杂的系统，按照人们解决复杂问题的方法，把计算机网络实现的功能分到不同的层次上，层与层之间用接口连接。通信的双方具有相同的层次，层次实现的功能由协议数据单元 (PDU) 来描述。不同系统中的同一层构成对等层，对等层之间通过对等层协议进行通信，理解彼此定义好的规则和约定。 计算机网络体系结构是计算机网络层次和协议的集合，网络体系结构对计算机网络实现的功能，以及网络协议、层次、接口和服务进行了描述，但并不涉及具体的实现。接口是同一节点内相邻层之间交换信息的连接处，也叫服务访问点 (SAP)。 三、OSI 参考模型前面我们介绍了计算机网络的体系结构，因为计算机网络是个复杂的系统，所以把计算机网络实现的功能分到不同的层次上，而计算机网络体系结构是计算机网络层次和协议的集合。那么，计算机网络如何进行分层呢？下面先介绍的是 OSI 参考模型。 简介 世界上第一个网络体系结构由 IBM 公司提出（1974 年，SNA），以后其他公司也相继提出自己的网络体系结构如：Digital 公司的 DNA，美国国防部的 TCP/IP 等，多种网络体系结构并存，其结果是若采用 IBM 的结构，只能选用 IBM 的产品，只能与同种结构的网络互联。 为了促进计算机网络的发展，国际标准化组织 ISO 于 1977 年成立了一个委员会，在现有网络的基础上，提出了不基于具体机型、操作系统或公司的网络体系结构，称为开放系统互连参考模型，即 OSI/RM (Open System Interconnection Reference Model)。OSI 模型把网络通信的工作分为 7 层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 OSI 模型层次功能 物理层 物理层处于 OSI 的最底层，是整个开放系统的基础。物理层涉及通信信道上传输的原始比特流 (bits)，它的功能主要是为数据端设备提供传送数据的通路以及传输数据。 数据链路层 数据链路层的主要任务是实现计算机网络中相邻节点之间的可靠传输，把原始的、有差错的物理传输线路加上数据链路协议以后，构成逻辑上可靠的数据链路。需要完成的功能有链路管理、成帧、差错控制以及流量控制等。其中成帧是对物理层的原始比特流进行界定，数据链路层也能够对帧的丢失进行处理。 网络层 网络层涉及源主机节点到目的主机节点之间可靠的网络传输，它需要完成的功能主要包括路由选择、网络寻址、流量控制、拥塞控制、网络互连等。 传输层 传输层起着承上启下的作用，涉及源端节点到目的端节点之间可靠的信息传输。传输层需要解决跨越网络连接的建立和释放，对底层不可靠的网络，建立连接时需要三次握手，释放连接时需要四次挥手。 会话层和表示层 会话层的主要功能是负责应用程序之间建立、维持和中断会话，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工 3 种不同的通信方式，使系统和服务之间有序地进行通信。 表示层关心所传输数据信息的格式定义，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。 应用层 应用层为 OSI 的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。 四、TCP/IP 参考模型OSI 参考模型的初衷是提供全世界范围的计算机网络都要遵循的统一标准，但是由于存在模型和协议自身的缺陷，迟迟没有成熟的产品推出。TCP/IP 协议在实践中不断完善和发展取得成功，作为网络的基础，Internet 的语言，可以说没有 TCP/IP 协议就没有互联网的今天。 简介 TCP/IP，即 Transmission Control Protocol/Internet Protocol 的简写，中译名为传输控制协议 / 因特网互联协议，是 Internet 最基本的协议、Internet 国际互联网络的基础。 TCP/IP 协议是一个开放的网络协议簇，它的名字主要取自最重要的网络层 IP 协议和传输层 TCP 协议。TCP/IP 协议定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。TCP/IP 参考模型采用 4 层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求，这 4 个层次分别是：网络接口层、互联网层 (IP 层)、传输层 (TCP 层)、应用层。 TCP/IP 模型层次功能 网络接口层 TCP/IP 协议对网络接口层没有给出具体的描述，网络接口层对应着物理层和数据链路层。 互联网层 (IP 层) 互联网层是整个 TCP/IP 协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。互联网层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，互联网层还需要完成拥塞控制的功能。 传输层 (TCP 层) TCP 层负责在应用进程之间建立端到端的连接和可靠通信，它只存在与端节点中。TCP 层涉及两个协议，TCP 和 UDP。其中，TCP 协议提供面向连接的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等。UDP 协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中。 应用层 应用层为 Internet 中的各种网络应用提供服务。 五、常见网络协议上面主要介绍了 OSI 参考模型和 TCP/IP 模型的相关内容，从下面这张图可以看出 TCP/IP 协议簇中不同的层次中有着很多不同的网络协议，下面主要介绍传输层的 TCP、UDP 协议和应用层的 HTTP 协议。 TCP 协议 简介 TCP（Transmission Control Protocol ，传输控制协议）是面向连接的传输层协议。TCP 层是位于 IP 层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换。TCP 协议采用字节流传输数据。 TCP 报文段格式 TCP 报文段包括协议首部和数据两部分，协议首部的固定部分有 20 个字节，首部的固定部分后面是选项部分。 下面是报文段首部各个字段的含义。 源端口号以及目的端口号，各占 2 个字节，端口是传输层和应用层的服务接口，用于寻找发送端和接收端的进程，一般来讲，通过端口号和 IP 地址，可以唯一确定一个 TCP 连接，在网络编程中，通常被称为一个 socket 接口。 序号，占 4 字节，用来标识从 TCP 发送端向 TCP 接收端发送的数据字节流。 确认序号，占 4 字节，包含发送确认的一端所期望收到的下一个序号，因此，确认序号应该是上次已经成功收到数据字节序号加 1. 数据偏移，占 4 位，用于指出 TCP 首部长度，若不存在选项，则这个值为 20 字节，数据偏移的最大值为 60 字节。 保留字段占 6 位，暂时可忽略，值全为 0 标志位URG（紧急） : 为 1 时表明紧急指针字段有效ACK（确认）：为 1 时表明确认号字段有效PSH（推送）：为 1 时接收方应尽快将这个报文段交给应用层RST（复位）：为 1 时表明 TCP 连接出现故障必须重建连接SYN（同步）：在连接建立时用来同步序号FIN （终止）： 为 1 时表明发送端数据发送完毕要求释放连接 接收窗口占 2 个字节，用于流量控制和拥塞控制，表示当前接收缓冲区的大小。在计算机网络中，通常是用接收方的接收能力的大小来控制发送方的数据发送量。TCP 连接的一端根据缓冲区大小确定自己的接收窗口值，告诉对方，使对方可以确定发送数据的字节数。 校验和占 2 个字节，范围包括首部和数据两部分。 选项是可选的，默认情况是不选。 三次握手与四次挥手 TCP 是面向连接的协议，因此每个 TCP 连接都有 3 个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为 “三次握手”。 TCP 三次握手过程如下： 第一次握手客户机发送连接请求报文段到服务器，并进入 SYN_SENT 状态，等待服务器确认。（SYN = 1,seq=x） 第二次握手服务器收到连接请求报文，如果同意建立连接，向客户机发回确认报文段，并为该 TCP 连接分配 TCP 缓存和变量。(SYN=1,ACK=1,seq=y,ack=x+1)。 第三次握手客户机收到服务器的确认报文段后，向服务器给出确认报文段，并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。(ACK=1,seq=x+1,ack=y+1)。 TCP 四次挥手过程如下： 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP 客户端发送一个 FIN，用来关闭客户到服务器的数据传送。 服务器收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。 服务器关闭客户端的连接，发送一个 FIN 给客户端。 客户端发回 ACK 报文确认，并将确认序号设置为收到序号加 1。 UDP 协议 简介 UDP，用户数据报协议，英文全称是 User Datagram Protocol，它是 TCP/IP 协议簇中无连接的运输层协议。 UDP 协议格式 从图中可以看到，UDP 协议十分简单，它由两部分组成：首部和数据。其中，首部仅有 8 个字节，包括源端口和目的端口，长度（UDP 用于数据报的长度）、校验和。 HTTP 协议 简介 HTTP，超文本传输协议，英文全称是 Hypertext Transfer Protocol，它是互联网上应用最为广泛的一种网络协议。HTTP 是一种应用层协议，它是基于 TCP 协议之上的请求 / 响应式的协议，即一个客户端与服务器建立连接后，向服务器发送一个请求；服务器接到请求后，给予相应的响应信息。HTTP 协议默认的端口号为 80. 现在使用的 HTTP 协议是 HTTP/1.1 版本，1997 年之前采用的是 HTTP1.0 版本。HTTP 连接在 1.0 版本中采用非持续连接工作方式，1.1 版本采用的是持续连接工作方式，持续连接是指服务器在发送响应后仍然在一段时间内保持这条由 TCP 运输层协议建立起来的连接，使客户机和服务器可以继续在这条连接上传输 HTTP 报文。 是否采用持续连接工作方式，1.0 中默认是关闭的，需要在 HTTP 头加入 “Connection:Keep-Alive”，才能启用 Keep-Alive。HTTP1.1 中默认启用 Keep-Alive，如果加入 “Connection:close”，才关闭。目前大部分浏览器都是用 HTTP1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep- Alive 连接就看服务器设置情况。 HTTP 报文 HTTP 协议是基于 TCP 协议之上的请求 / 响应式协议，下面主要介绍 HTTP 报文的格式，HTTP 报文主要有请求报文和响应报文两种。首先看请求报文的格式： HTTP 请求报文由请求行、首部行和实体主体组成，由浏览器发送给服务器。上面这张图中 SP 表示空格，cr lf 表示回车和换行。 上面这张图是 HTTP 响应报文，它由状态行、首部行和实体主体组成。下面两张图是在谷歌浏览器内访问服务器查看的 HTTP 请求和响应。 HTTP 请求方法和响应状态码 在上面的 HTTP 请求报文例子中，我们可以看到请求方法是 GET，这表示请求读取由 URL 所标志的信息，除了 GET，还有其它几种常用的方法。 在 HTTP 响应报文的例子中，我们可以看到状态码是 200，表示响应成功。下表是其它状态码，总共 5 大类，33 种。 HTTPS 和 HTTP 的区别 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。它是一个 URI scheme（抽象标识符体系），句法类同 http: 体系。用于安全的 HTTP 数据传输。https:URL 表明它使用了 HTTP，但 HTTPS 存在不同于 HTTP 的默认端口及一个加密 / 身份验证层（在 HTTP 与 TCP 之间）。 超文本传输协议 HTTP 协议被用于在 Web 浏览器和网站服务器之间传递信息。HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此 HTTP 协议不适合传输一些敏感信息，比如信用卡号、密码等。 为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS。为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS 和 HTTP 的区别主要为以下四点：1、https 协议需要到 ca 申请证书，一般免费证书很少，需要交费。2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 六、常见问题到这里，关于计算机网络部分的总结内容就结束了，下面是几个常见的问题，汇总在这里。 OSI 参考模型的分为哪几层，每层的功能？OSI，开放系统互连参考模型，它的 7 个层次自顶到下依次为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。各层的功能见文章开始。 TCP 协议和 UDP 协议的区别？TCP 协议是传输控制协议，UDP 协议是用户数据报协议，两者都是传输层的协议，主要区别在于前者是可靠的，面向连接的协议，后者是不可靠的，无连接的协议。其它的区别还有，TCP 协议传输速度慢，UDP 常用于一次性传输比较少量数据的网络应用。 TCP 三次握手为什么不能是两次?主要是防止两次握手情况下已经失效的连接请求报文段突然又传送到服务端而产生错误。例如，客户机 A 向服务器 B 发送 TCP 连接请求，第一个连接请求报文在网络的某个节点长时间滞留，A 超时后认为报文丢失，于是再重传一次连接请求，B 收到后建立连接。数据传输完毕后双方断开连接，而这时之前滞留的连接请求到达了服务端 B，而 B 认为 A 又发来连接请求。如果两次握手建立连接，A 并无连接请求，造成 B 的资源浪费。 HTTP 请求的 GET 方法和 POST 方法的区别？GET 和 POST 是 HTTP 请求的两种方法，主要区别在于 GET 方法是请求读取由 URL 所标志的信息，POST 是给服务器添加信息。点击查看更多 在浏览器中输入网址到显示出页面的整个过程？(1) 输出包含域名的网址 (2) 浏览器向 DNS 请求解析域名对应的 IP 地址 (3) 域名系统 DNS 解析出域名对应的 IP 地址 (4) 浏览器与该服务器建立 TCP 连接 (5) 浏览器发送 HTTP 请求 (6) 服务器通过 HTTP 响应把页面文件发送给浏览器 (7) TCP 连接释放 (8) 浏览器解释文件，并显示 七、Java 网络编程Java 的网络编程主要涉及到的内容是 Socket 编程，那么什么是 Socket 呢？简单地说，Socket，套接字，就是两台主机之间逻辑连接的端点。TPC/IP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协议，主要解决如何包装数据。Socket，本质上就是一组接口，是对 TCP/IP 协议的封装和应用 (程序员层面上)。 整体流程 Socket 编程主要涉及到客户端和服务器端两个方面，首先是在服务器端创建一个服务器套接字 (ServerSocket)，并把它附加到一个端口上，服务器从这个端口监听连接。端口号的范围是 0 到 65536，但是 0 到 1024 是为特权服务保留的端口号，我们可以选择任意一个当前没有被其他进程使用的端口。 客户端请求与服务器进行连接的时候，根据服务器的域名或者 IP 地址，加上端口号，打开一个套接字。当服务器接受连接后，服务器和客户端之间的通信就像输入输出流一样进行操作。 实例一 下面是一个客户端和服务器端进行数据交互的简单例子，客户端输入正方形的边长，服务器端接收到后计算面积并返回给客户端，通过这个例子可以初步对 Socket 编程有个把握。 服务器端 1234567891011121314151617181920212223242526272829303132public class SocketServer &#123; public static void main(String[] args) throws IOException &#123; // 端口号 int port = 7000; // 在端口上创建一个服务器套接字 ServerSocket serverSocket = new ServerSocket(port); // 监听来自客户端的连接 Socket socket = serverSocket.accept(); DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); do &#123; double length = dis.readDouble(); System.out.println(&quot;服务器端收到的边长数据为：&quot; + length); double result = length * length; dos.writeDouble(result); dos.flush(); &#125; while (dis.readInt() != 0); socket.close(); serverSocket.close(); &#125;&#125; 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SocketClient &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; int port = 7000; String host = &quot;localhost&quot;; // 创建一个套接字并将其连接到指定端口号 Socket socket = new Socket(host, port); DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); Scanner sc = new Scanner(System.in); boolean flag = false; while (!flag) &#123; System.out.println(&quot;请输入正方形的边长:&quot;); double length = sc.nextDouble(); dos.writeDouble(length); dos.flush(); double area = dis.readDouble(); System.out.println(&quot;服务器返回的计算面积为:&quot; + area); while (true) &#123; System.out.println(&quot;继续计算？(Y/N)&quot;); String str = sc.next(); if (str.equalsIgnoreCase(&quot;N&quot;)) &#123; dos.writeInt(0); dos.flush(); flag = true; break; &#125; else if (str.equalsIgnoreCase(&quot;Y&quot;)) &#123; dos.writeInt(1); dos.flush(); break; &#125; &#125; &#125; socket.close(); &#125;&#125; 实例二 可以看到上面的服务器端程序和客户端程序是一对一的关系，为了能让一个服务器端程序能同时为多个客户提供服务，可以使用多线程机制，每个客户端的请求都由一个独立的线程进行处理。下面是改写后的服务器端程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class SocketServerM &#123; public static void main(String[] args) throws IOException &#123; int port = 7000; int clientNo = 1; ServerSocket serverSocket = new ServerSocket(port); // 创建线程池 ExecutorService exec = Executors.newCachedThreadPool(); try &#123; while (true) &#123; Socket socket = serverSocket.accept(); exec.execute(new SingleServer(socket, clientNo)); clientNo++; &#125; &#125; finally &#123; serverSocket.close(); &#125; &#125;&#125;class SingleServer implements Runnable &#123; private Socket socket; private int clientNo; public SingleServer(Socket socket, int clientNo) &#123; this.socket = socket; this.clientNo = clientNo; &#125; @Override public void run() &#123; try &#123; DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); do &#123; double length = dis.readDouble(); System.out.println(&quot;从客户端&quot; + clientNo + &quot;接收到的边长数据为：&quot; + length); double result = length * length; dos.writeDouble(result); dos.flush(); &#125; while (dis.readInt() != 0); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;与客户端&quot; + clientNo + &quot;通信结束&quot;); try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面改进后的服务器端代码可以支持不断地并发响应网络中的客户请求。关键的地方在于多线程机制的运用，同时利用线程池可以改善服务器程序的性能。 参考：Java - 网络编程完全总结 - 简书https://www.jianshu.com/p/ae5e1cee5b04]]></content>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现Tomcat]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27-1%2F</url>
    <content type="text"><![CDATA[跟我一起动手实现 Tomcat（一）: 实现静态 Web 服务器前言1最近笔者读了《深入剖析tomcat》这本书（原作：《how tomcat works》）,发现该书简单易读，每个章节循序渐进的讲解了tomcat的原理，在接下来的章节中，tomcat都是基于上一章新增功能并完善，到最后形成一个简易版tomcat的完成品。所以有兴趣的同学请按顺序阅读，本文为记录第一章的知识点以及源码实现（造轮子）。 如何实现HTTP 协议就是咱们 web 服务器与浏览器交互的协议，具体的知识点以及背景本文就不再累述。那么举一个简单的例子就好： 在浏览器输入 http://www.baidu.com 按下回车键。 浏览器大概发送了以下的 http 请求到百度的服务器中： 123GET /index.html HTTP/1.1Host: www.baidu.com... 百度 web 服务器在接收到我们的请求的时候，找到对应的服务器资源并相应： 1234567891011HTTP/1.1 200 OK... &lt;html&gt; &lt;head&gt; &lt;title&gt;百度一下你就知道&lt;/title&gt; &lt;/head&gt; &lt;body&gt; .... &lt;/body&gt;&lt;/html&gt; 那么其实通过上面的例子我们可以发现，静态 (这里指的是 html / 图片 / css 等)web 服务器的实现也是比较简单的： 代码实现1在这里使用java socket api 实现简单的静态web服务器。 新建一个 main 方法，核心伪代码如下： 1//开启socket server 8080端口监听. ServerSocket server = new ServerSocket(8080, 1, InetAddress.getByName(&quot;127.0.0.1&quot;));try (Socket accept = serverSocket.accept(); InputStream inputStream = accept.getInputStream(); OutputStream outputStream = accept.getOutputStream()) &#123; //解析用户的请求 Request request = new Request(); request.setRequestStream(inputStream); request.parseRequest(); //生成响应对象并响应静态资源 Response resp = new Response(outputStream, request); resp.accessStaticResources();&#125; catch (IOException e) &#123; LOGGER.warn(&quot;catch from user request.&quot;,e);&#125;//关闭服务器serverSocket.close(); Request 对象 1主要功能：将用户请求（socket的inputStream流）解析为字符串，提取请求中的URI 解析字符串代码如下： 1StringBuilder requestStr = new StringBuilder();int i;//new 一个 byte缓冲数组byte[] buffer = ArrayUtil.generatorCache();try &#123; i = inputStream.read(buffer);&#125; catch (IOException e) &#123; e.printStackTrace(); i = -1;&#125;//将读取到的byte转为Stringfor (int j = 0; j &lt; i; j++) &#123; requestStr.append((char) buffer[j]);&#125;//解析请求的字符串，提取请求的URIthis.parseURI(requestStr.toString()); 那么请求的信息被我们解析成字符串了，我们怎么知道他想请求什么静态资源呢？ 那我们把解析字符串打印一下: 1System.out.println(requestStr.toString()); GET /index.html HTTP/1.1Host: 127.0.0.1:8080Connection: keep-aliveCache-Control: max-age=0User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36Upgrade-Insecure-Requests: 1Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9 可以很明显的看到，加粗的地方就是我们要提取的 URI，那么怎么提取呢？细心的我们发现了，/index.html 这段字符串前后都有一个空格！行，那我们可以直接用 String 的 indexOf 方法解析，参考代码如下： 1// 获取/index.html 前面的那个空格索引int oneSpace = requestStr.indexOf(&quot; &quot;);//获取/index.html 后面的那个空格索引int twoSpace = requestStr.indexOf(&quot; &quot;, oneSpace + 1);//截取获得用户请求URIuri = requestStr.substring(oneSpace + 1, twoSpace); Response 对象 1上面Request对象已经把用户想请求的资源解析出来了，那么Response的功能就是找到这个文件，使用Socket的outputStream把文件作为字节流输出给浏览器，就可以将我们的HTML显示给用户啦~ 那么这个项目我们的静态文件放在那里呢？来看看我们的项目结构： 1-main -java java代码 -resources -webroot 存放我们静态资源的文件夹 因为是只使用 MAVEN 构建项目，我们也没使用 Spring 等框架，如何定位到 webroot 这个文件夹呢？参考了网上的代码： 1String WEB_PROJECT_ROOT = HttpServer.class.getClassLoader().getResource(&quot;webroot&quot;).getFile().substring(1); 前面的疑惑都解决了，接下来我们就直接把对应的文件找到给写回去就完事了~伪码如下： 1//根据请求URI找到用户对应请求的资源文件File staticResource = new File(HttpServer.WEB_PROJECT_ROOT + request.getUri());//资源存在if (staticResource.exists() &amp;&amp; staticResource.isFile()) &#123; outputStream.write(this.responseToByte(200,&quot;OK&quot;)); write(staticResource);//资源不存在，使用默认的404返回&#125; else &#123; staticResource = new File(HttpServer.WEB_PROJECT_ROOT + &quot;/404.html&quot;); outputStream.write(this.responseToByte(404,&quot;file not found&quot;)); write(staticResource);&#125; 其中，responseToByte() 这个方法只负责将响应行输出： 1HTTP/1.1 200 OK 资源不存在时咱们就输出： 1HTTP/1.1 404 file not found write() 方法也很简单，将传入的 file 对象转成流并使用 socket 的 outputStream 输出 1try (FileInputStream fis = new FileInputStream(file)) &#123; byte[] cache = new byte[1024]; int read; while ((read = fis.read(cache, 0, 1024)) != -1) &#123; outputStream.write(cache, 0, read); &#125;&#125; 看看效果运行 main 方法，打开我们的浏览器输出 127.0.0.1/index.html 按下回车，可以看到结果如图： 试试随便输入一个不存在的资源：按下 F12 看看 Http 请求和响应分别是怎样的： 1请求：GET /abc.html HTTP/1.1Host: 127.0.0.1:8080其他请求头忽略...响应：HTTP/1.1 404 file not found&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;404 not found!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;请求页面不存在！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 到这里，咱们的 Tomcat 1.0 web 服务器就已经开发完成啦（滑稽脸），已经可以实现简单的 html 和 css、图片等资源的访问等功能，下一章咱们来实现以下简单的 Servlet 容器功能开发： PS：本章源码已上传 github SimpleTomcat 跟我一起动手实现 Tomcat（二）: 实现简单的 Servlet 容器前言1章节循序渐进的讲解了tomcat的原理，在接下来的章节中，tomcat都是基于上一章新增功能并完善，到最后形成一个简易版tomcat的完成品。所以有兴趣的同学请按顺序阅读，本文为记录第二章的知识点以及源码实现（造轮子）。 内容回顾跟我一起动手实现 Tomcat（一）: 实现静态 Web 服务器上一章我们实现了简单的静态资源 web 服务器，能够读取到用户自定义的 HTML/css/js / 图片并显示到浏览器以及 404 页面的展示等。 本章内容本章会实现简单的 Servlet 容器，能够根据用户请求 URI 调用对应的 Servlet 的 service() 方法并执行，init()/destory() 方法和 HttpServletRequest/HttpServletResponse 里面的大部分方法本章仍未实现，会在下面的几章逐步完善。 开始之前 javax.servlet.Servlet 1咱们web开发的同学都知道，刚学习web开发的时候都是先实现这个Servlet接口去自定义自己的Servlet类的，那么在这里简单的回顾一下Servlet这个接口。 项目加个依赖： 1&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt; Servlet 接口方法一览（具体方法干嘛的大家应该都懂了，就不介绍了）： 1public interface Servlet &#123; public void init(ServletConfig config) throws ServletException; public ServletConfig getServletConfig(); public void service(ServletRequest req, ServletResponse res)throws ServletException, IOException; public String getServletInfo();public void destroy();&#125; 如何实现 在这里基于上一章的代码，只要用户输入 127.0.0.1:8080/servlet/{servletName}，我们就将这个 URI 提取出具体的 servlet 名字，使用 java.net 包下的 URLClassLoader 将这个 Servlet 类加载并实例化，然后调用它的 service() 方法，一次 Servlet 调用就这样完成啦，是不是很简单呢，来让我们看看代码怎么去实现！！！ 代码实现1. 实现相应的接口 我们先把上个章节的 Request、Response 分别实现 ServletRequest、ServletResponse 接口（这是 Servlet 规范），具体实现的方法咱们什么都不做，等以后再完善。 1public class Request implements ServletRequest &#123; ...省略N个方法&#125;public class Response implements ServletResponse &#123; /*Response只实现这个方法，把我们socket的outputStream封装成一个PrintWriter*/ @Override public PrintWriter getWriter() throws IOException &#123; PrintWriter writer = new PrintWriter(outputStream,true); return writer; &#125;&#125; 2. 不同资源使用不同的执行器 我们的 tomcat 准备要支持 servlet 调用了，那么 servlet 和普通静态资源不一样，那么我们在代码层面应该将他们隔离开来，以方便日后的扩展，在这里我们实现以下两个执行器： 1- ServletProcess 专门执行Servlet的执行器 - StaticResourceProcess 执行静态资源的执行器 那么我们看看我们现在一个请求的执行流程： 好吧其实大家可以看到，跟以前变化也不是很大，只是多了个 if 判断，然后把相应的执行过程丢到执行器里面去执行而已~ 那我们来看看对应的实现： HttpServer 大家应该还记得 HttpServer 吧，是我们启动程序的主入口以及 ServerSocket 监听实现。它的改动不大，只是加了个 if 判断： 1public static void main(String[] args) &#123; ServerSocket serverSocket = new ServerSocket(8080, 1, InetAddress.getByName(&quot;127.0.0.1&quot;)); .... //解析用户的请求 Request request = new Request(); request.setRequestStream(inputStream); request.parseRequest(); //生成相应的响应 Response response = new Response(outputStream, request); //根据URI调用不同的处理器处理请求 if (request.getUri().startsWith(&quot;/servlet/&quot;)) &#123; new ServletProcess().process(request, response); &#125; else &#123; new StaticResourceProcess().process(request, response); &#125; ...&#125; StaticResourceProcess StaticResourceProcess 也没干啥，只是调用了上个章节读取静态资源的方法 1public class StaticResourceProcess &#123; public void process(Request request, Response response) throws IOException &#123; response.accessStaticResources(); &#125;&#125; ServletProcess ServletProcess 持有了一个 URLClassLoader 静态变量，专门用来加载 Servlet： 1private static final URLClassLoader URL_CLASS_LOADER;static &#123; /*定位到我们的webroot/servlet/文件夹*/ URL servletClassPath = new File(HttpServer.WEB_ROOT, &quot;servlet&quot;).toURI().toURL(); //初始化classloader URL_CLASS_LOADER = new URLClassLoader(new URL[]&#123;servletClassPath&#125;);&#125; 现在我们知道以 / servlet / 开头的 URI 请求是需要调用 Servlet 资源的，那么我们怎么提取 Servlet 的名字并初始化呢？先来看看一个 URI： 1/servlet/TestServlet 好像也不是很难提取，直接用 String 的 lastIndexOf 和 substring 方法就可以搞定啦： 1uri = uri.substring(uri.lastIndexOf(&quot;/&quot;) + 1); 前面的难题也都解决了，那么我们看看 process 是怎么执行的： 1public void process(Request request, Response response) throws IOException &#123; //就是上面的那个字符串截取方法 String servletName = this.parseServletName(request.getUri()); //使用URLClassLoader加载这个Servlet并实例化 Class servletClass = = URL_CLASS_LOADER.loadClass(servletName); Servlet servlet = (Servlet) servletClass.newInstance(); response.getWriter().println(new String(response.responseToByte(HttpStatusEnum.OK))); //调用servlet的service方法 servlet.service(request,response);&#125; 大家可能不太理解倒数第二行的代码，它就是调用了 Response.PrintWriter(我们刚才上面用 socket 的 outputStream 封装的) 对象向浏览器输出了一个响应头（不这么做傲娇的 chrome 会认为这个响应是无效的，servlet 回显的内容就看不到了 ServletProcess 大致调用流程： 3. 准备一个自定义 Servlet 我们 Servlet 容器也算开发完成了，我们搞一个 servlet 做做实验吧~ 1public class TestServlet implements Servlet &#123; public void init(ServletConfig config) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(&quot;Start invoke TestServlet ... &quot;); res.getWriter().println(&quot;Hello Servlet!&quot;); &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123; &#125;&#125; 它只是在控制台输出一个记录以及向浏览器回显一句话（是不是觉得不能处理参数很无聊，下面几章我们就会实现它），把这个类编译成 class 文件，丢到我们 resource/webroot/servlet 文件夹下，打开浏览器走一波： 搞定！不对… 其实上面的设计是有很严重的缺陷的 加强 Request、Response 安全性 缺陷在哪里 细心的哥们肯定发现了：我们在 ServletProcess 调用用户自定义的 servlet 的时候，是直接将 Request/Response 作为参数传入用户的 service 方法中 (因为我们的 reuqest、response 实现了 ServletRequest、ServletResponse 接口)，那么如果我们的这个 tomcat 拿去发布给其他人使用的时候，阅读过我们的 tomcat 源码的人的 servlet 就可以这样写: 1public class TestServlet &#123; public void service(HttpServletRequest request,HttpServletResponse response)&#123; ((Request)request).parseRequest(&quot;&quot;); ((Response)response).accessStaticResources(); &#125;&#125; 上面那两个方法我们设计时是提供我们 process 或者其他时候使用的 (所以方法不能设置为 private)，并不是提供给用户调用的，这就破坏了封装性了！！ 解决方案 有看过或者阅读过 Tomcat 源码的时候，发现 Tomcat 已经用了一种设计模式去解决这个缺陷了，就是外观设计模式 (门面设计模式)，具体设计模式大家可以去搜索了解一下，在这里我们也引用这种设计模式处理这个缺陷，UML 类图关系如下：代码也很简单都是调用内部 request 对象的相应方法： 1public class RequestFacade implements ServletRequest&#123; private Request request; @Override public Object getAttribute(String name) &#123; return request.getAttribute(name); &#125; 其他实现的方法也类似...&#125; 在 ServletProcess 方法调用 servlet 时我们用 Facade 类包装一下： 1...Servlet servlet = (Servlet) servletClass.newInstance();servlet.service(new RequestFacade(request), new ResponseFacade(response));... 就此大功告成！ 1使用者顶多只能将ServletRequest/ServletResponse向下转型为RequestFacade/ResponseFacade 但是我们没提供getReuqest()/getResponse()方法，所以它能调用的方法还是相应ServletRequest、ServletResponse接口定义的方法，这样我们内部的方法就不会被用户调用到啦~ 到这里，咱们的 Tomcat 2.0 web 服务器就已经开发完成啦（滑稽脸），已经可以实现简单的自定义 Servlet 调用，但是很多功能仍未完善： 1- 每一次请求就new一次Servlet，Servlet应该在初始化项目时就应该初始化，是单例的。 - 并未遵循Servlet规范实现相应的生命周期，例如init()/destory()方法我们均未调用。 - ServletRequest/ServletResponse接口的方法我们仍未实现 - 其他未实现的功能 在下一个章节我们会实现 Request 解析 Parameter、HTTPHeader、Cookie 等参数并重构架构模式： 跟我一起动手实现 Tomcat（三）: 解析 Request 请求参数、请求头、cookie PS：本章源码已上传 github SimpleTomcat 跟我一起动手实现 Tomcat（三）: 解析 Request 请求参数、请求头、cookie前言1最近笔者读了《深入剖析tomcat》这本书（原作：《how tomcat works》）,发现该书简单易读，每个章节循序渐进的讲解了tomcat的原理，在接下来的章节中，tomcat都是基于上一章新增功能并完善，到最后形成一个简易版tomcat的完成品。所以有兴趣的同学请按顺序阅读，本文为记录第三章的知识点以及源码实现（造轮子）。 内容回顾跟我一起动手实现 Tomcat（二）: 实现简单的 Servlet 容器上一章我们实现了一个简单的 Servlet 容器，能够调用并执行用户自定义实现 Servlet 接口的类。 本章内容 模块模仿 tomcat，实现 Connector(连接器)、Bootstrap(启动器) 和核心模块。 能够执行继承 HttpServlet 类的自定义 Servlet(上一章是实现了 Servlet 接口) 能够解析用户请求参数 (Parameters)/Cookie / 请求头 (Header) 开始之前 简单介绍 Connector(连接器) 对 Tomcat 比较熟悉的朋友对这个词应该不陌生，后面的篇幅会继续比较详细介绍，在这里不熟悉的朋友可以理解为：连接器只是负责接收请求，然后将请求丢给 Container(容器) 去执行相应的请求。 javax.servlet.http.HttpServlet 类 上一章我们自定义的 Servlet 是实现了 Servlet 接口，实例化 Servlet 的时候我们是将解析的 Request/Response(分别实现了 ServletRequest/ServletResponse 接口) 传入对应的 service() 方法中完成执行。那我们来回顾一下刚学 Servlet 开发的时候，大部分教程都按顺序讲解实现 Servlet 接口、继承 GenericServlet 类、继承 HttpServlet 类这三种方式去写自己的 Servlet，那么后面推荐的仍然是最后一种，重写其中的 doGet()/doPost() 方法即可，那么我们来看看上一章我们的 tomcat 能不能支持继承 HttpServlet 类的 Servlet 呢： 1//HttpServlet源代码片段public abstract class HttpServlet extends GenericServlet &#123; ... public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException&#123; HttpServletRequest request; HttpServletResponse response; //如果传进来的request/response对象不是Http类型的则抛异常 if (!(req instanceof HttpServletRequest &amp;&amp; res instanceof HttpServletResponse)) &#123; throw new ServletException(&quot;non-HTTP request or response&quot;); &#125; request = (HttpServletRequest) req; response = (HttpServletResponse) res; service(request, response); &#125; ...&#125; 如上所示源码，再来看看我们上一章的 ServletProcess 调用 Servlet 源码: 1servlet.service(new RequestFacade(request), new ResponseFacade(response)); 很明显上一章的 request/response 在 HttpServlet 时会抛出异常，所以本章我们会将 Request/Response 以及它们的外观类都实现 HttpServletRequest/HttpServletResponse 接口。 代码实现在代码实现前我们看看整体模块以及流程执行图（看不清可以点击放大）： 1. Bootstrap 模块 启动模块目前我们没有多大工作，只是启动 HttpConnector： 1public final class Bootstrap &#123; public static void main(String[] args)&#123; new HttpConnector().start(); &#125;&#125; 2. HttpConnector 模块 (连接器) 1连接器模块和下面的核心模块的前身其实就是上一章的HttpServer类，我们把它按功能拆分成了 等待和建立连接(HttpConnector)/处理连接(HttpProcess)2个模块。 连接器功能是等待请求并将请求丢给相应执行器去执行： 1public class HttpConnector implements Runnable &#123; public void start()&#123; new Thread(this).start(); &#125; @Override public void run() &#123; ServerSocket serverSocket = new ServerSocket(8080, 1, InetAddress.getByName(&quot;127.0.0.1&quot;)); while (true) &#123; Socket accept = serverSocket.accept(); HttpProcess process = new HttpProcess(this); process.process(accept); &#125; serverSocket.close(); &#125;&#125; 3. 核心模块 (执行器) 1上面也有说到，执行器也是上一章HttpServer类的前身，只不过这章我们修改了解析请求信息的方式。 主要代码 1public class HttpProcess &#123; private HttpRequest request; private HttpResponse response; public void process(Socket socket) &#123; InputStream input = socket.getInputStream(); OutputStream output = socket.getOutputStream(); //初始化request以及response request = new HttpRequest(input); response = new HttpResponse(output, request); //解析request请求行和请求头 this.parseRequestLine(input); this.parseHeaders(input); //调用对应的处理器处理 if (request.getRequestURI().startsWith(SERVLET_URI_START_WITH)) &#123; new ServletProcess().process(request, response); &#125; else &#123; new StaticResourceProcess().process(request, response); &#125; &#125;&#125; 看了上面的实现可能很多人对有些对象有点陌生，下面一一介绍： 11\. HttpRequest/HttpResponse变量就是上一章的Request/Response对象，因为实现了 HttpServletReuqest/HttpServletResponse也就顺便改了个名，将会在下面介绍； 2\. 每一个请求都对应了一个HttpProcess对象，所以这里request/response是成员变量； 3\. 解析请求行和解析请求头的方法也在下面介绍。 parseRequestLine、parseHeaders 方法 让我们先看看一个原始的 HTTP 请求字符串，看看如何去解析请求行和请求头： 1GET /index.html?utm_source=aaa HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: keep-alive\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\r\nAccept: text/html\r\nAccept-Encoding: gzip, deflate, sdch, br\r\nAccept-Language: zh-CN,zh;q=0.8\r\nCookie: BAIDUID=462A9AC35EE6158AA7DFCD27AF:FG=1; BIDUPSID=462A9AC35EE6158AA7DF027AF; PSTM=1506310304; BD_CK_SAM=1; PSINO=7; BD_HOME=1; H_PS_PSSID=1459_24885_21115_25436; BD_UPN=12314353; sug=3; sugstore=0; ORIGIN=2; bdime=0\r\n 大家可以发现，其实我们使用 socket 读取 HTTP 请求时候，发现每一行都会有’\r\n’这个回车换行符，只不过在我们浏览器按 F12 时被浏览器自动解析成了换行而已，我们分析上面的这个请求信息得出以下规律： 每一行结尾字符都是\r\n- 请求行（第一行）的HTTP请求方法、URI、请求协议中间都有个空格- 第二行开始（请求头）key和value的内容都是以’:’和一个’ ‘字符隔开- Cookie的键值对是以’=’分割，以’;’和’ ‘区分前后键值对 接下来我们分别去解析以下 ISO-8859-1 编码情况下上面字符对应的值，并建立一个常量类： 1public class HttpConstant &#123; /* 回车 \r */ public static final byte CARRIAGE_RETURN = 13; /* 换行 \n */ public static final byte LINE_FEED = 10; /* 空格 */ public static final byte SPACE = 32; /* 冒号 : */ public static final byte COLON = 58;&#125; 1.parseRequestLine 方法 根据上面的思路，我们就可以轻松地解析请求行的数据： 1StringBuilder temp = new StringBuilder();int cache;while ((cache = requestStream.read()) != -1) &#123; //读取到第一个\r\n时则说明读取请求行完毕 if (HttpConstant.CARRIAGE_RETURN == cache &amp;&amp; HttpConstant.LINE_FEED == requestStream.read()) &#123; break; &#125; temp.append((char)cache);&#125;String[] requestLineArray = temp.toString().split(&quot; &quot;); 最后分割空格使用数组装着请求行（如果你有更好的方案也可以在评论区说一说哈）接下来判断 URI 有没有使用 “?” 传递参数，如果有就截取并丢到 HttpRequest 的 QueryString 变量中，最后截取 URI 即可。 1String uri = requestLineArray[1];int question = uri.indexOf(&quot;?&quot;);if (question &gt;= 0) &#123; request.setQueryString(uri.substring(question+1,uri.length())); uri = uri.substring(0,question);&#125; 1判断是不是从?传递jsessionid过来，如果是就赋值到request对象中 1String match = &quot;;jsessionid=&quot;;int semicolon = uri.indexOf(match);if (semicolon &gt;= 0) &#123; String rest = uri.substring(semicolon + match.length()); int semicolon2 = rest.indexOf(&apos;;&apos;); if (semicolon2 &gt;= 0) &#123; request.setRequestedSessionId(rest.substring(0, semicolon2)); rest = rest.substring(semicolon2); &#125; else &#123; request.setRequestedSessionId(rest); rest = &quot;&quot;; &#125; request.setRequestedSessionURL(true); uri = uri.substring(0, semicolon) + rest;&#125; else &#123; request.setRequestedSessionId(null); request.setRequestedSessionURL(false);&#125; 这里调用了一个校验 URI 合法性的方法, 如果 URI 不合法 (例如包含’.//‘之类跳转目录的危险字符)则抛异常，否则就将上面解析到的内容丢到 request 中去。 1String normalizedUri = this.normalize(uri);if (normalizedUri == null) &#123; throw new ServletException(&quot;Invalid URI: &quot; + uri + &quot;&apos;&quot;);&#125;request.setRequestURI(normalizedUri);request.setMethod(requestLineArray[0]);request.setProtocol(requestLineArray[2]); 就这样，请求行的信息就被我们读取完毕，那我们再来看看读取请求头的代码： parseHeaders 方法 这里有个坑：Socket 的 read()方法读取完毕时最后一个字节不是 - 1，而是阻塞等待 Socket 客户端发送 - 1 过来结束读取，但是我们的 Socket 客户端是浏览器，浏览器不会发送 - 1 以表示结束发送，所以我们结合 InputStream#available()方法 (返回实际还可以读取的字节数) 来判断是否读取完毕即可。 1public void parseHeader() &#123; StringBuilder sb = new StringBuilder(); int cache; while (input.available() &gt; 0 &amp;&amp; (cache = input.read()) &gt; -1) &#123; sb.append((char)cache); &#125; ....看下文&#125; 读取完毕效果如图：如果是 POST 请求，那么表单参数会在空行后面： 也很有规律，请求头都用 \ r\n 隔开，并且如果是 POST 请求提交表单，那么表单参数会在一个空行后面 (两个 \ r\n) 1//使用\r\n分割请求头Queue&lt;String&gt; headers = Stream.of(sb.toString().split(&quot;\r\n&quot;)).collect(toCollection(LinkedList::new));while (!headers.isEmpty()) &#123; //获取一个请求头 String headerString = headers.poll(); //读取到空行则说明请求头已读取完毕 if (StringUtil.isBlank(headerString)) &#123; break; &#125; //分割请求头的key和value String[] headerKeyValue = headerString.split(&quot;: &quot;); request.addHeader(headerKeyValue[0], headerKeyValue[1]);&#125;//如果在读取到空行后还有数据，说明是POST请求的表单参数if(!headers.isEmpty())&#123; request.setPostParams(headers.poll());&#125; 大致流程： 最后我们对一些特殊的请求头信息设置到 Request 对象中 (cookie、content-type、content-length); 1String contentLength = request.getHeader(&quot;content-length&quot;);if(contentLength!=null)&#123; request.setContentLength(Integer.parseInt(contentLength));&#125;request.setContentType(request.getHeader(&quot;content-type&quot;));Cookie[] cookies = parseCookieHeader( request.getHeader(&quot;cookie&quot;));Stream.of(cookies).forEach(cookie -&gt; request.addCookie(cookie));//如果sessionid不是从cookie中获取的，则优先使用cookie中的sessionidif (!request.isRequestedSessionIdFromCookie()) &#123; Stream.of(cookies) .filter(cookie -&gt; &quot;jsessionid&quot;.equals(cookie.getName())) .findFirst(). ifPresent(cookie -&gt; &#123; //设置cookie的值 request.setRequestedSessionId(cookie.getValue()); request.setRequestedSessionCookie(true); request.setRequestedSessionURL(false); &#125;);&#125; 读取 cookie 的方法也很简单： 1private Cookie[] parseCookieHeader(String cookieListString) &#123; return Stream.of(cookieListString.split(&quot;; &quot;)) .map(cookieStr -&gt; &#123; String[] cookieArray = cookieStr.split(&quot;=&quot;); return new Cookie(cookieArray[0], cookieArray[1]); &#125;).toArray(Cookie[]::new);&#125; 不熟悉 JDK8 语法的小伙伴们可能看不太懂干了什么，没关系来张图解释一下上面那段代码内容： 到这里，HttpProcess 处理请求的逻辑就搞定啦，(是不是觉得代码有点多)，细心的客官们一定发现了，request 怎么可以设置那么多属性呢？上一章的 request 好像没有那么多功能吧？是的，我们这一章也对 request/response 做了手脚，请看下文分析： HttpRequest(上一章的 Request 对象) 没错，在文章的开头我们已经说了要把 Request 升级一下，那么怎么升级呢？也就是实现 HttpServletRequest 接口啦： 1public class HttpRequest implements HttpServletRequest &#123; private String contentType; private int contentLength; private InputStream input; private String method; private String protocol; private String queryString; private String postParams; private String requestURI; private boolean requestedSessionCookie; private String requestedSessionId; private boolean requestedSessionURL; protected ArrayList&lt;Cookie&gt; cookies = new ArrayList&lt;&gt;(); protected HashMap&lt;String, ArrayList&lt;String&gt;&gt; headers = new HashMap&lt;&gt;(); protected ParameterMap parameters; ...&#125; 哈哈没有看错，多了一堆参数，但是细心的客官们应该可以看到，这些参数都是非常眼熟，而且上面已经对大部分参数设值过了，眼生的可能就是下面的那个 ParameterMap，那么等下我们慢慢分析：(那些 get、set 方法就不分析了) 请求头 (header) 操作： 1public void addHeader(String name, String value) &#123; name = name.toLowerCase(); //如果key对应的value不存在则new一个ArrayList ArrayList&lt;String&gt; values = headers.computeIfAbsent(name, k -&gt; new ArrayList&lt;&gt;()); values.add(value);&#125;public ArrayList getHeaders(String name) &#123; name = name.toLowerCase(); return headers.get(name);&#125;public String getHeader(String name) &#123; name = name.toLowerCase(); ArrayList&lt;String&gt; values = headers.get(name); if (values != null) &#123; return values.get(0); &#125; else &#123; return null; &#125;&#125; public ArrayList getHeaderNames() &#123; return new ArrayList(headers.keySet());&#125; 大家可以看到请求头是是个 Map，key 是请求头的名字，value 则是请求头的内容数组 (一个请求头可以有多个内容)，所以也就是对这个 Map 做操作而已~ Cookie 操作： 1public Cookie[] getCookies() &#123; return cookies.toArray(new Cookie[cookies.size()]);&#125;public void addCookie(Cookie cookie) &#123; cookies.add(cookie);&#125; 好像也没什么好说的，对 List \ 做常规操作。 Parameters 操作：这是我们最常用的一个操作啦，那么 ParameterMap 是个什么东西呢，我们先来看看： 1public final class ParameterMap extends HashMap&lt;String,String[]&gt; &#123; private boolean locked = false; public boolean isLocked() &#123; return locked; &#125; public void setLocked(boolean locked) &#123; this.locked = locked; &#125; public String[] put(String key, String[] value) &#123; if (locked) &#123; throw new IllegalStateException(&quot;error&quot;); &#125; return (super.put(key, value)); &#125; ...&#125; 好吧其实它就是在 HashMap 基础上加了一个 locked 对象 (如果已经解析参数完毕了则将这个对象设置为 true 禁止更改),key 是参数名，value 是参数值数组 (可有多个) 例如：127.0.0.1:8080/servlet/QueryServlet?name=geoffrey&amp;name=yip 那么我们来看看对 parameter 这个 map 的操作有： 1public String getParameter(String name) &#123; parseParameters(); String[] values = parameters.get(name); return Optional.ofNullable(values).map(arr -&gt; arr[0]).orElse(null);&#125;public Map getParameterMap() &#123; parseParameters(); return this.parameters;&#125;public ArrayList&lt;String&gt; getParameterNames() &#123; parseParameters(); return new ArrayList&lt;&gt;(parameters.keySet());&#125; public String[] getParameterValues(String name) &#123; parseParameters(); return parameters.get(name);&#125; 代码都很简单，但是这个 parseParameters() 是什么呢，对，它是去解析请求的参数了 (懒加载)，因为我们不知道用户使用 Servlet 会不会用到请求参数这个功能，而且解析它的开销比解析其他数据大，所以我们会在用户真正使用参数的时候才会去解析，提高整体的响应速度，大概的代码如下： 1protected void parseParameters() &#123; if (parsed) &#123; //已经解析过则停止解析 return; &#125; ParameterMap results = parameters; if (results == null) &#123; results = new ParameterMap(); &#125; results.setLocked(false); String encoding = getCharacterEncoding(); if (encoding == null) &#123; encoding = StringUtil.ISO_8859_1; &#125; // 解析URI携带的请求参数 String queryString = getQueryString(); this.parseParameters(results, queryString, encoding); // 初始化Content-Type的值 String contentType = getContentType(); if (contentType == null) &#123; contentType = &quot;&quot;; &#125; int semicolon = contentType.indexOf(&apos;;&apos;); if (semicolon &gt;= 0) &#123; contentType = contentType.substring(0, semicolon).trim(); &#125; else &#123; contentType = contentType.trim(); &#125; //解析POST请求的表单参数 if (HTTPMethodEnum.POST.name().equals(getMethod()) &amp;&amp; getContentLength() &gt; 0 &amp;&amp; &quot;application/x-www-form-urlencoded&quot;.equals(contentType)) &#123; this.parseParameters(results, getPostParams(), encoding); &#125; //解析完毕就锁定 results.setLocked(true); parsed = true; parameters = results;&#125;/** * 解析请求参数 * @param map Request对象中的参数map * @param params 解析前的参数 * @param encoding 编码 */public void parseParameters(ParameterMap map, String params, String encoding) &#123; String[] paramArray = params.split(&quot;&amp;&quot;); Stream.of(paramArray).forEach(param -&gt; &#123; String[] splitParam = param.split(&quot;=&quot;); String name = splitParam[0]; String value = splitParam[1]; //此处是将key和value使用URLDecode解码并添加进map中 putMapEntry(map, urlDecode(name, encoding), urlDecode(value, encoding)); &#125;);&#125; 大概内容就是根据之前 HttpProcess 解析请求行的 queryString 参数以及如果是 POST 请求的表单数据放入 ParameterMap 中，并且锁定 Map。 HttpResponse(上一章的 Response 对象) HttpResponse 对象也跟随者实现了 HttpServletResponse 接口，但是本章没有实现具体的内容，所以此处略过。 1public class HttpResponse implements HttpServletResponse &#123; ...&#125; ServletProcess ServletProcess 具体只需要将 request 和 response 的外观类跟着升级实现对应的接口即可： 1public void process(HttpRequest request, HttpResponse response) throws IOException &#123; ... servlet.service(new HttpRequestFacade(request), new HttpResponseFacade(response)); ...&#125;public class HttpRequestFacade implements HttpServletRequest &#123; private HttpRequest request; ...&#125;public class HttpResponseFacade implements HttpServletResponse &#123; private HttpResponse response; ...&#125; 实验我们先编写一个 Servlet： 1/** * 测试注册Servlet */public class RegisterServlet extends HttpServlet &#123; @Override public void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; //打印表单参数 String name = req.getParameter(&quot;name&quot;); String password = req.getParameter(&quot;password&quot;); if (StringUtil.isBlank(name) || StringUtil.isBlank(password)) &#123; try &#123; resp.getWriter().println(&quot;账号/密码不能为空！&quot;); &#125; finally &#123; return; &#125; &#125; //打印请求行 System.out.println(&quot;Parse user register method:&quot; + req.getMethod()); //打印Cookie System.out.println(&quot;Parse user register cookies:&quot;); Optional.ofNullable(req.getCookies()) .ifPresent(cookies -&gt; Stream.of(cookies) .forEach(cookie -&gt;System.out.println(cookie.getName() + &quot;:&quot; + cookie.getValue() ))); //打印请求头 System.out.println(&quot;Parse http headers:&quot;); Enumeration&lt;String&gt; headerNames = req.getHeaderNames(); while (headerNames.hasMoreElements()) &#123; String headerName = headerNames.nextElement(); System.out.println(headerName + &quot;:&quot; + req.getHeader(headerName)); &#125; System.out.println(&quot;Parse User register name :&quot; + name); System.out.println(&quot;Parse User register password :&quot; + password); try &#123; resp.getWriter().println(&quot;注册成功！&quot;); &#125; finally &#123; return; &#125; &#125; @Override public void doPost(HttpServletRequest req, HttpServletResponse resp) &#123; this.doGet(req, resp); &#125;&#125; 编写一个 HTML： 1&lt;html&gt; &lt;head&gt; &lt;title&gt;注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;/servlet/RegisterServlet&quot;&gt; 账号：&lt;input type=&quot;text&quot; &gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; &gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 打开浏览器测试: 控制台输出： 到这里，咱们的 Tomcat 3.0 web 服务器就已经开发完成啦（滑稽脸），已经可以实现简单的自定义 Servlet 调用，以及请求行 / 请求头 / 请求参数 / cookie 等信息的解析，待完善的地方还有很多： 1- HTTPProcess一次性只能处理一个请求，其他请求只能堵塞，不具备服务器使用性。 - 每一次请求就new一次Servlet，Servlet应该在初始化项目时就应该初始化，是单例的。 - 并未遵循Servlet规范实现相应的生命周期，例如init()/destory()方法我们均未调用。 - HttpServletRequest/HttpServletResponse接口的大部分方法我们仍未实现 - 架构/包结构和tomcat相差太多 - 其他未实现的功能 在下一章节我们会把我们的连接器实现 Catalina 的 Connector 接口，并且使得我们可以同时处理多个请求，最终我们的连接器实现的功能以及结构和 Tomcat4 版本的默认连接器基本一致。 PS：本章源码已上传 github： SimpleTomcat 原文：Geoffrey.Yip🌴 的个人主页 - 专栏 - 掘金https://juejin.im/user/5915598ba0bb9f005fd2feb1/posts]]></content>
      <tags>
        <tag>待阅</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas处理数据,Echarts可视化]]></title>
    <url>%2F2018%2F03%2F27%2F2018-03-27%2F</url>
    <content type="text"><![CDATA[「需输入密码」 Decrypt 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]]></content>
      <tags>
        <tag>数据可视化</tag>
        <tag>pandas</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[韩顺平细说Servlet笔记]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-2%2F</url>
    <content type="text"><![CDATA[CS 结构与 BS 结构基本概述B/S 结构即浏览器和服务器结构。它是随着 Internet 技术的兴起，对 C/S 结构的一种变化或者改进的结构。在这种结构下，用户工作界面是通过 WWW 浏览器来实现，极少部分事务逻辑在前端 (Browser) 实现，但是主要事务逻辑在服务器端 (Server) 实现，形成所谓三层 3-tier 结构。 C/S 结构，即大家熟知的客户机和服务器结构。它是软件系统体系结构，通过它可以充分利用两端硬件环境的优势，将任务合理分配到 Client 端和 Server 端来实现，降低了系统的通讯开销。 PS：像腾讯就是以 C/S 结构起家的，其旗下的 QQ 这一软件就是典型的 C/S 结构应用，像 Facebook 就是以 B/S 为结构的。B/S 结构的好处就是方便，跨平台性好，真正的实现了一次开发，处处运行。C/S 结构以其稳定安全著称，降低了通讯代价，但是实现起来麻烦，需要开发服务器和客户端两套系统并且在不同的平台移植起来非常麻烦。所以现在大多是以 C/S 模式来开发。 C/S 系统结构 B/S 系统结构 实例： 1234567891011121314151617181920212223/** 模拟的简单Web服务器*/import java.io.*;import java.net.*;public class Servlet1&#123; public static void main(String[] args) throws Exception&#123; // 创建ServerSocket ServerSocket ss = new ServerSocket(9999); Socket s = ss.accept(); System.out.println("9999"); OutputStream os = s.getOutputStream(); BufferedReader br = new BufferedReader(new FileReader("c:\\hello.html")); String buf = ""; while((buf = br.readLine()) != null)&#123; os.write(buf.getBytes()); &#125; br.close(); os.close(); s.close(); &#125;&#125; Tomcat 容器入门介绍Tomcat 环境配置PS：JDK 的安装这里就不讲了，找到安装包直接下一步下一步就行了。 1、配置 JDK在 Windows10 下，找到环境变量 在环境变量中添加 JDK 主目录 格式为：JAVA_HOME= 指向你的 jdk 的主目录（并不是 bin 文件目录） 在环境变量中添加路径 格式为：path = %JAVA_HOME%\bin; 在环境变量中添加 classpath 格式为：classpath: .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 至此，JDK 就配置完了。 PS：如果在不配置 JAVAHOME 的前提下可以用如下方法启动 tomcat 在 startup.bat 的第 25 行中添加 set JAVA_HOME=JKD 路径 2、启动 tomcat到 tomcat 主目录下的 bin/startup.bat 点击启动 3、验证是否安装成功在浏览器中输入 http://127.0.0.1:8080(8080 是默认端口，如果该端口被占用需要到主目录 / conf/server.xml 中改端口号) 出现这个界面，就表示 tomcat 已经配置成功了。 Tomcat 配置异常及其解决1、JAVA_HOME 配置错误，或者没有配置这时候，可以按照上面的步骤在来一次，在命令行中输入 java -version，如果显示 就表示成功了。 2、如果你的机器已经占有了 8080 端口，则无法启动解决方法 (1) 你可以 8080 先关闭 netstat –an netstat –anb 来查看谁占用该 8080 (2) 主动改变 tomcat 的端口. 到 conf/server.xml 文件中修改 3、 能够正常启动，但是会导航到另外一个页面去修改工具 -&gt; 管理加载项，把默认的导航给禁用即可 4、浏览器显示 404 Not Found在访问 tomcat 时候，一定要保证 tomcat 服务器是启动，不然就会出现这种错误。 Tomcat 的目录结构文件 bin: 启动和关闭 tomcat 的 bat 文件 conf: 配置文件 –&gt;server.xml : 该文件用于配置和 server 相关的信息, 比如 tomcat 启动端口后, 配置 Host, 配置 Context 即 web 应用 –&gt;web.xml : 该文件配置与 web 应用 (web 应用就相当于是一个 web 站点) –&gt;tomcat-users.xml: 该文件用户配置 tomcat 的用户密码 和 权限 lib 目录: 该目录放置运行 tomcat 运行需要的 jar 包 logs 目录：存放日志, 当我们需要去查看日志的时候，很有用!, 当我们启动 tomcat 错误时候，可以查询信息. webapps 目录: 该目录下，放置我们的 web 应用 (web 站点), 比如: 建立 web1 目录 下面放置我们的 html 文件 jsp 文件.. 图片… 则 web1 就被当做一个 web 应用管理起来 (☞ 特别说明 tomcat 6.0 以后支持 tomcat 5 版本 还有别的设置) work: 工作目录: 该目录用于存放 jsp 被访问后 生成的对应的 server 文件 和. class 文件 如何访问一个 web 应用的某个文件 PS：想要访问一个 WEB 应用中的某个文件可以采用 url(Uniform Resource Locator) 统一资源定位符来访问，其格式如上。 Tomcat 应用部署目录结构规范 Tomcat 管理虚拟目录需求：当希望将 web 应用部署到非 webapps 目录下时，怎么解决这问题。 PS：可以通过虚拟目录配置技术解决。 配置步骤1、找到 server.xml 文件 2、编辑 host 节点，添加 Context path 例如：要访问该 web 应用根目录下的 hello.html 文件 实际访问时输入的地址：http://localhost:8088 / 应用名 / hello.html 3、重启、重新部署生效 context 的几个属性的说明path: 应用名称 docbase: web 应用所在的绝对路径 reloadable: 如果设为 ture ，表示 tomcat 会自动更新 web 应用，但是这个开销大，建议在开发过程中，可以设为 true, 但是真的发布了，则应当设为 false upackWAR: 如果设为 ture ，则自动解压，否则不自动解压. PS：war 包的打包和 Tomcat 怎么部署 war 包可以使用搜索引擎找到。 配置域名实现的步骤如下: (1) 在 C:\WINDOWS\system32\drivers\etc 下的 host 文件 添加 127.0.0.1 www.myweb.com (2) 在 tomcat 的 server.xml 文件添加主机名 12345&lt;Host d:\web3”&gt;&lt;Context path=&quot;/&quot; docBase=&quot;d:\web3&quot; /&gt;&lt;/Host&gt; (3) 在 d:\web3 加入了一个 /WEB-INF/web.xml 把 hello2.html 设为首页面，如果连端口都不希望带，则可以把 tomcat 的启动端口设为 80 即可. (4) 重启生效 Tomcat 框架机制 Tomcat 配置默认主机在 tomcat/conf/server.xml 文件 如： Servlet 入门基本概述Servlet（Server Applet），全称 Java Servlet，未有中文译文。是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。 Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。 PS：学习 Servlet 是学习 JSP 的基础，故很重要。 Servlet 在网络中的位置 Servlet 的生命周期 1、WEB 服务器 (Tomcat) 首先会找到该 Servlet 并装载该 Servlet 2、WEB 服务器 (Tomcat) 会创建该 Servlet 的实例 3、WEB 服务器 (Tomcat) 会调用实例对象的 init()方法 4、WEB 服务器 (Tomcat) 创建一个封装 HTTP 请求消息的 HttpServletRequest 对象和一个代表 HTTP 响应消息的 HttpServletResponse 对象，然后调用 service()方法并将请求对象和响应对象作为参数传递进去。(实现是通过多线程技术) 5、WEB 服务器在某种情况，停止对该 Servlet 支持，Servlet 引擎将卸载该 Servlet，在卸载之前会调用 Servlet 的 destroy() 方法进行销毁 手工开发 Servlet 的方式1、在 Tomcat 主目录的 webapps 文件夹下建立一个 web 应用 web1 2、在 web1 下建立文件夹 WEB-INF，在该文件夹中建立 web.xml [web.xml 可以从 ROOT/WEB-INF/web.xml 拷贝] 3、在 WEB-INF 目录下建立 classes 目录 (Servlet 在该目录下开发)，建立 lib 目录 4、在 classes 目录下开发 Servlet 5、在 web.xml 中配置 web.xml 6、编译 Servlet 文件 (编译时需要将 servlet-api.jar 包加入环境变量 classpath 中，该 jar 包在 Tomcat 主目录的 lib 文件夹下) 7、运行 Tomcat 8、访问 Servlet 开发 Servlet 的三种方法1、实现 Servlet 接口12345678910111213141516171819202122232425262728293031323334353637/** 使用实现Servlet接口的方式开发一个Servlet 要求：显示当前时间*/package com.pc;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class Servlet2 implements Servlet&#123; // 该方法用于初始化Servlet，就是把该Servlet装载入内存，该方法只会被调用一次 public void init(ServletConfig config)&#123; &#125; // 得到ServletConfig对象 public ServletConfig getServletConfig()&#123; return null; &#125; // 该方法是服务方法，业务逻辑代码写在这 // 该方法每次都会被调用 public void service(ServletRequest req, ServletResponse res) throws ServletException, java.io.IOException&#123; // 在控制台输出 System.out.println(&quot;hello world：&quot; + new java.util.Date().toString()); // 在浏览器返回 res.getWriter().println(&quot;hello world：&quot; + new java.util.Date().toLocaleString()); &#125; // 该方法得到Servlet配置信息 public java.lang.String getServletInfo()&#123; return null; &#125; // 销毁该Servlet，从内存中清除，该方法只会被调用一次 public void destroy()&#123; &#125;&#125; PS：不仅要写 Servlet 文件，还要在 web.xml 中添加配置信息，配置信息格式如下： 1234567891011121314&lt;!-- servlet部署到web.xml文件，该部署配置可以从examples下拷贝 --&gt;&lt;servlet&gt; &lt;!--servlet-name 该名字可以自定义，但是默认就使用servlet的名字 --&gt; &lt;servlet-name&gt;Servlet2&lt;/servlet-name&gt; &lt;!--servlet-class要指明该servlet放在那个包下的 --&gt; &lt;servlet-class&gt;com.pc.Servlet2&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射 --&gt;&lt;servlet-mapping&gt; &lt;!-- 这个servlet-name要和上面的servlet-name名字一样，这样才能匹配的上 --&gt; &lt;servlet-name&gt;Servlet2&lt;/servlet-name&gt; &lt;!-- url-pattern 这是访问该servlet的资源部分 默认命名规范：就是该servlet的名字--&gt; &lt;url-pattern&gt;/Servlet2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; PS： 1、在 classes 文件夹下编译 (当然 Servlet 文件也应该在这里) javac -encoding UTF-8 -d . Servlet 文件名. java 2、不重启更新 web 应用 首先，在 Tomcat 主目录的 conf 文件夹中找到 tomcat-users.xml 文件，打开它，并在标签中添加如下语句 1234&lt;tomcat-users&gt; &lt;role role/&gt; &lt;user user/&gt;&lt;/tomcat-users&gt; 然后，在 localhost:8080 主界面点击，进入 manager 界面，找到该应用，点击 reload 按钮即可。 2、继承 GenericServlet 类12345678910111213141516/** 使用继承GenericServlet的方式开发一个Servlet*/package com.pc;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class Servlet3 extends GenericServlet&#123; // 该方法是服务方法，业务逻辑代码写在这 // 该方法每次都会被调用 public void service(ServletRequest req,ServletResponse res) throws ServletException,IOException&#123; res.getWriter().println(&quot;hellow,world, GenericServle.&quot;); &#125;&#125; PS：不仅要写 Servlet 文件，还要在 web.xml 中添加配置信息，配置信息格式如下： 12345678&lt;servlet&gt; &lt;servlet-name&gt;Servlet3&lt;/servlet-name&gt; &lt;servlet-class&gt;com.pc.Servlet3&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Servlet3&lt;/servlet-name&gt; &lt;url-pattern&gt;/Servlet3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、继承 HttpServlet 类123456789101112131415161718192021222324/** 使用继承HttpServlet的方式开发一个Servlet 要求：显示当前时间*/package com.pc;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class Servlet4 extends HttpServlet&#123; // 在HttpServlet中，设计者分别提供了对Post提交和Get提交的处理，默认是get提交 // doGet().doPost()底层也是调用service方法 // 处理Get请求 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException&#123; resp.getWriter().println(&quot;doGet()&quot;); &#125; // 处理Post请求 protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; resp.getWriter().println(&quot;doPost()&quot;); &#125;&#125; PS：不仅要写 Servlet 文件，还要在 web.xml 中添加配置信息，配置信息格式如下： 12345678&lt;servlet&gt; &lt;servlet-name&gt;Servlet4&lt;/servlet-name&gt; &lt;servlet-class&gt;com.pc.Servlet4&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Servlet4&lt;/servlet-name&gt; &lt;url-pattern&gt;/Servlet4&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 使用 MyEclipse 集成开发环境 IDE 来开发 Web 应用PS：具体的配置步骤可以参考搜索引擎。 MyEclipse 的开发目录结构 Servlet 细节问题1、一个已经注册的 Servlet 可以被多次映射1234567891011121314151617181920 &lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;!-- servlet的注册名 --&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;!-- servlet类的全路径(包名+类名) --&gt; &lt;servlet-class&gt;com.web1.servlet.MyServlet1&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;!-- 对一个已经注册的servlet的映射 --&gt; &lt;servlet-mapping&gt; &lt;!-- servelt的注册名 --&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;!-- servlet的访问路径 --&gt; &lt;url-pattern&gt;/MyServlet1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet1&lt;/servlet-name&gt; &lt;url-pattern&gt;/abc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2、当映射一个 Servlet 时，可以多层映射1&lt;url-pattern&gt;/servlet/index.html&lt;/url-pattern&gt; 3、在 Servlet 使用通配符映射到 URL有两种格式: 第一种格式 . 扩展名 比如 .do *.ss 第二种格式 以 / 开头 同时以 / 结尾 比如 / /news/* 通配符案例： Servlet1 映射到 /abc/* Servlet2 映射到 /* Servlet3 映射到 /abc Servlet4 映射到 *.do 问题： 1、当请求 URL 为 “/abc/a.html”，“/abc/” 和 “/” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet1。 2、当请求 URL 为 “/abc” 时，“/abc/*”和 “/abc” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet3。 3、当请求 URL 为 “/abc/a.do” 时，“/abc/” 和 “.do” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet1。 4、当请求 URL 为 “/a.do” 时，“/” 和 “.do” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet2。 5、当请求 URL 为 “/xxx/yyy/a.do” 时，“/” 和 “.do” 都匹配，哪个 servlet 响应 Servlet 引擎将调用 Servlet2。 在匹配的时候，要参考的标准: 1、看谁的匹配度高，谁就被选择 2、*.do 的优先级最低 4、servlet 中的配置当需要在网站启动时，初始化一些资源时可以配置 123&lt;servlet&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; PS：在 servlet 中如此配置就行，中间的数是整数，越小优先级越高。 配置好了之后，在网站启动时就会调用该 Servlet 的 init() 方法，所以可以在该方法中进行需要的初始化步骤，比如定时刷新，建立内存表之类的等等。 ServletConfig 对象该对象主要用于读取 servlet 的配置信息. 案例: 123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletConfigTest&lt;/servlet-name&gt; &lt;servlet-class&gt;com.web1.servlet.ServletConfigTest&lt;/servlet-class&gt; &lt;!-- 这里可以给servlet配置信息,这里配置的信息，只能被该servlet 读取 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; 如何使用：在 Servlet 使用如下语句 1String encoding = this.getServletConfig().getInitParameter(&quot;encoding&quot;); 补充说明: 这种配置参数的方式，只能被某个 Servlet 独立使用. 如希望让所有的 Servlet 都去读取某个参数, 这样配置: 12345&lt;!-- 如果这里配置参数，可被所有servlet读取 --&gt;&lt;context-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt;&lt;/context-param&gt; 读取所有的参数，可以使用如下方法： 123456Enumeration&lt;String&gt; names=this.getServletConfig().getInitParameterNames();while(names.hasMoreElements())&#123; String name=names.nextElement(); System.out.println(name); System.out.println(this.getServletConfig().getInitParameter(name));&#125; 注意事项：1、Servlet 类是单例模式的，所以要注意线程同步情况。 2、Servlet 的 service() 方法，在每次响应时都会调用一次。 3、Servlet 的 init() 初始化方法，destroy() 销毁方法只会被调用一次。 4、Servlet 的 service() 方法，会根据客户端的请求方法来决定调用对应的 doXXX() 方法。 5、不要重写构造方法，因为所继承的 HttpServlet 及其父类都已经对构造方法进行了某些初始化，当不了解这些系统自带的初始化，然后盲目使用构造方法，可能导致 Servlet 无法创建实例。 6、不要重写 service 方法 (在继承 HttpServlet 的情况下)，因为其内部有判别客户端请求方法的逻辑和一些其他逻辑。 7、必须重写 doPost() 或者是 doGet() 方法中的一个。 8、当想用一种逻辑去处理 Get 和 Post 请求，可以采用委托机制，在 doPost 方法内加入 this.doGet(request, response); 或者在 doGet 方法中加入 this.doPost(request, response); 9、继承 HttpServlet 开发 Servlet 是最常用的方法。 10、get 提交和 post 提交的区别 10.1、从安全的角度看，get &lt; post，因为 get 会把提交的信息显示到地址栏。 10.2、从提交内容大小看， get &lt; post， get 一般不要大于 2k，post 理论无限制，但是在实际开发中，建议不要大于 64k 10.3、从速度看，get &gt; post，因为 get 仅仅只是获取数据而已 11、Servlet 的映射的后缀名不一定代表它就真的是那格式的文件。 HTTP 协议入门——1.1 版本基本概述超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。 HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示 (如文本先于图形) 等。 HTTP 是客户端浏览器或其他程序与 Web 服务器之间的应用层通信协议。在 Internet 上的 Web 服务器上存放的都是超文本信息，客户机需要通过 HTTP 协议传输所要访问的超文本信息。HTTP 包含命令和传输信息，不仅可用于 Web 访问，也可以用于其他因特网 / 内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。 长连接和短连接的区别解释 1 所谓长连接指建立 SOCKET 连接后不管是否使用都保持连接，但安全性较差，所谓短连接指建立 SOCKET 连接后发送后接收完数据后马上断开连接，一般银行都使用短连接 解释 2 长连接就是指在基于 tcp 的通讯中，一直保持连接，不管当前是否发送或者接收数据。而短连接就是只有在有数据传输的时候才进行连接，客户－服务器通信 / 传输数据完毕就关闭连接。 解释 3 长连接和短连接这个概念好像只有移动的 CMPP 协议中提到了，其他的地方没有看到过。通信方式各网元之间共有两种连接方式：长连接和短连接。所谓长连接，指在一个 TCP 连接上可以连续发送多个数据包，在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接。短连接是指通信双方有数据交互时，就建立一个 TCP 连接，数据发送完成后，则断开此 TCP 连接，即每次 TCP 连接只完成一对 CMPP 消息的发送。现阶段，要求 ISMG 之间必须采用长连接的通信方式，建议 SP 与 ISMG 之间采用长连接的通信方式。 解释 4 短连接：比如 http 的，只是连接、请求、关闭，过程时间较短, 服务器若是一段时间内没有收到请求即可关闭连接。长连接：有些服务需要长时间连接到服务器，比如 CMPP，一般需要自己做在线维持。 参考文章：http://blog.csdn.net/shine0181/article/details/7799754 HTTP 请求部分基本结构GET /q547550831?viewmode=contents HTTP/1.1 [请求行] Host: blog.csdn.net [消息头] 消息名: 内容 Connection: keep-alive Cache-Control: max-age=0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,_/_;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36 Referer: http://blog.csdn.net/q547550831?viewmode=contents Accept-Encoding: gzip, deflate, sdch Accept-Language: zh-CN,zh;q=0.8 PS：这是我博客主页的请求头，但是这并不代表每个网页的请求头都是这一样的。 请求方式请求方式有： POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT,CONNECT 等 参考文档：http://tools.jb51.net/table/http_request_method 常用的有：POST 和 GET 请求消息头Host: blog.csdn.net [主机名] Connection: keep-alive [连接状态: 保持连接] Cache-Control: max-age=0 [指定请求和响应遵循的缓存机制: 查看是否有修改并选择更新否] Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,_/_;q=0.8 [可接受的格式] User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36 [浏览器内核] Referer: http://blog.csdn.net/q547550831?viewmode=contents [从哪个网页跳转到这个网页来的，可以用来防盗链] Accept-Encoding: gzip, deflate, sdch [可接收的压缩格式] Accept-Language: zh-CN,zh;q=0.8 [浏览器支持的语言] PS：请求是指浏览器发出向服务器发出，所以这些信息都是浏览器的信息。请求头远远不止这几种，可以参考该文档：http://tools.jb51.net/table/http_header 案例：防止盗链 12345678910111213141516171819202122232425262728293031package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet6 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;a href=&apos;http://127.0.0.1:8080/servlet1/Servlet5&apos;&gt;连接到Servlet5&lt;/a&gt;&quot;); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet5 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 通过request对象来获取http请求信息 // 取出Host String host = request.getHeader(&quot;Host&quot;); out.println(&quot;host=&quot; + host); // 限制用户 // 获取用户浏览器的Referer // referer可以防止盗链，通过判断链接来至哪里 String referer = request.getHeader(&quot;Referer&quot;); if(referer == null || !referer.startsWith(&quot;http://127.0.0.1:8080/servlet1&quot;))&#123; out.println(&quot;非法盗链&quot;); &#125; else &#123; out.println(&quot;referer=&quot; + referer); &#125; out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 一般开发人员习惯把doGet()和doPost()合二为一 this.doGet(request, response); &#125; public void init() throws ServletException &#123; // Put your code here &#125;&#125; PS：该案例中只能允许 http://127.0.0.1:8080/servlet1 开头的网址进行访问 Servlet5 HTTP 响应部分基本结构HTTP/1.1 200 OK [状态行] Server: openresty [消息名] 消息名: 内容 Date: Fri, 01 Jan 2016 08:11:04 GMT Content-Type: text/html; charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive Vary: Accept-Encoding Cache-Control: private Set-Cookie: uuid=5cad65d6-7a99-4b15-a6e6-5c50e584ca77; expires=Sat, 02-Jan-2016 08:13:49 GMT; path=/ Set-Cookie: ViewMode=contents; path=/ Content-Encoding: gzip ————– 这是一个空行 消息体 响应状态码响应状态码分别为 1,2,3,4,5 开头的三位数字 响应状态码 含义 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 PS：常见的有 200(成功)，303(重定向)，400(Not Found)，500(服务器内部错误) 可以参考该文档：http://tools.jb51.net/table/http_status_code 响应消息头Server: openresty [服务器名称] Date: Fri, 01 Jan 2016 08:11:04 GMT [原始服务器消息发出的时间] Content-Type: text/html; charset=utf-8 [返回内容的 MIME 类型] Transfer-Encoding: chunked [文件传输编码] Connection: keep-alive [连接状态: 保持连接] Vary: Accept-Encoding [告诉下游代理是使用缓存响应还是从原始服务器请求] Cache-Control: private [告诉所有的缓存机制是否可以缓存及哪种类型] Set-Cookie: uuid=**; expires=Sat, 02-Jan-2016 08:13:49 GMT; path=/ [设置 Http Cookie] Set-Cookie: ViewMode=contents; path=/ [设置 Http Cookie] Content-Encoding: gzip [web 服务器支持的返回内容压缩编码类型] PS：可以参考该文档 http://tools.jb51.net/table/http_header 缓存机制浏览器默认情况下，会缓存所访问的页面，这样会出现一个问题：如果用户习惯把光标停留在地址栏，然后回车来取页面，就会默认调用 cache 中取数据。 案例 1、有些网站要求及时性很高，因此要求不缓存页面。 // 指定该页面不缓存 Ie response.setDateHeader(“Expires”, -1);【针对 IE 浏览器设置不缓存】 // 为了保证兼容性. response.setHeader(“Cache-Control”, “no-cache”);【针对火狐浏览器等】 response.setHeader(“Pragma”, “no-cache”);【其他浏览器】 案例 2、有些网站要求网页缓存一定时间, 比如缓存一个小时 response.setDateHeader(“Expires”, System.currentTimeMillis()+3600*1000); // 后面一个参数表示设置的缓存保持时间，-1 表示永远不缓存 Content-Type 消息头Content-Type，内容类型，一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件 PS：其作用就是告诉浏览器，该服务器返回的网页中消息体是什么格式的，该以什么编码格式来读取这个网页。 因为该类型很多，故给出参考文档，以备后用：http://tools.jb51.net/table/http_content_type 案例 1：定时刷新 Refresh 的使用 response.setHeader(“Refresh”, “5;url=/servletPro/Servlet2”); // 5 秒后刷新并跳转到 url 后的链接。通过这个可以实现页面定时刷新。 案例 2：文件下载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.pc;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet7 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); // 演示下载文件 response.setHeader("Content-Disposition", "attachment; file); // 打开文件 // 1.获取到要下载文件的全路径 String path = this.getServletContext().getRealPath("/EVO_120G.jpg"); // 测试 System.out.println("path=" + path); // 2.创建文件输入流 FileInputStream fis = new FileInputStream(new File(path)); // 做一个缓冲字符数组 byte buff[] = new byte[1024]; int length = 0; // 3.指向response的输出流 OutputStream os = response.getOutputStream(); // 4.循环读出 // length表示每次实际读入的字节数 while((length = fis.read(buff)) != -1)&#123; os.write(buff, 0, length); &#125; // 关闭 os.close(); fis.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; HttpServletResponse 说明基本概述HttpServletResponse 是用于将 Servlet 处理好的内容发送给浏览器的类，服务器通过对 HttpServletResponse 对象中的内容进行截取、拼接就能获得一个完整的 HTTP 响应信息。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html 常用方法public void addHeader(String name,String value) // 添加一个消息头到 HttpServletResponse 对象中去。 public void setHeader(String name,String value) // 重设一个消息头，其与 addHeader 的区别是，add 是添加 (重复也行)，set 表示的是，如果有该消息头就覆盖它，没有就创建它 public void setStatus(int sc) // 设置响应消息的状态码，具体可以参照我的另一篇博客 HTTP 协议入门 public void sendRedirect(String location) throws java.io.IOException // 这个方法在与 request 的 getRequestDispatch() 比较时，会探讨 public ServletOutputStream getOutputStream() throws java.io.IOException // 得到一个二进制输出流，可以回送任意格式数据数据 public java.io.PrintWriter getWriter() throws java.io.IOException // 得到一个字符输出流，可以回送字符数据 getWriter() 和 getOutputStream() 的区别getWriter() 用于向客户机回送字符数据 getOutputStream() 返回的对象，可以回送字符数据，也可以回送字节数据 (二进制数据) OutputStream os=response.getOutputStream(); os.write(“hello,world”.getBytes()); PS：通过该方法也能用 getOutputStream() 回送字符数据 如何选择如果是回送字符数据，则使用 PrintWriter 对象 , 效率高 如果是回送字节数据 (binary date) , 则只能使用 OutputStream 注意事项PrintWriter,OutputStream 这两个流不能同时使用 比如： OutputStream os=response.getOutputStream(); os.write(“hello,world”.getBytes()); PrintWriter out=response.getWriter(); out.println(“abc”); 会报错: java.lang.IllegalStateException: getOutputStream() has already been called for this response 不能同时使用 PrintWriter 和 OutputStream 的原因 结论：Web 服务器在完成一次 service 之后会自动关闭流，并销毁当前的 request 和 response 对象，故无法同时使用两个流。 案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.pc;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet7 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); // 演示下载文件 response.setHeader("Content-Disposition", "attachment; file); // 打开文件 // 1.获取到要下载文件的全路径 String path = this.getServletContext().getRealPath("/EVO_120G.jpg"); // 测试 System.out.println("path=" + path); // 2.创建文件输入流 FileInputStream fis = new FileInputStream(new File(path)); // 做一个缓冲字符数组 byte buff[] = new byte[1024]; int length = 0; // 3.指向response的输出流 OutputStream os = response.getOutputStream(); // 4.循环读出 // length表示每次实际读入的字节数 while((length = fis.read(buff)) != -1)&#123; os.write(buff, 0, length); &#125; // 关闭 os.close(); fis.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; Servlet 中文乱码处理发生中文乱码的原因 发生中文乱码的各种情况1、表单 form(1)post在服务器端设置成浏览器端的编码方式。 解决方法: request.setCharacterEncoding(“utf-8”); //gbk gb2312 big5 (2)get写一个工具类: 12345678910111213package com.pc.utils;public class MyTools &#123; public static String getNewString(String str) &#123; String newString=&quot;&quot;; try &#123; // 把iso-8859-1 转换成 utf-8 newString=new String(str.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return newString; &#125;&#125; 2、超链接&lt;a href=”http://www.sohu.com?name = 函数后”&gt; 测试 PS：该方法和 get 处理方法一样 3、sendRedirect() 发生乱码response.sendRedirect(“servlet 地址? username = 张三”); PS：重定向默认是 get 方法，所以处理方法参照 get。 重定向产生乱码的原因： 重定向的原理是 Web 服务器告知浏览器，要浏览器访问另一个地址，这样 HttpServletResponse 和 HttpServletRequest 对象都是不同的了，所以需要到跳转的地址再次设置才行。 4、返回浏览器显示乱码在服务端是中文，在 response 的时候，也要考虑浏览器显示是否正确, 一般通过使用： response.setContentType(“text/html;charset=utf-8”); 5、下载提示框中文乱码下载文件的时候，可能提示框是中文乱码 String temp=java.net.URLEncoder.encode(“演员. mp3”,”utf-8”); response.setHeader(“Content-Disposition”,”attachment; filename=”+temp); PS：应当尽量使用 post 方式提交，因为 post 方式提交处理该问题简单，而 get 方式就有点麻烦了。 HttpServletRequest 说明基本概述该对象是有 Web 服务器创建的，每一次请求都会创建一次。其作用是将 HTTP 请求封装成一个类，供 Servlet 处理。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html 常用方法getRequestURL 方法返回客户端发出请求时的完整 URL。 getRequestURI 方法返回请求行中的资源名部分。 getQueryString 方法返回请求行中的参数部分 (参数名 + 值)。 该函数可以获取请求部分的数据 比如 http://localhost/web名?username=abc&amp;pwd=123 request.getQueryString(); 就会得到 username=abc&amp;pwd=123 getRemoteAddr 方法返回发出请求的客户机的 IP 地址 getRemoteHost 方法返回发出请求的客户机的完整主机名 getRemotePort 方法返回客户机所使用的网络端口号 客户机的端口号是随机选择的，web 服务器的端口号是一定的 getLocalPort 方法返回 web 服务器所使用的网络端口号 getLocalAddr 方法返回 WEB 服务器的 IP 地址。 getLocalName 方法返回 WEB 服务器的主机名 getMothod 方法返回浏览器的提交方式 &lt;h3 data-line=)URL(统一资源定位符) 和 URI(统一资源标识符) 的区别 案例： URL=http://localhost:8080/web1/Servlet7 完整的请求 Uri=/web1/Servlet7 web 应用的名称 + 资源的名称 获取用户提交的内容 (通过表单)案例： 123456789101112131415161718192021222324252627282930package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInfoForm extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); out.println("&lt;form action='/servletPro3/RegisterCl' method='post'&gt;&lt;br/&gt;"); out.println("&lt;input type='hidden' value='abc' ); out.println("用户名:&lt;input type='text' ); out.println("密 码:&lt;input type='password' ); out.println("性 别:&lt;input type='radio' ); out.println("你的爱好:&lt;input type='checkbox' name='hobby' value='音乐'&gt;音乐 &lt;input type='checkbox' name='hobby' value='体育'&gt;体育 &lt;input type='checkbox' name='hobby' value=\"旅游\"&gt;旅游&lt;br/&gt;"); out.println("所在城市:&lt;select ); out.println("你的介绍:&lt;textarea cols='20' rows='10' ); out.println("提交照片:&lt;input type='file' ); //什么时候使用hidden传输数据 1.不希望用户看到该数据 2\. 不希望影响界面，同时使用该数据 out.println("&lt;input type='submit' value='提交信息'/&gt;"); out.println("&lt;/form&gt;"); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 接受信息的 Servlet: 12345678910111213141516171819202122232425262728293031323334353637383940package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class RegisterCl extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); String u=request.getParameter("username"); String p=request.getParameter("pwd"); String sex=request.getParameter("sex"); //如果接受复选框的内容，则使用getparameterValues String [] hobbies=request.getParameterValues("hobby"); String city=request.getParameter("city"); String intro=request.getParameter("intro"); String hidden1=request.getParameter("hidden1"); out.println("用户名="+u+"&lt;br/&gt;"); out.println("密 码="+p+"&lt;br/&gt;"); out.println("性 别="+sex+"&lt;br/&gt;"); if(hobbies!=null)&#123; for(int i=0;i&lt;hobbies.length;i++)&#123; out.println("爱好:"+hobbies[i]); &#125; &#125;else&#123; out.println("无爱好"); &#125; out.println("&lt;br/&gt;所在城市:"+city); out.println("&lt;br/&gt;个人介绍:"+intro); out.println("&lt;br/&gt;隐藏数据:"+hidden1); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; Servlet 传递数据方式基本概述Servlet 传递数据的方式有很多，这里提供五种方式： 1、静态变量 2、HttpServletResponse 的 sendRedirect() 方法 3、HttpServletRequest 的 getRequestDispatch() 方法 4、HttpServletRequest 的 getSession() 方法 5、HttpServletRequest 的 setAttribute() 方法 静态变量通过建立一个数据类来进行传递。 案例： public class MyData{ public static String data; // 通过使用该类来实现数据传递 } HttpServletResponse 的 sendRedirect() 方法sendRedirect() 方法是让浏览器重定向到另一个链接。其内部原理是设置状态码为 303，并设置相应的 Location 响应头。 基本语法： response.sendRedirect(“/Web 应用名 / 资源名? u+password); response.sendRedirect(“servlet 的地址? 参数名 = 参数值 &amp; 参数名 = 参数值…”); 参照值是 String , 参数名应当使用 字母组合 在接受数据的 Servlet 中： String 参数 = request.getParameter(“参数名”); 基本原理图 PS：使用重定向不能使用 PrintWrite，ServletOutputStream 这样的流。因为重定向已经将消息返回给浏览器，其数据流也就没必要使用了。 HttpServletRequest 的 getRequestDispatch() 方法getRequestDispatch() 方法是使 WEB 服务器从当前 Servlet 转发到当前应用下的另一个 Servlet。 基本语法： request.getRequestDispatcher(资源地址).forward(request,response); 资源地址：不需要项目名。因为它只能在 WEB 服务器内部转发。 基本原理图 PS：getRequestDispatcher() 请求转发可以一直转发下去，只要最终会处理并给服务器相应内容就行了。而且请求转发不会改变浏览器的 URL，sendRedirect() 会改变 URL。 注意事项： 1、使用 forward 不能转发到该 WEB 应用外的 URL2、因为 forward 发生在文本服务器内，所以 Servlet1、Servlet2 等等，只要一直转发，使用的都是相同的 request 和 response HttpServletRequest 的 getSession() 方法getSession() 方法会获取一个会话，这个内容会在另一篇博客会话技术中详细说明。 基本语法： 1、放入 session：request.getSession.setAttribute(“loginUser”,username); 2、取出 session：request.getSession.getAttribute(“loginUser”); PS：该方法可以传递对象 案例： 放入： User user= new User(); user.setName(“zs”); user.setPassWord(“123”); request.getSession.setAttribute(“userObj”,userObj); 取出： User user=(User)request.getSession.getAttribute(“userObj”); HttpServletRequest 的 setAttribute() 方法setAttribute() 方法可以设置一个键值对，该键值对在该 request 的有效期内都可以使用。相应的还有 removeAttribute() 注销键值对的方法。该方法经常和 getRequestDispatch() 一起使用。 基本语法： setAttribute(name, value); PS：request 的 Attribute 在一次请求中有效。一次请求：没有将响应消息返回给浏览器就视为一次请求。 比较 sendRedirect() 和 forward(request,response)1、sendRedirect() 重定向，forward() 转发 2、实际发生的位置不一样 sendRedirect 发生在浏览器 forward 发生在 web 服务器 3、使用用法不一样 request.getRequestDispatcher(“/ 资源 URI”).forward(request,response) response.sendRedirect(“/web 应用 / 资源 URI”); 4、能够去 URL 范围不一样 sendRedirect 可以去任意 URL forward 只能去当前的 WEB 应用的资源 Cookie 入门基本概述Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie 也可以叫做浏览器缓存。 因为 HTTP 是无状态的协议，它不能保存用户状态，这时候往往会用到 Cookie 技术来对用户进行标识并进行一些特定的处理。服务器可以利用 Cookies 包含信息的任意性来筛选并经常性维护这些信息，以判断在 HTTP 传输中的状态。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html Cookie 原理图 案例： 123456789101112131415161718192021222324252627282930313233343536package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：设置Cookie */public class Servlet8 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); PrintWriter out = response.getWriter(); // 创建Cookie (api) Cookie cookie = new Cookie("Switch", "123456"); // 设置cookie的生命周期 cookie.setMaxAge(3600); // 把cookie信息会写给浏览器 response.addCookie(cookie); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * * @author Switch * 功能：获取Cookie * */public class Servlet9 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 获取客户端发过来的所有cookie Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; // 测试 // System.out.println(cookies.length); for(Cookie c : cookies)&#123; out.println(c.getName() + &quot; &quot; + c.getValue()); &#125; &#125; out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.pc;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：测试Cookie同名会发生什么情况 */public class Servlet10 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 创建Cookie (api) Cookie cookie1 = new Cookie(&quot;Switch2&quot;, &quot;123456&quot;); // 设置cookie的生命周期 cookie1.setMaxAge(3600); // 把cookie信息会写给浏览器 response.addCookie(cookie1); // 同名会后面的会覆盖前面的Cookie Cookie cookie2 = new Cookie(&quot;Switch2&quot;, &quot;654321&quot;); // 设置cookie的生命周期 cookie2.setMaxAge(3600); // 把cookie信息会写给浏览器 response.addCookie(cookie2); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 小结： 1、cookie 是在服务器创建的 2、cookie 是保存在浏览器缓存文件中的 3、cookie 的生命周期是可设置的 cookie.setMaxAge(time); // time 是以秒为单位的 如果不设置 setMaxAge 则当浏览器关闭时，该 cookie 就消亡。 4、cookie 可以被多个浏览器共享 5、cookie 是 (名 — 值) 对应关系 name 和 value 都是 String 型的 如果设置 Cookie，name 相同，则后设置会覆盖前设置 6、一个 web 应用中可以保存多个 cookie，并且会保存在浏览器缓存文件夹的同一个文件中 7、cookie 存放方式是以明文的方式，所以为了安全，要进行加密。 MD5 加密算法123456789101112131415161718192021222324252627282930313233package com.pc;import java.security.*;import java.security.spec.*;/** * @author Switch * 功能：MD5加密 */class MD5_test &#123; public final static String MD5(String s) &#123; char hexDigits[] = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; &#125;; try &#123; byte[] strTemp = s.getBytes(); MessageDigest mdTemp = MessageDigest.getInstance(&quot;MD5&quot;); mdTemp.update(strTemp); byte[] md = mdTemp.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; return null; &#125; &#125; public static void main(String[] args) &#123; System.out.print(MD5_test.MD5(&quot;Switch&quot;)); &#125;&#125; PS：MD5 是一种单向加密方式，其加密是不可逆转的，但是也可能存在破解方法，不过要一定的时间，所以建议采用 MD5 64 位加密或者是 128 位加密，该提供的方法只是 32 位加密方式。 使用 Cookie 保存用户重要信息时，比如密码、银行账号时，必须要进行加密传输存储。 案例：保存上次登录的时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.text.SimpleDateFormat;import java.util.Date;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Servlet11 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 用Cookie记录上次登录时间 boolean b = false; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; // 获取name String name = cookie.getName(); if (&quot;lasttime&quot;.equals(name)) &#123; // 显示时间 out.println(&quot;上次登录时间是：&quot; + cookie.getValue()); updateDate(response); b = true; break; &#125; &#125; &#125; if (!b) &#123; out.println(&quot;这是您第一次登录&quot;); updateDate(response); &#125; out.flush(); out.close(); &#125; private void updateDate(HttpServletResponse response) &#123; // 更新时间 SimpleDateFormat simpleDateFormat = new SimpleDateFormat( &quot;yyyy-MM-dd HH:mm:ss&quot;); String nowDate = simpleDateFormat.format(new Date()); Cookie c = new Cookie(&quot;lasttime&quot;, nowDate); // 7天有效期 c.setMaxAge(3600 * 24 * 7); response.addCookie(c); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; cookie 生命周期cookie 默认的生命周期是会话级别的，也就是说浏览器一关闭 cookie 立即失效。可以通过 setMaxAge(time) 的方法设置生命周期。 time 解释 正数 设置多少秒后失效 0 删除该cooki 负数 设置该cookie为会话级别 案例： 1234567891011//先得到该cookieCookie cookies[]=request.getCookies();for(Cookie cookie: cookies)&#123; if(cookie.getName().equals(&quot;id&quot;))&#123; System.out.println(&quot;id&quot;); //删除 cookie.setMaxAge(0); //一定带上这句话，否则不能删除 response.addCookie(cookie); &#125;&#125; PS：如果该 web 应用只有一个 cookie ，则删除该 cookie 后，在浏览器的临时文件夹下没有该 cookie 文件，如果该 web 应用有多个 cookie, 则删除一个 cookie 后，文件还在，只是该 cookie 没有。 cookie 细节1、一个浏览器最多能够存放 300 个 cookie，每个 web 站点，最多只能占用 20 个 cookie，而且一个 cookie 大小最大不能超过 4k。 2、cookie 存放中文，有可能会出现乱码的情况，这时可以采用如下方法解决 存放: String val=java.net.URLEncoder.encode(“张三”,”utf-8”); Cookie cookie=new Cookie(“name”,val); 取出: String val=java.net.URLDecoder.decode(cookie.getValue(), “utf-8”); out.println(“name =”+val); Servlet 详解基本概述Session 在计算机中，尤其是在网络应用中，称为 “会话控制”。在计算机专业术语中，Session 是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间。具体到 Web 中的 Session 指的就是用户在浏览某个网站时，从进入网站到关闭这个网站所经过的这段时间，也就是用户浏览这个网站所花费的时间。因此从上述的定义中可以看到，Session 实际上是一个特定的时间概念。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html Session 工作原理图 Tomcat 默认是 30 分钟。 Tomcat 主目录的 conf 文件夹中的 web.xml 文件可以进行设置全局默认会话生命周期时间。 3 种设置 session 生命周期的方法1、tomcat/conf/web.xml如上图所示，将数字进行更改则行，单位为分钟。 2、在 web 应用下的 web.xml直接在中加入如图所示代码则行。 3、通过 request.getSession().setMaxInactiveInterval(time)time 是以秒为单位的。time 为正数表示用户未操作多少秒后会话失效，0 为立即失效，负数代表永不失效。 PS：session 的生命周期的时间是指用户未操作时间，也就是说当用户未操作多少秒后失效。而 cookie 的生命周期的时间指得是累积的时间，也就说无论用户访问否，只要累积过去了多少秒后就失效了。 案例： 12345678910111213141516171819202122232425262728293031323334353637383940package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.net.URLDecoder;import java.net.URLEncoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class Servlet12 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); PrintWriter out = response.getWriter(); // 访问session [当发现没用session时，就会自动创建session] HttpSession session = request.getSession(); // 给该session放入属性，可以加入对象 String val = URLEncoder.encode("张三", "utf-8"); session.setAttribute("name", val); session.setAttribute("age", 20); // session的生命周期(默认30min,可以修改) // time指的是等待时间，如果超过这个时间，则会自动释放该会话 // session.setMaxInactiveInterval(time); out.println("创建session并放入属性"); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.net.URLDecoder;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class Servlet13 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 获取Session HttpSession session = request.getSession(); // 获取属性 String name = (String) session.getAttribute(&quot;name&quot;); Integer age = (Integer) session.getAttribute(&quot;age&quot;); // 删除name属性 //session.removeAttribute(&quot;name&quot;); if (name != null &amp;&amp; age != null) &#123; out.println(URLDecoder.decode(name, &quot;utf-8&quot;) + &quot; &quot; + age); &#125; out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 小结1、session 存在于服务器的内存中 2、一个用户浏览器, 独享一个 session 域对象 3、session 中的属性的默认生命周期是 30min ，你可以通过 web.xml 来修改 4、session 中可以存放多个属性 5、session 可以存放对象 6、如果 request.getSession().setAttribute(“name”,val) , 如果名字重复，则会替换该属性. 7、生命周期设置优先级顺序为 setMaxInactiveInterval &gt; web 应用下的 web.xml 设置 &gt; tomcat/conf/web.xml 下的设置 8、1,2 两种方法之所以不能是秒级的一个关键原因是因为太耗费资源，3 能是秒级的原因是因为它是对单个 Session 进行监控。 9、session 生命周期时间指得是用户未操作时间，当用户访问后，有从新计时，可以采取如下几种方式使 session 或者其中属性失效。 1、重启、reload 应用、关机，session 会完全失效。 2、通过 request.getSession().invalidate() 让 session 中所有属性失效。 3、通过 request.getSession().removeAttribute() 让 session 中某一属性失效、 Session 工作原理更深入的理解 PS：JSESSIONID 是 Session 自动生成的用于唯一表示 Session 对象的一个 ID 号，通过该 ID 号服务器可以对每一个浏览器进行标识。 JSESSION 控制 session 销毁时间当关闭浏览器之后，因为 session 默认返回的 Cookie 是会话级别的，所以即使服务器那端 session 并没有失效，再打开浏览器也无法使用之前的会话了。不过可以通过重设 JSESSIONID 这个 Cookie 来实现有效期持续到 session 生命周期完。 案例： 1234567891011public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); HttpSession session = request.getSession(); session.setAttribute(&quot;name&quot;, &quot;张三&quot;); out.println(&quot;创一个session并放入姓名属性&quot;); //把该session id保存cookie，在id时，一定要按照规范命名，这里区分大小写 Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId()); cookie.setMaxAge(60*30); response.addCookie(cookie);&#125; 1234567 public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); HttpSession httpSession = request.getSession(); String name = (String) httpSession.getAttribute(&quot;name&quot;); out.println(&quot;name = &quot;+name);&#125; Cookie 禁用后使用 Session 的方法cookie 禁用后可以使用 URL 重写的方法，来实现 Session。 基本语法：response.encodeRedirectURL(java.lang.String url) 用于对 sendRedirect 方法后的 url 地址进行重写 response.encodeURL(java.lang.String url) 用于对表单 action 和超链接的 url 地址进行重写 encodeURL (String url) 方法的实现机制为：先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url，再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。 cookie 与 session 的比较1、存在的位置cookie：存在客户端的临时文件夹 session：存在服务器内存中，一个 session 域对象为一个用户浏览器服务 2、安全性cookie：是以明文的方式放在客户端的，安全性弱，可以通过（MD5）加密再存放。 session：是存放在服务器内存中，所有安全性好 3、网络传输cookie：属性值会传递信息给服务器 session：属性值不会给客户端 4、生命周期cookie 的生命周期：是累计时间，即如果我们给 cookie 设置 setMaxAge（30），则 30 秒后失效。 session 的生命周期：是间隔时间，如我们设置 session 20min，指在 20min 内，如果没有访问 session，则 session 失效（session 失效是指无法读取 session 属性）， 在以下情况 session 也会失效 （1）关闭 tomcat （2）reload web 应用 （3）时间到 （4） 调用 invalidate 方法 5、作用范围cookie：能够被多个浏览器共享 session：只能一个浏览器使用 6、使用原则session：因为 session 会占用服务器的内存，因此不要向 session 中存放过多过大的对象，会影响性能。 cookie：不要将太多数据放置在 cookie 中，这样会使用大量带宽。 过滤器 Filter基本概述Java 中的 Filter 并不是一个标准的 Servlet ，它不能处理用户请求，也不能对客户端生成响应。 主要用于对 HttpServletRequest 进行预处理，也可以对 HttpServletResponse 进行后处理，是个典型的处理链。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html 参考博客：http://blog.csdn.net/sd0902/article/details/8395641 开发过滤器的步骤1、创建继承 HttpServlet 同时实现 Filter 接口 默认 filter 不生效，需要配置. 123456789&lt;!-- 配置的一个filter --&gt; &lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.pc.filter.MyFilter&lt;/filter-class&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; /*表示对该WEB的所有网页都过滤 &lt;/filter-mapping&gt; 2、在 filter 的方法中添加业务逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243package com.pc.filter;import java.io.*;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.pc.domain.User;public class MyFilter1 extends HttpServlet implements Filter &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)hrows ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125; public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) throws IOException, ServletException &#123; System.out.print(&quot;myfilter1...&quot;); //获取sessionHttpServletRequest httpServletRequest=(HttpServletRequest)request; //看看请求的资源是什么 String uri=httpServletRequest.getRequestURI(); if(uri.startsWith(&quot;/UsersManager3/imgs&quot;)||uri.startsWith(&quot;/UsersManager3/Login&quot;))&#123; // 该过滤器放行，进入下一个过滤器 chain.doFilter(request, response); &#125;else&#123; HttpSession session=httpServletRequest.getSession(); User user=(User) session.getAttribute(&quot;loginuser&quot;); if(user!=null)&#123; //该用户合法,放行 chain.doFilter(request, response); &#125;else&#123; request.setAttribute(&quot;err&quot;, &quot;请好好登陆&quot;); httpServletRequest.getRequestDispatcher(&quot;/LoginServlet&quot;) .forward(request, response); &#125; &#125; &#125; public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 过滤器链过滤器链的概念很容易理解，就是在配置过滤器时，多个过滤器加载进内存中时，当使用过滤器之后调用 chain.doFilter(request, response);WEB 服务器会按配置顺序决定下一个调用的过滤器是什么。这就可以视为过滤器链。 简易购物车就是一个简单的购物车，还可以扩展。 实现原理： 用户在 ShowBook 页面购书，BuyBookCl 进行业务逻辑处理之后，显示在 ShowMyCart 上。Book 是图书信息类，DB 是一个内存图书数据库，用来存放初始化图书信息。 使用技术： 1、JAVASE 中的 ArrayList,HashMap,LinkedHashMap 2、Session 技术 3、Servlet 技术 4、单例 123456789101112131415161718192021222324252627282930313233343536373839404142package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.util.ArrayList;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：显示图书 */ public class ShowBook extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;h1&gt;欢迎购买&lt;/h1&gt;&quot;); // 取出DB ArrayList&lt;Book&gt; db = DB.getBooks(); for(Book book : db)&#123; out.println(book.getName() + &quot;&lt;a href=&apos;/MyCart/BuyBookCl?id=&quot;+ book.getId() + &quot;&amp;); &#125; out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedHashMap;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：处理购书信息 */public class BuyBookCl extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); // 接收用户购书信息 String bookname = request.getParameter(&quot;name&quot;); String id = request.getParameter(&quot;id&quot;); String price = request.getParameter(&quot;price&quot;); // 从会话获取总价 Float totalprice = (Float) request.getSession().getAttribute(&quot;totalprice&quot;); // 将总价加入会话中 if(totalprice == null)&#123; request.getSession().setAttribute(&quot;totalprice&quot;, Float.parseFloat(price)); &#125; else &#123; request.getSession().setAttribute(&quot;totalprice&quot;, totalprice + Float.parseFloat(price)); &#125; // 从session中取出mybooks HashMap&lt;String, Book&gt; books = (HashMap&lt;String, Book&gt;) request.getSession().getAttribute(&quot;mybooks&quot;); // 如果是第一次购物 books == 空 if(books == null)&#123; // 创建集合对象 books = new LinkedHashMap&lt;String, Book&gt;(); // 创建book对象 Book book = new Book(); book.setId(id); book.setName(bookname); // 设置图书数量为1 book.setNum(1); books.put(id, book); // 将bookd加入session request.getSession().setAttribute(&quot;mybooks&quot;, books); &#125; else &#123; // 检测集合中是否有该书 if(books.containsKey(id))&#123; // 表示数已被购买过 // 从集合中取出图书 Book book = books.get(id); // 数量+1 book.setNum(book.getNum() + 1); &#125; else &#123; // 该图书未被购买过 Book book = new Book(); book.setId(id); book.setName(bookname); book.setNum(1); books.put(id, book); &#125; &#125; // 转发到显示购物车界面 request.getRequestDispatcher(&quot;/ShowMyCart&quot;).forward(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.pc;import java.io.IOException;import java.io.PrintWriter;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @author Switch * 功能：显示购物车 */public class ShowMyCart extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 字符编码 request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); // 从session中取出购买的书 HashMap&lt;String, Book&gt; books = (HashMap&lt;String, Book&gt;) request.getSession().getAttribute(&quot;mybooks&quot;); // 测试 // System.out.println(books); out.println(&quot;您的购物车有以下书籍：&lt;br/&gt;&quot;); Iterator iterator = books.keySet().iterator(); while(iterator.hasNext())&#123; Book book = books.get(iterator.next()); out.println(&quot;书名为：&quot; + book.getName() + &quot; 数量为：&quot; + book.getNum()); out.println(&quot;&lt;br/&gt;&quot;); &#125; out.println(&quot;总价为：&quot; + request.getSession().getAttribute(&quot;totalprice&quot;)); out.println(&quot;&lt;br/&gt;&quot;); out.println(&quot;&lt;a href=&apos;/MyCart/ShowBook&apos;&gt;返回购物大厅&lt;/a&gt;&quot;); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package com.pc;/** * @author Switch * 功能：存储图书信息 * id------id号 * name----书名 * num-----数量 * price---价格 */public class Book &#123; private String id; private String name; private int num; private float price; // 设置器与获取器 public String getId() &#123; return id; &#125; public float getPrice() &#123; return price; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.pc;import java.io.Serializable;import java.util.ArrayList;/** * * @author Switch * 功能：模拟内存数据库,单例实现 * */public final class DB implements Serializable&#123; private static ArrayList&lt;Book&gt; books = null; private DB()&#123; &#125; // 静态代码块初始化图书信息 static&#123; books = new ArrayList&lt;Book&gt;(); Book book1 = new Book(); book1.setId(&quot;1&quot;); book1.setName(&quot;Think in Java&quot;); book1.setPrice(99); books.add(book1); Book book2 = new Book(); book2.setId(&quot;2&quot;); book2.setName(&quot;Javascript权威指南&quot;); book2.setPrice(139); books.add(book2); Book book3 = new Book(); book3.setId(&quot;3&quot;); book3.setName(&quot;Head First Servlet &amp; JSP&quot;); book3.setPrice(129); books.add(book3); Book book4 = new Book(); book4.setId(&quot;4&quot;); book4.setName(&quot;设计模式之禅&quot;); book4.setPrice(89); books.add(book4); Book book5 = new Book(); book5.setId(&quot;5&quot;); book5.setName(&quot;Java核心技术&quot;); book5.setPrice(139); books.add(book5); &#125; // 返回图书集合 public static ArrayList&lt;Book&gt; getBooks() &#123; return books; &#125;&#125; ServletContext基本概述servletContext 接口是 Servlet 中最大的一个接口，呈现了 web 应用的 Servlet 视图。ServletContext 实例是通过 getServletContext() 方法获得的，由于 HttpServlet 继承 GenericServlet 的关系，GenericServlet 类和 HttpServlet 类同时具有该方法。 每个应用都会有一个 ServletContext 对象与之关联, 当容器分布在在多个虚拟机上时，web 应用在所分布的每个虚拟机上都拥有一个 ServletContext 实例. 缺省情况下，ServletContext 不是分布式的，并且只存在于一个虚拟机上。 参考文档：http://tomcat.apache.org/tomcat-5.5-doc/servletapi/index.html ServletContext 原理图 PS：一个 WEB 服务器上所有的 Servlet 共享一个 ServletComtext。 小结1、ServletContext 是在服务器 2、ServletContext 是被所有客户端共享 3、ServletContext 是当 web 应用启动的时候，自动创建 4、ServletContext 当 web 应用关闭 / tomcat 关闭 / 对 web 应用 reload 会造成 servletContext 销毁 5、ServletContext 与 Session、Request 一样都能存入属性、取出属性，但是其作用域和生命周期是不同的 1、ServletContext 作用域是整个 WEB 应用，生命周期是从服务器启动到关闭 2、Session 作用域是对应的会话，生命周期是从会话创建到会话销毁 3、Request 作用域是一次响应，生命周期是一次响应 (服务器将 HTTP 响应发给浏览器) 6、ServletContext 能够通过以下几种方式使用1、获取 this.getServletConfig().getServletContext(); this.getServletContext(); // 两种效果一样，推荐下面这种 2、添加属性 this.getServletContext().setAttribute(String,Object); 3、取出属性 this.getServletContext().getAttribute(属性名); 4、移除属性 // 注意：同Session、Request 一样，移除属性只能一个一个移除 this.getServletContext().removeAttribute(属性名); ServletContext 应用1、获取 WEB 应用的初始化参数12345&lt;!-- 如果希望所有的servlet都可以访问该配置. --&gt;&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;scott&lt;/param-value&gt;&lt;/context-param&gt; 如何获取 1String val= this.getServletContext().getInitParameter(&quot;name&quot;); 2、使用 ServletContext 实现跳转1234567891011//目前我们跳转到下一个页面//1 response.sendRedirect(&quot;/web应用名/资源名&quot;);//2 request.getRequestDispatcher(&quot;/资源名&quot;).forward(request, response);/** 区别1\. getRequestDispatcher 一个跳转发生在web服务器 sendRedirect发生在浏览器 * 2\. 如果request.setAttribute(&quot;name&quot;,&quot;Switch&quot;) 希望下一个页面可以使用属性值，则使用 getRequestDispatcher* 3\. 如果session.setAttribute(&quot;name2&quot;,&quot;Switch2&quot;), 希望下一个页面可以使用属性值，则两个方法均可使用,但是建议使用 getRequestDispatcher* 4\. 如果我们希望跳转到本web应用外的一个url,应使用sendRedirect *///3.这种方法和2一样this.getServletContext().getRequestDispatcher(&quot;/资源url&quot;).forward(request, response); 3、读取文件，和获取文件全路径123456789101112//首先读取到文件InputStream inputStream=this.getServletContext().getResourceAsStream(&quot;dbinfo.properties&quot;);//创建PropertiesProperties pp=new Properties();pp.load(inputStream);out.println(&quot;));//如果文件放在src目录下，应该使用类加载器来读取//InputStream is=Servlet5.class.getClassLoader().getResourceAsStream(&quot;dbinfo.properties&quot;);//获取文件全路径//读取到一个文件的全路径String path=this.getServletContext().getRealPath(&quot;/imgs/Sunset.jpg&quot;);out.println(&quot;paht = &quot;+path); 用户管理系统基本概述该系统是一个简单的用户管理系统，目前实现的功能不是很多，但是可以扩展。其结构采用的是 MVC 模式。 MVC 模型示意图 系统框架图 开发目录结构图 注意事项：数据库采用的是 Oracle 数据库，用户名，密码之类的在上图的 dbinfo.properties 文件下更改，使用其他数据库也是在该文件下更改驱动名称。 SQL1234567891011121314151617181920212223242526272829303132333435363738394041424344create table users( id number primary key, --id username varchar2(32) not null, --用户名 email varchar2(64) not null, --电子邮箱 grade number default 1, --等级 1-&gt;5 1为普通用户，5为管理员 passwd varchar2(32) not null --密码);--插入测试数据insert into users values(1,&apos;zhangsan&apos;,&apos;zhangsan@switch.com&apos;,1,&apos;123456&apos;);insert into users values(2,&apos;lisi&apos;,&apos;lisi@switch.com&apos;,1,&apos;123456&apos;);insert into users values(3,&apos;wangwu&apos;,&apos;wangwu@switch.com&apos;,1,&apos;123456&apos;);insert into users values(4,&apos;zhaoliu&apos;,&apos;zhaoliu@switch.com&apos;,1,&apos;123456&apos;);insert into users values(5,&apos;switch&apos;,&apos;switch@switch.com&apos;,5,&apos;switch&apos;);insert into users values(6,&apos;AAA&apos;,&apos;AAA@switch.com&apos;,1,&apos;123456&apos;);insert into users values(7,&apos;BBB&apos;,&apos;BBB@switch.com&apos;,1,&apos;123456&apos;);insert into users values(8,&apos;CCC&apos;,&apos;CCC@switch.com&apos;,1,&apos;123456&apos;);insert into users values(9,&apos;DDD&apos;,&apos;DDD@switch.com&apos;,1,&apos;123456&apos;);insert into users values(10,&apos;EEE&apos;,&apos;EEE@switch.com&apos;,1,&apos;123456&apos;);insert into users values(11,&apos;FFF&apos;,&apos;FFF@switch.com&apos;,1,&apos;123456&apos;);insert into users values(12,&apos;GGG&apos;,&apos;GGG@switch.com&apos;,1,&apos;123456&apos;);insert into users values(13,&apos;HHH&apos;,&apos;HHH@switch.com&apos;,1,&apos;123456&apos;);insert into users values(14,&apos;AAA&apos;,&apos;AAA@switch.com&apos;,1,&apos;123456&apos;);insert into users values(15,&apos;BBB&apos;,&apos;BBB@switch.com&apos;,1,&apos;123456&apos;);insert into users values(16,&apos;CCC&apos;,&apos;CCC@switch.com&apos;,1,&apos;123456&apos;);insert into users values(17,&apos;DDD&apos;,&apos;DDD@switch.com&apos;,1,&apos;123456&apos;);insert into users values(18,&apos;EEE&apos;,&apos;EEE@switch.com&apos;,1,&apos;123456&apos;);insert into users values(19,&apos;FFF&apos;,&apos;FFF@switch.com&apos;,1,&apos;123456&apos;);insert into users values(20,&apos;GGG&apos;,&apos;GGG@switch.com&apos;,1,&apos;123456&apos;);insert into users values(21,&apos;HHH&apos;,&apos;HHH@switch.com&apos;,1,&apos;123456&apos;);insert into users values(22,&apos;HHH&apos;,&apos;HHH@switch.com&apos;,1,&apos;123456&apos;);--分页语句select * from (select u.*,rownum rn from (select * from users order by id) u where rownum &lt;= 6) where rn &gt;=4;--序列自增长create sequence users_seqstart with 100increment by 1minvalue 100nomaxvaluenocyclenocache; 源代码：http://download.csdn.net/detail/q547550831/9391557 导入 MyEclipse 就能用了。 原文：Servlet学习笔记https://www.kancloud.cn/digest/switch-servlet/120123]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet 工作原理解析]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-1%2F</url>
    <content type="text"><![CDATA[Servlet 工作原理解析从 Servlet 容器说起要介绍 Servlet 必须要先把 Servlet 容器说清楚，Servlet 与 Servlet 容器的关系有点像枪和子弹的关系，枪是为子弹而生，而子弹又让枪有了杀伤力。虽然它们是彼此依存的，但是又相互独立发展，这一切都是为了适应工业化生产的结果。从技术角度来说是为了解耦，通过标准化接口来相互协作。既然接口是连接 Servlet 与 Servlet 容器的关键，那我们就从它们的接口说起。 前面说了 Servlet 容器作为一个独立发展的标准化产品，目前它的种类很多，但是它们都有自己的市场定位，很难说谁优谁劣，各有特点。例如现在比较流行的 Jetty，在定制化和移动领域有不错的发展，我们这里还是以大家最为熟悉 Tomcat 为例来介绍 Servlet 容器如何管理 Servlet。Tomcat 本身也很复杂，我们只从 Servlet 与 Servlet 容器的接口部分开始介绍，关于 Tomcat 的详细介绍可以参考我的另外一篇文章《 Tomcat 系统架构与模式设计分析》。 Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式。 图 1 . Tomcat 容器模型 从上图可以看出 Tomcat 的容器分为四个等级，真正管理 Servlet 的容器是 Context 容器，一个 Context 对应一个 Web 工程，在 Tomcat 的配置文件中可以很容易发现这一点，如下： 清单 1 Context 配置参数12&lt;Context path="/projectOne " docBase="D:\projects\projectOne"reloadable="true" /&gt; 下面详细介绍一下 Tomcat 解析 Context 容器的过程，包括如何构建 Servlet 的过程。 Servlet 容器的启动过程Tomcat7 也开始支持嵌入式功能，增加了一个启动类 org.apache.catalina.startup.Tomcat。创建一个实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。 清单 2 . 给 Tomcat 增加一个 Web 工程1234567Tomcat tomcat = getTomcatInstance(); File appDir = new File(getBuildDirectory(), "webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/examples/servlets/servlet/HelloWorldExample"); assertTrue(res.toString().indexOf("&lt;h1&gt;Hello World!&lt;/h1&gt;") &gt; 0); 清单 2的代码是创建一个 Tomcat 实例并新增一个 Web 应用，然后启动 Tomcat 并调用其中的一个 HelloWorldExample Servlet，看有没有正确返回预期的数据。 Tomcat 的 addWebapp 方法的代码如下： 清单 3 .Tomcat.addWebapp1234567891011121314151617181920public Context addWebapp(Host host, String url, String path) &#123; silence(url); Context ctx = new StandardContext(); ctx.setPath( url ); ctx.setDocBase(path); if (defaultRealm == null) &#123; initSimpleAuth(); &#125; ctx.setRealm(defaultRealm); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); if (host == null) &#123; getHost().addChild(ctx); &#125; else &#123; host.addChild(ctx); &#125; return ctx; &#125; 前面已经介绍了一个 Web 应用对应一个 Context 容器，也就是 Servlet 运行时的 Servlet 容器，添加一个 Web 应用时将会创建一个 StandardContext 容器，并且给这个 Context 容器设置必要的参数，url 和 path 分别代表这个应用在 Tomcat 中的访问路径和这个应用实际的物理路径，这个两个参数与清单 1 中的两个参数是一致的。其中最重要的一个配置是 ContextConfig，这个类将会负责整个 Web 应用配置的解析工作，后面将会详细介绍。最后将这个 Context 容器加到父容器 Host 中。 接下去将会调用 Tomcat 的 start 方法启动 Tomcat，如果你清楚 Tomcat 的系统架构，你会容易理解 Tomcat 的启动逻辑，Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理着容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者（Listener），关于这个设计模式可以参考《 Tomcat 的系统架构与设计模式，第二部分：设计模式》。Tomcat 启动的时序图可以用图 2 表示。 图 2. Tomcat 主要类的启动时序图 上图描述了 Tomcat 启动过程中，主要类之间的时序关系，下面我们将会重点关注添加 examples 应用所对应的 StandardContext 容器的启动过程。 当 Context 容器初始化状态设为 init 时，添加在 Contex 容器的 Listener 将会被调用。ContextConfig 继承了 LifecycleListener 接口，它是在调用清单 3 时被加入到 StandardContext 容器中。ContextConfig 类会负责整个 Web 应用的配置文件的解析工作。 ContextConfig 的 init 方法将会主要完成以下工作： 创建用于解析 xml 配置文件的 contextDigester 对象 读取默认 context.xml 配置文件，如果存在解析它 读取默认 Host 配置文件，如果存在解析它 读取默认 Context 自身的配置文件，如果存在解析它 设置 Context 的 DocBase ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分： 创建读取资源文件的对象 创建 ClassLoader 对象 设置应用的工作目录 启动相关的辅助类如：logger、realm、resources 等 修改启动状态，通知感兴趣的观察者（Web 应用的配置） 子容器的初始化 获取 ServletContext 并设置必要的参数 初始化 “load on startup” 的 Servlet Web 应用的初始化工作Web 应用的初始化工作是在 ContextConfig 的 configureStart 方法中实现的，应用的初始化主要是要解析 web.xml 文件，这个文件描述了一个 Web 应用的关键信息，也是一个 Web 应用的入口。 Tomcat 首先会找 globalWebXml 这个文件的搜索路径是在 engine 的工作目录下寻找以下两个文件中的任一个 org/apache/catalin/startup/NO_DEFAULT_XML 或 conf/web.xml。接着会找 hostWebXml 这个文件可能会在 System.getProperty(“catalina.base”)/conf/${EngineName}/${HostName}/web.xml.default，接着寻找应用的配置文件 examples/WEB-INF/web.xml。web.xml 文件中的各个配置项将会被解析成相应的属性保存在 WebXml 对象中。如果当前应用支持 Servlet3.0，解析还将完成额外 9 项工作，这个额外的 9 项工作主要是为 Servlet3.0 新增的特性，包括 jar 包中的 META-INF/web-fragment.xml 的解析以及对 annotations 的支持。 接下去将会将 WebXml 对象中的属性设置到 Context 容器中，这里包括创建 Servlet 对象、filter、listener 等等。这段代码在 WebXml 的 configureContext 方法中。下面是解析 Servlet 的代码片段： 清单 4. 创建 Wrapper 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748for (ServletDef servlet : servlets.values()) &#123; Wrapper wrapper = context.createWrapper(); String jspFile = servlet.getJspFile(); if (jspFile != null) &#123; wrapper.setJspFile(jspFile); &#125; if (servlet.getLoadOnStartup() != null) &#123; wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); &#125; if (servlet.getEnabled() != null) &#123; wrapper.setEnabled(servlet.getEnabled().booleanValue()); &#125; wrapper.setName(servlet.getServletName()); Map&lt;String,String&gt; params = servlet.getParameterMap(); for (Entry&lt;String, String&gt; entry : params.entrySet()) &#123; wrapper.addInitParameter(entry.getKey(), entry.getValue()); &#125; wrapper.setRunAs(servlet.getRunAs()); Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) &#123; wrapper.addSecurityReference( roleRef.getName(), roleRef.getLink()); &#125; wrapper.setServletClass(servlet.getServletClass()); MultipartDef multipartdef = servlet.getMultipartDef(); if (multipartdef != null) &#123; if (multipartdef.getMaxFileSize() != null &amp;&amp; multipartdef.getMaxRequestSize()!= null &amp;&amp; multipartdef.getFileSizeThreshold() != null) &#123; wrapper.setMultipartConfigElement(new MultipartConfigElement( multipartdef.getLocation(), Long.parseLong(multipartdef.getMaxFileSize()), Long.parseLong(multipartdef.getMaxRequestSize()), Integer.parseInt( multipartdef.getFileSizeThreshold()))); &#125; else &#123; wrapper.setMultipartConfigElement(new MultipartConfigElement( multipartdef.getLocation())); &#125; &#125; if (servlet.getAsyncSupported() != null) &#123; wrapper.setAsyncSupported( servlet.getAsyncSupported().booleanValue()); &#125; context.addChild(wrapper); &#125; 这段代码清楚的描述了如何将 Servlet 包装成 Context 容器中的 StandardWrapper，这里有个疑问，为什么要将 Servlet 包装成 StandardWrapper 而不直接是 Servlet 对象。这里 StandardWrapper 是 Tomcat 容器中的一部分，它具有容器的特征，而 Servlet 为了一个独立的 web 开发标准，不应该强耦合在 Tomcat 中。 除了将 Servlet 包装成 StandardWrapper 并作为子容器添加到 Context 中，其它的所有 web.xml 属性都被解析到 Context 中，所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器，容器的配置属性由应用的 web.xml 指定，这样我们就能理解 web.xml 到底起到什么作用了。 创建 Servlet 实例前面已经完成了 Servlet 的解析工作，并且被包装成 StandardWrapper 添加在 Context 容器中，但是它仍然不能为我们工作，它还没有被实例化。下面我们将介绍 Servlet 对象是如何创建的，以及如何被初始化的。 创建 Servlet 对象如果 Servlet 的 load-on-startup 配置项大于 0，那么在 Context 容器启动的时候就会被实例化，前面提到在解析配置文件时会读取默认的 globalWebXml，在 conf 下的 web.xml 文件中定义了一些默认的配置项，其定义了两个 Servlet，分别是：org.apache.catalina.servlets.DefaultServlet 和 org.apache.jasper.servlet.JspServlet 它们的 load-on-startup 分别是 1 和 3，也就是当 Tomcat 启动时这两个 Servlet 就会被启动。 创建 Servlet 实例的方法是从 Wrapper. loadServlet 开始的。loadServlet 方法要完成的就是获取 servletClass 然后把它交给 InstanceManager 去创建一个基于 servletClass.class 的对象。如果这个 Servlet 配置了 jsp-file，那么这个 servletClass 就是 conf/web.xml 中定义的 org.apache.jasper.servlet.JspServlet 了。 创建 Servlet 对象的相关类结构图如下： 图 3. 创建 Servlet 对象的相关类结构 初始化 Servlet初始化 Servlet 在 StandardWrapper 的 initServlet 方法中，这个方法很简单就是调用 Servlet 的 init 的方法，同时把包装了 StandardWrapper 对象的 StandardWrapperFacade 作为 ServletConfig 传给 Servlet。Tomcat 容器为何要传 StandardWrapperFacade 给 Servlet 对象将在后面做详细解析。 如果该 Servlet 关联的是一个 jsp 文件，那么前面初始化的就是 JspServlet，接下去会模拟一次简单请求，请求调用这个 jsp 文件，以便编译这个 jsp 文件为 class，并初始化这个 class。 这样 Servlet 对象就初始化完成了，事实上 Servlet 从被 web.xml 中解析到完成初始化，这个过程非常复杂，中间有很多过程，包括各种容器状态的转化引起的监听事件的触发、各种访问权限的控制和一些不可预料的错误发生的判断行为等等。我们这里只抓了一些关键环节进行阐述，试图让大家有个总体脉络。 下面是这个过程的一个完整的时序图，其中也省略了一些细节。 图 4. 初始化 Servlet 的时序图 Servlet 体系结构我们知道 Java Web 应用是基于 Servlet 规范运转的，那么 Servlet 本身又是如何运转的呢？为何要设计这样的体系结构。 图 5.Servlet 顶层类关联图 从上图可以看出 Servlet 规范就是基于这几个类运转的，与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。我们很清楚 ServletRequest 和 ServletResponse 在 Servlet 运行的意义，但是 ServletConfig 和 ServletContext 对 Servlet 有何价值？仔细查看 ServletConfig 接口中声明的方法发现，这些方法都是为了获取这个 Servlet 的一些配置属性，而这些配置属性可能在 Servlet 运行时被用到。而 ServletContext 又是干什么的呢？ Servlet 的运行模式是一个典型的 “握手型的交互式” 运行模式。所谓 “握手型的交互式” 就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。 ServletConfig 是在 Servlet init 时由容器传过来的，那么 ServletConfig 到底是个什么对象呢？ 下图是 ServletConfig 和 ServletContext 在 Tomcat 容器中的类关系图。 图 6. ServletConfig 在容器中的类关联图 上图可以看出 StandardWrapper 和 StandardWrapperFacade 都实现了 ServletConfig 接口，而 StandardWrapperFacade 是 StandardWrapper 门面类。所以传给 Servlet 的是 StandardWrapperFacade 对象，这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet。 同样 ServletContext 也与 ServletConfig 有类似的结构，Servlet 中能拿到的 ServletContext 的实际对象也是 ApplicationContextFacade 对象。ApplicationContextFacade 同样保证 ServletContex 只能从容器中拿到它该拿的数据，它们都起到对数据的封装作用，它们使用的都是门面设计模式。 通过 ServletContext 可以拿到 Context 容器中一些必要信息，比如应用的工作路径，容器支持的 Servlet 最小版本等。 Servlet 中定义的两个 ServletRequest 和 ServletResponse 它们实际的对象又是什么呢？，我们在创建自己的 Servlet 类时通常使用的都是 HttpServletRequest 和 HttpServletResponse，它们继承了 ServletRequest 和 ServletResponse。为何 Context 容器传过来的 ServletRequest、ServletResponse 可以被转化为 HttpServletRequest 和 HttpServletResponse 呢？ 图 7.Request 相关类结构图 上图是 Tomcat 创建的 Request 和 Response 的类结构图。Tomcat 一接受到请求首先将会创建 org.apache.coyote.Request 和 org.apache.coyote.Response，这两个类是 Tomcat 内部使用的描述一次请求和相应的信息类它们是一个轻量级的类，它们作用就是在服务器接收到请求后，经过简单解析将这个请求快速的分配给后续线程去处理，所以它们的对象很小，很容易被 JVM 回收。接下去当交给一个用户线程去处理这个请求时又创建 org.apache.catalina.connector. Request 和 org.apache.catalina.connector. Response 对象。这两个对象一直穿越整个 Servlet 容器直到要传给 Servlet，传给 Servlet 的是 Request 和 Response 的门面类 RequestFacade 和 RequestFacade，这里使用门面模式与前面一样都是基于同样的目的——封装容器中的数据。一次请求对应的 Request 和 Response 的类转化如下图所示： 图 8.Request 和 Response 的转变过程 Servlet 如何工作我们已经清楚了 Servlet 是如何被加载的、Servlet 是如何被初始化的，以及 Servlet 的体系结构，现在的问题就是它是如何被调用的。 当用户从浏览器向服务器发起一个请求，通常会包含如下信息：http://hostname: port /contextpath/servletpath，hostname 和 port 是用来与服务器建立 TCP 连接，而后面的 URL 才是用来选择服务器中那个子容器服务用户的请求。那服务器是如何根据这个 URL 来达到正确的 Servlet 容器中的呢？ Tomcat7.0 中这件事很容易解决，因为这种映射工作有专门一个类来完成的，这个就是 org.apache.tomcat.util.http.mapper，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，当 org.apache.catalina.connector. Request 类在进入 Container 容器之前，mapper 将会根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中。所以当 Request 进入 Container 容器之前，它要访问那个子容器这时就已经确定了。 图 9.Request 的 Mapper 类关系图 可能你有疑问，mapper 中怎么会有容器的完整关系，这要回到图 2 中 19 步 MapperListener 类的初始化过程，下面是 MapperListener 的 init 方法代码 : 清单 5. MapperListener.init12345678910111213public void init() &#123; findDefaultHost(); Engine engine = (Engine) connector.getService().getContainer(); engine.addContainerListener(this); Container[] conHosts = engine.findChildren(); for (Container conHost : conHosts) &#123; Host host = (Host) conHost; if (!LifecycleState.NEW.equals(host.getState())) &#123; host.addLifecycleListener(this); registerHost(host); &#125; &#125; &#125; 这段代码的作用就是将 MapperListener 类作为一个监听者加到整个 Container 容器中的每个子容器中，这样只要任何一个容器发生变化，MapperListener 都将会被通知，相应的保存容器关系的 MapperListener 的 mapper 属性也会修改。for 循环中就是将 host 及下面的子容器注册到 mapper 中。 图 10.Request 在容器中的路由图 上图描述了一次 Request 请求是如何达到最终的 Wrapper 容器的，我们现正知道了请求是如何达到正确的 Wrapper 容器，但是请求到达最终的 Servlet 还要完成一些步骤，必须要执行 Filter 链，以及要通知你在 web.xml 中定义的 listener。 接下去就要执行 Servlet 的 service 方法了，通常情况下，我们自己定义的 servlet 并不是直接去实现 javax.servlet.servlet 接口，而是去继承更简单的 HttpServlet 类或者 GenericServlet 类，我们可以有选择的覆盖相应方法去实现我们要完成的工作。 Servlet 的确已经能够帮我们完成所有的工作了，但是现在的 web 应用很少有直接将交互全部页面都用 servlet 来实现，而是采用更加高效的 MVC 框架来实现。这些 MVC 框架基本的原理都是将所有的请求都映射到一个 Servlet，然后去实现 service 方法，这个方法也就是 MVC 框架的入口。 当 Servlet 从 Servlet 容器中移除时，也就表明该 Servlet 的生命周期结束了，这时 Servlet 的 destroy 方法将被调用，做一些扫尾工作。 Session 与 Cookie前面我们已经说明了 Servlet 如何被调用，我们基于 Servlet 来构建应用程序，那么我们能从 Servlet 获得哪些数据信息呢？ Servlet 能够给我们提供两部分数据，一个是在 Servlet 初始化时调用 init 方法时设置的 ServletConfig，这个类基本上含有了 Servlet 本身和 Servlet 所运行的 Servlet 容器中的基本信息。根据前面的介绍 ServletConfig 的实际对象是 StandardWrapperFacade，到底能获得哪些容器信息可以看看这类提供了哪些接口。还有一部分数据是由 ServletRequest 类提供，它的实际对象是 RequestFacade，从提供的方法中发现主要是描述这次请求的 HTTP 协议的信息。所以要掌握 Servlet 的工作方式必须要很清楚 HTTP 协议，如果你还不清楚赶紧去找一些参考资料。关于这一块还有一个让很多人迷惑的 Session 与 Cookie。 Session 与 Cookie 不管是对 Java Web 的熟练使用者还是初学者来说都是一个令人头疼的东西。Session 与 Cookie 的作用都是为了保持访问用户与后端服务器的交互状态。它们有各自的优点也有各自的缺陷。然而具有讽刺意味的是它们优点和它们的使用场景又是矛盾的，例如使用 Cookie 来传递信息时，随着 Cookie 个数的增多和访问量的增加，它占用的网络带宽也很大，试想假如 Cookie 占用 200 个字节，如果一天的 PV 有几亿的时候，它要占用多少带宽。所以大访问量的时候希望用 Session，但是 Session 的致命弱点是不容易在多台服务器之间共享，所以这也限制了 Session 的使用。 不管 Session 和 Cookie 有什么不足，我们还是要用它们。下面详细讲一下，Session 如何基于 Cookie 来工作。实际上有三种方式能可以让 Session 正常工作： 基于 URL Path Parameter，默认就支持 基于 Cookie，如果你没有修改 Context 容器个 cookies 标识的话，默认也是支持的 基于 SSL，默认不支持，只有 connector.getAttribute(“SSLEnabled”) 为 TRUE 时才支持 第一种情况下，当浏览器不支持 Cookie 功能时，浏览器会将用户的 SessionCookieName 重写到用户请求的 URL 参数中，它的传递格式如 /path/Servlet;name=value;name2=value2? Name3=value3，其中 “Servlet；” 后面的 K-V 对就是要传递的 Path Parameters，服务器会从这个 Path Parameters 中拿到用户配置的 SessionCookieName。关于这个 SessionCookieName，如果你在 web.xml 中配置 session-config 配置项的话，其 cookie-config 下的 name 属性就是这个 SessionCookieName 值，如果你没有配置 session-config 配置项，默认的 SessionCookieName 就是大家熟悉的“JSESSIONID”。接着 Request 根据这个 SessionCookieName 到 Parameters 拿到 Session ID 并设置到 request.setRequestedSessionId 中。 请注意如果客户端也支持 Cookie 的话，Tomcat 仍然会解析 Cookie 中的 Session ID，并会覆盖 URL 中的 Session ID。 如果是第三种情况的话将会根据 javax.servlet.request.ssl_session 属性值设置 Session ID。 有了 Session ID 服务器端就可以创建 HttpSession 对象了，第一次触发是通过 request. getSession() 方法，如果当前的 Session ID 还没有对应的 HttpSession 对象那么就创建一个新的，并将这个对象加到 org.apache.catalina. Manager 的 sessions 容器中保存，Manager 类将管理所有 Session 的生命周期，Session 过期将被回收，服务器关闭，Session 将被序列化到磁盘等。只要这个 HttpSession 对象存在，用户就可以根据 Session ID 来获取到这个对象，也就达到了状态的保持。 图 11.Session 相关类图 上从图中可以看出从 request.getSession 中获取的 HttpSession 对象实际上是 StandardSession 对象的门面对象，这与前面的 Request 和 Servlet 是一样的原理。下图是 Session 工作的时序图： 图 12.Session 工作的时序图 还有一点与 Session 关联的 Cookie 与其它 Cookie 没有什么不同，这个配置的配置可以通过 web.xml 中的 session-config 配置项来指定。 Servlet 中的 Listener整个 Tomcat 服务器中 Listener 使用的非常广泛，它是基于观察者模式设计的，Listener 的设计对开发 Servlet 应用程序提供了一种快捷的手段，能够方便的从另一个纵向维度控制程序和数据。目前 Servlet 中提供了 5 种两类事件的观察者接口，它们分别是：4 个 EventListeners 类型的，ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionAttributeListener 和 2 个 LifecycleListeners 类型的，ServletContextListener、HttpSessionListener。如下图所示： 图 13.Servlet 中的 Listener 它们基本上涵盖了整个 Servlet 生命周期中，你感兴趣的每种事件。这些 Listener 的实现类可以配置在 web.xml 中的 标签中。当然也可以在应用程序中动态添加 Listener，需要注意的是 ServletContextListener 在容器启动之后就不能再添加新的，因为它所监听的事件已经不会再出现。掌握这些 Listener 的使用，能够让我们的程序设计的更加灵活。 总结本文涉及到内容有点多，要把每个细节都说清楚，似乎不可能，本文试着从 Servlet 容器的启动到 Servlet 的初始化，以及 Servlet 的体系结构等这些环节中找出一些重点来讲述，目的是能读者有一个总体的完整的结构图，同时也详细分析了其中的一些难点问题，希望对大家有所帮助。 原文：Java Servlet完全教程 - ImportNewhttp://www.importnew.com/14621.html 参考：Java Servlet完全教程 - ImportNewhttp://www.importnew.com/14621.htmlServlet 工作原理解析https://www.ibm.com/developerworks/cn/java/j-lo-servlet/Servlet3.1规范（最终版）中文版下载 - 开涛的博客—公众号：kaitao-1234567，一如既往的干货分享 - ITeye博客http://jinnianshilongnian.iteye.com/blog/1912455前言 · Servlet学习笔记 · 看云https://www.kancloud.cn/digest/switch-servlet/120123Servlet教程_w3cschoolhttps://www.w3cschool.cn/servlet/]]></content>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda 大数据分析+json返回给echarts图表]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26%2F</url>
    <content type="text"><![CDATA[anaconda安装环境：pymysql 在jupyterlab中引入该包并建立数据库连接： 12345678910111213#!/usr/bin/python3 import pymysql # 打开数据库连接conn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码) 首先，我们要创建一个游标cursor = conn.cursor()什么是游标呢？ 游标就相当于一个缓冲区，存放暂时的结果（这是我的理解） 就像去超市买买买，你可能要推一个手推车，这里的手推车就像游标，推着手推车去对应的货架完成挑选操作，而手推车最终会在出超市时候清空 12345678910111213import pymysqlconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)cursor = conn.cursor()#创建一个游标cursor.execute('SELECT * FROM `f_vote`;')data = cursor.fetchone()#取一条数据print(data) 当我们将fetchone改成fetchall时候，就是取出所有信息了 下面是带异常检测的连接： 123456789101112131415161718import pymysqltry: conn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码 ) cursor = conn.cursor() cursor.execute('SELECT * FROM `f_vote`;') data = cursor.fetchall()#取一条数据 print(data) conn.close()except MySQLdb.Error as e: print('Error:%s' % e) 导入表中所有数据并查看前五行 12345678910111213import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)sql = 'SELECT * FROM `f_vote`;'df = pd.read_sql(sql,conn)df.head() 结果： 查找id=3的记录： 12345678910111213141516import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)#sql = 'SELECT * FROM `f_vote`;'#df = pd.read_sql(sql,conn)#df.head()sql1 = 'SELECT * FROM `f_vote` WHERE `id` = 3;'df1 = pd.read_sql(sql1,conn)df1 结果： 查找vote_num大于6000的数据，注意这里默认按照id排序的： 12345678910111213141516171819import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)#sql = 'SELECT * FROM `f_vote`;'#df = pd.read_sql(sql,conn)#df.head()#sql1 = 'SELECT * FROM `f_vote` WHERE `id` = 3;'#df1 = pd.read_sql(sql1,conn)#df1sql2 = 'SELECT * FROM `f_vote` WHERE `vote_num` &gt; 6000;'df2 = pd.read_sql(sql2,conn)df2 结果： 加上ORDER BY goods_prices之后，就是按照价格升序排列： 1234567891011121314151617181920import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)#sql = 'SELECT * FROM `f_vote`;'#df = pd.read_sql(sql,conn)#df.head()#sql1 = 'SELECT * FROM `f_vote` WHERE `id` = 3;'#df1 = pd.read_sql(sql1,conn)#df1sql2 = 'SELECT * FROM `f_vote` WHERE `vote_num` &gt; 6000 ORDER BY `vote_num`;'#sql2 = 'SELECT * FROM `f_vote` WHERE `vote_num` &gt; 6000 ORDER BY `vote_num`DESC;'df2 = pd.read_sql(sql2,conn)df2 结果： 将数据库文件导出成csv 12345678910111213141516171819import pymysqlimport pandas as pdconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)#sql = 'SELECT * FROM `f_vote`;'#df = pd.read_sql(sql,conn)#df.head()#sql1 = 'SELECT * FROM `f_vote` WHERE `id` = 3;'#df1 = pd.read_sql(sql1,conn)#df1sql2 = 'SELECT * FROM `f_vote` WHERE `vote_num` &gt; 6000 ORDER BY `vote_num`DESC;'df2 = pd.read_sql(sql2,conn)df2.to_csv('/Users/pailiu/Downloads/goods_info.csv', encoding = 'utf-8', index = False) 最后养成好习惯，断开与数据库的连接：conn.close() pandas.DataFrame.to_json按行转json 官网demo： 123456789101112131415161718192021222324252627282930313233df = pd.DataFrame([['a', 'b'], ['c', 'd']], index=['row 1', 'row 2'], columns=['col 1', 'col 2'])###########split###########df.to_json(orient='split')&gt;'&#123;"columns":["col 1","col 2"], "index":["row 1","row 2"], "data":[["a","b"],["c","d"]]&#125;'###########index###########df.to_json(orient='index')&gt;'&#123;"row 1":&#123;"col 1":"a","col 2":"b"&#125;,"row 2":&#123;"col 1":"c","col 2":"d"&#125;&#125;'###########records###########df.to_json(orient='index')&gt;'[&#123;"col 1":"a","col 2":"b"&#125;,&#123;"col 1":"c","col 2":"d"&#125;]'###########table###########df.to_json(orient='table')&gt;'&#123;"schema": &#123;"fields": [&#123;"name": "index", "type": "string"&#125;, &#123;"name": "col 1", "type": "string"&#125;, &#123;"name": "col 2", "type": "string"&#125;], "primaryKey": "index", "pandas_version": "0.20.0"&#125;, "data": [&#123;"index": "row 1", "col 1": "a", "col 2": "b"&#125;, &#123;"index": "row 2", "col 1": "c", "col 2": "d"&#125;]&#125;' 主要参考官网API：https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_json.html 下面是示例： split： index records table pandas_views.py文件内容如下： 123456789101112131415161718import MySQLdbimport pandas as pdimport pandas as pdconn = MySQLdb.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)sql1 = 'SELECT * FROM `bigdata1`;'df1 = pd.read_sql(sql1,conn)df1.to_json('../static/BigDataAnalysis/test.json',orient='table')conn.close() jupterLab： 1234567891011121314import pymysqlimport pandas as pdimport jsonconn = pymysql.connect( host = '127.0.0.1',#本地地址 user = 'root',#一般默认用户名 passwd = 'root',#本地数据库登录密码 db = 'maibao2',#数据库名称 port = 3306,#安装mysql默认的端口号 charset = 'utf8'#设置数据库统一编码)sql1 = 'SELECT * FROM `bigdata1`;'df1 = pd.read_sql(sql1,conn)df1.to_json('/Users/pailiu/Downloads/1234.json',orient='table') BigDataOnlineJson.html如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&#123;% extends "Scratch/index.html" %&#125;&#123;% load render_table from django_tables2 %&#125;&#123;% load favorite_extra %&#125;&#123;% load staticfiles %&#125;&#123;% block css %&#125; &lt;link href=&#123;% static "Scratch/css/productlist.css" %&#125; rel='stylesheet' type='text/css'/&gt; &lt;link href=&#123;% static "Scratch/css/gallerylist.css" %&#125; rel='stylesheet' type='text/css'/&gt;&#123;% endblock %&#125;&#123;% block mainbody %&#125; &lt;body style="height: 100%; margin: 0"&gt; &lt;div id="container" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/echarts.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts-gl/echarts-gl.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts-stat/ecStat.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/dataTool.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/china.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/map/js/world.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=ZUONbpqGBsYGXNIYHicvbAbM"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/echarts/extension/bmap.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://echarts.baidu.com/gallery/vendors/simplex.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;function loadOneColumn() &#123; var myChart = echarts.init(document.getElementById('container')); // 显示标题，图例和空的坐标轴 myChart.setOption(&#123; title: &#123; text: '异步数据加载示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data: ['发布排行'] &#125;, xAxis: &#123; data: [] &#125;, yAxis: &#123; splitLine: &#123; show: false &#125;,//去除网格线 name: '' &#125;, series: [&#123; barWidth: "30px", name: '发布排行', type: 'bar', itemStyle: &#123; normal: &#123; label: &#123; show: true, position: 'top', textStyle: &#123; color: '#333' &#125; &#125; &#125; &#125;, data: [] &#125;] &#125;); myChart.showLoading(); //数据加载完之前先显示一段简单的loading动画 var names = []; //类别数组（实际用来盛放X轴坐标值） var nums = []; //销量数组（实际用来盛放Y坐标值） $.ajax(&#123; type: 'get', url: '&#123;% static "BigDataAnalysis/test.json" %&#125;',//请求数据的地址 dataType: "json", //返回数据形式为json success: function (result) &#123; //请求成功时执行该函数内容，result即为服务器返回的json对象 $.each(result.data, function (index, item) &#123; names.push(item.department); //挨个取出类别并填入类别数组 nums.push(item.num); //挨个取出销量并填入销量数组 &#125;); myChart.hideLoading(); //隐藏加载动画 myChart.setOption(&#123; //加载数据图表 xAxis: &#123; data: names &#125;, series: [&#123; // 根据名字对应到相应的系列 name: '发布排行', //显示在上部的标题 data: nums &#125;] &#125;); &#125;, error: function (errorMsg) &#123; //请求失败时执行该函数 alert("图表请求数据失败!"); myChart.hideLoading(); &#125; &#125;);&#125;;loadOneColumn(); &lt;/script&gt; &lt;/body&gt;&#123;% endblock %&#125; 最终效果展示: 参考：Python操作Mysql数据库入门——查看和增加记录 - 天善智能：专注于商业智能BI和数据分析、大数据领域的垂直社区平台https://ask.hellobi.com/blog/wangdawei/9367Python操作Mysql数据库入门——数据导入pandas（数据分析准备） - 天善智能：专注于商业智能BI和数据分析、大数据领域的垂直社区平台https://ask.hellobi.com/blog/wangdawei/9441Python3 MySQL 数据库连接 | 菜鸟教程http://www.runoob.com/python3/python3-mysql.html]]></content>
      <tags>
        <tag>python</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache commons BeanUtils学习]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25-4%2F</url>
    <content type="text"><![CDATA[BeanUtils 简要描述beanutils，顾名思义，是 java bean 的一个工具类，可以帮助我们方便的读取 (get) 和设置(set)bean 属性值、动态定义和访问 bean 属性； 细心的话，会发现其实 JDK 已经提供了一个 java.beans 包，同样可以实现以上功能，只不过使用起来比较麻烦，所以诞生了 apache commons beanutils； 看源码就知道，其实 apache commons beanutils 就是基于 jdk 的 java.beans 包实现的。 Java Bean在介绍 apache commons beanutils 之前，很有必要先了解下 javabean。 apache commons beanutils 就是基于 JavaBeans 的设计命名规范来实现的，如下是一个简单的 javabean 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* * File Name: Employee.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.pojo;import java.util.Date;/** * * @author PiChen * @version 2017年5月29日 */public class Employee&#123; private String firstName; private String lastName; private Date hireDate; private boolean isManager;/** * @return the firstName */ public String getFirstName() &#123; return firstName; &#125; /** * @param firstName the firstName to set */ public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; /** * @return the lastName */ public String getLastName() &#123; return lastName; &#125; /** * @param lastName the lastName to set */ public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; /** * @return the hireDate */ public Date getHireDate() &#123; return hireDate; &#125; /** * @param hireDate the hireDate to set */ public void setHireDate(Date hireDate) &#123; this.hireDate = hireDate; &#125; /** * @return the isManager */ public boolean isManager() &#123; return isManager; &#125; /** * @param isManager the isManager to set */ public void setManager(boolean isManager) &#123; this.isManager = isManager; &#125; /** * @return the fullName */ public String getFullName() &#123; return firstName + " " + lastName; &#125;&#125; javabean 一般有以下几个特性：1、类必须是 public 访问权限，且需要有一个 public 的无参构造方法，之所以这样主要是方便利用 Java 的反射动态创建对象实例： 12Class beanClass = Class.forName(className);Object beanInstance = beanClass.newInstance(); 2、由于 javabean 的构造方法是无参的，所以我们的 bean 的行为配置（即设置 bean 的属性值，方法对应行为，属性对应数据）不能在构造方法完成，取而代之的是通过一系列的 set 方法来设置属性值，通过 setter 方法，我们可以改变 javabean 呈现出来的行为和内部数据，这里的 setter 方法会按一定的约定来命名，如 setHireDate、setName。。。 3、读取和设置 bean 属性值的命名约定，即 getter 方法和 setter 方法, 不过这里需要特别注意 boolean 类型的约定，如下示例： 123456789101112private String firstName;private String lastName;private Date hireDate;private boolean isManager;public String getFirstName();public void setFirstName(String firstName);public String getLastName();public void setLastName(String lastName);public Date getHireDate();public void setHireDate(Date hireDate);public boolean isManager();public void setManager(boolean manager); 4、并不是必须为每个属性提供 setter 和 getter 方法，我们可以只定义一个属性的 getter 方法而不定义 setter 方法，这样的属性一般是只读属性； 访问基本数据类型的 Bean 属性简述： 这类属性指的是 Integer, Double, Float, boolean 等,,,, 注意这里还包括 String，其实像 HashMap，ArrayList, 等属性都可以设置，只不过 Map 里面的键值对、List 索引处的值无法通过这两个 API 访问，需要使用专门的 API 来处理，接下来将会介绍； 访问 API： PropertyUtils.getSimpleProperty(Object, String) PropertyUtils.setSimpleProperty(Object, String, Object) 调用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * File Name: Main.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.Employee;/** * * @author PiChen * @version 2017年5月29日 */public class BasicPropertyAccess&#123; /** * * * @param args * @throws NoSuchMethodException * @throws InvocationTargetException * @throws IllegalAccessException */ public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Employee employee = new Employee(); String firstName = (String) PropertyUtils.getSimpleProperty(employee, "firstName"); String lastName = (String) PropertyUtils.getSimpleProperty(employee, "lastName"); firstName = firstName == null ? "Pi" : ""; lastName = lastName == null ? "Chen" : ""; PropertyUtils.setSimpleProperty(employee, "firstName", firstName); PropertyUtils.setSimpleProperty(employee, "lastName", lastName); System.out.println(employee.getFullName()); &#125;&#125; 访问索引类型的 Bean 属性简述： 可索引的属性，如 ArrayList, 数组等，可以通过下标索引来访问 Bean 属性的值, 同理可设置 value； 访问 API PropertyUtils.getIndexedProperty(Object, String) PropertyUtils.getIndexedProperty(Object, String, int) PropertyUtils.setIndexedProperty(Object, String, Object) PropertyUtils.setIndexedProperty(Object, String, int, Object) 调用示例 Bean： 12345678910111213141516171819202122232425262728293031323334353637383940package apache.commons.beanutils.example.pojo;import java.util.List;public class IndexedBean &#123; private List&lt;Employee&gt; employeeList; private Integer[] intArr; /** * @return the employeeList */ public List&lt;Employee&gt; getEmployeeList() &#123; return employeeList; &#125; /** * @param employeeList the employeeList to set */ public void setEmployeeList(List&lt;Employee&gt; employeeList) &#123; this.employeeList = employeeList; &#125; /** * @return the intArr */ public Integer[] getIntArr() &#123; return intArr; &#125; /** * @param intArr the intArr to set */ public void setIntArr(Integer[] intArr) &#123; this.intArr = intArr; &#125;&#125; 调用 example： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * File Name: Main.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import java.util.ArrayList;import java.util.List;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.Employee;import apache.commons.beanutils.example.pojo.IndexedBean;/** * * @author PiChen * @version 2017年5月29日 */public class IndexedPropertiesAccess&#123; /** * * * @param args * @throws NoSuchMethodException * @throws InvocationTargetException * @throws IllegalAccessException */ public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; // 初始工作 IndexedBean indexedBean = new IndexedBean(); List&lt;Employee&gt; employeeList = new ArrayList&lt;Employee&gt;(); Employee e1 = new Employee(); e1.setLastName("Chen"); Employee e2 = new Employee(); e2.setLastName("Wang"); employeeList.add(e1); employeeList.add(e2); indexedBean.setEmployeeList(employeeList); indexedBean.setIntArr(new Integer[]&#123; 0, 1, 2 &#125;); // API测试 int index0 = 0; String name0 = "employeeList[" + index0 + "]"; Employee employee0 = (Employee) PropertyUtils.getIndexedProperty(indexedBean, name0); System.out.println(employee0.getLastName()); int index1 = 1; String name1 = "employeeList[" + index1 + "]"; Employee employee1 = (Employee) PropertyUtils.getIndexedProperty(indexedBean, name1); System.out.println(employee1.getLastName()); Employee employee00 = (Employee) PropertyUtils.getIndexedProperty(indexedBean,"employeeList", 0); Employee employee11 = (Employee) PropertyUtils.getIndexedProperty(indexedBean,"employeeList", 1); System.out.println(employee00.getLastName()); System.out.println(employee11.getLastName()); Integer i = (Integer) PropertyUtils.getIndexedProperty(indexedBean,"intArr", 1); System.out.println(i); &#125;&#125; 访问 Map 映射类型的 Bean 属性简述： 常见的 HashMap，TreeMap 等，可以通过 key 来访问 Bean 属性值，同理可设置 value； 访问 API: PropertyUtils.getMappedProperty(Object, String) PropertyUtils.getMappedProperty(Object, String, String) PropertyUtils.setMappedProperty(Object, String, Object) PropertyUtils.setMappedProperty(Object, String, String, Object) 调用示例： map bean: 12345678910111213141516171819202122232425262728293031323334353637/* * File Name: MappedBean.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.pojo;import java.util.Map;/** * * @author PiChen * @version 2017年5月29日 */public class MappedBean&#123; private Map&lt;String, Object&gt; mapProperty; /** * @return the mapProperty */ public Map&lt;String, Object&gt; getMapProperty() &#123; return mapProperty; &#125; /** * @param mapProperty the mapProperty to set */ public void setMapProperty(Map&lt;String, Object&gt; mapProperty) &#123; this.mapProperty = mapProperty; &#125;&#125; 使用 example： 123456789101112131415161718192021222324252627282930313233343536373839/* * File Name: MapPropertyAccess.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.MappedBean;/** * * @author PiChen * @version 2017年5月29日 */public class MapPropertyAccess&#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; MappedBean employee = new MappedBean(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //employee.setMapProperty(map); PropertyUtils.setSimpleProperty(employee, "mapProperty", map); PropertyUtils.setMappedProperty(employee, "mapProperty", "testKey1", "testValue1"); PropertyUtils.setMappedProperty(employee, "mapProperty(testKey2)", "testValue2"); System.out.println(employee.getMapProperty().get("testKey1")); System.out.println(employee.getMapProperty().get("testKey2")); &#125;&#125; 访问嵌套类型的 Bean 属性简述： 指的是对象内嵌套对象 访问 API: PropertyUtils.getNestedProperty(Object, String) [PropertyUtils.setNestedProperty(Object, String, Object)](http://commons.apache.org/proper/commons-beanutils/javadocs/v1.9.3/apidocs/org/apache/commons/beanutils/PropertyUtils.html#setNestedProperty-java.lang.Object-java.lang.String-java.lang.Object-) 调用示例： 嵌套 bean： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * File Name: NestedBean.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.pojo;import java.util.List;import java.util.Map;/** * * @author PiChen * @version 2017年5月29日 */public class NestedBean&#123; private List&lt;Employee&gt; listProperty; private Map&lt;String, Employee&gt; mapProperty; /** * @return the listProperty */ public List&lt;Employee&gt; getListProperty() &#123; return listProperty; &#125; /** * @param listProperty the listProperty to set */ public void setListProperty(List&lt;Employee&gt; listProperty) &#123; this.listProperty = listProperty; &#125; /** * @return the mapProperty */ public Map&lt;String, Employee&gt; getMapProperty() &#123; return mapProperty; &#125; /** * @param mapProperty the mapProperty to set */ public void setMapProperty(Map&lt;String, Employee&gt; mapProperty) &#123; this.mapProperty = mapProperty; &#125;&#125; 使用 example： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * File Name: NestedPropertyAccess.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.Employee;import apache.commons.beanutils.example.pojo.NestedBean;/** * * @author PiChen * @version 2017年5月29日 */public class NestedPropertyAccess&#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Employee e = new Employee(); e.setLastName("Chen"); NestedBean nestedBean = new NestedBean(); List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); list.add(e); Map&lt;String, Employee&gt; map = new HashMap&lt;String, Employee&gt;(); map.put("testKey", e); nestedBean.setListProperty(list); nestedBean.setMapProperty(map); String lastName = (String) PropertyUtils.getNestedProperty(nestedBean, "mapProperty(testKey).lastName"); System.out.println(lastName); String lastName2 = (String) PropertyUtils.getNestedProperty(nestedBean, "listProperty[0].lastName"); System.out.println(lastName2); &#125;&#125; 访问所有类型的 Bean 属性简述 通过以上 API 的使用，我们了解了各类 bean 属性的访问方法，其实还有一种通用的方法，适用于各类 bean 属性类型； 访问 API PropertyUtils.getProperty(Object, String) PropertyUtils.setProperty(Object, String, Object) 使用示例，这里直接以嵌套类型属性为例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * File Name: NestedPropertyAccess.java * Description: * Author: PiChen * Create Date: 2017年5月29日 */package apache.commons.beanutils.example.propertyaccess;import java.lang.reflect.InvocationTargetException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.beanutils.PropertyUtils;import apache.commons.beanutils.example.pojo.Employee;import apache.commons.beanutils.example.pojo.NestedBean;/** * * @author PiChen * @version 2017年5月29日 */public class NestedPropertyAccess&#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123; Employee e = new Employee(); e.setLastName("Chen"); NestedBean nestedBean = new NestedBean(); List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); list.add(e); Map&lt;String, Employee&gt; map = new HashMap&lt;String, Employee&gt;(); map.put("testKey", e); nestedBean.setListProperty(list); nestedBean.setMapProperty(map); String lastName2 = (String) PropertyUtils.getProperty(nestedBean, "listProperty[0].lastName"); System.out.println(lastName2); PropertyUtils.setProperty(nestedBean, "listProperty[0].lastName", "Hello World"); System.out.println(nestedBean.getListProperty().get(0).getLastName()); &#125;&#125; 参考：http://www.cnblogs.com/chenpi/p/6917499.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>待阅</tag>
        <tag>工具类</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache commons lang学习]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25-3%2F</url>
    <content type="text"><![CDATA[概述跟 java.lang 这个包的作用类似，Commons Lang 这一组 API 也是提供一些基础的、通用的操作和处理，如自动生成 toString() 的结果、自动实现 hashCode() 和 equals() 方法、数组操作、枚举、日期和时间的处理等等。 这一组 API 的所有包名都以 org.apache.commons.lang 开头，共有如下 8 个包： org.apache.commons.langorg.apache.commons.lang.builderorg.apache.commons.lang.enumorg.apache.commons.lang.enumsorg.apache.commons.lang.exceptionorg.apache.commons.lang.mathorg.apache.commons.lang.mutableorg.apache.commons.lang.time 其中的 lang.enum 已不建议使用，替代它的是紧随其后的 lang.enums 包。 lang 包主要是一些可以高度重用的 Util 类；lang.builder 包包含了一组用于产生每个 Java 类中都常使用到的 toString()、hashCode()、equals()、compareTo() 等等方法的构造器；lang.enums 包顾名思义用于处理枚举；lang.exception 包用于处理 Java 标准 API 中的 exception，为 1.4 之前版本提供 Nested Exception 功能；lang.math 包用于处理数字；lang.mutable 用于包装值型变量；lang.time 包提供处理日期和时间的功能。 下面讲下最常用的三个类 ArrayUtils数组是我们经常需要使用到的一种数据结构，但是由于 Java 本身并没有提供很好的 API 支持，使得很多操作实际上做起来相当繁琐，以至于我们实际编码中甚至会不惜牺牲性能去使用 Collections API，用 Collection 当然能够很方便的解决我们的问题，但是我们一定要以性能为代价吗？ArrayUtils 帮我们解决了处理类似情况的大部分问题。 常量数组1234567public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0]; public static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class[0]; public static final String[] EMPTY_STRING_ARRAY = new String[0]; public static final long[] EMPTY_LONG_ARRAY = new long[0]; public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0]; public static final int[] EMPTY_INT_ARRAY = new int[0]; public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0]; 转换为 MaptoMap(Object[] array)将二维数组转换为 Map。 12345Map colorMap = ArrayUtils.toMap(new String[][] &#123; &#123;"RED", "#FF0000"&#125;, &#123;"GREEN", "#00FF00"&#125;, &#123;"BLUE", "#0000FF"&#125;&#125;); 生成数组T[] toArray(final T… items)将不定参数转换为数组。 12String[] array = ArrayUtils.toArray("1", "2"); String[] emptyArray = ArrayUtils.&lt;String&gt;toArray(); null 转空数组Object[] nullToEmpty(Object[] array)将 null 数组转为对应类型的空数组，如果 array 不是 null，则返回 array。 1String[] arr = ArrayUtils.nullToEmpty((String[]) null); 数组操作T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive)截取数组开始索引位置和结束索引位置的数组为子数组 12Object[]s1=ArrayUtils.subarray(newObject[]&#123;"aa","bb","cc"&#125;,0,1); // ["aa"] Object[]s2=ArrayUtils.subarray(newObject[]&#123;"aa","bb","cc"&#125;,0,2); // ["aa", "bb"] reverse(long[] array)反转数组。 1ArrayUtils.reverse(new String[]&#123;"aa","bb"&#125;);//结果是：&#123;"bb"，"aa"&#125; swap(Object[] array, int offset1, int offset2)交换数组中的元素。 12345ArrayUtils.swap(["1", "2", "3"], 0, 2) -&gt; ["3", "2", "1"] ArrayUtils.swap(["1", "2", "3"], 0, 0) -&gt; ["1", "2", "3"] ArrayUtils.swap(["1", "2", "3"], 1, 0) -&gt; ["2", "1", "3"] ArrayUtils.swap(["1", "2", "3"], 0, 5) -&gt; ["1", "2", "3"] ArrayUtils.swap(["1", "2", "3"], -1, 1) -&gt; ["2", "1", "3"] 数组元素查找int indexOf(Object[] array, Object objectToFind)数组元素所在的索引位置, 如果没有则返回 - 1, 可指定起始搜索位置。 123ArrayUtils.indexOf(new String[]&#123;"aa","bb","cc"&#125;,"cc"); // 2 ArrayUtils.indexOf(new String[]&#123;"aa","bb","bb"&#125;,"bb",2); // 2 ArrayUtils.indexOf(newObject[]&#123;"aa","bb","cc"&#125;,"cc",3); // -1 int lastIndexOf(Object[] array, Object objectToFind, int startIndex)同indexOf(Object[] array, Object objectToFind)相反。反向查询某个 object 在数组中的位置，可以指定起始搜索位置。 contains(Object[] array, Object objectToFind)判断数组中是否包含某个元素。 1ArrayUtils.contains(new String[]&#123;"a", "b", "c"&#125;, "a"); // true 数组判空boolean isEmpty(Object[] array)判断数组是否为空。 1234ArrayUtils.isEmpty(new String[]&#123;"21","是"&#125;); // false ArrayUtils.isEmpty(new String[]&#123;""&#125;); // false ArrayUtils.isEmpty(new String[]&#123;null&#125;); // false ArrayUtils.isEmpty(new String[]&#123;&#125;); // true boolean isNotEmpty(T[] array)同 boolean isEmpty 相反。判断数组是否不为空。 合并数组元素T[] addAll(T[] array1, T… array2)合并多个数组到某一个数组中。 123456ArrayUtils.addAll(null, null) = null ArrayUtils.addAll(array1, null) = cloned copy of array1 ArrayUtils.addAll(null, array2) = cloned copy of array2 ArrayUtils.addAll([], []) = [] ArrayUtils.addAll([null], [null]) = [null, null] ArrayUtils.addAll(["a", "b", "c"], ["1", "2", "3"]) = ["a", "b", "c", "1", "2", "3"] T[] add(T[] array, T element)将单个元素合并到数组中。 12345ArrayUtils.add(null, null) = IllegalArgumentException ArrayUtils.add(null, "a") = ["a"] ArrayUtils.add(["a"], null) = ["a", null] ArrayUtils.add(["a"], "b") = ["a", "b"] ArrayUtils.add(["a", "b"], "c") = ["a", "b", "c"] T[] add(T[] array, int index, T element)将单个元素合并到指定索引位置的数组中。 12345ArrayUtils.add(null, 0, null) = IllegalArgumentException ArrayUtils.add(null, 0, "a") = ["a"] ArrayUtils.add(["a"], 1, null) = ["a", null] ArrayUtils.add(["a"], 0, "b") = ["b", "a"] ArrayUtils.add(["a", "b"], 1, "c") = ["a", "c", "b"] 移除数组元素T[] remove(T[] array, int index)移除数组中指定索引位置的元素。 1234ArrayUtils.remove(["a"], 0) = [] ArrayUtils.remove(["a", "b"], 0) = ["b"] ArrayUtils.remove(["a", "b"], 1) = ["a"] ArrayUtils.remove(["a", "b", "c"], 1) = ["a", "c"] T[] removeAll(T[] array, int… indices)同&lt;T&gt; T[] remove(T[] array, int index)相似，移除数组中所有指定索引位置的元素。 12ArrayUtils.removeAll(["a", "b", "c"], 0, 2) = ["b"] ArrayUtils.removeAll(["a", "b", "c"], 1, 2) = ["a"] T[] removeElement(T[] array, Object element)移除数组中的第一个 element 元素。 12345ArrayUtils.removeElement(null, "a") = null ArrayUtils.removeElement([], "a") = [] ArrayUtils.removeElement(["a"], "b") = ["a"] ArrayUtils.removeElement(["a", "b"], "a") = ["b"] ArrayUtils.removeElement(["a", "b", "a"], "a") = ["b", "a"] 字符串的处理类（StringUtils）处理文本对 Java 应用来说应该算是家常便饭了，在 1.4 出现之前，Java 自身提供的 API 非常有限，如 String、StringTokenizer、StringBuffer，操作也比较单一。无非就是查找 substring、分解、合并等等。到 1.4 的出现可以说 Java 的文字处理上了一个台阶，因为它支持 regular expression 了。这可是个重量级而方便的东东啊，缺点是太复杂，学习起来有一定难度。相较而言，Jakarta Commons 提供的 StringUtils 和 WordUtils 至今还维持着那种简洁而强大的美，使用起来也很顺手。 org.apache.commons.lang3.StringUtils 继承 Object,Operations onString that are null safe。所谓的 null safe 就是对 String 进行操作不会出现 NullPointerException 异常，很实用有没有！以后再也不怕到处出现空指针异常了。先看看官方文档中这个类都有些什么方法： 判断空字符串isEmpty(CharSequence cs)判断是否是空字符串，代码示例： 12345StringUtils.isEmpty(null) = true StringUtils.isEmpty("") = true StringUtils.isEmpty(" ") = false StringUtils.isEmpty("bob") = false StringUtils.isEmpty(" bob ") = false isNotEmpty(CharSequence cs)判断是否不是空字符串，与isEmpty(CharSequence cs)相反。 isAnyEmpty(CharSequence… css)判断是否含有空字符串，代码示例： 1234567StringUtils.isAnyEmpty(null) = true StringUtils.isAnyEmpty(null, "foo") = true StringUtils.isAnyEmpty("", "bar") = true StringUtils.isAnyEmpty("bob", "") = true StringUtils.isAnyEmpty(" bob ", null) = true StringUtils.isAnyEmpty(" ", "bar") = false StringUtils.isAnyEmpty("foo", "bar") = false isNoneEmpty(CharSequence… css)判断是否都不是空字符串，与isAnyEmpty(CharSequence... css)相反。 isAllEmpty(CharSequence… css)判断是否都是空字符串，代码示例： 123456789StringUtils.isAllEmpty(null) = true StringUtils.isAllEmpty(null, "") = true StringUtils.isAllEmpty(new String[] &#123;&#125;) = true StringUtils.isAllEmpty(null, "foo") = false StringUtils.isAllEmpty("", "bar") = false StringUtils.isAllEmpty("bob", "") = false StringUtils.isAllEmpty(" bob ", null) = false StringUtils.isAllEmpty(" ", "bar") = false StringUtils.isAllEmpty("foo", "bar") = false isBlank(CharSequence cs)判断是否是 “大空字符串”，代码示例： 12345StringUtils.isBlank(null) = true StringUtils.isBlank("") = true StringUtils.isBlank(" ") = true StringUtils.isBlank("bob") = false StringUtils.isBlank(" bob ") = false isNotBlank(CharSequence cs)判断是否不是 “大空字符串”，与isBlank(CharSequence cs)相反，与isNotEmpty(CharSequence cs)相似。 isAnyBlank(CharSequence… css)判断是否有 “大空字符串”，与isAnyEmpty(CharSequence... css)相似。 isNoneBlank(CharSequence… css)判断是否都不是 “大空字符串”，与isAnyBlank(CharSequence... css)相反，与isNoneEmpty(CharSequence... css)相似。 isAllBlank(CharSequence… css)判断是否都是 “大空字符串”，与isAllEmpty(CharSequence... css)相似。 截取字符串trim(String str)去除字符串前后的控制符，代码示例： 12345StringUtils.trim(null) = null StringUtils.trim("") = "" StringUtils.trim(" ") = "" StringUtils.trim("abc") = "abc" StringUtils.trim(" abc ") = "abc" trimToNull(String str)去除字符串前后的控制符，如何是空字符串则转为null，代码示例： 12345StringUtils.trimToNull(null) = null StringUtils.trimToNull("") = null StringUtils.trimToNull(" ") = null StringUtils.trimToNull("abc") = "abc" StringUtils.trimToNull(" abc ") = "abc" trimToEmpty(String str)去除字符串前后的控制符，如何是null则转为空字符串，代码示例： 12345StringUtils.trimToEmpty(null) = "" StringUtils.trimToEmpty("") = "" StringUtils.trimToEmpty(" ") = "" StringUtils.trimToEmpty("abc") = "abc" StringUtils.trimToEmpty(" abc ") = "abc" truncate(String str, int maxWidth)截断字符串，具有以下特点： 如果 str 字符串的长度小于 maxWidth，则直接返回 str。 不满足第一条时，则为substring(str, 0, maxWidth)。 如果 maxWidth 小于 0，则抛出 IllegalArgumentException。 在任何情况下都不会返回长度大于 maxWidth 的字符串。 代码示例： 12345678StringUtils.truncate(null, 0) = null StringUtils.truncate(null, 2) = null StringUtils.truncate("", 4) = "" StringUtils.truncate("abcdefg", 4) = "abcd" StringUtils.truncate("abcdefg", 6) = "abcdef" StringUtils.truncate("abcdefg", 7) = "abcdefg" StringUtils.truncate("abcdefg", 8) = "abcdefg" StringUtils.truncate("abcdefg", -1) = throws an IllegalArgumentException truncate(String str, int offset, int maxWidth)截断字符串，具有以下特点： 如果 str 字符串的长度小于 maxWidth，则直接返回 str。 不满足第一条时，则为substring(str, offset, maxWidth)。 如果 maxWidth 或者 offset 小于 0，则抛出 IllegalArgumentException。 在任何情况下都不会返回长度大于 maxWidth 的字符串。 代码示例： 123456789101112131415161718192021222324252627282930StringUtils.truncate(null, 0, 0) = null StringUtils.truncate(null, 2, 4) = null StringUtils.truncate("", 0, 10) = "" StringUtils.truncate("", 2, 10) = "" StringUtils.truncate("abcdefghij", 0, 3) = "abc" StringUtils.truncate("abcdefghij", 5, 6) = "fghij" StringUtils.truncate("raspberry peach", 10, 15) = "peach" StringUtils.truncate("abcdefghijklmno", 0, 10) = "abcdefghij" StringUtils.truncate("abcdefghijklmno", -1, 10) = throws an IllegalArgumentException StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, 10) = "abcdefghij" StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, Integer.MAX_VALUE) = "abcdefghijklmno" StringUtils.truncate("abcdefghijklmno", 0, Integer.MAX_VALUE) = "abcdefghijklmno" StringUtils.truncate("abcdefghijklmno", 1, 10) = "bcdefghijk" StringUtils.truncate("abcdefghijklmno", 2, 10) = "cdefghijkl" StringUtils.truncate("abcdefghijklmno", 3, 10) = "defghijklm" StringUtils.truncate("abcdefghijklmno", 4, 10) = "efghijklmn" StringUtils.truncate("abcdefghijklmno", 5, 10) = "fghijklmno" StringUtils.truncate("abcdefghijklmno", 5, 5) = "fghij" StringUtils.truncate("abcdefghijklmno", 5, 3) = "fgh" StringUtils.truncate("abcdefghijklmno", 10, 3) = "klm" StringUtils.truncate("abcdefghijklmno", 10, Integer.MAX_VALUE) = "klmno" StringUtils.truncate("abcdefghijklmno", 13, 1) = "n" StringUtils.truncate("abcdefghijklmno", 13, Integer.MAX_VALUE) = "no" StringUtils.truncate("abcdefghijklmno", 14, 1) = "o" StringUtils.truncate("abcdefghijklmno", 14, Integer.MAX_VALUE) = "o" StringUtils.truncate("abcdefghijklmno", 15, 1) = "" StringUtils.truncate("abcdefghijklmno", 15, Integer.MAX_VALUE) = "" StringUtils.truncate("abcdefghijklmno", Integer.MAX_VALUE, Integer.MAX_VALUE) = "" StringUtils.truncate("abcdefghij", 3, -1) = throws an IllegalArgumentException StringUtils.truncate("abcdefghij", -2, 4) = throws an IllegalArgumentException left(String str, int len)得到一个字符串最左边的 len 个字符 123StringUtils.left("abc", 0) = "" StringUtils.left("abc", 2) = "ab" StringUtils.left("abc", 4) = "abc" right(String str, int len)同left(String str, int len)相反，从右边截取 len 个字符。 mid(String str, int pos, int len)得到一个字符串中间的 len 个字符。 12345StringUtils.mid("abc", 0, 2) = "ab" StringUtils.mid("abc", 0, 4) = "abc" StringUtils.mid("abc", 2, 4) = "c" StringUtils.mid("abc", 4, 2) = "" StringUtils.mid("abc", -2, 2) = "ab" substringBefore(String str, String separator)得到一个字符串第一个分隔符字符串之前的字符串。 123456StringUtils.substringBefore("abc", "a") = "" StringUtils.substringBefore("abcba", "b") = "a" StringUtils.substringBefore("abc", "c") = "ab" StringUtils.substringBefore("abc", "d") = "abc" StringUtils.substringBefore("abc", "") = "" StringUtils.substringBefore("abc", null) = "abc" substringAfter(String str, String separator)同substringBefore(String str, String separator)相反。得到一个字符串第一个分隔符字符串之后的字符串。 substringBetween(String str, String open, String close)得到一个字符串两个字符串之间字符串。 123456StringUtils.substringBetween("", "", "") = "" StringUtils.substringBetween("", "", "]") = null StringUtils.substringBetween("", "[", "]") = null StringUtils.substringBetween("yabcz", "", "") = "" StringUtils.substringBetween("yabcz", "y", "z") = "abc" StringUtils.substringBetween("yabczyabcz", "y", "z") = "abc" substringBetween(String str, String tag)是substringBetween(String str, String open, String close)的特殊情形。得到一个字符串中同一个字符串之间的字符串。 比较字符串equals(CharSequence cs1, CharSequence cs2)判断两字符串相等，代码示例： 12345StringUtils.equals(null, null) = true StringUtils.equals(null, "abc") = false StringUtils.equals("abc", null) = false StringUtils.equals("abc", "abc") = true StringUtils.equals("abc", "ABC") = false equalsIgnoreCase(CharSequence str1, CharSequence str2)判断两字符串相等，忽略大小写，代码示例： 12345StringUtils.equalsIgnoreCase(null, null) = true StringUtils.equalsIgnoreCase(null, "abc") = false StringUtils.equalsIgnoreCase("abc", null) = false StringUtils.equalsIgnoreCase("abc", "abc") = true StringUtils.equalsIgnoreCase("abc", "ABC") = true equalsAny(CharSequence string, CharSequence… searchStrings)比较一个字符串是否与其后的某个字符串相等，代码示例： 123456StringUtils.equalsAny(null, (CharSequence[]) null) = false StringUtils.equalsAny(null, null, null) = true StringUtils.equalsAny(null, "abc", "def") = false StringUtils.equalsAny("abc", null, "def") = false StringUtils.equalsAny("abc", "abc", "def") = true StringUtils.equalsAny("abc", "ABC", "DEF") = false equalsAnyIgnoreCase(CharSequence string, CharSequence…searchStrings)比较一个字符串是否与其后的某个字符串相等，忽略大小写，代码示例： 123456StringUtils.equalsAnyIgnoreCase(null, (CharSequence[]) null) = false StringUtils.equalsAnyIgnoreCase(null, null, null) = true StringUtils.equalsAnyIgnoreCase(null, "abc", "def") = false StringUtils.equalsAnyIgnoreCase("abc", null, "def") = false StringUtils.equalsAnyIgnoreCase("abc", "abc", "def") = true StringUtils.equalsAnyIgnoreCase("abc", "ABC", "DEF") = true compare(String str1, String str2)比较两字符串的大小，代码示例： 12345678StringUtils.compare(null, null) = 0 StringUtils.compare(null , "a") &lt; 0 StringUtils.compare("a", null) &gt; 0 StringUtils.compare("abc", "abc") = 0 StringUtils.compare("a", "b") &lt; 0 StringUtils.compare("b", "a") &gt; 0 StringUtils.compare("a", "B") &gt; 0 StringUtils.compare("ab", "abc") &lt; 0 compareIgnoreCase(String str1, String str2)比较两字符串的大小，忽略大小写，代码示例： 12345678910StringUtils.compareIgnoreCase(null, null) = 0 StringUtils.compareIgnoreCase(null , "a") &lt; 0 StringUtils.compareIgnoreCase("a", null) &gt; 0 StringUtils.compareIgnoreCase("abc", "abc") = 0 StringUtils.compareIgnoreCase("abc", "ABC") = 0 StringUtils.compareIgnoreCase("a", "b") &lt; 0 StringUtils.compareIgnoreCase("b", "a") &gt; 0 StringUtils.compareIgnoreCase("a", "B") &lt; 0 StringUtils.compareIgnoreCase("A", "b") &lt; 0 StringUtils.compareIgnoreCase("ab", "ABC") &lt; 0 查找元素indexOf(CharSequence seq, int searchChar)查找某个字符在字符串中第一次出现时的索引位置，代码示例： 12StringUtils.indexOf("aabaabaa", 'a') = 0 StringUtils.indexOf("aabaabaa", 'b') = 2 indexOf(CharSequence seq, CharSequence searchSeq)同indexOf(CharSequence seq, int searchChar)相似。 12345StringUtils.indexOf("aabaabaa", "c") = -1 StringUtils.indexOf("aabaabaa", "a") = 0 StringUtils.indexOf("aabaabaa", "b") = 2 StringUtils.indexOf("aabaabaa", "ab") = 1 StringUtils.indexOf("aabaabaa", "") = 0 indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos)同indexOf(CharSequence seq, int searchChar)相似。 12345678StringUtils.indexOf("aabaabaa", "a", 0) = 0 StringUtils.indexOf("aabaabaa", "b", 0) = 2 StringUtils.indexOf("aabaabaa", "ab", 0) = 1 StringUtils.indexOf("aabaabaa", "b", 3) = 5 StringUtils.indexOf("aabaabaa", "b", 9) = -1 StringUtils.indexOf("aabaabaa", "b", -1) = 2 StringUtils.indexOf("aabaabaa", "", 2) = 2 StringUtils.indexOf("abc", "", 9) = 3 indexOfIgnoreCase(CharSequence str, CharSequence searchStr)同indexOf(CharSequence seq, int searchChar)相似, 忽略大小写。 lastIndexOf(CharSequence seq, int searchChar)同indexOf(CharSequence seq, int searchChar)相似，从后面开始查找。 contains(CharSequence seq, CharSequence searchSeq)判断某字符串是否包含某子字符串。 1234StringUtils.contains("", "") = true StringUtils.contains("abc", "") = true StringUtils.contains("abc", "a") = true StringUtils.contains("abc", "z") = false containsIgnoreCase(CharSequence str, CharSequence searchStr)同contains(CharSequence seq, CharSequence searchSeq)相似，忽略大小写。 containsWhitespace(final CharSequence seq)是contains(CharSequence seq, CharSequence searchSeq)的特殊情形，判断是否包含空白字符。 containsAny(CharSequence cs, CharSequence… searchCharSequences)判断某字符串是否包含其后的任意一个字符串。 123StringUtils.containsAny("abcd", "ab", null) = true StringUtils.containsAny("abcd", "ab", "cd") = true StringUtils.containsAny("abc", "d", "abc") = true containsNone(CharSequence cs, String invalidChars)判断某字符串是否不含其后字符串的任意一个字符。 1234StringUtils.containsNone("ab", "") = true StringUtils.containsNone("abab", "xyz") = true StringUtils.containsNone("ab1", "xyz") = true StringUtils.containsNone("abz", "xyz") = false 分割字符串split(String str, String separatorChars)将某字符串按字符分割成数组，默认按空格分组。 1234StringUtils.split("abc def", null) = ["abc", "def"] StringUtils.split("abc def", " ") = ["abc", "def"] StringUtils.split("abc def", " ") = ["abc", "def"] StringUtils.split("ab:cd:ef", ":") = ["ab", "cd", "ef"] split(String str, String separatorChars, int max)将某字符串按字符分割成最大 max 长度的数组，默认按空格分组。 1234StringUtils.split("ab cd ef", null, 0) = ["ab", "cd", "ef"] StringUtils.split("ab cd ef", null, 0) = ["ab", "cd", "ef"] StringUtils.split("ab:cd:ef", ":", 0) = ["ab", "cd", "ef"] StringUtils.split("ab:cd:ef", ":", 2) = ["ab", "cd:ef"] splitByCharacterType(final String str)按字符串类型划分字符串为数组。 123456789StringUtils.splitByCharacterType(null) = null StringUtils.splitByCharacterType("") = [] StringUtils.splitByCharacterType("ab de fg") = ["ab", " ", "de", " ", "fg"] StringUtils.splitByCharacterType("ab de fg") = ["ab", " ", "de", " ", "fg"] StringUtils.splitByCharacterType("ab:cd:ef") = ["ab", ":", "cd", ":", "ef"] StringUtils.splitByCharacterType("number5") = ["number", "5"] StringUtils.splitByCharacterType("fooBar") = ["foo", "B", "ar"] StringUtils.splitByCharacterType("foo200Bar") = ["foo", "200", "B", "ar"] StringUtils.splitByCharacterType("ASFRules") = ["ASFR", "ules"] 连接字符串join(T… elements)无连接符连接字符串。 12345StringUtils.join(null) = null StringUtils.join([]) = "" StringUtils.join([null]) = "" StringUtils.join(["a", "b", "c"]) = "abc" StringUtils.join([null, "", "a"]) = "a" join(Object[] array, String separator)将提供的数组按连接符连成字符串。 123456StringUtils.join(null, *) = null StringUtils.join([], *) = "" StringUtils.join([null], *) = "" StringUtils.join(["a", "b", "c"], ';') = "a;b;c" StringUtils.join(["a", "b", "c"], null) = "abc" StringUtils.join([null, "", "a"], ';') = ";;a" 删除字符串deleteWhitespace(String str)删除空白字符。 1234StringUtils.deleteWhitespace(null) = null StringUtils.deleteWhitespace("") = "" StringUtils.deleteWhitespace("abc") = "abc" StringUtils.deleteWhitespace(" ab c ") = "abc" removeStart(String str, String remove)删除指定字符串前缀的字符串。 1234StringUtils.removeStart("www.domain.com", "www.") = "domain.com" StringUtils.removeStart("domain.com", "www.") = "domain.com" StringUtils.removeStart("www.domain.com", "domain") = "www.domain.com" StringUtils.removeStart("abc", "") = "abc" removeStartIgnoreCase(String str, String remove)同removeStart(String str, String remove)相似，忽略大小写。 removeEnd(String str, String remove)同removeStart(String str, String remove)相反。 removeEndIgnoreCase(String str, String remove)同removeEnd(String str, String remove)相似，忽略大小写。 remove(String str, String remove)移除字符串中指定的字符串。 12StringUtils.remove("queued", "ue") = "qd" StringUtils.remove("queued", "zz") = "queued" removeIgnoreCase(String str, String remove)同remove(String str, String remove)相似，忽略大小写。 替换字符串replace(String text, String searchString, String replacement)替换某字符串为另一个字符串。 123StringUtils.replace("aba", "a", null) = "aba" StringUtils.replace("aba", "a", "") = "b" StringUtils.replace("aba", "a", "z") = "zbz" replaceIgnoreCase(String text, String searchString, String replacement)同replace(String text, String searchString, String replacement)相似，忽略大小写。 replace(String text, String searchString, String replacement, int max)替换某字符串为另一个字符串, 从左到右替换最大 max 次。 123456StringUtils.replace("abaa", "a", null, -1) = "abaa" StringUtils.replace("abaa", "a", "", -1) = "b" StringUtils.replace("abaa", "a", "z", 0) = "abaa" StringUtils.replace("abaa", "a", "z", 1) = "zbaa" StringUtils.replace("abaa", "a", "z", 2) = "zbza" StringUtils.replace("abaa", "a", "z", -1) = "zbzz" replaceEach(String text, String[] searchList, String[] replacementList)替换某些字符串为另一些字符串。 12345678StringUtils.replaceEach("aba", null, null) = "aba" StringUtils.replaceEach("aba", new String[0], null) = "aba" StringUtils.replaceEach("aba", null, new String[0]) = "aba" StringUtils.replaceEach("aba", new String[]&#123;"a"&#125;, null) = "aba" StringUtils.replaceEach("aba", new String[]&#123;"a"&#125;, new String[]&#123;""&#125;) = "b" StringUtils.replaceEach("aba", new String[]&#123;null&#125;, new String[]&#123;"a"&#125;) = "aba" StringUtils.replaceEach("abcde", new String[]&#123;"ab", "d"&#125;, new String[]&#123;"w", "t"&#125;) = "wcte" StringUtils.replaceEach("abcde", new String[]&#123;"ab", "d"&#125;, new String[]&#123;"d", "t"&#125;) = "dcte" 填充字符串repeat(final String str, final int repeat)生成重复的字符串，repeat 代表生成次数。 123456StringUtils.repeat(null, 2) = null StringUtils.repeat("", 0) = "" StringUtils.repeat("", 2) = "" StringUtils.repeat("a", 3) = "aaa" StringUtils.repeat("ab", 2) = "abab" StringUtils.repeat("a", -2) = "" repeat(String str, String separator, int repeat)生成重复的字符串，repeat 代表生成次数。 123456StringUtils.repeat(null, null, 2) = null StringUtils.repeat(null, "x", 2) = null StringUtils.repeat("", null, 0) = "" StringUtils.repeat("", "", 2) = "" StringUtils.repeat("", "x", 3) = "xxx" StringUtils.repeat("?", ", ", 3) = "?, ?, ?" 字符串计数countMatches(CharSequence str, CharSequence sub)计算某字符串在字符串中的出现次数。 12345StringUtils.countMatches("abba", null) = 0 StringUtils.countMatches("abba", "") = 0 StringUtils.countMatches("abba", "a") = 2 StringUtils.countMatches("abba", "ab") = 1 StringUtils.countMatches("abba", "xxx") = 0 字符测试isAlpha(CharSequence cs)判断字符串是否是 Unicode 字母。 123456StringUtils.isAlpha(null) = false StringUtils.isAlpha("") = false StringUtils.isAlpha(" ") = false StringUtils.isAlpha("abc") = true StringUtils.isAlpha("ab2c") = false StringUtils.isAlpha("ab-c") = false isAlphaSpace(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是 Unicode 字母或空格。 1234567StringUtils.isAlphaSpace(null) = false StringUtils.isAlphaSpace("") = true StringUtils.isAlphaSpace(" ") = true StringUtils.isAlphaSpace("abc") = true StringUtils.isAlphaSpace("ab c") = true StringUtils.isAlphaSpace("ab2c") = false StringUtils.isAlphaSpace("ab-c") = false isAlphanumeric(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是 Unicode 字母或数字。 isAlphanumericSpace(CharSequence cs)同isAlpha(CharSequence cs)相似。判断字符串是否是 Unicode 字母、空格或数字。 isNumeric(CharSequence cs)判断字符串是否是数字。 1234567StringUtils.isNumeric("123") = true StringUtils.isNumeric("12 3") = false StringUtils.isNumeric("ab2c") = false StringUtils.isNumeric("12-3") = false StringUtils.isNumeric("12.3") = false StringUtils.isNumeric("-123") = false StringUtils.isNumeric("+123") = false isNumericSpace(CharSequence cs)同isNumeric(CharSequence cs)相似。判断字符串是否是空格或数字。 getDigits(String str)从字符串中提取出数字为字符串。 123456StringUtils.getDigits(null) = null StringUtils.getDigits("") = "" StringUtils.getDigits("abc") = "" StringUtils.getDigits("1000$") = "1000" StringUtils.getDigits("1123~45") = "12345" StringUtils.getDigits("(541) 754-3010") = "5417543010" isWhitespace(CharSequence cs)判断是否是空格。 123456StringUtils.isWhitespace(null) = false StringUtils.isWhitespace("") = true StringUtils.isWhitespace(" ") = true StringUtils.isWhitespace("abc") = false StringUtils.isWhitespace("ab2c") = false StringUtils.isWhitespace("ab-c") = false isAllLowerCase(CharSequence cs)判断字符串是否都是小写。 12345678StringUtils.isAllLowerCase(null) = false StringUtils.isAllLowerCase("") = false StringUtils.isAllLowerCase(" ") = false StringUtils.isAllLowerCase("abc") = true StringUtils.isAllLowerCase("abC") = false StringUtils.isAllLowerCase("ab c") = false StringUtils.isAllLowerCase("ab1c") = false StringUtils.isAllLowerCase("ab/c") = false isAllUpperCase(CharSequence cs)同isAllLowerCase相反。判断字符串是否都是大写。 isMixedCase(CharSequence cs)同isAllLowerCase相似。判断字符串是否大小写都有。 默认字符串defaultString(String str)得到默认字符串，默认空字符串。 123StringUtils.defaultString(null) = "" StringUtils.defaultString("") = "" StringUtils.defaultString("bat") = "bat" defaultString(String str, String defaultStr)如果是 null，则得到默认字符串。 123StringUtils.defaultString(null, &quot;NULL&quot;) = &quot;NULL&quot; StringUtils.defaultString(&quot;&quot;, &quot;NULL&quot;) = &quot;&quot; StringUtils.defaultString(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot; defaultIfEmpty(T str, T defaultStr)同defaultString(String str, String defaultStr)相似。如果是空字符串，则得到默认字符串。 反转字符串reverse(final String str)反转字符串。 123StringUtils.reverse(null) = null StringUtils.reverse("") = "" StringUtils.reverse("bat") = "tab" 缩写字符串abbreviate(String str, int maxWidth)缩写字符串为最大 maxWidth 长度的字符串，使用...作为缩写的后缀，maxWidth 不能小于等于 3。 123456StringUtils.abbreviate("", 4) = "" StringUtils.abbreviate("abcdefg", 6) = "abc..." StringUtils.abbreviate("abcdefg", 7) = "abcdefg" StringUtils.abbreviate("abcdefg", 8) = "abcdefg" StringUtils.abbreviate("abcdefg", 4) = "a..." StringUtils.abbreviate("abcdefg", 3) = IllegalArgumentException abbreviate(String str, String abbrevMarker, int maxWidth)缩写字符串为最大 maxWidth 长度的字符串，使用abbrevMarker作为缩写的后缀，maxWidth 不能小于等于abbrevMarker的长度。 12345678StringUtils.abbreviate("", "...", 4) = "" StringUtils.abbreviate("abcdefg", ".", 5) = "abcd." StringUtils.abbreviate("abcdefg", ".", 7) = "abcdefg" StringUtils.abbreviate("abcdefg", ".", 8) = "abcdefg" StringUtils.abbreviate("abcdefg", "..", 4) = "ab.." StringUtils.abbreviate("abcdefg", "..", 3) = "a.." StringUtils.abbreviate("abcdefg", "..", 2) = IllegalArgumentException StringUtils.abbreviate("abcdefg", "...", 3) = IllegalArgumentException 字符串钱后缀startsWith(CharSequence str, CharSequence prefix)判断某字符串是否包含有指定前缀的字符串。 12345StringUtils.startsWith(null, null) = true StringUtils.startsWith(null, "abc") = false StringUtils.startsWith("abcdef", null) = false StringUtils.startsWith("abcdef", "abc") = true StringUtils.startsWith("ABCDEF", "abc") = false startsWithIgnoreCase(CharSequence str, CharSequence prefix)同startsWith(CharSequence str, CharSequence prefix)相似。忽略大小写。 startsWithAny(CharSequence sequence, CharSequence… searchStrings)判断某字符串是否包含有其后任意一个指定前缀的字符串。 12345678StringUtils.startsWithAny(null, null) = false StringUtils.startsWithAny(null, new String[] &#123;"abc"&#125;) = false StringUtils.startsWithAny("abcxyz", null) = false StringUtils.startsWithAny("abcxyz", new String[] &#123;""&#125;) = true StringUtils.startsWithAny("abcxyz", new String[] &#123;"abc"&#125;) = true StringUtils.startsWithAny("abcxyz", new String[] &#123;null, "xyz", "abc"&#125;) = true StringUtils.startsWithAny("abcxyz", null, "xyz", "ABCX") = false StringUtils.startsWithAny("ABCXYZ", null, "xyz", "abc") = false endsWith(CharSequence str, CharSequence suffix)同startsWith(CharSequence str, CharSequence prefix)相反。 endsWithIgnoreCase(CharSequence str, CharSequence suffix)同startsWithIgnoreCase(CharSequence str, CharSequence prefix)相反。 endsWithAny(CharSequence sequence, CharSequence… searchStrings)同startsWithAny(CharSequence sequence, CharSequence... searchStrings)相反。 日期时间工具类FastDateFormatFastDateFormat是一个快速且线程安全的时间操作类，它完全可以替代SimpleDateFromat。因为是线程安全的，所以你可以把它作为一个类的静态字段使用。构造方法为 protected，不允许直接构造它的对象，可以通过工厂方法获取。FastDateFormat 之所以是线程安全的，是因为这个类是无状态的：内部的成员在构造时就完成了初始化，并在对象存活期，不提供任何 API 供外界修改他们。 getInstance(String pattern)获取指定日期时间格式的FastDateFormat实例。 format(Date date)将日期时间格式化为字符串。 1FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss").format(new Date()); // 2017-06-03 23:32:31 format(long millis)同format(Date date)相似。 format(Calendar calendar)同format(Date date)相似。 DateFormatUtils将时间转化为字符串的工具类。不可实例化对象且线程安全，依赖于FastDateFormat。 预定义的日期格式DateFormatUtils预定义的日期格式有如下几种： 123456public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss"); public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_TIME_ZONE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ssZZ"); public static final FastDateFormat ISO_8601_EXTENDED_DATE_FORMAT = FastDateFormat.getInstance("yyyy-MM-dd"); public static final FastDateFormat ISO_8601_EXTENDED_TIME_FORMAT = FastDateFormat.getInstance("HH:mm:ss"); public static final FastDateFormat ISO_8601_EXTENDED_TIME_TIME_ZONE_FORMAT = FastDateFormat.getInstance("HH:mm:ssZZ"); public static final FastDateFormat SMTP_DATETIME_FORMAT = FastDateFormat.getInstance("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US); format(Date date, String pattern)将日期格式化为字符串。 123DateFormatUtils.format(new Date(), "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:03:53 DateFormatUtils.ISO_8601_EXTENDED_DATETIME_FORMAT.format(new Date()); // 2017-06-03T23:09:52 DateFormatUtils.format(System.currentTimeMillis(), "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:16:59 format(long millis, String pattern)同format(Date date, String pattern)相似。 format(Calendar calendar, String pattern)同format(Date date, String pattern)相似。 DateUtilsDateUtils提供了很多很方便的功能，减轻了使用 Date 的复杂性。把原来需用Calendar才能完成的功能统一集中了起来，也就是说没有对应的CalendarUtils类。在 JDK 中，Date 与 Calendar 概念本身就有些混淆，只是为了保持兼容性才引入的 Calendar。相对于 Calendar 提供的方法，DateUtils 提供了更加合理的方法，对时间的单个字段操作变得更加的容易。 常量1234public static final long MILLIS_PER_SECOND = 1000; // 1秒钟的毫秒数 public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND; // 1分钟的毫秒数 public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE; // 1小时的毫秒数 public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR; // 1天的毫秒数 boolean isSameDay(Date date1, Date date2)判断两个日期是否是同一天。 1DateUtils.isSameDay(new Date(), new Date()); // true boolean isSameDay(Calendar cal1, Calendar cal2)同isSameDay(Date date1, Date date2)相似。 Date parseDate(String str, String… parsePatterns)解析日期时间字符串日期时间 Date 对象，通过尝试各种不同的解析器来解析表示日期的字符串。 12DateUtils.parseDate("2017-06-03 23:51:44", "yyyy-MM-dd HH:mm:ss"); // 2017-06-03 23:51:44 DateUtils.parseDate("2017年06月03日 23时51分44秒", "yyyy-MM-dd HH:mm:ss", "yyyy年MM月dd日 HH时mm分ss秒"); Date addYears(Date date, int amount)得到date日期时间后（前）amount年后的日期时间。 12Date d3 = DateUtils.addYears(new Date(), 3); // 2020-06-04 00:06:21 Date d3 = DateUtils.addYears(new Date(), -2); // 2015-06-04 00:06:21 Date addMonths(Date date, int amount)同addYears(Date date, int amount)相似，对月份数进行加减。 Date addWeeks(Date date, int amount)同addYears(Date date, int amount)相似，对周数进行加减。 Date addDays(Date date, int amount)同addYears(Date date, int amount)相似，对天数进行加减。 Date addHours(Date date, int amount)同addYears(Date date, int amount)相似，对小时数进行加减。 Date addMinutes(Date date, int amount)同addYears(Date date, int amount)相似，对分钟数进行加减。 Date addSeconds(Date date, int amount)同addYears(Date date, int amount)相似，对秒数进行加减。 Date addMilliseconds(Date date, int amount)同addYears(Date date, int amount)相似，对毫秒数进行加减。 Date setYears(Date date, int amount)对给定的日期时间设置年份。 1Date d4 = DateUtils.setYears(new Date(), 2028); // 2028-06-04 00:16:48 Date setMonths(Date date, int amount)同setYears(Date date, int amount)相似，对月数进行设置。 Date setDays(Date date, int amount)同setYears(Date date, int amount)相似，对天数进行设置。 Date setHours(Date date, int amount)同setYears(Date date, int amount)相似，对小时数进行设置。 Date setMinutes(Date date, int amount)同setYears(Date date, int amount)相似，对分钟数进行设置。 Date setSeconds(Date date, int amount)同setYears(Date date, int amount)相似，对秒钟数进行设置。 Date setMilliseconds(Date date, int amount)同setYears(Date date, int amount)相似，对毫秒数进行设置。 toCalendar(Date date)将日期转为Calendar实例。 Date round(Date date, int field)对日期时间进行四舍五入。filed 指定取整的字段，可以取的值为 Calendar.SECOND Calendar.MINUTE Calendar.HOUR_OF_DAY Calendar.DAY_OF_MONTH Calendar.MONTH Calendar.YEAR … 12345678// 当前时间为'2017-06-04 00:44:41'，则执行以下代码DateUtils.round(new Date(), Calendar.YEAR); // 2017-01-01 00:00:00 DateUtils.round(new Date(), Calendar.MONTH); // 2017-06-01 00:00:00 DateUtils.round(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 01:00:00 DateUtils.round(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-04 00:00:00 DateUtils.round(new Date(), Calendar.HOUR); // 2017-06-04 01:00:00 DateUtils.round(new Date(), Calendar.MINUTE); // 2017-06-04 00:45:00 DateUtils.round(new Date(), Calendar.SECOND); // 2017-06-04 00:44:43 Date truncate(Date date, int field)从给定字段开始格式化截取日期。对一个时间对象的某个字段进行截断。 12345678// 当前时间为'2017-06-04 00:56:05'，则执行以下代码DateUtils.truncate(new Date(), Calendar.YEAR); // 2017-01-01 00:00:00 DateUtils.truncate(new Date(), Calendar.MONTH); // 2017-06-01 00:00:00 DateUtils.truncate(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 00:00:00 DateUtils.truncate(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-04 00:00:00 DateUtils.truncate(new Date(), Calendar.HOUR); // 2017-06-04 00:00:00 DateUtils.truncate(new Date(), Calendar.MINUTE); // 2017-06-04 00:56:00 DateUtils.truncate(new Date(), Calendar.SECOND); // 2017-06-04 00:56:05 Date ceiling(Date date, int field)从给定字段开始 “向上” 格式化日期。 12345678// 当前时间为'2017-06-04 01:02:31'，则执行以下代码DateUtils.ceiling(new Date(), Calendar.YEAR); // 2018-01-01 00:00:00 DateUtils.ceiling(new Date(), Calendar.MONTH); // 2017-07-01 00:00:00 DateUtils.ceiling(new Date(), Calendar.HOUR_OF_DAY); // 2017-06-04 02:00:00 DateUtils.ceiling(new Date(), Calendar.DAY_OF_MONTH); // 2017-06-05 00:00:00 DateUtils.ceiling(new Date(), Calendar.HOUR); // 2017-06-04 02:00:00 DateUtils.ceiling(new Date(), Calendar.MINUTE); // 2017-06-04 01:03:00 DateUtils.ceiling(new Date(), Calendar.SECOND); // 2017-06-04 01:02:32 long getFragmentInDays(Date date, int fragment)返回一个指定时间的天数。关键的是参数fragment，它的作用非常重要。它的值必须是 Calendar 的时间常量字段。 注意：小时必须用 24 小时制的，即Calendar.HOUR_OF_DAY，而不能用Calendar.HOUR字段。 123// 当前时间为'2017-06-04 01:12:31'，则执行以下代码DateUtils.getFragmentInDays(new Date(), Calendar.YEAR); // 155 DateUtils.getFragmentInDays(new Date(), Calendar.MONTH); // 4 long getFragmentInMilliseconds(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInSeconds(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInMinutes(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 long getFragmentInHours(Date date, int fragment)同getFragmentInDays(Date date, int fragment)相似。 boolean truncatedEquals(Date date1, Date date2, int field)比较日历对应字段是否相等。 StopWatchStopWatch是一个方便的计时器。 使用示例12345StopWatch stopWatch = new StopWatch(); stopWatch.start(); ...stopWatch.stop(); System.out.println(stopWatch.getTime()); 主要方法： start() 开始计时 stop() 停止计时 reset() 重置计时 suspend() 暂停计时 resume() 继续计时 getTime() 获取消耗的毫秒数 getNanoTime() 获取消耗的纳秒数 getStartTime() 获取开始的毫秒数 isStarted() 是否开始 isSuspended() 是否暂停 isStopped() 是否停止 其它类简介RandomStringUtils: 1234567//随机生成n位数数字RandomStringUtils.randomNumeric(n);//在指定字符串中生成长度为n的随机字符串RandomStringUtils.random(n, "abcdefghijk");//指定从字符或数字中生成随机字符串System.out.println(RandomStringUtils.random(n, true, false)); System.out.println(RandomStringUtils.random(n, false, true)); NumberUtils: 123456//从数组中选出最大值NumberUtils.max(new int[] &#123; 1, 2, 3, 4 &#125;);//---4//判断字符串是否全是整数NumberUtils.isDigits("153.4");//--false//判断字符串是否是有效数字NumberUtils.isNumber("0321.1");//---false 结语 只是简单的介绍了 commons-lang 中的一些常用工具类，还有许多挺实用的就不一一列举。还是要自己去查阅文档试用了才能体会到它的简便。 参考：https://blog.csdn.net/terryzero/article/details/4317320http://www.cnblogs.com/DreamDrive/p/4282323.htmlhttp://blinkfox.com/tag/commons/]]></content>
      <tags>
        <tag>Java</tag>
        <tag>工具类</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[guava入门实战]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25-2%2F</url>
    <content type="text"><![CDATA[实战操作教程：https://www.yiibai.com/guava/参考官方中文文档：http://ifeve.com/google-guava/guava官方项目：https://github.com/google/guava]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式三种实现----饿汉式 饱汉式(懒汉式) 双重锁模式]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25-1%2F</url>
    <content type="text"><![CDATA[在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。Java 中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。” 一、什么时候使用单例模式：当实例存在多个会引起程序逻辑错误的时候 二、好处：1、减少内存的占用 2、单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。 3、因为类控制了实例化过程，所以类可以灵活更改实例化过程 三、单例模式的三种模式：1、饿汉式 1234567891011121314151617181920212223package com.lxk.designPattern.singleton;/** * 饿汉式--就是屌丝，穷，不给准备好，担心饿死。类加载就给准备好 * * Created by lxk on 2017/3/23 */public class SingletonPattern1 &#123; //有的会加final修饰符（更为严谨），添加final修饰符之后，指向的引用不能再做更改。 //这是final的用法：final成员变量表示常量，只能被赋值一次，赋值后值不能再改变。 //这句话得这么理解： //对于一个final变量。 // 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改； // 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 private static final SingletonPattern1 singletonInstance = new SingletonPattern1(); private SingletonPattern1() &#123; &#125; public static SingletonPattern1 getSingletonInstance() &#123; return singletonInstance; &#125;&#125; 2、饱汉式（也叫懒汉式）– 延迟加载 123456789101112131415161718192021222324252627282930313233343536373839package com.lxk.designPattern.singleton;/** * 饱汉式（懒汉式）----就是有钱，豪，用的时候再new（线程不安全） * * Created by lxk on 2017/3/23 */public class SingletonPattern2 &#123; //这个就不能加final，因为要在其他地方给他再次赋值呢。 //加了final，那就默认一直是null啦，而且还不能再次给此属性赋值。 //此属性是静态，那么就是共享数据，多线程并发操作共享数据是有可能的。那么就会出现下面的线程不安全现象。 private static SingletonPattern2 singletonInstance; private SingletonPattern2() &#123; &#125; public static SingletonPattern2 getSingletonInstance() &#123; if (singletonInstance == null) &#123; //在这个地方,多线程的时候， //可能A线程挂起，此属性还是null，那么B线程可能也判断条件OK也进来啦。 //然后A线程可以执行的时候就会new个对象，线程B也会new个对象。 //就不能保证内存的唯一性。也就是线程不安全 singletonInstance = new SingletonPattern2(); &#125; return singletonInstance; &#125; ///** // * 为了应对上述的不安全，可以简单的如下操作给方法添加[synchronized],使之成为同步函数。 // * 但是： // * 在很多线程的情况下，就每个线程访问都得判断锁，效率就是问题。所以，才有后面的[双重锁形式] // */ //public static synchronized SingletonPattern2 getSingletonInstance() &#123; // if (singletonInstance == null) &#123; // singletonInstance = new SingletonPattern2(); // &#125; // return singletonInstance; //&#125;&#125; 3、双重锁形式 这个模式将同步内容下放到 if 内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。避免土豪模式下创建单例，可能存在的线程不安全问题。 123456789101112131415161718192021222324252627282930313233343536package com.lxk.designPattern.singleton;/** * 双重锁形式 * 这个模式将同步内容下放到if内部，提高了执行的效率，不必每次获取对象时都进行同步， * 只有第一次才同步，创建了以后就没必要了。避免土豪模式下创建单例，可能存在的线程不安全问题。 * &lt;p&gt; * Created by lxk on 2017/3/23 */public class SingletonPattern3 &#123; private static SingletonPattern3 singletonInstance; private SingletonPattern3() &#123; &#125; /** * 静态方法同步的时候，使用的锁，就不能是this，而是类.class */ public static SingletonPattern3 getSingletonInstance() &#123; if (singletonInstance == null) &#123; //这个地方可能有多个线程，在这排队，ABCD..。 synchronized (SingletonPattern3.class) &#123; if (singletonInstance == null) &#123; //假设第一次A线程走到这，然后，呈挂起状态。这个时候，单例对象还未创建； // 假设此时，B线程也来了判断单例对象==null成立，但是，因为A线程已经给里层的if判断上锁，所以，B只能在外等着。 //假设A线程被唤醒，那么，单例就会下面语句赋值，单例对象就创建啦。然后释放锁。B就可以进来啦。 //B线程进来之后，先判断单例对象是否为null，发现已经不是null啦，那么就不需要创建啦。 //CD线程同样， //再往后面来的，第一个if就进不来啦，那就不会判断锁了。 singletonInstance = new SingletonPattern3(); &#125; &#125; &#125; return singletonInstance; &#125;&#125; 重点就是：1. 私有 (private) 静态 (static) 的单例对象(object)2. 构造函数 (struct)—– 可在构造方法初始化单例对象3. 提供对外 (public)，静态方法获得单例对象 原文：https://blog.csdn.net/qq_27093465/article/details/50978916]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列五：JUC线程池]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-25%2F</url>
    <content type="text"><![CDATA[01 线程池架构概要前面分别介绍了 “Java 多线程基础 “、”JUC 原子类 “和”JUC 锁 “。本章介绍 JUC 的最后一部分的内容——线程池。内容包括：线程池架构图线程池示例 线程池架构图线程池的架构图如下： 1. Executor 它是 “执行者” 接口，它是来执行任务的。准确的说，Executor 提供了 execute() 接口来执行已提交的 Runnable 任务的对象。Executor 存在的目的是提供一种将 “任务提交” 与 “任务如何运行” 分离开来的机制。它只包含一个函数接口： 1void execute(Runnable command) 2. ExecutorService ExecutorService 继承于 Executor。它是 “执行者服务” 接口，它是为 “执行者接口 Executor” 服务而存在的；准确的话，ExecutorService 提供了 “将任务提交给执行者的接口 (submit 方法)”，”让执行者执行任务 (invokeAll, invokeAny 方法)” 的接口等等。 ExecutorService 的函数列表 123456789101112131415161718192021222324// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。boolean awaitTermination(long timeout, TimeUnit unit)// 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)// 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表。&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)// 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)// 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)// 如果此执行程序已关闭，则返回 true。boolean isShutdown()// 如果关闭后所有任务都已完成，则返回 true。boolean isTerminated()// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。void shutdown()// 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。List&lt;Runnable&gt; shutdownNow()// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。Future&lt;?&gt; submit(Runnable task)// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) 3. AbstractExecutorService AbstractExecutorService 是一个抽象类，它实现了 ExecutorService 接口。AbstractExecutorService 存在的目的是为 ExecutorService 中的函数接口提供了默认实现。 AbstractExecutorService 函数列表由于它的函数列表和 ExecutorService 一样，这里就不再重复列举了。 4. ThreadPoolExecutor ThreadPoolExecutor 就是大名鼎鼎的 “线程池”。它继承于 AbstractExecutorService 抽象类。 ThreadPoolExecutor 函数列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)// 用给定的初始参数和默认的线程工厂创建新的 ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)// 用给定的初始参数和默认被拒绝的执行处理程序创建新的 ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)// 用给定的初始参数创建新的 ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)// 基于完成执行给定 Runnable 所调用的方法。protected void afterExecute(Runnable r, Throwable t)// 如果在保持活动时间内没有任务到达，新任务到达时正在替换（如果需要），则设置控制核心线程是超时还是终止的策略。void allowCoreThreadTimeOut(boolean value)// 如果此池允许核心线程超时和终止，如果在 keepAlive 时间内没有任务到达，新任务到达时正在替换（如果需要），则返回 true。boolean allowsCoreThreadTimeOut()// 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行。boolean awaitTermination(long timeout, TimeUnit unit)// 在执行给定线程中的给定 Runnable 之前调用的方法。protected void beforeExecute(Thread t, Runnable r)// 在将来某个时间执行给定任务。void execute(Runnable command)// 当不再引用此执行程序时，调用 shutdown。protected void finalize()// 返回主动执行任务的近似线程数。int getActiveCount()// 返回已完成执行的近似任务总数。long getCompletedTaskCount()// 返回核心线程数。int getCorePoolSize()// 返回线程保持活动的时间，该时间就是超过核心池大小的线程可以在终止前保持空闲的时间值。long getKeepAliveTime(TimeUnit unit)// 返回曾经同时位于池中的最大线程数。int getLargestPoolSize()// 返回允许的最大线程数。int getMaximumPoolSize()// 返回池中的当前线程数。int getPoolSize()// 返回此执行程序使用的任务队列。BlockingQueue&lt;Runnable&gt; getQueue()// 返回用于未执行任务的当前处理程序。RejectedExecutionHandler getRejectedExecutionHandler()// 返回曾计划执行的近似任务总数。long getTaskCount()// 返回用于创建新线程的线程工厂。ThreadFactory getThreadFactory()// 如果此执行程序已关闭，则返回 true。boolean isShutdown()// 如果关闭后所有任务都已完成，则返回 true。boolean isTerminated()// 如果此执行程序处于在 shutdown 或 shutdownNow 之后正在终止但尚未完全终止的过程中，则返回 true。boolean isTerminating()// 启动所有核心线程，使其处于等待工作的空闲状态。int prestartAllCoreThreads()// 启动核心线程，使其处于等待工作的空闲状态。boolean prestartCoreThread()// 尝试从工作队列移除所有已取消的 Future 任务。void purge()// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。boolean remove(Runnable task)// 设置核心线程数。void setCorePoolSize(int corePoolSize)// 设置线程在终止前可以保持空闲的时间限制。void setKeepAliveTime(long time, TimeUnit unit)// 设置允许的最大线程数。void setMaximumPoolSize(int maximumPoolSize)// 设置用于未执行任务的新处理程序。void setRejectedExecutionHandler(RejectedExecutionHandler handler)// 设置用于创建新线程的线程工厂。void setThreadFactory(ThreadFactory threadFactory)// 按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。void shutdown()// 尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表。List&lt;Runnable&gt; shutdownNow()// 当 Executor 已经终止时调用的方法。protected void terminated() 5. ScheduledExecutorService ScheduledExecutorService 是一个接口，它继承于于 ExecutorService。它相当于提供了 “延时” 和 “周期执行” 功能的 ExecutorService。ScheduledExecutorService 提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。 ScheduledExecutorService 函数列表 12345678// 创建并执行在给定延迟后启用的 ScheduledFuture。&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)// 创建并执行在给定延迟后启用的一次性操作。ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) 6. ScheduledThreadPoolExecutor ScheduledThreadPoolExecutor 继承于 ThreadPoolExecutor，并且实现了 ScheduledExecutorService 接口。它相当于提供了 “延时” 和 “周期执行” 功能的 ScheduledExecutorService。ScheduledThreadPoolExecutor 类似于 Timer，但是在高并发程序中，ScheduledThreadPoolExecutor 的性能要优于 Timer。 ScheduledThreadPoolExecutor 函数列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 使用给定核心池大小创建一个新 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor(int corePoolSize)// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler)// 使用给定的初始参数创建一个新 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory)// 使用给定初始参数创建一个新 ScheduledThreadPoolExecutor。ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)// 修改或替换用于执行 callable 的任务。protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)// 修改或替换用于执行 runnable 的任务。protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)// 使用所要求的零延迟执行命令。void execute(Runnable command)// 获取有关在此执行程序已 shutdown 的情况下、是否继续执行现有定期任务的策略。boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()// 获取有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()// 返回此执行程序使用的任务队列。BlockingQueue&lt;Runnable&gt; getQueue()// 从执行程序的内部队列中移除此任务（如果存在），从而如果尚未开始，则其不再运行。boolean remove(Runnable task)// 创建并执行在给定延迟后启用的 ScheduledFuture。&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)// 创建并执行在给定延迟后启用的一次性操作。ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有定期任务的策略。void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)// 设置有关在此执行程序已 shutdown 的情况下是否继续执行现有延迟任务的策略。void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)// 在以前已提交任务的执行中发起一个有序的关闭，但是不接受新任务。void shutdown()// 尝试停止所有正在执行的任务、暂停等待任务的处理，并返回等待执行的任务列表。List&lt;Runnable&gt; shutdownNow()// 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。Future&lt;?&gt; submit(Runnable task)// 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) 7. Executors Executors 是个静态工厂类。它通过静态工厂方法返回 ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。 Executors 函数列表 12345678910111213141516171819202122232425262728293031323334353637383940// 返回 Callable 对象，调用它时可运行给定特权的操作并返回其结果。static Callable&lt;Object&gt; callable(PrivilegedAction&lt;?&gt; action)// 返回 Callable 对象，调用它时可运行给定特权的异常操作并返回其结果。static Callable&lt;Object&gt; callable(PrivilegedExceptionAction&lt;?&gt; action)// 返回 Callable 对象，调用它时可运行给定的任务并返回 null。static Callable&lt;Object&gt; callable(Runnable task)// 返回 Callable 对象，调用它时可运行给定的任务并返回给定的结果。static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result)// 返回用于创建新线程的默认线程工厂。static ThreadFactory defaultThreadFactory()// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。static ExecutorService newCachedThreadPool()// 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。static ExecutorService newFixedThreadPool(int nThreads)// 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)// 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。static ExecutorService newSingleThreadExecutor()// 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。static ScheduledExecutorService newSingleThreadScheduledExecutor()// 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)// 返回 Callable 对象，调用它时可在当前的访问控制上下文中执行给定的 callable 对象。static &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable)// 返回 Callable 对象，调用它时可在当前的访问控制上下文中，使用当前上下文类加载器作为上下文类加载器来执行给定的 callable 对象。static &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable)// 返回用于创建新线程的线程工厂，这些新线程与当前线程具有相同的权限。static ThreadFactory privilegedThreadFactory()// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。static ExecutorService unconfigurableExecutorService(ExecutorService executor)// 返回一个将所有已定义的 ExecutorService 方法委托给指定执行程序的对象，但是使用强制转换可能无法访问其他方法。static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) 线程池示例下面通过示例来对线程池的使用做简单演示。 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;public class ThreadPoolDemo1 &#123; public static void main(String[] args) &#123; // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread ta = new MyThread(); Thread tb = new MyThread(); Thread tc = new MyThread(); Thread td = new MyThread(); Thread te = new MyThread(); // 将线程放入池中进行执行 pool.execute(ta); pool.execute(tb); pool.execute(tc); pool.execute(td); pool.execute(te); // 关闭线程池 pool.shutdown(); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+ " is running."); &#125;&#125; 运行结果： 12345pool-1-thread-1 is running.pool-1-thread-2 is running.pool-1-thread-1 is running.pool-1-thread-2 is running.pool-1-thread-1 is running. 结果说明：主线程中创建了线程池 pool，线程池的容量是 2。即，线程池中最多能同时运行 2 个线程。紧接着，将 ta,tb,tc,td,te 这 3 个线程添加到线程池中运行。最后，通过 shutdown() 关闭线程池。 02 线程池原理(一)概要在上一章 “Java 多线程系列 –“JUC 线程池”01 之 线程池架构 “ 中，我们了解了线程池的架构。线程池的实现类是 ThreadPoolExecutor 类。本章，我们通过分析 ThreadPoolExecutor 类，来了解线程池的原理。内容包括：ThreadPoolExecutor 简介ThreadPoolExecutor 数据结构线程池调度 ThreadPoolExecutor 简介ThreadPoolExecutor 是线程池类。对于线程池，可以通俗的将它理解为 “存放一定数量线程的一个线程集合。线程池允许若干个线程同时运行，允许同时运行的线程数量就是线程池的容量；当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。” ThreadPoolExecutor 数据结构ThreadPoolExecutor 的数据结构如下图所示： 各个数据在 ThreadPoolExecutor.java 中的定义如下： 123456789101112131415161718192021222324// 阻塞队列。private final BlockingQueue&lt;Runnable&gt; workQueue;// 互斥锁private final ReentrantLock mainLock = new ReentrantLock();// 线程集合。一个Worker对应一个线程。private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();// “终止条件”，与“mainLock”绑定。private final Condition termination = mainLock.newCondition();// 线程池中线程数量曾经达到过的最大值。private int largestPoolSize;// 已完成任务数量private long completedTaskCount;// ThreadFactory对象，用于创建线程。private volatile ThreadFactory threadFactory;// 拒绝策略的处理句柄。private volatile RejectedExecutionHandler handler;// 保持线程存活时间。private volatile long keepAliveTime;private volatile boolean allowCoreThreadTimeOut;// 核心池大小private volatile int corePoolSize;// 最大池大小private volatile int maximumPoolSize; 1. workers workers 是 HashSet 类型，即它是一个 Worker 集合。而一个 Worker 对应一个线程，也就是说线程池通过 workers 包含了 “一个线程集合”。当 Worker 对应的线程池启动时，它会执行线程池中的任务；当执行完一个任务后，它会从线程池的阻塞队列中取出一个阻塞的任务来继续运行。 wokers 的作用是，线程池通过它实现了 “允许多个线程同时运行”。 2. workQueue workQueue 是 BlockingQueue 类型，即它是一个阻塞队列。当线程池中的线程数超过它的容量的时候，线程会进入阻塞队列进行阻塞等待。 通过 workQueue，线程池实现了阻塞功能。 3. mainLock mainLock 是互斥锁，通过 mainLock 实现了对线程池的互斥访问。 4. corePoolSize 和 maximumPoolSize corePoolSize 是 “ 核心池大小 “，maximumPoolSize 是” 最大池大小 “。它们的作用是调整” 线程池中实际运行的线程的数量 “。 例如，当新任务提交给线程池时 (通过 execute 方法)。 – 如果此时，线程池中运行的线程数量 &lt; corePoolSize，则创建新线程来处理请求。 – 如果此时，线程池中运行的线程数量 &gt; corePoolSize，但是却 &lt; maximumPoolSize；则仅当阻塞队列满时才创建新线程。 如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。在大多数情况下，核心池大小和最大池大小的值是在创建线程池设置的；但是，也可以使用 setCorePoolSize(int) 和 setMaximumPoolSize(int) 进行动态更改。 5. poolSize poolSize 是当前线程池的实际大小，即线程池中任务的数量。 6. allowCoreThreadTimeOut 和 keepAliveTime allowCoreThreadTimeOut 表示是否允许 “线程在空闲状态时，仍然能够存活”；而 keepAliveTime 是当线程池处于空闲状态的时候，超过 keepAliveTime 时间之后，空闲的线程会被终止。 7. threadFactory threadFactory 是 ThreadFactory 对象。它是一个线程工厂类，”线程池通过 ThreadFactory 创建线程”。 8. handler handler 是 RejectedExecutionHandler 类型。它是 “线程池拒绝策略” 的句柄，也就是说 “当某任务添加到线程池中，而线程池拒绝该任务时，线程池会通过 handler 进行相应的处理”。 综上所说，线程池通过 workers 来管理 “线程集合”，每个线程在启动后，会执行线程池中的任务；当一个任务执行完后，它会从线程池的阻塞队列中取出任务来继续运行。阻塞队列是管理线程池任务的队列，当添加到线程池中的任务超过线程池的容量时，该任务就会进入阻塞队列进行等待。 线程池调度我们通过下面的图看看下面线程池中任务的调度策略，加深对线程池的理解。 图 - 01: 图 - 02: 说明： 在 “图 - 01” 中，线程池中有 N 个任务。”任务 1”, “任务 2”, “任务 3” 这 3 个任务在执行，而 “任务 3” 到 “任务 N” 在阻塞队列中等待。正在执行的任务，在 workers 集合中，workers 集合包含 3 个 Worker，每一个 Worker 对应一个 Thread 线程，Thread 线程每次处理一个任务。 当 workers 集合中处理完某一个任务之后，会从阻塞队列中取出一个任务来继续执行，如图 - 02 所示。图 - 02 表示 “任务 1” 处理完毕之后，线程池将 “任务 4” 从阻塞队列中取出，放到 workers 中进行处理。 03 线程池原理(二)概要在前面一章 “Java 多线程系列 –“JUC 线程池”02 之 线程池原理 (一)“ 中介绍了线程池的数据结构，本章会通过分析线程池的源码，对线程池进行说明。内容包括：线程池示例参考代码 (基于 JDK1.7.0_40)线程池源码分析 (一) 创建 “线程池” (二) 添加任务到 “线程池” (三) 关闭 “线程池” 线程池示例在分析线程池之前，先看一个简单的线程池示例。 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;public class ThreadPoolDemo1 &#123; public static void main(String[] args) &#123; // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread ta = new MyThread(); Thread tb = new MyThread(); Thread tc = new MyThread(); Thread td = new MyThread(); Thread te = new MyThread(); // 将线程放入池中进行执行 pool.execute(ta); pool.execute(tb); pool.execute(tc); pool.execute(td); pool.execute(te); // 关闭线程池 pool.shutdown(); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+ " is running."); &#125;&#125; 运行结果： 12345pool-1-thread-1 is running.pool-1-thread-2 is running.pool-1-thread-1 is running.pool-1-thread-2 is running.pool-1-thread-1 is running. 示例中，包括了线程池的创建，将任务添加到线程池中，关闭线程池这 3 个主要的步骤。稍后，我们会从这 3 个方面来分析 ThreadPoolExecutor。 参考代码 (基于 JDK1.7.0_40)Executors 完整源码Executors.java完整源码ThreadPoolExecutor 完整源码ThreadPoolExecutor.java完整源码 线程池源码分析(一) 创建 “线程池” 下面以 newFixedThreadPool() 介绍线程池的创建过程。 1. newFixedThreadPool() newFixedThreadPool() 在 Executors.java 中定义，源码如下： 123public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 说明：newFixedThreadPool(int nThreads) 的作用是创建一个线程池，线程池的容量是 nThreads。 newFixedThreadPool() 在调用 ThreadPoolExecutor() 时，会传递一个 LinkedBlockingQueue() 对象，而 LinkedBlockingQueue 是单向链表实现的阻塞队列。在线程池中，就是通过该阻塞队列来实现 “当线程池中任务数量超过允许的任务数量时，部分任务会阻塞等待”。关于 LinkedBlockingQueue 的实现细节，读者可以参考 “Java 多线程系列 –“JUC 集合”08 之 LinkedBlockingQueue“。 2. ThreadPoolExecutor() ThreadPoolExecutor() 在 ThreadPoolExecutor.java 中定义，源码如下： 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 说明：该函数实际上是调用 ThreadPoolExecutor 的另外一个构造函数。该函数的源码如下： 1234567891011121314151617181920212223242526public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); // 核心池大小 this.corePoolSize = corePoolSize; // 最大池大小 this.maximumPoolSize = maximumPoolSize; // 线程池的等待队列 this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); // 线程工厂对象 this.threadFactory = threadFactory; // 拒绝策略的句柄 this.handler = handler;&#125; 说明：在 ThreadPoolExecutor() 的构造函数中，进行的是初始化工作。corePoolSize, maximumPoolSize, unit, keepAliveTime 和 workQueue 这些变量的值是已知的，它们都是通过 newFixedThreadPool() 传递而来。下面看看 threadFactory 和 handler 对象。 2.1 ThreadFactory 线程池中的 ThreadFactory 是一个线程工厂，线程池创建线程都是通过线程工厂对象 (threadFactory) 来完成的。上面所说的 threadFactory 对象，是通过 Executors.defaultThreadFactory() 返回的。Executors.java 中的 defaultThreadFactory() 源码如下： 123public static ThreadFactory defaultThreadFactory() &#123; return new DefaultThreadFactory();&#125; defaultThreadFactory() 返回 DefaultThreadFactory 对象。Executors.java 中的 DefaultThreadFactory() 源码如下： 123456789101112131415161718192021222324252627282930static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-"; &#125; // 提供创建线程的API。 public Thread newThread(Runnable r) &#123; // 线程对应的任务是Runnable对象r Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); // 设为“非守护线程” if (t.isDaemon()) t.setDaemon(false); // 将优先级设为“Thread.NORM_PRIORITY” if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 说明：ThreadFactory 的作用就是提供创建线程的功能的线程工厂。 它是通过 newThread()提供创建线程功能的，下面简单说说 newThread()。newThread()创建的线程对应的任务是 Runnable 对象，它创建的线程都是 “非守护线程” 而且“线程优先级都是 Thread.NORM_PRIORITY”。 2.2 RejectedExecutionHandler handler 是 ThreadPoolExecutor 中拒绝策略的处理句柄。所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。线程池默认会采用的是 defaultHandler 策略，即 AbortPolicy 策略。在 AbortPolicy 策略中，线程池拒绝任务时会抛出异常！defaultHandler 的定义如下： 1private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); AbortPolicy 的源码如下： 12345678910public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; // 抛出异常 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); &#125;&#125; (二) 添加任务到 “线程池” 1. execute() execute() 定义在 ThreadPoolExecutor.java 中，源码如下： 1234567891011121314151617181920212223242526272829public void execute(Runnable command) &#123; // 如果任务为null，则抛出异常。 if (command == null) throw new NullPointerException(); // 获取ctl对应的int值。该int值保存了"线程池中任务的数量"和"线程池状态"信息 int c = ctl.get(); // 当线程池中的任务数量 &lt; "核心池大小"时，即线程池中少于corePoolSize个任务。 // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 当线程池中的任务数量 &gt;= "核心池大小"时， // 而且，"线程池处于允许状态"时，则尝试将任务添加到阻塞队列中。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；然后通过reject()执行相应的拒绝策略的内容。 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 否则，如果"线程池中任务数量"为0，则通过addWorker(null, false)尝试新建一个线程，新建线程对应的任务为null。 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。 else if (!addWorker(command, false)) reject(command);&#125; 说明：execute() 的作用是将任务添加到线程池中执行。它会分为 3 种情况进行处理： 情况 1 – 如果 “线程池中任务数量” &lt; “核心池大小” 时，即线程池中少于 corePoolSize 个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。 情况 2 – 如果 “线程池中任务数量” &gt;= “核心池大小”，并且 “线程池是允许状态”；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认 “线程池的状态”，如果 “第 2 次读到的线程池状态” 和 “第 1 次读到的线程池状态” 不同，则从阻塞队列中删除该任务。 情况 3 – 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过 reject() 拒绝该任务。 2. addWorker() addWorker() 的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: // 更新"线程池状态和计数"标记，即更新ctl。 for (;;) &#123; // 获取ctl对应的int值。该int值保存了"线程池中任务的数量"和"线程池状态"信息 int c = ctl.get(); // 获取线程池状态。 int rs = runStateOf(c); // 有效性检查 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; // 获取线程池中任务的数量。 int wc = workerCountOf(c); // 如果"线程池中任务的数量"超过限制，则返回false。 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 通过CAS函数将c的值+1。操作失败的话，则退出循环。 if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl // 检查"线程池状态"，如果与之前的状态不同，则从retry重新开始。 if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; // 添加任务到线程池，并启动任务所在的线程。 try &#123; final ReentrantLock mainLock = this.mainLock; // 新建Worker，并且指定firstTask为Worker的第一个任务。 w = new Worker(firstTask); // 获取Worker对应的线程。 final Thread t = w.thread; if (t != null) &#123; // 获取锁 mainLock.lock(); try &#123; int c = ctl.get(); int rs = runStateOf(c); // 再次确认"线程池状态" if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 将Worker对象(w)添加到"线程池的Worker集合(workers)"中 workers.add(w); // 更新largestPoolSize int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; // 如果"成功将任务添加到线程池"中，则启动任务所在的线程。 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; // 返回任务是否启动。 return workerStarted;&#125; 说明： addWorker(Runnable firstTask, boolean core) 的作用是将任务 (firstTask) 添加到线程池中，并启动该任务。 core 为 true 的话，则以 corePoolSize 为界限，若 “线程池中已有任务数量 &gt;=corePoolSize”，则返回 false；core 为 false 的话，则以 maximumPoolSize 为界限，若 “线程池中已有任务数量 &gt;=maximumPoolSize”，则返回 false。 addWorker() 会先通过 for 循环不断尝试更新 ctl 状态，ctl 记录了 “线程池中任务数量和线程池状态”。 更新成功之后，再通过 try 模块来将任务添加到线程池中，并启动任务所在的线程。 从 addWorker() 中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的 Worker 对象；而一个 Workder 对象包含一个 Thread 对象。(01) 通过将 Worker 对象添加到 &quot;线程的 workers 集合&quot; 中，从而实现将任务添加到线程池中。 (02) 通过启动 Worker 对应的 Thread 线程，则执行该任务。 3. submit() 补充说明一点，submit() 实际上也是通过调用 execute() 实现的，源码如下： 123456public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125; (三) 关闭 “线程池” shutdown() 的源码如下： 1234567891011121314151617181920public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; // 获取锁 mainLock.lock(); try &#123; // 检查终止线程池的“线程”是否有权限。 checkShutdownAccess(); // 设置线程池的状态为关闭状态。 advanceRunState(SHUTDOWN); // 中断线程池中空闲的线程。 interruptIdleWorkers(); // 钩子函数，在ThreadPoolExecutor中没有任何动作。 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; // 释放锁 mainLock.unlock(); &#125; // 尝试终止线程池 tryTerminate();&#125; 说明：shutdown() 的作用是关闭线程池。 04 线程池原理(三)本章介绍线程池的生命周期。在 “Java 多线程系列 –“基础篇”01 之 基本概念 “ 中，我们介绍过，线程有 5 种状态：新建状态，就绪状态，运行状态，阻塞状态，死亡状态。线程池也有 5 种状态；然而，线程池不同于线程，线程池的 5 种状态是：Running, SHUTDOWN, STOP, TIDYING, TERMINATED。 线程池状态定义代码如下： 12345678910private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 说明：ctl 是一个 AtomicInteger 类型的原子对象。ctl 记录了 “线程池中的任务数量” 和 “线程池状态”2 个信息。ctl 共包括 32 位。其中，高 3 位表示 “线程池状态”，低 29 位表示 “线程池中的任务数量”。 RUNNING – 对应的高3位值是111。SHUTDOWN – 对应的高3位值是000。STOP – 对应的高3位值是001。TIDYING – 对应的高3位值是010。TERMINATED – 对应的高3位值是011。 线程池各个状态之间的切换如下图所示： 1. RUNNING (01) 状态说明：线程池处在 RUNNING 状态时，能够接收新任务，以及对已添加的任务进行处理。(02) 状态切换：线程池的初始化状态是 RUNNING。换句话说，线程池被一旦被创建，就处于 RUNNING 状态！道理很简单，在 ctl 的初始化代码中 (如下)，就将它初始化为 RUNNING 状态，并且 “任务数量” 初始化为 0。 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 2. SHUTDOWN (01) 状态说明：线程池处在 SHUTDOWN 状态时，不接收新任务，但能处理已添加的任务。(02) 状态切换：调用线程池的 shutdown() 接口时，线程池由 RUNNING -&gt; SHUTDOWN。 3. STOP (01) 状态说明：线程池处在 STOP 状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。(02) 状态切换：调用线程池的 shutdownNow() 接口时，线程池由 (RUNNING or SHUTDOWN ) -&gt; STOP。 4. TIDYING TIDYING: adj. 整齐的；整洁的 (01) 状态说明：当所有的任务已终止，ctl 记录的 “任务数量” 为 0，线程池会变为 TIDYING 状态。当线程池变为 TIDYING 状态时，会执行钩子函数 terminated()。terminated() 在 ThreadPoolExecutor 类中是空的，若用户想在线程池变为 TIDYING 时，进行相应的处理；可以通过重载 terminated() 函数来实现。 【钩子方法】：原理就是实现为空的方法，在某任务之前、之后、 执行中、报异常后调用的方法（是不是有种熟悉的感觉）。 通常钩子方法是通过抽象类或是本类中的空方法来实现的。 (02) 状态切换：当线程池在 SHUTDOWN 状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。当线程池在 STOP 状态下，线程池中执行的任务为空时，就会由 STOP -&gt; TIDYING。 5. TERMINATED(01) 状态说明：线程池彻底终止，就变成 TERMINATED 状态。(02) 状态切换：线程池处在 TIDYING 状态时，执行完 terminated() 之后，就会由 TIDYING -&gt; TERMINATED。 05 线程池原理(四)概要本章介绍线程池的拒绝策略。内容包括：拒绝策略介绍拒绝策略对比和示例 拒绝策略介绍线程池的拒绝策略，是指当任务添加到线程池中被拒绝，而采取的处理措施。当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制。 线程池共包括 4 种拒绝策略，它们分别是：AbortPolicy, CallerRunsPolicy, DiscardOldestPolicy 和 DiscardPolicy。 AbortPolicy – 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。CallerRunsPolicy – 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。DiscardOldestPolicy – 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。DiscardPolicy – 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。 线程池默认的处理策略是 AbortPolicy！ 拒绝策略对比和示例下面通过示例，分别演示线程池的 4 种拒绝策略。1. DiscardPolicy 示例2. DiscardOldestPolicy 示例3. AbortPolicy 示例4. CallerRunsPolicy 示例 1. DiscardPolicy 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.ThreadPoolExecutor.DiscardPolicy;public class DiscardPolicyDemo &#123; private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception &#123; // 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为"丢弃" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) &#123; Runnable myrun = new MyRunnable("task-"+i); pool.execute(myrun); &#125; // 关闭线程池 pool.shutdown(); &#125;&#125;class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(this.name + " is running."); Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12task-0 is running.task-1 is running. 结果说明：线程池 pool 的 “最大池大小” 和 “核心池大小” 都为 1(THREADS_SIZE)，这意味着 “线程池能同时运行的任务数量最大只能是 1”。线程池 pool 的阻塞队列是 ArrayBlockingQueue，ArrayBlockingQueue 是一个有界的阻塞队列，ArrayBlockingQueue 的容量为 1。这也意味着线程池的阻塞队列只能有一个线程池阻塞等待。根据 “” 中分析的 execute() 代码可知：线程池中共运行了 2 个任务。第 1 个任务直接放到 Worker 中，通过线程去执行；第 2 个任务放到阻塞队列中等待。其他的任务都被丢弃了！ 2. DiscardOldestPolicy 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.lang.reflect.Field;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy;public class DiscardOldestPolicyDemo &#123; private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception &#123; // 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为"DiscardOldestPolicy" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) &#123; Runnable myrun = new MyRunnable("task-"+i); pool.execute(myrun); &#125; // 关闭线程池 pool.shutdown(); &#125;&#125;class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(this.name + " is running."); Thread.sleep(200); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12task-0 is running.task-9 is running. 结果说明：将 “线程池的拒绝策略” 由 DiscardPolicy 修改为 DiscardOldestPolicy 之后，当有任务添加到线程池被拒绝时，线程池会丢弃阻塞队列中末尾的任务，然后将被拒绝的任务添加到末尾。 3. AbortPolicy 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.lang.reflect.Field;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.ThreadPoolExecutor.AbortPolicy;import java.util.concurrent.RejectedExecutionException;public class AbortPolicyDemo &#123; private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception &#123; // 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为"抛出异常" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); try &#123; // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) &#123; Runnable myrun = new MyRunnable("task-"+i); pool.execute(myrun); &#125; &#125; catch (RejectedExecutionException e) &#123; e.printStackTrace(); // 关闭线程池 pool.shutdown(); &#125; &#125;&#125;class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(this.name + " is running."); Thread.sleep(200); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; (某一次) 运行结果： 1234567java.util.concurrent.RejectedExecutionException at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:1774) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:768) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:656) at AbortPolicyDemo.main(AbortPolicyDemo.java:27)task-0 is running.task-1 is running. 结果说明：将 “线程池的拒绝策略” 由 DiscardPolicy 修改为 AbortPolicy 之后，当有任务添加到线程池被拒绝时，会抛出 RejectedExecutionException。 4. CallerRunsPolicy 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.lang.reflect.Field;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;public class CallerRunsPolicyDemo &#123; private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception &#123; // 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY)); // 设置线程池的拒绝策略为"CallerRunsPolicy" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i &lt; 10; i++) &#123; Runnable myrun = new MyRunnable("task-"+i); pool.execute(myrun); &#125; // 关闭线程池 pool.shutdown(); &#125;&#125;class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; System.out.println(this.name + " is running."); Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; (某一次) 运行结果： 12345678910task-2 is running.task-3 is running.task-4 is running.task-5 is running.task-6 is running.task-7 is running.task-8 is running.task-9 is running.task-0 is running.task-1 is running. 结果说明：将 “线程池的拒绝策略” 由 DiscardPolicy 修改为 CallerRunsPolicy 之后，当有任务添加到线程池被拒绝时，线程池会将被拒绝的任务添加到 “线程池正在运行的线程” 中取运行。 06 Callable和Future概要本章介绍线程池中的 Callable 和 Future。Callable 和 Future 简介示例和源码分析 (基于 JDK1.7.0_40) Callable 和 Future 简介 Callable 和 Future 是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到它们。Callable 用于产生结果，Future 用于获取结果。 1. Callable Callable 是一个接口，它只包含一个 call() 方法。Callable 是一个返回结果并且可能抛出异常的任务。 为了便于理解，我们可以将 Callable 比作一个 Runnable 接口，而 Callable 的 call() 方法则类似于 Runnable 的 run() 方法。 Callable 的源码如下： 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 说明：从中我们可以看出 Callable 支持泛型。 2. Future Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。 Future 的源码如下： 1234567891011121314151617public interface Future&lt;V&gt; &#123; // 试图取消对此任务的执行。 boolean cancel(boolean mayInterruptIfRunning) // 如果在任务正常完成前将其取消，则返回 true。 boolean isCancelled() // 如果任务已完成，则返回 true。 boolean isDone() // 如有必要，等待计算完成，然后获取其结果。 V get() throws InterruptedException, ExecutionException; // 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 说明： Future 用于表示异步计算的结果。它的实现类是 FutureTask，在讲解 FutureTask 之前，我们先看看 Callable, Future, FutureTask 它们之间的关系图，如下： 说明：(01) RunnableFuture 是一个接口，它继承了 Runnable 和 Future 这两个接口。RunnableFuture 的源码如下： 123public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; (02) FutureTask 实现了 RunnableFuture 接口。所以，我们也说它实现了 Future 接口。 示例和源码分析 (基于 JDK1.7.0_40)我们先通过一个示例看看 Callable 和 Future 的基本用法，然后再分析示例的实现原理。 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.Callable;import java.util.concurrent.Future;import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;import java.util.concurrent.ExecutionException;class MyCallable implements Callable &#123; @Override public Integer call() throws Exception &#123; int sum = 0; // 执行任务 for (int i=0; i&lt;100; i++) sum += i; //return sum; return Integer.valueOf(sum); &#125; &#125;public class CallableTest1 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException&#123; //创建一个线程池 ExecutorService pool = Executors.newSingleThreadExecutor(); //创建有返回值的任务 Callable c1 = new MyCallable(); //执行任务并获取Future对象 Future f1 = pool.submit(c1); // 输出结果 System.out.println(f1.get()); //关闭线程池 pool.shutdown(); &#125;&#125; 运行结果： 14950 结果说明： 在主线程 main 中，通过 newSingleThreadExecutor() 新建一个线程池。接着创建 Callable 对象 c1，然后再通过 pool.submit(c1) 将 c1 提交到线程池中进行处理，并且将返回的结果保存到 Future 对象 f1 中。然后，我们通过 f1.get() 获取 Callable 中保存的结果；最后通过 pool.shutdown() 关闭线程池。 1. submit() submit() 在 java/util/concurrent/AbstractExecutorService.java 中实现，它的源码如下： 123456789public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); // 创建一个RunnableFuture对象 RunnableFuture&lt;T&gt; ftask = newTaskFor(task); // 执行“任务ftask” execute(ftask); // 返回“ftask” return ftask;&#125; 说明：submit() 通过 newTaskFor(task) 创建了 RunnableFuture 对象 ftask。它的源码如下： 123protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125; 2. FutureTask 的构造函数 FutureTask 的构造函数如下： 12345678public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); // callable是一个Callable对象 this.callable = callable; // state记录FutureTask的状态 this.state = NEW; // ensure visibility of callable&#125; 3. FutureTask 的 run() 方法 我们继续回到 submit() 的源码中。在 newTaskFor() 新建一个 ftask 对象之后，会通过 execute(ftask) 执行该任务。此时 ftask 被当作一个 Runnable 对象进行执行，最终会调用到它的 run() 方法；ftask 的 run() 方法在 java/util/concurrent/FutureTask.java 中实现，源码如下： 1234567891011121314151617181920212223242526272829303132public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; // 将callable对象赋值给c。 Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; // 执行Callable的call()方法，并保存结果到result中。 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; // 如果运行成功，则将result保存 if (ran) set(result); &#125; &#125; finally &#123; runner = null; // 设置“state状态标记” int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 说明：run() 中会执行 Callable 对象的 call() 方法，并且最终将结果保存到 result 中，并通过 set(result) 将 result 保存。 之后调用 FutureTask 的 get() 方法，返回的就是通过 set(result) 保存的值。 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列四：JUC集合]]></title>
    <url>%2F2018%2F03%2F24%2F2018-03-24-2%2F</url>
    <content type="text"><![CDATA[01 框架概要之前，在 “Java 集合系列目录 (Category)“中，讲解了 Java 集合包中的各个类。接下来，将展开对 JUC 包中的集合进行学习。在学习之前，先温习一下”Java 集合包 “。本章内容包括：Java 集合包JUC 中的集合类 Java 集合包在 “Java 集合系列 01 之 总体框架” 中，介绍 java 集合的架构。主体内容包括 Collection 集合和 Map 类；而 Collection 集合又可以划分为 List(队列) 和 Set(集合)。 1. List 的实现类主要有: LinkedList, ArrayList, Vector, Stack。 (01) LinkedList 是双向链表实现的双端队列；它不是线程安全的，只适用于单线程。(02) ArrayList 是数组实现的队列，它是一个动态数组；它也不是线程安全的，只适用于单线程。(03) Vector 是数组实现的矢量队列，它也一个动态数组；不过和 ArrayList 不同的是，Vector 是线程安全的，它支持并发。(04) Stack 是 Vector 实现的栈；和 Vector 一样，它也是线程安全的。 2. Set 的实现类主要有: HastSet 和 TreeSet。 (01) HashSet 是一个没有重复元素的集合，它通过 HashMap 实现的；HashSet 不是线程安全的，只适用于单线程。(02) TreeSet 也是一个没有重复元素的集合，不过和 HashSet 不同的是，TreeSet 中的元素是有序的；它是通过 TreeMap 实现的；TreeSet 也不是线程安全的，只适用于单线程。 3.Map 的实现类主要有: HashMap，WeakHashMap, Hashtable 和 TreeMap。 (01) HashMap 是存储 “键 - 值对” 的哈希表；它不是线程安全的，只适用于单线程。(02) WeakHashMap 是也是哈希表；和 HashMap 不同的是，HashMap 的 “键” 是强引用类型，而 WeakHashMap 的 “键” 是弱引用类型，也就是说当 WeakHashMap 中的某个键不再正常使用时，会被从 WeakHashMap 中被自动移除。WeakHashMap 也不是线程安全的，只适用于单线程。(03) Hashtable 也是哈希表；和 HashMap 不同的是，Hashtable 是线程安全的，支持并发。(04) TreeMap 也是哈希表，不过 TreeMap 中的 “键 - 值对” 是有序的，它是通过 R-B Tree(红黑树)实现的；TreeMap 不是线程安全的，只适用于单线程。更多关于这些集合类的介绍，可以参考 “Java 集合系列目录 (Category)”。 为了方便，我们将前面介绍集合类统称为”java 集合包 “。java 集合包大多是 “非线程安全的”，虽然可以通过 Collections 工具类中的方法获取 java 集合包对应的同步类，但是这些同步类的并发效率并不是很高。为了更好的支持高并发任务，并发大师 Doug Lea 在 JUC(java.util.concurrent) 包中添加了 java 集合包中单线程类的对应的支持高并发的类。例如，ArrayList 对应的高并发类是 CopyOnWriteArrayList，HashMap 对应的高并发类是 ConcurrentHashMap，等等。 JUC 包在添加”java 集合包 “对应的高并发类时，为了保持 API 接口的一致性，使用了”Java 集合包 “中的框架。例如，CopyOnWriteArrayList 实现了 “Java 集合包” 中的 List 接口，HashMap 继承了 “java 集合包” 中的 AbstractMap 类，等等。得益于 “JUC 包使用了 Java 集合包中的类”，如果我们了解了 Java 集合包中的类的思想之后，理解 JUC 包中的类也相对容易；理解时，最大的难点是，对 JUC 包是如何添加对“高并发” 的支持的！ JUC 中的集合类下面，我们先了解 JUC 包中集合类的框架；为了方便讲诉，我将 JUC 包中的集合类划分为 3 部分来进行说明。在简单的了解 JUC 包中集合类的框架之后，后面的章节再逐步对各个类进行介绍。 1. List 和 Set JUC 集合包中的 List 和 Set 实现类包括: CopyOnWriteArrayList, CopyOnWriteArraySet 和 ConcurrentSkipListSet。ConcurrentSkipListSet 稍后在说明 Map 时再说明，CopyOnWriteArrayList 和 CopyOnWriteArraySet 的框架如下图所示： (01) CopyOnWriteArrayList 相当于线程安全的 ArrayList，它实现了 List 接口。CopyOnWriteArrayList 是支持高并发的。(02) CopyOnWriteArraySet 相当于线程安全的 HashSet，它继承于 AbstractSet 类。CopyOnWriteArraySet 内部包含一个 CopyOnWriteArrayList 对象，它是通过 CopyOnWriteArrayList 实现的。 2. Map JUC 集合包中 Map 的实现类包括: ConcurrentHashMap 和 ConcurrentSkipListMap。它们的框架如下图所示： (01) ConcurrentHashMap 是线程安全的哈希表 (相当于线程安全的 HashMap)；它继承于 AbstractMap 类，并且实现 ConcurrentMap 接口。ConcurrentHashMap 是通过“锁分段” 来实现的，它支持并发。(02) ConcurrentSkipListMap 是线程安全的有序的哈希表 (相当于线程安全的 TreeMap); 它继承于 AbstractMap 类，并且实现 ConcurrentNavigableMap 接口。ConcurrentSkipListMap 是通过“跳表” 来实现的，它支持并发。(03) ConcurrentSkipListSet 是线程安全的有序的集合 (相当于线程安全的 TreeSet)；它继承于 AbstractSet，并实现了 NavigableSet 接口。ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，它也支持并发。 3. Queue JUC 集合包中 Queue 的实现类包括: ArrayBlockingQueue, LinkedBlockingQueue, LinkedBlockingDeque, ConcurrentLinkedQueue 和 ConcurrentLinkedDeque。它们的框架如下图所示： (01) ArrayBlockingQueue 是数组实现的线程安全的有界的阻塞队列。(02) LinkedBlockingQueue 是单向链表实现的 (指定大小) 阻塞队列，该队列按 FIFO（先进先出）排序元素。(03) LinkedBlockingDeque 是双向链表实现的 (指定大小) 双向并发阻塞队列，该阻塞队列同时支持 FIFO 和 FILO 两种操作方式。(04) ConcurrentLinkedQueue 是单向链表实现的无界队列，该队列按 FIFO（先进先出）排序元素。(05) ConcurrentLinkedDeque 是双向链表实现的无界队列，该队列同时支持 FIFO 和 FILO 两种操作方式。 接下来，将逐个对 JUC 包中的集合类进行学习。 02 CopyOnWriteArrayList概要本章是 “JUC 系列 “ 的 CopyOnWriteArrayList 篇。接下来，会先对 CopyOnWriteArrayList 进行基本介绍，然后再说明它的原理，接着通过代码去分析，最后通过示例更进一步的了解 CopyOnWriteArrayList。内容包括：CopyOnWriteArrayList 介绍 CopyOnWriteArrayList 原理和数据结构CopyOnWriteArrayList 函数列表CopyOnWriteArrayList 源码分析 (JDK1.7.0_40 版本)CopyOnWriteArrayList 示例 CopyOnWriteArrayList 介绍它相当于线程安全的 ArrayList。和 ArrayList 一样，它是个可变数组；但是和 ArrayList 不同的时，它具有以下特性：1. 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。2. 它是线程安全的。3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。4. 迭代器支持 hasNext(), next() 等不可变操作，但不支持可变 remove() 等操作。5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 建议：在学习 CopyOnWriteArraySet 之前，先通过 “Java 集合系列 03 之 ArrayList 详细介绍 (源码解析) 和使用示例 “ 对 ArrayList 进行了解！ CopyOnWriteArrayList 原理和数据结构CopyOnWriteArrayList 的数据结构，如下图所示： 说明：1. CopyOnWriteArrayList 实现了 List 接口，因此它是一个队列。2. CopyOnWriteArrayList 包含了成员 lock。每一个 CopyOnWriteArrayList 都和一个互斥锁 lock 绑定，通过 lock，实现了对 CopyOnWriteArrayList 的互斥访问。3. CopyOnWriteArrayList 包含了成员 array 数组，这说明 CopyOnWriteArrayList 本质上通过数组实现的。 下面从 “动态数组” 和“线程安全”两个方面进一步对 CopyOnWriteArrayList 的原理进行说明。 CopyOnWriteArrayList 的 “动态数组” 机制 – 它内部有个 “volatile 数组”(array) 来保持数据。在 “添加 / 修改 / 删除” 数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给 “volatile 数组”。这就是它叫做 CopyOnWriteArrayList 的原因！CopyOnWriteArrayList 就是通过这种方式实现的动态数组；不过正由于它在“添加 / 修改 / 删除” 数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，效率比较高。 CopyOnWriteArrayList 的 “线程安全” 机制 – 是通过 volatile 和互斥锁来实现的。(01) CopyOnWriteArrayList 是通过 “volatile 数组” 来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了 “读取到的数据总是最新的” 这个机制的保证。(02) CopyOnWriteArrayList 通过互斥锁来保护数据。在 “添加 / 修改 / 删除” 数据时，会先 “获取互斥锁”，再修改完毕之后，先将数据更新到“volatile 数组” 中，然后再“释放互斥锁”；这样，就达到了保护数据的目的。 CopyOnWriteArrayList 函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 创建一个空列表。CopyOnWriteArrayList()// 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。CopyOnWriteArrayList(Collection&lt;? extends E&gt; c)// CopyOnWriteArrayList(E[] toCopyIn)创建一个保存给定数组的副本的列表。// 将指定元素添加到此列表的尾部。boolean add(E e)// 在此列表的指定位置上插入指定元素。void add(int index, E element)// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。boolean addAll(Collection&lt;? extends E&gt; c)// 从指定位置开始，将指定 collection 的所有元素插入此列表。boolean addAll(int index, Collection&lt;? extends E&gt; c)// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。int addAllAbsent(Collection&lt;? extends E&gt; c)// 添加元素（如果不存在）。boolean addIfAbsent(E e)// 从此列表移除所有元素。void clear()// 返回此列表的浅表副本。Object clone()// 如果此列表包含指定的元素，则返回 true。boolean contains(Object o)// 如果此列表包含指定 collection 的所有元素，则返回 true。boolean containsAll(Collection&lt;?&gt; c)// 比较指定对象与此列表的相等性。boolean equals(Object o)// 返回列表中指定位置的元素。E get(int index)// 返回此列表的哈希码值。int hashCode()// 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。int indexOf(E e, int index)// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。int indexOf(Object o)// 如果此列表不包含任何元素，则返回 true。boolean isEmpty()// 返回以恰当顺序在此列表元素上进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。int lastIndexOf(E e, int index)// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。int lastIndexOf(Object o)// 返回此列表元素的列表迭代器（按适当顺序）。ListIterator&lt;E&gt; listIterator()// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。ListIterator&lt;E&gt; listIterator(int index)// 移除此列表指定位置上的元素。E remove(int index)// 从此列表移除第一次出现的指定元素（如果存在）。boolean remove(Object o)// 从此列表移除所有包含在指定 collection 中的元素。boolean removeAll(Collection&lt;?&gt; c)// 只保留此列表中包含在指定 collection 中的元素。boolean retainAll(Collection&lt;?&gt; c)// 用指定的元素替代此列表指定位置上的元素。E set(int index, E element)// 返回此列表中的元素数。int size()// 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。List&lt;E&gt; subList(int fromIndex, int toIndex)// 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。Object[] toArray()// 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a)// 返回此列表的字符串表示形式。String toString() CopyOnWriteArrayList 源码分析 (JDK1.7.0_40 版本)JDK1.7.0_40 版本中 CopyOnWriteArrayList.java 的完整源码如下： CopyOnWriteArrayList.java 的完整源码 下面我们从 “创建，添加，删除，获取，遍历” 这 5 个方面去分析 CopyOnWriteArrayList 的原理。 1. 创建 CopyOnWriteArrayList 共 3 个构造函数。它们的源码如下： 1234567891011121314public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements = c.toArray(); if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); setArray(elements);&#125;public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));&#125; 说明：这 3 个构造函数都调用了 setArray()，setArray() 的源码如下： 123456789private volatile transient Object[] array;final Object[] getArray() &#123; return array;&#125;final void setArray(Object[] a) &#123; array = a;&#125; 说明：setArray() 的作用是给 array 赋值；其中，array 是 volatile transient Object[] 类型，即 array 是 “volatile 数组”。关于 volatile 关键字，我们知道 “volatile 能让变量变得可见”，即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。正在由于这种特性，每次更新了“volatile 数组” 之后，其它线程都能看到对它所做的更新。关于 transient 关键字，它是在序列化中才起作用，transient 变量不会被自动序列化。transient 不是本文关注的重点，了解即可。关于 transient 的更多内容，请参考：http://www.cnblogs.com/skywang12345/p/io_06.html 2. 添加 以 add(E e)为例，来对 “CopyOnWriteArrayList 的添加操作” 进行说明。下面是 add(E e)的代码： 123456789101112131415161718192021public boolean add(E e) &#123; final ReentrantLock lock = this.lock; // 获取“锁” lock.lock(); try &#123; // 获取原始”volatile数组“中的数据和数据长度。 Object[] elements = getArray(); int len = elements.length; // 新建一个数组newElements，并将原始数据拷贝到newElements中； // newElements数组的长度=“原始数组的长度”+1 Object[] newElements = Arrays.copyOf(elements, len + 1); // 将“新增加的元素”保存到newElements中。 newElements[len] = e; // 将newElements赋值给”volatile数组“。 setArray(newElements); return true; &#125; finally &#123; // 释放“锁” lock.unlock(); &#125;&#125; 说明：add(E e) 的作用就是将数据 e 添加到”volatile 数组 “中。它的实现方式是，新建一个数组，接着将原始的”volatile 数组 “的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile 数组 “。在 add(E e) 中有两点需要关注。 第一，在” 添加操作 “开始前，获取独占锁 (lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁 (lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock 的定义如下： transient final ReentrantLock lock = new ReentrantLock(); 关于 ReentrantLock 的更多内容，可以参考：Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock 第二，操作完毕时，会通过 setArray()来更新”volatile 数组 “。而且，前面我们提过” 即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入“；这样，每次添加元素之后，其它线程都能看到新添加的元素。 3. 获取 以 get(int index)为例，来对 “CopyOnWriteArrayList 的删除操作” 进行说明。下面是 get(int index)的代码： 1234567public E get(int index) &#123; return get(getArray(), index);&#125;private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 说明：get(int index) 的实现很简单，就是返回”volatile 数组 “中的第 index 个元素。 4. 删除 以 remove(int index)为例，来对 “CopyOnWriteArrayList 的删除操作” 进行说明。下面是 remove(int index)的代码： 12345678910111213141516171819202122232425262728public E remove(int index) &#123; final ReentrantLock lock = this.lock; // 获取“锁” lock.lock(); try &#123; // 获取原始”volatile数组“中的数据和数据长度。 Object[] elements = getArray(); int len = elements.length; // 获取elements数组中的第index个数据。 E oldValue = get(elements, index); int numMoved = len - index - 1; // 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。 // 否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组“。 if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; // 释放“锁” lock.unlock(); &#125;&#125; 说明：remove(int index)的作用就是将”volatile 数组 “中第 index 个元素删除。它的实现方式是，如果被删除的是最后一个元素，则直接通过 Arrays.copyOf() 进行处理，而不需要新建数组。否则，新建数组，然后将”volatile 数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile 数组“。 和 add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是 “；并且” 在操作完成时，会通过将数据更新到 volatile 数组中“。 5. 遍历 以 iterator()为例，来对 “CopyOnWriteArrayList 的遍历操作” 进行说明。下面是 iterator()的代码： 123public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125; 说明：iterator() 会返回 COWIterator 对象。 COWIterator 实现额 ListIterator 接口，它的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot; private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; // 获取下一个元素 @SuppressWarnings("unchecked") public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; // 获取上一个元素 @SuppressWarnings("unchecked") public E previous() &#123; if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor-1; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; public void add(E e) &#123; throw new UnsupportedOperationException(); &#125;&#125; 说明：COWIterator 不支持修改元素的操作。例如，对于 remove(),set(),add() 等操作，COWIterator 都会抛出异常！另外，需要提到的一点是，CopyOnWriteArrayList 返回迭代器不会抛出 ConcurrentModificationException 异常，即它不是 fail-fast 机制的！关于 fail-fast 机制，可以参考 “Java 集合系列 04 之 fail-fast 总结 (通过 ArrayList 来说明 fail-fast 的原理、解决办法)”。 CopyOnWriteArrayList 示例下面，我们通过一个例子去对比 ArrayList 和 CopyOnWriteArrayList。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * CopyOnWriteArrayList是“线程安全”的动态数组，而ArrayList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历list”的示例 * (01) 当list是CopyOnWriteArrayList对象时，程序能正常运行。 * (02) 当list是ArrayList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class CopyOnWriteArrayListTest1 &#123; // TODO: list是ArrayList对象时，程序会出错。 //private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对list进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value = null; Iterator iter = list.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+"-"+i; list.add(val); // 通过“Iterator”遍历List。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112ta-1, tb-1, ta-1, tb-1, ta-1, ta-1, tb-1, tb-1, tb-2, tb-2, ta-1, ta-2, tb-1, ta-1, tb-2, tb-1, ta-2, tb-2, tb-3, ta-2, ta-1, tb-3, tb-1, ta-3, tb-2, ta-1, ta-2, tb-1, tb-3, tb-2, ta-3, ta-2, tb-4, tb-3, ta-1, ta-3, tb-1, tb-4, tb-2, ta-4, ta-2, ta-1, tb-3, tb-1, ta-3, tb-2, tb-4, ta-2, ta-4, tb-3, tb-5, ta-3, ta-1, tb-4, tb-1, ta-4, tb-2, tb-5, ta-2, ta-5, tb-3, ta-1, ta-3, tb-1, tb-4, tb-2, ta-4, ta-2, tb-5, tb-3, ta-5, ta-3, tb-6, tb-4, ta-4, tb-5, ta-5, tb-6, ta-6, 结果说明：如果将源码中的 list 改成 ArrayList 对象时，程序会产生 ConcurrentModificationException 异常。 03 CopyOnWriteArraySet概要本章是 JUC 系列中的 CopyOnWriteArraySet 篇。接下来，会先对 CopyOnWriteArraySet 进行基本介绍，然后再说明它的原理，接着通过代码去分析，最后通过示例更进一步的了解 CopyOnWriteArraySet。内容包括：CopyOnWriteArraySet 介绍 CopyOnWriteArraySet 原理和数据结构CopyOnWriteArraySet 函数列表CopyOnWriteArraySet 源码 (JDK1.7.0_40 版本)CopyOnWriteArraySet 示例 CopyOnWriteArraySet 介绍它是线程安全的无序的集合，可以将它理解成线程安全的 HashSet。有意思的是，CopyOnWriteArraySet 和 HashSet 虽然都继承于共同的父类 AbstractSet；但是，HashSet 是通过 “散列表 (HashMap)” 实现的，而 CopyOnWriteArraySet 则是通过 “动态数组 (CopyOnWriteArrayList)” 实现的，并不是散列表。和 CopyOnWriteArrayList 类似，CopyOnWriteArraySet 具有以下特性：1. 它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。2. 它是线程安全的。3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。4. 迭代器支持 hasNext(), next() 等不可变操作，但不支持可变 remove() 等 操作。5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 建议：在学习 CopyOnWriteArraySet 之前，先通过 “Java 集合系列 16 之 HashSet 详细介绍 (源码解析) 和使用示例 “ 对 HashSet 进行了解。 CopyOnWriteArraySet 原理和数据结构CopyOnWriteArraySet 的数据结构，如下图所示： 说明： 1. CopyOnWriteArraySet 继承于 AbstractSet，这就意味着它是一个集合。 2. CopyOnWriteArraySet 包含 CopyOnWriteArrayList 对象，它是通过 CopyOnWriteArrayList 实现的。而 CopyOnWriteArrayList 本质是个动态数组队列，所以 CopyOnWriteArraySet 相当于通过通过动态数组实现的 “集合”！ CopyOnWriteArrayList 中允许有重复的元素；但是，CopyOnWriteArraySet 是一个集合，所以它不能有重复集合。因此，CopyOnWriteArrayList 额外提供了 addIfAbsent() 和 addAllAbsent()这两个添加元素的 API，通过这些 API 来添加元素时，只有当元素不存在时才执行添加操作！ 至于 CopyOnWriteArraySet 的 “线程安全” 机制，和 CopyOnWriteArrayList 一样，是通过 volatile 和互斥锁来实现的。这个在前一章节介绍 CopyOnWriteArrayList 时数据结构时，已经进行了说明，这里就不再重复叙述了。 CopyOnWriteArraySet 函数列表123456789101112131415161718192021222324252627282930313233// 创建一个空 set。CopyOnWriteArraySet()// 创建一个包含指定 collection 所有元素的 set。CopyOnWriteArraySet(Collection&lt;? extends E&gt; c)// 如果指定元素并不存在于此 set 中，则添加它。boolean add(E e)// 如果此 set 中没有指定 collection 中的所有元素，则将它们都添加到此 set 中。boolean addAll(Collection&lt;? extends E&gt; c)// 移除此 set 中的所有元素。void clear()// 如果此 set 包含指定元素，则返回 true。boolean contains(Object o)// 如果此 set 包含指定 collection 的所有元素，则返回 true。boolean containsAll(Collection&lt;?&gt; c)// 比较指定对象与此 set 的相等性。boolean equals(Object o)// 如果此 set 不包含任何元素，则返回 true。boolean isEmpty()// 返回按照元素添加顺序在此 set 中包含的元素上进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 如果指定元素存在于此 set 中，则将其移除。boolean remove(Object o)// 移除此 set 中包含在指定 collection 中的所有元素。boolean removeAll(Collection&lt;?&gt; c)// 仅保留此 set 中那些包含在指定 collection 中的元素。boolean retainAll(Collection&lt;?&gt; c)// 返回此 set 中的元素数目。int size()// 返回一个包含此 set 所有元素的数组。Object[] toArray()// 返回一个包含此 set 所有元素的数组；返回数组的运行时类型是指定数组的类型。&lt;T&gt; T[] toArray(T[] a) CopyOnWriteArraySet 源码 (JDK1.7.0_40 版本)CopyOnWriteArraySet.java 的完整源码如下： CopyOnWriteArraySet.java 的完整源码 CopyOnWriteArraySet 是通过 CopyOnWriteArrayList 实现的，它的 API 基本上都是通过调用 CopyOnWriteArrayList 的 API 来实现的。相信对 CopyOnWriteArrayList 了解的话，对 CopyOnWriteArraySet 的了解是水到渠成的事；所以，这里就不再对 CopyOnWriteArraySet 的代码进行详细的解析了。若对 CopyOnWriteArrayList 不了解，请参考 “Java 多线程系列 –“JUC 集合”02 之 CopyOnWriteArrayList”。 CopyOnWriteArraySet 示例下面，我们通过一个例子去对比 HashSet 和 CopyOnWriteArraySet。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * CopyOnWriteArraySet是“线程安全”的集合，而HashSet是非线程安全的。 * * 下面是“多个线程同时操作并且遍历集合set”的示例 * (01) 当set是CopyOnWriteArraySet对象时，程序能正常运行。 * (02) 当set是HashSet对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class CopyOnWriteArraySetTest1 &#123; // TODO: set是HashSet对象时，程序会出错。 //private static Set&lt;String&gt; set = new HashSet&lt;String&gt;(); private static Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对set进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value = null; Iterator iter = set.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 10) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName() + "-" + (i%6); set.add(val); // 通过“Iterator”遍历set。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 1234567891011121314151617181920ta-1, tb-1, ta-1, tb-1, ta-1, tb-1, ta-1, ta-2, tb-1, ta-1, ta-2, tb-1, tb-2, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-1, ta-3, tb-1, tb-3, ta-2, ta-4, tb-2, ta-1, ta-3, tb-1, tb-3, ta-2, ta-4, tb-2, tb-4, ta-3, ta-1, tb-3, tb-1, ta-4, ta-2, tb-4, tb-2, ta-5, ta-3, ta-1, tb-3, tb-1, ta-4, ta-2, tb-4, tb-2, ta-5, ta-3, tb-5, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, tb-0, ta-4, ta-1, tb-4, tb-1, ta-5, ta-2, tb-5, tb-2, ta-0, ta-3, tb-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-5, ta-0, tb-0, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-4, ta-3, tb-4, tb-3, ta-5, ta-4, tb-5, tb-4, ta-0, ta-5, tb-0, tb-5, ta-1, ta-0, tb-1, tb-0, ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-4, ta-3, tb-4, tb-3, ta-5, tb-5, ta-0, tb-0, ta-4, ta-1, tb-4, tb-1, ta-5, ta-2, tb-5, tb-2, ta-0, ta-3, tb-0, tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, tb-0, ta-4, tb-4, ta-5, tb-5, ta-0, tb-0, 结果说明：由于 set 是集合对象，因此它不会包含重复的元素。如果将源码中的 set 改成 HashSet 对象时，程序会产生 ConcurrentModificationException 异常。 04 ConcurrentHashMap概要本章是 JUC 系列的 ConcurrentHashMap 篇。内容包括：ConcurrentHashMap 介绍 ConcurrentHashMap 原理和数据结构ConcurrentHashMap 函数列表ConcurrentHashMap 源码分析 (JDK1.7.0_40 版本)ConcurrentHashMap 示例 ConcurrentHashMap 介绍ConcurrentHashMap 是线程安全的哈希表。HashMap, Hashtable, ConcurrentHashMap 之间的关联如下： HashMap 是非线程安全的哈希表，常用于单线程程序中。 Hashtable 是线程安全的哈希表，它是通过 synchronized 来保证线程安全的；即，多线程通过同一个 “对象的同步锁” 来实现并发控制。Hashtable 在线程竞争激烈时，效率比较低(此时建议使用 ConcurrentHashMap)！因为当一个线程访问 Hashtable 的同步方法时，其它线程就访问 Hashtable 的同步方法时，可能会进入阻塞状态。 ConcurrentHashMap 是线程安全的哈希表，它是通过 “锁分段” 来保证线程安全的。ConcurrentHashMap 将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。 关于 HashMap,Hashtable 以及 ReentrantLock 的更多内容，可以参考： Java 集合系列 10 之 HashMap 详细介绍 (源码解析) 和使用示例 Java 集合系列 11 之 Hashtable 详细介绍 (源码解析) 和使用示例 Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock ConcurrentHashMap 原理和数据结构要想搞清 ConcurrentHashMap，必须先弄清楚它的数据结构： (01) ConcurrentHashMap 继承于 AbstractMap 抽象类。 (02) Segment 是 ConcurrentHashMap 中的内部类，它就是 ConcurrentHashMap 中的 “锁分段” 对应的存储结构。ConcurrentHashMap 与 Segment 是组合关系，1 个 ConcurrentHashMap 对象包含若干个 Segment 对象。在代码中，这表现为 ConcurrentHashMap 类中存在 “Segment 数组” 成员。 (03) Segment 类继承于 ReentrantLock 类，所以 Segment 本质上是一个可重入的互斥锁。 (04) HashEntry 也是 ConcurrentHashMap 的内部类，是单向链表节点，存储着 key-value 键值对。Segment 与 HashEntry 是组合关系，Segment 类中存在 “HashEntry 数组” 成员，“HashEntry 数组”中的每个 HashEntry 就是一个单向链表。 对于多线程访问对一个 “哈希表对象” 竞争资源，Hashtable 是通过一把锁来控制并发；而 ConcurrentHashMap 则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发。ConcurrentHashMap 对并发的控制更加细腻，它也更加适应于高并发场景！ ConcurrentHashMap 函数列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。ConcurrentHashMap()// 创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。ConcurrentHashMap(int initialCapacity)// 创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (16) 的新的空映射。ConcurrentHashMap(int initialCapacity, float loadFactor)// 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)// 构造一个与给定映射具有相同映射关系的新映射。ConcurrentHashMap(Map&lt;? extends K,? extends V&gt; m)// 从该映射中移除所有映射关系void clear()// 一种遗留方法，测试此表中是否有一些与指定值存在映射关系的键。boolean contains(Object value)// 测试指定对象是否为此表中的键。boolean containsKey(Object key)// 如果此映射将一个或多个键映射到指定值，则返回 true。boolean containsValue(Object value)// 返回此表中值的枚举。Enumeration&lt;V&gt; elements()// 返回此映射所包含的映射关系的 Set 视图。Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()// 返回指定键所映射到的值，如果此映射不包含该键的映射关系，则返回 null。V get(Object key)// 如果此映射不包含键-值映射关系，则返回 true。boolean isEmpty()// 返回此表中键的枚举。Enumeration&lt;K&gt; keys()// 返回此映射中包含的键的 Set 视图。Set&lt;K&gt; keySet()// 将指定键映射到此表中的指定值。V put(K key, V value)// 将指定映射中所有映射关系复制到此映射中。void putAll(Map&lt;? extends K,? extends V&gt; m)// 如果指定键已经不再与某个值相关联，则将它与给定值关联。V putIfAbsent(K key, V value)// 从此映射中移除键（及其相应的值）。V remove(Object key)// 只有目前将键的条目映射到给定值时，才移除该键的条目。boolean remove(Object key, Object value)// 只有目前将键的条目映射到某一值时，才替换该键的条目。V replace(K key, V value)// 只有目前将键的条目映射到给定值时，才替换该键的条目。boolean replace(K key, V oldValue, V newValue)// 返回此映射中的键-值映射关系数。int size()// 返回此映射中包含的值的 Collection 视图。Collection&lt;V&gt; values() ConcurrentHashMap 源码分析 (JDK1.7.0_40 版本)ConcurrentHashMap.java 的完整源码如下： ConcurrentHashMap.java 的完整源码 下面从 ConcurrentHashMap 的创建，获取，添加，删除这 4 个方面对 ConcurrentHashMap 进行分析。 1 创建 下面以 ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) 来进行说明。 123456789101112131415161718192021222324252627282930313233343536373839@SuppressWarnings("unchecked")public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; // 参数有效性判断 if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); // concurrencyLevel是“用来计算segments的容量” if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; int sshift = 0; int ssize = 1; // ssize=“大于或等于concurrencyLevel的最小的2的N次方值” while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; // 初始化segmentShift和segmentMask this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; // 哈希表的初始容量 // 哈希表的实际容量=“segments的容量” x “segments中数组的长度” if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // “哈希表的初始容量” / “segments的容量” int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; // cap就是“segments中的HashEntry数组的长度” int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // segments Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss;&#125; 说明：(01) 前面我们说过，ConcurrentHashMap 采用了 “锁分段” 技术；在代码中，它通过 “segments 数组” 对象来保存各个分段。segments 的定义如下： 1final Segment&lt;K,V&gt;[] segments; concurrencyLevel 的作用就是用来计算 segments 数组的容量大小。先计算出 “大于或等于 concurrencyLevel 的最小的 2 的 N 次方值”，然后将其保存为 “segments 的容量大小 (ssize)”。(02) initialCapacity 是哈希表的初始容量。需要注意的是，哈希表的实际容量 =“segments 的容量” x “segments 中数组的长度”。(03) loadFactor 是加载因子。它是哈希表在其容量自动增加之前可以达到多满的一种尺度。 ConcurrentHashMap 的构造函数中涉及到的非常重要的一个结构体，它就是 Segment。下面看看 Segment 的声明： 1234567891011121314151617static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; ... transient volatile HashEntry&lt;K,V&gt;[] table; // threshold阈，是哈希表在其容量自动增加之前可以达到多满的一种尺度。 transient int threshold; // loadFactor是加载因子 final float loadFactor; Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123; this.loadFactor = lf; this.threshold = threshold; this.table = tab; &#125; ...&#125; 说明：Segment 包含 HashEntry 数组，HashEntry 保存了哈希表中的键值对。此外，还需要说明的 Segment 继承于 ReentrantLock。这意味着，Segment 本质上就是可重入的互斥锁。 HashEntry 的源码如下： 123456789101112131415static final class HashEntry&lt;K,V&gt; &#123; final int hash; // 哈希值 final K key; // 键 volatile V value; // 值 volatile HashEntry&lt;K,V&gt; next; // 下一个HashEntry节点 HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ...&#125; 说明：和 HashMap 的节点一样，HashEntry 也是链表。这就说明，ConcurrentHashMap 是链式哈希表，它是通过 “拉链法” 来解决哈希冲突的。 2 获取 下面以 get(Object key) 为例，对 ConcurrentHashMap 的获取方法进行说明。 1234567891011121314151617181920public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // 获取key对应的Segment片段。 // 如果Segment片段不为null，则在“Segment片段的HashEntry数组中”中找到key所对应的HashEntry列表； // 接着遍历该HashEntry链表，找到于key-value键值对对应的HashEntry节点。 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; 说明：get(Object key) 的作用是返回 key 在 ConcurrentHashMap 哈希表中对应的值。它首先根据 key 计算出来的哈希值，获取 key 所对应的 Segment 片段。如果 Segment 片段不为 null，则在 “Segment 片段的 HashEntry 数组中” 中找到 key 所对应的 HashEntry 列表。Segment 包含 “HashEntry 数组” 对象，而每一个 HashEntry 本质上是一个单向链表。接着遍历该 HashEntry 链表，找到于 key-value 键值对对应的 HashEntry 节点。 下面是 hash() 的源码 123456789101112131415161718private int hash(Object k) &#123; int h = hashSeed; if ((0 != h) &amp;&amp; (k instanceof String)) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; 3 增加 下面以 put(K key, V value) 来对 ConcurrentHashMap 中增加键值对来进行说明。 12345678910111213public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); // 获取key对应的哈希值 int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; // 如果找不到该Segment，则新建一个。 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false);&#125; 说明：(01) put() 根据 key 获取对应的哈希值，再根据哈希值找到对应的 Segment 片段。如果 Segment 片段不存在，则新增一个 Segment。(02) 将 key-value 键值对添加到 Segment 片段中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // tryLock()获取锁，成功返回true，失败返回false。 // 获取锁失败的话，则通过scanAndLockForPut()获取锁，并返回”要插入的key-value“对应的”HashEntry链表“。 HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; // tab代表”当前Segment中的HashEntry数组“ HashEntry&lt;K,V&gt;[] tab = table; // 根据”hash值“获取”HashEntry数组中对应的HashEntry链表“ int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; // 如果”HashEntry链表中的当前HashEntry节点“不为null， if (e != null) &#123; K k; // 当”要插入的key-value键值对“已经存在于”HashEntry链表中“时，先保存原有的值。 // 若”onlyIfAbsent“为true，即”要插入的key不存在时才插入”，则直接退出； // 否则，用新的value值覆盖原有的原有的值。 if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; // 如果node非空，则将first设置为“node的下一个节点”。 // 否则，新建HashEntry链表 if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; // 如果添加key-value键值对之后，Segment中的元素超过阈值(并且，HashEntry数组的长度没超过限制)，则rehash； // 否则，直接添加key-value键值对。 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; // 释放锁 unlock(); &#125; return oldValue;&#125; 说明：put() 的作用是将 key-value 键值对插入到 “当前 Segment 对应的 HashEntry 中”，在插入前它会获取 Segment 对应的互斥锁，插入后会释放锁。具体的插入过程如下：(01) 首先根据 “hash 值” 获取 “当前 Segment 的 HashEntry 数组对象” 中的“HashEntry 节点”，每个 HashEntry 节点都是一个单向链表。(02) 接着，遍历 HashEntry 链表。 若在遍历 HashEntry 链表时，找到与 “要 key-value 键值对” 对应的节点，即 “要插入的 key-value 键值对” 的 key 已经存在于 HashEntry 链表中。则根据 onlyIfAbsent 进行判断，若 onlyIfAbsent 为 true，即“当要插入的 key 不存在时才插入”，则不进行插入，直接返回；否则，用新的 value 值覆盖原始的 value 值，然后再返回。 若在遍历 HashEntry 链表时，没有找到与 “要 key-value 键值对” 对应的节点。当 node!=null 时，即在 scanAndLockForPut()获取锁时，已经新建了 key-value 对应的 HashEntry 节点，则”将 HashEntry 添加到 Segment 中 “；否则，新建 key-value 对应的 HashEntry 节点，然后再“将 HashEntry 添加到 Segment 中”。 在” 将 HashEntry 添加到 Segment 中 “前，会判断是否需要 rehash。如果在添加 key-value 键值之后，容量会超过阈值，并且 HashEntry 数组的长度没有超过限制，则进行 rehash；否则，直接通过 setEntryAt() 将 key-value 键值对添加到 Segment 中。 在介绍 rehash() 和 setEntryAt() 之前，我们先看看自旋函数 scanAndLockForPut()。下面是它的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123; // 第一个HashEntry节点 HashEntry&lt;K,V&gt; first = entryForHash(this, hash); // 当前的HashEntry节点 HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null; // 重复计数(自旋计数器) int retries = -1; // negative while locating node // 查找”key-value键值对“在”HashEntry链表上对应的节点“； // 若找到的话，则不断的自旋；在自旋期间，若通过tryLock()获取锁成功则返回；否则自旋MAX_SCAN_RETRIES次数之后，强制获取”锁“并退出。 // 若没有找到的话，则新建一个HashEntry链表。然后不断的自旋。 // 此外，若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋工作！ while (!tryLock()) &#123; HashEntry&lt;K,V&gt; f; // to recheck first below // 1\. retries&lt;0的处理情况 if (retries &lt; 0) &#123; // 1.1 如果当前的HashEntry节点为空(意味着，在该HashEntry链表上上没有找到”要插入的键值对“对应的节点)，而且node=null；则新建HashEntry链表。 if (e == null) &#123; if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; &#125; // 1.2 如果当前的HashEntry节点是”要插入的键值对在该HashEntry上对应的节点“，则设置retries=0 else if (key.equals(e.key)) retries = 0; // 1.3 设置为下一个HashEntry。 else e = e.next; &#125; // 2\. 如果自旋次数超过限制，则获取“锁”并退出 else if (++retries &gt; MAX_SCAN_RETRIES) &#123; lock(); break; &#125; // 3\. 当“尝试了偶数次”时，就获取“当前Segment的第一个HashEntry”，即f。 // 然后，通过f!=first来判断“当前Segment的第一个HashEntry是否发生了改变”。 // 若是的话，则重置e，first和retries的值，并重新遍历。 else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123; e = first = f; // re-traverse if entry changed retries = -1; &#125; &#125; return node;&#125; 说明：scanAndLockForPut() 的目标是获取锁。流程如下： 它首先会调用 entryForHash()，根据 hash 值获取” 当前 Segment 中对应的 HashEntry 节点 (first)，即找到对应的 HashEntry 链表 “。 紧接着进入 while 循环。在 while 循环中，它会遍历”HashEntry 链表 (e)“，查找” 要插入的 key-value 键值对 “在” 该 HashEntry 链表上对应的节点“。 若找到的话，则不断的自旋，即不断的执行 while 循环。在自旋期间，若通过 tryLock() 获取锁成功则返回；否则，在自旋 MAX_SCAN_RETRIES 次数之后，强制获取锁并退出。 若没有找到的话，则新建一个 HashEntry 链表，然后不断的自旋。在自旋期间，若通过 tryLock() 获取锁成功则返回；否则，在自旋 MAX_SCAN_RETRIES 次数之后，强制获取锁并退出。 此外，若在自旋期间，HashEntry 链表的表头发生变化；则重新进行查找和自旋工作！ 理解 scanAndLockForPut()时，务必要联系”哈希表 “的数据结构。一个 Segment 本身就是一个哈希表，Segment 中包含了”HashEntry 数组“对象，而每一个 HashEntry 对象本身是一个” 单向链表“。 下面看看 rehash() 的实现代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void rehash(HashEntry&lt;K,V&gt; node) &#123; HashEntry&lt;K,V&gt;[] oldTable = table; // ”Segment中原始的HashEntry数组的长度“ int oldCapacity = oldTable.length; // ”Segment中新HashEntry数组的长度“ int newCapacity = oldCapacity &lt;&lt; 1; // 新的阈值 threshold = (int)(newCapacity * loadFactor); // 新的HashEntry数组 HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity]; int sizeMask = newCapacity - 1; // 遍历”原始的HashEntry数组“， // 将”原始的HashEntry数组“中的每个”HashEntry链表“的值，都复制到”新的HashEntry数组的HashEntry元素“中。 for (int i = 0; i &lt; oldCapacity ; i++) &#123; // 获取”原始的HashEntry数组“中的”第i个HashEntry链表“ HashEntry&lt;K,V&gt; e = oldTable[i]; if (e != null) &#123; HashEntry&lt;K,V&gt; next = e.next; int idx = e.hash &amp; sizeMask; if (next == null) // Single node on list newTable[idx] = e; else &#123; // Reuse consecutive sequence at same slot HashEntry&lt;K,V&gt; lastRun = e; int lastIdx = idx; for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123; int k = last.hash &amp; sizeMask; if (k != lastIdx) &#123; lastIdx = k; lastRun = last; &#125; &#125; newTable[lastIdx] = lastRun; // 将”原始的HashEntry数组“中的”HashEntry链表(e)“的值，都复制到”新的HashEntry数组的HashEntry“中。 for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123; V v = p.value; int h = p.hash; int k = h &amp; sizeMask; HashEntry&lt;K,V&gt; n = newTable[k]; newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n); &#125; &#125; &#125; &#125; // 将新的node节点添加到“Segment的新HashEntry数组(newTable)“中。 int nodeIndex = node.hash &amp; sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; table = newTable;&#125; 说明：rehash()的作用是将”Segment 的容量 “变为” 原始的 Segment 容量的 2 倍“。在将原始的数据拷贝到 “新的 Segment” 中后，会将新增加的 key-value 键值对添加到 “新的 Segment” 中。 setEntryAt() 的源码如下： 1234static final &lt;K,V&gt; void setEntryAt(HashEntry&lt;K,V&gt;[] tab, int i, HashEntry&lt;K,V&gt; e) &#123; UNSAFE.putOrderedObject(tab, ((long)i &lt;&lt; TSHIFT) + TBASE, e);&#125; UNSAFE 是 Segment 类中定义的 “静态 sun.misc.Unsafe” 对象。源码如下： 1static final sun.misc.Unsafe UNSAFE; Unsafe.java 在 openjdk6 中的路径是：openjdk6/jdk/src/share/classes/sun/misc/Unsafe.java。其中，putOrderedObject() 的源码下： 1public native void putOrderedObject(Object o, long offset, Object x); 说明：putOrderedObject() 是一个本地方法。它会设置 obj 对象中 offset 偏移地址对应的 object 型 field 的值为指定值。它是一个有序或者有延迟的 putObjectVolatile() 方法，并且不保证值的改变被其他线程立即看到。只有在 field 被 volatile 修饰并且期望被意外修改的时候，使用 putOrderedObject() 才有用。 总之，setEntryAt() 的目的是设置 tab 中第 i 位置元素的值为 e，且该设置会有延迟。 4 删除 下面以 remove(Object key) 来对 ConcurrentHashMap 中的删除操作来进行说明。 123456public V remove(Object key) &#123; int hash = hash(key); // 根据hash值，找到key对应的Segment片段。 Segment&lt;K,V&gt; s = segmentForHash(hash); return s == null ? null : s.remove(key, hash, null);&#125; 说明：remove()首先根据 “key 的计算出来的哈希值” 找到对应的 Segment 片段，然后再从该 Segment 片段中删除对应的“key-value 键值对”。 remove() 的方法如下： 123456789101112131415161718192021222324252627282930313233343536373839final V remove(Object key, int hash, Object value) &#123; // 尝试获取Segment对应的锁。 // 尝试失败的话，则通过scanAndLock()来获取锁。 if (!tryLock()) scanAndLock(key, hash); V oldValue = null; try &#123; // 根据“hash值”找到“Segment的HashEntry数组”中对应的“HashEntry节点(e)”，该HashEntry节点是一HashEntry个链表。 HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; e = entryAt(tab, index); HashEntry&lt;K,V&gt; pred = null; // 遍历“HashEntry链表”，删除key-value键值对 while (e != null) &#123; K k; HashEntry&lt;K,V&gt; next = e.next; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; V v = e.value; if (value == null || value == v || value.equals(v)) &#123; if (pred == null) setEntryAt(tab, index, next); else pred.setNext(next); ++modCount; --count; oldValue = v; &#125; break; &#125; pred = e; e = next; &#125; &#125; finally &#123; // 释放锁 unlock(); &#125; return oldValue;&#125; 说明：remove() 的目的就是删除 key-value 键值对。在删除之前，它会获取到 Segment 的互斥锁，在删除之后，再释放锁。它的删除过程也比较简单，它会先根据 hash 值，找到 “Segment 的 HashEntry 数组” 中对应的 “HashEntry” 节点。根据 Segment 的数据结构，我们知道 Segment 中包含一个 HashEntry 数组对象，而每一个 HashEntry 本质上是一个单向链表。 在找到 “HashEntry” 节点之后，就遍历该 “HashEntry” 节点对应的链表，找到 key-value 键值对对应的节点，然后删除。 下面对 scanAndLock() 进行说明。它的源码如下： 1234567891011121314151617181920212223242526272829303132333435private void scanAndLock(Object key, int hash) &#123; // 第一个HashEntry节点 HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; int retries = -1; // 查找”key-value键值对“在”HashEntry链表上对应的节点“； // 无论找没找到，最后都会不断的自旋；在自旋期间，若通过tryLock()获取锁成功则返回；否则自旋MAX_SCAN_RETRIES次数之后，强制获取”锁“并退出。 // 若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋！ while (!tryLock()) &#123; HashEntry&lt;K,V&gt; f; if (retries &lt; 0) &#123; // 如果“遍历完该HashEntry链表，仍然没找到”要删除的键值对“对应的节点” // 或者“在该HashEntry链表上找到”要删除的键值对“对应的节点”，则设置retries=0 // 否则，设置e为下一个HashEntry节点。 if (e == null || key.equals(e.key)) retries = 0; else e = e.next; &#125; // 自旋超过限制次数之后，获取锁并退出。 else if (++retries &gt; MAX_SCAN_RETRIES) &#123; lock(); break; &#125; // 当“尝试了偶数次”时，就获取“当前Segment的第一个HashEntry”，即f。 // 然后，通过f!=first来判断“当前Segment的第一个HashEntry是否发生了改变”。 // 若是的话，则重置e，first和retries的值，并重新遍历。 else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123; e = first = f; retries = -1; &#125; &#125;&#125; 说明：scanAndLock() 的目标是获取锁。它的实现与 scanAndLockForPut() 类似，这里就不再过多说明。 总结：ConcurrentHashMap 是线程安全的哈希表，它是通过 “锁分段” 来实现的。ConcurrentHashMap 中包括了 “Segment(锁分段) 数组”，每个 Segment 就是一个哈希表，而且也是可重入的互斥锁。第一，Segment 是哈希表表现在，Segment 包含了 “HashEntry 数组”，而“HashEntry 数组” 中的每一个 HashEntry 元素是一个单向链表。即 Segment 是通过链式哈希表。第二，Segment 是可重入的互斥锁表现在，Segment 继承于 ReentrantLock，而 ReentrantLock 就是可重入的互斥锁。对于 ConcurrentHashMap 的添加，删除操作，在操作开始前，线程都会获取 Segment 的互斥锁；操作完毕之后，才会释放。而对于读取操作，它是通过 volatile 去实现的，HashEntry 数组是 volatile 类型的，而 volatile 能保证 “即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”，即我们总能读到其它线程写入 HashEntry 之后的值。 以上这些方式，就是 ConcurrentHashMap 线程安全的实现原理。 ConcurrentHashMap 示例下面，我们通过一个例子去对比 HashMap 和 ConcurrentHashMap。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;import java.util.concurrent.*;/* * ConcurrentHashMap是“线程安全”的哈希表，而HashMap是非线程安全的。 * * 下面是“多个线程同时操作并且遍历map”的示例 * (01) 当map是ConcurrentHashMap对象时，程序能正常运行。 * (02) 当map是HashMap对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ConcurrentHashMapDemo1 &#123; // TODO: map是HashMap对象时，程序会出错。 //private static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); private static Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;String, String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对map进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String key, value; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); value = (String)entry.getValue(); System.out.print(key+" - "+value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; map.put(String.valueOf(i), val); // 通过“Iterator”遍历map。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 1234567891011121 - tb1, 1 - tb1, 1 - tb1, 1 - tb1, 2 - tb2, 2 - tb2, 1 - tb1, 3 - ta3, 1 - tb1, 2 - tb2, 3 - tb3, 1 - tb1, 2 - tb2, 3 - tb3, 1 - tb1, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 1 - tb1, 2 - tb2, 5 - ta5, 1 - tb1, 3 - tb3, 5 - tb5, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 1 - tb1, 2 - tb2, 5 - tb5, 1 - tb1, 6 - tb6, 5 - tb5, 3 - tb3, 6 - tb6, 4 - tb4, 3 - tb3, 2 - tb2, 4 - tb4, 2 - tb2, 结果说明：如果将源码中的 map 改成 HashMap 对象时，程序会产生 ConcurrentModificationException 异常。 05 ConcurrentSkipListMap概要本章对 Java.util.concurrent 包中的 ConcurrentSkipListMap 类进行详细的介绍。内容包括：ConcurrentSkipListMap 介绍 ConcurrentSkipListMap 原理和数据结构ConcurrentSkipListMap 函数列表ConcurrentSkipListMap 源码分析 (JDK1.7.0_40 版本)ConcurrentSkipListMap 示例 ConcurrentSkipListMap 介绍ConcurrentSkipListMap 是线程安全的有序的哈希表，适用于高并发的场景。ConcurrentSkipListMap 和 TreeMap，它们虽然都是有序的哈希表。但是，第一，它们的线程安全机制不同，TreeMap 是非线程安全的，而 ConcurrentSkipListMap 是线程安全的。第二，ConcurrentSkipListMap 是通过跳表实现的，而 TreeMap 是通过红黑树实现的。关于跳表 (Skip List)，它是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。 ConcurrentSkipListMap 原理和数据结构ConcurrentSkipListMap 的数据结构，如下图所示： 说明： 先以数据 “7,14,21,32,37,71,85” 序列为例，来对跳表进行简单说明。 跳表分为许多层 (level)，每一层都可以看作是数据的索引，这些索引的意义就是加快跳表查找数据速度。每一层的数据都是有序的，上一层数据是下一层数据的子集，并且第一层(level 1) 包含了全部的数据；层次越高，跳跃性越大，包含的数据越少。跳表包含一个表头，它查找数据时，是从上往下，从左往右进行查找。现在 “需要找出值为 32 的节点” 为例，来对比说明跳表和普遍的链表。 情况 1：链表中查找 “32” 节点路径如下图 1-02 所示： 需要 4 步 (红色部分表示路径)。 情况 2：跳表中查找 “32” 节点路径如下图 1-03 所示： 忽略索引垂直线路上路径的情况下，只需要 2 步 (红色部分表示路径)。 下面说说 Java 中 ConcurrentSkipListMap 的数据结构。(01) ConcurrentSkipListMap 继承于 AbstractMap 类，也就意味着它是一个哈希表。(02) Index 是 ConcurrentSkipListMap 的内部类，它与 “跳表中的索引相对应”。HeadIndex 继承于 Index，ConcurrentSkipListMap 中含有一个 HeadIndex 的对象 head，head 是 “跳表的表头”。(03) Index 是跳表中的索引，它包含 “右索引的指针(right)”，“下索引的指针(down)” 和“哈希表节点 node”。node 是 Node 的对象，Node 也是 ConcurrentSkipListMap 中的内部类。 ConcurrentSkipListMap 函数列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 构造一个新的空映射，该映射按照键的自然顺序进行排序。ConcurrentSkipListMap()// 构造一个新的空映射，该映射按照指定的比较器进行排序。ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator)// 构造一个新映射，该映射所包含的映射关系与给定映射包含的映射关系相同，并按照键的自然顺序进行排序。ConcurrentSkipListMap(Map&lt;? extends K,? extends V&gt; m)// 构造一个新映射，该映射所包含的映射关系与指定的有序映射包含的映射关系相同，使用的顺序也相同。ConcurrentSkipListMap(SortedMap&lt;K,? extends V&gt; m)// 返回与大于等于给定键的最小键关联的键-值映射关系；如果不存在这样的条目，则返回 null。Map.Entry&lt;K,V&gt; ceilingEntry(K key)// 返回大于等于给定键的最小键；如果不存在这样的键，则返回 null。K ceilingKey(K key)// 从此映射中移除所有映射关系。void clear()// 返回此 ConcurrentSkipListMap 实例的浅表副本。ConcurrentSkipListMap&lt;K,V&gt; clone()// 返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。Comparator&lt;? super K&gt; comparator()// 如果此映射包含指定键的映射关系，则返回 true。boolean containsKey(Object key)// 如果此映射为指定值映射一个或多个键，则返回 true。boolean containsValue(Object value)// 返回此映射中所包含键的逆序 NavigableSet 视图。NavigableSet&lt;K&gt; descendingKeySet()// 返回此映射中所包含映射关系的逆序视图。ConcurrentNavigableMap&lt;K,V&gt; descendingMap()// 返回此映射中所包含的映射关系的 Set 视图。Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()// 比较指定对象与此映射的相等性。boolean equals(Object o)// 返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。Map.Entry&lt;K,V&gt; firstEntry()// 返回此映射中当前第一个（最低）键。K firstKey()// 返回与小于等于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。Map.Entry&lt;K,V&gt; floorEntry(K key)// 返回小于等于给定键的最大键；如果不存在这样的键，则返回 null。K floorKey(K key)// 返回指定键所映射到的值；如果此映射不包含该键的映射关系，则返回 null。V get(Object key)// 返回此映射的部分视图，其键值严格小于 toKey。ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey)// 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)// 返回与严格大于给定键的最小键关联的键-值映射关系；如果不存在这样的键，则返回 null。Map.Entry&lt;K,V&gt; higherEntry(K key)// 返回严格大于给定键的最小键；如果不存在这样的键，则返回 null。K higherKey(K key)// 如果此映射未包含键-值映射关系，则返回 true。boolean isEmpty()// 返回此映射中所包含键的 NavigableSet 视图。NavigableSet&lt;K&gt; keySet()// 返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。Map.Entry&lt;K,V&gt; lastEntry()// 返回映射中当前最后一个（最高）键。K lastKey()// 返回与严格小于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。Map.Entry&lt;K,V&gt; lowerEntry(K key)// 返回严格小于给定键的最大键；如果不存在这样的键，则返回 null。K lowerKey(K key)// 返回此映射中所包含键的 NavigableSet 视图。NavigableSet&lt;K&gt; navigableKeySet()// 移除并返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。Map.Entry&lt;K,V&gt; pollFirstEntry()// 移除并返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。Map.Entry&lt;K,V&gt; pollLastEntry()// 将指定值与此映射中的指定键关联。V put(K key, V value)// 如果指定键已经不再与某个值相关联，则将它与给定值关联。V putIfAbsent(K key, V value)// 从此映射中移除指定键的映射关系（如果存在）。V remove(Object key)// 只有目前将键的条目映射到给定值时，才移除该键的条目。boolean remove(Object key, Object value)// 只有目前将键的条目映射到某一值时，才替换该键的条目。V replace(K key, V value)// 只有目前将键的条目映射到给定值时，才替换该键的条目。boolean replace(K key, V oldValue, V newValue)// 返回此映射中的键-值映射关系数。int size()// 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)// 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey)// 返回此映射的部分视图，其键大于等于 fromKey。ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey)// 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)// 返回此映射中所包含值的 Collection 视图。Collection&lt;V&gt; values() ConcurrentSkipListMap 源码分析 (JDK1.7.0_40 版本)ConcurrentSkipListMap.java 的完整源码如下： ConcurrentSkipListMap.java源码 下面从 ConcurrentSkipListMap 的添加，删除，获取这 3 个方面对它进行分析。 1. 添加 下面以 put(K key, V value) 为例，对 ConcurrentSkipListMap 的添加方法进行说明。 12345public V put(K key, V value) &#123; if (value == null) throw new NullPointerException(); return doPut(key, value, false);&#125; 实际上，put() 是通过 doPut() 将 key-value 键值对添加到 ConcurrentSkipListMap 中的。 doPut() 的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private V doPut(K kkey, V value, boolean onlyIfAbsent) &#123; Comparable&lt;? super K&gt; key = comparable(kkey); for (;;) &#123; // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“key的前继节点的后继节点”，即n应该是“插入节点”的“后继节点” Node&lt;K,V&gt; n = b.next; for (;;) &#123; if (n != null) &#123; Node&lt;K,V&gt; f = n.next; // 如果两次获得的b.next不是相同的Node，就跳转到”外层for循环“，重新获得b和n后再遍历。 if (n != b.next) break; // v是“n的值” Object v = n.value; // 当n的值为null(意味着其它线程删除了n)；此时删除b的下一个节点，然后跳转到”外层for循环“，重新获得b和n后再遍历。 if (v == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; // 如果其它线程删除了b；则跳转到”外层for循环“，重新获得b和n后再遍历。 if (v == n || b.value == null) // b is deleted break; // 比较key和n.key int c = key.compareTo(n.key); if (c &gt; 0) &#123; b = n; n = f; continue; &#125; if (c == 0) &#123; if (onlyIfAbsent || n.casValue(v, value)) return (V)v; else break; // restart if lost race to replace value &#125; // else c &lt; 0; fall through &#125; // 新建节点(对应是“要插入的键值对”) Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(kkey, value, n); // 设置“b的后继节点”为z if (!b.casNext(n, z)) break; // 多线程情况下，break才可能发生(其它线程对b进行了操作) // 随机获取一个level // 然后在“第1层”到“第level层”的链表中都插入新建节点 int level = randomLevel(); if (level &gt; 0) insertIndex(z, level); return null; &#125; &#125;&#125; 说明：doPut() 的作用就是将键值对添加到 “跳表” 中。要想搞清 doPut()，首先要弄清楚它的主干部分 —— 我们先单纯的只考虑 “单线程的情况下，将 key-value 添加到跳表中”，即忽略 “多线程相关的内容”。它的流程如下：第 1 步：找到 “插入位置”。即，找到 “key 的前继节点(b)” 和“key 的后继节点(n)”；key 是要插入节点的键。第 2 步：新建并插入节点。即，新建节点 z(key 对应的节点)，并将新节点 z 插入到 “跳表” 中(设置“b 的后继节点为 z”，“z 的后继节点为 n”)。第 3 步：更新跳表。即，随机获取一个 level，然后在 “跳表” 的第 1 层～第 level 层之间，每一层都插入节点 z；在第 level 层之上就不再插入节点了。若 level 数值大于“跳表的层次”，则新建一层。主干部分 “对应的精简后的 doPut() 的代码”如下(仅供参考)： 1234567891011121314151617181920212223private V doPut(K kkey, V value, boolean onlyIfAbsent) &#123; Comparable&lt;? super K&gt; key = comparable(kkey); for (;;) &#123; // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为key的后继节点 Node&lt;K,V&gt; n = b.next; for (;;) &#123; // 新建节点(对应是“要被插入的键值对”) Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(kkey, value, n); // 设置“b的后继节点”为z b.casNext(n, z); // 随机获取一个level // 然后在“第1层”到“第level层”的链表中都插入新建节点 int level = randomLevel(); if (level &gt; 0) insertIndex(z, level); return null; &#125; &#125;&#125; 理清主干之后，剩余的工作就相对简单了。主要是上面几步的对应算法的具体实现，以及多线程相关情况的处理！ 2. 删除 下面以 remove(Object key) 为例，对 ConcurrentSkipListMap 的删除方法进行说明。 123public V remove(Object key) &#123; return doRemove(key, null);&#125; 实际上，remove() 是通过 doRemove() 将 ConcurrentSkipListMap 中的 key 对应的键值对删除的。 doRemove() 的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final V doRemove(Object okey, Object value) &#123; Comparable&lt;? super K&gt; key = comparable(okey); for (;;) &#123; // 找到“key的前继节点” Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) &#123; if (n == null) return null; // f是“当前节点n的后继节点” Node&lt;K,V&gt; f = n.next; // 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (n != b.next) // inconsistent read break; // 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 Object v = n.value; if (v == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; // 如果“前继节点b”被删除(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (v == n || b.value == null) // b is deleted break; int c = key.compareTo(n.key); if (c &lt; 0) return null; if (c &gt; 0) &#123; b = n; n = f; continue; &#125; // 以下是c=0的情况 if (value != null &amp;&amp; !value.equals(v)) return null; // 设置“当前节点n”的值为null if (!n.casValue(v, null)) break; // 设置“b的后继节点”为f if (!n.appendMarker(f) || !b.casNext(n, f)) findNode(key); // Retry via findNode else &#123; // 清除“跳表”中每一层的key节点 findPredecessor(key); // Clean index // 如果“表头的右索引为空”，则将“跳表的层次”-1。 if (head.right == null) tryReduceLevel(); &#125; return (V)v; &#125; &#125;&#125; 说明：doRemove() 的作用是删除跳表中的节点。和 doPut() 一样，我们重点看 doRemove() 的主干部分，了解主干部分之后，其余部分就非常容易理解了。下面是 “单线程的情况下，删除跳表中键值对的步骤”：第 1 步：找到 “被删除节点的位置”。即，找到 “key 的前继节点 (b)”，“key 所对应的节点 (n)”，“n 的后继节点 f”；key 是要删除节点的键。第 2 步：删除节点。即，将 “key 所对应的节点 n” 从跳表中移除 – 将 “b 的后继节点” 设为“f”！第 3 步：更新跳表。即，遍历跳表，删除每一层的 “key 节点”(如果存在的话)。如果删除“key 节点” 之后，跳表的层次需要 - 1；则执行相应的操作！主干部分 “对应的精简后的 doRemove() 的代码”如下(仅供参考)： 12345678910111213141516171819202122232425final V doRemove(Object okey, Object value) &#123; Comparable&lt;? super K&gt; key = comparable(okey); for (;;) &#123; // 找到“key的前继节点” Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) &#123; // f是“当前节点n的后继节点” Node&lt;K,V&gt; f = n.next; // 设置“当前节点n”的值为null n.casValue(v, null); // 设置“b的后继节点”为f b.casNext(n, f); // 清除“跳表”中每一层的key节点 findPredecessor(key); // 如果“表头的右索引为空”，则将“跳表的层次”-1。 if (head.right == null) tryReduceLevel(); return (V)v; &#125; &#125;&#125; 3. 获取 下面以 get(Object key) 为例，对 ConcurrentSkipListMap 的获取方法进行说明。 123public V get(Object key) &#123; return doGet(key);&#125; doGet 的源码如下： 123456789101112private V doGet(Object okey) &#123; Comparable&lt;? super K&gt; key = comparable(okey); for (;;) &#123; // 找到“key对应的节点” Node&lt;K,V&gt; n = findNode(key); if (n == null) return null; Object v = n.value; if (v != null) return (V)v; &#125;&#125; 说明：doGet() 是通过 findNode() 找到并返回节点的。 1234567891011121314151617181920212223242526272829303132333435private Node&lt;K,V&gt; findNode(Comparable&lt;? super K&gt; key) &#123; for (;;) &#123; // 找到key的前继节点 Node&lt;K,V&gt; b = findPredecessor(key); // 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点) Node&lt;K,V&gt; n = b.next; for (;;) &#123; // 如果“n为null”，则跳转中不存在key对应的节点，直接返回null。 if (n == null) return null; Node&lt;K,V&gt; f = n.next; // 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (n != b.next) // inconsistent read break; Object v = n.value; // 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。 if (v == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; if (v == n || b.value == null) // b is deleted break; // 若n是当前节点，则返回n。 int c = key.compareTo(n.key); if (c == 0) return n; // 若“节点n的key”小于“key”，则说明跳表中不存在key对应的节点，返回null if (c &lt; 0) return null; // 若“节点n的key”大于“key”，则更新b和n，继续查找。 b = n; n = f; &#125; &#125;&#125; 说明：findNode(key) 的作用是在返回跳表中 key 对应的节点；存在则返回节点，不存在则返回 null。先弄清函数的主干部分，即抛开 “多线程相关内容”，单纯的考虑单线程情况下，从跳表获取节点的算法。第 1 步：找到 “被删除节点的位置”。根据 findPredecessor() 定位 key 所在的层次以及找到 key 的前继节点 (b)，然后找到 b 的后继节点 n。第 2 步：根据 “key 的前继节点(b)” 和“key 的前继节点的后继节点 (n)” 来定位“key 对应的节点”。具体是通过比较 “n 的键值” 和“key”的大小。如果相等，则 n 就是所要查找的键。 ConcurrentSkipListMap 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;import java.util.concurrent.*;/* * ConcurrentSkipListMap是“线程安全”的哈希表，而TreeMap是非线程安全的。 * * 下面是“多个线程同时操作并且遍历map”的示例 * (01) 当map是ConcurrentSkipListMap对象时，程序能正常运行。 * (02) 当map是TreeMap对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ConcurrentSkipListMapDemo1 &#123; // TODO: map是TreeMap对象时，程序会出错。 //private static Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(); private static Map&lt;String, String&gt; map = new ConcurrentSkipListMap&lt;String, String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对map进行操作！ new MyThread("a").start(); new MyThread("b").start(); &#125; private static void printAll() &#123; String key, value; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); value = (String)entry.getValue(); System.out.print("("+key+", "+value+"), "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "序号" String val = Thread.currentThread().getName()+i; map.put(val, "0"); // 通过“Iterator”遍历map。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112(a1, 0), (a1, 0), (b1, 0), (b1, 0),(a1, 0), (b1, 0), (b2, 0), (a1, 0), (a1, 0), (a2, 0), (a2, 0), (b1, 0), (b1, 0), (b2, 0), (b2, 0), (b3, 0), (b3, 0), (a1, 0), (a2, 0), (a3, 0), (a1, 0), (b1, 0), (a2, 0), (b2, 0), (a3, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (a1, 0), (b3, 0), (a2, 0), (b4, 0), (a3, 0), (a1, 0), (a4, 0), (a2, 0), (b1, 0), (a3, 0), (b2, 0), (a4, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (b5, 0), (b3, 0), (a1, 0), (b4, 0), (a2, 0), (b5, 0), (a3, 0), (a1, 0), (a4, 0), (a2, 0), (a5, 0), (a3, 0), (b1, 0), (a4, 0), (b2, 0), (a5, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (b5, 0), (b3, 0), (b6, 0), (b4, 0), (a1, 0), (b5, 0), (a2, 0), (b6, 0), (a3, 0), (a4, 0), (a5, 0), (a6, 0), (b1, 0), (b2, 0), (b3, 0), (b4, 0), (b5, 0), (b6, 0), 结果说明：示例程序中，启动两个线程 (线程 a 和线程 b) 分别对 ConcurrentSkipListMap 进行操作。以线程 a 而言，它会先获取 “线程名”+“序号”，然后将该字符串作为 key，将“0” 作为 value，插入到 ConcurrentSkipListMap 中；接着，遍历并输出 ConcurrentSkipListMap 中的全部元素。 线程 b 的操作和线程 a 一样，只不过线程 b 的名字和线程 a 的名字不同。当 map 是 ConcurrentSkipListMap 对象时，程序能正常运行。如果将 map 改为 TreeMap 时，程序会产生 ConcurrentModificationException 异常。 06 ConcurrentSkipListSet概要本章对 Java.util.concurrent 包中的 ConcurrentSkipListSet 类进行详细的介绍。内容包括：ConcurrentSkipListSet 介绍ConcurrentSkipListSet 原理和数据结构ConcurrentSkipListSet 函数列表ConcurrentSkipListSet 源码 (JDK1.7.0_40 版本)ConcurrentSkipListSet 示例 ConcurrentSkipListSet 介绍ConcurrentSkipListSet 是线程安全的有序的集合，适用于高并发的场景。ConcurrentSkipListSet 和 TreeSet，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet 是非线程安全的，而 ConcurrentSkipListSet 是线程安全的。第二，ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，而 TreeSet 是通过 TreeMap 实现的。 ConcurrentSkipListSet 原理和数据结构ConcurrentSkipListSet 的数据结构，如下图所示： 说明：(01) ConcurrentSkipListSet 继承于 AbstractSet。因此，它本质上是一个集合。(02) ConcurrentSkipListSet 实现了 NavigableSet 接口。因此，ConcurrentSkipListSet 是一个有序的集合。(03) ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的。它包含一个 ConcurrentNavigableMap 对象 m，而 m 对象实际上是 ConcurrentNavigableMap 的实现类 ConcurrentSkipListMap 的实例。ConcurrentSkipListMap 中的元素是 key-value 键值对；而 ConcurrentSkipListSet 是集合，它只用到了 ConcurrentSkipListMap 中的 key！ ConcurrentSkipListSet 函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 构造一个新的空 set，该 set 按照元素的自然顺序对其进行排序。ConcurrentSkipListSet()// 构造一个包含指定 collection 中元素的新 set，这个新 set 按照元素的自然顺序对其进行排序。ConcurrentSkipListSet(Collection&lt;? extends E&gt; c)// 构造一个新的空 set，该 set 按照指定的比较器对其元素进行排序。ConcurrentSkipListSet(Comparator&lt;? super E&gt; comparator)// 构造一个新 set，该 set 所包含的元素与指定的有序 set 包含的元素相同，使用的顺序也相同。ConcurrentSkipListSet(SortedSet&lt;E&gt; s)// 如果此 set 中不包含指定元素，则添加指定元素。boolean add(E e)// 返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。E ceiling(E e)// 从此 set 中移除所有元素。void clear()// 返回此 ConcurrentSkipListSet 实例的浅表副本。ConcurrentSkipListSet&lt;E&gt; clone()// 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。Comparator&lt;? super E&gt; comparator()// 如果此 set 包含指定的元素，则返回 true。boolean contains(Object o)// 返回在此 set 的元素上以降序进行迭代的迭代器。Iterator&lt;E&gt; descendingIterator()// 返回此 set 中所包含元素的逆序视图。NavigableSet&lt;E&gt; descendingSet()// 比较指定对象与此 set 的相等性。boolean equals(Object o)// 返回此 set 中当前第一个（最低）元素。E first()// 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。E floor(E e)// 返回此 set 的部分视图，其元素严格小于 toElement。NavigableSet&lt;E&gt; headSet(E toElement)// 返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement。NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive)// 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。E higher(E e)// 如果此 set 不包含任何元素，则返回 true。boolean isEmpty()// 返回在此 set 的元素上以升序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 返回此 set 中当前最后一个（最高）元素。E last()// 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。E lower(E e)// 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。E pollFirst()// 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。E pollLast()// 如果此 set 中存在指定的元素，则将其移除。boolean remove(Object o)// 从此 set 中移除包含在指定 collection 中的所有元素。boolean removeAll(Collection&lt;?&gt; c)// 返回此 set 中的元素数目。int size()// 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)// 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。NavigableSet&lt;E&gt; subSet(E fromElement, E toElement)// 返回此 set 的部分视图，其元素大于等于 fromElement。NavigableSet&lt;E&gt; tailSet(E fromElement)// 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) ConcurrentSkipListSet 源码 (JDK1.7.0_40 版本)ConcurrentSkipListSet.java 的完整源码如下： ConcurrentSkipListSet.java 的完整源码 ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，它的接口基本上都是通过调用 ConcurrentSkipListMap 接口来实现的。这里就不再对它的源码进行分析了。 ConcurrentSkipListSet 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * ConcurrentSkipListSet是“线程安全”的集合，而TreeSet是非线程安全的。 * * 下面是“多个线程同时操作并且遍历集合set”的示例 * (01) 当set是ConcurrentSkipListSet对象时，程序能正常运行。 * (02) 当set是TreeSet对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ConcurrentSkipListSetDemo1 &#123; // TODO: set是TreeSet对象时，程序会出错。 //private static Set&lt;String&gt; set = new TreeSet&lt;String&gt;(); private static Set&lt;String&gt; set = new ConcurrentSkipListSet&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对set进行操作！ new MyThread("a").start(); new MyThread("b").start(); &#125; private static void printAll() &#123; String value = null; Iterator iter = set.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 10) &#123; // “线程名” + "序号" String val = Thread.currentThread().getName() + (i%6); set.add(val); // 通过“Iterator”遍历set。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 1234567891011121314151617181920a1, b1, a1, a1, a2, b1, b1, a1, a2, a3, b1,a1, a2, a3, a1, a4, b1, b2, a2, a1, a2, a3, a4, a5, b1, b2, a3, a0, a4, a5, a1, b1, a2, b2, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, a0, b1, a1, b2, a2, b3, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, b4, b1, a0, b2, a1, b3, a2, b4, a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, b4, b1, b5, b2, a0, a1, a2, a3, a4, a5, b3, b1, b4, b2, b5, b3, a0, b4, a1, b5, a2, a0, a3, a1, a4, a2, a5, a3, b0, a4, b1, a5, b2, b0, b3, b1, b4, b2, b5, b3, b4, a0, b5, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, 结果说明：示例程序中，启动两个线程 (线程 a 和线程 b) 分别对 ConcurrentSkipListSet 进行操作。以线程 a 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 ConcurrentSkipListSet 集合中；接着，遍历并输出集合中的全部元素。 线程 b 的操作和线程 a 一样，只不过线程 b 的名字和线程 a 的名字不同。当 set 是 ConcurrentSkipListSet 对象时，程序能正常运行。如果将 set 改为 TreeSet 时，程序会产生 ConcurrentModificationException 异常。 07 ArrayBlockingQueue概要本章对 Java.util.concurrent 包中的 ArrayBlockingQueue 类进行详细的介绍。内容包括：ArrayBlockingQueue 介绍 ArrayBlockingQueue 原理和数据结构ArrayBlockingQueue 函数列表ArrayBlockingQueue 源码分析 (JDK1.7.0_40 版本)ArrayBlockingQueue 示例 ArrayBlockingQueue 介绍ArrayBlockingQueue 是数组实现的线程安全的有界的阻塞队列。线程安全是指，ArrayBlockingQueue 内部通过 “互斥锁” 保护竞争资源，实现了多线程对竞争资源的互斥访问。而有界，则是指 ArrayBlockingQueue 对应的数组是有界限的。 阻塞队列，是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待；而且，ArrayBlockingQueue 是按 FIFO（先进先出）原则对元素进行排序，元素都是从尾部插入到队列，从头部开始返回。 注意：ArrayBlockingQueue 不同于 ConcurrentLinkedQueue，ArrayBlockingQueue 是数组实现的，并且是有界限的；而 ConcurrentLinkedQueue 是链表实现的，是无界限的。 ArrayBlockingQueue 原理和数据结构ArrayBlockingQueue 的数据结构，如下图所示： 说明： 1. ArrayBlockingQueue 继承于 AbstractQueue，并且它实现了 BlockingQueue 接口。 2. ArrayBlockingQueue 内部是通过 Object[] 数组保存数据的，也就是说 ArrayBlockingQueue 本质上是通过数组实现的。ArrayBlockingQueue 的大小，即数组的容量是创建 ArrayBlockingQueue 时指定的。 3. ArrayBlockingQueue 与 ReentrantLock 是组合关系，ArrayBlockingQueue 中包含一个 ReentrantLock 对象 (lock)。ReentrantLock 是可重入的互斥锁，ArrayBlockingQueue 就是根据该互斥锁实现 “多线程对竞争资源的互斥访问”。而且，ReentrantLock 分为公平锁和非公平锁，关于具体使用公平锁还是非公平锁，在创建 ArrayBlockingQueue 时可以指定；而且，ArrayBlockingQueue 默认会使用非公平锁。 4. ArrayBlockingQueue 与 Condition 是组合关系，ArrayBlockingQueue 中包含两个 Condition 对象 (notEmpty 和 notFull)。而且，Condition 又依赖于 ArrayBlockingQueue 而存在，通过 Condition 可以实现对 ArrayBlockingQueue 的更精确的访问 – (01) 若某线程 (线程 A) 要取数据时，数组正好为空，则该线程会执行 notEmpty.await()进行等待；当其它某个线程 (线程 B) 向数组中插入了数据之后，会调用 notEmpty.signal()唤醒 “notEmpty 上的等待线程”。此时，线程 A 会被唤醒从而得以继续运行。(02) 若某线程 (线程 H) 要插入数据时，数组已满，则该线程会它执行 notFull.await()进行等待；当其它某个线程 (线程 I) 取出数据之后，会调用 notFull.signal()唤醒“notFull 上的等待线程”。此时，线程 H 就会被唤醒从而得以继续运行。 关于 ReentrantLock，公平锁，非公平锁，以及 Condition 等更多的内容，可以参考： (01) Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock (02) Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) (03) Java 多线程系列 –“JUC 锁”04 之 公平锁 (二) (04) Java 多线程系列 –“JUC 锁”05 之 非公平锁 (05) Java 多线程系列 –“JUC 锁”06 之 Condition 条件 ArrayBlockingQueue 函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445// 创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。ArrayBlockingQueue(int capacity)// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。ArrayBlockingQueue(int capacity, boolean fair)// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c)// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException。boolean add(E e)// 自动移除此队列中的所有元素。void clear()// 如果此队列包含指定的元素，则返回 true。boolean contains(Object o)// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c)// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c, int maxElements)// 返回在此队列中的元素上按适当顺序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false。boolean offer(E e)// 将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间。boolean offer(E e, long timeout, TimeUnit unit)// 获取但不移除此队列的头；如果此队列为空，则返回 null。E peek()// 获取并移除此队列的头，如果此队列为空，则返回 null。E poll()// 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。E poll(long timeout, TimeUnit unit)// 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间。void put(E e)// 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的其他元素数量。int remainingCapacity()// 从此队列中移除指定元素的单个实例（如果存在）。boolean remove(Object o)// 返回此队列中元素的数量。int size()// 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。E take()// 返回一个按适当顺序包含此队列中所有元素的数组。Object[] toArray()// 返回一个按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a)// 返回此 collection 的字符串表示形式。String toString() ArrayBlockingQueue 源码分析 (JDK1.7.0_40 版本)ArrayBlockingQueue.java 的完整源码如下： ArrayBlockingQueue.java 的完整源码 下面从 ArrayBlockingQueue 的创建，添加，取出，遍历这几个方面对 ArrayBlockingQueue 进行分析。 1. 创建 下面以 ArrayBlockingQueue(int capacity, boolean fair) 来进行说明。 12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 说明：(01) items 是保存 “阻塞队列” 数据的数组。它的定义如下： final Object[] items; (02) fair 是 “可重入的独占锁(ReentrantLock)” 的类型。fair 为 true，表示是公平锁；fair 为 false，表示是非公平锁。notEmpty 和 notFull 是锁的两个 Condition 条件。它们的定义如下： final ReentrantLock lock;private final Condition notEmpty;private final Condition notFull; 简单对 Condition 和 Lock 的用法进行说明，更多内容请参考 “Java 多线程系列 –“JUC 锁”06 之 Condition 条件”。Lock 的作用是提供独占锁机制，来保护竞争资源；而 Condition 是为了更加精细的对锁进行控制，它依赖于 Lock，通过某个条件对多线程进行控制。notEmpty 表示 “锁的非空条件”。当某线程想从队列中取数据时，而此时又没有数据，则该线程通过 notEmpty.await() 进行等待；当其它线程向队列中插入了元素之后，就调用 notEmpty.signal()唤醒 “之前通过 notEmpty.await() 进入等待状态的线程”。同理，notFull 表示 “锁的满条件”。当某线程想向队列中插入元素，而此时队列已满时，该线程等待；当其它线程从队列中取出元素之后，就唤醒该等待的线程。 2. 添加 下面以 offer(E e) 为例，对 ArrayBlockingQueue 的添加方法进行说明。 1234567891011121314151617181920public boolean offer(E e) &#123; // 创建插入的元素是否为null，是的话抛出NullPointerException异常 checkNotNull(e); // 获取“该阻塞队列的独占锁” final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 如果队列已满，则返回false。 if (count == items.length) return false; else &#123; // 如果队列未满，则插入e，并返回true。 insert(e); return true; &#125; &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 说明：offer(E e) 的作用是将 e 插入阻塞队列的尾部。如果队列已满，则返回 false，表示插入失败；否则，插入元素，并返回 true。(01) count 表示” 队列中的元素个数 “。除此之外，队列中还有另外两个遍历 takeIndex 和 putIndex。takeIndex 表示下一个被取出元素的索引，putIndex 表示下一个被添加元素的索引。它们的定义如下： 123456// 队列中的元素个数int takeIndex;// 下一个被取出元素的索引int putIndex;// 下一个被添加元素的索引int count; (02) insert() 的源码如下： 12345678910private void insert(E x) &#123; // 将x添加到”队列“中 items[putIndex] = x; // 设置”下一个被取出元素的索引“ putIndex = inc(putIndex); // 将”队列中的元素个数”+1 ++count; // 唤醒notEmpty上的等待线程 notEmpty.signal();&#125; insert() 在插入元素之后，会唤醒 notEmpty 上面的等待线程。 inc() 的源码如下： 123final int inc(int i) &#123; return (++i == items.length) ? 0 : i;&#125; 若 i+1 的值等于 “队列的长度”，即添加元素之后，队列满；则设置“下一个被添加元素的索引” 为 0。 3. 取出 下面以 take() 为例，对 ArrayBlockingQueue 的取出方法进行说明。 12345678910111213141516public E take() throws InterruptedException &#123; // 获取“队列的独占锁” final ReentrantLock lock = this.lock; // 获取“锁”，若当前线程是中断状态，则抛出InterruptedException异常 lock.lockInterruptibly(); try &#123; // 若“队列为空”，则一直等待。 while (count == 0) notEmpty.await(); // 取出元素 return extract(); &#125; finally &#123; // 释放“锁” lock.unlock(); &#125;&#125; 说明：take() 的作用是取出并返回队列的头。若队列为空，则一直等待。 extract() 的源码如下： 1234567891011121314private E extract() &#123; final Object[] items = this.items; // 强制将元素转换为“泛型E” E x = this.&lt;E&gt;cast(items[takeIndex]); // 将第takeIndex元素设为null，即删除。同时，帮助GC回收。 items[takeIndex] = null; // 设置“下一个被取出元素的索引” takeIndex = inc(takeIndex); // 将“队列中元素数量”-1 --count; // 唤醒notFull上的等待线程。 notFull.signal(); return x;&#125; 说明：extract() 在删除元素之后，会唤醒 notFull 上的等待线程。 4. 遍历 下面对 ArrayBlockingQueue 的遍历方法进行说明。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; Itr 是实现了 Iterator 接口的类，它的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private class Itr implements Iterator&lt;E&gt; &#123; // 队列中剩余元素的个数 private int remaining; // Number of elements yet to be returned // 下一次调用next()返回的元素的索引 private int nextIndex; // Index of element to be returned by next // 下一次调用next()返回的元素 private E nextItem; // Element to be returned by next call to next // 上一次调用next()返回的元素 private E lastItem; // Element returned by last call to next // 上一次调用next()返回的元素的索引 private int lastRet; // Index of last element returned, or -1 if none Itr() &#123; // 获取“阻塞队列”的锁 final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; lastRet = -1; if ((remaining = count) &gt; 0) nextItem = itemAt(nextIndex = takeIndex); &#125; finally &#123; // 释放“锁” lock.unlock(); &#125; &#125; public boolean hasNext() &#123; return remaining &gt; 0; &#125; public E next() &#123; // 获取“阻塞队列”的锁 final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; // 若“剩余元素&lt;=0”，则抛出异常。 if (remaining &lt;= 0) throw new NoSuchElementException(); lastRet = nextIndex; // 获取第nextIndex位置的元素 E x = itemAt(nextIndex); // check for fresher value if (x == null) &#123; x = nextItem; // we are forced to report old value lastItem = null; // but ensure remove fails &#125; else lastItem = x; while (--remaining &gt; 0 &amp;&amp; // skip over nulls (nextItem = itemAt(nextIndex = inc(nextIndex))) == null) ; return x; &#125; finally &#123; lock.unlock(); &#125; &#125; public void remove() &#123; final ReentrantLock lock = ArrayBlockingQueue.this.lock; lock.lock(); try &#123; int i = lastRet; if (i == -1) throw new IllegalStateException(); lastRet = -1; E x = lastItem; lastItem = null; // only remove if item still at index if (x != null &amp;&amp; x == items[i]) &#123; boolean removingHead = (i == takeIndex); removeAt(i); if (!removingHead) nextIndex = dec(nextIndex); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; ArrayBlockingQueue 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * ArrayBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是ArrayBlockingQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ArrayBlockingQueueDemo1&#123; // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(20); public static void main(String[] args) &#123; // 同时启动两个线程对queue进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value; Iterator iter = queue.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112ta1, ta1, tb1, ta1, tb1, ta1, ta2, tb1, ta1, ta2, tb1, tb2, ta2, ta1, tb2, tb1, ta3, ta2, ta1, tb2, tb1, ta3, ta2, tb3, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, tb4, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, tb5, tb3, ta1, ta4, tb1, tb4, ta2, ta5, tb2, tb5, ta3, ta6, tb3, ta4, tb4, ta5, tb5, ta6, tb6, 结果说明：如果将源码中的 queue 改成 LinkedList 对象时，程序会产生 ConcurrentModificationException 异常。 08 LinkedBlockingQueue概要本章介绍 JUC 包中的 LinkedBlockingQueue。内容包括：LinkedBlockingQueue 介绍LinkedBlockingQueue 原理和数据结构LinkedBlockingQueue 函数列表LinkedBlockingQueue 源码分析 (JDK1.7.0_40 版本)LinkedBlockingQueue 示例 LinkedBlockingQueue 介绍LinkedBlockingQueue 是一个单向链表实现的阻塞队列。该队列按 FIFO（先进先出）排序元素，新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 此外，LinkedBlockingQueue 还是可选容量的 (防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于 Integer.MAX_VALUE。 LinkedBlockingQueue 原理和数据结构LinkedBlockingQueue 的数据结构，如下图所示： 说明：1. LinkedBlockingQueue 继承于 AbstractQueue，它本质上是一个 FIFO(先进先出) 的队列。2. LinkedBlockingQueue 实现了 BlockingQueue 接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。3. LinkedBlockingQueue 是通过单链表实现的。(01) head 是链表的表头。取出数据时，都是从表头 head 处插入。(02) last 是链表的表尾。新增数据时，都是从表尾 last 处插入。(03) count 是链表的实际大小，即当前链表中包含的节点个数。(04) capacity 是列表的容量，它是在创建链表时指定的。(05) putLock 是插入锁，takeLock 是取出锁；notEmpty 是 “非空条件”，notFull 是 “未满条件”。通过它们对链表进行并发控制。 LinkedBlockingQueue 在实现 “多线程对竞争资源的互斥访问” 时，对于 “插入” 和“取出 (删除)” 操作分别使用了不同的锁。对于插入操作，通过 “插入锁 putLock” 进行同步；对于取出操作，通过 “取出锁 takeLock” 进行同步。 此外，插入锁 putLock 和 “非满条件 notFull” 相关联，取出锁 takeLock 和 “非空条件 notEmpty” 相关联。通过 notFull 和 notEmpty 更细腻的控制锁。 – 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。 – 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。 关于 ReentrantLock 和 Condition 等更多的内容，可以参考： (01) Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock (02) Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) (03) Java 多线程系列 –“JUC 锁”04 之 公平锁 (二) (04) Java 多线程系列 –“JUC 锁”05 之 非公平锁 (05) Java 多线程系列 –“JUC 锁”06 之 Condition 条件 LinkedBlockingQueue 函数列表1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue。LinkedBlockingQueue()// 创建一个容量是 Integer.MAX_VALUE 的 LinkedBlockingQueue，最初包含给定 collection 的元素，元素按该 collection 迭代器的遍历顺序添加。LinkedBlockingQueue(Collection&lt;? extends E&gt; c)// 创建一个具有给定（固定）容量的 LinkedBlockingQueue。LinkedBlockingQueue(int capacity)// 从队列彻底移除所有元素。void clear()// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c)// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c, int maxElements)// 返回在队列中的元素上按适当顺序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 将指定元素插入到此队列的尾部（如果立即可行且不会超出此队列的容量），在成功时返回 true，如果此队列已满，则返回 false。boolean offer(E e)// 将指定元素插入到此队列的尾部，如有必要，则等待指定的时间以使空间变得可用。boolean offer(E e, long timeout, TimeUnit unit)// 获取但不移除此队列的头；如果此队列为空，则返回 null。E peek()// 获取并移除此队列的头，如果此队列为空，则返回 null。E poll()// 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。E poll(long timeout, TimeUnit unit)// 将指定元素插入到此队列的尾部，如有必要，则等待空间变得可用。void put(E e)// 返回理想情况下（没有内存和资源约束）此队列可接受并且不会被阻塞的附加元素数量。int remainingCapacity()// 从此队列移除指定元素的单个实例（如果存在）。boolean remove(Object o)// 返回队列中的元素个数。int size()// 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。E take()// 返回按适当顺序包含此队列中所有元素的数组。Object[] toArray()// 返回按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a)// 返回此 collection 的字符串表示形式。String toString() LinkedBlockingQueue 源码分析 (JDK1.7.0_40 版本)LinkedBlockingQueue.java 的完整源码如下： LinkedBlockingQueue.java 的完整源码下面从 LinkedBlockingQueue 的创建，添加，删除，遍历这几个方面对它进行分析。 1. 创建 下面以 LinkedBlockingQueue(int capacity) 来进行说明。 12345public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null);&#125; 说明：(01) capacity 是 “链式阻塞队列” 的容量。(02) head 和 last 是 “链式阻塞队列” 的首节点和尾节点。它们在 LinkedBlockingQueue 中的声明如下： 123456789101112// 容量private final int capacity;// 当前数量private final AtomicInteger count = new AtomicInteger(0);private transient Node&lt;E&gt; head; // 链表的表头private transient Node&lt;E&gt; last; // 链表的表尾// 用于控制“删除元素”的互斥锁takeLock 和 锁对应的“非空条件”notEmptyprivate final ReentrantLock takeLock = new ReentrantLock();private final Condition notEmpty = takeLock.newCondition();// 用于控制“添加元素”的互斥锁putLock 和 锁对应的“非满条件”notFullprivate final ReentrantLock putLock = new ReentrantLock();private final Condition notFull = putLock.newCondition(); 链表的节点定义如下： 123456static class Node&lt;E&gt; &#123; E item; // 数据 Node&lt;E&gt; next; // 下一个节点的指针 Node(E x) &#123; item = x; &#125;&#125; 2. 添加 下面以 offer(E e) 为例，对 LinkedBlockingQueue 的添加方法进行说明。 123456789101112131415161718192021222324252627282930313233public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); // 如果“队列已满”，则返回false，表示插入失败。 final AtomicInteger count = this.count; if (count.get() == capacity) return false; int c = -1; // 新建“节点e” Node&lt;E&gt; node = new Node(e); final ReentrantLock putLock = this.putLock; // 获取“插入锁putLock” putLock.lock(); try &#123; // 再次对“队列是不是满”的进行判断。 // 若“队列未满”，则插入节点。 if (count.get() &lt; capacity) &#123; // 插入节点 enqueue(node); // 将“当前节点数量”+1，并返回“原始的数量” c = count.getAndIncrement(); // 如果在插入元素之后，队列仍然未满，则唤醒notFull上的等待线程。 if (c + 1 &lt; capacity) notFull.signal(); &#125; &#125; finally &#123; // 释放“插入锁putLock” putLock.unlock(); &#125; // 如果在插入节点前，队列为空；则插入节点后，唤醒notEmpty上的等待线程 if (c == 0) signalNotEmpty(); return c &gt;= 0;&#125; 说明：offer() 的作用很简单，就是将元素 E 添加到队列的末尾。 enqueue() 的源码如下： 12345private void enqueue(Node&lt;E&gt; node) &#123; // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node;&#125; enqueue() 的作用是将 node 添加到队列末尾，并设置 node 为新的尾节点！ signalNotEmpty() 的源码如下： 123456789private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125; signalNotEmpty() 的作用是唤醒 notEmpty 上的等待线程。 3. 取出 下面以 take() 为例，对 LinkedBlockingQueue 的取出方法进行说明。 123456789101112131415161718192021222324252627public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; // 获取“取出锁”，若当前线程是中断状态，则抛出InterruptedException异常 takeLock.lockInterruptibly(); try &#123; // 若“队列为空”，则一直等待。 while (count.get() == 0) &#123; notEmpty.await(); &#125; // 取出元素 x = dequeue(); // 取出元素之后，将“节点数量”-1；并返回“原始的节点数量”。 c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; // 释放“取出锁” takeLock.unlock(); &#125; // 如果在“取出元素之前”，队列是满的；则在取出元素之后，唤醒notFull上的等待线程。 if (c == capacity) signalNotFull(); return x;&#125; 说明：take() 的作用是取出并返回队列的头。若队列为空，则一直等待。 dequeue() 的源码如下： 1234567891011private E dequeue() &#123; // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x;&#125; dequeue() 的作用就是删除队列的头节点，并将表头指向 “原头节点的下一个节点”。 signalNotFull() 的源码如下： 123456789private void signalNotFull() &#123; final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125;&#125; signalNotFull() 的作用就是唤醒 notFull 上的等待线程。 4. 遍历 下面对 LinkedBlockingQueue 的遍历方法进行说明。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; iterator() 实际上是返回一个 Iter 对象。 Itr 类的定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private class Itr implements Iterator&lt;E&gt; &#123; // 当前节点 private Node&lt;E&gt; current; // 上一次返回的节点 private Node&lt;E&gt; lastRet; // 当前节点对应的值 private E currentElement; Itr() &#123; // 同时获取“插入锁putLock” 和 “取出锁takeLock” fullyLock(); try &#123; // 设置“当前元素”为“队列表头的下一节点”，即为队列的第一个有效节点 current = head.next; if (current != null) currentElement = current.item; &#125; finally &#123; // 释放“插入锁putLock” 和 “取出锁takeLock” fullyUnlock(); &#125; &#125; // 返回“下一个节点是否为null” public boolean hasNext() &#123; return current != null; &#125; private Node&lt;E&gt; nextNode(Node&lt;E&gt; p) &#123; for (;;) &#123; Node&lt;E&gt; s = p.next; if (s == p) return head.next; if (s == null || s.item != null) return s; p = s; &#125; &#125; // 返回下一个节点 public E next() &#123; fullyLock(); try &#123; if (current == null) throw new NoSuchElementException(); E x = currentElement; lastRet = current; current = nextNode(current); currentElement = (current == null) ? null : current.item; return x; &#125; finally &#123; fullyUnlock(); &#125; &#125; // 删除下一个节点 public void remove() &#123; if (lastRet == null) throw new IllegalStateException(); fullyLock(); try &#123; Node&lt;E&gt; node = lastRet; lastRet = null; for (Node&lt;E&gt; trail = head, p = trail.next; p != null; trail = p, p = p.next) &#123; if (p == node) &#123; unlink(p, trail); break; &#125; &#125; &#125; finally &#123; fullyUnlock(); &#125; &#125;&#125; LinkedBlockingQueue 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import java.util.*;import java.util.concurrent.*;/* * LinkedBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是LinkedBlockingQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class LinkedBlockingQueueDemo1 &#123; // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对queue进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value; Iterator iter = queue.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112tb1, ta1, tb1, ta1, ta2, tb1, ta1, ta2, ta3, tb1, ta1, ta2, ta3, ta4, tb1, ta1, tb1, ta2, ta1, ta3, ta2, ta4, ta3, ta5, ta4, tb1, ta5, ta1, ta6, ta2, tb1, ta3, ta1, ta4, ta2, ta5, ta3, ta6, ta4, tb2, ta5, ta6, tb2, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb5, tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb5, tb6, 结果说明：示例程序中，启动两个线程 (线程 ta 和线程 tb) 分别对 LinkedBlockingQueue 进行操作。以线程 ta 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 LinkedBlockingQueue 中；接着，遍历并输出 LinkedBlockingQueue 中的全部元素。 线程 tb 的操作和线程 ta 一样，只不过线程 tb 的名字和线程 ta 的名字不同。当 queue 是 LinkedBlockingQueue 对象时，程序能正常运行。如果将 queue 改为 LinkedList 时，程序会产生 ConcurrentModificationException 异常。 09 LinkedBlockingDeque概要本章介绍 JUC 包中的 LinkedBlockingDeque。内容包括：LinkedBlockingDeque 介绍LinkedBlockingDeque 原理和数据结构LinkedBlockingDeque 函数列表LinkedBlockingDeque 源码分析 (JDK1.7.0_40 版本)LinkedBlockingDeque 示例 LinkedBlockingDeque 介绍LinkedBlockingDeque 是双向链表实现的双向并发阻塞队列。该阻塞队列同时支持 FIFO 和 FILO 两种操作方式，即可以从队列的头和尾同时操作 (插入 / 删除)；并且，该阻塞队列是支持线程安全。 此外，LinkedBlockingDeque 还是可选容量的 (防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于 Integer.MAX_VALUE。 LinkedBlockingDeque 原理和数据结构LinkedBlockingDeque 的数据结构，如下图所示： 说明：1. LinkedBlockingDeque 继承于 AbstractQueue，它本质上是一个支持 FIFO 和 FILO 的双向的队列。2. LinkedBlockingDeque 实现了 BlockingDeque 接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。3. LinkedBlockingDeque 是通过双向链表实现的。3.1 first 是双向链表的表头。3.2 last 是双向链表的表尾。3.3 count 是 LinkedBlockingDeque 的实际大小，即双向链表中当前节点个数。3.4 capacity 是 LinkedBlockingDeque 的容量，它是在创建 LinkedBlockingDeque 时指定的。3.5 lock 是控制对 LinkedBlockingDeque 的互斥锁，当多个线程竞争同时访问 LinkedBlockingDeque 时，某线程获取到了互斥锁 lock，其它线程则需要阻塞等待，直到该线程释放 lock，其它线程才有机会获取 lock 从而获取 cpu 执行权。3.6 notEmpty 和 notFull 分别是 “非空条件” 和“未满条件”。通过它们能够更加细腻进行并发控制。 – 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。– 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。 关于 ReentrantLock 和 Condition 等更多的内容，可以参考： (01) Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock (02) Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) (03) Java 多线程系列 –“JUC 锁”04 之 公平锁 (二) (04) Java 多线程系列 –“JUC 锁”05 之 非公平锁 (05) Java 多线程系列 –“JUC 锁”06 之 Condition 条件 LinkedBlockingDeque 函数列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingDeque。LinkedBlockingDeque()// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingDeque，最初包含给定 collection 的元素，以该 collection 迭代器的遍历顺序添加。LinkedBlockingDeque(Collection&lt;? extends E&gt; c)// 创建一个具有给定（固定）容量的 LinkedBlockingDeque。LinkedBlockingDeque(int capacity)// 在不违反容量限制的情况下，将指定的元素插入此双端队列的末尾。boolean add(E e)// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头；如果当前没有空间可用，则抛出 IllegalStateException。void addFirst(E e)// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾；如果当前没有空间可用，则抛出 IllegalStateException。void addLast(E e)// 以原子方式 (atomically) 从此双端队列移除所有元素。void clear()// 如果此双端队列包含指定的元素，则返回 true。boolean contains(Object o)// 返回在此双端队列的元素上以逆向连续顺序进行迭代的迭代器。Iterator&lt;E&gt; descendingIterator()// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c)// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。int drainTo(Collection&lt;? super E&gt; c, int maxElements)// 获取但不移除此双端队列表示的队列的头部。E element()// 获取，但不移除此双端队列的第一个元素。E getFirst()// 获取，但不移除此双端队列的最后一个元素。E getLast()// 返回在此双端队列元素上以恰当顺序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），并在成功时返回 true；如果当前没有空间可用，则返回 false。boolean offer(E e)// 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将在指定的等待时间内一直等待可用空间。boolean offer(E e, long timeout, TimeUnit unit)// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头，并在成功时返回 true；如果当前没有空间可用，则返回 false。boolean offerFirst(E e)// 将指定的元素插入此双端队列的开头，必要时将在指定的等待时间内等待可用空间。boolean offerFirst(E e, long timeout, TimeUnit unit)// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾，并在成功时返回 true；如果当前没有空间可用，则返回 false。boolean offerLast(E e)// 将指定的元素插入此双端队列的末尾，必要时将在指定的等待时间内等待可用空间。boolean offerLast(E e, long timeout, TimeUnit unit)// 获取但不移除此双端队列表示的队列的头部（即此双端队列的第一个元素）；如果此双端队列为空，则返回 null。E peek()// 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。E peekFirst()// 获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。E peekLast()// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素）；如果此双端队列为空，则返回 null。E poll()// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），如有必要将在指定的等待时间内等待可用元素。E poll(long timeout, TimeUnit unit)// 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。E pollFirst()// 获取并移除此双端队列的第一个元素，必要时将在指定的等待时间等待可用元素。E pollFirst(long timeout, TimeUnit unit)// 获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。E pollLast()// 获取并移除此双端队列的最后一个元素，必要时将在指定的等待时间内等待可用元素。E pollLast(long timeout, TimeUnit unit)// 从此双端队列所表示的堆栈中弹出一个元素。E pop()// 将元素推入此双端队列表示的栈。void push(E e)// 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将一直等待可用空间。void put(E e)// 将指定的元素插入此双端队列的开头，必要时将一直等待可用空间。void putFirst(E e)// 将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间。void putLast(E e)// 返回理想情况下（没有内存和资源约束）此双端队列可不受阻塞地接受的额外元素数。int remainingCapacity()// 获取并移除此双端队列表示的队列的头部。E remove()// 从此双端队列移除第一次出现的指定元素。boolean remove(Object o)// 获取并移除此双端队列第一个元素。E removeFirst()// 从此双端队列移除第一次出现的指定元素。boolean removeFirstOccurrence(Object o)// 获取并移除此双端队列的最后一个元素。E removeLast()// 从此双端队列移除最后一次出现的指定元素。boolean removeLastOccurrence(Object o)// 返回此双端队列中的元素数。int size()// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），必要时将一直等待可用元素。E take()// 获取并移除此双端队列的第一个元素，必要时将一直等待可用元素。E takeFirst()// 获取并移除此双端队列的最后一个元素，必要时将一直等待可用元素。E takeLast()// 返回以恰当顺序（从第一个元素到最后一个元素）包含此双端队列所有元素的数组。Object[] toArray()// 返回以恰当顺序包含此双端队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a)// 返回此 collection 的字符串表示形式。String toString() LinkedBlockingDeque 源码分析 (JDK1.7.0_40 版本)LinkedBlockingDeque.java 的完整源码如下： LinkedBlockingDeque.java 的完整源码 下面从 ArrayBlockingQueue 的创建，添加，取出，遍历这几个方面对 LinkedBlockingDeque 进行分析 1. 创建 下面以 LinkedBlockingDeque(int capacity) 来进行说明。 1234public LinkedBlockingDeque(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity;&#125; 说明：capacity 是 “链式阻塞队列” 的容量。 LinkedBlockingDeque 中相关的数据结果定义如下： 123456789101112// “双向队列”的表头transient Node&lt;E&gt; first;// “双向队列”的表尾transient Node&lt;E&gt; last;// 节点数量private transient int count;// 容量private final int capacity;// 互斥锁 , 互斥锁对应的“非空条件notEmpty”, 互斥锁对应的“未满条件notFull”final ReentrantLock lock = new ReentrantLock();private final Condition notEmpty = lock.newCondition();private final Condition notFull = lock.newCondition(); 说明：lock 是互斥锁，用于控制多线程对 LinkedBlockingDeque 中元素的互斥访问；而 notEmpty 和 notFull 是与 lock 绑定的条件，它们用于实现对多线程更精确的控制。 双向链表的节点 Node 的定义如下： 1234567static final class Node&lt;E&gt; &#123; E item; // 数据 Node&lt;E&gt; prev; // 前一节点 Node&lt;E&gt; next; // 后一节点 Node(E x) &#123; item = x; &#125;&#125; 2. 添加 下面以 offer(E e) 为例，对 LinkedBlockingDeque 的添加方法进行说明。 123public boolean offer(E e) &#123; return offerLast(e);&#125; offer() 实际上是调用 offerLast() 将元素添加到队列的末尾。 offerLast() 的源码如下： 123456789101112131415public boolean offerLast(E e) &#123; if (e == null) throw new NullPointerException(); // 新建节点 Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try &#123; // 将“新节点”添加到双向链表的末尾 return linkLast(node); &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 说明：offerLast() 的作用，是新建节点并将该节点插入到双向链表的末尾。它在插入节点前，会获取锁；操作完毕，再释放锁。 linkLast() 的源码如下： 123456789101112131415161718private boolean linkLast(Node&lt;E&gt; node) &#123; // 如果“双向链表的节点数量” &gt; “容量”，则返回false，表示插入失败。 if (count &gt;= capacity) return false; // 将“node添加到链表末尾”，并设置node为新的尾节点 Node&lt;E&gt; l = last; node.prev = l; last = node; if (first == null) first = node; else l.next = node; // 将“节点数量”+1 ++count; // 插入节点之后，唤醒notEmpty上的等待线程。 notEmpty.signal(); return true;&#125; 说明：linkLast() 的作用，是将节点插入到双向队列的末尾；插入节点之后，唤醒 notEmpty 上的等待线程。 3. 删除 下面以 take() 为例，对 LinkedBlockingDeque 的取出方法进行说明。 123public E take() throws InterruptedException &#123; return takeFirst();&#125; take() 实际上是调用 takeFirst() 队列的第一个元素。 takeFirst() 的源码如下： 123456789101112131415public E takeFirst() throws InterruptedException &#123; final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try &#123; E x; // 若“队列为空”，则一直等待。否则，通过unlinkFirst()删除第一个节点。 while ( (x = unlinkFirst()) == null) notEmpty.await(); return x; &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 说明：takeFirst() 的作用，是删除双向链表的第一个节点，并返回节点对应的值。它在插入节点前，会获取锁；操作完毕，再释放锁。 unlinkFirst() 的源码如下： 123456789101112131415161718192021private E unlinkFirst() &#123; // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; f = first; if (f == null) return null; // 删除并更新“第一个节点” Node&lt;E&gt; n = f.next; E item = f.item; f.item = null; f.next = f; // help GC first = n; if (n == null) last = null; else n.prev = null; // 将“节点数量”-1 --count; // 删除节点之后，唤醒notFull上的等待线程。 notFull.signal(); return item;&#125; 说明：unlinkFirst() 的作用，是将双向队列的第一个节点删除；删除节点之后，唤醒 notFull 上的等待线程。 4. 遍历 下面对 LinkedBlockingDeque 的遍历方法进行说明。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; iterator() 实际上是返回一个 Iter 对象。 Itr 类的定义如下： 123456private class Itr extends AbstractItr &#123; // “双向队列”的表头 Node&lt;E&gt; firstNode() &#123; return first; &#125; // 获取“节点n的下一个节点” Node&lt;E&gt; nextNode(Node&lt;E&gt; n) &#123; return n.next; &#125;&#125; Itr 继承于 AbstractItr，而 AbstractItr 的定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private abstract class AbstractItr implements Iterator&lt;E&gt; &#123; // next是下一次调用next()会返回的节点。 Node&lt;E&gt; next; // nextItem是next()返回节点对应的数据。 E nextItem; // 上一次next()返回的节点。 private Node&lt;E&gt; lastRet; // 返回第一个节点 abstract Node&lt;E&gt; firstNode(); // 返回下一个节点 abstract Node&lt;E&gt; nextNode(Node&lt;E&gt; n); AbstractItr() &#123; final ReentrantLock lock = LinkedBlockingDeque.this.lock; // 获取“LinkedBlockingDeque的互斥锁” lock.lock(); try &#123; // 获取“双向队列”的表头 next = firstNode(); // 获取表头对应的数据 nextItem = (next == null) ? null : next.item; &#125; finally &#123; // 释放“LinkedBlockingDeque的互斥锁” lock.unlock(); &#125; &#125; // 获取n的后继节点 private Node&lt;E&gt; succ(Node&lt;E&gt; n) &#123; // Chains of deleted nodes ending in null or self-links // are possible if multiple interior nodes are removed. for (;;) &#123; Node&lt;E&gt; s = nextNode(n); if (s == null) return null; else if (s.item != null) return s; else if (s == n) return firstNode(); else n = s; &#125; &#125; // 更新next和nextItem。 void advance() &#123; final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try &#123; // assert next != null; next = succ(next); nextItem = (next == null) ? null : next.item; &#125; finally &#123; lock.unlock(); &#125; &#125; // 返回“下一个节点是否为null” public boolean hasNext() &#123; return next != null; &#125; // 返回下一个节点 public E next() &#123; if (next == null) throw new NoSuchElementException(); lastRet = next; E x = nextItem; advance(); return x; &#125; // 删除下一个节点 public void remove() &#123; Node&lt;E&gt; n = lastRet; if (n == null) throw new IllegalStateException(); lastRet = null; final ReentrantLock lock = LinkedBlockingDeque.this.lock; lock.lock(); try &#123; if (n.item != null) unlink(n); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; LinkedBlockingDeque 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;import java.util.concurrent.*;/* * LinkedBlockingDeque是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是LinkedBlockingDeque对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class LinkedBlockingDequeDemo1 &#123; // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new LinkedBlockingDeque&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对queue进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value; Iterator iter = queue.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112ta1, ta1, tb1, tb1,ta1, ta1, tb1, tb1, tb2, tb2, ta2, ta2, ta1, ta1, tb1, tb1, tb2, tb2, ta2, ta2, tb3, tb3, ta3, ta3, ta1, tb1, ta1, tb2, tb1, ta2, tb2, tb3, ta2, ta3, tb3, tb4, ta3, ta4, tb4, ta1, ta4, tb1, tb5, tb2, ta1, ta2, tb1, tb3, tb2, ta3, ta2, tb4, tb3, ta4, ta3, tb5, tb4, ta5, ta4, ta1, tb5, tb1, ta5, tb2, tb6, ta2, ta1, tb3, tb1, ta3, tb2, tb4, ta2, ta4, tb3, tb5, ta3, ta5, tb4, tb6, ta4, ta6, tb5, ta5, tb6, ta6, 结果说明：示例程序中，启动两个线程 (线程 ta 和线程 tb) 分别对 LinkedBlockingDeque 进行操作。以线程 ta 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 LinkedBlockingDeque 中；接着，遍历并输出 LinkedBlockingDeque 中的全部元素。 线程 tb 的操作和线程 ta 一样，只不过线程 tb 的名字和线程 ta 的名字不同。当 queue 是 LinkedBlockingDeque 对象时，程序能正常运行。如果将 queue 改为 LinkedList 时，程序会产生 ConcurrentModificationException 异常。 10 ConcurrentLinkedQueue概要本章对 Java.util.concurrent 包中的 ConcurrentHashMap 类进行详细的介绍。内容包括：ConcurrentLinkedQueue 介绍ConcurrentLinkedQueue 原理和数据结构ConcurrentLinkedQueue 函数列表ConcurrentLinkedQueue 源码分析 (JDK1.7.0_40 版本)ConcurrentLinkedQueue 示例 ConcurrentLinkedQueue 介绍ConcurrentLinkedQueue 是线程安全的队列，它适用于 “高并发” 的场景。它是一个基于链接节点的无界线程安全队列，按照 FIFO（先进先出）原则对元素进行排序。队列元素中不可以放置 null 元素（内部实现的特殊节点除外）。 ConcurrentLinkedQueue 原理和数据结构ConcurrentLinkedQueue 的数据结构，如下图所示： 说明：1. ConcurrentLinkedQueue 继承于 AbstractQueue。2. ConcurrentLinkedQueue 内部是通过链表来实现的。它同时包含链表的头节点 head 和尾节点 tail。ConcurrentLinkedQueue 按照 FIFO（先进先出）原则对元素进行排序。元素都是从尾部插入到链表，从头部开始返回。3. ConcurrentLinkedQueue 的链表 Node 中的 next 的类型是 volatile，而且链表数据 item 的类型也是 volatile。关于 volatile，我们知道它的语义包含：“即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”。ConcurrentLinkedQueue 就是通过 volatile 来实现多线程对竞争资源的互斥访问的。 ConcurrentLinkedQueue 函数列表123456789101112131415161718192021222324252627// 创建一个最初为空的 ConcurrentLinkedQueue。ConcurrentLinkedQueue()// 创建一个最初包含给定 collection 元素的 ConcurrentLinkedQueue，按照此 collection 迭代器的遍历顺序来添加元素。ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c)// 将指定元素插入此队列的尾部。boolean add(E e)// 如果此队列包含指定元素，则返回 true。boolean contains(Object o)// 如果此队列不包含任何元素，则返回 true。boolean isEmpty()// 返回在此队列元素上以恰当顺序进行迭代的迭代器。Iterator&lt;E&gt; iterator()// 将指定元素插入此队列的尾部。boolean offer(E e)// 获取但不移除此队列的头；如果此队列为空，则返回 null。E peek()// 获取并移除此队列的头，如果此队列为空，则返回 null。E poll()// 从队列中移除指定元素的单个实例（如果存在）。boolean remove(Object o)// 返回此队列中的元素数量。int size()// 返回以恰当顺序包含此队列所有元素的数组。Object[] toArray()// 返回以恰当顺序包含此队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。&lt;T&gt; T[] toArray(T[] a) ConcurrentLinkedQueue 源码分析 (JDK1.7.0_40 版本)ConcurrentLinkedQueue 的完整源码如下： ConcurrentLinkedQueue.java的完整源码 下面从 ConcurrentLinkedQueue 的创建，添加，删除这几个方面对它进行分析。 1 创建 下面以 ConcurrentLinkedQueue() 来进行说明。 123public ConcurrentLinkedQueue() &#123; head = tail = new Node&lt;E&gt;(null);&#125; 说明：在构造函数中，新建了一个 “内容为 null 的节点”，并设置表头 head 和表尾 tail 的值为新节点。 head 和 tail 的定义如下： 12private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail; head 和 tail 都是 volatile 类型，他们具有 volatile 赋予的含义：“即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”。 Node 的声明如下： 1234567891011121314151617181920212223242526272829303132333435363738private static class Node&lt;E&gt; &#123; volatile E item; volatile Node&lt;E&gt; next; Node(E item) &#123; UNSAFE.putObject(this, itemOffset, item); &#125; boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val); &#125; boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("item")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("next")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 说明：Node 是个单向链表节点，next 用于指向下一个 Node，item 用于存储数据。Node 中操作节点数据的 API，都是通过 Unsafe 机制的 CAS 函数实现的；例如 casNext() 是通过 CAS 函数 “比较并设置节点的下一个节点”。 2. 添加 下面以 add(E e) 为例对 ConcurrentLinkedQueue 中的添加进行说明。 123public boolean add(E e) &#123; return offer(e);&#125; 说明：add() 实际上是调用的 offer() 来完成添加操作的。 offer() 的源码如下： 12345678910111213141516171819202122232425262728public boolean offer(E e) &#123; // 检查e是不是null，是的话抛出NullPointerException异常。 checkNotNull(e); // 创建新的节点 final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); // 将“新的节点”添加到链表的末尾。 for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; // 情况1：q为空 if (q == null) &#123; // CAS操作：如果“p的下一个节点为null”(即p为尾节点)，则设置p的下一个节点为newNode。 // 如果该CAS操作成功的话，则比较“p和t”(若p不等于t，则设置newNode为新的尾节点)，然后返回true。 // 如果该CAS操作失败，这意味着“其它线程对尾节点进行了修改”，则重新循环。 if (p.casNext(null, newNode)) &#123; if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; &#125; &#125; // 情况2：p和q相等 else if (p == q) p = (t != (t = tail)) ? t : head; // 情况3：其它 else p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; 说明：offer(E e) 的作用就是将元素 e 添加到链表的末尾。offer() 比较的地方是理解 for 循环，下面区分 3 种情况对 for 进行分析。 情况 1 – q 为空。这意味着 q 是尾节点的下一个节点。此时，通过 p.casNext(null, newNode) 将 “p 的下一个节点设为 newNode”，若设置成功的话，则比较 “p 和 t”(若 p 不等于 t，则设置 newNode 为新的尾节点)，然后返回 true。否则的话 (意味着 “其它线程对尾节点进行了修改”)，什么也不做，继续进行 for 循环。p.casNext(null, newNode)，是调用 CAS 对 p 进行操作。若 “p 的下一个节点等于 null”，则设置 “p 的下一个节点等于 newNode”；设置成功的话，返回 true，失败的话返回 false。 情况 2 – p 和 q 相等。这种情况什么时候会发生呢？通过 “情况 3”，我们知道，经过“情况 3” 的处理后，p 的值可能等于 q。此时，若尾节点没有发生变化的话，那么，应该是头节点发生了变化，则设置 p 为头节点，然后重新遍历链表；否则 (尾节点变化的话)，则设置 p 为尾节点。 情况 3 – 其它。我们将 p = (p != t &amp;&amp; t != (t = tail)) ? t : q; 转换成如下代码。 1234567891011if (p==t) &#123; p = q;&#125; else &#123; Node&lt;E&gt; tmp=t; t = tail; if (tmp==t) &#123; p=q; &#125; else &#123; p=t; &#125;&#125; 如果 p 和 t 相等，则设置 p 为 q。否则的话，判断 “尾节点是否发生变化”，没有变化的话，则设置 p 为 q；否则，设置 p 为尾节点。 checkNotNull() 的源码如下： 1234private static void checkNotNull(Object v) &#123; if (v == null) throw new NullPointerException();&#125; 3. 删除 下面以 poll() 为例对 ConcurrentLinkedQueue 中的删除进行说明。 1234567891011121314151617181920212223242526272829303132public E poll() &#123; // 设置“标记” restartFromHead: for (;;) &#123; for (Node&lt;E&gt; h = head, p = h, q;;) &#123; E item = p.item; // 情况1 // 表头的数据不为null，并且“设置表头的数据为null”这个操作成功的话; // 则比较“p和h”(若p!=h，即表头发生了变化，则更新表头，即设置表头为p)，然后返回原表头的item值。 if (item != null &amp;&amp; p.casItem(item, null)) &#123; if (p != h) // hop two nodes at a time updateHead(h, ((q = p.next) != null) ? q : p); return item; &#125; // 情况2 // 表头的下一个节点为null，即链表只有一个“内容为null的表头节点”。则更新表头为p，并返回null。 else if ((q = p.next) == null) &#123; updateHead(h, p); return null; &#125; // 情况3 // 这可能到由于“情况4”的发生导致p=q，在该情况下跳转到restartFromHead标记重新操作。 else if (p == q) continue restartFromHead; // 情况4 // 设置p为q else p = q; &#125; &#125;&#125; 说明：poll() 的作用就是删除链表的表头节点，并返回被删节点对应的值。poll() 的实现原理和 offer() 比较类似，下面根将 or 循环划分为 4 种情况进行分析。 情况 1：“表头节点的数据”不为 null，并且 “设置表头节点的数据为 null” 这个操作成功。p.casItem(item, null) – 调用 CAS 函数，比较 “节点 p 的数据值” 与 item 是否相等，是的话，设置节点 p 的数据值为 null。在情况 1 发生时，先比较 “p 和 h”，若 p!=h，即表头发生了变化，则调用 updateHead() 更新表头；然后返回删除节点的 item 值。updateHead() 的源码如下： 1234final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123; if (h != p &amp;&amp; casHead(h, p)) h.lazySetNext(h);&#125; 说明：updateHead() 的最终目的是更新表头为 p，并设置 h 的下一个节点为 h 本身。casHead(h,p) 是通过 CAS 函数设置表头，若表头等于 h 的话，则设置表头为 p。lazySetNext() 的源码如下： 123void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val);&#125; putOrderedObject()函数，我们在前面一章 “TODO” 中介绍过。h.lazySetNext(h)的作用是通过 CAS 函数设置 h 的下一个节点为 h 自身，该设置可能会延迟执行。 情况 2：如果表头的下一个节点为 null，即链表只有一个 “内容为 null 的表头节点”。则调用 updateHead(h, p)，将表头更新 p；然后返回 null。 情况 3：p=q在 “情况 4” 的发生后，会导致 p=q；此时，“情况 3”就会发生。当 “情况 3” 发生后，它会跳转到 restartFromHead 标记重新操作。 情况 4：其它情况。设置 p=q。 ConcurrentLinkedQueue 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import java.util.*;import java.util.concurrent.*;/* * ConcurrentLinkedQueue是“线程安全”的队列，而LinkedList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历queue”的示例 * (01) 当queue是ConcurrentLinkedQueue对象时，程序能正常运行。 * (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */public class ConcurrentLinkedQueueDemo1 &#123; // TODO: queue是LinkedList对象时，程序会出错。 //private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); private static Queue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对queue进行操作！ new MyThread("ta").start(); new MyThread("tb").start(); &#125; private static void printAll() &#123; String value; Iterator iter = queue.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; System.out.println(); &#125; private static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (i++ &lt; 6) &#123; // “线程名” + "-" + "序号" String val = Thread.currentThread().getName()+i; queue.add(val); // 通过“Iterator”遍历queue。 printAll(); &#125; &#125; &#125;&#125; (某一次) 运行结果： 123456789101112ta1, ta1, tb1, tb1,ta1, ta1, tb1, tb1, ta2, ta2, tb2, tb2, ta1, ta1, tb1, tb1, ta2, ta2, tb2, tb2, ta3, tb3, ta3, ta1, tb3, tb1, ta4, ta2, ta1, tb2, tb1, ta3, ta2, tb3, tb2, ta4, ta3, tb4, tb3, ta1, ta4, tb1, tb4, ta2, ta5, tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, tb4, ta3, ta5, tb3, tb5, ta4, ta1, tb4, tb1, ta5, ta2, tb5, tb2, ta6, ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, tb5, tb3, ta6, ta4, tb6, tb4, ta5, tb5, ta6, tb6, 结果说明：如果将源码中的 queue 改成 LinkedList 对象时，程序会产生 ConcurrentModificationException 异常。 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列三：JUC锁]]></title>
    <url>%2F2018%2F03%2F24%2F2018-03-24-1%2F</url>
    <content type="text"><![CDATA[01 框架根据锁添加到 Java 中的时间，Java 中的锁，可以分为 “ 同步锁 “和”JUC 包中的锁 “。 同步锁 即通过 synchronized 关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0 版本中就已经支持同步锁了。 同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行 CPU 调度，从而在 CPU 上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运行。这就是，多线程通过同步锁进行同步的原理！ 关于 “同步锁” 的更多内容，请参考 “Java 锁的基础部分 “ 的内容。 JUC 包中的锁 相比同步锁，JUC 包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。 JUC 包中的锁，包括：Lock 接口，ReadWriteLock 接口，LockSupport 阻塞原语，Condition 条件，AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer 三个抽象类，ReentrantLock 独占锁，ReentrantReadWriteLock 读写锁。由于 CountDownLatch，CyclicBarrier 和 Semaphore 也是通过 AQS 来实现的；因此，我也将它们归纳到锁的框架中进行介绍。 先看看锁的框架图，如下所示。 01. Lock 接口 JUC 包中的 Lock 接口支持那些语义不同 (重入、公平等) 的锁规则。所谓语义不同，是指锁可是有 “公平机制的锁”、”非公平机制的锁”、”可重入的锁” 等等。”公平机制” 是指 “不同线程获取锁的机制是公平的”，而 “非公平机制” 则是指 “不同线程获取锁的机制是非公平的”，”可重入的锁” 是指同一个锁能够被一个线程多次获取。 02. ReadWriteLock ReadWriteLock 接口以和 Lock 类似的方式定义了一些读取者可以共享而写入者独占的锁。JUC 包只有一个类实现了该接口，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。 03. AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer AbstractQueuedSynchronizer 就是被称之为 AQS 的类，它是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器；ReentrantLock，ReentrantReadWriteLock，CountDownLatch，CyclicBarrier 和 Semaphore 等这些类都是基于 AQS 类实现的。AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。 04. LockSupport LockSupport 提供 “创建锁” 和“其他同步类的基本线程阻塞原语”。 LockSupport 的功能和 “Thread 中的 Thread.suspend()和 Thread.resume()有点类似”，LockSupport 中的 park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是 park()和 unpark()不会遇到 “Thread.suspend 和 Thread.resume 所可能引发的死锁” 问题。 05. Condition Condition 需要和 Lock 联合使用，它的作用是代替 Object 监视器方法，可以通过 await(),signal() 来休眠 / 唤醒线程。strong textCondition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 06. ReentrantLock Reentrant:可重入 ReentrantLock 是独占锁。所谓独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。ReentrantLock 锁包括 “公平的 ReentrantLock” 和 “非公平的 ReentrantLock”。”公平的 ReentrantLock” 是指 “不同线程获取锁的机制是公平的”，而 “非公平的 ReentrantLock” 则是指 “不同线程获取锁的机制是非公平的”，ReentrantLock 是 “可重入的锁”。 ReentrantLock 的 UML 类图如下： (01) ReentrantLock 实现了 Lock 接口。 (02) ReentrantLock 中有一个成员变量 sync，sync 是 Sync 类型；Sync 是一个抽象类，而且它继承于 AQS。 (03) ReentrantLock 中有 “公平锁类”FairSync 和 “非公平锁类”NonfairSync，它们都是 Sync 的子类。ReentrantReadWriteLock 中 sync 对象，是 FairSync 与 NonfairSync 中的一种，这也意味着 ReentrantLock 是 “公平锁” 或 “非公平锁” 中的一种，ReentrantLock 默认是非公平锁。 07. ReentrantReadWriteLock ReentrantReadWriteLock 是读写锁接口 ReadWriteLock 的实现类，它包括子类 ReadLock 和 WriteLock。ReentrantLock 是共享锁，而 WriteLock 是独占锁。 ReentrantReadWriteLock 的 UML 类图如下： (01) ReentrantReadWriteLock 实现了 ReadWriteLock 接口。 (02) ReentrantReadWriteLock 中包含 sync 对象，读锁 readerLock 和写锁 writerLock。读锁 ReadLock 和写锁 WriteLock 都实现了 Lock 接口。 (03) 和 “ReentrantLock” 一样，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平锁”FairSync 和 “非公平锁”NonfairSync。 08. CountDownLatch CountDownLatch 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 CountDownLatch 的 UML 类图如下： CountDownLatch 包含了 sync 对象，sync 是 Sync 类型。CountDownLatch 的 Sync 是实例类，它继承于 AQS。 09. CyclicBarrier CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 CyclicBarrier 的 UML 类图如下： CyclicBarrier 是包含了 “ReentrantLock 对象 lock” 和 “Condition 对象 trip”，它是通过独占锁实现的。 CyclicBarrier 和 CountDownLatch 的区别是： (01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。 (02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。 10. Semaphore Semaphore 是一个计数信号量，它的本质是一个 “共享锁”。 信号量维护了一个信号量许可集。线程可以通过调用 acquire() 来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过 release() 来释放它所持有的信号量许可。 Semaphore 的 UML 类图如下： 和 “ReentrantLock” 一样，Semaphore 包含了 sync 对象，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平信号量”FairSync 和 “非公平信号量”NonfairSync。 02 互斥锁ReentrantLock本章对 ReentrantLock 包进行基本介绍，这一章主要对 ReentrantLock 进行概括性的介绍，内容包括：ReentrantLock 介绍ReentrantLock 函数列表ReentrantLock 示例在后面的两章，会分别介绍 ReentrantLock 的两个子类 (公平锁和非公平锁) 的实现原理。 ReentrantLock 介绍ReentrantLock 是一个可重入的互斥锁，又被称为 “独占锁”。 顾名思义，ReentrantLock 锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock 锁，可以被单个线程多次获取。ReentrantLock分为 “公平锁” 和 “非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock 在同一个时间点只能被一个线程获取 (当某线程获取到“锁” 时，其它线程就必须等待)；ReentraantLock 是通过一个 FIFO 的等待队列来管理获取该锁所有线程的。在 “公平锁” 的机制下，线程依次排队获取锁；而 “非公平锁” 在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。 ReentrantLock 函数列表1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个 ReentrantLock ，默认是“非公平锁”。ReentrantLock()// 创建策略是fair的 ReentrantLock。fair为true表示是公平锁，fair为false表示是非公平锁。ReentrantLock(boolean fair)// 查询当前线程保持此锁的次数。int getHoldCount()// 返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。protected Thread getOwner()// 返回一个 collection，它包含可能正等待获取此锁的线程。protected Collection&lt;Thread&gt; getQueuedThreads()// 返回正等待获取此锁的线程估计数。int getQueueLength()// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition)// 返回等待与此锁相关的给定条件的线程估计数。int getWaitQueueLength(Condition condition)// 查询给定线程是否正在等待获取此锁。boolean hasQueuedThread(Thread thread)// 查询是否有些线程正在等待获取此锁。boolean hasQueuedThreads()// 查询是否有些线程正在等待与此锁有关的给定条件。boolean hasWaiters(Condition condition)// 如果是“公平锁”返回true，否则返回false。boolean isFair()// 查询当前线程是否保持此锁。boolean isHeldByCurrentThread()// 查询此锁是否由任意线程保持。boolean isLocked()// 获取锁。void lock()// 如果当前线程未被中断，则获取锁。void lockInterruptibly()// 返回用来与此Lock实例一起使用的 Condition 实例。Condition newCondition()// 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。boolean tryLock()// 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。boolean tryLock(long timeout, TimeUnit unit)// 试图释放此锁。void unlock() ReentrantLock 示例通过对比 “示例 1” 和“示例 2”, 我们能够清晰的认识 lock 和 unlock 的作用 示例 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;// LockTest1.java// 仓库class Depot &#123; private int size; // 仓库的实际数量 private Lock lock; // 独占锁 public Depot() &#123; this.size = 0; this.lock = new ReentrantLock(); &#125; public void produce(int val) &#123; lock.lock(); try &#123; size += val; System.out.printf("%s produce(%d) --&gt; size=%d\n", Thread.currentThread().getName(), val, size); &#125; finally &#123; lock.unlock(); &#125; &#125; public void consume(int val) &#123; lock.lock(); try &#123; size -= val; System.out.printf("%s consume(%d) &lt;-- size=%d\n", Thread.currentThread().getName(), val, size); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;; // 生产者class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) &#123; new Thread() &#123; public void run() &#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;// 消费者class Customer &#123; private Depot depot; public Customer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) &#123; new Thread() &#123; public void run() &#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest1 &#123; public static void main(String[] args) &#123; Depot mDepot = new Depot(); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); &#125;&#125; 运行结果： 12345Thread-0 produce(60) --&gt; size=60Thread-1 produce(120) --&gt; size=180Thread-3 consume(150) &lt;-- size=30Thread-2 consume(90) &lt;-- size=-60Thread-4 produce(110) --&gt; size=50 结果分析：(01) Depot 是个仓库。通过 produce()能往仓库中生产货物，通过 consume()能消费仓库中的货物。通过独占锁 lock 实现对仓库的互斥访问：在操作 (生产 / 消费) 仓库中货品前，会先通过 lock()锁住仓库，操作完之后再通过 unlock()解锁。(02) Producer 是生产者类。调用 Producer 中的 produce() 函数可以新建一个线程往仓库中生产产品。(03) Customer 是消费者类。调用 Customer 中的 consume() 函数可以新建一个线程消费仓库中的产品。(04) 在主线程 main 中，我们会新建 1 个生产者 mPro，同时新建 1 个消费者 mCus。它们分别向仓库中生产 / 消费产品。根据 main 中的生产 / 消费数量，仓库最终剩余的产品应该是 50。运行结果是符合我们预期的！ 这个模型存在两个问题：(01) 现实中，仓库的容量不可能为负数。但是，此模型中的仓库容量可以为负数，这与现实相矛盾！(02) 现实中，仓库的容量是有限制的。但是，此模型中的容量确实没有限制的！这两个问题，我们稍微会讲到如何解决。现在，先看个简单的示例 2；通过对比 “示例 1” 和“示例 2”, 我们能更清晰的认识 lock(),unlock()的用途。 示例 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;// LockTest2.java// 仓库class Depot &#123; private int size; // 仓库的实际数量 private Lock lock; // 独占锁 public Depot() &#123; this.size = 0; this.lock = new ReentrantLock(); &#125; public void produce(int val) &#123;// lock.lock();// try &#123; size += val; System.out.printf("%s produce(%d) --&gt; size=%d\n", Thread.currentThread().getName(), val, size);// &#125; catch (InterruptedException e) &#123;// &#125; finally &#123;// lock.unlock();// &#125; &#125; public void consume(int val) &#123;// lock.lock();// try &#123; size -= val; System.out.printf("%s consume(%d) &lt;-- size=%d\n", Thread.currentThread().getName(), val, size);// &#125; finally &#123;// lock.unlock();// &#125; &#125;&#125;; // 生产者class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) &#123; new Thread() &#123; public void run() &#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;// 消费者class Customer &#123; private Depot depot; public Customer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) &#123; new Thread() &#123; public void run() &#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest2 &#123; public static void main(String[] args) &#123; Depot mDepot = new Depot(); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); &#125;&#125; (某一次) 运行结果： 12345Thread-0 produce(60) --&gt; size=-60Thread-4 produce(110) --&gt; size=50Thread-2 consume(90) &lt;-- size=-60Thread-1 produce(120) --&gt; size=-60Thread-3 consume(150) &lt;-- size=-60 结果说明：“示例 2”在 “示例 1” 的基础上去掉了 lock 锁。在 “示例 2” 中，仓库中最终剩余的产品是 - 60，而不是我们期望的 50。原因是我们没有实现对仓库的互斥访问。 示例 3 在 “示例 3” 中，我们通过 Condition 去解决 “示例 1” 中的两个问题：“仓库的容量不可能为负数”以及“仓库的容量是有限制的”。解决该问题是通过 Condition。Condition 是需要和 Lock 联合使用的：通过 Condition 中的 await()方法，能让线程阻塞 [类似于 wait()]；通过 Condition 的 signal() 方法，能唤醒线程[类似于 notify()]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.Condition;// LockTest3.java// 仓库class Depot &#123; private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 private Lock lock; // 独占锁 private Condition fullCondtion; // 生产条件 private Condition emptyCondtion; // 消费条件 public Depot(int capacity) &#123; this.capacity = capacity; this.size = 0; this.lock = new ReentrantLock(); this.fullCondtion = lock.newCondition(); this.emptyCondtion = lock.newCondition(); &#125; public void produce(int val) &#123; lock.lock(); try &#123; // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left &gt; 0) &#123; // 库存已满时，等待“消费者”消费产品。 while (size &gt;= capacity) fullCondtion.await(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)&gt;capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf("%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\n", Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 emptyCondtion.signal(); &#125; &#125; catch (InterruptedException e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; public void consume(int val) &#123; lock.lock(); try &#123; // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left &gt; 0) &#123; // 库存为0时，等待“生产者”生产产品。 while (size &lt;= 0) emptyCondtion.await(); // 获取“实际消费的数量”(即库存中实际减少的数量) // 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”； // 否则，“实际消费量”=“客户要消费的数量”。 int dec = (size&lt;left) ? size : left; size -= dec; left -= dec; System.out.printf("%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\n", Thread.currentThread().getName(), val, left, dec, size); fullCondtion.signal(); &#125; &#125; catch (InterruptedException e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; public String toString() &#123; return "capacity:"+capacity+", actual size:"+size; &#125;&#125;; // 生产者class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) &#123; new Thread() &#123; public void run() &#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;// 消费者class Customer &#123; private Depot depot; public Customer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) &#123; new Thread() &#123; public void run() &#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest3 &#123; public static void main(String[] args) &#123; Depot mDepot = new Depot(100); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); &#125;&#125; (某一次) 运行结果： 12345678910Thread-0 produce( 60) --&gt; left= 0, inc= 60, size= 60Thread-1 produce(120) --&gt; left= 80, inc= 40, size=100Thread-2 consume( 90) &lt;-- left= 0, dec= 90, size= 10Thread-3 consume(150) &lt;-- left=140, dec= 10, size= 0Thread-4 produce(110) --&gt; left= 10, inc=100, size=100Thread-3 consume(150) &lt;-- left= 40, dec=100, size= 0Thread-4 produce(110) --&gt; left= 0, inc= 10, size= 10Thread-3 consume(150) &lt;-- left= 30, dec= 10, size= 0Thread-1 produce(120) --&gt; left= 0, inc= 80, size= 80Thread-3 consume(150) &lt;-- left= 0, dec= 30, size= 50 代码中的已经包含了很详细的注释，这里就不再说明了。更多 “生产者 / 消费者模型” 的更多内容，可以参考“Java 多线程系列 –“基础篇”11 之 生产消费者问题”。而关于 Condition 的内容，在后面我们会详细介绍。 03 公平锁(一)概要本章对 “公平锁” 的获取锁机制进行介绍(本文的公平锁指的是互斥锁的公平锁)，内容包括：基本概念 ReentrantLock 数据结构参考代码获取公平锁 (基于 JDK1.7.0_40) 一. tryAcquire() 二. addWaiter() 三. acquireQueued() 四. selfInterrupt()“公平锁” 的释放锁的机制在后面一章再做介绍，锁的使用示例请参考 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock”。 基本概念本章，我们会讲解 “线程获取公平锁” 的原理；在讲解之前，需要了解几个基本概念。后面的内容，都是基于这些概念的；这些概念可能比较枯燥，但从这些概念中，能窥见 “java 锁” 的一些架构，这对我们了解锁是有帮助的。1. AQS – 指 AbstractQueuedSynchronizer 类。 AQS 是 java 中管理 “锁” 的抽象类，锁的许多公共方法都是在这个类中实现。AQS 是独占锁 (例如，ReentrantLock) 和共享锁 (例如，Semaphore) 的公共父类。 2. AQS 锁的类别 – 分为 “独占锁” 和 “共享锁” 两种。 (01) 独占锁 – 锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为 “公平锁” 和 “非公平锁”。公平锁，是按照通过 CLH 等待线程按照先来先得的规则，公平的获取锁；而非公平锁，则当线程要获取锁时，它会无视 CLH 等待队列而直接获取锁。独占锁的典型实例子是 ReentrantLock，此外，ReentrantReadWriteLock.WriteLock 也是独占锁。 (02) 共享锁 – 能被多个线程同时拥有，能被共享的锁。JUC 包中的 ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch 和 Semaphore 都是共享锁。这些锁的用途和原理，在以后的章节再详细介绍。 CLH 队列 – Craig, Landin, and Hagersten lock queue CLH 队列是 AQS 中 “等待锁” 的线程队列。在多线程中，为了保护竞争资源不被多个线程同时操作而起来错误，我们常常需要通过锁来保护这些资源。在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；而其它线程则需要等待。CLH 就是管理这些 “等待锁” 的线程的队列。 CLH 是一个非阻塞的 FIFO 队列。也就是说往里面插入或移除一个节点的时候，在并发条件下不会阻塞，而是通过自旋锁和 CAS 保证节点插入和移除的原子性。 4. CAS 函数 – Compare And Swap CAS 函数，是比较并交换函数，它是原子操作函数；即，通过 CAS 操作的数据都是以原子方式进行的。例如，compareAndSetHead(), compareAndSetTail(), compareAndSetNext() 等函数。它们共同的特点是，这些函数所执行的动作是以原子的方式进行的。 本章是围绕 “公平锁” 如何获取锁而层次展开。“公平锁”涉及到的知识点比较多，但总的来说，不是特别难；如果读者能读懂 AQS 和 ReentrantLock.java 这两个类的大致意思，理解锁的原理和机制也就不成问题了。本章只是作者本人对锁的一点点理解，希望这部分知识能帮助您了解 “公平锁” 的获取过程，认识 “锁” 的框架。 ReentrantLock 数据结构ReentrantLock 的 UML 类图 从图中可以看出：(01) ReentrantLock 实现了 Lock 接口。(02) ReentrantLock 与 sync 是组合关系。ReentrantLock 中，包含了 Sync 对象；而且，Sync 是 AQS 的子类；更重要的是，Sync 有两个子类 FairSync(公平锁) 和 NonFairSync(非公平锁)。ReentrantLock 是一个独占锁，至于它到底是公平锁还是非公平锁，就取决于 sync 对象是 “FairSync 的实例” 还是 “NonFairSync 的实例”。 参考代码下面给出 Java1.7.0_40 版本中，ReentrantLock 和 AQS 的源码，仅供参考！ ReentranLock.java ReentranLock.java源码 AQS(AbstractQueuedSynchronizer.java) AbstractQueuedSynchronizer.java源码 获取公平锁 (基于 JDK1.7.0_40)通过前面 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock”的 “示例 1”，我们知道，获取锁是通过 lock() 函数。下面，我们以 lock()对获取公平锁的过程进行展开。 1. lock() lock() 在 ReentrantLock.java 的 FairSync 类中实现，它的源码如下： 123final void lock() &#123; acquire(1);&#125; 说明：“当前线程” 实际上是通过 acquire(1) 获取锁的。 这里说明一下 “1”的含义，它是设置 “锁的状态” 的参数。对于 “独占锁” 而言，锁处于可获取状态时，它的状态值是 0；锁被线程初次获取到了，它的状态值就变成了 1。 由于 ReentrantLock(公平锁 / 非公平锁)是可重入锁，所以 “独占锁” 可以被单个线程多此获取，每获取 1 次就将锁的状态 + 1。也就是说，初次获取锁时，通过 acquire(1)将锁的状态值设为 1；再次获取锁时，将锁的状态值设为 2；依次类推… 这就是为什么获取锁时，传入的参数是 1 的原因了。 可重入就是指锁可以被单个线程多次获取。 2. acquire() acquire() 在 AQS 中实现的，它的源码如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; (01) “当前线程” 首先通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列排序等待 (前面还有可能有需要线程在等待该锁)。(02) “当前线程”尝试失败的情况下，先通过 addWaiter(Node.EXCLUSIVE)来将 “当前线程” 加入到 “CLH 队列(非阻塞的 FIFO 队列)” 末尾。CLH 队列就是线程等待队列。(03) 再执行完 addWaiter(Node.EXCLUSIVE) 之后，会调用 acquireQueued() 来获取锁。由于此时 ReentrantLock 是公平锁，它会根据公平性原则来获取锁。(04) “当前线程” 在执行 acquireQueued() 时，会进入到 CLH 队列中休眠等待，直到获取锁了才返回！如果 “当前线程” 在休眠等待过程中被中断过，acquireQueued 会返回 true，此时 “当前线程” 会调用 selfInterrupt()来自己给自己产生一个中断。至于为什么要自己给自己产生一个中断，后面再介绍。 上面是对 acquire() 的概括性说明。下面，我们将该函数分为 4 部分来逐步解析。一. tryAcquire()二. addWaiter()三. acquireQueued()四. selfInterrupt() 一. tryAcquire()1. tryAcquire() 公平锁的 tryAcquire() 在 ReentrantLock.java 的 FairSync 类中实现，源码如下： 123456789101112131415161718192021222324252627protected final boolean tryAcquire(int acquires) &#123; // 获取“当前线程” final Thread current = Thread.currentThread(); // 获取“独占锁”的状态 int c = getState(); // c=0意味着“锁没有被任何线程锁拥有”， if (c == 0) &#123; // 若“锁没有被任何线程锁拥有”， // 则判断“当前线程”是不是CLH队列中的第一个线程线程， // 若是的话，则获取该锁，设置锁的状态，并切设置锁的拥有者为“当前线程”。 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 如果“独占锁”的拥有者已经为“当前线程”， // 则将更新锁的状态。 int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 说明：根据代码，我们可以分析出，tryAcquire() 的作用就是尝试去获取锁。注意，这里只是尝试！ 尝试成功的话，返回 true；尝试失败的话，返回 false，后续再通过其它办法来获取该锁。后面我们会说明，在尝试失败的情况下，是如何一步步获取锁的。 2. hasQueuedPredecessors() hasQueuedPredecessors() 在 AQS 中实现，源码如下： 1234567public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 说明： 通过代码，能分析出，hasQueuedPredecessors() 是通过判断 “当前线程” 是不是在 CLH 队列的队首，来返回 AQS 中是不是有比 “当前线程” 等待更久的线程。下面对 head、tail 和 Node 进行说明。 3. Node 的源码 Node 就是 CLH 队列的节点。Node 在 AQS 中实现，它的数据结构如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private transient volatile Node head; // CLH队列的队首private transient volatile Node tail; // CLH队列的队尾// CLH队列的节点static final class Node &#123; static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; // 线程已被取消，对应的waitStatus的值 static final int CANCELLED = 1; // “当前线程的后继线程需要被unpark(唤醒)”，对应的waitStatus的值。 // 一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。 static final int SIGNAL = -1; // 线程(处在Condition休眠状态)在等待Condition唤醒，对应的waitStatus的值 static final int CONDITION = -2; // (共享锁)其它线程获取到“共享锁”，对应的waitStatus的值 static final int PROPAGATE = -3; // waitStatus为“CANCELLED, SIGNAL, CONDITION, PROPAGATE”时分别表示不同状态， // 若waitStatus=0，则意味着当前线程不属于上面的任何一种状态。 volatile int waitStatus; // 前一节点 volatile Node prev; // 后一节点 volatile Node next; // 节点所对应的线程 volatile Thread thread; // nextWaiter是“区别当前CLH队列是 ‘独占锁’队列 还是 ‘共享锁’队列 的标记” // 若nextWaiter=SHARED，则CLH队列是“独占锁”队列； // 若nextWaiter=EXCLUSIVE，(即nextWaiter=null)，则CLH队列是“共享锁”队列。 Node nextWaiter; // “共享锁”则返回true，“独占锁”则返回false。 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; // 返回前一节点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; // 构造函数。thread是节点所对应的线程，mode是用来表示thread的锁是“独占锁”还是“共享锁”。 Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; // 构造函数。thread是节点所对应的线程，waitStatus是线程的等待状态。 Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 说明：Node 是 CLH 队列的节点，代表 “等待锁的线程队列”。(01) 每个 Node 都会一个线程对应。(02) 每个 Node 会通过 prev 和 next 分别指向上一个节点和下一个节点，这分别代表上一个等待线程和下一个等待线程。(03) Node 通过 waitStatus 保存线程的等待状态。(04) Node 通过 nextWaiter 来区分线程是 “独占锁” 线程还是 “共享锁” 线程。如果是 “独占锁” 线程，则 nextWaiter 的值为 EXCLUSIVE；如果是 “共享锁” 线程，则 nextWaiter 的值是 SHARED。 4. compareAndSetState() compareAndSetState() 在 AQS 中实现。它的源码如下： 123protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 说明： compareAndSwapInt() 是 sun.misc.Unsafe 类中的一个本地方法。对此，我们需要了解的是 compareAndSetState(expect, update) 是以原子的方式操作当前线程；若当前线程的状态为 expect，则设置它的状态为 update。 5. setExclusiveOwnerThread() setExclusiveOwnerThread() 在 AbstractOwnableSynchronizer.java 中实现，它的源码如下： 12345// exclusiveOwnerThread是当前拥有“独占锁”的线程private transient Thread exclusiveOwnerThread;protected final void setExclusiveOwnerThread(Thread t) &#123; exclusiveOwnerThread = t;&#125; 说明：setExclusiveOwnerThread()的作用就是，设置线程 t 为当前拥有 “独占锁” 的线程。 6. getState(), setState() getState() 和 setState() 都在 AQS 中实现，源码如下： 12345678910// 锁的状态private volatile int state;// 设置锁的状态protected final void setState(int newState) &#123; state = newState;&#125;// 获取锁的状态protected final int getState() &#123; return state;&#125; 说明：state 表示锁的状态，对于 “独占锁” 而已，state=0 表示锁是可获取状态(即，锁没有被任何线程锁持有)。由于 java 中的独占锁是可重入的，state 的值可以 &gt; 1。 小结：tryAcquire()的作用就是让 “当前线程” 尝试获取锁。获取成功返回 true，失败则返回 false。 二. addWaiter(Node.EXCLUSIVE)addWaiter(Node.EXCLUSIVE)的作用是，创建 “当前线程” 的 Node 节点，且 Node 中记录 “当前线程” 对应的锁是 “独占锁” 类型，并且将该节点添加到 CLH 队列的末尾。 1.addWaiter() addWaiter() 在 AQS 中实现，源码如下： 12345678910111213141516private Node addWaiter(Node mode) &#123; // 新建一个Node节点，节点对应的线程是“当前线程”，“当前线程”的锁的模型是mode。 Node node = new Node(Thread.currentThread(), mode); Node pred = tail; // 若CLH队列不为空，则将“当前线程”添加到CLH队列末尾 if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 若CLH队列为空，则调用enq()新建CLH队列，然后再将“当前线程”添加到CLH队列中。 enq(node); return node;&#125; 说明：对于 “公平锁” 而言，addWaiter(Node.EXCLUSIVE)会首先创建一个 Node 节点，节点的类型是 “独占锁”(Node.EXCLUSIVE) 类型。然后，再将该节点添加到 CLH 队列的末尾。 2. compareAndSetTail() compareAndSetTail() 在 AQS 中实现，源码如下： 123private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update);&#125; 说明：compareAndSetTail 也属于 CAS 函数，也是通过 “本地方法” 实现的。compareAndSetTail(expect, update)会以原子的方式进行操作，它的作用是判断 CLH 队列的队尾是不是为 expect，是的话，就将队尾设为 update。 3. enq() enq() 在 AQS 中实现，源码如下： 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 说明： enq() 的作用很简单。如果 CLH 队列为空，则新建一个 CLH 表头；然后将 node 添加到 CLH 末尾。否则，直接将 node 添加到 CLH 末尾。 小结：addWaiter()的作用，就是将当前线程添加到 CLH 队列中。这就意味着将当前线程添加到等待获取 “锁” 的等待线程队列中了。 三. acquireQueued()前面，我们已经将当前线程添加到 CLH 队列中了。而 acquireQueued() 的作用就是逐步的去执行 CLH 队列的线程，如果当前线程获取到了锁，则返回；否则，当前线程进行休眠，直到唤醒并重新获取锁了才返回。下面，我们看看 acquireQueued() 的具体流程。 1. acquireQueued() acquireQueued() 在 AQS 中实现，源码如下： 12345678910111213141516171819202122232425final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; // interrupted表示在CLH队列的调度中， // “当前线程”在休眠时，有没有被中断过。 boolean interrupted = false; for (;;) &#123; // 获取上一个节点。 // node是“当前线程”对应的节点，这里就意味着“获取上一个等待锁的线程”。 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：acquireQueued() 的目的是从队列中获取锁。 2. shouldParkAfterFailedAcquire() shouldParkAfterFailedAcquire() 在 AQS 中实现，源码如下： 12345678910111213141516171819// 返回“当前线程是否应该阻塞”private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 前继节点的状态 int ws = pred.waitStatus; // 如果前继节点是SIGNAL状态，则意味这当前线程需要被unpark唤醒。此时，返回true。 if (ws == Node.SIGNAL) return true; // 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点’的前继节点”。 if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 说明：(01) 关于 waitStatus 请参考下表 (中扩号内为 waitStatus 的值)，更多关于 waitStatus 的内容，可以参考前面的 Node 类的介绍。 CANCELLED[1] – 当前线程已被取消SIGNAL[-1] – “当前线程的后继线程需要被unpark(唤醒)”。一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。CONDITION[-2] – 当前线程(处在Condition休眠状态)在等待Condition唤醒PROPAGATE[-3] – (共享锁)其它线程获取到“共享锁”[0] – 当前线程不属于上面的任何一种状态。 (02) shouldParkAfterFailedAcquire()通过以下规则，判断 “当前线程” 是否需要被阻塞。 规则1：如果前继节点状态为SIGNAL，表明当前节点需要被unpark(唤醒)，此时则返回true。规则2：如果前继节点状态为CANCELLED(ws&gt;0)，说明前继节点已经被取消，则通过先前回溯找到一个有效(非CANCELLED状态)的节点，并返回false。规则3：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，并返回false。 如果 “规则 1” 发生，即 “前继节点是 SIGNAL” 状态，则意味着 “当前线程” 需要被阻塞。接下来会调用 parkAndCheckInterrupt()阻塞当前线程，直到当前先被唤醒才从 parkAndCheckInterrupt()中返回。 3. parkAndCheckInterrupt()) parkAndCheckInterrupt() 在 AQS 中实现，源码如下： 123456private final boolean parkAndCheckInterrupt() &#123; // 通过LockSupport的park()阻塞“当前线程”。 LockSupport.park(this); // 返回线程的中断状态。 return Thread.interrupted();&#125; 说明：parkAndCheckInterrupt()的作用是阻塞当前线程，并且返回 “线程被唤醒之后” 的中断状态。它会先通过 LockSupport.park()阻塞 “当前线程”，然后通过 Thread.interrupted() 返回线程的中断状态。 这里介绍一下线程被阻塞之后如何唤醒。一般有 2 种情况：第 1 种情况：unpark() 唤醒。“前继节点对应的线程” 使用完锁之后，通过 unpark() 方式唤醒当前线程。第 2 种情况：中断唤醒。其它线程通过 interrupt() 中断当前线程。 补充：LockSupport() 中的 park(),unpark() 的作用 和 Object 中的 wait(),notify() 作用类似，是阻塞 / 唤醒。它们的用法不同，park(),unpark() 是轻量级的，而 wait(),notify() 是必须先通过 Synchronized 获取同步锁。关于 LockSupport，我们会在之后的章节再专门进行介绍！ 4. 再次 tryAcquire() 了解了 shouldParkAfterFailedAcquire() 和 parkAndCheckInterrupt() 函数之后。我们接着分析 acquireQueued() 的 for 循环部分。 1234567final Node p = node.predecessor();if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted;&#125; 说明：(01) 通过 node.predecessor() 获取前继节点。predecessor() 就是返回 node 的前继节点，若对此有疑惑可以查看下面关于 Node 类的介绍。(02) p == head &amp;&amp; tryAcquire(arg) 首先，判断 “前继节点” 是不是 CHL 表头。如果是的话，则通过 tryAcquire()尝试获取锁。 其实，这样做的目的是为了 “让当前线程获取锁”，但是为什么需要先判断 p==head 呢？理解这个对理解“公平锁” 的机制很重要，因为这么做的原因就是为了保证公平性！ (a) 前面，我们在 shouldParkAfterFailedAcquire()我们判断 “当前线程” 是否需要阻塞； (b) 接着，“当前线程”阻塞的话，会调用 parkAndCheckInterrupt()来阻塞线程。当线程被解除阻塞的时候，我们会返回线程的中断状态。而线程被解决阻塞，可能是由于 “线程被中断”，也可能是由于“其它线程调用了该线程的 unpark() 函数”。 (c) 再回到 p==head 这里。如果当前线程是因为其它线程调用了 unpark()函数而被唤醒，那么唤醒它的线程，应该是它的前继节点所对应的线程 (关于这一点，后面在“释放锁” 的过程中会看到)。 OK，是前继节点调用 unpark()唤醒了当前线程！ 此时，再来理解 p==head 就很简单了：当前继节点是 CLH 队列的头节点，并且它释放锁之后；就轮到当前节点获取锁了。然后，当前节点通过 tryAcquire() 获取锁；获取成功的话，通过 setHead(node) 设置当前节点为头节点，并返回。 总之，如果 “前继节点调用 unpark() 唤醒了当前线程”并且 “前继节点是 CLH 表头”，此时就是满足 p==head，也就是符合公平性原则的。否则，如果当前线程是因为“线程被中断” 而唤醒，那么显然就不是公平了。这就是为什么说 p==head 就是保证公平性！ 小结：acquireQueued()的作用就是 “当前线程” 会根据公平性原则进行阻塞等待，直到获取锁为止；并且返回当前线程在等待过程中有没有并中断过。 四. selfInterrupt()selfInterrupt() 是 AQS 中实现，源码如下： 123private static void selfInterrupt() &#123; Thread.currentThread().interrupt();&#125; 说明：selfInterrupt()的代码很简单，就是 “当前线程” 自己产生一个中断。但是，为什么需要这么做呢？这必须结合 acquireQueued() 进行分析。如果在 acquireQueued() 中，当前线程被中断过，则执行 selfInterrupt()；否则不会执行。 在 acquireQueued() 中，即使是线程在阻塞状态被中断唤醒而获取到 cpu 执行权利；但是，如果该线程的前面还有其它等待锁的线程，根据公平性原则，该线程依然无法获取到锁。它会再次阻塞！ 该线程再次阻塞，直到该线程被它的前面等待锁的线程锁唤醒；线程才会获取锁，然后 “真正执行起来”！也就是说，在该线程 “成功获取锁并真正执行起来” 之前，它的中断会被忽略并且中断标记会被清除！ 因为在 parkAndCheckInterrupt()中，我们线程的中断状态时调用了 Thread.interrupted()。该函数不同于 Thread 的 isInterrupted()函数，isInterrupted()仅仅返回中断状态，而 interrupted()在返回当前中断状态之后，还会清除中断状态。 正因为之前的中断状态被清除了，所以这里需要调用 selfInterrupt()重新产生一个中断！ 小结：selfInterrupt() 的作用就是当前线程自己产生一个中断。 总结 再回过头看看 acquire() 函数，它最终的目的是获取锁！ 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; (01) 先是通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，再通过 acquireQueued() 获取锁。(02) 尝试失败的情况下，会先通过 addWaiter()来将 “当前线程” 加入到 “CLH 队列” 末尾；然后调用 acquireQueued()，在 CLH 队列中排序等待获取锁，在此过程中，线程处于休眠状态。直到获取锁了才返回。 如果在休眠等待过程中被中断过，则调用 selfInterrupt()来自己产生一个中断。 04 公平锁(二)概要前面一章，我们学习了 “公平锁” 获取锁的详细流程；这里，我们再来看看 “公平锁” 释放锁的过程。内容包括：释放公平锁 (基于 JDK1.7.0_40)“公平锁” 的获取过程请参考 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)”，锁的使用示例请参考 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock”。注意：(01) 这里是以 “公平锁” 来进行说明。(02) 关于本章的术语，如 “AQS”，“CAS 函数”，“CLH 队列”，“公平锁”，“非公平锁”，“独占锁”，“共享锁” 等内容，请参考 Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) 的基本概念。 释放公平锁 (基于 JDK1.7.0_40)1. unlock() unlock() 在 ReentrantLock.java 中实现的，源码如下： 123public void unlock() &#123; sync.release(1);&#125; 说明：unlock() 是解锁函数，它是通过 AQS 的 release() 函数来实现的。在这里，“1”的含义和 “获取锁的函数 acquire(1) 的含义”一样，它是设置 “释放锁的状态” 的参数。由于 “公平锁” 是可重入的，所以对于同一个线程，每释放锁一次，锁的状态 - 1。 关于 AQS, ReentrantLock 和 sync 的关系如下： 12345678910public class ReentrantLock implements Lock, java.io.Serializable &#123; private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer &#123; ... &#125; ...&#125; 从中，我们发现：sync 是 ReentrantLock.java 中的成员对象，而 Sync 是 AQS 的子类。 2. release() release() 在 AQS 中实现的，源码如下： 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 说明：release() 会先调用 tryRelease() 来尝试释放当前线程锁持有的锁。成功的话，则唤醒后继等待线程，并返回 true。否则，直接返回 false。 3. tryRelease() tryRelease() 在 ReentrantLock.java 的 Sync 类中实现，源码如下： 1234567891011121314151617protected final boolean tryRelease(int releases) &#123; // c是本次释放锁之后的状态 int c = getState() - releases; // 如果“当前线程”不是“锁的持有者”，则抛出异常！ if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 如果“锁”已经被当前线程彻底释放，则设置“锁”的持有者为null，即锁是可获取状态。 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; // 设置当前线程的锁的状态。 setState(c); return free;&#125; 说明：tryRelease() 的作用是尝试释放锁。(01) 如果 “当前线程” 不是“锁的持有者”，则抛出异常。(02) 如果 “当前线程” 在本次释放锁操作之后，对锁的拥有状态是 0(即，当前线程彻底释放该 “锁”)，则设置“锁” 的持有者为 null，即锁是可获取状态。同时，更新当前线程的锁的状态为 0。getState(), setState() 在前一章已经介绍过，这里不再说明。getExclusiveOwnerThread(), setExclusiveOwnerThread() 在 AQS 的父类 AbstractOwnableSynchronizer.java 中定义，源码如下： 123456789101112131415161718public abstract class AbstractOwnableSynchronizer implements java.io.Serializable &#123; // “锁”的持有线程 private transient Thread exclusiveOwnerThread; // 设置“锁的持有线程”为t protected final void setExclusiveOwnerThread(Thread t) &#123; exclusiveOwnerThread = t; &#125; // 获取“锁的持有线程” protected final Thread getExclusiveOwnerThread() &#123; return exclusiveOwnerThread; &#125; ...&#125; 4. unparkSuccessor() 在 release()中 “当前线程” 释放锁成功的话，会唤醒当前线程的后继线程。根据 CLH 队列的 FIFO 规则，“当前线程”(即已经获取锁的线程) 肯定是 head；如果 CLH 队列非空的话，则唤醒锁的下一个等待线程。下面看看 unparkSuccessor() 的源码，它在 AQS 中实现。 1234567891011121314151617181920private void unparkSuccessor(Node node) &#123; // 获取当前线程的状态 int ws = node.waitStatus; // 如果状态&lt;0，则设置状态=0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); //获取当前节点的“有效的后继节点”，无效的话，则通过for循环进行获取。 // 这里的有效，是指“后继节点对应的线程状态&lt;=0” Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; // 唤醒“后继节点对应的线程” if (s != null) LockSupport.unpark(s.thread);&#125; 说明：unparkSuccessor() 的作用是 “唤醒当前线程的后继线程”。后继线程被唤醒之后，就可以获取该锁并恢复运行了。关于 node.waitStatus 的说明，请参考 “上一章关于 Node 类的介绍”。 总结 “释放锁”的过程相对 “获取锁” 的过程比较简单。释放锁时，主要进行的操作，是更新当前线程对应的锁的状态。如果当前线程对锁已经彻底释放，则设置 “锁” 的持有线程为 null，设置当前线程的状态为空，然后唤醒后继线程。 05 非公平锁概要前面两章分析了 “公平锁的获取和释放机制”，这一章开始对 “非公平锁” 的获取锁 / 释放锁的过程进行分析。内容包括：获取非公平锁 (基于 JDK1.7.0_40)释放非公平锁 (基于 JDK1.7.0_40)关于锁的数据结构请参考 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) “，锁的使用示例请参考 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock”。 获取非公平锁 (基于 JDK1.7.0_40)非公平锁和公平锁在获取锁的方法上，流程是一样的；它们的区别主要表现在 “尝试获取锁的机制不同”。简单点说，“公平锁” 在每次尝试获取锁时，都是采用公平策略 (根据等待队列依次排序等待)；而“非公平锁” 在每次尝试获取锁时，都是采用的非公平策略(无视等待队列，直接尝试获取锁，如果锁是空闲的，即可获取状态，则获取锁)。在前面的 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)” 中，已经详细介绍了获取公平锁的流程和机制；下面，通过代码分析以下获取非公平锁的流程。 1. lock() lock() 在 ReentrantLock.java 的 NonfairSync 类中实现，它的源码如下： 123456final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 说明：lock()会先通过 compareAndSet(0, 1)来判断 “锁” 是不是空闲状态。是的话，“当前线程”直接获取 “锁”；否则的话，调用 acquire(1) 获取锁。(01) compareAndSetState() 是 CAS 函数，它的作用是比较并设置当前锁的状态。若锁的状态值为 0，则设置锁的状态值为 1。(02) setExclusiveOwnerThread(Thread.currentThread())的作用是，设置 “当前线程” 为“锁”的持有者。 “公平锁”和 “非公平锁” 关于 lock()的对比 公平锁 – 公平锁的lock()函数，会直接调用acquire(1)。非公平锁 – 非公平锁会先判断当前锁的状态是不是空闲，是的话，就不排队，而是直接获取锁。 2. acquire() acquire() 在 AQS 中实现的，它的源码如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; (01) “当前线程” 首先通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列依次排序，然后获取锁。(02) “当前线程”尝试失败的情况下，会先通过 addWaiter(Node.EXCLUSIVE)来将 “当前线程” 加入到 “CLH 队列(非阻塞的 FIFO 队列)” 末尾。(03) 然后，调用 acquireQueued()获取锁。在 acquireQueued()中，当前线程会等待它在 “CLH 队列” 中前面的所有线程执行并释放锁之后，才能获取锁并返回。如果 “当前线程” 在休眠等待过程中被中断过，则调用 selfInterrupt()来自己产生一个中断。 “公平锁”和 “非公平锁” 关于 acquire()的对比 公平锁和非公平锁，只有 tryAcquire() 函数的实现不同；即它们尝试获取锁的机制不同。这就是我们所说的 “它们获取锁策略的不同所在之处”！在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)” 中，已经详细介绍了 acquire() 涉及到的各个函数。这里仅对它们有差异的函数 tryAcquire() 进行说明。 非公平锁的 tryAcquire() 在 ReentrantLock.java 的 NonfairSync 类中实现，源码如下： 123protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125; nonfairTryAcquire() 在 ReentrantLock.java 的 Sync 类中实现，源码如下： 12345678910111213141516171819202122232425final boolean nonfairTryAcquire(int acquires) &#123; // 获取“当前线程” final Thread current = Thread.currentThread(); // 获取“锁”的状态 int c = getState(); // c=0意味着“锁没有被任何线程锁拥有” if (c == 0) &#123; // 若“锁没有被任何线程锁拥有”，则通过CAS函数设置“锁”的状态为acquires。 // 同时，设置“当前线程”为锁的持有者。 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 如果“锁”的持有者已经是“当前线程”， // 则将更新锁的状态。 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 说明：根据代码，我们可以分析出，tryAcquire() 的作用就是尝试去获取锁。(01) 如果 “锁” 没有被任何线程拥有，则通过 CAS 函数设置 “锁” 的状态为 acquires，同时，设置 “当前线程” 为锁的持有者，然后返回 true。(02) 如果 “锁” 的持有者已经是当前线程，则将更新锁的状态即可。(03) 如果不术语上面的两种情况，则认为尝试失败。 “公平锁”和 “非公平锁” 关于 tryAcquire()的对比 公平锁和非公平锁，它们尝试获取锁的方式不同。公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。而非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。 释放非公平锁 (基于 JDK1.7.0_40)非公平锁和公平锁在释放锁的方法和策略上是一样的。而在前面的 “Java 多线程系列 –“JUC 锁”04 之 公平锁 (二) ”中，已经对 “释放公平锁” 进行了介绍；这里就不再重复的进行说明。 总结公平锁和非公平锁的区别，是在获取锁的机制上的区别。表现在，在尝试获取锁时 —— 公平锁，只有在当前线程是 CLH 等待队列的表头时，才获取锁；而非公平锁，只要当前锁处于空闲状态，则直接获取锁，而不管 CLH 等待队列中的顺序。只有当非公平锁尝试获取锁失败的时候，它才会像公平锁一样，进入 CLH 等待队列排序等待。 06 Condition条件概要前面对 JUC 包中的锁的原理进行了介绍，本章会 JUC 中对与锁经常配合使用的 Condition 进行介绍，内容包括:Condition 介绍Condition 函数列表Condition 示例 Condition 介绍Condition 的作用是对锁进行更精确的控制。Condition 中的 await() 方法相当于 Object 的 wait() 方法，Condition 中的 signal() 方法相当于 Object 的 notify() 方法，Condition 中的 signalAll() 相当于 Object 的 notifyAll() 方法。不同的是，Object 中的 wait(),notify(),notifyAll() 方法是和 “同步锁”(synchronized 关键字) 捆绑使用的；而 Condition 是需要与 “互斥锁”/“共享锁” 捆绑使用的。 Condition 函数列表1234567891011121314// 造成当前线程在接到信号或被中断之前一直处于等待状态。void await()// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。boolean await(long time, TimeUnit unit)// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。long awaitNanos(long nanosTimeout)// 造成当前线程在接到信号之前一直处于等待状态。void awaitUninterruptibly()// 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。boolean awaitUntil(Date deadline)// 唤醒一个等待线程。void signal()// 唤醒所有等待线程。void signalAll() Condition 示例示例 1 是通过 Object 的 wait(), notify() 来演示线程的休眠 / 唤醒功能。示例 2 是通过 Condition 的 await(), signal() 来演示线程的休眠 / 唤醒功能。示例 3 是通过 Condition 的高级功能。 示例 1 1234567891011121314151617181920212223242526272829303132333435public class WaitTest1 &#123; public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); synchronized(ta) &#123; // 通过synchronized(ta)获取“对象ta的同步锁” try &#123; System.out.println(Thread.currentThread().getName()+" start ta"); ta.start(); System.out.println(Thread.currentThread().getName()+" block"); ta.wait(); // 等待 System.out.println(Thread.currentThread().getName()+" continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; synchronized (this) &#123; // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+" wakup others"); notify(); // 唤醒“当前对象上的等待线程” &#125; &#125; &#125;&#125; 示例 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ConditionTest1 &#123; private static Lock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); lock.lock(); // 获取锁 try &#123; System.out.println(Thread.currentThread().getName()+" start ta"); ta.start(); System.out.println(Thread.currentThread().getName()+" block"); condition.await(); // 等待 System.out.println(Thread.currentThread().getName()+" continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; lock.lock(); // 获取锁 try &#123; System.out.println(Thread.currentThread().getName()+" wakup others"); condition.signal(); // 唤醒“condition所在锁上的其它线程” &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; &#125;&#125; 运行结果： 1234main start tamain blockta wakup othersmain continue 通过 “示例 1” 和“示例 2”，我们知道 Condition 和 Object 的方法有一下对应关系： 情况 Object Condition 休眠 wait await 唤醒某个线程 notify signal 唤醒所有线程 notifyAll signalAll Condition 除了支持上面的功能之外，它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个 Condition，在不同的情况下使用不同的 Condition。例如，假如多线程读 / 写同一个缓冲区：当向缓冲区中写入数据之后，唤醒 “读线程”；当从缓冲区读出数据之后，唤醒 “写线程”；并且当缓冲区满的时候，”写线程” 需要等待；当缓冲区为空时，”读线程” 需要等待。 如果采用 Object 类中的 wait(), notify(), notifyAll() 实现该缓冲区，当向缓冲区写入数据之后需要唤醒 “读线程” 时，不可能通过 notify() 或 notifyAll() 明确的指定唤醒 “读线程”，而只能通过 notifyAll 唤醒所有线程 (但是 notifyAll 无法区分唤醒的线程是读线程，还是写线程)。 但是，通过 Condition，就能明确的指定唤醒读线程。看看下面的示例 3，可能对这个概念有更深刻的理解。 示例 3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[5]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); //获取锁 try &#123; // 如果“缓冲已满”，则等待；直到“缓冲”不是满的，才将x添加到缓冲中。 while (count == items.length) notFull.await(); // 将x添加到缓冲中 items[putptr] = x; // 将“put统计数putptr+1”；如果“缓冲已满”，则设putptr为0。 if (++putptr == items.length) putptr = 0; // 将“缓冲”数量+1 ++count; // 唤醒take线程，因为take线程通过notEmpty.await()等待 notEmpty.signal(); // 打印写入的数据 System.out.println(Thread.currentThread().getName() + " put "+ (Integer)x); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); //获取锁 try &#123; // 如果“缓冲为空”，则等待；直到“缓冲”不为空，才将x从缓冲中取出。 while (count == 0) notEmpty.await(); // 将x从缓冲中取出 Object x = items[takeptr]; // 将“take统计数takeptr+1”；如果“缓冲为空”，则设takeptr为0。 if (++takeptr == items.length) takeptr = 0; // 将“缓冲”数量-1 --count; // 唤醒put线程，因为put线程通过notFull.await()等待 notFull.signal(); // 打印取出的数据 System.out.println(Thread.currentThread().getName() + " take "+ (Integer)x); return x; &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; &#125;public class ConditionTest2 &#123; private static BoundedBuffer bb = new BoundedBuffer(); public static void main(String[] args) &#123; // 启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)； // 启动10个“读线程”，从BoundedBuffer中不断的读数据。 for (int i=0; i&lt;10; i++) &#123; new PutThread("p"+i, i).start(); new TakeThread("t"+i).start(); &#125; &#125; static class PutThread extends Thread &#123; private int num; public PutThread(String name, int num) &#123; super(name); this.num = num; &#125; public void run() &#123; try &#123; Thread.sleep(1); // 线程休眠1ms bb.put(num); // 向BoundedBuffer中写入数据 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; static class TakeThread extends Thread &#123; public TakeThread(String name) &#123; super(name); &#125; public void run() &#123; try &#123; Thread.sleep(10); // 线程休眠1ms Integer num = (Integer)bb.take(); // 从BoundedBuffer中取出数据 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; (某一次) 运行结果： 1234567891011121314151617181920p1 put 1p4 put 4p5 put 5p0 put 0p2 put 2t0 take 1p3 put 3t1 take 4p6 put 6t2 take 5p7 put 7t3 take 0p8 put 8t4 take 2p9 put 9t5 take 3t6 take 6t7 take 7t8 take 8t9 take 9 结果说明：(01) BoundedBuffer 是容量为 5 的缓冲，缓冲中存储的是 Object 对象，支持多线程的读 / 写缓冲。多个线程操作 “一个 BoundedBuffer 对象” 时，它们通过互斥锁 lock 对缓冲区 items 进行互斥访问；而且同一个 BoundedBuffer 对象下的全部线程共用 “notFull” 和“notEmpty”这两个 Condition。 notFull 用于控制写缓冲，notEmpty 用于控制读缓冲。当缓冲已满的时候，调用 put 的线程会执行 notFull.await() 进行等待；当缓冲区不是满的状态时，就将对象添加到缓冲区并将缓冲区的容量 count+1，最后，调用 notEmpty.signal() 缓冲 notEmpty 上的等待线程 (调用 notEmpty.await 的线程)。 简言之，notFull 控制 “缓冲区的写入”，当往缓冲区写入数据之后会唤醒 notEmpty 上的等待线程。 同理，notEmpty 控制 “缓冲区的读取”，当读取了缓冲区数据之后会唤醒 notFull 上的等待线程。(02) 在 ConditionTest2 的 main 函数中，启动 10 个 “写线程”，向 BoundedBuffer 中不断的写数据 (写入 0-9)；同时，也启动 10 个 “读线程”，从 BoundedBuffer 中不断的读数据。(03) 简单分析一下运行结果。 12345678910111, p1线程向缓冲中写入1。 此时，缓冲区数据: | 1 | | | | |2, p4线程向缓冲中写入4。 此时，缓冲区数据: | 1 | 4 | | | |3, p5线程向缓冲中写入5。 此时，缓冲区数据: | 1 | 4 | 5 | | |4, p0线程向缓冲中写入0。 此时，缓冲区数据: | 1 | 4 | 5 | 0 | |5, p2线程向缓冲中写入2。 此时，缓冲区数据: | 1 | 4 | 5 | 0 | 2 |此时，缓冲区容量为5；缓冲区已满！如果此时，还有“写线程”想往缓冲中写入数据，会调用put中的notFull.await()等待，直接缓冲区非满状态，才能继续运行。6, t0线程从缓冲中取出数据1。此时，缓冲区数据: | | 4 | 5 | 0 | 2 |7, p3线程向缓冲中写入3。 此时，缓冲区数据: | 3 | 4 | 5 | 0 | 2 |8, t1线程从缓冲中取出数据4。此时，缓冲区数据: | 3 | | 5 | 0 | 2 |9, p6线程向缓冲中写入6。 此时，缓冲区数据: | 3 | 6 | 5 | 0 | 2 |... 07 LockSupport概述本章介绍 JUC(java.util.concurrent) 包中的 LockSupport。内容包括：LockSupport 介绍LockSupport 函数列表LockSupport 参考代码 (基于 JDK1.7.0_40)LockSupport 示例 LockSupport 介绍LockSupport 是用来创建锁和其他同步类的基本线程阻塞原语。LockSupport 中的 park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，而且 park()和 unpark()不会遇到 “Thread.suspend 和 Thread.resume 所可能引发的死锁” 问题。因为 park() 和 unpark() 有许可的存在；调用 park() 的线程和另一个试图将其 unpark() 的线程之间的竞争将保持活性。 LockSupport 函数列表12345678910111213141516// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。static Object getBlocker(Thread t)// 为了线程调度，禁用当前线程，除非许可可用。static void park()// 为了线程调度，在许可可用之前禁用当前线程。static void park(Object blocker)// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。static void parkNanos(long nanos)// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。static void parkNanos(Object blocker, long nanos)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(long deadline)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(Object blocker, long deadline)// 如果给定线程的许可尚不可用，则使其可用。static void unpark(Thread thread) LockSupport 参考代码 (基于 JDK1.7.0_40)LockSupport.java源码 说明：LockSupport 是通过调用 Unsafe 函数中的接口实现阻塞和解除阻塞的。 LockSupport 示例对比下面的 “示例 1” 和“示例 2”可以更清晰的了解 LockSupport 的用法。 示例 1 123456789101112131415161718192021222324252627282930313233343536public class WaitTest1 &#123; public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); synchronized(ta) &#123; // 通过synchronized(ta)获取“对象ta的同步锁” try &#123; System.out.println(Thread.currentThread().getName()+" start ta"); ta.start(); System.out.println(Thread.currentThread().getName()+" block"); // 主线程等待 ta.wait(); System.out.println(Thread.currentThread().getName()+" continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; synchronized (this) &#123; // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+" wakup others"); notify(); // 唤醒“当前对象上的等待线程” &#125; &#125; &#125;&#125; 示例 2 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.locks.LockSupport;public class LockSupportTest1 &#123; private static Thread mainThread; public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); // 获取主线程 mainThread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+" start ta"); ta.start(); System.out.println(Thread.currentThread().getName()+" block"); // 主线程阻塞 LockSupport.park(mainThread); System.out.println(Thread.currentThread().getName()+" continue"); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; System.out.println(Thread.currentThread().getName()+" wakup others"); // 唤醒“主线程” LockSupport.unpark(mainThread); &#125; &#125;&#125; 运行结果： 1234main start tamain blockta wakup othersmain continue 说明：park 和 wait 的区别。wait 让线程阻塞前，必须通过 synchronized 获取同步锁。 08 共享锁和ReentrantReadWriteLock概要Java 的 JUC(java.util.concurrent) 包中的锁包括 “独占锁” 和 “共享锁”。在 “Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock ”中，对 Java 的独占锁进行了说明。本章对 Java 的 “共享锁” 进行介绍，JUC 中的共享锁有 CountDownLatch, CyclicBarrier, Semaphore, ReentrantReadWriteLock 等；本章会以 ReentrantReadWriteLock 为蓝本对共享锁进行说明。内容包括：ReadWriteLock 和 ReentrantReadWriteLock 介绍ReadWriteLock 和 ReentrantReadWriteLock 函数列表 ReentrantReadWriteLock 数据结构参考代码 (基于 JDK1.7.0_40) 获取共享锁 释放共享锁 公平共享锁和非公平共享锁ReentrantReadWriteLock 示例 ReadWriteLock 和 ReentrantReadWriteLock 介绍ReadWriteLock，顾名思义，是读写锁。它维护了一对相关的锁 — — “读取锁” 和 “写入锁”，一个用于读取操作，另一个用于写入操作。“读取锁” 用于只读操作，它是 “共享锁”，能同时被多个线程获取。“写入锁” 用于写入操作，它是 “独占锁”，写入锁只能被一个线程锁获取。注意：不能同时存在读取锁和写入锁！ReadWriteLock 是一个接口。ReentrantReadWriteLock 是它的实现类，ReentrantReadWriteLock 包括子类 ReadLock 和 WriteLock。 ReadWriteLock 和 ReentrantReadWriteLock 函数列表ReadWriteLock 函数列表 1234// 返回用于读取操作的锁。Lock readLock()// 返回用于写入操作的锁。Lock writeLock() ReentrantReadWriteLock 函数列表 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个新的 ReentrantReadWriteLock，默认是采用“非公平策略”。ReentrantReadWriteLock()// 创建一个新的 ReentrantReadWriteLock，fair是“公平策略”。fair为true，意味着公平策略；否则，意味着非公平策略。ReentrantReadWriteLock(boolean fair)// 返回当前拥有写入锁的线程，如果没有这样的线程，则返回 null。protected Thread getOwner()// 返回一个 collection，它包含可能正在等待获取读取锁的线程。protected Collection&lt;Thread&gt; getQueuedReaderThreads()// 返回一个 collection，它包含可能正在等待获取读取或写入锁的线程。protected Collection&lt;Thread&gt; getQueuedThreads()// 返回一个 collection，它包含可能正在等待获取写入锁的线程。protected Collection&lt;Thread&gt; getQueuedWriterThreads()// 返回等待获取读取或写入锁的线程估计数目。int getQueueLength()// 查询当前线程在此锁上保持的重入读取锁数量。int getReadHoldCount()// 查询为此锁保持的读取锁数量。int getReadLockCount()// 返回一个 collection，它包含可能正在等待与写入锁相关的给定条件的那些线程。protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition)// 返回正等待与写入锁相关的给定条件的线程估计数目。int getWaitQueueLength(Condition condition)// 查询当前线程在此锁上保持的重入写入锁数量。int getWriteHoldCount()// 查询是否给定线程正在等待获取读取或写入锁。boolean hasQueuedThread(Thread thread)// 查询是否所有的线程正在等待获取读取或写入锁。boolean hasQueuedThreads()// 查询是否有些线程正在等待与写入锁有关的给定条件。boolean hasWaiters(Condition condition)// 如果此锁将公平性设置为 ture，则返回 true。boolean isFair()// 查询是否某个线程保持了写入锁。boolean isWriteLocked()// 查询当前线程是否保持了写入锁。boolean isWriteLockedByCurrentThread()// 返回用于读取操作的锁。ReentrantReadWriteLock.ReadLock readLock()// 返回用于写入操作的锁。ReentrantReadWriteLock.WriteLock writeLock() ReentrantReadWriteLock 数据结构ReentrantReadWriteLock 的 UML 类图如下： 从中可以看出： (01) ReentrantReadWriteLock 实现了 ReadWriteLock 接口。ReadWriteLock 是一个读写锁的接口，提供了 “获取读锁的 readLock() 函数” 和 “获取写锁的 writeLock() 函数”。(02) ReentrantReadWriteLock 中包含：sync 对象，读锁 readerLock 和写锁 writerLock。读锁 ReadLock 和写锁 WriteLock 都实现了 Lock 接口。读锁 ReadLock 和写锁 WriteLock 中也都分别包含了 “Sync 对象”，它们的 Sync 对象和 ReentrantReadWriteLock 的 Sync 对象 是一样的，就是通过 sync，读锁和写锁实现了对同一个对象的访问。(03) 和 “ReentrantLock” 一样，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平锁”FairSync 和 “非公平锁”NonfairSync。sync 对象是 “FairSync” 和 “NonfairSync” 中的一个，默认是 “NonfairSync”。 参考代码 (基于 JDK1.7.0_40)ReentrantReadWriteLock 的完整源码 ReentrantReadWriteLock.java源码 其中，共享锁源码相关的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class ReadLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = -5992448646407690164L; // ReentrantReadWriteLock的AQS对象 private final Sync sync; protected ReadLock(ReentrantReadWriteLock lock) &#123; sync = lock.sync; &#125; // 获取“共享锁” public void lock() &#123; sync.acquireShared(1); &#125; // 如果线程是中断状态，则抛出一场，否则尝试获取共享锁。 public void lockInterruptibly() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; // 尝试获取“共享锁” public boolean tryLock() &#123; return sync.tryReadLock(); &#125; // 在指定时间内，尝试获取“共享锁” public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; // 释放“共享锁” public void unlock() &#123; sync.releaseShared(1); &#125; // 新建条件 public Condition newCondition() &#123; throw new UnsupportedOperationException(); &#125; public String toString() &#123; int r = sync.getReadLockCount(); return super.toString() + "[Read locks = " + r + "]"; &#125;&#125; 说明：ReadLock 中的 sync 是一个 Sync 对象，Sync 继承于 AQS 类，即 Sync 就是一个锁。ReentrantReadWriteLock 中也有一个 Sync 对象，而且 ReadLock 中的 sync 和 ReentrantReadWriteLock 中的 sync 是对应关系。即 ReentrantReadWriteLock 和 ReadLock 共享同一个 AQS 对象，共享同一把锁。ReentrantReadWriteLock 中 Sync 的定义如下： final Sync sync; 下面，分别从 “获取共享锁” 和“释放共享锁”两个方面对共享锁进行说明。 获取共享锁获取共享锁的思想 (即 lock 函数的步骤)，是先通过 tryAcquireShared() 尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过 doAcquireShared()不断的循环并尝试获取锁，若有需要，则阻塞等待。doAcquireShared()在循环中每次尝试获取锁时，都是通过 tryAcquireShared()来进行尝试的。下面看看 “获取共享锁” 的详细流程。 1. lock() lock() 在 ReadLock 中，源码如下： 123public void lock() &#123; sync.acquireShared(1);&#125; 2. acquireShared() Sync 继承于 AQS，acquireShared() 定义在 AQS 中。源码如下： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 说明：acquireShared() 首先会通过 tryAcquireShared() 来尝试获取锁。尝试成功的话，则不再做任何动作 (因为已经成功获取到锁了)。尝试失败的话，则通过 doAcquireShared() 来获取锁。doAcquireShared() 会获取到锁了才返回。 3. tryAcquireShared() tryAcquireShared() 定义在 ReentrantReadWriteLock.java 的 Sync 中，源码如下： 123456789101112131415161718192021222324252627282930313233343536protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); // 获取“锁”的状态 int c = getState(); // 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取“读取锁”的共享计数 int r = sharedCount(c); // 如果“不需要阻塞等待”，并且“读取锁”的共享计数小于MAX_COUNT； // 则通过CAS函数更新“锁的状态”，将“读取锁”的共享计数+1。 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; // 第1次获取“读取锁”。 if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程 &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; // HoldCounter是用来统计该线程获取“读取锁”的次数。 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); // 将该线程获取“读取锁”的次数+1。 rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 说明：tryAcquireShared() 的作用是尝试获取 “共享锁”。如果在尝试获取锁时，“不需要阻塞等待” 并且 “读取锁的共享计数小于 MAX_COUNT”，则直接通过 CAS 函数更新 “读取锁的共享计数”，以及将 “当前线程获取读取锁的次数 + 1”。否则，通过 fullTryAcquireShared() 获取读取锁。 4. fullTryAcquireShared() fullTryAcquireShared() 在 ReentrantReadWriteLock 中定义，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758final int fullTryAcquireShared(Thread current) &#123; HoldCounter rh = null; for (;;) &#123; // 获取“锁”的状态 int c = getState(); // 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。 if (exclusiveCount(c) != 0) &#123; if (getExclusiveOwnerThread() != current) return -1; // 如果“需要阻塞等待”。 // (01) 当“需要阻塞等待”的线程是第1个获取锁的线程的话，则继续往下执行。 // (02) 当“需要阻塞等待”的线程获取锁的次数=0时，则返回-1。 &#125; else if (readerShouldBlock()) &#123; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程 if (firstReader == current) &#123; &#125; else &#123; if (rh == null) &#123; rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) &#123; rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); &#125; &#125; // 如果当前线程获取锁的计数=0,则返回-1。 if (rh.count == 0) return -1; &#125; &#125; // 如果“不需要阻塞等待”，则获取“读取锁”的共享统计数； // 如果共享统计数超过MAX_COUNT，则抛出异常。 if (sharedCount(c) == MAX_COUNT) throw new Error("Maximum lock count exceeded"); // 将线程获取“读取锁”的次数+1。 if (compareAndSetState(c, c + SHARED_UNIT)) &#123; // 如果是第1次获取“读取锁”，则更新firstReader和firstReaderHoldCount。 if (sharedCount(c) == 0) &#123; firstReader = current; firstReaderHoldCount = 1; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程， // 则将firstReaderHoldCount+1。 &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); // 更新线程的获取“读取锁”的共享计数 rh.count++; cachedHoldCounter = rh; // cache for release &#125; return 1; &#125; &#125;&#125; 说明：fullTryAcquireShared()会根据 “是否需要阻塞等待”，“读取锁的共享计数是否超过限制” 等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过 CAS 尝试获取锁，并返回 1。 5. doAcquireShared() doAcquireShared() 定义在 AQS 函数中，源码如下： 1234567891011121314151617181920212223242526272829303132private void doAcquireShared(int arg) &#123; // addWaiter(Node.SHARED)的作用是，创建“当前线程”对应的节点，并将该线程添加到CLH队列中。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取“node”的前一节点 final Node p = node.predecessor(); // 如果“当前线程”是CLH队列的表头，则尝试获取共享锁。 if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; // 如果“当前线程”不是CLH队列的表头，则通过shouldParkAfterFailedAcquire()判断是否需要等待， // 需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。若阻塞等待过程中，线程被中断过，则设置interrupted为true。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：doAcquireShared() 的作用是获取共享锁。它会首先创建线程对应的 CLH 队列的节点，然后将该节点添加到 CLH 队列中。CLH 队列是管理获取锁的等待线程的队列。如果 “当前线程” 是 CLH 队列的表头，则尝试获取共享锁；否则，则需要通过 shouldParkAfterFailedAcquire()判断是否阻塞等待，需要的话，则通过 parkAndCheckInterrupt()进行阻塞等待。doAcquireShared() 会通过 for 循环，不断的进行上面的操作；目的就是获取共享锁。需要注意的是：doAcquireShared() 在每一次尝试获取锁时，是通过 tryAcquireShared() 来执行的！ shouldParkAfterFailedAcquire(), parkAndCheckInterrupt() 等函数已经在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一) ” 中详细介绍过，这里就不再重复说明了。 释放共享锁释放共享锁的思想，是先通过 tryReleaseShared() 尝试释放共享锁。尝试成功的话，则通过 doReleaseShared() 唤醒 “其他等待获取共享锁的线程”，并返回 true；否则的话，返回 flase。 1. unlock() public void unlock() { sync.releaseShared(1);} 说明：该函数实际上调用 releaseShared(1) 释放共享锁。 2. releaseShared() releaseShared() 在 AQS 中实现，源码如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 说明：releaseShared() 的目的是让当前线程释放它所持有的共享锁。它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。 3. tryReleaseShared() tryReleaseShared() 定义在 ReentrantReadWriteLock 中，源码如下： 123456789101112131415161718192021222324252627282930313233343536protected final boolean tryReleaseShared(int unused) &#123; // 获取当前线程，即释放共享锁的线程。 Thread current = Thread.currentThread(); // 如果想要释放锁的线程(current)是第1个获取锁(firstReader)的线程， // 并且“第1个获取锁的线程获取锁的次数”=1，则设置firstReader为null； // 否则，将“第1个获取锁的线程的获取次数”-1。 if (firstReader == current) &#123; // assert firstReaderHoldCount &gt; 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; // 获取rh对象，并更新“当前线程获取锁的信息”。 &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) rh = readHolds.get(); int count = rh.count; if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; --rh.count; &#125; for (;;) &#123; // 获取锁的状态 int c = getState(); // 将锁的获取次数-1。 int nextc = c - SHARED_UNIT; // 通过CAS更新锁的状态。 if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 说明：tryReleaseShared() 的作用是尝试释放共享锁。 4. doReleaseShared() doReleaseShared() 定义在 AQS 中，源码如下： 1234567891011121314151617181920212223242526private void doReleaseShared() &#123; for (;;) &#123; // 获取CLH队列的头节点 Node h = head; // 如果头节点不为null，并且头节点不等于tail节点。 if (h != null &amp;&amp; h != tail) &#123; // 获取头节点对应的线程的状态 int ws = h.waitStatus; // 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。 if (ws == Node.SIGNAL) &#123; // 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // 唤醒“头节点的下一个节点所对应的线程”。 unparkSuccessor(h); &#125; // 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; // 如果头节点发生变化，则继续循环。否则，退出循环。 if (h == head) // loop if head changed break; &#125;&#125; 说明：doReleaseShared()会释放 “共享锁”。它会从前往后的遍历 CLH 队列，依次“唤醒” 然后 “执行” 队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的锁。 公平共享锁和非公平共享锁和互斥锁 ReentrantLock 一样，ReadLock 也分为公平锁和非公平锁。 公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数 readerShouldBlock() 是不同的。公平锁的 readerShouldBlock() 的源码如下： 123final boolean readerShouldBlock() &#123; return hasQueuedPredecessors();&#125; 在公平共享锁中，如果在当前线程的前面有其他线程在等待获取共享锁，则返回 true；否则，返回 false。非公平锁的 readerShouldBlock() 的源码如下： 123final boolean readerShouldBlock() &#123; return apparentlyFirstQueuedIsExclusive();&#125; 在非公平共享锁中，它会无视当前线程的前面是否有其他线程在等待获取共享锁。只要该非公平共享锁对应的线程不为 null，则返回 true。 ReentrantReadWriteLock 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLockTest1 &#123; public static void main(String[] args) &#123; // 创建账户 MyCount myCount = new MyCount("4238920615242830", 10000); // 创建用户，并指定账户 User user = new User("Tommy", myCount); // 分别启动3个“读取账户金钱”的线程 和 3个“设置账户金钱”的线程 for (int i=0; i&lt;3; i++) &#123; user.getCash(); user.setCash((i+1)*1000); &#125; &#125; &#125; class User &#123; private String name; //用户名 private MyCount myCount; //所要操作的账户 private ReadWriteLock myLock; //执行操作所需的锁对象 User(String name, MyCount myCount) &#123; this.name = name; this.myCount = myCount; this.myLock = new ReentrantReadWriteLock(); &#125; public void getCash() &#123; new Thread() &#123; public void run() &#123; myLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() +" getCash start"); myCount.getCash(); Thread.sleep(1); System.out.println(Thread.currentThread().getName() +" getCash end"); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; myLock.readLock().unlock(); &#125; &#125; &#125;.start(); &#125; public void setCash(final int cash) &#123; new Thread() &#123; public void run() &#123; myLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() +" setCash start"); myCount.setCash(cash); Thread.sleep(1); System.out.println(Thread.currentThread().getName() +" setCash end"); &#125; catch (InterruptedException e) &#123; &#125; finally &#123; myLock.writeLock().unlock(); &#125; &#125; &#125;.start(); &#125;&#125;class MyCount &#123; private String id; //账号 private int cash; //账户余额 MyCount(String id, int cash) &#123; this.id = id; this.cash = cash; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public int getCash() &#123; System.out.println(Thread.currentThread().getName() +" getCash cash="+ cash); return cash; &#125; public void setCash(int cash) &#123; System.out.println(Thread.currentThread().getName() +" setCash cash="+ cash); this.cash = cash; &#125; &#125; 运行结果： 123456789101112131415161718Thread-0 getCash startThread-2 getCash startThread-0 getCash cash=10000Thread-2 getCash cash=10000Thread-0 getCash endThread-2 getCash endThread-1 setCash startThread-1 setCash cash=1000Thread-1 setCash endThread-3 setCash startThread-3 setCash cash=2000Thread-3 setCash endThread-4 getCash startThread-4 getCash cash=2000Thread-4 getCash endThread-5 setCash startThread-5 setCash cash=3000Thread-5 setCash end 结果说明：(01) 观察 Thread0 和 Thread-2 的运行结果，我们发现，Thread-0 启动并获取到 “读取锁”，在它还没运行完毕的时候，Thread-2 也启动了并且也成功获取到 “读取锁”。因此，“读取锁” 支持被多个线程同时获取。(02) 观察 Thread-1,Thread-3,Thread-5 这三个 “写入锁” 的线程。只要 “写入锁” 被某线程获取，则该线程运行完毕了，才释放该锁。因此，“写入锁” 不支持被多个线程同时获取。 09 CountDownLatch原理和示例概要前面对 “ 独占锁 “和” 共享锁 “有了个大致的了解；本章，我们对 CountDownLatch 进行学习。和 ReadWriteLock.ReadLock 一样，CountDownLatch 的本质也是一个” 共享锁 “。本章的内容包括：CountDownLatch 简介 CountDownLatch 数据结构CountDownLatch 源码分析 (基于 JDK1.7.0_40)CountDownLatch 示例 CountDownLatch 简介CountDownLatch 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 CountDownLatch 和 CyclicBarrier 的区别(01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。(02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。关于 CyclicBarrier 的原理，后面一章再来学习。 CountDownLatch 函数列表 CountDownLatch(int count)构造一个用给定计数初始化的 CountDownLatch。 12345678910// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。void await()// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。boolean await(long timeout, TimeUnit unit)// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。void countDown()// 返回当前计数。long getCount()// 返回标识此锁存器及其状态的字符串。String toString() CountDownLatch 数据结构CountDownLatch 的 UML 类图如下： CountDownLatch 的数据结构很简单，它是通过 “ 共享锁 “ 实现的。它包含了 sync 对象，sync 是 Sync 类型。Sync 是实例类，它继承于 AQS。 CountDownLatch 源码分析 (基于 JDK1.7.0_40)CountDownLatch 完整源码 (基于 JDK1.7.0_40) CountDownLatch.java完整源码 CountDownLatch 是通过 “共享锁” 实现的。下面，我们分析 CountDownLatch 中 3 个核心函数: CountDownLatch(int count), await(), countDown()。 1. CountDownLatch(int count) 1234public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count);&#125; 说明：该函数是创建一个 Sync 对象，而 Sync 是继承于 AQS 类。Sync 构造函数如下： 123Sync(int count) &#123; setState(count);&#125; setState() 在 AQS 中实现，源码如下：123protected final void setState(long newState) &#123; state = newState;&#125; 说明：在 AQS 中，state 是一个 private volatile long 类型的对象。对于 CountDownLatch 而言，state 表示的”锁计数器 “。CountDownLatch 中的 getCount() 最终是调用 AQS 中的 getState()，返回的 state 对象，即”锁计数器“。 2. await() 123public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125; 说明：该函数实际上是调用的 AQS 的 acquireSharedInterruptibly(1); AQS 中的 acquireSharedInterruptibly() 的源码如下： 1234567public final void acquireSharedInterruptibly(long arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 说明：acquireSharedInterruptibly() 的作用是获取共享锁。如果当前线程是中断状态，则抛出异常 InterruptedException。否则，调用 tryAcquireShared(arg)尝试获取共享锁；尝试成功则返回，否则就调用 doAcquireSharedInterruptibly()。doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁 (或被中断) 才返回。 tryAcquireShared() 在 CountDownLatch.java 中被重写，它的源码如下： 123protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; 说明：tryAcquireShared() 的作用是尝试获取共享锁。如果 “锁计数器 = 0”，即锁是可获取状态，则返回 1；否则，锁是不可获取状态，则返回 - 1。 123456789101112131415161718192021222324252627282930private void doAcquireSharedInterruptibly(long arg) throws InterruptedException &#123; // 创建"当前线程"的Node节点，且Node中记录的锁是"共享锁"类型；并将该节点添加到CLH队列末尾。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 获取上一个节点。 // 如果上一节点是CLH队列的表头，则"尝试获取共享锁"。 final Node p = node.predecessor(); if (p == head) &#123; long r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; // (上一节点不是CLH队列的表头) 当前线程一直等待，直到获取到共享锁。 // 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：(01) addWaiter(Node.SHARED)的作用是，创建”当前线程 “的 Node 节点，且 Node 中记录的锁的类型是” 共享锁“(Node.SHARED)；并将该节点添加到 CLH 队列末尾。关于 Node 和 CLH 在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)“ 已经详细介绍过，这里就不再重复说明了。(02) node.predecessor() 的作用是，获取上一个节点。如果上一节点是 CLH 队列的表头，则” 尝试获取共享锁 “。(03) shouldParkAfterFailedAcquire() 的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回 true；否则，返回 false。(04) 当 shouldParkAfterFailedAcquire() 返回 ture 时，则调用 parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。doAcquireSharedInterruptibly() 中的 shouldParkAfterFailedAcquire(), parkAndCheckInterrupt 等函数在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)“ 中介绍过，这里也就不再详细说明了。 3. countDown() 123public void countDown() &#123; sync.releaseShared(1);&#125; 说明：该函数实际上调用 releaseShared(1) 释放共享锁。 releaseShared() 在 AQS 中实现，源码如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 说明：releaseShared() 的目的是让当前线程释放它所持有的共享锁。它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。 tryReleaseShared() 在 CountDownLatch.java 中被重写，源码如下： 1234567891011121314protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; // 获取“锁计数器”的状态 int c = getState(); if (c == 0) return false; // “锁计数器”-1 int nextc = c-1; // 通过CAS函数进行赋值。 if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 说明：tryReleaseShared()的作用是释放共享锁，将 “锁计数器” 的值 - 1。 总结：CountDownLatch 是通过 “共享锁” 实现的。在创建 CountDownLatch 中时，会传递一个 int 类型参数 count，该参数是 “锁计数器” 的初始状态，表示该 “共享锁” 最多能被 count 个线程同时获取。当某线程调用该 CountDownLatch 对象的 await()方法时，该线程会等待 “共享锁” 可用时，才能获取 “共享锁” 进而继续运行。而 “共享锁” 可用的条件，就是 “锁计数器” 的值为 0！而 “锁计数器” 的初始值为 count，每当一个线程调用该 CountDownLatch 对象的 countDown()方法时，才将 “锁计数器”减1；通过这种方式，必须有 count 个线程调用 countDown() 之后，“锁计数器”才为 0，而前面提到的等待线程才能继续运行！ 以上，就是 CountDownLatch 的实现原理。 CountDownLatch 的使用示例下面通过 CountDownLatch 实现：”主线程” 等待 “5 个子线程” 全部都完成 “指定的工作 (休眠 1000ms)” 之后，再继续运行。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.CountDownLatch;import java.util.concurrent.CyclicBarrier;public class CountDownLatchTest1 &#123; private static int LATCH_SIZE = 5; private static CountDownLatch doneSignal; public static void main(String[] args) &#123; try &#123; doneSignal = new CountDownLatch(LATCH_SIZE); // 新建5个任务 for(int i=0; i&lt;LATCH_SIZE; i++) new InnerThread().start(); System.out.println("main await begin."); // "主线程"等待线程池中5个任务的完成 doneSignal.await(); System.out.println("main await finished."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + " sleep 1000ms."); // 将CountDownLatch的数值减1 doneSignal.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234567main await begin.Thread-0 sleep 1000ms.Thread-2 sleep 1000ms.Thread-1 sleep 1000ms.Thread-4 sleep 1000ms.Thread-3 sleep 1000ms.main await finished. 结果说明：主线程通过 doneSignal.await() 等待其它线程将 doneSignal 递减至 0。其它的 5 个 InnerThread 线程，每一个都通过 doneSignal.countDown() 将 doneSignal 的值减 1；当 doneSignal 为 0 时，main 被唤醒后继续执行。 10 CyclicBarrier原理和示例概要本章介绍 JUC 包中的 CyclicBarrier 锁。内容包括：CyclicBarrier 简介CyclicBarrier 数据结构CyclicBarrier 源码分析 (基于 JDK1.7.0_40)CyclicBarrier 示例 CyclicBarrier 简介CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 注意比较 CountDownLatch 和 CyclicBarrier：(01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。(02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。 CyclicBarrier 函数列表 1234567891011121314151617CyclicBarrier(int parties)//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。CyclicBarrier(int parties, Runnable barrierAction)//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。int await()//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。int await(long timeout, TimeUnit unit)//在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。int getNumberWaiting()//返回当前在屏障处等待的参与者数目。int getParties()//返回要求启动此 barrier 的参与者数目。boolean isBroken()//查询此屏障是否处于损坏状态。void reset()//将屏障重置为其初始状态。 CyclicBarrier 数据结构CyclicBarrier 的 UML 类图如下： CyclicBarrier 是包含了 “ReentrantLock 对象 lock”和”Condition 对象 trip”，它是通过独占锁实现的。下面通过源码去分析到底是如何实现的。 CyclicBarrier 源码分析 (基于 JDK1.7.0_40)CyclicBarrier 完整源码 (基于 JDK1.7.0_40) CyclicBarrier.java源码 CyclicBarrier 是通过 ReentrantLock(独占锁) 和 Condition 来实现的。下面，我们分析 CyclicBarrier 中 3 个核心函数: 构造函数, await() 作出分析。 1. 构造函数 CyclicBarrier 的构造函数共 2 个：CyclicBarrier 和 CyclicBarrier(int parties, Runnable barrierAction)。第 1 个构造函数是调用第 2 个构造函数来实现的，下面第 2 个构造函数的源码。 123456789public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); // parties表示“必须同时到达barrier的线程个数”。 this.parties = parties; // count表示“处在等待状态的线程个数”。 this.count = parties; // barrierCommand表示“parties个线程到达barrier时，会执行的动作”。 this.barrierCommand = barrierAction;&#125; 2. 等待函数 CyclicBarrier.java 中 await() 方法如下： 1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen; &#125;&#125; 说明：await() 是通过 dowait() 实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; // 获取“独占锁(lock)” lock.lock(); try &#123; // 保存“当前的generation” final Generation g = generation; // 若“当前generation已损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; // 将“count计数器”-1 int index = --count; // 如果index=0，则意味着“有parties个线程到达barrier”。 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; // 如果barrierCommand不为null，则执行该动作。 final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; // 唤醒所有等待线程，并更新generation。 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; // 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生， // 当前线程才继续执行。 for (;;) &#123; try &#123; // 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。 if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; // 如果等待过程中，线程被中断，则执行下面的函数。 if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; Thread.currentThread().interrupt(); &#125; &#125; // 如果“当前generation已经损坏”，则抛出异常。 if (g.broken) throw new BrokenBarrierException(); // 如果“generation已经换代”，则返回index。 if (g != generation) return index; // 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。 if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; // 释放“独占锁(lock)” lock.unlock(); &#125;&#125; 说明：dowait()的作用就是让当前线程阻塞，直到 “有 parties 个线程到达 barrier” 或 “当前线程被中断” 或 “超时” 这 3 者之一发生，当前线程才继续执行。(01) generation 是 CyclicBarrier 的一个成员遍历，它的定义如下： 12345private Generation generation = new Generation();private static class Generation &#123; boolean broken = false;&#125; 在 CyclicBarrier 中，同一批的线程属于同一代，即同一个 Generation；CyclicBarrier 中通过 generation 对象，记录属于哪一代。当有 parties 个线程到达 barrier，generation 就会被更新换代。 (02) 如果当前线程被中断，即 Thread.interrupted() 为 true；则通过 breakBarrier() 终止 CyclicBarrier。breakBarrier() 的源码如下： 12345private void breakBarrier() &#123; generation.broken = true; count = parties; trip.signalAll();&#125; breakBarrier()会设置当前中断标记 broken 为 true，意味着 “将该 Generation 中断”；同时，设置 count=parties，即重新初始化 count；最后，通过 signalAll() 唤醒 CyclicBarrier 上所有的等待线程。 (03) 将 “count 计数器”-1，即 –count；然后判断是不是 “有 parties 个线程到达 barrier”，即 index 是不是为 0。当 index=0 时，如果 barrierCommand 不为 null，则执行该 barrierCommand，barrierCommand 就是我们创建 CyclicBarrier 时，传入的 Runnable 对象。然后，调用 nextGeneration() 进行换代工作，nextGeneration() 的源码如下： 12345private void nextGeneration() &#123; trip.signalAll(); count = parties; generation = new Generation();&#125; 首先，它会调用 signalAll() 唤醒 CyclicBarrier 上所有的等待线程；接着，重新初始化 count；最后，更新 generation 的值。 (04) 在 for(;;)循环中。timed 是用来表示当前是不是 “超时等待” 线程。如果不是，则通过 trip.await()进行等待；否则，调用 awaitNanos()进行超时等待。 CyclicBarrier 的使用示例示例 1新建 5 个线程，这 5 个线程达到一定的条件时，它们才继续往后运行。 12345678910111213141516171819202122232425262728293031323334 import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest1 &#123; private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) &#123; cb = new CyclicBarrier(SIZE); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " wait for CyclicBarrier."); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + " continued."); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 12345678910Thread-1 wait for CyclicBarrier.Thread-2 wait for CyclicBarrier.Thread-3 wait for CyclicBarrier.Thread-4 wait for CyclicBarrier.Thread-0 wait for CyclicBarrier.Thread-0 continued.Thread-4 continued.Thread-2 continued.Thread-3 continued.Thread-1 continued. 结果说明：主线程中新建了 5 个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到 cb 中所有线程都达到 barrier 时，这些线程才继续运行！ 示例 2 新建 5 个线程，当这 5 个线程达到一定的条件时，执行某项任务。 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest2 &#123; private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) &#123; cb = new CyclicBarrier(SIZE, new Runnable () &#123; public void run() &#123; System.out.println("CyclicBarrier's parties is: "+ cb.getParties()); &#125; &#125;); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " wait for CyclicBarrier."); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + " continued."); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011Thread-1 wait for CyclicBarrier.Thread-2 wait for CyclicBarrier.Thread-3 wait for CyclicBarrier.Thread-4 wait for CyclicBarrier.Thread-0 wait for CyclicBarrier.CyclicBarrier's parties is: 5Thread-0 continued.Thread-4 continued.Thread-2 continued.Thread-3 continued.Thread-1 continued. 结果说明：主线程中新建了 5 个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到 cb 中所有线程都达到 barrier 时，执行新建 cb 时注册的 Runnable 任务。 11 Semaphore信号量的原理和示例概要本章，我们对 JUC 包中的信号量 Semaphore 进行学习。内容包括：Semaphore 简介Semaphore 数据结构Semaphore 源码分析 (基于 JDK1.7.0_40)Semaphore 示例 Semaphore 简介Semaphore 是一个计数信号量，它的本质是一个 “ 共享锁 “。 信号量维护了一个信号量许可集。线程可以通过调用 acquire() 来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过 release() 来释放它所持有的信号量许可。 Semaphore 的函数列表 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建具有给定的许可数和非公平的公平设置的 Semaphore。Semaphore(int permits)// 创建具有给定的许可数和给定的公平设置的 Semaphore。Semaphore(int permits, boolean fair)// 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。void acquire()// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞，或者线程已被中断。void acquire(int permits)// 从此信号量中获取许可，在有可用的许可前将其阻塞。void acquireUninterruptibly()// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞。void acquireUninterruptibly(int permits)// 返回此信号量中当前可用的许可数。int availablePermits()// 获取并返回立即可用的所有许可。int drainPermits()// 返回一个 collection，包含可能等待获取的线程。protected Collection&lt;Thread&gt; getQueuedThreads()// 返回正在等待获取的线程的估计数目。int getQueueLength()// 查询是否有线程正在等待获取。boolean hasQueuedThreads()// 如果此信号量的公平设置为 true，则返回 true。boolean isFair()// 根据指定的缩减量减小可用许可的数目。protected void reducePermits(int reduction)// 释放一个许可，将其返回给信号量。void release()// 释放给定数目的许可，将其返回到信号量。void release(int permits)// 返回标识此信号量的字符串，以及信号量的状态。String toString()// 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。boolean tryAcquire()// 仅在调用时此信号量中有给定数目的许可时，才从此信号量中获取这些许可。boolean tryAcquire(int permits)// 如果在给定的等待时间内此信号量有可用的所有许可，并且当前线程未被中断，则从此信号量获取给定数目的许可。boolean tryAcquire(int permits, long timeout, TimeUnit unit)// 如果在给定的等待时间内，此信号量有可用的许可并且当前线程未被中断，则从此信号量获取一个许可。boolean tryAcquire(long timeout, TimeUnit unit) Semaphore 数据结构Semaphore 的 UML 类图如下： 从图中可以看出： (01) 和 “ReentrantLock“ 一样，Semaphore 也包含了 sync 对象，sync 是 Sync 类型；而且，Sync 是一个继承于 AQS 的抽象类。 (02) Sync 包括两个子类：”公平信号量”FairSync 和 “非公平信号量”NonfairSync。sync 是 “FairSync 的实例”，或者 “NonfairSync 的实例”；默认情况下，sync 是 NonfairSync(即，默认是非公平信号量)。 Semaphore 源码分析 (基于 JDK1.7.0_40)Semaphore 完整源码 (基于 JDK1.7.0_40) Semaphore.java源码 Semaphore 是通过共享锁实现的。根据共享锁的获取原则，Semaphore 分为 “公平信号量” 和 “非公平信号量”。 “公平信号量” 和 “非公平信号量” 的区别 “公平信号量” 和 “非公平信号量” 的释放信号量的机制是一样的！不同的是它们获取信号量的机制：线程在尝试获取信号量许可时，对于公平信号量而言，如果当前线程不在 CLH 队列的头部，则排队等候；而对于非公平信号量而言，无论当前线程是不是在 CLH 队列的头部，它都会直接获取信号量。该差异具体的体现在，它们的 tryAcquireShared() 函数的实现不同。 “公平信号量” 类 12345678910111213141516171819static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125;&#125; “非公平信号量” 类 1234567891011static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125;&#125; 下面，我们逐步的对它们的源码进行分析。 1. 信号量构造函数 1234567public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; 从中，我们可以信号量分为 “公平信号量(FairSync)” 和“非公平信号量 (NonfairSync)”。Semaphore(int permits) 函数会默认创建“非公平信号量”。 2. 公平信号量获取和释放 2.1 公平信号量的获取Semaphore 中的公平信号量是 FairSync。它的获取 API 如下： 12345678public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public void acquire(int permits) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.acquireSharedInterruptibly(permits);&#125; 信号量中的 acquire() 获取函数，实际上是调用的 AQS 中的 acquireSharedInterruptibly()。 acquireSharedInterruptibly() 的源码如下： 123456789public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; // 如果线程是中断状态，则抛出异常。 if (Thread.interrupted()) throw new InterruptedException(); // 否则，尝试获取“共享锁”；获取成功则直接返回，获取失败，则通过doAcquireSharedInterruptibly()获取。 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; Semaphore 中”公平锁 “对应的 tryAcquireShared() 实现如下： 12345678910111213141516protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; // 判断“当前线程”是不是CLH队列中的第一个线程线程， // 若是的话，则返回-1。 if (hasQueuedPredecessors()) return -1; // 设置“可以获得的信号量的许可数” int available = getState(); // 设置“获得acquires个信号量许可之后，剩余的信号量许可数” int remaining = available - acquires; // 如果“剩余的信号量许可数&gt;=0”，则设置“可以获得的信号量许可数”为remaining。 if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125; 说明：tryAcquireShared() 的作用是尝试获取 acquires 个信号量许可数。对于 Semaphore 而言，state 表示的是 “当前可获得的信号量许可数”。 下面看看 AQS 中 doAcquireSharedInterruptibly() 的实现： 123456789101112131415161718192021222324252627282930private void doAcquireSharedInterruptibly(long arg) throws InterruptedException &#123; // 创建”当前线程“的Node节点，且Node中记录的锁是”共享锁“类型；并将该节点添加到CLH队列末尾。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; // 获取上一个节点。 // 如果上一节点是CLH队列的表头，则”尝试获取共享锁“。 final Node p = node.predecessor(); if (p == head) &#123; long r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; // 当前线程一直等待，直到获取到共享锁。 // 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 说明：doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁 (或被中断) 才返回。(01) addWaiter(Node.SHARED)的作用是，创建”当前线程 “的 Node 节点，且 Node 中记录的锁的类型是” 共享锁“(Node.SHARED)；并将该节点添加到 CLH 队列末尾。关于 Node 和 CLH 在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)“ 已经详细介绍过，这里就不再重复说明了。(02) node.predecessor() 的作用是，获取上一个节点。如果上一节点是 CLH 队列的表头，则” 尝试获取共享锁 “。(03) shouldParkAfterFailedAcquire() 的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回 true；否则，返回 false。(04) 当 shouldParkAfterFailedAcquire() 返回 ture 时，则调用 parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。doAcquireSharedInterruptibly() 中的 shouldParkAfterFailedAcquire(), parkAndCheckInterrupt 等函数在 “Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)“ 中介绍过，这里也就不再详细说明了。 2.2 公平信号量的释放 Semaphore 中公平信号量 (FairSync) 的释放 API 如下： 12345678public void release() &#123; sync.releaseShared(1);&#125;public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits);&#125; 信号量的 releases() 释放函数，实际上是调用的 AQS 中的 releaseShared()。 releaseShared() 在 AQS 中实现，源码如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 说明：releaseShared() 的目的是让当前线程释放它所持有的共享锁。它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。 Semaphore 重写了 tryReleaseShared()，它的源码如下： 12345678910111213protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; // 获取“可以获得的信号量的许可数” int current = getState(); // 获取“释放releases个信号量许可之后，剩余的信号量许可数” int next = current + releases; if (next &lt; current) // overflow throw new Error("Maximum permit count exceeded"); // 设置“可以获得的信号量的许可数”为next。 if (compareAndSetState(current, next)) return true; &#125;&#125; 如果 tryReleaseShared() 尝试释放共享锁失败，则会调用 doReleaseShared() 去释放共享锁。doReleaseShared() 的源码如下： 1234567891011121314151617181920212223242526private void doReleaseShared() &#123; for (;;) &#123; // 获取CLH队列的头节点 Node h = head; // 如果头节点不为null，并且头节点不等于tail节点。 if (h != null &amp;&amp; h != tail) &#123; // 获取头节点对应的线程的状态 int ws = h.waitStatus; // 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。 if (ws == Node.SIGNAL) &#123; // 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // 唤醒“头节点的下一个节点所对应的线程”。 unparkSuccessor(h); &#125; // 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; // 如果头节点发生变化，则继续循环。否则，退出循环。 if (h == head) // loop if head changed break; &#125;&#125; 说明：doReleaseShared()会释放 “共享锁”。它会从前往后的遍历 CLH 队列，依次“唤醒” 然后 “执行” 队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的信号量。 3 非公平信号量获取和释放 Semaphore 中的非公平信号量是 NonFairSync。在 Semaphore 中，“非公平信号量许可的释放 (release)” 与“公平信号量许可的释放 (release)” 是一样的。不同的是它们获取 “信号量许可” 的机制不同，下面是非公平信号量获取信号量许可的代码。 非公平信号量的 tryAcquireShared() 实现如下： 123protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires);&#125; nonfairTryAcquireShared() 的实现如下： 123456789101112final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; // 设置“可以获得的信号量的许可数” int available = getState(); // 设置“获得acquires个信号量许可之后，剩余的信号量许可数” int remaining = available - acquires; // 如果“剩余的信号量许可数&gt;=0”，则设置“可以获得的信号量许可数”为remaining。 if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125; 说明：非公平信号量的 tryAcquireShared()调用 AQS 中的 nonfairTryAcquireShared()。而在 nonfairTryAcquireShared()的 for 循环中，它都会直接判断 “当前剩余的信号量许可数” 是否足够；足够的话，则直接“设置可以获得的信号量许可数”，进而再获取信号量。而公平信号量的 tryAcquireShared() 中，在获取信号量之前会通过 if (hasQueuedPredecessors()) 来判断 “当前线程是不是在 CLH 队列的头部”，是的话，则返回 - 1。 Semaphore 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; public class SemaphoreTest1 &#123; private static final int SEM_MAX = 10; public static void main(String[] args) &#123; Semaphore sem = new Semaphore(SEM_MAX); //创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(3); //在线程池中执行任务 threadPool.execute(new MyThread(sem, 5)); threadPool.execute(new MyThread(sem, 4)); threadPool.execute(new MyThread(sem, 7)); //关闭池 threadPool.shutdown(); &#125;&#125;class MyThread extends Thread &#123; private volatile Semaphore sem; // 信号量 private int count; // 申请信号量的大小 MyThread(Semaphore sem, int count) &#123; this.sem = sem; this.count = count; &#125; public void run() &#123; try &#123; // 从信号量中获取count个许可 sem.acquire(count); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + " acquire count="+count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放给定数目的许可，将其返回到信号量。 sem.release(count); System.out.println(Thread.currentThread().getName() + " release " + count + ""); &#125; &#125;&#125; (某一次) 运行结果： 123456pool-1-thread-1 acquire count=5pool-1-thread-2 acquire count=4pool-1-thread-1 release 5pool-1-thread-2 release 4pool-1-thread-3 acquire count=7pool-1-thread-3 release 7 结果说明：信号量 sem 的许可总数是 10 个；共 3 个线程，分别需要获取的信号量许可数是 5,4,7。前面两个线程获取到信号量的许可后，sem 中剩余的可用的许可数是 1；因此，最后一个线程必须等前两个线程释放了它们所持有的信号量许可之后，才能获取到 7 个信号量许可。 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列二：JUC原子类]]></title>
    <url>%2F2018%2F03%2F24%2F2018-03-24%2F</url>
    <content type="text"><![CDATA[01 框架根据修改的数据类型，可以将 JUC 包中的原子操作类可以分为 4 类。 基本类型: AtomicInteger, AtomicLong, AtomicBoolean ; 数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ; 引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ; 对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。 这些类存在的目的是对相应的数据进行原子操作。所谓原子操作，是指操作过程不会被中断，保证数据操作是以原子方式进行的。 02 AtomicLong原子类概要AtomicInteger, AtomicLong 和 AtomicBoolean 这 3 个基本类型的原子类的原理和用法相似。本章以 AtomicLong 对基本类型的原子类进行介绍。内容包括：AtomicLong 介绍和函数列表AtomicLong 源码分析 (基于 JDK1.7.0_40)AtomicLong 示例 AtomicLong 介绍和函数列表AtomicLong 是作用是对长整形进行原子操作。在 32 位操作系统中，64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操作，所以不具有原子性。而使用 AtomicLong 能让 long 的操作保持原子型。 AtomicLong 函数列表 123456789101112131415161718192021222324252627282930313233343536// 构造函数AtomicLong()// 创建值为initialValue的AtomicLong对象AtomicLong(long initialValue)// 以原子方式设置当前值为newValue。final void set(long newValue) // 获取当前值final long get() // 以原子方式将当前值减 1，并返回减1后的值。等价于“--num”final long decrementAndGet() // 以原子方式将当前值减 1，并返回减1前的值。等价于“num--”final long getAndDecrement() // 以原子方式将当前值加 1，并返回加1后的值。等价于“++num”final long incrementAndGet() // 以原子方式将当前值加 1，并返回加1前的值。等价于“num++”final long getAndIncrement() // 以原子方式将delta与当前值相加，并返回相加后的值。final long addAndGet(long delta) // 以原子方式将delta添加到当前值，并返回相加前的值。final long getAndAdd(long delta) // 如果当前值 == expect，则以原子方式将该值设置为update。成功返回true，否则返回false，并且不修改原值。final boolean compareAndSet(long expect, long update)// 以原子方式设置当前值为newValue，并返回旧值。final long getAndSet(long newValue)// 返回当前值对应的int值int intValue() // 获取当前值对应的long值long longValue() // 以 float 形式返回当前值float floatValue() // 以 double 形式返回当前值double doubleValue() // 最后设置为给定值。延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。final void lazySet(long newValue)// 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但不创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。final boolean weakCompareAndSet(long expect, long update) AtomicLong 源码分析 (基于 JDK1.7.0_40)AtomicLong 的完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255/* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. *//* * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */package java.util.concurrent.atomic;import sun.misc.Unsafe;/** * A &#123;@code long&#125; value that may be updated atomically. See the * &#123;@link java.util.concurrent.atomic&#125; package specification for * description of the properties of atomic variables. An * &#123;@code AtomicLong&#125; is used in applications such as atomically * incremented sequence numbers, and cannot be used as a replacement * for a &#123;@link java.lang.Long&#125;. However, this class does extend * &#123;@code Number&#125; to allow uniform access by tools and utilities that * deal with numerically-based classes. * * @since 1.5 * @author Doug Lea */public class AtomicLong extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 1927816293512124184L; // setup to use Unsafe.compareAndSwapLong for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; /** * Records whether the underlying JVM supports lockless * compareAndSwap for longs. While the Unsafe.compareAndSwapLong * method works in either case, some constructions should be * handled at Java level to avoid locking user-visible locks. */ static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8(); /** * Returns whether underlying JVM supports lockless CompareAndSet * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS. */ private static native boolean VMSupportsCS8(); static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicLong.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile long value; /** * Creates a new AtomicLong with the given initial value. * * @param initialValue the initial value */ public AtomicLong(long initialValue) &#123; value = initialValue; &#125; /** * Creates a new AtomicLong with initial value &#123;@code 0&#125;. */ public AtomicLong() &#123; &#125; /** * Gets the current value. * * @return the current value */ public final long get() &#123; return value; &#125; /** * Sets to the given value. * * @param newValue the new value */ public final void set(long newValue) &#123; value = newValue; &#125; /** * Eventually sets to the given value. * * @param newValue the new value * @since 1.6 */ public final void lazySet(long newValue) &#123; unsafe.putOrderedLong(this, valueOffset, newValue); &#125; /** * Atomically sets to the given value and returns the old value. * * @param newValue the new value * @return the previous value */ public final long getAndSet(long newValue) &#123; while (true) &#123; long current = get(); if (compareAndSet(current, newValue)) return current; &#125; &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return true if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update); &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;May &lt;a href="package-summary.html#Spurious"&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to &#123;@code compareAndSet&#125;. * * @param expect the expected value * @param update the new value * @return true if successful. */ public final boolean weakCompareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update); &#125; /** * Atomically increments by one the current value. * * @return the previous value */ public final long getAndIncrement() &#123; while (true) &#123; long current = get(); long next = current + 1; if (compareAndSet(current, next)) return current; &#125; &#125; /** * Atomically decrements by one the current value. * * @return the previous value */ public final long getAndDecrement() &#123; while (true) &#123; long current = get(); long next = current - 1; if (compareAndSet(current, next)) return current; &#125; &#125; /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the previous value */ public final long getAndAdd(long delta) &#123; while (true) &#123; long current = get(); long next = current + delta; if (compareAndSet(current, next)) return current; &#125; &#125; /** * Atomically increments by one the current value. * * @return the updated value */ public final long incrementAndGet() &#123; for (;;) &#123; long current = get(); long next = current + 1; if (compareAndSet(current, next)) return next; &#125; &#125; /** * Atomically decrements by one the current value. * * @return the updated value */ public final long decrementAndGet() &#123; for (;;) &#123; long current = get(); long next = current - 1; if (compareAndSet(current, next)) return next; &#125; &#125; /** * Atomically adds the given value to the current value. * * @param delta the value to add * @return the updated value */ public final long addAndGet(long delta) &#123; for (;;) &#123; long current = get(); long next = current + delta; if (compareAndSet(current, next)) return next; &#125; &#125; /** * Returns the String representation of the current value. * @return the String representation of the current value. */ public String toString() &#123; return Long.toString(get()); &#125; public int intValue() &#123; return (int)get(); &#125; public long longValue() &#123; return get(); &#125; public float floatValue() &#123; return (float)get(); &#125; public double doubleValue() &#123; return (double)get(); &#125;&#125; AtomicLong 的代码很简单，下面仅以 incrementAndGet() 为例，对 AtomicLong 的原理进行说明。incrementAndGet() 源码如下： 1234567891011public final long incrementAndGet() &#123; for (;;) &#123; // 获取AtomicLong当前对应的long值 long current = get(); // 将current加1 long next = current + 1; // 通过CAS函数，更新current的值 if (compareAndSet(current, next)) return next; &#125;&#125; 说明：(01) incrementAndGet() 首先会根据 get() 获取 AtomicLong 对应的 long 值。该值是 volatile 类型的变量，get() 的源码如下： 123456// value是AtomicLong对应的long值private volatile long value;// 返回AtomicLong对应的long值public final long get() &#123; return value;&#125; (02) incrementAndGet() 接着将 current 加 1, 然后通过 CAS 函数，将新的值赋值给 value。compareAndSet() 的源码如下： 123public final boolean compareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update);&#125; compareAndSet() 的作用是更新 AtomicLong 对应的 long 值。它会比较 AtomicLong 的原始值是否与 expect 相等，若相等的话，则设置 AtomicLong 的值为 update。 AtomicLong 示例12345678910111213141516171819202122232425262728293031// LongTest.java的源码import java.util.concurrent.atomic.AtomicLong;public class LongTest &#123; public static void main(String[] args)&#123; // 新建AtomicLong对象 AtomicLong mAtoLong = new AtomicLong(); mAtoLong.set(0x0123456789ABCDEFL); System.out.printf("%20s : 0x%016X\n", "get()", mAtoLong.get()); System.out.printf("%20s : 0x%016X\n", "intValue()", mAtoLong.intValue()); System.out.printf("%20s : 0x%016X\n", "longValue()", mAtoLong.longValue()); System.out.printf("%20s : %s\n", "doubleValue()", mAtoLong.doubleValue()); System.out.printf("%20s : %s\n", "floatValue()", mAtoLong.floatValue()); System.out.printf("%20s : 0x%016X\n", "getAndDecrement()", mAtoLong.getAndDecrement()); System.out.printf("%20s : 0x%016X\n", "decrementAndGet()", mAtoLong.decrementAndGet()); System.out.printf("%20s : 0x%016X\n", "getAndIncrement()", mAtoLong.getAndIncrement()); System.out.printf("%20s : 0x%016X\n", "incrementAndGet()", mAtoLong.incrementAndGet()); System.out.printf("%20s : 0x%016X\n", "addAndGet(0x10)", mAtoLong.addAndGet(0x10)); System.out.printf("%20s : 0x%016X\n", "getAndAdd(0x10)", mAtoLong.getAndAdd(0x10)); System.out.printf("\n%20s : 0x%016X\n", "get()", mAtoLong.get()); System.out.printf("%20s : %s\n", "compareAndSet()", mAtoLong.compareAndSet(0x12345679L, 0xFEDCBA9876543210L)); System.out.printf("%20s : 0x%016X\n", "get()", mAtoLong.get()); &#125;&#125; 运行结果： 123456789101112131415 get() : 0x0123456789ABCDEF intValue() : 0x0000000089ABCDEF longValue() : 0x0123456789ABCDEF doubleValue() : 8.1985529216486896E16 floatValue() : 8.1985531E16getAndDecrement() : 0x0123456789ABCDEFdecrementAndGet() : 0x0123456789ABCDEDgetAndIncrement() : 0x0123456789ABCDEDincrementAndGet() : 0x0123456789ABCDEF addAndGet(0x10) : 0x0123456789ABCDFF getAndAdd(0x10) : 0x0123456789ABCDFF get() : 0x0123456789ABCE0F compareAndSet() : false get() : 0x0123456789ABCE0F 03 AtomicLongArray原子类概要AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray 这 3 个数组类型的原子类的原理和用法相似。本章以 AtomicLongArray 对数组类型的原子类进行介绍。内容包括：AtomicLongArray 介绍和函数列表AtomicLongArray 源码分析 (基于 JDK1.7.0_40)AtomicLongArray 示例 AtomicLongArray 介绍和函数列表在 “Java 多线程系列 –“JUC 原子类”02 之 AtomicLong 原子类 “中介绍过，AtomicLong 是作用是对长整形进行原子操作。而 AtomicLongArray 的作用则是对” 长整形数组 “ 进行原子操作。 AtomicLongArray 函数列表 123456789101112131415161718192021222324252627282930313233// 创建给定长度的新 AtomicLongArray。AtomicLongArray(int length)// 创建与给定数组具有相同长度的新AtomicLongArray，并从给定数组复制其所有元素。AtomicLongArray(long[] array)// 以原子方式将给定值添加到索引 i 的元素。long addAndGet(int i, long delta)// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean compareAndSet(int i, long expect, long update)// 以原子方式将索引 i 的元素减1。long decrementAndGet(int i)// 获取位置 i 的当前值。long get(int i)// 以原子方式将给定值与索引 i 的元素相加。long getAndAdd(int i, long delta)// 以原子方式将索引 i 的元素减 1。long getAndDecrement(int i)// 以原子方式将索引 i 的元素加 1。long getAndIncrement(int i)// 以原子方式将位置 i 的元素设置为给定值，并返回旧值。long getAndSet(int i, long newValue)// 以原子方式将索引 i 的元素加1。long incrementAndGet(int i)// 最终将位置 i 的元素设置为给定值。void lazySet(int i, long newValue)// 返回该数组的长度。int length()// 将位置 i 的元素设置为给定值。void set(int i, long newValue)// 返回数组当前值的字符串表示形式。String toString()// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean weakCompareAndSet(int i, long expect, long update) AtomicLongArray 源码分析 (基于 JDK1.7.0_40)AtomicLongArray 的完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260 /* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. *//* * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */package java.util.concurrent.atomic;import sun.misc.Unsafe;import java.util.*;/** * A &#123;@code long&#125; array in which elements may be updated atomically. * See the &#123;@link java.util.concurrent.atomic&#125; package specification * for description of the properties of atomic variables. * @since 1.5 * @author Doug Lea */public class AtomicLongArray implements java.io.Serializable &#123; private static final long serialVersionUID = -2308431214976778248L; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final int base = unsafe.arrayBaseOffset(long[].class); private static final int shift; private final long[] array; static &#123; int scale = unsafe.arrayIndexScale(long[].class); if ((scale &amp; (scale - 1)) != 0) throw new Error("data type scale not a power of two"); shift = 31 - Integer.numberOfLeadingZeros(scale); &#125; private long checkedByteOffset(int i) &#123; if (i &lt; 0 || i &gt;= array.length) throw new IndexOutOfBoundsException("index " + i); return byteOffset(i); &#125; private static long byteOffset(int i) &#123; return ((long) i &lt;&lt; shift) + base; &#125; /** * Creates a new AtomicLongArray of the given length, with all * elements initially zero. * * @param length the length of the array */ public AtomicLongArray(int length) &#123; array = new long[length]; &#125; /** * Creates a new AtomicLongArray with the same length as, and * all elements copied from, the given array. * * @param array the array to copy elements from * @throws NullPointerException if array is null */ public AtomicLongArray(long[] array) &#123; // Visibility guaranteed by final field guarantees this.array = array.clone(); &#125; /** * Returns the length of the array. * * @return the length of the array */ public final int length() &#123; return array.length; &#125; /** * Gets the current value at position &#123;@code i&#125;. * * @param i the index * @return the current value */ public final long get(int i) &#123; return getRaw(checkedByteOffset(i)); &#125; private long getRaw(long offset) &#123; return unsafe.getLongVolatile(array, offset); &#125; /** * Sets the element at position &#123;@code i&#125; to the given value. * * @param i the index * @param newValue the new value */ public final void set(int i, long newValue) &#123; unsafe.putLongVolatile(array, checkedByteOffset(i), newValue); &#125; /** * Eventually sets the element at position &#123;@code i&#125; to the given value. * * @param i the index * @param newValue the new value * @since 1.6 */ public final void lazySet(int i, long newValue) &#123; unsafe.putOrderedLong(array, checkedByteOffset(i), newValue); &#125; /** * Atomically sets the element at position &#123;@code i&#125; to the given value * and returns the old value. * * @param i the index * @param newValue the new value * @return the previous value */ public final long getAndSet(int i, long newValue) &#123; long offset = checkedByteOffset(i); while (true) &#123; long current = getRaw(offset); if (compareAndSetRaw(offset, current, newValue)) return current; &#125; &#125; /** * Atomically sets the element at position &#123;@code i&#125; to the given * updated value if the current value &#123;@code ==&#125; the expected value. * * @param i the index * @param expect the expected value * @param update the new value * @return true if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(int i, long expect, long update) &#123; return compareAndSetRaw(checkedByteOffset(i), expect, update); &#125; private boolean compareAndSetRaw(long offset, long expect, long update) &#123; return unsafe.compareAndSwapLong(array, offset, expect, update); &#125; /** * Atomically sets the element at position &#123;@code i&#125; to the given * updated value if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;May &lt;a href="package-summary.html#Spurious"&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to &#123;@code compareAndSet&#125;. * * @param i the index * @param expect the expected value * @param update the new value * @return true if successful. */ public final boolean weakCompareAndSet(int i, long expect, long update) &#123; return compareAndSet(i, expect, update); &#125; /** * Atomically increments by one the element at index &#123;@code i&#125;. * * @param i the index * @return the previous value */ public final long getAndIncrement(int i) &#123; return getAndAdd(i, 1); &#125; /** * Atomically decrements by one the element at index &#123;@code i&#125;. * * @param i the index * @return the previous value */ public final long getAndDecrement(int i) &#123; return getAndAdd(i, -1); &#125; /** * Atomically adds the given value to the element at index &#123;@code i&#125;. * * @param i the index * @param delta the value to add * @return the previous value */ public final long getAndAdd(int i, long delta) &#123; long offset = checkedByteOffset(i); while (true) &#123; long current = getRaw(offset); if (compareAndSetRaw(offset, current, current + delta)) return current; &#125; &#125; /** * Atomically increments by one the element at index &#123;@code i&#125;. * * @param i the index * @return the updated value */ public final long incrementAndGet(int i) &#123; return addAndGet(i, 1); &#125; /** * Atomically decrements by one the element at index &#123;@code i&#125;. * * @param i the index * @return the updated value */ public final long decrementAndGet(int i) &#123; return addAndGet(i, -1); &#125; /** * Atomically adds the given value to the element at index &#123;@code i&#125;. * * @param i the index * @param delta the value to add * @return the updated value */ public long addAndGet(int i, long delta) &#123; long offset = checkedByteOffset(i); while (true) &#123; long current = getRaw(offset); long next = current + delta; if (compareAndSetRaw(offset, current, next)) return next; &#125; &#125; /** * Returns the String representation of the current values of array. * @return the String representation of the current values of array */ public String toString() &#123; int iMax = array.length - 1; if (iMax == -1) return "[]"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123; b.append(getRaw(byteOffset(i))); if (i == iMax) return b.append(']').toString(); b.append(',').append(' '); &#125; &#125;&#125; AtomicLongArray 的代码很简单，下面仅以 incrementAndGet() 为例，对 AtomicLongArray 的原理进行说明。incrementAndGet() 源码如下： 123public final long incrementAndGet(int i) &#123; return addAndGet(i, 1);&#125; 说明：incrementAndGet() 的作用是以原子方式将 long 数组的索引 i 的元素加 1，并返回加 1 之后的值。 addAndGet() 源码如下： 12345678910111213public long addAndGet(int i, long delta) &#123; // 检查数组是否越界 long offset = checkedByteOffset(i); while (true) &#123; // 获取long型数组的索引 offset 的原始值 long current = getRaw(offset); // 修改long型值 long next = current + delta; // 通过CAS更新long型数组的索引 offset的值。 if (compareAndSetRaw(offset, current, next)) return next; &#125;&#125; 说明：addAndGet() 首先检查数组是否越界。如果没有越界的话，则先获取数组索引 i 的值；然后通过 CAS 函数更新 i 的值。 getRaw() 源码如下： 123private long getRaw(long offset) &#123; return unsafe.getLongVolatile(array, offset);&#125; 说明：unsafe 是通过 Unsafe.getUnsafe() 返回的一个 Unsafe 对象。通过 Unsafe 的 CAS 函数对 long 型数组的元素进行原子操作。如 compareAndSetRaw() 就是调用 Unsafe 的 CAS 函数，它的源码如下： 123private boolean compareAndSetRaw(long offset, long expect, long update) &#123; return unsafe.compareAndSwapLong(array, offset, expect, update);&#125; AtomicLongArray 示例123456789101112131415161718192021222324252627 // LongArrayTest.java的源码import java.util.concurrent.atomic.AtomicLongArray;public class LongArrayTest &#123; public static void main(String[] args)&#123; // 新建AtomicLongArray对象 long[] arrLong = new long[] &#123;10, 20, 30, 40, 50&#125;; AtomicLongArray ala = new AtomicLongArray(arrLong); ala.set(0, 100); for (int i=0, len=ala.length(); i&lt;len; i++) System.out.printf("get(%d) : %s\n", i, ala.get(i)); System.out.printf("%20s : %s\n", "getAndDecrement(0)", ala.getAndDecrement(0)); System.out.printf("%20s : %s\n", "decrementAndGet(1)", ala.decrementAndGet(1)); System.out.printf("%20s : %s\n", "getAndIncrement(2)", ala.getAndIncrement(2)); System.out.printf("%20s : %s\n", "incrementAndGet(3)", ala.incrementAndGet(3)); System.out.printf("%20s : %s\n", "addAndGet(100)", ala.addAndGet(0, 100)); System.out.printf("%20s : %s\n", "getAndAdd(100)", ala.getAndAdd(1, 100)); System.out.printf("%20s : %s\n", "compareAndSet()", ala.compareAndSet(2, 31, 1000)); System.out.printf("%20s : %s\n", "get(2)", ala.get(2)); &#125;&#125; 运行结果： 12345678910111213get(0) : 100get(1) : 20get(2) : 30get(3) : 40get(4) : 50 getAndDecrement(0) : 100 decrementAndGet(1) : 19 getAndIncrement(2) : 30 incrementAndGet(3) : 41 addAndGet(100) : 199 getAndAdd(100) : 19 compareAndSet() : true get(2) : 1000 04 AtomicReference原子类概要本章对 AtomicReference 引用类型的原子类进行介绍。内容包括：AtomicReference 介绍和函数列表AtomicReference 源码分析 (基于 JDK1.7.0_40)AtomicReference 示例 AtomicReference 介绍和函数列表AtomicReference 的作用是对 “对象” 进行原子操作。 AtomicReference 函数列表 12345678910111213141516171819// 使用 null 初始值创建新的 AtomicReference。AtomicReference()// 使用给定的初始值创建新的 AtomicReference。AtomicReference(V initialValue)// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean compareAndSet(V expect, V update)// 获取当前值。V get()// 以原子方式设置为给定值，并返回旧值。V getAndSet(V newValue)// 最终设置为给定值。void lazySet(V newValue)// 设置为给定值。void set(V newValue)// 返回当前值的字符串表示形式。String toString()// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean weakCompareAndSet(V expect, V update) AtomicReference 源码分析 (基于 JDK1.7.0_40)在 JDK1.7.0_40 中 AtomicReference.java 的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123; private static final long serialVersionUID = -1848883965231344442L; // 获取Unsafe对象，Unsafe的作用是提供CAS操作 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // volatile类型 private volatile V value; public AtomicReference(V initialValue) &#123; value = initialValue; &#125; public AtomicReference() &#123; &#125; public final V get() &#123; return value; &#125; public final void set(V newValue) &#123; value = newValue; &#125; public final void lazySet(V newValue) &#123; unsafe.putOrderedObject(this, valueOffset, newValue); &#125; public final boolean compareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update); &#125; public final boolean weakCompareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update); &#125; public final V getAndSet(V newValue) &#123; while (true) &#123; V x = get(); if (compareAndSet(x, newValue)) return x; &#125; &#125; public String toString() &#123; return String.valueOf(get()); &#125;&#125; 说明：AtomicReference 的源码比较简单。它是通过 “volatile” 和 “Unsafe 提供的 CAS 函数实现” 原子操作。(01) value 是 volatile 类型。这保证了：当某线程修改 value 的值时，其他线程看到的 value 值都是最新的 value 值，即修改之后的 volatile 的值。(02) 通过 CAS 设置 value。这保证了：当某线程池通过 CAS 函数 (如 compareAndSet 函数) 设置 value 时，它的操作是原子的，即线程在操作 value 时不会被中断。 AtomicReference 示例123456789101112131415161718192021222324252627282930// AtomicReferenceTest.java的源码import java.util.concurrent.atomic.AtomicReference;public class AtomicReferenceTest &#123; public static void main(String[] args)&#123; // 创建两个Person对象，它们的id分别是101和102。 Person p1 = new Person(101); Person p2 = new Person(102); // 新建AtomicReference对象，初始化它的值为p1对象 AtomicReference ar = new AtomicReference(p1); // 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。 ar.compareAndSet(p1, p2); Person p3 = (Person)ar.get(); System.out.println("p3 is "+p3); System.out.println("p3.equals(p1)="+p3.equals(p1)); &#125;&#125;class Person &#123; volatile long id; public Person(long id) &#123; this.id = id; &#125; public String toString() &#123; return "id:"+id; &#125;&#125; 运行结果： 12p3 is id:102p3.equals(p1)=false 结果说明：新建 AtomicReference 对象 ar 时，将它初始化为 p1。紧接着，通过 CAS 函数对它进行设置。如果 ar 的值为 p1 的话，则将其设置为 p2。最后，获取 ar 对应的对象，并打印结果。p3.equals(p1) 的结果为 false，这是因为 Person 并没有覆盖 equals() 方法，而是采用继承自 Object.java 的 equals() 方法；而 Object.java 中的 equals() 实际上是调用 “==” 去比较两个对象，即比较两个对象的地址是否相等。 05 AtomicLongFieldUpdater原子类概要AtomicIntegerFieldUpdater, AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater 这 3 个修改类的成员的原子类型的原理和用法相似。本章以对基本类型的原子类进行介绍。内容包括：AtomicLongFieldUpdater 介绍和函数列表AtomicLongFieldUpdater 源码分析 (基于 JDK1.7.0_40)AtomicLongFieldUpdater 示例 转载请注明出处：http://www.cnblogs.com/skywang12345/p/3514623.html AtomicLongFieldUpdater 介绍和函数列表AtomicLongFieldUpdater 可以对指定 “类的’volatile long’类型的成员” 进行原子更新。它是基于反射原理实现的。 AtomicLongFieldUpdater 函数列表 1234567891011121314151617181920212223242526272829// 受保护的无操作构造方法，供子类使用。protected AtomicLongFieldUpdater()// 以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值。long addAndGet(T obj, long delta)// 如果当前值 == 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值。abstract boolean compareAndSet(T obj, long expect, long update)// 以原子方式将此更新器管理的给定对象字段当前值减 1。long decrementAndGet(T obj)// 获取此更新器管理的在给定对象的字段中保持的当前值。abstract long get(T obj)// 以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值。long getAndAdd(T obj, long delta)// 以原子方式将此更新器管理的给定对象字段当前值减 1。long getAndDecrement(T obj)// 以原子方式将此更新器管理的给定对象字段的当前值加 1。long getAndIncrement(T obj)// 将此更新器管理的给定对象的字段以原子方式设置为给定值，并返回旧值。long getAndSet(T obj, long newValue)// 以原子方式将此更新器管理的给定对象字段当前值加 1。long incrementAndGet(T obj)// 最后将此更新器管理的给定对象的字段设置为给定更新值。abstract void lazySet(T obj, long newValue)// 为对象创建并返回一个具有给定字段的更新器。static &lt;U&gt; AtomicLongFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName)// 将此更新器管理的给定对象的字段设置为给定更新值。abstract void set(T obj, long newValue)// 如果当前值 == 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值。abstract boolean weakCompareAndSet(T obj, long expect, long update) AtomicLongFieldUpdater 源码分析 (基于 JDK1.7.0_40)AtomicLongFieldUpdater 完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284/* * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. *//* * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */package java.util.concurrent.atomic;import java.lang.reflect.*;import sun.misc.Unsafe;import sun.reflect.CallerSensitive;import sun.reflect.Reflection;/** * A reflection-based utility that enables atomic updates to * designated &#123;@code volatile&#125; reference fields of designated * classes. This class is designed for use in atomic data structures * in which several reference fields of the same node are * independently subject to atomic updates. For example, a tree node * might be declared as * * &lt;pre&gt; &#123;@code * class Node &#123; * private volatile Node left, right; * * private static final AtomicReferenceFieldUpdater&lt;Node, Node&gt; leftUpdater = * AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "left"); * private static AtomicReferenceFieldUpdater&lt;Node, Node&gt; rightUpdater = * AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "right"); * * Node getLeft() &#123; return left; &#125; * boolean compareAndSetLeft(Node expect, Node update) &#123; * return leftUpdater.compareAndSet(this, expect, update); * &#125; * // ... and so on * &#125;&#125;&lt;/pre&gt; * * &lt;p&gt;Note that the guarantees of the &#123;@code compareAndSet&#125; * method in this class are weaker than in other atomic classes. * Because this class cannot ensure that all uses of the field * are appropriate for purposes of atomic access, it can * guarantee atomicity only with respect to other invocations of * &#123;@code compareAndSet&#125; and &#123;@code set&#125; on the same updater. * * @since 1.5 * @author Doug Lea * @param &lt;T&gt; The type of the object holding the updatable field * @param &lt;V&gt; The type of the field */public abstract class AtomicReferenceFieldUpdater&lt;T, V&gt; &#123; /** * Creates and returns an updater for objects with the given field. * The Class arguments are needed to check that reflective types and * generic types match. * * @param tclass the class of the objects holding the field. * @param vclass the class of the field * @param fieldName the name of the field to be updated. * @return the updater * @throws IllegalArgumentException if the field is not a volatile reference type. * @throws RuntimeException with a nested reflection-based * exception if the class does not hold field or is the wrong type. */ @CallerSensitive public static &lt;U, W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; newUpdater(Class&lt;U&gt; tclass, Class&lt;W&gt; vclass, String fieldName) &#123; return new AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;(tclass, vclass, fieldName, Reflection.getCallerClass()); &#125; /** * Protected do-nothing constructor for use by subclasses. */ protected AtomicReferenceFieldUpdater() &#123; &#125; /** * Atomically sets the field of the given object managed by this updater * to the given updated value if the current value &#123;@code ==&#125; the * expected value. This method is guaranteed to be atomic with respect to * other calls to &#123;@code compareAndSet&#125; and &#123;@code set&#125;, but not * necessarily with respect to other changes in the field. * * @param obj An object whose field to conditionally set * @param expect the expected value * @param update the new value * @return true if successful. */ public abstract boolean compareAndSet(T obj, V expect, V update); /** * Atomically sets the field of the given object managed by this updater * to the given updated value if the current value &#123;@code ==&#125; the * expected value. This method is guaranteed to be atomic with respect to * other calls to &#123;@code compareAndSet&#125; and &#123;@code set&#125;, but not * necessarily with respect to other changes in the field. * * &lt;p&gt;May &lt;a href="package-summary.html#Spurious"&gt;fail spuriously&lt;/a&gt; * and does not provide ordering guarantees, so is only rarely an * appropriate alternative to &#123;@code compareAndSet&#125;. * * @param obj An object whose field to conditionally set * @param expect the expected value * @param update the new value * @return true if successful. */ public abstract boolean weakCompareAndSet(T obj, V expect, V update); /** * Sets the field of the given object managed by this updater to the * given updated value. This operation is guaranteed to act as a volatile * store with respect to subsequent invocations of &#123;@code compareAndSet&#125;. * * @param obj An object whose field to set * @param newValue the new value */ public abstract void set(T obj, V newValue); /** * Eventually sets the field of the given object managed by this * updater to the given updated value. * * @param obj An object whose field to set * @param newValue the new value * @since 1.6 */ public abstract void lazySet(T obj, V newValue); /** * Gets the current value held in the field of the given object managed * by this updater. * * @param obj An object whose field to get * @return the current value */ public abstract V get(T obj); /** * Atomically sets the field of the given object managed by this updater * to the given value and returns the old value. * * @param obj An object whose field to get and set * @param newValue the new value * @return the previous value */ public V getAndSet(T obj, V newValue) &#123; for (;;) &#123; V current = get(obj); if (compareAndSet(obj, current, newValue)) return current; &#125; &#125; private static final class AtomicReferenceFieldUpdaterImpl&lt;T,V&gt; extends AtomicReferenceFieldUpdater&lt;T,V&gt; &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private final long offset; private final Class&lt;T&gt; tclass; private final Class&lt;V&gt; vclass; private final Class cclass; /* * Internal type checks within all update methods contain * internal inlined optimizations checking for the common * cases where the class is final (in which case a simple * getClass comparison suffices) or is of type Object (in * which case no check is needed because all objects are * instances of Object). The Object case is handled simply by * setting vclass to null in constructor. The targetCheck and * updateCheck methods are invoked when these faster * screenings fail. */ AtomicReferenceFieldUpdaterImpl(Class&lt;T&gt; tclass, Class&lt;V&gt; vclass, String fieldName, Class&lt;?&gt; caller) &#123; Field field = null; Class fieldClass = null; int modifiers = 0; try &#123; field = tclass.getDeclaredField(fieldName); modifiers = field.getModifiers(); sun.reflect.misc.ReflectUtil.ensureMemberAccess( caller, tclass, null, modifiers); sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass); fieldClass = field.getType(); &#125; catch (Exception ex) &#123; throw new RuntimeException(ex); &#125; if (vclass != fieldClass) throw new ClassCastException(); if (!Modifier.isVolatile(modifiers)) throw new IllegalArgumentException("Must be volatile type"); this.cclass = (Modifier.isProtected(modifiers) &amp;&amp; caller != tclass) ? caller : null; this.tclass = tclass; if (vclass == Object.class) this.vclass = null; else this.vclass = vclass; offset = unsafe.objectFieldOffset(field); &#125; void targetCheck(T obj) &#123; if (!tclass.isInstance(obj)) throw new ClassCastException(); if (cclass != null) ensureProtectedAccess(obj); &#125; void updateCheck(T obj, V update) &#123; if (!tclass.isInstance(obj) || (update != null &amp;&amp; vclass != null &amp;&amp; !vclass.isInstance(update))) throw new ClassCastException(); if (cclass != null) ensureProtectedAccess(obj); &#125; public boolean compareAndSet(T obj, V expect, V update) &#123; if (obj == null || obj.getClass() != tclass || cclass != null || (update != null &amp;&amp; vclass != null &amp;&amp; vclass != update.getClass())) updateCheck(obj, update); return unsafe.compareAndSwapObject(obj, offset, expect, update); &#125; public boolean weakCompareAndSet(T obj, V expect, V update) &#123; // same implementation as strong form for now if (obj == null || obj.getClass() != tclass || cclass != null || (update != null &amp;&amp; vclass != null &amp;&amp; vclass != update.getClass())) updateCheck(obj, update); return unsafe.compareAndSwapObject(obj, offset, expect, update); &#125; public void set(T obj, V newValue) &#123; if (obj == null || obj.getClass() != tclass || cclass != null || (newValue != null &amp;&amp; vclass != null &amp;&amp; vclass != newValue.getClass())) updateCheck(obj, newValue); unsafe.putObjectVolatile(obj, offset, newValue); &#125; public void lazySet(T obj, V newValue) &#123; if (obj == null || obj.getClass() != tclass || cclass != null || (newValue != null &amp;&amp; vclass != null &amp;&amp; vclass != newValue.getClass())) updateCheck(obj, newValue); unsafe.putOrderedObject(obj, offset, newValue); &#125; public V get(T obj) &#123; if (obj == null || obj.getClass() != tclass || cclass != null) targetCheck(obj); return (V)unsafe.getObjectVolatile(obj, offset); &#125; private void ensureProtectedAccess(T obj) &#123; if (cclass.isInstance(obj)) &#123; return; &#125; throw new RuntimeException( new IllegalAccessException("Class " + cclass.getName() + " can not access a protected member of class " + tclass.getName() + " using an instance of " + obj.getClass().getName() ) ); &#125; &#125;&#125; 下面分析 LongFieldTest.java 的流程。 1. newUpdater()newUpdater() 的源码如下： 1234567public static &lt;U&gt; AtomicLongFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); if (AtomicLong.VM_SUPPORTS_LONG_CAS) return new CASUpdater&lt;U&gt;(tclass, fieldName, caller); else return new LockedUpdater&lt;U&gt;(tclass, fieldName, caller);&#125; 说明：newUpdater() 的作用是获取一个 AtomicIntegerFieldUpdater 类型的对象。它实际上返回的是 CASUpdater 对象，或者 LockedUpdater 对象；具体返回哪一个类取决于 JVM 是否支持 long 类型的 CAS 函数。CASUpdater 和 LockedUpdater 都是 AtomicIntegerFieldUpdater 的子类，它们的实现类似。下面以 CASUpdater 来进行说明。 CASUpdater 类的源码如下： 1234public boolean compareAndSet(T obj, long expect, long update) &#123; if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj); return unsafe.compareAndSwapLong(obj, offset, expect, update);&#125; 说明：它实际上是通过 CAS 函数操作。如果类的 long 对象的值是 expect，则设置它的值为 update。 AtomicLongFieldUpdater 示例123456789101112131415161718192021222324252627282930// LongTest.java的源码import java.util.concurrent.atomic.AtomicLongFieldUpdater;public class LongFieldTest &#123; public static void main(String[] args) &#123; // 获取Person的class对象 Class cls = Person.class; // 新建AtomicLongFieldUpdater对象，传递参数是“class对象”和“long类型在类中对应的名称” AtomicLongFieldUpdater mAtoLong = AtomicLongFieldUpdater.newUpdater(cls, "id"); Person person = new Person(12345678L); // 比较person的"id"属性，如果id的值为12345678L，则设置为1000。 mAtoLong.compareAndSet(person, 12345678L, 1000); System.out.println("id="+person.getId()); &#125;&#125;class Person &#123; volatile long id; public Person(long id) &#123; this.id = id; &#125; public void setId(long id) &#123; this.id = id; &#125; public long getId() &#123; return id; &#125;&#125; 运行结果： 1id=1000 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程系列一：基础篇]]></title>
    <url>%2F2018%2F03%2F23%2F2018-03-23-1%2F</url>
    <content type="text"><![CDATA[01 基本概念多线程是 Java 中不可避免的一个重要主体。从本章开始，我们将展开对多线程的学习。接下来的内容，是对 “JDK 中新增 JUC 包” 之前的 Java 多线程内容的讲解，涉及到的内容包括，Object 类中的 wait(), notify()等接口；Thread 类中的接口；synchronized 关键字。 注：JUC 包是指，Java.util.concurrent 包，它是由 Java 大师 Doug Lea 完成并在 JDK1.5 版本添加到 Java 中的 在进入后面章节的学习之前，先了解一些多线程的相关概念。线程状态图 说明：线程共包括以下 5 种状态。1. 新建状态 (New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。2. 就绪状态 (Runnable): 也被称为 “可执行状态”。线程对象被创建后，其它线程调用了该对象的 start() 方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被 CPU 调度执行。3. 运行状态 (Running) : 线程获取 CPU 权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。4. 阻塞状态 (Blocked) : 阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： (01) 等待阻塞 – 通过调用线程的 wait() 方法，让线程等待某工作的完成。 (02) 同步阻塞 – 线程在获取 synchronized 同步锁失败 (因为锁被其它线程所占用)，它会进入同步阻塞状态。 (03) 其他阻塞 – 通过调用线程的 sleep() 或 join() 或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。5. 死亡状态 (Dead) : 线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期。 这 5 种状态涉及到的内容包括 Object 类, Thread 和 synchronized 关键字。这些内容我们会在后面的章节中逐个进行学习。Object 类，定义了 wait(), notify(), notifyAll() 等休眠 / 唤醒函数。Thread 类，定义了一些列的线程操作函数。例如，sleep() 休眠函数, interrupt() 中断函数, getName() 获取线程名称等。synchronized，是关键字；它区分为 synchronized 代码块和 synchronized 方法。synchronized 的作用是让线程获取对象的同步锁。在后面详细介绍 wait(),notify()等方法时，我们会分析为什么 “wait(), notify() 等方法要定义在 Object 类，而不是 Thread 类中”。 02 常用的实现多线程的两种方式概要本章，我们学习 “常用的实现多线程的 2 种方式”：Thread 和 Runnable。之所以说是常用的，是因为通过还可以通过 java.util.concurrent 包中的线程池来实现多线程。关于线程池的内容，我们以后会详细介绍；现在，先对的 Thread 和 Runnable 进行了解。本章内容包括：Thread 和 Runnable 的简介Thread 和 Runnable 的异同点Thread 和 Runnable 的多线程的示例 Thread 和 Runnable 简介Runnable 是一个接口，该接口中只包含了一个 run() 方法。它的定义如下： 123public interface Runnable &#123; public abstract void run();&#125; Runnable 的作用，实现多线程。我们可以定义一个类 A 实现 Runnable 接口；然后，通过 new Thread(new A()) 等方式新建线程。 Thread 是一个类。Thread 本身就实现了 Runnable 接口。它的声明如下： 1public class Thread implements Runnable &#123;&#125; Thread 的作用，实现多线程。 Thread 和 Runnable 的异同点Thread 和 Runnable 的相同点：都是 “多线程的实现方式”。Thread 和 Runnable 的不同点：Thread 是类，而 Runnable 是接口；Thread 本身是实现了 Runnable 接口的类。我们知道 “一个类只能有一个父类，但是却能实现多个接口”，因此 Runnable 具有更好的扩展性。此外，Runnable 还可以用于 “资源的共享”。即，多个线程都是基于某一个 Runnable 对象建立的，它们会共享 Runnable 对象上的资源。通常，建议通过 “Runnable” 实现多线程！ Thread 和 Runnable 的多线程示例1. Thread 的多线程示例下面通过示例更好的理解 Thread 和 Runnable，借鉴网上一个例子比较具有说服性的例子。 1234567891011121314151617181920212223// ThreadTest.java 源码class MyThread extends Thread&#123; private int ticket=10; public void run()&#123; for(int i=0;i&lt;20;i++)&#123; if(this.ticket&gt;0)&#123; System.out.println(this.getName()+" 卖票：ticket"+this.ticket--); &#125; &#125; &#125; &#125;;public class ThreadTest &#123; public static void main(String[] args) &#123; // 启动3个线程t1,t2,t3；每个线程各卖10张票！ MyThread t1=new MyThread(); MyThread t2=new MyThread(); MyThread t3=new MyThread(); t1.start(); t2.start(); t3.start(); &#125; &#125; 运行结果： 123456789101112131415161718192021222324252627282930Thread-0 卖票：ticket10Thread-1 卖票：ticket10Thread-2 卖票：ticket10Thread-1 卖票：ticket9Thread-0 卖票：ticket9Thread-1 卖票：ticket8Thread-2 卖票：ticket9Thread-1 卖票：ticket7Thread-0 卖票：ticket8Thread-1 卖票：ticket6Thread-2 卖票：ticket8Thread-1 卖票：ticket5Thread-0 卖票：ticket7Thread-1 卖票：ticket4Thread-2 卖票：ticket7Thread-1 卖票：ticket3Thread-0 卖票：ticket6Thread-1 卖票：ticket2Thread-2 卖票：ticket6Thread-2 卖票：ticket5Thread-2 卖票：ticket4Thread-1 卖票：ticket1Thread-0 卖票：ticket5Thread-2 卖票：ticket3Thread-0 卖票：ticket4Thread-2 卖票：ticket2Thread-0 卖票：ticket3Thread-2 卖票：ticket1Thread-0 卖票：ticket2Thread-0 卖票：ticket1 结果说明： (01) MyThread 继承于 Thread，它是自定义个线程。每个 MyThread 都会卖出 10 张票。(02) 主线程 main 创建并启动 3 个 MyThread 子线程。每个子线程都各自卖出了 10 张票。 2. Runnable 的多线程示例下面，我们对上面的程序进行修改。通过 Runnable 实现一个接口，从而实现多线程。 12345678910111213141516171819202122232425// RunnableTest.java 源码class MyThread implements Runnable&#123; private int ticket=10; public void run()&#123; for(int i=0;i&lt;20;i++)&#123; if(this.ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+" 卖票：ticket"+this.ticket--); &#125; &#125; &#125; &#125;; public class RunnableTest &#123; public static void main(String[] args) &#123; MyThread mt=new MyThread(); // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！ Thread t1=new Thread(mt); Thread t2=new Thread(mt); Thread t3=new Thread(mt); t1.start(); t2.start(); t3.start(); &#125; &#125; 运行结果： 12345678910Thread-0 卖票：ticket10Thread-2 卖票：ticket8Thread-1 卖票：ticket9Thread-2 卖票：ticket6Thread-0 卖票：ticket7Thread-2 卖票：ticket4Thread-1 卖票：ticket5Thread-2 卖票：ticket2Thread-0 卖票：ticket3Thread-1 卖票：ticket1 结果说明：(01) 和上面 “MyThread 继承于 Thread” 不同；这里的 MyThread 实现了 Thread 接口。(02) 主线程 main 创建并启动 3 个子线程，而且这 3 个子线程都是基于 “mt 这个 Runnable 对象” 而创建的。运行结果是这 3 个子线程一共卖出了 10 张票。这说明它们是共享了 MyThread 接口的。 03 Thread中start()和run()的区别概要Thread 类包含 start() 和 run() 方法，它们的区别是什么？本章将对此作出解答。本章内容包括：start() 和 run() 的区别说明start() 和 run() 的区别示例start() 和 run() 相关源码 (基于 JDK1.7.0_40) start() 和 run() 的区别说明start() : 它的作用是启动一个新线程，新线程会执行相应的 run() 方法。start() 不能被重复调用。run() : run() 就和普通的成员方法一样，可以被重复调用。单独调用 run() 的话，会在当前线程中执行 run()，而并不会启动新线程！ 下面以代码来进行说明。 123456class MyThread extends Thread&#123; public void run()&#123; ... &#125; &#125;;MyThread mythread = new MyThread(); mythread.start() 会启动一个新线程，并在新线程中运行 run() 方法。而 mythread.run() 则会直接在当前线程中运行 run() 方法，并不会启动一个新线程来运行 run()。 start() 和 run() 的区别示例下面，通过一个简单示例演示它们之间的区别。源码如下： 12345678910111213141516171819202122// Demo.java 的源码class MyThread extends Thread&#123; public MyThread(String name) &#123; super(name); &#125; public void run()&#123; System.out.println(Thread.currentThread().getName()+" is running"); &#125; &#125;; public class Demo &#123; public static void main(String[] args) &#123; Thread mythread=new MyThread("mythread"); System.out.println(Thread.currentThread().getName()+" call mythread.run()"); mythread.run(); System.out.println(Thread.currentThread().getName()+" call mythread.start()"); mythread.start(); &#125; &#125; 运行结果： 1234main call mythread.run()main is runningmain call mythread.start()mythread is running 结果说明：(01) Thread.currentThread().getName()是用于获取 “当前线程” 的名字。当前线程是指正在 cpu 中调度执行的线程。(02) mythread.run()是在 “主线程 main” 中调用的，该 run()方法直接运行在 “主线程 main” 上。(03) mythread.start()会启动 “线程 mythread”，“线程 mythread” 启动之后，会调用 run()方法；此时的 run()方法是运行在 “线程 mythread” 上。 start() 和 run() 相关源码 (基于 JDK1.7.0_40)Thread.java 中 start() 方法的源码如下： 1234567891011121314151617181920212223public synchronized void start() &#123; // 如果线程不是"就绪状态"，则抛出异常！ if (threadStatus != 0) throw new IllegalThreadStateException(); // 将线程添加到ThreadGroup中 group.add(this); boolean started = false; try &#123; // 通过start0()启动线程 start0(); // 设置started标记 started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125;&#125; 说明：start() 实际上是通过本地方法 start0() 启动线程的。而 start0() 会新运行一个线程，新线程会调用 run() 方法。 1private native void start0(); Thread.java 中 run() 的代码如下： 12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 说明：target 是一个 Runnable 对象。run() 就是直接调用 Thread 线程的 Runnable 成员的 run() 方法，并不会新建一个线程。 04 synchronized关键字概要本章，会对 synchronized 关键字进行介绍。涉及到的内容包括：1. synchronized 原理2. synchronized 基本规则3. synchronized 方法 和 synchronized 代码块4. 实例锁 和 全局锁 1. synchronized 原理在 java 中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当我们调用某对象的 synchronized 方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了 “obj 这个对象” 的同步锁。不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对 “对象 / 方法” 的互斥访问。 例如，现在有两个线程 A 和线程 B，它们都会访问 “对象 obj 的同步锁”。假设，在某一时刻，线程 A 获取到“obj 的同步锁” 并在执行一些操作；而此时，线程 B 也企图获取 “obj 的同步锁” —— 线程 B 会获取失败，它必须等待，直到线程 A 释放了“该对象的同步锁” 之后线程 B 才能获取到 “obj 的同步锁” 从而才可以运行。 2. synchronized 基本规则我们将 synchronized 的基本规则总结为下面 3 条，并通过实例对它们进行说明。 第一条: 当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程对 “该对象”的该 “synchronized 方法” 或者 “synchronized 代码块” 的访问将被阻塞。 第二条: 当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程仍然可以访问 “该对象” 的非同步代码块。 第三条: 当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程对 “该对象”的其他的 “synchronized 方法” 或者 “synchronized 代码块” 的访问将被阻塞。 第一条当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程对 “该对象” 的该 “synchronized 方法” 或者 “synchronized 代码块” 的访问将被阻塞。下面是 “synchronized 代码块” 对应的演示程序。 1234567891011121314151617181920212223242526 class MyRunable implements Runnable &#123; //注意这里是implements实现 @Override public void run() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125;public class Demo1_1 &#123; public static void main(String[] args) &#123; Runnable demo = new MyRunable(); // 新建“Runnable对象” Thread t1 = new Thread(demo, "t1"); // 新建“线程t1”, t1是基于demo这个Runnable对象 Thread t2 = new Thread(demo, "t2"); // 新建“线程t2”, t2是基于demo这个Runnable对象 t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” &#125; &#125; 运行结果： 12345678910t1 loop 0t1 loop 1t1 loop 2t1 loop 3t1 loop 4t2 loop 0t2 loop 1t2 loop 2t2 loop 3t2 loop 4 结果说明：run()方法中存在 “synchronized(this) 代码块”，而且 t1 和 t2 都是基于 “demo 这个 Runnable 对象” 创建的线程。这就意味着，我们可以将 synchronized(this)中的 this 看作是 “demo 这个 Runnable 对象”；因此，线程 t1 和 t2 共享“demo 对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程” 释放 “demo 的同步锁” 之后才能运行。 如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下： 1234567891011121314151617181920212223242526272829class MyThread extends Thread &#123; //注意这里是extends继承 public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125;public class Demo1_2 &#123; public static void main(String[] args) &#123; Thread t1 = new MyThread("t1"); // 新建“线程t1” Thread t2 = new MyThread("t2"); // 新建“线程t2” t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” &#125; &#125; 代码说明：比较 Demo1_2 和 Demo1_1，我们发现，Demo1_2 中的 MyThread 类是直接继承于 Thread，而且 t1 和 t2 都是 MyThread 子线程。幸运的是，在 “Demo1_2 的 run() 方法”也调用了 synchronized(this)，正如 “Demo1_1 的 run() 方法”也调用了 synchronized(this)一样！那么，Demo1_2 的执行流程是不是和 Demo1_1 一样呢？运行结果： 12345678910t1 loop 0t2 loop 0t1 loop 1t2 loop 1t1 loop 2t2 loop 2t1 loop 3t2 loop 3t1 loop 4t2 loop 4 结果说明：如果这个结果一点也不令你感到惊讶，那么我相信你对 synchronized 和 this 的认识已经比较深刻了。否则的话，请继续阅读这里的分析。synchronized(this)中的 this 是指 “当前的类对象”，即 synchronized(this) 所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。对于 Demo1_2 中，synchronized(this) 中的 this 代表的是 MyThread 对象，而 t1 和 t2 是两个不同的 MyThread 对象，因此 t1 和 t2 在执行 synchronized(this) 时，获取的是不同对象的同步锁。对于 Demo1_1 对而言，synchronized(this) 中的 this 代表的是 MyRunable 对象；t1 和 t2 共同一个 MyRunable 对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。 第二条当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程仍然可以访问 “该对象” 的非同步代码块。下面是 “synchronized 代码块” 对应的演示程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Count &#123; // 含有synchronized同步块的方法 public void synMethod() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " synMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; // 非同步的方法 public void nonSynMethod() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " nonSynMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class Demo2 &#123; public static void main(String[] args) &#123; final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.synMethod(); &#125; &#125;, "t1"); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.nonSynMethod(); &#125; &#125;, "t2"); t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125; 运行结果： 12345678910t1 synMethod loop 0t2 nonSynMethod loop 0t1 synMethod loop 1t2 nonSynMethod loop 1t1 synMethod loop 2t2 nonSynMethod loop 2t1 synMethod loop 3t2 nonSynMethod loop 3t1 synMethod loop 4t2 nonSynMethod loop 4 结果说明：主线程中新建了两个子线程 t1 和 t2。t1 会调用 count 对象的 synMethod()方法，该方法内含有同步块；而 t2 则会调用 count 对象的 nonSynMethod()方法，该方法不是同步方法。t1 运行时，虽然调用 synchronized(this)获取 “count 的同步锁”；但是并没有造成 t2 的阻塞，因为 t2 没有用到“count” 同步锁。 第三条当一个线程访问 “某对象” 的“synchronized 方法”或者 “synchronized 代码块” 时，其他线程对 “该对象” 的其他的 “synchronized 方法” 或者 “synchronized 代码块” 的访问将被阻塞。我们将上面的例子中的 nonSynMethod() 方法体的也用 synchronized(this) 修饰。修改后的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 class Count &#123; // 含有synchronized同步块的方法 public void synMethod() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " synMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; // 也包含synchronized同步块的方法 public void nonSynMethod() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " nonSynMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125;public class Demo3 &#123; public static void main(String[] args) &#123; final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.synMethod(); &#125; &#125;, "t1"); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.nonSynMethod(); &#125; &#125;, "t2"); t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125; 运行结果： 12345678910t1 synMethod loop 0t1 synMethod loop 1t1 synMethod loop 2t1 synMethod loop 3t1 synMethod loop 4t2 nonSynMethod loop 0t2 nonSynMethod loop 1t2 nonSynMethod loop 2t2 nonSynMethod loop 3t2 nonSynMethod loop 4 结果说明：主线程中新建了两个子线程 t1 和 t2。t1 和 t2 运行时都调用 synchronized(this)，这个 this 是 Count 对象 (count)，而 t1 和 t2 共用 count。因此，在 t1 运行时，t2 会被阻塞，等待 t1 运行释放 “count 对象的同步锁”，t2 才能运行。 3. synchronized 方法 和 synchronized 代码块“synchronized 方法” 是用 synchronized 修饰方法，而 “synchronized 代码块” 则是用 synchronized 修饰代码块。 synchronized 方法示例 123public synchronized void foo1() &#123; System.out.println("synchronized methoed");&#125; synchronized 代码块 12345public void foo2() &#123; synchronized (this) &#123; System.out.println("synchronized methoed"); &#125;&#125; synchronized 代码块中的 this 是指当前对象。也可以将 this 替换成其他对象，例如将 this 替换成 obj，则 foo2() 在执行 synchronized(obj) 时就获取的是 obj 的同步锁。 synchronized 代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示： 123456789101112131415161718192021222324252627282930// Demo4.java的源码public class Demo4 &#123; public synchronized void synMethod() &#123; for(int i=0; i&lt;1000000; i++) ; &#125; public void synBlock() &#123; synchronized( this ) &#123; for(int i=0; i&lt;1000000; i++) ; &#125; &#125; public static void main(String[] args) &#123; Demo4 demo = new Demo4(); long start, diff; start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synMethod(); // 调用“synchronized方法” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println("synMethod() : "+ diff); start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synBlock(); // 调用“synchronized方法块” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println("synBlock() : "+ diff); &#125;&#125; (某一次) 执行结果： 12synMethod() : 11synBlock() : 3 4. 实例锁 和 全局锁实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。实例锁对应的就是 synchronized 关键字。全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 全局锁对应的就是 static synchronized（或者是锁在该类的 class 或者 classloader 对象上）。 关于 “实例锁” 和“全局锁”有一个很形象的例子： 123456pulbic class Something &#123; public synchronized void isSyncA()&#123;&#125; public synchronized void isSyncB()&#123;&#125; public static synchronized void cSyncA()&#123;&#125; public static synchronized void cSyncB()&#123;&#125;&#125; 假设，Something 有两个实例 x 和 y。分析下面 4 组表达式获取的锁的情况。(01) x.isSyncA() 与 x.isSyncB()(02) x.isSyncA() 与 y.isSyncA()(03) x.cSyncA() 与 y.cSyncB()(04) x.isSyncA() 与 Something.cSyncA() (01) 不能被同时访问。因为 isSyncA()和 isSyncB()都是访问同一个对象 (对象 x) 的同步锁！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// LockTest1.java的源码class Something &#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class LockTest1 &#123; Something x = new Something(); Something y = new Something(); // 比较(01) x.isSyncA()与x.isSyncB() private void test1() &#123; // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncA(); &#125; &#125;, "t11"); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncB(); &#125; &#125;, "t12"); t11.start(); // 启动t11 t12.start(); // 启动t12 &#125; public static void main(String[] args) &#123; LockTest1 demo = new LockTest1(); demo.test1(); &#125;&#125; 运行结果： 12345678910t11 : isSyncAt11 : isSyncAt11 : isSyncAt11 : isSyncAt11 : isSyncAt12 : isSyncBt12 : isSyncBt12 : isSyncBt12 : isSyncBt12 : isSyncB (02) 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA() 访问的是 x 的同步锁，而 y.isSyncA() 访问的是 y 的同步锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 // LockTest2.java的源码class Something &#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class LockTest2 &#123; Something x = new Something(); Something y = new Something(); // 比较(02) x.isSyncA()与y.isSyncA() private void test2() &#123; // 新建t21, t21会调用 x.isSyncA() Thread t21 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncA(); &#125; &#125;, "t21"); // 新建t22, t22会调用 x.isSyncB() Thread t22 = new Thread( new Runnable() &#123; @Override public void run() &#123; y.isSyncA(); &#125; &#125;, "t22"); t21.start(); // 启动t21 t22.start(); // 启动t22 &#125; public static void main(String[] args) &#123; LockTest2 demo = new LockTest2(); demo.test2(); &#125;&#125; 运行结果： 12345678910t21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncA (03) 不能被同时访问。因为 cSyncA() 和 cSyncB() 都是 static 类型，x.cSyncA() 相当于 Something.isSyncA()，y.cSyncB() 相当于 Something.isSyncB()，因此它们共用一个同步锁，不能被同时访问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// LockTest3.java的源码class Something &#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class LockTest3 &#123; Something x = new Something(); Something y = new Something(); // 比较(03) x.cSyncA()与y.cSyncB() private void test3() &#123; // 新建t31, t31会调用 x.isSyncA() Thread t31 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.cSyncA(); &#125; &#125;, "t31"); // 新建t32, t32会调用 x.isSyncB() Thread t32 = new Thread( new Runnable() &#123; @Override public void run() &#123; y.cSyncB(); &#125; &#125;, "t32"); t31.start(); // 启动t31 t32.start(); // 启动t32 &#125; public static void main(String[] args) &#123; LockTest3 demo = new LockTest3(); demo.test3(); &#125;&#125; 运行结果： 12345678910t31 : cSyncAt31 : cSyncAt31 : cSyncAt31 : cSyncAt31 : cSyncAt32 : cSyncBt32 : cSyncBt32 : cSyncBt32 : cSyncBt32 : cSyncB (04) 可以被同时访问。因为 isSyncA() 是实例方法，x.isSyncA() 使用的是对象 x 的锁；而 cSyncA() 是静态方法，Something.cSyncA() 可以理解对使用的是 “类的锁”。因此，它们是可以被同时访问的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// LockTest4.java的源码class Something &#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;public class LockTest4 &#123; Something x = new Something(); Something y = new Something(); // 比较(04) x.isSyncA()与Something.cSyncA() private void test4() &#123; // 新建t41, t41会调用 x.isSyncA() Thread t41 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncA(); &#125; &#125;, "t41"); // 新建t42, t42会调用 x.isSyncB() Thread t42 = new Thread( new Runnable() &#123; @Override public void run() &#123; Something.cSyncA(); &#125; &#125;, "t42"); t41.start(); // 启动t41 t42.start(); // 启动t42 &#125; public static void main(String[] args) &#123; LockTest4 demo = new LockTest4(); demo.test4(); &#125;&#125; 运行结果： 12345678910t41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncA 05 线程等待与唤醒概要本章，会对线程等待 / 唤醒方法进行介绍。涉及到的内容包括：1. wait(), notify(), notifyAll() 等方法介绍2. wait() 和 notify()3. wait(long timeout) 和 notify()4. wait() 和 notifyAll()5. 为什么 notify(), wait() 等函数定义在 Object 中，而不是 Thread 中 1.wait(), notify(), notifyAll() 等方法介绍在 Object.java 中，定义了 wait(), notify() 和 notifyAll() 等接口。wait() 的作用是让当前线程进入等待状态，同时，wait() 也会让当前线程释放它所持有的锁。而 notify() 和 notifyAll() 的作用，则是唤醒当前对象上的等待线程；notify() 是唤醒单个线程，而 notifyAll() 是唤醒所有的线程。 Object 类中关于等待 / 唤醒的 API 详细信息如下：notify() – 唤醒在此对象监视器上等待的单个线程。notifyAll() – 唤醒在此对象监视器上等待的所有线程。wait() – 让当前线程处于 “等待(阻塞) 状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout) – 让当前线程处于 “等待(阻塞) 状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout, int nanos) – 让当前线程处于 “等待(阻塞) 状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。 2. wait() 和 notify() 示例下面通过示例演示 “wait() 和 notify() 配合使用的情形”。 12345678910111213141516171819202122232425262728293031323334353637383940// WaitTest.java的源码class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName()+" call notify()"); // 唤醒当前的wait线程 notify(); &#125; &#125;&#125;public class WaitTest &#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); synchronized(t1) &#123; try &#123; // 启动“线程t1” System.out.println(Thread.currentThread().getName()+" start t1"); t1.start(); // 主线程等待t1通过notify()唤醒。 System.out.println(Thread.currentThread().getName()+" wait()"); //虽然 t1.wait()是通过 “线程 t1” 调用的 wait()方法，但是调用 t1.wait()的地方是在 “主线程 main” 中,t1.wait()是让 “主线程” 等待，而不是“线程 t1”！ t1.wait(); System.out.println(Thread.currentThread().getName()+" continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果: 1234main start t1main wait()t1 call notify()main continue 结果说明：如下图，说明了 “主线程” 和“线程 t1”的流程。 (01) 注意，图中 “主线程” 代表 “主线程 main”。”线程 t1” 代表 WaitTest 中启动的 “线程 t1”。 而 “锁” 代表 “t1 这个对象的同步锁”。(02) “主线程”通过 new ThreadA(“t1”) 新建 “线程 t1”。随后通过 synchronized(t1) 获取 “t1 对象的同步锁”。然后调用 t1.start() 启动“线程 t1”。(03) “主线程”执行 t1.wait()是让 “主线程” 等待，而不是“线程 t1”！ ,释放 “t1 对象的锁” 并且进入 “等待(阻塞) 状态”。等待 t1 对象上的线程通过 notify() 或 notifyAll()将其唤醒。(04) “线程 t1”运行之后，通过 synchronized(this)获取 “当前对象的锁”；接着调用 notify() 唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。(05) “线程 t1”运行完毕之后，释放 “当前对象的锁”。紧接着，“主线程” 获取“t1 对象的锁”，然后接着运行。 对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让 “线程 t1” 等待；但是，为什么却是让 “主线程 main” 等待了呢？在解答该问题前，我们先看看 jdk 文档中关于 wait 的一段介绍： Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.In other words, this method behaves exactly as if it simply performs the call wait(0).The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution. 中文意思大概是： 引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。 注意：jdk 的解释中，说 wait()的作用是让 “当前线程” 等待，而 “当前线程” 是指正在 cpu 上运行的线程！这也意味着，虽然 t1.wait()是通过 “线程 t1” 调用的 wait()方法，但是调用 t1.wait()的地方是在 “主线程 main” 中。而主线程必须是 “当前线程”，也就是运行状态，才可以执行 t1.wait()。所以，此时的“当前线程” 是“主线程 main”！因此，t1.wait()是让 “主线程” 等待，而不是“线程 t1”！ 3. wait(long timeout) 和 notify()wait(long timeout)会让当前线程处于 “等待(阻塞) 状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。下面的示例就是演示 wait(long timeout) 在超时情况下，线程被唤醒的情况。 1234567891011121314151617181920212223242526272829303132333435363738// WaitTimeoutTest.java的源码class ThreadA extends Thread&#123; public ThreadA(String name) &#123; super(name); &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + " run "); // 死循环，不断运行。 while(true) ; &#125;&#125;public class WaitTimeoutTest &#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); synchronized(t1) &#123; try &#123; // 启动“线程t1” System.out.println(Thread.currentThread().getName() + " start t1"); t1.start(); // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。 System.out.println(Thread.currentThread().getName() + " call wait "); t1.wait(3000); System.out.println(Thread.currentThread().getName() + " continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 1234main start t1main call wait t1 run // 大约3秒之后...输出“main continue”main continue 结果说明：如下图，说明了 “主线程” 和“线程 t1”的流程。(01) 注意，图中 “主线程” 代表 WaitTimeoutTest 主线程 (即，线程 main)。”线程 t1” 代表 WaitTest 中启动的线程 t1。 而 “锁” 代表 “t1 这个对象的同步锁”。(02) 主线程 main 执行 t1.start() 启动 “线程 t1”。(03) 主线程 main 执行 t1.wait(3000)，此时，主线程进入 “阻塞状态”。需要“用于 t1 对象锁的线程通过 notify() 或者 notifyAll() 将其唤醒” 或者 “超时 3000ms 之后”，主线程 main 才进入到“就绪状态”，然后才可以运行。(04) “线程 t1” 运行之后，进入了死循环，一直不断的运行。(05) 超时 3000ms 之后，主线程 main 会进入到 “就绪状态”，然后接着进入 “运行状态”。 4. wait() 和 notifyAll()通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。下面，我们通过示例演示 notifyAll() 的用法；它的作用是唤醒在此对象监视器上等待的所有线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class NotifyAllTest &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); ThreadA t3 = new ThreadA("t3"); t1.start(); t2.start(); t3.start(); try &#123; System.out.println(Thread.currentThread().getName()+" sleep(3000)"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized(obj) &#123; // 主线程等待唤醒。 System.out.println(Thread.currentThread().getName()+" notifyAll()"); obj.notifyAll(); &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run() &#123; synchronized (obj) &#123; try &#123; // 打印输出结果 System.out.println(Thread.currentThread().getName() + " wait"); // 唤醒当前的wait线程 obj.wait(); // 打印输出结果 System.out.println(Thread.currentThread().getName() + " continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 运行结果： 12345678t1 waitmain sleep(3000)t3 waitt2 waitmain notifyAll()t2 continuet3 continuet1 continue 结果说明：参考下面的流程图。(01) 主线程中新建并且启动了 3 个线程 “t1”, “t2” 和 “t3”。(02) 主线程通过 sleep(3000) 休眠 3 秒。在主线程休眠 3 秒的过程中，我们假设 “t1”, “t2” 和 “t3” 这 3 个线程都运行了。以 “t1” 为例，当它运行的时候，它会执行 obj.wait() 等待其它线程通过 notify() 或额 nofityAll() 来唤醒它；相同的道理，”t2” 和 “t3” 也会等待其它线程通过 nofity() 或 nofityAll() 来唤醒它们。(03) 主线程休眠 3 秒之后，接着运行。执行 obj.notifyAll() 唤醒 obj 上的等待线程，即唤醒 “t1”, “t2” 和 “t3” 这 3 个线程。 紧接着，主线程的 synchronized(obj)运行完毕之后，主线程释放 “obj 锁”。这样，”t1”, “t2” 和 “t3” 就可以获取“obj 锁” 而继续运行了！ 5. 为什么 notify(), wait() 等函数定义在 Object 中，而不是 Thread 中Object 中的 wait(), notify()等函数，和 synchronized 一样，会对 “对象的同步锁” 进行操作。 wait()会使 “当前线程” 等待，因为线程进入等待状态，所以线程应该释放它锁持有的 “同步锁”，否则其它线程获取不到该“同步锁” 而无法运行！OK，线程调用 wait()之后，会释放它锁持有的 “同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被 notify() 或 notifyAll()唤醒。现在，请思考一个问题：notify() 是依据什么唤醒等待线程的？或者说，wait() 等待线程和 notify() 之间是通过什么关联起来的？答案是：依据 “对象的同步锁”。 负责唤醒等待线程的那个线程 (我们称为 “唤醒线程”)，它只有在获取 “该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用 notify()或 notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有 “该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁” 之后，等待线程才能获取到 “对象的同步锁” 进而继续运行。 总之，notify(), wait()依赖于 “同步锁”，而“同步锁” 是对象锁持有，并且每个对象有且仅有一个！这就是为什么 notify(), wait()等函数定义在 Object 类，而不是 Thread 类中的原因。 06 线程让步概要本章，会对 Thread 中的线程让步方法 yield() 进行介绍。涉及到的内容包括：1. yield() 介绍2. yield() 示例3. yield() 与 wait() 的比较 1. yield() 介绍yield()的作用是让步。它能让当前线程由 “运行状态” 进入到 “就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用 yield() 之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到 “运行状态” 继续运行！ 2. yield() 示例下面，通过示例查看它的用法。 1234567891011121314151617181920212223// YieldTest.java的源码class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public synchronized void run()&#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s [%d]:%d\n", this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i%4 == 0) Thread.yield(); &#125; &#125; &#125; public class YieldTest&#123; public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; &#125; (某一次的) 运行结果: 1234567891011121314151617181920t1 [5]:0t2 [5]:0t1 [5]:1t1 [5]:2t1 [5]:3t1 [5]:4t1 [5]:5t1 [5]:6t1 [5]:7t1 [5]:8t1 [5]:9t2 [5]:1t2 [5]:2t2 [5]:3t2 [5]:4t2 [5]:5t2 [5]:6t2 [5]:7t2 [5]:8t2 [5]:9 结果说明：“线程 t1”在能被 4 整数的时候，并没有切换到 “线程 t2”。这表明，yield() 虽然可以让线程由 “运行状态” 进入到 “就绪状态”；但是，它不一定会让其它线程获取 CPU 执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程” 与当前调用 yield()的线程具有相同的优先级。 3. yield() 与 wait() 的比较我们知道，wait() 的作用是让当前线程由 “运行状态” 进入 “等待(阻塞) 状态”的同时，也会释放同步锁。而 yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：(01) wait()是让线程由 “运行状态” 进入到 “等待(阻塞) 状态”，而 yield()是让线程由 “运行状态” 进入到“就绪状态”。(02) wait() 会让线程释放它所持有对象的同步锁，而 yield() 方法不会释放锁。 下面通过示例演示 yield() 是不会释放锁的。 1234567891011121314151617181920212223242526272829 // YieldLockTest.java 的源码public class YieldLockTest&#123; private static Object obj = new Object(); public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; // 获取obj对象的同步锁 synchronized (obj) &#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s [%d]:%d\n", this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i%4 == 0) Thread.yield(); &#125; &#125; &#125; &#125; &#125; (某一次) 运行结果： 1234567891011121314151617181920t1 [5]:0t1 [5]:1t1 [5]:2t1 [5]:3t1 [5]:4t1 [5]:5t1 [5]:6t1 [5]:7t1 [5]:8t1 [5]:9t2 [5]:0t2 [5]:1t2 [5]:2t2 [5]:3t2 [5]:4t2 [5]:5t2 [5]:6t2 [5]:7t2 [5]:8t2 [5]:9 结果说明：主线程 main 中启动了两个线程 t1 和 t2。t1 和 t2 在 run() 会引用同一个对象的同步锁，即 synchronized(obj)。在 t1 运行过程中，虽然它会调用 Thread.yield()；但是，t2 是不会获取 cpu 执行权的。因为，t1 并没有释放 “obj 所持有的同步锁”！ 07 线程休眠概要本章，会对 Thread 中 sleep() 方法进行介绍。涉及到的内容包括：1. sleep() 介绍2. sleep() 示例3. sleep() 与 wait() 的比较 1. sleep() 介绍sleep() 定义在 Thread.java 中。sleep() 的作用是让当前线程休眠，即当前线程会从 “运行状态” 进入到 “休眠 (阻塞) 状态”。sleep() 会指定休眠时间，线程休眠的时间会大于 / 等于该休眠时间；在线程重新被唤醒时，它会由 “阻塞状态” 变成 “就绪状态”，从而等待 cpu 的调度执行。 2. sleep() 示例下面通过一个简单示例演示 sleep() 的用法。 12345678910111213141516171819202122232425// SleepTest.java的源码class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public synchronized void run() &#123; try &#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public class SleepTest&#123; public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); t1.start(); &#125; &#125; 运行结果： 12345678910t1: 0t1: 1t1: 2t1: 3t1: 4t1: 5t1: 6t1: 7t1: 8t1: 9 结果说明：程序比较简单，在主线程 main 中启动线程 t1。t1 启动之后，当 t1 中的计算 i 能被 4 整除时，t1 会通过 Thread.sleep(100) 休眠 100 毫秒。 3. sleep() 与 wait() 的比较我们知道，wait()的作用是让当前线程由 “运行状态” 进入 “等待(阻塞) 状态”的同时，也会释放同步锁。而 sleep()的作用是也是让当前线程由 “运行状态” 进入到 “休眠(阻塞) 状态”。但是，wait() 会释放对象的同步锁，而 sleep() 则不会释放锁。下面通过示例演示 sleep() 是不会释放锁的。 123456789101112131415161718192021222324252627282930313233// SleepLockTest.java的源码public class SleepLockTest&#123; private static Object obj = new Object(); public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; // 获取obj对象的同步锁 synchronized (obj) &#123; try &#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 运行结果： 1234567891011121314151617181920t1: 0t1: 1t1: 2t1: 3t1: 4t1: 5t1: 6t1: 7t1: 8t1: 9t2: 0t2: 1t2: 2t2: 3t2: 4t2: 5t2: 6t2: 7t2: 8t2: 9 结果说明：主线程 main 中启动了两个线程 t1 和 t2。t1 和 t2 在 run() 会引用同一个对象的同步锁，即 synchronized(obj)。在 t1 运行过程中，虽然它会调用 Thread.sleep(100)；但是，t2 是不会获取 cpu 执行权的。因为，t1 并没有释放 “obj 所持有的同步锁”！注意，若我们注释掉 synchronized (obj) 后再次执行该程序，t1 和 t2 是可以相互切换的。下面是注释调 synchronized(obj) 之后的源码： 123456789101112131415161718192021222324252627282930313233// SleepLockTest.java的源码(注释掉synchronized(obj))public class SleepLockTest&#123; private static Object obj = new Object(); public static void main(String[] args)&#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; // 获取obj对象的同步锁// synchronized (obj) &#123; try &#123; for(int i=0; i &lt;10; i++)&#123; System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i%4 == 0) Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;// &#125; &#125; &#125; &#125; 08 join()概要本章，会对 Thread 中 join() 方法进行介绍。涉及到的内容包括：1. join() 介绍2. join() 源码分析 (基于 JDK1.7.0_40)3. join() 示例 1. join() 介绍join() 定义在 Thread.java 中。join() 的作用：让 “主线程” 等待 “子线程” 结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解： 123456789101112131415// 主线程public class Father extends Thread &#123; public void run() &#123; Son s = new Son(); s.start(); s.join(); ... &#125;&#125;// 子线程public class Son extends Thread &#123; public void run() &#123; ... &#125;&#125; 说明：上面的有两个类 Father(主线程类) 和 Son(子线程类)。因为 Son 是在 Father 中创建并启动的，所以，Father 是主线程类，Son 是子线程类。在 Father 主线程中，通过 new Son()新建 “子线程 s”。接着通过 s.start() 启动 “子线程 s”，并且调用 s.join()。在调用 s.join() 之后，Father 主线程会一直等待，直到 “子线程 s” 运行完毕；在 “子线程 s” 运行完毕之后，Father 主线程才能接着运行。 这也就是我们所说的 “join() 的作用，是让主线程会等待子线程结束之后才能继续运行”！ 2. join() 源码分析 (基于 JDK1.7.0_40)12345678910111213141516171819202122232425262728public final void join() throws InterruptedException &#123; join(0);&#125;public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 说明：从代码中，我们可以发现。当 millis==0 时，会进入 while(isAlive()) 循环；即只要子线程是活的，主线程就不停的等待。我们根据上面解释 join() 作用时的代码来理解 join() 的用法！问题：虽然 s.join()被调用的地方是发生在 “Father 主线程” 中，但是 s.join()是通过 “子线程 s” 去调用的 join()。那么，join()方法中的 isAlive()应该是判断 “子线程 s” 是不是 Alive 状态；对应的 wait(0)也应该是 “让子线程 s” 等待才对。但如果是这样的话，s.join()的作用怎么可能是 “让主线程等待，直到子线程 s 完成为止” 呢，应该是让 “子线程等待才对(因为调用子线程对象 s 的 wait 方法嘛)”？答案：wait() 的作用是让 “当前线程” 等待，而这里的 “当前线程” 是指当前在 CPU 上运行的线程。所以，虽然是调用子线程的 wait()方法，但是它是通过 “主线程” 去调用的；所以，休眠的是主线程，而不是“子线程”！ 3. join() 示例在理解 join() 的作用之后，接下来通过示例查看 join() 的用法。 12345678910111213141516171819202122232425262728293031// JoinTest.java的源码public class JoinTest&#123; public static void main(String[] args)&#123; try &#123; ThreadA t1 = new ThreadA("t1"); // 新建“线程t1” t1.start(); // 启动“线程t1” t1.join(); // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成” System.out.printf("%s finish\n", Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; System.out.printf("%s start\n", this.getName()); // 延时操作 for(int i=0; i &lt;1000000; i++) ; System.out.printf("%s finish\n", this.getName()); &#125; &#125; &#125; 运行结果： 123t1 startt1 finishmain finish 结果说明：运行流程如图(01) 在 “主线程 main” 中通过 new ThreadA(“t1”) 新建“线程 t1”。 接着，通过 t1.start() 启动“线程 t1”，并执行 t1.join()。(02) 执行 t1.join()之后，“主线程 main”会进入 “阻塞状态” 等待 t1 运行结束。“子线程 t1”结束之后，会唤醒 “主线程 main”，“主线程” 重新获取 cpu 执行权，继续运行。 09 interrupt()和线程终止方式概要本章，会对线程的 interrupt() 中断和终止方式进行介绍。涉及到的内容包括：1. interrupt() 说明2. 终止线程的方式 2.1 终止处于 “阻塞状态” 的线程 2.2 终止处于 “运行状态” 的线程3. 终止线程的示例4. interrupted() 和 isInterrupted() 的区别 1. interrupt() 说明在介绍终止线程的方式之前，有必要先对 interrupt() 进行了解。关于 interrupt()，java 的 djk 文档描述如下：http://docs.oracle.com/javase/7/docs/api/ 123456789101112Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.If this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.If none of the previous conditions hold then this thread's interrupt status will be set.Interrupting a thread that is not alive need not have any effect. 大致意思是： interrupt()的作用是中断本线程。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。 2. 终止线程的方式Thread 中的 stop() 和 suspend() 方法，由于固有的不安全性，已经建议不再使用！下面，我先分别讨论线程在 “阻塞状态” 和“运行状态”的终止方式，然后再总结出一个通用的方式。 2.1 终止处于 “阻塞状态” 的线程通常，我们通过 “中断” 方式终止处于 “阻塞状态” 的线程。当线程由于被调用了 sleep(), wait(), join() 等方法而进入阻塞状态；若此时调用线程的 interrupt() 将线程的中断标记设为 true。由于处于阻塞状态，中断标记会被清除，同时产生一个 InterruptedException 异常。将 InterruptedException 放在适当的位置就能终止线程，形式如下： 12345678910@Overridepublic void run() &#123; try &#123; while (true) &#123; // 执行任务... &#125; &#125; catch (InterruptedException ie) &#123; // 由于产生InterruptedException异常，退出while(true)循环，线程终止！ &#125;&#125; 说明：在 while(true) 中不断的执行任务，当线程处于阻塞状态时，调用线程的 interrupt() 产生 InterruptedException 中断。中断的捕获在 while(true) 之外，这样就退出了 while(true) 循环！注意：对 InterruptedException 的捕获务一般放在 while(true) 循环体的外面，这样，在产生异常时就退出了 while(true) 循环。否则，InterruptedException 在 while(true) 循环体之内，就需要额外的添加退出处理。形式如下： 123456789101112@Overridepublic void run() &#123; while (true) &#123; try &#123; // 执行任务... &#125; catch (InterruptedException ie) &#123; // InterruptedException在while(true)循环体内。 // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出 break; &#125; &#125;&#125; 说明：上面的 InterruptedException 异常的捕获在 whle(true) 之内。当产生 InterruptedException 异常时，被 catch 处理之外，仍然在 while(true) 循环体内；要退出 while(true) 循环体，需要额外的执行退出 while(true) 的操作。 2.2 终止处于 “运行状态” 的线程通常，我们通过 “标记” 方式终止处于 “运行状态” 的线程。其中，包括“中断标记” 和 “额外添加标记”。(01) 通过 “中断标记” 终止线程。形式如下： 123456@Overridepublic void run() &#123; while (!isInterrupted()) &#123; // 执行任务... &#125;&#125; 说明：isInterrupted() 是判断线程的中断标记是不是为 true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的 interrupt() 方法，使用线程的中断标记为 true，即 isInterrupted() 会返回 true。此时，就会退出 while 循环。注意：interrupt()并不会终止处于 “运行状态” 的线程！它会将线程的中断标记设为 true。 (02) 通过 “额外添加标记”。形式如下： 1234567891011private volatile boolean flag= true;protected void stopTask() &#123; flag = false;&#125;@Overridepublic void run() &#123; while (flag) &#123; // 执行任务... &#125;&#125; 说明：线程中有一个 flag 标记，它的默认值是 true；并且我们提供 stopTask() 来设置 flag 标记。当我们需要终止该线程时，调用该线程的 stopTask() 方法就可以让线程退出 while 循环。注意：将 flag 定义为 volatile 类型，是为了保证 flag 的可见性。即其它线程通过 stopTask() 修改了 flag 之后，本线程能看到修改后的 flag 的值。 综合线程处于 “阻塞状态” 和“运行状态”的终止方式，比较通用的终止线程的形式如下： 1234567891011@Overridepublic void run() &#123; try &#123; // 1\. isInterrupted()保证，只要中断标记为true就终止线程。 while (!isInterrupted()) &#123; // 执行任务... &#125; &#125; catch (InterruptedException ie) &#123; // 2\. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。 &#125;&#125; 3. 终止线程的示例interrupt()常常被用来终止 “阻塞状态” 线程。参考下面示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Demo1.java的源码class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; int i=0; while (!isInterrupted()) &#123; Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+" ("+this.getState()+") loop " + i); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() +" ("+this.getState()+") catch InterruptedException."); &#125; &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; try &#123; Thread t1 = new MyThread("t1"); // 新建“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is new."); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 运行结果： 1234567t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (TERMINATED) is interrupted now. 结果说明：(01) 主线程 main 中通过 new MyThread(“t1”) 创建线程 t1，之后通过 t1.start() 启动线程 t1。(02) t1 启动之后，会不断的检查它的中断标记，如果中断标记为 “false”；则休眠 100ms。(03) t1 休眠之后，会切换到主线程 main；主线程再次运行时，会执行 t1.interrupt()中断线程 t1。t1 收到中断指令之后，会将 t1 的中断标记设置 “false”，而且会抛出 InterruptedException 异常。在 t1 的 run() 方法中，是在循环体 while 之外捕获的异常；因此循环被终止。 我们对上面的结果进行小小的修改，将 run() 方法中捕获 InterruptedException 异常的代码块移到 while 循环体内。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Demo2.java的源码class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i=0; while (!isInterrupted()) &#123; try &#123; Thread.sleep(100); // 休眠100ms &#125; catch (InterruptedException ie) &#123; System.out.println(Thread.currentThread().getName() +" ("+this.getState()+") catch InterruptedException."); &#125; i++; System.out.println(Thread.currentThread().getName()+" ("+this.getState()+") loop " + i); &#125; &#125;&#125;public class Demo2 &#123; public static void main(String[] args) &#123; try &#123; Thread t1 = new MyThread("t1"); // 新建“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is new."); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;c 运行结果： 123456789101112131415t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (RUNNABLE) loop 3t1 (RUNNABLE) loop 4t1 (RUNNABLE) loop 5t1 (TIMED_WAITING) is interrupted now.t1 (RUNNABLE) loop 6t1 (RUNNABLE) loop 7t1 (RUNNABLE) loop 8t1 (RUNNABLE) loop 9... 结果说明：程序进入了死循环！为什么会这样呢？这是因为，t1 在 “等待(阻塞) 状态”时，被 interrupt()中断；此时，会清除中断标记 [即 isInterrupted() 会返回 false]，而且会抛出 InterruptedException 异常[该异常在 while 循环体内被捕获]。因此，t1 理所当然的会进入死循环了。解决该问题，需要我们在捕获异常时，额外的进行退出 while 循环的处理。例如，在 MyThread 的 catch(InterruptedException) 中添加 break 或 return 就能解决该问题。 下面是通过 “额外添加标记” 的方式终止 “状态状态” 的线程的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Demo3.java的源码class MyThread extends Thread &#123; private volatile boolean flag= true; public void stopTask() &#123; flag = false; &#125; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized(this) &#123; try &#123; int i=0; while (flag) &#123; Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+" ("+this.getState()+") loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; System.out.println(Thread.currentThread().getName() +" ("+this.getState()+") catch InterruptedException."); &#125; &#125; &#125;&#125;public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; MyThread t1 = new MyThread("t1"); // 新建“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is new."); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +" ("+t1.getState()+") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.stopTask(); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +" ("+t1.getState()+") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 运行结果： 1234567t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) loop 3t1 (TERMINATED) is interrupted now. 4. interrupted() 和 isInterrupted() 的区别最后谈谈 interrupted() 和 isInterrupted()。interrupted() 和 isInterrupted() 都能够用于检测对象的 “中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记 (即将中断标记设为 false)；而 isInterrupted() 仅仅返回中断标记。 10 线程优先级和守护线程概要本章，会对守护线程和线程优先级进行介绍。涉及到的内容包括：1. 线程优先级的介绍2. 线程优先级的示例3. 守护线程的示例 1. 线程优先级的介绍java 中的线程优先级的范围是 1～10，默认的优先级是 5。“高优先级线程”会优先于 “低优先级线程” 执行。 daemon：美 [‘dimən] java 中有两种线程：用户线程和守护线程。可以通过 isDaemon() 方法来区别它们：如果返回 false，则说明该线程是 “用户线程”；否则就是 “守护线程”。用户线程一般是用户执行的用户级任务，而守护线程也就是 “后台线程”，一般用来执行后台任务。需要注意的是：Java 虚拟机在“用户线程” 都结束后会后退出。 JDK 中关于线程优先级和守护线程的介绍如下： 1234567Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads. 大致意思是： 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：(01) 调用了exit()方法，并且exit()有权限被正常执行。(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。 2. 线程优先级的示例我们先看看优先级的示例 12345678910111213141516171819202122232425262728class MyThread extends Thread&#123; public MyThread(String name) &#123; super(name); &#125; public void run()&#123; for (int i=0; i&lt;5; i++) &#123; System.out.println(Thread.currentThread().getName() +"("+Thread.currentThread().getPriority()+ ")" +", loop "+i); &#125; &#125; &#125;; public class Demo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() +"("+Thread.currentThread().getPriority()+ ")"); Thread t1=new MyThread("t1"); // 新建t1 Thread t2=new MyThread("t2"); // 新建t2 t1.setPriority(1); // 设置t1的优先级为1 t2.setPriority(10); // 设置t2的优先级为10 t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125; 运行结果： 1234567891011main(5)t1(1), loop 0t2(10), loop 0t1(1), loop 1t2(10), loop 1t1(1), loop 2t2(10), loop 2t1(1), loop 3t2(10), loop 3t1(1), loop 4t2(10), loop 4 结果说明：(01) 主线程 main 的优先级是 5。(02) t1 的优先级被设为 1，而 t2 的优先级被设为 10。cpu 在执行 t1 和 t2 的时候，根据时间片轮循调度，所以能够并发执行。 3. 守护线程的示例下面是守护线程的示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Demo.javaclass MyThread extends Thread&#123; public MyThread(String name) &#123; super(name); &#125; public void run()&#123; try &#123; for (int i=0; i&lt;5; i++) &#123; Thread.sleep(3); System.out.println(this.getName() +"(isDaemon="+this.isDaemon()+ ")" +", loop "+i); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;; class MyDaemon extends Thread&#123; public MyDaemon(String name) &#123; super(name); &#125; public void run()&#123; try &#123; for (int i=0; i&lt;10000; i++) &#123; Thread.sleep(1); System.out.println(this.getName() +"(isDaemon="+this.isDaemon()+ ")" +", loop "+i); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;public class Demo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() +"(isDaemon="+Thread.currentThread().isDaemon()+ ")"); Thread t1=new MyThread("t1"); // 新建t1 Thread t2=new MyDaemon("t2"); // 新建t2 t2.setDaemon(true); // 设置t2为守护线程 t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125; 运行结果： 12345678910111213141516171819main(isDaemon=false)t2(isDaemon=true), loop 0t2(isDaemon=true), loop 1t1(isDaemon=false), loop 0t2(isDaemon=true), loop 2t2(isDaemon=true), loop 3t1(isDaemon=false), loop 1t2(isDaemon=true), loop 4t2(isDaemon=true), loop 5t2(isDaemon=true), loop 6t1(isDaemon=false), loop 2t2(isDaemon=true), loop 7t2(isDaemon=true), loop 8t2(isDaemon=true), loop 9t1(isDaemon=false), loop 3t2(isDaemon=true), loop 10t2(isDaemon=true), loop 11t1(isDaemon=false), loop 4t2(isDaemon=true), loop 12 结果说明：(01) 主线程 main 是用户线程，它创建的子线程 t1 也是用户线程。(02) t2 是守护线程。在 “主线程 main” 和“子线程 t1”(它们都是用户线程)执行完毕，只剩 t2 这个守护线程的时候，JVM 自动退出。 11 生产消费者问题概要本章，会对 “生产 / 消费者问题” 进行讨论。涉及到的内容包括：1. 生产 / 消费者模型2. 生产 / 消费者实现 1. 生产 / 消费者模型生产 / 消费者问题是个非常典型的多线程问题，涉及到的对象包括 “生产者”、“消费者”、“仓库” 和“产品”。他们之间的关系如下：(01) 生产者仅仅在仓储未满时候生产，仓满则停止生产。(02) 消费者仅仅在仓储有产品时候才能消费，仓空则等待。(03) 当消费者发现仓储没产品可消费时候会通知生产者生产。(04) 生产者在生产出可消费产品时候，应该通知等待的消费者去消费。 2. 生产 / 消费者实现下面通过 wait()/notify() 方式实现该模型 (后面在学习了线程池相关内容之后，再通过其它方式实现生产 / 消费者模型)。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 // Demo1.java// 仓库class Depot &#123; private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 public Depot(int capacity) &#123; this.capacity = capacity; this.size = 0; &#125; public synchronized void produce(int val) &#123; try &#123; // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left &gt; 0) &#123; // 库存已满时，等待“消费者”消费产品。 while (size &gt;= capacity) wait(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)&gt;capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf("%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\n", Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 notifyAll(); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; public synchronized void consume(int val) &#123; try &#123; // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left &gt; 0) &#123; // 库存为0时，等待“生产者”生产产品。 while (size &lt;= 0) wait(); // 获取“实际消费的数量”(即库存中实际减少的数量) // 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”； // 否则，“实际消费量”=“客户要消费的数量”。 int dec = (size&lt;left) ? size : left; size -= dec; left -= dec; System.out.printf("%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\n", Thread.currentThread().getName(), val, left, dec, size); notifyAll(); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; public String toString() &#123; return "capacity:"+capacity+", actual size:"+size; &#125;&#125; // 生产者class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程向仓库中生产产品。 public void produce(final int val) &#123; new Thread() &#123; public void run() &#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;// 消费者class Customer &#123; private Depot depot; public Customer(Depot depot) &#123; this.depot = depot; &#125; // 消费产品：新建一个线程从仓库中消费产品。 public void consume(final int val) &#123; new Thread() &#123; public void run() &#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; Depot mDepot = new Depot(100); Producer mPro = new Producer(mDepot); Customer mCus = new Customer(mDepot); mPro.produce(60); mPro.produce(120); mCus.consume(90); mCus.consume(150); mPro.produce(110); &#125;&#125; 说明：(01) Producer 是 “生产者” 类，它与 “仓库(depot)” 关联。当调用 “生产者” 的 produce()方法时，它会新建一个线程并向 “仓库” 中生产产品。(02) Customer 是 “消费者” 类，它与 “仓库(depot)” 关联。当调用 “消费者” 的 consume()方法时，它会新建一个线程并消费 “仓库” 中的产品。(03) Depot 是 “仓库” 类，仓库中记录 “仓库的容量(capacity)” 以及“仓库中当前产品数目(size)”。 “仓库”类的生产方法 produce()和消费方法 consume()方法都是 synchronized 方法，进入 synchronized 方法体，意味着这个线程获取到了该 “仓库” 对象的同步锁。这也就是说，同一时间，生产者和消费者线程只能有一个能运行。通过同步锁，实现了对 “仓库” 的互斥访问。 对于生产方法 produce() 而言：当仓库满时，生产者线程等待，需要等待消费者消费产品之后，生产线程才能生产；生产者线程生产完产品之后，会通过 notifyAll() 唤醒同步锁上的所有线程，包括 “消费者线程”，即我们所说的 “通知消费者进行消费”。 对于消费方法 consume() 而言：当仓库为空时，消费者线程等待，需要等待生产者生产产品之后，消费者线程才能消费；消费者线程消费完产品之后，会通过 notifyAll() 唤醒同步锁上的所有线程，包括 “生产者线程”，即我们所说的 “通知生产者进行生产”。 (某一次) 运行结果： 123456789Thread-0 produce( 60) --&gt; left= 0, inc= 60, size= 60Thread-4 produce(110) --&gt; left= 70, inc= 40, size=100Thread-2 consume( 90) &lt;-- left= 0, dec= 90, size= 10Thread-3 consume(150) &lt;-- left=140, dec= 10, size= 0Thread-1 produce(120) --&gt; left= 20, inc=100, size=100Thread-3 consume(150) &lt;-- left= 40, dec=100, size= 0Thread-4 produce(110) --&gt; left= 0, inc= 70, size= 70Thread-3 consume(150) &lt;-- left= 0, dec= 40, size= 30Thread-1 produce(120) --&gt; left= 0, inc= 20, size= 50 原文地址：http://www.cnblogs.com/skywang12345/p/java_threads_category.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 并发 多线程 面试总结 top50+top40]]></title>
    <url>%2F2018%2F03%2F23%2F2018-03-23%2F</url>
    <content type="text"><![CDATA[不管你是新程序员还是老手，你一定在面试中遇到过有关线程的问题。Java 语言一个重要的特点就是内置了对并发的支持，让 Java 大受企业和程序员的欢迎。大多数待遇丰厚的 Java 开发职位都要求开发者精通多线程技术并且有丰富的 Java 程序开发、调试、优化经验，所以线程相关的问题在面试中经常会被提到。 在典型的 Java 面试中， 面试官会从线程的基本概念问起, 如：为什么你需要使用线程， 如何创建线程，用什么方式创建线程比较好（比如：继承 thread 类还是调用 Runnable 接口），然后逐渐问到并发问题像在 Java 并发编程的过程中遇到了什么挑战，Java 内存模型，JDK1.5 引入了哪些更高阶的并发工具，并发编程常用的设计模式，经典多线程问题如生产者消费者，哲学家就餐，读写器或者简单的有界缓冲区问题。仅仅知道线程的基本概念是远远不够的， 你必须知道如何处理死锁，竞态条件，内存冲突和线程安全等并发问题。掌握了这些技巧，你就可以轻松应对多线程和并发面试了。 许多 Java 程序员在面试前才会去看面试题，这很正常。因为收集面试题和练习很花时间，所以我从许多面试者那里收集了 Java 多线程和并发相关的 50 个热门问题。我只收集了比较新的面试题且没有提供全部答案。想必聪明的你对这些问题早就心中有数了， 如果遇到不懂的问题，你可以用 Google 找到答案。若你实在找不到答案，可以在文章的评论中向我求助。你也可以在这找到一些答案 Java 线程问答 Top 12。 50 道 Java 线程面试题下面是 Java 线程相关的热门面试题，你可以用它来好好准备面试。 1) 什么是线程？线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要 100 毫秒，那么用十个线程完成改任务只需 10 毫秒。Java 在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。欲了解更多详细信息请点击这里。 2) 线程和进程有什么区别？线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。更多详细信息请点击这里。 3) 如何在 Java 中实现线程？在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用 java.lang.Runnable 接口来执行，由于线程类本身就是调用的 Runnable 接口所以你可以继承 java.lang.Thread 类或者直接调用 Runnable 接口来重写 run() 方法实现线程。更多详细信息请点击这里. 4) 用 Runnable 还是 Thread？这个问题是上题的后续，大家都知道我们可以通过继承 Thread 类或者调用 Runnable 接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道 Java 不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用 Runnable 接口好了。更多详细信息请点击这里。 6) Thread 类中的 start() 和 run() 方法有什么区别？这个问题经常被问到，但还是能从此区分出面试者对 Java 线程模型的理解程度。start() 方法被用来启动新创建的线程，而且 start() 内部调用了 run() 方法，这和直接调用 run() 方法的效果不一样。当你调用 run() 方法的时候，只会是在原来的线程中调用，没有新的线程启动，start() 方法才会启动新线程。更多讨论请点击这里 7) Java 中 Runnable 和 Callable 有什么不同？Runnable 和 Callable 都代表那些要在不同的线程中执行的任务。Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的。它们的主要区别是 Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。我的博客有更详细的说明。 8) Java 中 CyclicBarrier 和 CountDownLatch 有什么不同？CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。点此查看更多信息和示例代码。 9) Java 内存模型是什么？Java 内存模型规定和指引 Java 程序在不同的内存架构、CPU 和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java 内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了： 线程内的代码能够按先后顺序执行，这被称为程序次序规则。 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。 一个线程内的任何操作必需在这个线程的 start() 调用之后，也叫作线程启动规则。 一个线程的所有操作都会在线程终止之前，线程终止规则。 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。 可传递性 我强烈建议大家阅读《Java 并发编程实践》第十六章来加深对 Java 内存模型的理解。 10) Java 中的 volatile 变量是什么？volatile 是一个特殊的修饰符，只有成员变量才能使用它。在 Java 并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile 变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的 volatile 变量规则。点击这里查看更多 volatile 的相关内容。 11) 什么是线程安全？Vector 是一个线程安全类吗？ （详见这里)如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的 ArrayList 不是线程安全的。 12) Java 中什么是竞态条件？ 举个例子说明。竞态条件会导致程序在并发情况下出现一些 bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的 bugs。这种 bugs 很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见答案。 13) Java 中如何停止一个线程？Java 提供了很丰富的 API 但没有为停止线程提供 API。JDK 1.0 本来有一些像 stop(), suspend() 和 resume() 的控制方法但是由于潜在的死锁威胁因此在后续的 JDK 版本中他们被弃用了，之后 Java API 的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当 run() 或者 call() 方法执行完的时候线程会自动结束, 如果要手动结束一个线程，你可以用 volatile 布尔变量来退出 run() 方法的循环或者是取消任务来中断线程。点击这里查看示例代码。 14) 一个线程运行时发生异常会怎样？这是我在一次面试中遇到的一个很刁钻的 Java 面试题, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 Thread.getUncaughtExceptionHandler() 来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException() 方法进行处理。 15） 如何在两个线程间共享数据？你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程《Java 线程间通信》(涉及到在两个线程间共享对象) 用 wait 和 notify 方法实现了生产者消费者模型。 16) Java 中 notify 和 notifyAll 有什么区别？这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify() 方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而 notifyAll() 唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。我的博客有更详细的资料和示例代码。 17) 为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object 类里是有意义的，还有不把它放在 Thread 类里的原因。一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的 wait() 方法就有意义了。如果 wait() 方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象。你也可以查看这篇文章了解更多。 18) 什么是 ThreadLocal 变量？ThreadLocal 是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让 SimpleDateFormat 变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是 ThreadLocalRandom 类，它在多线程环境中减少了创建代价高昂的 Random 对象的个数。查看答案了解更多。 19) 什么是 FutureTask？在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable 接口所以它可以提交给 Executor 来执行。 20) Java 中 interrupted 和 isInterruptedd 方法的区别？interrupted() 和 isInterrupted() 的主要区别是前者会将中断状态清除而后者不会。Java 多线程的中断机制是用内部标识来实现的，调用 Thread.interrupt() 来中断一个线程就会设置中断标识为 true。当中断线程调用静态方法 Thread.interrupted() 来检查中断状态时，中断状态会被清零。而非静态方法 isInterrupted() 用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出 InterruptedException 异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。 21) 为什么 wait 和 notify 方法要在同步块中调用？主要是因为 Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。 22) 为什么你应该在循环中检查等待条件?处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在 notify() 方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用 wait() 方法效果更好的原因，你可以在 Eclipse 中创建模板调用 wait 和 notify 试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。 23) Java 中的同步集合与并发集合有什么区别？同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像 ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见答案。 24） Java 中堆和栈有什么不同？为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。更多内容详见答案。 25） 什么是线程池？ 为什么要使用它？创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从 JDK1.5 开始，Java API 提供了 Executor 框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见这篇文章。 26） 如何写代码来解决生产者消费者问题？在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用 wait 和 notify 来解决这个问题，比较赞的办法是用 Semaphore 或者 BlockingQueue 来实现生产者消费者模型，这篇教程有实现它。 27） 如何避免死锁？Java 多线程中的死锁死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节。 28) Java 中活锁和死锁有什么区别？这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。 29） 怎么检测一个线程是否拥有锁？我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在 java.lang.Thread 中有一个方法叫 holdsLock()，它返回 true 如果当且仅当当前线程拥有某个具体对象的锁。你可以查看这篇文章了解更多。 30) 你如何在 Java 中获取线程堆栈？对于不同的操作系统，有多种方法来获得 Java 进程的线程堆栈。当你获取线程堆栈时，JVM 会把所有线程的状态存到日志文件或者输出到控制台。在 Windows 你可以使用 Ctrl + Break 组合键来获取线程堆栈，Linux 下用 kill -3 命令。你也可以用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。 31) JVM 中哪个参数是用来控制线程的栈堆栈小的这个问题很简单， -Xss 参数用来控制线程的堆栈大小。你可以查看 JVM 配置列表来了解这个参数的更多信息。 32） Java 中 synchronized 和 ReentrantLock 有什么不同？Java 在过去很长一段时间只能通过 synchronized 关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过 Lock 接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。你可以查看这篇文章了解更多 33） 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的 join() 方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个 (T3 调用 T2，T2 调用 T1)，这样 T1 就会先完成而 T3 最后完成。你可以查看这篇文章了解更多。 34) Thread 类中的 yield 方法有什么作用？Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield() 的线程有可能在进入到暂停状态后马上又被执行。点击这里查看更多 yield 方法的相关内容。 35） Java 中 ConcurrentHashMap 的并发度是什么？ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章 How ConcurrentHashMap works in Java。 36） Java 中 Semaphore 是什么？Java 中的 Semaphore 是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请点击这里。 37）如果你提交任务时，线程池队列已满。会时发会生什么？这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么 ThreadPoolExecutor’s submit() 方法将会抛出一个 RejectedExecutionException 异常。 38) Java 线程池中 submit() 和 execute() 方法有什么区别？两个方法都可以向线程池提交任务，execute() 方法的返回类型是 void，它定义在 Executor 接口中, 而 submit() 方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。更多详细信息请点击这里。 39) 什么是阻塞式方法？阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的 accept() 方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请点击这里。 40) Swing 是线程安全的吗？ 为什么？你可以很肯定的给出回答，Swing 不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说 swing 不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对 GUI 组件的更新都要在 AWT 线程中完成，而 Swing 提供了同步和异步两种回调方法来进行更新。点击这里查看更多 swing 和线程安全的相关内容。 41） Java 中 invokeAndWait 和 invokeLater 有什么区别？这两个方法是 Swing API 提供给 Java 开发者用来从当前线程而不是事件派发线程更新 GUI 组件用的。InvokeAndWait() 同步更新 GUI 组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用 invokeAndWait() 方法请求事件派发线程对组件进行相应更新。而 invokeLater() 方法是异步调用更新组件的。更多详细信息请点击这里。 42) Swing API 中那些方法是线程安全的？这个问题又提到了 swing 和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如 repaint(), revalidate()。 JTextComponent 的 setText() 方法和 JTextArea 的 insert() 和 append() 方法也是线程安全的。 43) 如何在 Java 中创建 Immutable 对象？这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable 对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是 Java 没有 @Immutable 这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供 setter 方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在 getter 方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章 how to make an object Immutable in Java 有详细的教程，看完你可以充满自信。 44） Java 中的 ReadWriteLock 是什么？一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java 中的 ReadWriteLock 是 Java 5 中新增的一个接口，一个 ReadWriteLock 维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用 JDK 中的 ReentrantReadWriteLock 来实现这个规则，它最多支持 65535 个写锁和 65535 个读锁。 45) 多线程中的忙循环是什么?忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看这篇文章获得更多信息。 46）volatile 变量和 atomic 变量有什么不同？这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作就不是原子性的。而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如 getAndIncrement() 方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。 47) 如果同步块内的线程抛出异常会发生什么？这个问题坑了很多 Java 程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在 finally block 里释放锁实现。 48） 单例模式的双检锁是什么？这个问题在 Java 面试中经常被问到，但是面试官对回答此问题的满意度仅为 50%。一半的人写不出双检锁还有一半的人说不出它的隐患和 Java1.5 是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在 JDK1.4 中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看 how double checked locking on Singleton works 这篇文章获得更多信息。 49） 如何在 Java 中创建线程安全的 Singleton？这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建 Singleton 类的替代方法，你可以利用 JVM 的类加载和静态变量初始化特征来创建 Singleton 实例，或者是利用枚举类型来创建 Singleton，我很喜欢用这种方法。你可以查看这篇文章获得更多信息。 50) 写出 3 条你遵循的多线程最佳实践这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数 Java 程序员都应该遵循： 给你的线程起个有意义的名字。这样可以方便找 bug 或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至 JDK 都遵循这个最佳实践。 避免锁定和缩小同步的范围锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。 多用同步类少用 wait 和 notify首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用 wait 和 notify 很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的 JDK 中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。 多用并发集合少用同步集合这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到 map，你应该首先想到用 ConcurrentHashMap。我的文章 Java 并发集合有更详细的说明。 51) 如何强制启动一个线程？这个问题就像是如何强制进行 Java 垃圾回收，目前还没有觉得方法，虽然你可以使用 System.gc() 来进行垃圾回收，但是不保证能成功。在 Java 里面没有办法强制启动一个线程，它是被线程调度器控制着且 Java 没有公布相关的 API。 52) Java 中的 fork join 框架是什么？fork join 框架是 JDK7 中出现的一款高效的工具，Java 开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join 框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。你可以查看这篇文章获得更多信息。 53） Java 多线程中调用 wait() 和 sleep() 方法有什么不同？Java 程序中 wait 和 sleep 都会造成某种形式的暂停，它们可以满足不同的需要。wait() 方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep() 方法仅仅释放 CPU 资源或者让当前线程停止执行一段时间，但不会释放锁。你可以查看这篇文章获得更多信息。 以上就是 50 道热门 Java 多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有 Java 多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的 Java 开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。 原文链接： javarevisited 翻译： ImportNew.com - 李 广译文链接： http://www.importnew.com/12773.html[ 转载请保留原文出处、译者和译文链接。] 前言 Java 多线程分类中写了 21 篇多线程的文章，21 篇文章的内容很多，个人认为，学习，内容越多、越杂的知识，越需要进行深刻的总结，这样才能记忆深刻，将知识变成自己的。这篇文章主要是对多线程的问题进行总结的，因此罗列了 40 个多线程的问题。 这些多线程的问题，有些来源于各大网站、有些来源于自己的思考。可能有些问题网上有、可能有些问题对应的答案也有、也可能有些各位网友也都看过，但是本文写作的重心就是所有的问题都会按照自己的理解回答一遍，不会去看网上的答案，因此可能有些问题讲的不对，能指正的希望大家不吝指教。 40个问题汇总1、多线程有什么用？ （1）发挥多核 CPU 的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4 核、8 核甚至 16 核的也都不少见，如果是单线程的程序，那么在双核 CPU 上就浪费了 50%，在 4 核 CPU 上就浪费了 75%。单核 CPU 上所谓的 “多线程” 那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程 “同时” 运行罢了。多核 CPU 上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的。 （2）防止阻塞 从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核 CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 （3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 2、创建线程的方式 比较常见的一个问题了，一般就是两种： （1）继承 Thread 类 （2）实现 Runnable 接口 至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式 6 大原则的核心。 3、start() 方法和 run() 方法的区别 只有调用了 start() 方法，才会表现出多线程的特性，不同线程的 run() 方法里面的代码交替执行。如果只是调用 run() 方法，那么代码还是同步执行的，必须等待一个线程的 run() 方法里面的代码全部执行完毕之后，另外一个线程才可以执行其 run() 方法里面的代码。 4、Runnable 接口和 Callable 接口的区别 有点深的问题了，也看出一个 Java 程序员学习知识的广度。 Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已；Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而 Callable+Future/FutureTask 却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 5、CyclicBarrier 和 CountDownLatch 的区别 两个看上去有点像的类，都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上，二者的区别在于： （1）CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值 - 1 而已，该线程继续运行 （2）CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务 （3）CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为 0 该 CountDownLatch 就不可再用了 6、volatile 关键字的作用 一个非常重要的问题，是每个学习、应用多线程的 Java 程序员都必须掌握的。理解 volatile 关键字的作用的前提是要理解 Java 内存模型，这里就不讲 Java 内存模型了，可以参见第 31 点，volatile 关键字的作用主要有两个： （1）多线程主要围绕可见性和原子性两个特性而展开，使用 volatile 关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到 volatile 变量，一定是最新的数据 （2）代码底层执行不像我们看到的高级语言 —-Java 程序这么简单，它的执行是 Java 代码 –&gt; 字节码 –&gt; 根据字节码执行对应的 C/C++ 代码 –&gt;C/C++ 代码被编译成汇编语言 –&gt; 和硬件电路交互，现实中，为了获取更好的性能 JVM 可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用 volatile 则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。 7、什么是线程安全 又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的： （1）不可变 像 String、Integer、Long 这些，都是 final 类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 （2）绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java 中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java 中也有，比方说 CopyOnWriteArrayList、CopyOnWriteArraySet （3）相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像 Vector 这种，add、remove 方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个 Vector、有个线程同时在 add 这个 Vector，99% 的情况下都会出现 ConcurrentModificationException，也就是 fail-fast 机制。 （4）线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap 等都是线程非安全的类 8、Java 中如何获取到线程 dump 文件 死循环、死锁、阻塞、页面打开慢等问题，打线程 dump 是最好的解决问题的途径。所谓线程 dump 也就是线程堆栈，获取到线程堆栈有两步： （1）获取到线程的 pid，可以通过使用 jps 命令，在 Linux 环境下还可以使用 ps -ef | grep java （2）打印线程堆栈，可以通过使用 jstack pid 命令，在 Linux 环境下还可以使用 kill -3 pid 另外提一点，Thread 类提供了一个 getStackTrace() 方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈， 9、一个线程如果出现了运行时异常会怎么样 如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放 10、如何在两个线程之间共享数据 通过在线程之间共享对象就可以了，然后通过 wait/notify/notifyAll、await/signal/signalAll 进行唤起和等待，比方说阻塞队列 BlockingQueue 就是为线程之间共享数据而设计的 11、sleep 方法和 wait 方法有什么区别 这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器 12、生产者消费者模型的作用是什么 这个问题很理论，但是很重要： （1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 13、ThreadLocal 有什么用 简单说 ThreadLocal 就是一种以空间换时间的做法，在每个 Thread 里面维护了一个以开地址法实现的 ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 14、为什么 wait() 方法和 notify()/notifyAll() 方法要在同步块中被调用 这是 JDK 强制的，wait() 方法和 notify()/notifyAll() 方法在调用前都必须先获得对象的锁 15、wait() 方法和 notify()/notifyAll() 方法在放弃对象监视器时有什么区别 wait() 方法和 notify()/notifyAll() 方法在放弃对象监视器的时候的区别在于：wait() 方法立即释放对象监视器，notify()/notifyAll() 方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 16、为什么要使用线程池 避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 17、怎么检测一个线程是否持有对象监视器 我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread 类提供了一个 holdsLock(Object obj) 方法，当且仅当对象 obj 的监视器被某条线程持有的时候才会返回 true，注意这是一个 static 方法，这意味着 “某条线程” 指的是当前线程。 18、synchronized 和 ReentrantLock 的区别 synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上： （1）ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁 （2）ReentrantLock 可以获取各种锁的信息 （3）ReentrantLock 可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word，这点我不能确定。 19、ConcurrentHashMap 的并发度是什么 ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有 16 条线程操作 ConcurrentHashMap，这也是 ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗？ 20、ReadWriteLock 是什么 首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁 ReadWriteLock。ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 21、FutureTask 是什么 这个其实前面有提到过，FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。 22、Linux 环境下如何查找哪个线程使用 CPU 最长 这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做： （1）获取项目的 pid，jps 或者 ps -ef | grep java，这个前面有讲过 （2）top -H -p pid，顺序不能改变 这样就可以打印出当前的项目，每条线程占用 CPU 时间的百分比。注意这里打出的是 LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署 Linux 环境下的 Java 工程，因此没有办法截图演示，网友朋友们如果公司是使用 Linux 环境部署项目的话，可以尝试一下。 使用 “top -H -p pid”+”jps pid” 可以很容易地找到某条占用 CPU 高的线程的线程堆栈，从而定位占用 CPU 高的原因，一般是因为不当的代码操作导致了死循环。 最后提一点，”top -H -p pid” 打出来的 LWP 是十进制的，”jps pid” 打出来的本地线程号是十六进制的，转换一下，就能定位到占用 CPU 高的线程的当前线程堆栈了。 23、Java 编程写一个会导致死锁的程序 第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程 A 和线程 B 相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。 真正理解什么是死锁，这个问题其实不难，几个步骤： （1）两个线程里面分别持有两个 Object 对象：lock1 和 lock2。这两个 lock 作为同步代码块的锁； （2）线程 1 的 run() 方法中同步代码块先获取 lock1 的对象锁，Thread.sleep(xxx)，时间不需要太多，50 毫秒差不多了，然后接着获取 lock2 的对象锁。这么做主要是为了防止线程 1 启动一下子就连续获得了 lock1 和 lock2 两个对象的对象锁 （3）线程 2 的 run)(方法中同步代码块先获取 lock2 的对象锁，接着获取 lock1 的对象锁，当然这时 lock1 的对象锁已经被线程 1 锁持有，线程 2 肯定是要等待线程 1 释放 lock1 的对象锁的 这样，线程 1”睡觉” 睡完，线程 2 已经获取了 lock2 的对象锁了，线程 1 此时尝试获取 lock2 的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java 多线程 7：死锁这篇文章里面有，就是上面步骤的代码实现。 24、怎么唤醒一个阻塞的线程 如果线程是因为调用了 wait()、sleep() 或者 join() 方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统。 25、不可变对象对多线程有什么帮助 前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 26、什么是多线程的上下文切换 多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。 27、如果你提交任务时，线程池队列已满，这时会发生什么 这里区分一下： 如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务 如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据 maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 28、Java 中用到的线程调度算法是什么 抢占式。一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 29、Thread.sleep(0) 的作用是什么 这个问题和上面那个问题是相关的，我就连在一起了。由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU 控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用 Thread.sleep(0) 手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制权的一种操作。 30、什么是自旋 很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 31、什么是 Java 内存模型 Java 内存模型定义了一种多线程访问 Java 内存的规范。Java 内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下 Java 内存模型的几部分内容： （1）Java 内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次 Java 线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 （2）定义了几个原子操作，用于操作主内存和工作内存中的变量 （3）定义了 volatile 变量的使用规则 （4）happens-before，即先行发生原则，定义了操作 A 必然先行发生于操作 B 的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁 unlock 的动作一定先行发生于后面对于同一个锁进行锁定 lock 的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的 happens-before 规则，则这段代码一定是线程非安全的 32、什么是 CAS CAS，全称为 Compare and Swap，即比较 - 替换。假设有三个操作数：内存值 V、旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false。当然 CAS 一定要 volatile 变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功。 33、什么是乐观锁和悲观锁 （1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较 - 替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。 34、什么是 AQS 简单说一下 AQS，AQS 全称为 AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。 如果说 java.util.concurrent 的基础是 CAS 的话，那么 AQS 就是整个 Java 并发包的核心了，ReentrantLock、CountDownLatch、Semaphore 等等都用到了它。AQS 实际上以双向队列的形式连接所有的 Entry，比方说 ReentrantLock，所有等待的线程都被放在一个 Entry 中并连成双向队列，前面一个线程使用 ReentrantLock 好了，则双向队列实际上的第一个 Entry 开始运行。 AQS 定义了对双向队列所有的操作，而只开放了 tryLock 和 tryRelease 方法给开发者使用，开发者可以根据自己的实现重写 tryLock 和 tryRelease 方法，以实现自己的并发功能。 35、单例模式的线程安全性 老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： （1）饿汉式单例模式的写法：线程安全 （2）懒汉式单例模式的写法：非线程安全 （3）双检锁单例模式的写法：线程安全 36、Semaphore 有什么作用 Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。 37、Hashtable 的 size() 方法中明明只有一条语句 “return count”，为什么还要做同步？ 这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是 size() 方法明明只有一条语句，为什么还要加锁？ 关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点： （1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B 则可以正常调用 size() 方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对 size++，线程 B 就已经读取 size 了，那么对于线程 B 来说读取到的 size 一定是不准确的。而给 size() 方法加了同步之后，意味着线程 B 调用 size() 方法只有在线程 A 调用 put 方法完毕之后才可以调用，这样就保证了线程安全性 （2）CPU 执行代码，执行的不是 Java 代码，这点很关键，一定得记住。Java 代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到 Java 代码只有一行，甚至你看到 Java 代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句 “return count” 假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。 38、线程类的构造方法、静态块是被哪个线程调用的 这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new 这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了 Thread1，main 函数中 new 了 Thread2，那么： （1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run() 方法是 Thread2 自己调用的 （2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run() 方法是 Thread1 自己调用的 39、同步方法和同步块，哪个是更好的选择 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。 借着这一条，我额外提一点，虽说同步的范围越少越好，但是在 Java 虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说 StringBuffer，它是一个线程安全的类，自然最常用的 append() 方法是一个同步方法，我们写代码的时候会反复 append 字符串，这意味着要进行反复的加锁 -&gt; 解锁，这对性能不利，因为这意味着 Java 虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此 Java 虚拟机会将多次 append 方法调用的代码进行一个锁粗化的操作，将多次的 append 的操作扩展到 append 方法的头尾，变成一个大的同步块，这样就减少了加锁 –&gt; 解锁的次数，有效地提升了代码执行的效率。 40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？ 这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是： （1）高并发、任务执行时间短的业务，线程池线程数可以设置为 CPU 核数 + 1，减少线程上下文的切换 （2）并发不高、任务执行时间长的业务要区分开看： a）假如是业务时间长集中在 IO 操作上，也就是 IO 密集型的任务，因为 IO 操作并不占用 CPU，所以不要让所有的 CPU 闲下来，可以加大线程池中的线程数目，让 CPU 处理更多的业务 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。 原文：http://www.cnblogs.com/xrq730/p/5060921.html]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 笔记四]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22-3%2F</url>
    <content type="text"><![CDATA[第四章 对象的组合Composing Objects4.1 设计线程安全的类在设计线程安全类的过程中，需要包含三个步骤：1）找出构成对象状态的所有变量。2）找出约束状态变量的不变形条件。3）建立对象状态的并发访问管理策略。 对象的域：是指对象中的变量。对象的状态：如果对象中的所有域都是基本类型的变量，那么这些域将构成对象的全部状态。如果对象中引用了其他对象，那么该对象的状态将包含被引用对象的域。 4.1.1 收集同步需求如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助原子性和封装性。说的更简略些是 Java 线程安全问题都是因为共享变量，共享变量后会因为多个线程同时修改导致不正确的问题，所以收集一共有多少处会涉及到这些需要同步的变量，只有收集说有可能出问题的因素基于此之上保证所有元素线程安全也才能保证程序是线程安全的。 4.1.2 依赖状态的操作在某些对象的方法中还包含一些基于状态的先验条件，如删除前的非空判断，这样的操作就被称为依赖状态的操作。要想实现某个等待先验条件为真时才执行的操作，一种简单的方法是通过现有库中的类，如阻塞队列 Blocking Queue 或者信号量 Semaphore 来实现依赖状态的行为。 4.1.3 状态的所有权单独一个基本对象比较保证其安全性，但是如果是包含对象的集合（容器类 例如：ArrayList），容器类通常表现出一种 “所有权分离” 的形式。即使用线程安全的容器类（Collections.synchronizedList(List)），也只能保证容器相关的操作是线程安全的，如果发布了可变对象的引用，就不会拥有独占的控制权。（非线程安全） 4.2 实例封闭将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。封闭机制更易于构造线程安全的类，因为当封闭类的状态时，在分析类的线程安全性时就无须检查整个程序。Java 监听器模式遵循 java 监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。示例： 1234567891011121314public class Counter &#123; private long value = 0; public synchronized long getValue()&#123; return this.value; &#125; public synchronized long increment()&#123; if(value == Long.MAX_VALUE)&#123; throw new IllegalStateException(&quot;counter overflow&quot;); &#125; return ++value; &#125;&#125; 或者： 12345678910111213141516171819public class Counter &#123; private Long value = 0l; public long getValue()&#123; synchronized (value) &#123; return this.value; &#125; &#125; public long increment()&#123; synchronized (value) &#123; if(value == Long.MAX_VALUE)&#123; throw new IllegalStateException(&quot;counter overflow&quot;); &#125; return ++value; &#125; &#125;&#125; 使用私有的锁对象而不是对象的内置锁，有许多优点，私有的锁对象可以将锁封装起来，使客户端代码无法获取到锁，以便参与到它的同步策略中，避免产生活跃性问题。 synchronized 为什么不能修饰基本数据类型？因为基本数据类型是放在栈里面的，栈数据是可共享的，所以不能加 synchronized。 4.3 线程安全性委托1、客户端加锁机制 使用某个对象的代码时必须使用该对象本身用于保护其状态的锁，不推荐（同步的实现被分到两个不相关的类中）在客户端加锁，但要确保使加锁对象在实现客户端加锁或者外部加锁时使用同一个锁。 123456789101112@ThreadSafe public class ListHelper&lt;E&gt;&#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x)&#123; synchronized(list)&#123;//使List在实现客户端加锁或者外部加锁时使用同一个锁 boolean absent = !list.contains(x); if(absent) list.add(x); return absent; &#125; &#125; &#125; 另外一个更好的方式是使用组合 12345678910111213@ThreadSafe public class ImprovedList&lt;T&gt; implements List&lt;T&gt;&#123; private final List&lt;T&gt; list; public ImprovedList(List&lt;T&gt; list)&#123; this.list = list; &#125; public synchronized boolean putIfAbsent(T x)&#123; boolean contains = list.contains(x); if(!contains) list.add(x); return !contains; &#125; &#125; 4.4 在现有的安全类中添加功能 扩展类 123456789101112ThreadSafepublic class BetterVector &lt;E&gt; extends Vector&lt;E&gt; &#123; // When extending a serializable class, you should redefine serialVersionUID static final long serialVersionUID = -3963416950630760754L; public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !contains(x); if (absent) add(x); return absent; &#125;&#125; 这种方法比较脆弱，同步策略分散在多个类中单独维护，比如Vector变了实现，这里面就失效了。 4.4.1 客户端加锁1234567891011@NotThreadSafeclass BadListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125;&#125; 非常经典的例子，本来是想做到安全，但是不是用的同一把锁。正确的如下： 12345678910111213@ThreadSafeclass GoodListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x) &#123; synchronized (list) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125; &#125;&#125; 4.4.2 组合1234567891011121314151617@ThreadSafepublic class ImprovedList&lt;T&gt; implements List&lt;T&gt; &#123; private final List&lt;T&gt; list; /** * PRE: list argument is thread-safe. */ public ImprovedList(List&lt;T&gt; list) &#123; this.list = list; &#125; public synchronized boolean putIfAbsent(T x) &#123; boolean contains = list.contains(x); if (contains) list.add(x); return !contains; &#125; //...&#125; 完全不暴露list出去，额外一层加锁。 4.5 将同步策略文档化在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 笔记三]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22-2%2F</url>
    <content type="text"><![CDATA[第三章 对象的共享 我们已经知道了同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字 synchronized 只能用于实现原子性和确定 “临界区 (Critical Section)”。同步还有另一个重要的方面：内存可见性 (Memory Visibility)。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。你可以通过显式的同步或者类库中内置的同步来确保对象被安全的发布。 3.1 可见性可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。在单线程环境中，如果向某个变量先写入值，然后在没有其他写入的情况下读取这个变量，那么总能得到相同的值。然而，当读取操作和写入操作在不同的线程中执行时，情况却并非如此。通常，我们无法确保执行读取操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制，例如： 12345678910111213141516171819public class NoVisibility &#123; private static boolean ready; private static int number; private static class ReaderThread extends Thread &#123; public void run() &#123; while(!ready) Thread.yield(); System.out.println(number); &#125; &#125; public static void main(String[] args) &#123; // 从代码上来看，先执行run函数，在设置number和ready的值 new ReaderThread().start(); number = 42; ready = true; &#125;&#125; NoVisibility 可能会持续循环下去，因为读线程可能永远都看不到 ready 的值。一种更奇怪的现象是，NoVisibility 可能会输出 0，因为读线程可能看到了写入 ready 的值，但却没有看到之后写入 number 的值，这种现象被称为 “重排序 (Reordering)”。只要在某个线程中无法检测到重排序情况，那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主程序先写入 number，然后在没有同步的情况下写入 ready，那么读线程看到的顺序可能与写入的顺序完全相反。 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。 3.1.1 失效数据NoVisibility 展示了在缺乏同步的程序中可能产生的错误结果的一种：失效数据。当读线程查看 ready 变量时，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步。否则很可能获得该变量的一个失效值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。再看来一个例子： 123456789101112// 线程不安全public class MutableInteger &#123; private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125;&#125; MutableInteger 不是线程安全的，因为 get 和 set 都是在没有同步的情况下访问 value 的。如果某个线程调用了 set，那么另一个正在调用 get 的线程可能会看到更新后的 value 值，也可能看不到。下面将该类改写成线程安全的： 123456789101112// 线程安全public class MutableInteger &#123; private int value; public synchronized int getValue() &#123; return value; &#125; public synchronized void setValue(int value) &#123; this.value = value; &#125;&#125; 通过对 get 和 set 等方法进行同步，可以使 MutableInteger 成为一个线程安全的类。仅仅对 set 方法进行同步是不够的，调用 get 的线程仍然会看到失效值。 3.1.2 非原子的 64 位操作 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性 (out-of-thin-airsafety)。 最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值变量 (double 和 long)。Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非 volatile 类型的 long 和 double 变量，JVM 允许将 64 位的读操作或写操作分解为两个 32 位的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的 long 和 double 等类型的变量也不是安全的，除非用关键字 volatile 来声明他们，或者用锁保护起来。 3.1.3 加锁与可见性在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下读取某个变量，那么读到的可能是一个失效值。 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读取操作或者写入操作的线程都必须在同一个锁上同步。 3.1.4 Volatile 变量Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器在运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一个重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。 注意，在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。 volatile 变量对可见性的影响比 volatile 变量本身更为重要。从内存可见性的角度来看，写入 volatile 变量相当于退出同步代码块，而读取 volatile 变量相当于进入同步代码块。然而，并不建议过度依赖 volatile 变量提供可见性。 仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。 volatile 变量的正确使用方式包括：确保他们自身的状态的可见性，确保他们所引用的对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如，初始化或关闭）。 虽然 volatile 变量很方便，但也存在一些局限性。volatile 变量通常用作某个操作完成、发生中断或者状态的标志。尽管 volatile 变量也可以用于表示其他的状态信息，但在使用时要非常小心。例如，volatile 的语义不足以确保递增操作 (count++) 的原子性，除非你能确保只有一个线程对变量执行写操作。 加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。 当且仅当满足一下所有条件时，才应该使用 volatile 变量： 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值； 该变量不会与其他状态变量一起纳入不变性条件中； 在访问变量时不需要加锁； 3.2 发布与逸出 发布 (Publish) 一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。在许多情况中，我们要确保对象及其内部状态不被发布。而在某些情况下，我们有需要发布这个对象，但如果在发布时要确保线程安全性，则可能需要同步。发布内部状态会破坏封装性，并使程序难以维持不变性条件。当某个不应该发布的对象被发布时，这种情况就被称为逸出(Escape)。例如： 12345public static Set&lt;Secret&gt; knownSecrets;public void initialize() &#123; knownSecrets = new HashSet&lt;Secret&gt;();&#125; 在 initialize 方法中实例化一个新的 HashSet 对象，并将对象的引用保存到 knownSecrets 中以发布对象。 3.2.1 避免内部的可变状态逸出当发布某个对象时，可能会间接发布其他对象。如果将一个 Secret 对象添加到集合 knownSecrets 中，那么同样会发布这个对象，因为任何代码都可以遍历这个集合，并获得对这个新 Secret 对象的引用。同样，如果从非私有方法中返回一个引用，那么同样会发布返回的对象。看一段代码： 1234567class UnsafeStates &#123; private String[] states = new String[] &#123; "AK", "AL", ... &#125;; public String[] getStates() &#123; return states; &#125;&#125; 如果按照上面的代码发布 states，就会出现问题，因为任何调用者都能修改这个数组的内容。在这个例子中，数组 states 已经逸出了它所在的作用域，因为这个本应是私有的变量已经被发布了。 当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。 3.2.2 隐式地使 this 引用逸出最后一种发布对象或其内部状态的机制就是发布一个内部的类实例，例如： 1234567891011publi class ThisEscape &#123; public ThisEscape(EventSource source) &#123; source.registerListener &#123; new EventListener() &#123; public void onEvent(Event e) &#123; doSomething(e); &#125; &#125; &#125;; &#125;&#125; 不要在构造过程中使 this 引用逸出。 当内部的 EventListener 实例发布时，在外部封装的 ThisEscape 实例也逸出了。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果 this 引用在构造过程中逸出，那么这种对象就被认为是不正确构造。 可以使用工厂方式来防治 this 引用在构造过程中逸出。 3.3 线程封闭当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭 (Thread Confinement)，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。 在 Java 语言中并没有强制规定某个变量必须由锁来保护，同样在 Java 语言中也无法强制将对象封闭在某个线程中。线程封闭式在程序设计中的一个考虑因素，必须在程序中实现。Java 语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和 ThreadLocal类 。但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。 3.3.1 Ad-hoc 线程封闭Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭式非常脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。事实上，对线程封闭对象的引用通常保存在公有变量中。 当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程子系统。在某些情况下，单线程子系统提供的简便性要胜过 Ad-hoc 线程封闭技术的脆弱性。 举个例子，在 volatile 变量上存在一种特殊的线程封闭。只要你能确定只有单个线程对共享的 volatile 变量执行写入操作，那么就可以安全的在这些共享的 volatile 变量上执行 “读取 - 修改 - 写入” 的操作。在这种情况下，相当于修改操作封闭在单个线程中以防止发生竞态条件，并且 volatile 变量的可见性保证还确保了其他线程能看到最新的值。 由于 Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量少用它，可能的情况下，应该使用更强的线程封闭技术（例如，栈封闭和 ThreadLocal 类）。 3.3.2 栈封闭栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。正如封装能使得代码更容易维持不变性条件那样，同步变量也能使对象更易于封闭在线程中。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比 Ad-hoc 线程封闭更易于维护，也更加健壮。 12345678910111213141516171819public int loadTheArk(Collection&lt;Animal&gt; candidates) &#123; SortedSet&lt;Animal&gt; animals; int numPairs = 0; Animal candidate = null; animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator()); animals.addAll(candidates); for (Animal a : animals) &#123; if (candidate == null || !candidate.isPotentialMate(a)) candidate = a; else &#123; ark.load(new AnimalPair(candidate, a)); ++numPairs; candidate = null; &#125; &#125; return numPairs;&#125; 在上面的代码中，numPairs 无论如何都不会破坏栈封闭性。由于任何方法都无法获得对基本类型的引用，因此 Java 语言的这种语义就确保了基本类型的局部变量封闭在线程内。 在维持对象引用的栈封闭性时，程序员需要多做一些工作以确保被引用的对象不会逸出。在 loadTheArk 中实例化一个 TreeSet 对象，并将指向该对象的一个引用确保到 animals 中。此时，只有一个引用指向集合 animals，这个引用被封闭在局部变量中，因此也被封闭在执行线程中。然而，如果发布了对集合 animals 的引用，那么封闭性将被破坏，并导致对象 animals 的逸出。 3.3.3 ThreadLocal 类维持线程封闭性的一种更规范方式是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本。因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。 ThreadLocal 对象通常用于防止对可变的单实例变量 (Singleton) 或全局变量进行共享。例如 Connection 对象，由于 JDBC 的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的链接，例如： 12345678910111213141516171819 public class ConnectionDispenser &#123; static String DB_URL = "jdbc:mysql://localhost/mydatabase"; private ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123; public Connection initialValue() &#123; try &#123; return DriverManager.getConnection(DB_URL); &#125; catch (SQLException e) &#123; throw new RuntimeException("Unable to acquire Connection, e"); &#125; &#125;; &#125;; public Connection getConnection() &#123; return connectionHolder.get(); &#125;&#125; 在实现应用程序框架时大量使用了 ThreadLocal。例如，在 EJB 调用期间，J2EE 容器需要将一个事务上下文 (Transaction Context) 与某个执行中的线程关联起来。通过将事务上下文保存在静态的 ThreadLocal 对象中，可以很容易地实现这个功能：当框架代码需要判断当前运行的是哪一个事务时，只需从这个 ThreadLocal 对象中读取事务上下文。 开发人员经常滥用 ThreadLocal，例如将所有的全局变量都作为 ThreadLocal 对象，或者作为一种 “隐藏” 方法参数的手段。ThreadLocal 变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时需要格外小心。 3.4 不变性如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象 (Immutable Object)。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。 不可变对象一定是线程安全的。 不可变对象很简单。它们只有一种状态，并且该状态由构造函数来控制。在程序设计中，一个最困难的地方就是判断复杂对象的可能状态。然而，判断不可变对象的状态却很简单。 同样，不可变对象也更加安全。如果将一个可变对象传递给不可信的代码，或者将该对象发布到不可信代码可以访问它的地方，那么就很危险 —— 不可信代码会改变它们的状态，更糟的是，在代码中将保留一个对该对象的引用并稍后再其他线程中修改对象的状态。另一方面，不可变对象不会像这样被恶意代码或者有问题的代码破坏，因此可以安全地共享和发布这些对象，而无须创建保护性的副本。 虽然在 Java 语言规范和 Java 内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为 final 类型，即使对象中所有的域都是 final 类型的，这个对象也仍然是可变的，因为在 final 类型的域中可以保存对可变对象的引用。 当满足一下条件时，对象才是不可变的： 对象创建以后其状态就不能修改； 对象的所有域都是 fianl 类型； 对象是正确创建的； 关键字 final 可以视为 C++ 中 const 机制的一种受限版本，用于构造不可变性对象。final 类型的域是不能修改的。然而，在 Java 内存模型中，final 域还有着特殊的语义。final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步。 即使对象是可变的，通过将对象的某些域声明为 final 类型，仍然可以简化对状态的判断，因此限制对象的可变性也就相当于限制了该对象可能的状态集合。仅包含一个或两个可变状态的 “基本不可变” 对象仍然比包含多个可变状态的对象简单。通过将域声明为 final 类型，也相当于告诉维护人员这些域是不会变化的。 除非需要某个域是可变的，否则应将其声明为 final 域。 3.5 安全发布到目前为止，我们重点讨论的是如何确保对象不被发布，例如让对象封闭在线程或另一个对象的内部。当然，在某些情况下我们希望在多个线程之间共享对象，此时必须确保安全的进行共享。看一段代码： 1234public Holder holder;public void initialize() &#123; holder = new Holder(42);&#125; 这段代码中，将引用对象保存到公有域中，那么还不足以安全得发布这个对象。由于存在可见性问题，其他线程看到的 Holder 对象将处于一个不一致的状态，即便在该对象的构造函数中已经正确的构造了不变性条件。这种不正确的发布导致其他线程看到尚未创建完成的对象。 3.5.1 不正确的发布：正确的对象被破坏你不能指望一个尚未被完全创建的对象拥有完整性。某个观察该对象的线程将看到对象处于不一致状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。例如： 123456789public class Holder &#123; private int n; public Holder(int n) &#123;this.n = n;&#125; public void assertSanity() &#123; if (n != n) throw new AssertionError("this statement is false."); &#125;&#125; 由于没有使用同步来确保 Holder 对象对其他线程可见，因此将 Holder 称为 “未被正确发布”。这里面存在两个问题，首先，除了发布对象的线程外，其他线程可以看到的 Holder 域是一个失效值，因此将看到一个空引用或者之前的旧值。然而，更糟的情况是线程看到 Holder 引用的值是最新的，但 Holder 状态的值却是失效的。情况变得更加不可预测的是，某个线程在第一次读取域时得到失效值，而再次读取这个域时会得到一个更新值，这也是 assertSainty 抛出 AssertionError 的原因。 3.5.2 不可变对象与初始化安全性由于不可变对象是一种非常重要的对象，因此 Java 内存模型为不可变对象提供了一种特殊的初始化安全性保证。我们已经知道，即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一直的视图，就必须使用同步。 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。 3.5.3 安全发布的常用模式要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布： 在静态初始化函数中初始化一个对象引用； 将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中； 将对象的引用保存到某个正确构造对象的 final 类型域中； 将对象的引用保存到一个由锁保护的域中； 在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如 Vector 或 synchronizedList 时，将满足上述最后一条需求。 3.5.4 事实不可变对象如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全地访问这些对象的线程来说，安全发布是足够的。所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将是可见的，并且如果对象状态不会再改变，那么就足以确保任何访问都是安全的。 在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。 3.5.5 可变对象如果对象在构造后可以修改，那么安全发布只能确保 “发布当时” 状态的可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。 对象的发布需求取决于它的可变性： 不可变对象可以通过任意机制来发布； 事实不可变对象必须通过安全方式来发布； 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来； 3.5.6 安全的共享对象在并发程序中使用和共享对象时，可以使用一些实用的策略，包括： 线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改； 只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象； 线程安全共享：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步； 保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象； 参考：https://my.oschina.net/u/2450666/blog/737432]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程习惯分析 实现方法]]></title>
    <url>%2F2018%2F03%2F22%2F2018-03-22%2F</url>
    <content type="text"><![CDATA[「需输入密码」 Decrypt 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]]></content>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 笔记二]]></title>
    <url>%2F2018%2F03%2F21%2F2018-03-21%2F</url>
    <content type="text"><![CDATA[第二章 线程安全性Thread Safety 对象的状态指存储在状态变量（实例变量、静态域）中的数据，对象的状态可能包括其他依赖对象的域 “共享” 意味着变量可以由多个线程访问；“可变” 意味着变量的值在其声明周期内可以发生变化 多个线程访问同一个可变的状态变量没有使用合适的同步，就可能出现错误，有三种方式可以修复这个问题 a. 不在线程之间共享该状态变量 b. 将该状态变量修改为不可变的变量 c. 在使用状态变量时使用同步 2.1 什么是线程安全性正确性：某个类的行为与其规范完全一致 当多个线程访问某个类时，不管运行环境采用何种调用方式或者这些线程如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的 无状态类一定是线程安全的 2.2 原子性2.2.1 竞态条件由于不恰当的执行时序而出现的不正确的结果的情况称为竞态条件 最常见的竞态条件类型就是 “先检查后执行（Check-then-Act）” “读取 - 修改 - 写入” 操作也是一种竞态条件 一个很常见的例子就是延迟初始化。当一个线程根据观察结果为空进行初始化时，一个线程可能已经建立了初始化。 1234567891011@NotThreadSafepublic class LazyInitRace &#123; private SampleClass sample; public SampleClass getInstance() &#123; if (instance == null) &#123; instance = new SampleClass(); &#125; return instance; &#125;&#125; 2.2.2 延迟初始化中的竞态条件2.2.3 复合操作原子操作：对于访问同一个状态的所有操作（包括操作本身）来说，这个操作是一个以原子方式执行的操作 复合操作：包含了一组必须以原子方式执行的操作以保证线程安全性 当在无状态的类中加入一个状态时，如果该状态完全由线程安全的对象管理，那么这个类仍旧是线程安全的 2.3 加锁机制要保证状态一致性，就需要单个原子操作中更新所有相关的状态变量 2.3.1 内置锁Java提供的一种内置锁机制：同步代码块。同步代码块包括两个部分：有个作为锁的对象引用，一个作为由这个锁保护的代码块，常见的有synchronized关键字： 123synchronized (lock) &#123; // TODO&#125; 同步代码块（Synchronized Block） 每个 Java 对象都可以用作一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或者监视器锁（Monitor Lock） 内置锁是一种互斥锁，最多只有一个线程持有这个锁 2.3.2 重入重入意味着获取锁的操作的粒度是 “线程”，而不是 “调用” 重入提升了加锁行为的封装性，因此简化了面向对象并发代码的执行 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞。而如果这个线程试图获取已经由它自己持有的锁，则这个请求就会成功。否则，就会导致死锁的发生。简单示例如下： 1234567public class Parent &#123; public synchronized void parentMethod &#123; ... &#125;&#125;public class Child extends Parent &#123; public synchronized void childMethod &#123; ... &#125;&#125; 2.4 用锁来保护状态锁能够使其被保护的对象以串行方式来执行 一种常见的加锁机制：将所有可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得该对象上不会发生并发访问 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护 2.5 活跃性与性能通常，在简单性与性能之间存在着相互制约因素，但是实现某个同步策略时，一定不要为了性能而牺牲简单性（这可能会破坏安全性） 当执行时间较长的计算或者可能无法快速完成的操作（例如网络 I/O 或者控制台 I/O）, 一定不要持有锁 参考:https://www.jianshu.com/p/facf03fb385a]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读十一：ConcurrentHashMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-14%2F</url>
    <content type="text"><![CDATA[概述ConcurrentHashMap 是 Java 并发框架中很重要的一个类，是实现支持高并发、高吞吐量的线程安全的 HashMap。当然不能直接对整个 hashtable 加锁，所以在 ConcurrentHashMap 中，数据的组织结构和 HashMap 有所区别。 与 HashTable 区别下面这幅图直观展示了 ConcurrentHashMap 与 HashTable 的区别，可以看到 HashTable 是对整个 Hash 表进行加锁，而 ConcurrentHashMap 则是分段加锁，加锁的基本单元为 Segment ConcurrentHashMap 原理分析ConcurrentHashMap 的结构是比较复杂的，深究去本质，其实也就是数组和链表而已。我们由浅入深慢慢的分析其结构。 SegmentSegment 是 ConcurrentHashMap 的内部类，Segment 的类定义为 1static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable 其继承于 ReentrantLock 类，从而使得 Segment 对象可以充当锁的角色。Segment 中包含 HashEntry 的数组，其可以守护其包含的若干个桶（HashEntry 的数组）。Segment 在某些意义上有点类似于 HashMap 了，都是包含了一个数组，而数组中的元素可以是一个链表。 tabletable 是由 HashEntry 对象组成的数组如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表 table 数组的数组成员代表散列映射表的一个桶每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16。 count 变量是计数器，表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 的链表）包含的 HashEntry 对象的个数。之所以在每个 Segment 对象中包含一个 count 计数器，而不在 ConcurrentHashMap 中使用全局的计数器，是为了避免出现 “热点域” 而影响并发性。 HashEntryHashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。其类的定义为： 123456789101112131415static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ... ...&#125; HashEntry 的学习可以类比着 HashMap 中的 Entry。我们的存储键值对的过程中，散列的时候如果发生 “碰撞”，将采用“分离链表法” 来处理碰撞：把碰撞的 HashEntry 对象链接成一个链表。 并发 put 操作在 ConcurrentHashMap 中，当执行 put 方法的时候，会需要加锁来完成。我们通过代码来解释一下具体过程： 当我们 new 一个 ConcurrentHashMap 对象，并且执行 put 操作的时候，首先会执行 ConcurrentHashMap 类中的 put 方法，该方法源码为： 123456789101112@SuppressWarnings(&quot;unchecked&quot;) public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false); &#125; 我们通过注释可以了解到，ConcurrentHashMap 不允许空值。该方法首先有一个 Segment 的引用 s，然后会通过 hash() 方法对 key 进行计算，得到哈希值；继而通过调用 Segment 的 put(K key, int hash, V value, boolean onlyIfAbsent) 方法进行存储操作。该方法源码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; //加锁，这里是锁定的Segment而不是整个ConcurrentHashMap HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value); V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; //得到hash对应的table中的索引index int index = (tab.length - 1) &amp; hash; //找到hash对应的是具体的哪个桶，也就是哪个HashEntry链表 HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; //解锁 unlock(); &#125; return oldValue;&#125; 关于该方法的某些关键步骤，在源码上加上了注释。 需要注意的是：加锁操作是针对的 hash 值对应的某个 Segment，而不是整个 ConcurrentHashMap。因为 put 操作只是在这个 Segment 中完成，所以并不需要对整个 ConcurrentHashMap 加锁。所以，此时，其他的线程也可以对另外的 Segment 进行 put 操作，因为虽然该 Segment 被锁住了，但其他的 Segment 并没有加锁。同时，读线程并不会因为本线程的加锁而阻塞。 正是因为其内部的结构以及机制，所以 ConcurrentHashMap 在并发访问的性能上要比 Hashtable 和同步包装之后的 HashMap 的性能提高很多。在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。 get 操作Get 方法的实现 12345678910111213141516V get(Object key, int hash) &#123; if(count != 0) &#123; // 首先读 count 变量 HashEntry&lt;K,V&gt; e = getFirst(hash); while(e != null) &#123; if(e.hash == hash &amp;&amp; key.equals(e.key)) &#123; V v = e.value; if(v != null) return v; // 如果读到 value 域为 null，说明发生了重排序，加锁后重新读取 return readValueUnderLock(e); &#125; e = e.next; &#125; &#125; return null; &#125; ConcurrentHashMap 中的读方法不需要加锁，所有的修改操作在进行结构修改时都会在最后一步写 count 变量，通过这种机制保证 get 操作能够得到几乎最新的结构更新。 总结在实际的应用中，散列表一般的应用场景是：除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。正是基于这个前提，ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得 大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。 ConcurrentHashMap 的高并发性主要来自于三个方面： 用分离锁实现多个线程间的更深层次的共享访问。 用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读十：HashTable]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-13%2F</url>
    <content type="text"><![CDATA[HashTable 介绍 HashTable 经常和 HashMap 拿来做对比。HashTable 同样是基于哈希表实现的，同样每个元素都是 key-value 对，其内部也是通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。Hashtable 也是 JDK1.0 引入的类，是线程安全的，能用于多线程环境中。Hashtable 同样实现了 Serializable 接口，它支持序列化，实现了 Cloneable 接口，能被克隆。 HashTable 类层次结构如下 HashTable 源码HashTable 源码如下，加入了比较详细的注释，(基于 Sun JDK 1.7)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835package java.util;import java.io.*;public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; // 保存key-value的数组。 // Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表 private transient Entry&lt;K,V&gt;[] table; // Hashtable中键值对的数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数，用于fail-fast机制的实现 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; /** * The default threshold of map capacity above which alternative hashing is * used for String keys. Alternative hashing reduces the incidence of * collisions due to weak hash code calculation for String keys. * &lt;p&gt; * This value may be overridden by defining the system property * &#123;@code jdk.map.althashing.threshold&#125;. A property value of &#123;@code 1&#125; * forces alternative hashing to be used at all times whereas * &#123;@code -1&#125; value ensures that alternative hashing is never used. */ static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE; /** * holds values which can&apos;t be initialized until after VM is booted. */ private static class Holder &#123; /** * Table capacity above which to switch to use alternative hashing. */ static final int ALTERNATIVE_HASHING_THRESHOLD; static &#123; String altThreshold = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction( &quot;jdk.map.althashing.threshold&quot;)); int threshold; try &#123; threshold = (null != altThreshold) ? Integer.parseInt(altThreshold) : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT; // disable alternative hashing if -1 if (threshold == -1) &#123; threshold = Integer.MAX_VALUE; &#125; if (threshold &lt; 0) &#123; throw new IllegalArgumentException(&quot;value must be positive integer.&quot;); &#125; &#125; catch(IllegalArgumentException failed) &#123; throw new Error(&quot;Illegal value for &apos;jdk.map.althashing.threshold&apos;&quot;, failed); &#125; ALTERNATIVE_HASHING_THRESHOLD = threshold; &#125; &#125; // 指定“容量大小”的构造函数 final boolean initHashSeedAsNeeded(int capacity) &#123; boolean currentAltHashing = hashSeed != 0; boolean useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean switching = currentAltHashing ^ useAltHashing; if (switching) &#123; hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(this) : 0; &#125; return switching; &#125; private int hash(Object k) &#123; // hashSeed will be zero if alternative hashing is disabled. return hashSeed ^ k.hashCode(); &#125; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); initHashSeedAsNeeded(initialCapacity); &#125; // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f); &#125; // 默认构造函数。 public Hashtable() &#123; // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); &#125; // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t); &#125; public synchronized int size() &#123; return count; &#125; public synchronized boolean isEmpty() &#123; return count == 0; &#125; // 返回“所有key”的枚举对象 public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; // 返回“所有value”的枚举对象 public synchronized Enumeration&lt;V&gt; elements() &#123; return this.&lt;V&gt;getEnumeration(VALUES); &#125; // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) &#123; if (value == null) &#123; throw new NullPointerException(); &#125; Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean containsValue(Object value) &#123; return contains(value); &#125; // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false; &#125; // 返回key对应的value，没有的话返回null public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 调整Hashtable的长度，将长度变成原来的2倍+1 protected void rehash() &#123; int oldCapacity = table.length; Entry&lt;K,V&gt;[] oldMap = table; // overflow-conscious code int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; if (oldCapacity == MAX_ARRAY_SIZE) // Keep running with MAX_ARRAY_SIZE buckets return; newCapacity = MAX_ARRAY_SIZE; &#125; Entry&lt;K,V&gt;[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); boolean rehash = initHashSeedAsNeeded(newCapacity); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; if (rehash) &#123; e.hash = hash(e.key); &#125; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; &#125; &#125; &#125; // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; modCount++; if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; hash = hash(key); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; return null; &#125; // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null; &#125; // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue()); &#125; // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() &#123; Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0; &#125; // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() &#123; try &#123; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) &#123; t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; &#125; t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); &#125; &#125; public synchronized String toString() &#123; int max = size() - 1; if (max == -1) return &quot;&#123;&#125;&quot;; StringBuilder sb = new StringBuilder(); Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator(); sb.append(&apos;&#123;&apos;); for (int i = 0; ; i++) &#123; Map.Entry&lt;K,V&gt; e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? &quot;(this Map)&quot; : key.toString()); sb.append(&apos;=&apos;); sb.append(value == this ? &quot;(this Map)&quot; : value.toString()); if (i == max) return sb.append(&apos;&#125;&apos;).toString(); sb.append(&quot;, &quot;); &#125; &#125; // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。 private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return Collections.emptyEnumeration(); &#125; else &#123; return new Enumerator&lt;&gt;(type, false); &#125; &#125; // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) &#123; if (count == 0) &#123; return Collections.emptyIterator(); &#125; else &#123; return new Enumerator&lt;&gt;(type, true); &#125; &#125; // Views // Hashtable的“key的集合”。它是一个Set，没有重复元素 private transient volatile Set&lt;K&gt; keySet = null; // Hashtable的“key-value的集合”。它是一个Set，没有重复元素 private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素 private transient volatile Collection&lt;V&gt; values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;K&gt; keySet() &#123; if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; &#125; // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return getIterator(KEYS); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return Hashtable.this.remove(o) != null; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; &#125;// Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return getIterator(ENTRIES); &#125; public boolean add(Map.Entry&lt;K,V&gt; o) &#123; return super.add(o); &#125; // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash &amp;&amp; e.equals(entry)) return true; return false; &#125; // 删除元素Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，删除链表中的元素Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e.hash==hash &amp;&amp; e.equals(entry)) &#123; modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; &#125; &#125; return false; &#125; public int size() &#123; return count; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection&lt;V&gt; values() &#123; if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; &#125; // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return getIterator(VALUES); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // Comparison and hashing // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o; if (t.size() != size()) return false; try &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(t.get(key)==null &amp;&amp; t.containsKey(key))) return false; &#125; else &#123; if (!value.equals(t.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true; &#125; // 计算Entry的hashCode // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。 // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。 public synchronized int hashCode() &#123; int h = 0; if (count == 0 || loadFactor &lt; 0) return h; // Returns zero loadFactor = -loadFactor; // Mark hashCode computation in progress Entry[] tab = table; for (Entry&lt;K,V&gt; entry : tab) while (entry != null) &#123; h += entry.hashCode(); entry = entry.next; &#125; loadFactor = -loadFactor; // Mark hashCode computation complete return h; &#125; // java.io.Serializable的写入函数 // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; Entry&lt;K, V&gt; entryStack = null; synchronized (this) &#123; // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements s.writeInt(table.length); s.writeInt(count); // Stack copies of the entries in the table for (int index = 0; index &lt; table.length; index++) &#123; Entry&lt;K,V&gt; entry = table[index]; while (entry != null) &#123; entryStack = new Entry&lt;&gt;(0, entry.key, entry.value, entryStack); entry = entry.next; &#125; &#125; &#125; // Write out the key/value objects from the stacked entries while (entryStack != null) &#123; s.writeObject(entryStack.key); s.writeObject(entryStack.value); entryStack = entryStack.next; &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it&apos;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that&apos;s not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry&lt;K,V&gt;[] newTable = new Entry[length]; threshold = (int) Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1); count = 0; initHashSeedAsNeeded(length); // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(newTable, key, value); &#125; this.table = newTable; &#125; /** * The put method used by readObject. This is provided because put * is overridable and should not be called in readObject since the * subclass will not yet be initialized. * * &lt;p&gt;This differs from the regular put method in several ways. No * checking for rehashing is necessary since the number of elements * initially in the table is known. The modCount is not incremented * because we are creating a new instance. Also, no return value * is needed. */ private void reconstitutionPut(Entry&lt;K,V&gt;[] tab, K key, V value) throws StreamCorruptedException &#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; &#125; // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 哈希值 int hash; final K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; protected Object clone() &#123; return new Entry&lt;&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); &#125; // Map.Entry Ops public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; // 设置value。若value是null，则抛出异常。 public V setValue(V value) &#123; if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; &#125; // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry)o; return key.equals(e.getKey()) &amp;&amp; value.equals(e.getValue()); &#125; public int hashCode() &#123; return (Objects.hashCode(key) ^ Objects.hashCode(value)); &#125; public String toString() &#123; return key.toString()+&quot;=&quot;+value.toString(); &#125; &#125; // Types of Enumerations/Iterations private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null; &#125; // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException(&quot;Hashtable Enumerator&quot;); &#125; // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() &#123; return hasMoreElements(); &#125; // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException(&quot;Hashtable Enumerator&quot;); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125; &#125;&#125; 重点解析从以上的源码中，我们可以看到，HashTable 和 HashMap 还是非常相似的。 相同点 二者的存储结构和解决冲突的方法都是相同的。HashTable 同样是基于哈希表实现的，同样每个元素都是 key-value 对，其内部也是通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。 Hashtable 同样实现了 Serializable 接口，它支持序列化，实现了 Cloneable 接口，能被克隆。 不同点 最重要一点 HashTable 是很多方法都加了同步，因此支持多线程并发执行，是线程同步的而 HashMap 不是线程同步的。 HashTable 在不指定容量的情况下的默认容量为 11，而 HashMap 为 16，Hashtable 不要求底层数组的容量一定要为 2 的整数次幂，而 HashMap 则要求一定为 2 的整数次幂。 Hashtable 中 key 和 value 都不允许为 null，而 HashMap 中 key 和 value 都允许为 null（key 只能有一个为 null，而 value 则可以有多个为 null）。但是如果在 Hashtable 中有类似 put(null,null) 的操作，编译同样可以通过，因为 key 和 value 都是 Object 类型，但运行时会抛出NullPointerException异常，这是 JDK 的规范规定的。 Hashtable 扩容时，将容量变为原来的 2 倍加 1，而 HashMap 扩容时，将容量变为原来的 2 倍。 Hashtable 计算 hash 值，直接用 key 的 hashCode()，而 HashMap 重新计算了 key 的 hash 值，Hashtable 在求 hash 值对应的位置索引时，用取模运算，而 HashMap 在求位置索引时，则用与运算，且这里一般先用 hash&amp;0x7FFFFFFF 后，再对 length 取模，&amp;0x7FFFFFFF 的目的是为了将负的 hash 值转化为正值，因为 hash 值有可能为负数，而 &amp; 0x7FFFFFFF 后，只有符号外改变，而后面的位都不变。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读九：HashTable]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-12%2F</url>
    <content type="text"><![CDATA[Vector 介绍Vector 也是基于数组实现的，是一个动态数组，其容量能自动增长。Vector 是 JDK1.0 引入了，它的很多实现方法都加入了同步语句，因此是线程安全的（其实也只是相对安全，有些时候还是要加入同步语句来保证线程的安全），可以用于多线程环境。Vector 实现了 Serializable 接口，可以被序列化，Cloneable 接口，能被克隆，实现了 RandomAccess 接口，支持快速随机访问。 Vector 类层次 Vector 源码分析以下是 Vector 的源码，基于 Sun JDK1.7 版本，加入了较为详细的注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606package java.util;public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 保存Vector中数据的数组 protected Object[] elementData; // 实际数据的数量 protected int elementCount; // 容量增长系数 protected int capacityIncrement; // Vector的序列版本号 private static final long serialVersionUID = -2767605614048989439L; // 指定Vector&quot;容量大小&quot;和&quot;增长系数&quot;的构造函数 public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; &#125; // 指定Vector容量大小的构造函数 public Vector(int initialCapacity) &#123; this(initialCapacity, 0); &#125; // Vector构造函数。默认容量是10。 public Vector() &#123; this(10); &#125; // 指定集合的Vector构造函数。 public Vector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); &#125; // 将数组Vector的全部元素都拷贝到数组anArray中 public synchronized void copyInto(Object[] anArray) &#123; System.arraycopy(elementData, 0, anArray, 0, elementCount); &#125; // 将当前容量值设为 =实际元素个数 public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125; &#125; // 确定Vector的容量。 public synchronized void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) &#123; modCount++; ensureCapacityHelper(minCapacity); &#125; &#125; // 确认“Vector容量”的帮助函数 private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize; &#125; // 返回“Vector的总的容量” public synchronized int capacity() &#123; return elementData.length; &#125; // 返回“Vector的实际大小”，即Vector中元素个数 public synchronized int size() &#123; return elementCount; &#125; // 判断Vector是否为空 public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; // 返回“Vector中全部元素对应的Enumeration” public Enumeration&lt;E&gt; elements() &#123; // 通过匿名类实现Enumeration return new Enumeration&lt;E&gt;() &#123; int count = 0; // 是否存在下一个元素 public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; // 获取下一个元素 public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return elementData(count++); &#125; &#125; throw new NoSuchElementException(&quot;Vector Enumeration&quot;); &#125; &#125;; &#125; // 返回Vector中是否包含对象(o) public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0; &#125; // 返回Vector中是否包含对象(o) public int indexOf(Object o) &#123; return indexOf(o, 0); &#125; // 从index位置开始向后查找元素(o)。 // 若找到，则返回元素的索引值；否则，返回-1 public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; // 若查找元素为null，则正向找出null元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; // 若查找元素不为null，则正向找出该元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 从后向前查找元素(o)。并返回元素的索引 public synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1); &#125; // 从后向前查找元素(o)。开始位置是从前向后的第index个数； // 若找到，则返回元素的“索引值”；否则，返回-1。 public synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot;+ elementCount); if (o == null) &#123; // 若查找元素为null，则反向找出null元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; // 若查找元素不为null，则反向找出该元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回Vector中index位置的元素。 // 若index越界，则抛出异常 public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; return elementData(index); &#125; // 获取Vector中的第一个元素。 // 若失败，则抛出异常！ public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; // 获取Vector中的最后一个元素。 // 若失败，则抛出异常！ public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; // 设置index位置的元素值为obj public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; elementData[index] = obj; &#125; // 删除index位置的元素 public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */ &#125; // 在index位置处插入元素(obj) public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt; &quot; + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; &#125; // 将“元素obj”添加到Vector末尾 public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; // 在Vector中查找并删除元素obj。 // 成功的话，返回true；否则，返回false。 public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false; &#125; // 删除Vector中的全部元素 public synchronized void removeAllElements() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0; &#125; // 克隆函数 public synchronized Object clone() &#123; try &#123; @SuppressWarnings(&quot;unchecked&quot;) Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, elementCount); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(); &#125; &#125; // 返回Object数组 public synchronized Object[] toArray() &#123; return Arrays.copyOf(elementData, elementCount); &#125; // 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型 @SuppressWarnings(&quot;unchecked&quot;) public synchronized &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; Vector的元素个数； // 则新建一个T[]数组，数组大小是“Vector的元素个数”，并将“Vector”全部拷贝到新数组中 if (a.length &lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); // 若数组a的大小 &gt;= Vector的元素个数； // 则将Vector的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, elementCount); if (a.length &gt; elementCount) a[elementCount] = null; return a; &#125; // Positional Access Operations @SuppressWarnings(&quot;unchecked&quot;) E elementData(int index) &#123; return (E) elementData[index]; &#125; // 获取index位置的元素 public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); &#125; // 设置index位置的值为element。并返回index位置的原始值 public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; // 将“元素e”添加到Vector最后。 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; // 删除Vector中的元素o public boolean remove(Object o) &#123; return removeElement(o); &#125; // 在index位置添加元素element public void add(int index, E element) &#123; insertElementAt(element, index); &#125; // 删除index位置的元素，并返回index位置的原始值 public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue; &#125; // 清空Vector public void clear() &#123; removeAllElements(); &#125; // Bulk Operations // 返回Vector是否包含集合c public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123; return super.containsAll(c); &#125; // 将集合c添加到Vector中 public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; &#125; // 删除集合c的全部元素 public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123; return super.removeAll(c); &#125; // 删除“非集合c中的元素” public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123; return super.retainAll(c); &#125; // 从index位置开始，将集合c添加到Vector中 public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; modCount++; if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); int numMoved = elementCount - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0; &#125; // 返回两个对象是否相等 public synchronized boolean equals(Object o) &#123; return super.equals(o); &#125; // 计算哈希值 public synchronized int hashCode() &#123; return super.hashCode(); &#125; // 调用父类的toString() public synchronized String toString() &#123; return super.toString(); &#125; // 获取Vector中fromIndex(包括)到toIndex(不包括)的子集 public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); &#125; // 删除Vector中fromIndex到toIndex的元素 protected synchronized void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = elementCount - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; &#125; // java.io.Serializable的写入函数 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; final java.io.ObjectOutputStream.PutField fields = s.putFields(); final Object[] data; synchronized (this) &#123; fields.put(&quot;capacityIncrement&quot;, capacityIncrement); fields.put(&quot;elementCount&quot;, elementCount); data = elementData.clone(); &#125; fields.put(&quot;elementData&quot;, data); s.writeFields(); &#125; //返回从指定位置处开始的listIterator public synchronized ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; elementCount) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); return new ListItr(index); &#125; //返回listIterator public synchronized ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */ public synchronized Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; // Racy but within spec, since modifications are checked // within or after synchronization in next/previous return cursor != elementCount; &#125; public E next() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor; if (i &gt;= elementCount) throw new NoSuchElementException(); cursor = i + 1; return elementData(lastRet = i); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.remove(lastRet); expectedModCount = modCount; &#125; cursor = lastRet; lastRet = -1; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ final class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public E previous() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); cursor = i; return elementData(lastRet = i); &#125; &#125; public void set(E e) &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.set(lastRet, e); &#125; &#125; public void add(E e) &#123; int i = cursor; synchronized (Vector.this) &#123; checkForComodification(); Vector.this.add(i, e); expectedModCount = modCount; &#125; cursor = i + 1; lastRet = -1; &#125; &#125;&#125; 重点分析从上述源码可以看到，Vector 总体与 ArrayList 类似，但还是有区别的，关于 ArrayList 的分析可以查看《Java 集合框架源码分析 (一)——ArrayList》。 相同点 Vector 内部使用数组来保存元素。 Vector 实现了 RandomAccess, Cloneable, java.io.Serializable 三个标记接口，表示它自身支持快速随机访问，克隆，序列化。 如果不指定容量大小，默认情况下，Vector 容量为 10, 在 JDk1.7 中 Vector 最大容量为 Integer.MAX_VALUE - 8. 内部具备自动扩容机制，当容量不足时，会自动申请内存空间。 同样在查找给定元素索引值等的方法中，源码都将该元素的值分为 null 和不为 null 两种情况处理，Vector 中也允许元素为 null。 不同点1 . 并发性很多方法都加入了 synchronized 同步语句，来保证线程安全。2. 扩容实现方案 Vector 具体的扩容最终会调用到 grow 方法。 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; 详细扩容过程：当容量不足以容纳当前的元素个数时，就先看构造方法中传入的容量增长量参数 CapacityIncrement 是否为 0，如果不为 0，就设置新的容量为就容量加上容量增长量，如果为 0，就设置新的容量为旧的容量的 2 倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后同样用 Arrays.copyof() 方法将元素拷贝到新的数组。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读八：WeakHashMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-11%2F</url>
    <content type="text"><![CDATA[WeakHashMap总体介绍一个特殊的成员：WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。 更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况： 调用两次size()方法返回不同的值； 两次调用isEmpty()方法，第一次返回false，第二次返回true； 两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key； 两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。 遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，WeekHashMap 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。 要明白 WeekHashMap 的工作原理，还需要引入一个概念：弱引用（WeakReference）。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的“有效引用”并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。 WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 WeakHashMap 里并不能避免该key值被GC回收，除非在 WeakHashMap 之外还有对该key的强引用。 关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。 具体实现WeakHashMap的存储结构类似于HashMap，读者可自行参考前文，这里不再赘述。 关于强弱引用的管理方式，博主将会另开专题单独讲解。 Weak HashSet?如果你看过前几篇关于 Map 和 Set 的讲解，一定会问：既然有 WeekHashMap，是否有 WeekHashSet 呢？答案是没有:( 。不过Java Collections工具类给出了解决方案，Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)方法可以将任何 Map包装成一个Set。通过如下方式可以快速得到一个 Weak HashSet： 123// 将WeakHashMap包装成一个SetSet&lt;Object&gt; weakHashSet = Collections.newSetFromMap( new WeakHashMap&lt;Object, Boolean&gt;()); 不出你所料，newSetFromMap()方法只是对传入的 Map做了简单包装： 12345678910111213141516171819202122232425262728293031323334// Collections.newSetFromMap()用于将任何Map包装成一个Setpublic static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) &#123; return new SetFromMap&lt;&gt;(map);&#125;private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Serializable&#123; private final Map&lt;E, Boolean&gt; m; // The backing map private transient Set&lt;E&gt; s; // Its keySet SetFromMap(Map&lt;E, Boolean&gt; map) &#123; if (!map.isEmpty()) throw new IllegalArgumentException("Map is non-empty"); m = map; s = map.keySet(); &#125; public void clear() &#123; m.clear(); &#125; public int size() &#123; return m.size(); &#125; public boolean isEmpty() &#123; return m.isEmpty(); &#125; public boolean contains(Object o) &#123; return m.containsKey(o); &#125; public boolean remove(Object o) &#123; return m.remove(o) != null; &#125; public boolean add(E e) &#123; return m.put(e, Boolean.TRUE) == null; &#125; public Iterator&lt;E&gt; iterator() &#123; return s.iterator(); &#125; public Object[] toArray() &#123; return s.toArray(); &#125; public &lt;T&gt; T[] toArray(T[] a) &#123; return s.toArray(a); &#125; public String toString() &#123; return s.toString(); &#125; public int hashCode() &#123; return s.hashCode(); &#125; public boolean equals(Object o) &#123; return o == this || s.equals(o); &#125; public boolean containsAll(Collection&lt;?&gt; c) &#123;return s.containsAll(c);&#125; public boolean removeAll(Collection&lt;?&gt; c) &#123;return s.removeAll(c);&#125; public boolean retainAll(Collection&lt;?&gt; c) &#123;return s.retainAll(c);&#125; // addAll is the only inherited implementation ......&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读七：PriorityQueue]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-10%2F</url>
    <content type="text"><![CDATA[PriorityQueue总体介绍前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，类似于C++的仿函数）。 Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现。 上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系： leftNo = parentNo*2+1 rightNo = parentNo*2+2 parentNo = (nodeNo-1)/2 通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。 PriorityQueue的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是log(N)。 方法剖析add()和offer()add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。 新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。 123456789101112131415//offer(E e)public boolean offer(E e) &#123; if (e == null)//不允许放入null元素 throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1);//自动扩容 size = i + 1; if (i == 0)//队列原来为空，这是插入的第一个元素 queue[0] = e; else siftUp(i, e);//调整 return true;&#125; 上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。 123456789101112//siftUp()private void siftUp(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2 Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法 break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125; 新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。 element()和peek()element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。 代码也就非常简洁： 123456//peek()public E peek() &#123; if (size == 0) return null; return (E) queue[0];//0下标处的那个元素就是最小的那个&#125; remove()和poll()remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。 代码如下： 123456789101112public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0];//0下标处的那个元素就是最小的那个 E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x);//调整 return result;&#125; 上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）。重点是siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。 123456789101112131415161718//siftDown()private void siftDown(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标 int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1 Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c;//然后用c取代原来的值 k = child; &#125; queue[k] = x;&#125; remove(Object o)remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。 具体代码如下： 1234567891011121314151617//remove(Object o)public boolean remove(Object o) &#123; //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标 int i = indexOf(o); if (i == -1) return false; int s = --size; if (s == i) //情况1 queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved);//情况2 ...... &#125; return true;&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读六：LinkedHashSet and LinkedHashMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-9%2F</url>
    <content type="text"><![CDATA[LinkedHashSet and LinkedHashMap总体介绍如果你已看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文将要讲解的LinkedHashSet和LinkedHashMap其实也是一回事。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说LinkedHashSet里面有一个LinkedHashMap（适配器模式）。因此本文将重点分析LinkedHashMap。 LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将LinkedHashMap看作采用linked list增强的HashMap。 事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表（doubly-linked list）的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部（是一个哑元），该双向链表的迭代顺序就是entry的插入顺序。 除了可以保证迭代历顺序，这种结构还有一个好处：迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。 有两个参数可以影响LinkedHashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@OverridehashCode()和equals()方法。 通过如下方式可以得到一个跟源Map 迭代顺序一样的LinkedHashMap： 1234void foo(Map m) &#123; Map copy = new LinkedHashMap(m); ...&#125; 出于性能原因，LinkedHashMap是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成（wrapped）同步的： Map m = Collections.synchronizedMap(new LinkedHashMap(...)); 方法剖析get()get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行参考前文，这里不再赘述。 put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。 注意，这里的插入有两重含义： 从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。 从header的角度看，新的entry需要插入到双向链表的尾部。 addEntry()代码如下： 123456789101112131415// LinkedHashMap.addEntry()void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);// 自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);// hash%table.length &#125; // 1.在冲突链表头部插入新的entry HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; // 2.在双向链表的尾部插入新的entry e.addBefore(header); size++;&#125; 上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下： 1234567// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; 上述代码只是简单修改相关entry的引用而已。 remove()remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟get()方法类似。 注意，这里的删除也有两重含义： 从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。 从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。 removeEntryForKey()对应的代码如下： 12345678910111213141516171819202122232425// LinkedHashMap.removeEntryForKey()，删除key值对应的entryfinal Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);// hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;// 遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;// 找到要删除的entry modCount++; size--; // 1. 将e从对应bucket的冲突链表中删除 if (prev == e) table[i] = next; else prev.next = next; // 2. 将e从双向链表中删除 e.before.after = e.after; e.after.before = e.before; return e; &#125; prev = e; e = next; &#125; return e;&#125; LinkedHashSet前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。 1234567891011121314public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ...... // LinkedHashSet里面有一个LinkedHashMap public LinkedHashSet(int initialCapacity, float loadFactor) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125; LinkedHashMap经典用法LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法：可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下： 12345678910111213/** 一个固定大小的FIFO替换策略的缓存 */class FIFOCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt;&#123; private final int cacheSize; public FIFOCache(int cacheSize)&#123; this.cacheSize = cacheSize; &#125; // 当Entry个数超过cacheSize时，删除最老的Entry @Override protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return size() &gt; cacheSize; &#125;&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读五：HashSet and HashMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-8%2F</url>
    <content type="text"><![CDATA[HashSet and HashMap总体介绍之所以把HashSet和HashMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap（适配器模式）。因此本文将重点分析HashMap。 HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟Hashtable大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。Java HashMap采用的是冲突链表方式。 从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。 有两个参数可以影响HashMap的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到HashMap或HashSet中时，有两个方法需要特别关心：hashCode()和equals()。hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@OverridehashCode()和equals()方法。 方法剖析get()get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。 上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。 1234567891011121314//getEntry()方法final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表 e != null; e = e.next) &#123;//依次遍历冲突链表中的每个entry Object k; //依据equals()方法判断是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。 123456789101112//addEntry()void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);//hash%table.length &#125; //在冲突链表头部插入新的entry Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; remove()remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry（修改链表的相应引用）。查找过程跟getEntry()过程类似。 123456789101112131415161718192021//removeEntryForKey()final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; ...... int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);//hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];//得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;//遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;//找到要删除的entry modCount++; size--; if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry else prev.next = next; return e; &#125; prev = e; e = next; &#125; return e;&#125; HashSet前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。 12345678910111213141516//HashSet是对HashMap的简单包装public class HashSet&lt;E&gt;&#123; ...... private transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读四：TreeSet and TreeMap]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-7%2F</url>
    <content type="text"><![CDATA[总体介绍之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap（适配器模式）。因此本文将重点分析TreeMap。 Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。 TreeMap底层通过红黑树（Red-Black tree）实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。 出于性能原因，TreeMap是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成（wrapped）同步的： SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...)); 红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）： 每个节点要么是红色，要么是黑色。 根节点必须是黑色 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。 对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。 在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。 预备知识前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（RotateRight）。 左旋左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 TreeMap中左旋代码如下： 123456789101112131415161718//Rotate Leftprivate void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125; 右旋右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 TreeMap中右旋代码如下： 12345678910111213141516//Rotate Rightprivate void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 寻找节点后继对于一棵二叉查找树，给定节点t，其后继（树中比大于t的最小的那个元素）可以通过如下方式找到： t的右子树不空，则t的后继是其右子树中最小的那个元素。 t的右孩子为空，则t的后继是其第一个向左走的祖先。 后继节点在红黑树的删除操作中将会用到。 TreeMap中寻找节点后继的代码如下： 12345678910111213141516171819// 寻找节点后继函数successor()static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123;// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素 Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123;// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; 方法剖析get()get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。 具体代码如下： 123456789101112131415161718//getEntry()方法final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... if (key == null)//不允许key值为null throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0)//向左找 p = p.left; else if (cmp &gt; 0)//向右找 p = p.right; else return p; &#125; return null;&#125; put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改变某些节点的颜色）。 123456789101112131415161718192021public V put(K key, V value) &#123; ...... int cmp; Entry&lt;K,V&gt; parent; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left;//向左找 else if (cmp &gt; 0) t = t.right;//向右找 else return t.setValue(value); &#125; while (t != null); Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e);//调整 size++; return null;&#125; 上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的entry并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。 调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。 12345678910111213141516171819202122232425262728293031323334353637383940//红黑树调整函数fixAfterInsertion()private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况1 setColor(y, BLACK); // 情况1 setColor(parentOf(parentOf(x)), RED); // 情况1 x = parentOf(parentOf(x)); // 情况1 &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); // 情况2 rotateLeft(x); // 情况2 &#125; setColor(parentOf(x), BLACK); // 情况3 setColor(parentOf(parentOf(x)), RED); // 情况3 rotateRight(parentOf(parentOf(x))); // 情况3 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况4 setColor(y, BLACK); // 情况4 setColor(parentOf(parentOf(x)), RED); // 情况4 x = parentOf(parentOf(x)); // 情况4 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); // 情况5 rotateRight(x); // 情况5 &#125; setColor(parentOf(x), BLACK); // 情况6 setColor(parentOf(parentOf(x)), RED); // 情况6 rotateLeft(parentOf(parentOf(x))); // 情况6 &#125; &#125; &#125; root.color = BLACK;&#125; remove()remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。 getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。 由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况： 删除点p的左右子树都为空，或者只有一棵子树非空。 删除点p的左右子树都非空。 对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）。 基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下： 123456789101112131415161718192021222324252627282930313233343536// 红黑树entry删除函数deleteEntry()private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; if (p.left != null &amp;&amp; p.right != null) &#123;// 2. 删除点p的左右子树都非空。 Entry&lt;K,V&gt; s = successor(p);// 后继 p.key = s.key; p.value = s.value; p = s; &#125; Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123;// 1. 删除点p只有一棵子树非空。 replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; p.left = p.right = p.parent = null; if (p.color == BLACK) fixAfterDeletion(replacement);// 调整 &#125; else if (p.parent == null) &#123; root = null; &#125; else &#123; // 1. 删除点p的左右子树都为空 if (p.color == BLACK) fixAfterDeletion(p);// 调整 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。 跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。 上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。 删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况1 setColor(parentOf(x), RED); // 情况1 rotateLeft(parentOf(x)); // 情况1 sib = rightOf(parentOf(x)); // 情况1 &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况2 x = parentOf(x); // 情况2 &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); // 情况3 setColor(sib, RED); // 情况3 rotateRight(sib); // 情况3 sib = rightOf(parentOf(x)); // 情况3 &#125; setColor(sib, colorOf(parentOf(x))); // 情况4 setColor(parentOf(x), BLACK); // 情况4 setColor(rightOf(sib), BLACK); // 情况4 rotateLeft(parentOf(x)); // 情况4 x = root; // 情况4 &#125; &#125; else &#123; // 跟前四种情况对称 Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况5 setColor(parentOf(x), RED); // 情况5 rotateRight(parentOf(x)); // 情况5 sib = leftOf(parentOf(x)); // 情况5 &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况6 x = parentOf(x); // 情况6 &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); // 情况7 setColor(sib, RED); // 情况7 rotateLeft(sib); // 情况7 sib = leftOf(parentOf(x)); // 情况7 &#125; setColor(sib, colorOf(parentOf(x))); // 情况8 setColor(parentOf(x), BLACK); // 情况8 setColor(leftOf(sib), BLACK); // 情况8 rotateRight(parentOf(x)); // 情况8 x = root; // 情况8 &#125; &#125; &#125; setColor(x, BLACK);&#125; TreeSet前面已经说过TreeSet是对TreeMap的简单包装，对TreeSet的函数调用都会转换成合适的TreeMap方法，因此TreeSet的实现非常简单。这里不再赘述。 1234567891011121314151617// TreeSet是对TreeMap的简单包装public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; ...... private transient NavigableMap&lt;E,Object&gt; m; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public TreeSet() &#123; this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap &#125; ...... public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; ......&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读三：Stack and Queue]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-6%2F</url>
    <content type="text"><![CDATA[前言Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）。 总体介绍要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口： Queue Method Equivalent Deque Method 说明 add(e) addLast(e) 向队尾插入元素，失败则抛出异常 offer(e) offerLast(e) 向队尾插入元素，失败则返回false remove() removeFirst() 获取并删除队首元素，失败则抛出异常 poll() pollFirst() 获取并删除队首元素，失败则返回null element() getFirst() 获取但不删除队首元素，失败则抛出异常 peek() peekFirst() 获取但不删除队首元素，失败则返回null 下表列出了Deque与Stack对应的接口： Stack Method Equivalent Deque Method 说明 push(e) addFirst(e) 向栈顶插入元素，失败则抛出异常 无 offerFirst(e) 向栈顶插入元素，失败则返回false pop() removeFirst() 获取并删除栈顶元素，失败则抛出异常 无 pollFirst() 获取并删除栈顶元素，失败则返回null peek() peekFirst() 获取但不删除栈顶元素，失败则抛出异常 无 peekFirst() 获取但不删除栈顶元素，失败则返回null 上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（false或null）。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。 ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。 从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。 上图中我们看到，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。 方法剖析addFirst()addFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[--head] = e即可。 实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。 12345678//addFirst(E e)public void addFirst(E e) &#123; if (e == null)//不允许放入null throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界 if (head == tail)//1.空间是否够用 doubleCapacity();//扩容&#125; 上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。 下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数（其实只可能是-1），则相当于对其取相对于elements.length的补码。 下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示： 图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。 12345678910111213141516//doubleCapacity()private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // head右边元素的个数 int newCapacity = n &lt;&lt; 1;//原空间的2倍 if (newCapacity &lt; 0) throw new IllegalStateException("Sorry, deque too big"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分 System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分 elements = (E[])a; head = 0; tail = n;&#125; addLast()addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。 1234567public void addLast(E e) &#123; if (e == null)//不允许放入null throw new NullPointerException(); elements[tail] = e;//赋值 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理 doubleCapacity();//扩容&#125; 下标越界处理方式addFirt()中已经讲过，不再赘述。 pollFirst()pollFirst()的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当elements[head] == null时，意味着容器为空。 12345678public E pollFirst() &#123; E result = elements[head]; if (result == null)//null值意味着deque为空 return null; elements[h] = null;//let GC work head = (head + 1) &amp; (elements.length - 1);//下标越界处理 return result;&#125; pollLast()pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。 123456789public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素 E result = elements[t]; if (result == null)//null值意味着deque为空 return null; elements[t] = null;//let GC work tail = t; return result;&#125; peekFirst()peekFirst()的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回elements[head]即可。 123public E peekFirst() &#123; return elements[head]; // elements[head] is null if deque empty&#125; peekLast()peekLast()的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。 123public E peekLast() &#123; return elements[(tail - 1) &amp; (elements.length - 1)];&#125; 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读二：LinkedList]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-5%2F</url>
    <content type="text"><![CDATA[总体介绍LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类（它是个接口名字）。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList（当作栈或队列使用时）更好的性能。 LinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，而将Queue和Stack以及Deque相关的知识放在下一节讲。双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。 1234567891011//Node内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。 方法剖析add()add()方法有两个版本，一个是add(E e)，该方法在LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。 结合上图，可以看出add(E e)的逻辑非常简单。123456789101112//add(E e)public boolean add(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode;//原来链表为空，这是插入的第一个元素 else l.next = newNode; size++; return true;&#125; add(int index, E element)的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。 123456789101112131415161718//add(int index, E element)public void add(int index, E element) &#123; checkPositionIndex(index);//index &gt;= 0 &amp;&amp; index &lt;= size; if (index == size)//插入位置是末尾，包括列表为空的情况 add(element); else&#123; Node&lt;E&gt; succ = node(index);//1.先根据index找到要插入的位置 //2.修改引用，完成插入操作。 final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null)//插入位置为0 first = newNode; else pred.next = newNode; size++; &#125;&#125; 上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。 remove()remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。 两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。 在寻找被删元素引用的时候remove(Object o)调用的是元素的equals方法，而remove(int index)使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个revome()方法都是通过unlink(Node&lt;E&gt; x)方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。 123456789101112131415161718192021//unlink(Node&lt;E&gt; x)，删除一个NodeE unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123;//删除的是第一个元素 first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123;//删除的是最后一个元素 last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null;//let GC work size--; return element;&#125; get()get(int index)得到指定下标处元素的引用，通过调用上文中提到的node(int index)方法实现。1234public E get(int index) &#123; checkElementIndex(index);//index &gt;= 0 &amp;&amp; index &lt; size; return node(index).item;&#125; set()set(int index, E element)方法将指定下标处的元素修改成指定值，也是先通过node(int index)找到对应下表元素的引用，然后修改Node中item的值。1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element;//替换新值 return oldVal;&#125; 参考： LinkedList 简介LinkedList 是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当作链表来操作外，它还可以当作栈，队列和双端队列来使用。 LinkedList 同样是非线程安全的，只在单线程下适合使用。 LinkedList 实现了 Serializable 接口，因此它支持序列化，能够通过序列化传输，实现了 Cloneable 接口，能被克隆。 LinkedList 源码剖析源码如下（加入了比较详细的注释） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637package java.util; public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() &#123; header.next = header.previous = header; &#125; // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; // 获取LinkedList的第一个元素 public E getFirst() &#123; if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; &#125; // 获取LinkedList的最后一个元素 public E getLast() &#123; if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; &#125; // 删除LinkedList的第一个元素 public E removeFirst() &#123; return remove(header.next); &#125; // 删除LinkedList的最后一个元素 public E removeLast() &#123; return remove(header.previous); &#125; // 将元素添加到LinkedList的起始位置 public void addFirst(E e) &#123; addBefore(e, header.next); &#125; // 将元素添加到LinkedList的结束位置 public void addLast(E e) &#123; addBefore(e, header); &#125; // 判断LinkedList是否包含元素(o) public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; // 返回LinkedList的大小 public int size() &#123; return size; &#125; // 将元素(E)添加到LinkedList中 public boolean add(E e) &#123; // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; &#125; // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) &#123; if (o==null) &#123; // 若o为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // 若o不为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) &#123; Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; &#125; successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; &#125; // 清空双向链表 public void clear() &#123; Entry&lt;E&gt; e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) &#123; Entry&lt;E&gt; next = e.next; e.next = e.previous = null; e.element = null; e = next; &#125; header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; &#125; // 返回LinkedList指定位置的元素 public E get(int index) &#123; return entry(index).element; &#125; // 设置index位置对应的节点的值为element public E set(int index, E element) &#123; Entry&lt;E&gt; e = entry(index); E oldVal = e.element; e.element = element; return oldVal; &#125; // 在index前添加节点，且节点的值为element public void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index))); &#125; // 删除index位置的节点 public E remove(int index) &#123; return remove(entry(index)); &#125; // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e; &#125; // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) &#123; int index = 0; if (o==null) &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (e.element==null) return index; index++; &#125; &#125; else &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) return index; index++; &#125; &#125; return -1; &#125; // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) &#123; int index = size; if (o==null) &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (e.element==null) return index; &#125; &#125; else &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (o.equals(e.element)) return index; &#125; &#125; return -1; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() &#123; if (size==0) return null; return getFirst(); &#125; // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() &#123; return getFirst(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() &#123; if (size==0) return null; return removeFirst(); &#125; // 将e添加双向链表末尾 public boolean offer(E e) &#123; return add(e); &#125; // 将e添加双向链表开头 public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; // 将e添加双向链表末尾 public boolean offerLast(E e) &#123; addLast(e); return true; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() &#123; if (size==0) return null; return getFirst(); &#125; // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() &#123; if (size==0) return null; return getLast(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() &#123; if (size==0) return null; return removeFirst(); &#125; // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() &#123; if (size==0) return null; return removeLast(); &#125; // 将e插入到双向链表开头 public void push(E e) &#123; addFirst(e); &#125; // 删除并返回第一个节点 public E pop() &#123; return removeFirst(); &#125; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) &#123; if (o==null) &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; // List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) &#123; // index的有效性处理 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+ &quot;, Size: &quot;+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; &#125; else &#123; next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; &#125; &#125; // 是否存在下一个元素 public boolean hasNext() &#123; // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; &#125; // 获取下一个元素 public E next() &#123; checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; &#125; // 是否存在上一个元素 public boolean hasPrevious() &#123; // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; &#125; // 获取上一个元素 public E previous() &#123; if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; &#125; // 获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; // 获取上一个元素的索引 public int previousIndex() &#123; return nextIndex-1; &#125; // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() &#123; checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try &#123; LinkedList.this.remove(lastReturned); &#125; catch (NoSuchElementException e) &#123; throw new IllegalStateException(); &#125; if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; &#125; // 设置当前节点为e public void set(E e) &#123; if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; &#125; // 将e添加到当前节点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; &#125; // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) &#123; if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; &#125; // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; // 反向迭代器实现类。 private class DescendingIterator implements Iterator &#123; final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() &#123; return itr.hasPrevious(); &#125; // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() &#123; return itr.previous(); &#125; // 删除当前节点 public void remove() &#123; itr.remove(); &#125; &#125; // 返回LinkedList的Object[]数组 public Object[] toArray() &#123; // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; &#125; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; &#125; // 克隆函数。返回LinkedList的克隆对象。 public Object clone() &#123; LinkedList&lt;E&gt; clone = null; // 克隆一个LinkedList克隆对象 try &#123; clone = (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; &#125; // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); &#125; // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); &#125; &#125; 总结关于 LinkedList 的源码，给出几点比较重要的总结： 1、从源码中很明显可以看出，LinkedList 的实现是基于双向循环链表的，且头结点中不存放数据。 2、注意两个不同的构造方法。无参构造方法直接建立一个仅包含 head 节点的空链表，包含 Collection 的构造方法，先调用无参构造方法建立一个空链表，然后将 Collection 中的数据加入到链表的尾部后面。 3、在查找和删除某元素时，源码中都划分为该元素为 null 和不为 null 两种情况来处理，LinkedList 中允许元素为 null。 4、LinkedList 是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。 5、注意源码中的 Entry entry(int index) 方法。该方法返回双向链表中指定位置处的节点，而链表中是没有下标索引的，要指定位置出的元素，就要遍历该链表，从源码的实现中，我们看到这里有一个加速动作。源码中先将 index 与长度 size 的一半比较，如果 index &lt; size/2，就只从位置 0 往后遍历到位置 index 处，而如果 index &gt; size/2，就只从位置 size 往前遍历到位置 index 处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。 6、注意链表类对应的数据结构 Entry。如下 123456789101112131415161718192021222324// 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; 7、LinkedList 是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。 8、要注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读一：ArrayList]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-4%2F</url>
    <content type="text"><![CDATA[简介ArrayList 中是平常比较常用的一个集合类，经常帮助我们封装一些实体 Bean 的 List 集合。典型使用场景如下： 1234List&lt;Book&gt; bookList=new ArrayList&lt;Book&gt;();bookList.add(book1);bookList.add(book2);... ArrayList 位于java.util 属于 Java 集合框架的一部分。层次关系如下。 java.util类 ArrayListjava.lang.Object—- 继承者 java.util.AbstractCollection—– 继承者 java.util.AbstractList—–继承者 java.util.ArrayList 总体介绍ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。 size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。 方法剖析set()既然底层是一个数组, ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。123456public E set(int index, E element) &#123; rangeCheck(index);//下标越界检查 E oldValue = elementData(index); elementData[index] = element;//赋值到指定位置，复制的仅仅是引用 return oldValue;&#125; get()get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。1234public E get(int index) &#123; rangeCheck(index); return (E) elementData[index];//注意类型转换&#125; add()跟C++ 的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。123456789private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//原来的1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制&#125; 由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。 空间的问题解决后，插入过程就显得非常简单。 add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。 addAll()addAll()方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的addAll(Collection&lt;? extends E&gt; c)方法，一个是从指定位置开始插入的addAll(int index, Collection&lt;? extends E&gt; c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。 remove()remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。12345678910public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; //清除该位置的引用，让GC起作用 return oldValue;&#125; 关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。 源码分析以下是 ArrayList 部分源码（基于 sun JDK 1.7.） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506package java.util;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始化容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 用于空实例使用的一个共享的初始化为空的数组。 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 用于保存具体元素的数组。 */ private transient Object[] elementData; /** * ArrayList的大小(包含的元素数量) */ private int size; /** * 根据指定容量大小，构造一个空的ArrayList * */ public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; /** * 构造空的list,默认容量为10 */ public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; /** *构造一个包含指定 collection 的元素的列表， * 这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; /** * 将此 ArrayList 实例的容量调整为列表的当前大小。应用程序可以使用此操作来最小化 ArrayList 实例的存储量。 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; /** 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** *可以分配的Array最大容量。 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 扩容方法 */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 返回list中的元素个数 * * */ public int size() &#123; return size; &#125; /** * 返回当前列表是否为空。 * */ public boolean isEmpty() &#123; return size == 0; &#125; /** 如果此列表中包含指定的元素，则返回 true。更确切地讲，当且仅当此列表包含至少一个满 足 (o==null ? e==null : o.equals(e)) 的元素 e 时，则返回 true。 */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。更确切地讲，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最低索引 i ，如果不存在此类索引，则返回 -1。 */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。更确切地讲，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的最高索引 i，如果不存在此类索引，则返回 -1。 */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回ArrayList的浅拷贝。 * */ public Object clone() &#123; try &#123; @SuppressWarnings("unchecked") ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; /** * 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的 * 运行时类型是指定数组的运行时类型。 * */ @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // 位置访问函数 @SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 获取list指定位置出的元素。 */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 用指定的元素替代此列表中指定位置上的元素。 */ public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; /** * 将指定的元素添加到此列表的尾部。 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * 将指定的元素插入此列表中的指定位置。向右移动当前位于该位置的元素（如果有）以及所有后续元素（将其索引加 1）。 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** *移除此列表中指定位置上的元素。向左移动所有后续元素（将其索引减 1）。 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; /** *移除此列表中首次出现的指定元素（如果存在）。如果列表不包含此元素，则列表不做改动。更确切地讲，移除满足 (o==null ? get(i)==null : o.equals(get(i))) 的最低索引的元素（如果存在此类元素）。如果列表中包含指定的元素，则返回 true（或者等同于这种情况：如果列表由于调用而发生更改，则返回 true）。 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /** * * 私有remove方法跳过边界检查并且不返回被移除的value. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 清空当前list. */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素 * 添加到此列表的尾部。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。 */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 边界检查 */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 用于add 和addAll操作的边界检查方法。 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 构造IndexOutOfBoundsException异常信息封装。 */ private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size; &#125; /** *找到ArrayLis中 与Collection的交集部分并从当前List中移除 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false); &#125; /** * 保留ArrayList 与Collection的交集，并将剩余部分移除 */ public boolean retainAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, true); &#125; /** * removeAll(Collection&lt;?&gt; c) retainAll(Collection&lt;?&gt; c)两个方法的具体实现 */ private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; /** * 将ArrayList实例的保存至流中，序列化。 */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 反序列化，从流中还原ArrayList实例。 */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125;//省略其余部分...&#125; 为了便于理解，对源码进行了中文注释。ArrayList 直接继承于 AbstractList 类，这是一个抽象类，定义了一些基本操作。至少从源码中我们可以得到以下几点：1. ArrayList 内部使用数组来保存元素。2. ArrayList 实现了 RandomAccess, Cloneable, java.io.Serializable 三个标记接口，表示它自身支持快速随机访问，克隆，序列化。3. ArrayList 不具备并发访问特性，因为所有的方法没有加锁机制。4. 如果不指定容量大小，默认情况下，ArrayList 容量为 10, 在 JDk1.7 中 ArrayList 最大容量MAX_ARRAY_SIZE为 Integer.MAX_VALUE - 8.5. ArrayList 内部具备自动扩容机制，当容量不足时，会自动申请内存空间。 扩容实现方案ArrayList 具体的扩容最终会调用到grow方法。 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 具体扩容过程 首先得到数组的旧容量，然后进行oldCapacity + (oldCapacity &gt;&gt; 1)，将 oldCapacity 右移一位，其效果相当于 oldCapacity /2，我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的 1.5 倍，然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，接着，再检查新容量是否超出了 ArrayList 所定义的最大容量，若超出了，则调用 hugeCapacity() 来比较minCapacity和MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为 ArrayList 定义的最大容量，否则，新容量大小则为 minCapacity。 特别注意还有一点需要注意的是，扩容是创建一个新的数组，然后将旧数组上的数组 copy 到新数组，最终调用的是 System 类中的 native 方法。 12public static native void arraycopy(Object src, int srcPos,Object dest, int destPos,int length); 这是一个很大的消耗，所以在我们使用 ArrayList 时，最好能预计数据的大小，在第一次创建时就申请够内存。 参考：http://blog.csdn.net/ylyg050518/article/details/52149816https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antlr学习]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20%2F</url>
    <content type="text"><![CDATA[参考：《ANTLR 4权威指南》http://codemany.com/blog/archives/https://dohkoos.gitbooks.io/antlr4-short-course/content/getting-started.htmlhttp://blog.csdn.net/dc_726/article/details/45399371https://www.jianshu.com/p/1f5e72156075]]></content>
      <tags>
        <tag>antlr</tag>
        <tag>语法树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 笔记一]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-9%2F</url>
    <content type="text"><![CDATA[1.1 并发简史操作系统多进程出现的原因 资源利用率：一个程序等待某个外部操作的时候运行另一个程序 公平性：粗粒度的时间分片共享计算机资源 便利性：多个程序执行多个任务 促使进程出现的因素同样也促使着线程的出现 线程允许同一个进程中同时存在多条程序控制流。线程共享进程范围内的资源，例如内存句柄、文件句柄 每个线程有各自的程序计数器、栈以及局部变量 线程也称作轻量级进程 1.2 线程的优势1.2.1 发挥多处理的的强大能力操作系统调度单位是线程，如果一个程序只有一个线程，那么只能在一个处理器上运行 多线程程序可以再多个处理器上运行，如果设计正确，可以通过处理器资源利用率来提升系统的吞吐率 多线程有助于单处理器系统上获得更高的吞吐率 1.2.2 建模的简单性可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在单独的线程中运行，并在特定的同步位置进行交互 1.2.3 异步事件的简化处理1.2.4 响应更灵敏的用户界面1.3 线程带来的风险1.3.1 安全性问题永远不发生糟糕的事情 1.3.2 活跃性问题某件正确的事情最终会发生 1.3.3 性能问题1.4 线程无处不在Timer Servlet 和 JSP RMI Swing 和 AWT 参考：https://www.jianshu.com/p/bdbb55de64e4]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程实战 准备]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-8%2F</url>
    <content type="text"><![CDATA[并发项目推荐 基础并发工具：Google Guava（ https://github.com/google/guava ） 并发技术应用：Zookeeper（ http://zookeeper.apache.org/ ） 并发技术应用：Alibaba Dubbo（ http://dubbo.io/ ） 延伸应用：Akka（ http://akka.io/ ） 实战练习 对一个业务工程师，使用并发技术的场景较少，但仍然是有一些使用场景的，例如： 一些异步执行系统，需要使用线程池来管理多个异步任务。 在一些消息中间件的业务处理端，从接收到消息到分发处理，往往需要线程池来管理。 在一些基础架构岗位上，并发技术使用较多，主要有： 微服务架构的通讯层（包括 I/O、数据序列化处理等）、业务处理层都需要并发技术。 消息中间件的消息调度、消息分级处理等，需要并发技术。 学习重点 ConcurrentHashMap AtomicInteger/AtomicLong ReentranLock ExecuteService 参考:https://github.com/neoremind/coddding/blob/master/codding/src/main/java/net/neoremind/mycode/concurrent/JAVA_CONCURRENCY_IN_PRACTICE_NOTES.mdhttp://zhouchaofei2010.iteye.com/category/346380https://my.oschina.net/indestiny/blog?search=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7]]></content>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-7%2F</url>
    <content type="text"><![CDATA[以下内容来自《深入了解java虚拟机》的后几章 物理机如何处理并发问题？运算任务，除了需要处理器计算之外，还需要与内存交互，如读取运算数据、存储运算结果等（不能仅靠寄存器来解决）。计算机的存储设备和处理器的运算速度差了几个数量级，所以不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache），作为内存与处理器之间的缓冲：将运算需要的数据复制到缓存中，让运算快速运行。当运算结束后再从缓存同步回内存，这样处理器就无需等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓存，它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存时，可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时遵循缓存一致性协议。同时为了使得处理器充分被利用，处理器可能会对输出代码进行乱序执行优化。Java 虚拟机的即时编译器也有类似的指令重排序优化。 Java 内存模型什么是 Java 内存模型？Java 虚拟机的规范，用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各个平台下都能达到一致的并发效果。 Java 内存模型的目标？定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。此处的变量包括实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是线程私有的，不会被共享，所以不存在竞争问题。 主内存与工作内存所以的变量都存储在主内存，每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存。 内存间的交互操作一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存，Java 内存模型定义了 8 种操作： 原子性、可见性、有序性 原子性：对基本数据类型的访问和读写是具备原子性的。对于更大范围的原子性保证，可以使用字节码指令 monitorenter 和 monitorexit 来隐式使用 lock 和 unlock 操作。这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字。因此 synchronized 块之间的操作也具有原子性。 可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取之前从主内存刷新变量值来实现可见性的。volatile 的特殊规则保证了新值能够立即同步到主内存，每次使用前立即从主内存刷新。synchronized 和 final 也能实现可见性。final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么其他线程中就能看见 final 字段的值。 有序性：Java 程序的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）；如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序和工作内存与主内存同步延迟线性）。 volatile什么是 volatile？关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。当一个变量被定义成 volatile 之后，具备两种特性： 保证此变量对所有线程的可见性。当一条线程修改了这个变量的值，新值对于其他线程是可以立即得知的。而普通变量做不到这一点。 禁止指令重排序优化。普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。 为什么基于 volatile 变量的运算在并发下不一定是安全的？volatile 变量在各个线程的工作内存，不存在一致性问题（各个线程的工作内存中 volatile 变量，每次使用前都要刷新到主内存）。但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。 为什么使用 volatile？在某些情况下，volatile 同步机制的性能要优于锁（synchronized 关键字），但是由于虚拟机对锁实行的许多消除和优化，所以并不是很快。 volatile 变量读操作的性能消耗与普通变量几乎没有差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 并发与线程并发与线程的关系？并发不一定要依赖多线程，PHP 中有多进程并发。但是 Java 里面的并发是多线程的。 什么是线程？线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O），又可以独立调度（线程是 CPU 调度的最基本单位）。 实现线程有哪些方式？ 使用内核线程实现 使用用户线程实现 使用用户线程 + 轻量级进程混合实现 Java 线程的实现操作系统支持怎样的线程模型，在很大程度上就决定了 Java 虚拟机的线程是怎样映射的。 Java 线程调度什么是线程调度？线程调度是系统为线程分配处理器使用权的过程。 线程调度有哪些方法？ 协同式线程调度：实现简单，没有线程同步的问题。但是线程执行时间不可控，容易系统崩溃。 抢占式线程调度：每个线程由系统来分配执行时间，不会有线程导致整个进程阻塞的问题。 虽然 Java 线程调度是系统自动完成的，但是我们可以建议系统给某些线程多分配点时间——设置线程优先级。Java 语言有 10 个级别的线程优先级，优先级越高的线程，越容易被系统选择执行。 但是并不能完全依靠线程优先级。因为 Java 的线程是被映射到系统的原生线程上，所以线程调度最终还是由操作系统说了算。如 Windows 中只有 7 种优先级，所以 Java 不得不出现几个优先级相同的情况。同时优先级可能会被系统自行改变。Windows 系统中存在一个 “优先级推进器”，当系统发现一个线程执行特别勤奋，可能会越过线程优先级为它分配执行时间。 线程安全的定义？当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。 Java 语言操作的共享数据，包括哪些？ 不可变 绝对线程安全 相对线程安全 线程兼容 线程对立 不可变在 Java 语言里，不可变的对象一定是线程安全的，只要一个不可变的对象被正确构建出来，那其外部的可见状态永远也不会改变，永远也不会在多个线程中处于不一致的状态。 如何实现线程安全？虚拟机提供了同步和锁机制。 阻塞同步（互斥同步） 非阻塞同步 阻塞同步（互斥同步）互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。Java 中最基本的同步手段就是 synchronized 关键字，其编译后会在同步块的前后分别形成 monitorenter 和 monitorexit 两个字节码指令。这两个字节码都需要一个 Reference 类型的参数指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那么这个对象就是 Reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去获取对应的对象实例或 Class 对象作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。 如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器 + 1；当执行 monitorexit 指令时将锁计数器 - 1。当计数器为 0 时，锁就被释放了。 如果获取对象失败了，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。 除了 synchronized 之外，还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步。ReentrantLock 比 synchronized 增加了高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，对处理执行时间非常长的同步块很有用。 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的。 非阻塞同步互斥同步最大的问题，就是进行线程阻塞和唤醒所带来的性能问题，是一种悲观的并发策略。总是认为只要不去做正确的同步措施（加锁），那就肯定会出问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。 锁优化是在 JDK 的那个版本？JDK1.6 的一个重要主题，就是高效并发。HotSpot 虚拟机开发团队在这个版本上，实现了各种锁优化： 适应性自旋 锁消除 锁粗化 轻量级锁 偏向锁 为什么要提出自旋锁？互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来很大压力。同时很多应用共享数据的锁定状态，只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。先不挂起线程，等一会儿。 自旋锁的原理？如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，让后面请求锁的线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放。为了让线程等待，我们只需让线程执行一个忙循环（自旋）。 自旋的缺点？自旋等待本身虽然避免了线程切换的开销，但它要占用处理器时间。所以如果锁被占用的时间很短，自旋等待的效果就非常好；如果时间很长，那么自旋的线程只会白白消耗处理器的资源。所以自旋等待的时间要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，那就应该使用传统的方式挂起线程了。 什么是自适应自旋？自旋的时间不固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果一个锁对象，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行，那么虚拟机认为这次自旋仍然可能成功，进而运行自旋等待更长的时间。 如果对于某个锁，自旋很少成功，那在以后要获取这个锁，可能省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机也会越来越聪明。 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。 程序员怎么会在明知道不存在数据竞争的情况下使用同步呢？很多不是程序员自己加入的。 锁粗化原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。 锁粗化就是增大锁的作用域。 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 偏向锁消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。即在无竞争的情况下，把整个同步都消除掉。这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。 以下内容来自《java核心技术 卷一 第14章》 第十四章：并发Thread：static Thread currentThread() 获取当前线程static void sleep(long millis) 休眠指定的毫秒数 (当前线程)static void yield() 导致当前线程处于让步状态 (当前线程)static boolean interrupted() 检测线程中断状态并置位为 false(当前线程)boolean isInterrupted() 只检测线程中断状态void interrupt() 向线程发送请求，请求中断线程void join() 等待终止指定的线程 (其他线程调用)Thread.State getState() 得到线程状态 (6 种)void setPriority(int newPriority) 设置线程优先级 MIN_PRIORITY=1/NORM_PRIORITY=5/MAX_PRIORITY=10void setDaemon(boolean isDaemon) 设置线程为守护线程，必须在线程启动之前调用 Object：void wait() 导致线程进入等待状态直到它被通知void nitify() 随机选择一个在该对象上调用 wait 方法的线程，解除其阻塞状态vodi notifyAll() 解除那些在该对象上调用 wait 方法的线程的阻塞状态 多线程： 几个概念：• 多任务系统：操作系统将 CPU 时间片分配给每一个进程，给人以并行处理的感觉。但是并发进程数并不是由 CPU 数目制约的。• 多线程程序：一个程序 (进程) 可以同时执行多个任务，同时运行一个以上的线程。• 进程与线程：每个进程拥有自己的一套变量，而每个线程共享数据。一个进程相当于一个应用程序，一个进程中可以包含多个线程，其中有一个主线程，其余都是工作线程，线程更轻量级。 不要直接调用 Thread 或 Runnable 的run()方法，它只会执行一个线程中的任务 (当前线程)，而不会启动一个新线程，要使用thread.start()来开启 (Runnable 就是包装业务逻辑的类，在指定的时间和线程中执行某段代码)。 没有什么强制终止线程的方法，interrupt()用来请求终止线程；如果线程被阻塞 (调用 sleep 或 wait 方法)，interrupt()将抛出异常；如果在中断状态被置位时调用sleep()不会引起休眠且会清除中断状态并抛异常，因此中断置位后就别进行其他操作了；中断请求只是先标记一个状态，被中断的线程可以决定如何响应中断。 静态方法interrupted()检测当前线程是否中断且清除中断状态；实例方法isInterrupt()检测是否被中断且不改变中断状态；实例方法interrupt()请求中断。 线程的 6 种状态：New(新创建)、Runnable(可运行)、Blocked(被阻塞)、Waiting(等待)、Timed waiting(计时等待)、Terminated(被终止)。 调用start()后线程进入可执行状态，不一定是立即执行，取决于操作系统给线程提供运行的时间。这里安卓的Handler.post()是等本方法体执行完，才有可能执行 runnable 里的逻辑，而线程的start()方法后 runnable 里的执行逻辑和本方法体里的下一行不一定谁先执行呢。 两种操作系统调度方式：• 抢占式调度：系统给每一个可运行线程分配时间片来执行任务，当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。• 协作式调度：一个线程只有在调用 yield 方法、被阻塞或等待时，线程才会失去控制权。 几种状态的区别：• 阻塞状态：一个线程试图获取一个对象的内部对象锁，而该锁被其他线程所持有，则该线程进入阻塞状态，当其他线程释放该锁，且线程调度器允许本线程持有它的时候，该线程变为非阻塞状态 (正常竞争对象锁)，相当于自动解锁。• 等待状态：可理解为阻塞的一种，当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。如调用 Object.wait()、thread.join()、Lock 或 Condition 时出现 (手动阻塞，必须被其他线程主动唤醒，可能出现死锁)。• 计时等待：等待状态一直保持到超时期满或者接收到适当的通知。如调用 Thread.sleep()、Object.wait()、thread.join()、Lock.tryLock() 或 Condition.await() 时出现。 每个线程有一个优先级，默认继承父线程优先级，范围为 MIN_PRIORITY(1)~MAX_PRIORITY(10) 之间，NORM_PRIORITY 为 5。当线程调度器有机会选择新线程时，它会优先选择优先级较高的线程，但是这个过程是高度依赖于操作系统的。 守护线程：调用thread.setDaemon(true)将线程转换为守护线程，唯一用途是为其他线程服务，当只剩下守护线程时，虚拟机就退出了。守护线程应该永远不去访问固有资源、文件等，因为它会在任何时候发生中断。 线程的run()方法不能抛出任何受查异常，但是，非受查异常会导致线程终止。这时候可以用setUncaughtExceptionHandler(实例方法) 来为任何一个线程安装一个处理器。也可以用Thread.setDefaultUncaughtExceptionHandler(静态方法) 来为所有线程安装一个默认的处理器。默认处理器默认为 null，实例处理器默认为线程的 ThreadGroup 对象。ThreadGruop 内部其实还是优先使用父处理器 -&gt; 默认处理器等来处理的，如果都没就 System.err 输出日志并崩溃退出。 同步： 同步的作用就是要保证一组操作的原子性。如线程安全队列保证了对该队列操作的线程安全 (队列的内部锁)，但是外部调用时如果有判断逻辑，就要保证判断逻辑上下的原子性 (外部调用者的对象锁)，最好每次使用都判下空，其实也没有绝对的线程安全。 锁对象 Lock： Java 提供了synchronized关键字和 Java SE5 中引入的ReentrantLock类来解决线程同步问题，将某一段代码控制为原子性操作。 一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句，但其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。把解锁操作放在finally语句中很重要，如果代码抛出异常，锁必须被释放 (注意异常退出的话要回滚避免对象损坏)。如果使用锁，就不能使用带资源的 try 语句。 注意例子中每个对象有自己的ReentrantLock锁对象，如果两个线程试图访问同一个对象，那么锁以串行的方式提供服务。访问不同的对象，则不会发生阻塞。 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数器来跟踪 lock 方法的嵌套调用。线程在每一次调用lock()后都要调用unlock()来释放锁。被一个锁保护的代码可以调用另一个使用相同的锁的方法。注意异常时要先回滚，否则对象可能处于一种受损状态。 条件对象 Condition： 数据结构本身是安全的话 (如例子中的 Bank 类的 transfer 方法)，在外部调用如果有判断逻辑还是可能会不安全 (如上面所讲锁对象已经不是一个层级的了)，这时要么在外部使用加锁控制判断逻辑，要么在内部 transfer 方法添加条件锁判断逻辑。 条件对象：一个锁可以有一个或多个相关的条件对象。等待获得锁的线程和调用了 await 方法的线程本质上不同。一旦一个线程调用await()，它进入该条件的等待集，当锁可用时，该线程不是马上解除阻塞，而是等待直到另一线程调用同一条件上的signalAll()方法为止 (阻塞是得到锁自己就唤醒，等待是必须由其他线程来唤醒 (相互 await 死锁现象，死锁发生的原因是有超出条件限制的操作导致可能同时双方都不满足条件而相互等待))。 signalAll()不会立即激活一个等待线程，它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对象的访问。signal()注意是 “随机” 解除一个线程的阻塞。仅可在该条件上调用await()、singal()或singalAll()。被激活的线程从之前await()的方法出继续执行。 Synchronized 关键字： Java 中的每一个对象都有一个内部锁，如果方法用synchronized声明，那么对象锁将保护整个方法。内部对象锁只有一个相关条件，wait()方法添加一个线程到等待集中，notify()/nitifyAll()方法解除等待线程的阻塞状态。这三个方法必须在synchronized代码块中，也就是必须先拿到锁才能等待 (condition 也是先 lock() 后才能 await()等)。缺陷：不能中断一个正在获得锁的线程、锁不能设置超时、条件是单一的。 实例方法上加synchronized关键字锁的是该实例的这个和所有同步实例方法，通过获取该对象的内部锁来实现；静态方法上加synchronized关键字锁的是同一个类的这个或任何其它的同步静态方法，通过获取该类对象的内部锁实现。 实现同步的两种方式：①在方法上添加synchronized关键字来实现同步 (使用自己的内部对象锁)。②通过synchronized(obj)进入一个同步阻塞。(使用一个其他 Obj 的对象锁，道理其实是一样的，都是拿到对象的内部锁来 lock) 注意条件对象有await()、singal()、singalAll()方法；对象是wait()、notify()、notifyAll()方法。对象的几个方法内也是获取内部锁对象进行同步的，要放到synchronized代码块中，先lock()获取锁才能wait()等操作。 volatile 关键字：• 为实例域的同步访问提供一种免锁机制，更轻量级，如果声明一个域为volatile，那么编译器和虚拟机就知道该域可能被另一个线程并发更新。• 作用：禁止指令重排序 (操作系统可以对指令集重排序的(分配内存 -&gt; 初始化对象 -&gt;赋值空间地址给引用)；实现可见性(针对变量)；保证有序性(long、double 等类型)。• 注意：volatile 保证可见性、有序性，不保证原子性，因为有序、可见是针对域的锁定，原子性是一系列操作，已经不是同一级别的锁了，可以在原子操作外部加锁，也可使用 CAS(轻量级的判断 / 再赋值锁)。 线程安全方法 有时候要避免共享变量，使用 ThreadLocal 辅助类可以为各个线程构造单独的实例。ThreadLocal 提供了set()和get()访问器用来访问与当前线程相关联的线程局部变量；ThreadLocal 中有个内部类 ThreadLocalMap，key 为 ThreadLocal，value 为变量 T；每个线程有个变量threadLocals(即 ThreadLocalMap)，在调用set()方法时会取到线程当前这个 map 是否为空，空的话就createMap()，否则就将 key 设为 ThreadLocal，value 设为原共享变量 T 的副本存进去，因此每个线程可以放多个 ThreadLocal 包装过的变量，这些变量线程间独享。 lock()方法获取锁会阻塞；tryLock()方法试图申请一个锁，在成功获得锁后返回 true，否则立即返回 false。lock()方法不能被中断，如果出现死锁lock()就无法终止；带超时的tryLock()方法被中断会抛异常，允许程序打破死锁。 读写锁ReentrantReadWriteLock的readLock()得到一个允许多线程读，排斥写的锁，或者writeLock()得到一个排斥其他读写操作的锁。 线程的stop()方法会立即终止所有未结束的方法，包括run()方法，因此有可能导致对象状态损坏，因此被弃用了。应当在合适的时候中断线程，线程会在安全的时候停止。 阻塞队列 对多线程问题，可以用一个或多个队列以安全的方式将其形式化，生产者向线程队列中插入元素，消费者从中取出它们；可以将例子中的转账指令插入某一队列，而另一个线程从队列中取指令执行，不直接操作 bank 对象，队列自己控制好线程安全即可，对 bank 对象进行操作 (单线程执行，类似 Handler，避免显示控制同步)。 当队列为空或者已满时，阻塞队列将导致操作的线程阻塞：add()/remove()/element()方法会抛异常、offer()/poll()/peek()方法不阻塞也不会抛异常、take()/put()方法会导致阻塞。 阻塞队列的几种类型：• ArrayBlockingQueue(带有指定容量的循环数组阻塞队列)• LinkedBlockingQueue(无上限链表阻塞队列)• PriorityBlockingQueue(无边界的优先堆阻塞队列)• DelayQueue(无边界的阻塞时间有限的阻塞队列) 几种线程安全的集合：• ConcurrenHashMap• ConcurrentSkipListMap• ConcurrentSkipListSet• ConcurrentLinkedQueue集合返回弱一致性的迭代器，不一定能反映出他们被构造之后的所有修改。 并发集视图：ConcurrentHashMap.&lt;T&gt;newKeySet()。写数组拷贝：CopyOnWriteArrayList、CopyOnWriteArraySet，并发读，写的时候生成一个副本，占用双倍内存。 任何集合类都可以使用同步包装器变为线程安全的：Collections.synchronizedList(new ArrayList&lt;E&gt;())、Collections.synchronizedMap(new HashMap&lt;K,V&gt;())。 线程池 Runnable 封装一个无返回值的异步任务，可用在线程或线程池中；Callable 封装一个有返回值的异步任务，只能放在线程池中。 Future 保存并管理异步计算的结果；FutureTask 实现了 Ruannable 和 Future 两个接口，可把自己提交给线程池，完了从自己拿处理结果。 如果程序中创建了大量生命周期很短的线程，或为了减少并发线程的数目，就应该使用线程池。 四种常用线程池：• CachedThreadPool(核心 = 0，最大 = MAX，0 长度阻塞队列，空线程保持 60s，适用于较多异步任务)• FixedThreadPool(核心 = 最大 = 固定数，MAX 长度阻塞队列，适用快速执行任务)• SingleThreadPool(核心 = 固定 = 1，顺序执行任务)• ScheduledThreadPool(延迟执行或延迟后周期执行的线程池)。 submit()方法提交任务，得到一个 Future 对象用于管理结果；shutdown()方法启动线程池关闭序列，被关闭的线程池不再接受新任务，所有任务执行完后线程池死亡；shotdownNow()方法取消尚未开始的所有任务并试图中断正在执行的线程。 同步器 几种常用同步器：• 信号量 Semaphore：一个信号量管理许多的许可证，为了通过信号量，线程通过调用acquire()方法请求许可，否则等待，信号量其实仅维护一个计数，因此用于控制同一时刻的线程数量。任何线程都可以通过release()释放任意数目的许可。• 倒计时门栓 CountDownLatch：让一个线程集等待直到计数器变为 0，用于暂停某个线程等待其他线程执行完必备操作后继续执行。它是一次性的，一旦计数器变为 0，就不能再重用了。• 循环栅栏 CyclicBarrier：允许线程集到达一个公共栅栏 (等待到指定数目) 后执行某段逻辑，然后各自再继续执行(先到达的先 await)。如果任何一个在栅栏上等待的线程离开了栅栏，栅栏就被破坏了，如等待线程的 await 方法超时或者被中断了，这时其他线程的 await 方法会抛异常，那些已经等待的线程会立即终止 await 的调用。 同步队列：将生产者和消费者线程配对的机制。当一个线程调用 SynchronousQueue 的put()方法时，它会阻塞直到另一个线程调用take()方法为止，反之亦然。数据仅沿一个方向传递，从生产者到消费者。它不是一个队列，没有包含任何元素，size()方法总是返回 0。重点：都很重要 补充知识点 Java 内存分配：①运行时数据区域：方法区、堆区、栈区 (虚拟机栈、本地方法栈)、程序计数器。前两者是线程共享区、后面的是线程隔离区。②各部分作用：• 程序计数器：当前线程所执行的字节码的行号指示器，这个计数器记录的是在正在执行的虚拟机字节码指令的地址，当执行的是 Native 方法，这个计数器值为空。此内存区域是唯一一个没有规定任何 OutOfMemoryError 情况的区域 。• Java 虚拟机栈：线程私有的 ，它的生命周期与线程相同。存储方法执行时的局部变量表、操作数栈、方法出口等，含有基本数据类型、引用类型的空间地址。如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。• 本地方法栈：与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的 Java 方法服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。• Java 堆：所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例 ，是垃圾收集器管理的主要区域，由 GC 管理内存的回收，有一套自己的回收机制。如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出 OutOfMemoryError 异常。• 方法区：又称静态存储区，各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 ，运行时常量也是其中一部分。垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需要时，将抛出 OutOfMemoryError 异常。③对象的创建过程：创建一个对象通常是需要 new 关键字，当虚拟机遇到一条 new 指令时，首先检查这个指令的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有那么执行相应的类加载过程。类加载检查通过后，虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。Java 程序通过栈上的 reference 数据来操作堆上的具体对象。主要的访问方式有使用句柄和直接指针两种：句柄就是引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 ；直接指针指引用中存储的就是对象地址 。 ClassLoader• ClassLoader 的具体作用就是将 class 文件加载到 jvm 虚拟机中去，程序就可以正确运行了。但是，jvm 启动的时候，并不会一次性加载所有的 class 文件，而是根据需要去动态加载。• class 文件是字节码格式文件，java 虚拟机并不能直接识别我们平常编写的. java 源文件，所以需要 javac 这个命令转换成. class 文件。其他语言编写的代码只要能编译成. class 文件都可以被 java 虚拟机运行。• 三种 ClassLoader：①BootstrapClassLoader：最顶层的加载类，主要加载核心类库，%JRE_HOME%\lib 下的 rt.jar、resources.jar、charsets.jar 和 class 等。②ExtClassLoader：扩展的类加载器，加载目录 %JRE_HOME%\lib\ext 目录下的 jar 包和 class 文件。③AppClassLoader：也称为 SystemAppClass 加载当前应用的 classpath 的所有类。• 加载顺序：BootstrapClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader。• ExtClassLoader 和 AppClassLoader 都是 UrlClassLoader 的子类。每个类加载器都有一个父加载器，AppClassLoader 的父加载器是 ExtClassLoader，ExtClassLoader 的父加载器是 null。一个 ClassLoader 创建时可以直接指定 parent，如果没有指定 parent，那么它的 parent 默认就是Launcher.getClassLoader()，即 AppClassLoader。• Bootstrap ClassLoader 是由 C/C++ 编写的，它本身是虚拟机的一部分，所以它并不是一个 JAVA 类，也就是无法在 java 代码中获取它的引用。• 双亲委托机制：一个类加载器查找 class 和 resource 时，是通过 “委托模式” 进行的，它首先判断这个 class 是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到 Bootstrap ClassLoader，如果 Bootstrap Classloader 找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象，再找不到就抛异常了。虽然 ExtClassLoader 的 parent 为 null，但是在找类时如果 parent 为 null 就调用findBootstrapClassOrNull(name)Bootstrap ClassLoader 去找。• 自定义 ClassLoader 可以根据自定义路径去加载 class 文件，从而将外部类加载进来并使用。一般复写findClass()方法和在findClass()方法中调用defineClass()方法。可以根据自己的规定来进行类加密解密操作，并自定义类加载器来解析类。]]></content>
      <tags>
        <tag>并发</tag>
        <tag>待阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读：集合框架概述]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-18-3%2F</url>
    <content type="text"><![CDATA[学习:《算法 第四版》 关于 Java 集合框架，我们首先应该把握住几个核心的接口，请看下图： 我们还要了解到这些接口描述了一组什么样的机制，然后以此作为出发点，去了解具体哪些类实现了哪些机制。像这样自顶向下的学习，我们很快就能掌握常见集合类的用法。对于一些我们平常经常使用的类，我们还可以阅读一下它的源码，了解它的实现细节，这样我们以后使用起来会更加得心应手。不过阅读一些集合类（比如 TreeMap、HashMap）的源码需要我们具备一定的数据结构与算法的基础知识，这方面推荐阅读 算法（第 4 版） (豆瓣)。 集合框架介绍 Java 集合工具包位于 Java.util 包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习 Java 集合框架下大致可以分为如下五个部分：List 列表、Set 集合、Map 映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。 Java 集合类的整体框架如下： 从上图中可以看出，集合类主要分为两大类：Collection 和 Map。 Collection 是 List、Set 等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List 和 Set。 List 接口 List 接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为 ArrayList 和 LinkedList，另外还有不常用的 Vector。另外，LinkedList 还是实现了 Queue 接口，因此也可以作为队列使用。 Set 接口 Set 接口通常表示一个集合，其中的元素不允许重复（通过 hashcode 和 equals 函数保证），常用实现类有 HashSet 和 TreeSet，HashSet 是通过 Map 中的 HashMap 实现的，而 TreeSet 是通过 Map 中的 TreeMap 实现的。另外，TreeSet 还实现了 SortedSet 接口，因此是有序的集合（集合中的元素要实现 Comparable 接口，并覆写 Compartor 函数才行）。 我们看到，抽象类 AbstractCollection、AbstractList 和 AbstractSet 分别实现了 Collection、List 和 Set 接口，这就是在 Java 集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。 Map 接口 Map 是一个映射接口，其中的每个元素都是一个 key-value 键值对，同样抽象类 AbstractMap 通过适配器模式实现了 Map 接口中的大部分函数，TreeMap、HashMap、WeakHashMap 等实现类都通过继承 AbstractMap 来实现，另外，不常用的 HashTable 直接实现了 Map 接口，它和 Vector 都是 JDK1.0 就引入的集合类。 Iterator 迭代器 Iterator 是遍历集合的迭代器（不能遍历 Map，只用来遍历 Collection），Collection 的实现类都实现了 iterator() 函数，它返回一个 Iterator 对象，用来遍历集合，ListIterator 则专门用来遍历 List。而 Enumeration 则是 JDK1.0 时引入的，作用与 Iterator 相同，但它的功能比 Iterator 要少，它只能在 Hashtable、Vector 和 Stack 中使用。 工具类 Arrays 和 Collections 是用来操作数组、集合的两个工具类，例如在 ArrayList 和 Vector 中大量调用了 Arrays.Copyof() 方法，而 Collections 中有很多静态方法可以返回各集合类的 synchronized 版本，即线程安全的版本，当然了，如果要用线程安全的集合类，首选 Concurrent 并发包下的对应的集合类。 参考专栏：http://blog.csdn.net/column/details/12706.htmlhttps://crowhawk.github.io/tags/#Java%E5%9F%BA%E7%A1%80https://www.jianshu.com/p/b9d8814c3654]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 的类之间的关系及UML表示：继承、依赖、关联、实现、聚合、组合]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-20-2%2F</url>
    <content type="text"><![CDATA[UML基础类： 矩形框代表一个类 (如图 - 1), 类图分为三层，第一层为类的名称，如果是抽象类类名用斜体字表示，如图中动物类所示。第二层是类的特性(通常就是类的字段和属性)。第三层为类的操作（通常就是方法或行为）。注意前面的符号，“+” 表示 public，“-”表示 private,“#”表示 protected. （图 - 1） 动物类是一抽象类，它是不能被实例化的，而猪类可以被实例化。 接口： 接口有两种表示方法：矩形表示法（如图 - 2 中的飞翔的接口）和棒棒糖表示法 (如图 - 2 中唐老鸭类中实现讲人话的接口)。矩形表示法，顶端有&lt;&lt;接口&gt;&gt; 或者&lt;&gt;，第一行：接口名称，第二行：接口方法。棒棒糖表示法，圆圈旁为接口名称，接口方法在实现类中出现，如唐老鸭类中的讲话。 （图 - 2） 泛化（继承）：• 泛化关系 (Generalization) 也就是继承关系，也称为 “is-a-kind-of” 关系，泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在 UML 中，泛化关系用带空心三角形的直线来表示。• 在代码实现时，使用面向对象的继承机制来实现泛化关系，如在 Java 语言中使用 extends 关键字、在 C++/C# 中使用冒号 “：” 来实现。泛化对应 Java 中继承关系，即子类继承父类中出 private 修饰外的所有东西（变量、方法等）。示例代码： 1234public class Animal &#123;&#125;public class Tiger extends Animal &#123;&#125; 在 UML 当中，对泛化关系有三个要求：1、子类与父类应该完全一致，父类所具有的属性、操作，子类应该都有； 2、子类中除了与父类一致的信息以外，还包括额外的信息； 3、可以使用父类的实例的地方，也可以使用子类的实例； 依赖：• 依赖关系 (Dependency) 是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。• 在 UML 中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 123456public class Screwdriver &#123; //螺丝刀，作为人类的工具，是用来被人类使用的&#125;public class Person&#123; public void screw(Screwdriver src)&#123; //拧螺丝，需使用螺丝刀&#125;&#125; 依赖关系有如下三种情况：1、A 类是 B 类中的（某中方法的）局部变量； 2、A 类是 B 类方法当中的一个参数； 3、A 类向 B 类发送消息，从而影响 B 类发生变化； 关联（Association）：是一种结构关系，说明一个事物的对象与另一个事物的对象相联系。给定有关联的两个类，可以从一个类的对象得到另一个类的对象。关联有两元关系和多元关系。两元关系是指一种一对一的关系，多元关系是一对多或多对一的关系。两个类之间的简单关联表示了两个同等地位类之间的结构关系。当你想要表示结构化关系时使用关联。• 关联关系 (Association) 是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。• 在 UML 类图中，用实线连接有关联的对象所对应的类，在使用 Java、C# 和 C++ 等编程语言实现关联关系时，通常将一个类的对象作为另一个类的属性。• 在使用类图表示关联关系时可以在关联线上标注角色名。 分为几种情况：双向关联12345678910public class Customer &#123; private Product[] products; …… &#125; public class Product &#123; private Customer customer; …… &#125; 单向关联12345678910public class Customer &#123; private Address address; …… &#125; public class Address &#123; …… &#125; 自关联12345public class Node &#123; private Node subNode; …… &#125; 聚合关系（Aggregation）• 聚合关系 (Aggregation) 表示一个整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。• 在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在 UML 中，聚合关系用带空心菱形的直线表示。 12345public class Student&#123;&#125;public class School&#123; private List&lt;Student&gt; students ; //学校与学生是聚合关系&#125; 例子： 组合关系（Composition）组合关系 (Composition) 也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之 间具有同生共死的关系。• 在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。在 UML 中，组合关系用带实心菱形的直线表示。 12345public class Menu&#123;&#125;public class Window&#123; private List&lt;Menu&gt; menus ;&#125; 菜单的存在前提是窗口的存在，两者之间存在很强的拥有关系。且窗口对菜单的生命周期负责，只有在窗口创建之后，菜单才能够创建，菜单必须在窗口销毁之前销毁。因此 Window 与 Menu 之间是组合关系。 实现关系（Implementation)• 接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系 (Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所 声明的操作。在 UML 中，类与接口之间的实现关系用带空心三角形的虚线来表示。 123456789101112131415161718public interface Vehicle &#123; public void move(); &#125; public class Ship implements Vehicle &#123; public void move() &#123; …… &#125; &#125; public class Car implements Vehicle &#123; public void move() &#123; …… &#125; &#125; 总结：关于关联，聚合，组合在实现上并没有显著区别，相区别他们只有通过判断关系双方之间的实际关系，如关系强弱、创建与销毁之间有无必要关联等。它们的强弱关系是没有异议的：依赖 &lt; 关联 &lt; 聚合 &lt; 组合 &lt; 泛化（继承） 实现方式区别：1) 依赖关系：关系对象出现在局部变量或者方法的参数里，或者关系类的静态方法被调用(2) 关联关系：关系对象出现在实例变量中(3) 聚合关系: 关系对象出现在实例变量中(4) 组合关系：关系对象出现在实例变量中(5) 泛化（继承）: extends(6) 实现： implements 参考：http://blog.csdn.net/lpjishu/article/details/51491779]]></content>
      <tags>
        <tag>Java</tag>
        <tag>类关系</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架源码解读零：集合框架概述]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-20-1%2F</url>
    <content type="text"><![CDATA[集合框架介绍 Java 集合工具包位于 Java.util 包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习 Java 集合框架下大致可以分为如下五个部分：List 列表、Set 集合、Map 映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。 Java 集合类的整体框架如下： 从上图中可以看出，集合类主要分为两大类：Collection 和 Map。 Collection 是 List、Set 等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List 和 Set。 List 接口 List 接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为 ArrayList 和 LinkedList，另外还有不常用的 Vector。另外，LinkedList 还是实现了 Queue 接口，因此也可以作为队列使用。 Set 接口 Set 接口通常表示一个集合，其中的元素不允许重复（通过 hashcode 和 equals 函数保证），常用实现类有 HashSet 和 TreeSet，HashSet 是通过 Map 中的 HashMap 实现的，而 TreeSet 是通过 Map 中的 TreeMap 实现的。另外，TreeSet 还实现了 SortedSet 接口，因此是有序的集合（集合中的元素要实现 Comparable 接口，并覆写 Compartor 函数才行）。 我们看到，抽象类 AbstractCollection、AbstractList 和 AbstractSet 分别实现了 Collection、List 和 Set 接口，这就是在 Java 集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。 Map 接口 Map 是一个映射接口，其中的每个元素都是一个 key-value 键值对，同样抽象类 AbstractMap 通过适配器模式实现了 Map 接口中的大部分函数，TreeMap、HashMap、WeakHashMap 等实现类都通过继承 AbstractMap 来实现，另外，不常用的 HashTable 直接实现了 Map 接口，它和 Vector 都是 JDK1.0 就引入的集合类。 Iterator 迭代器 Iterator 是遍历集合的迭代器（不能遍历 Map，只用来遍历 Collection），Collection 的实现类都实现了 iterator() 函数，它返回一个 Iterator 对象，用来遍历集合，ListIterator 则专门用来遍历 List。而 Enumeration 则是 JDK1.0 时引入的，作用与 Iterator 相同，但它的功能比 Iterator 要少，它只能再 Hashtable、Vector 和 Stack 中使用。 工具类 Arrays 和 Collections 是用来操作数组、集合的两个工具类，例如在 ArrayList 和 Vector 中大量调用了 Arrays.Copyof() 方法，而 Collections 中有很多静态方法可以返回各集合类的 synchronized 版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选 Concurrent 并发包下的对应的集合类。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客加密文章测试]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-6%2F</url>
    <content type="text"><![CDATA[「密码不能告诉你」 Decrypt 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]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog无法输入双括号的解决方法]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-4%2F</url>
    <content type="text"><![CDATA[1&#123;% raw %&#125;&#123;&#123;message&#125;&#125;&#123;% endraw %&#125;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第9章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-5%2F</url>
    <content type="text"><![CDATA[第九章：集合（重点掌握源码）概述Java 集合框架由 Java 类库的一系列接口、抽象类以及具体实现类组成。我们这里所说的集合就是把一组对象组织到一起，然后再根据不同的需求操纵这些数据。集合类型就是容纳这些对象的一个容器。也就是说，最基本的集合特性就是把一组对象放一起集中管理。根据集合中是否允许有重复的对象、对象组织在一起是否按某种顺序等标准来划分的话，集合类型又可以细分为许多种不同的子类型。 Java 集合框架为我们提供了一组基本机制以及这些机制的参考实现，其中基本的集合接口是 Collection 接口，其他相关的接口还有 Iterator 接口、RandomAccess 接口等。这些集合框架中的接口定义了一个集合类型应该实现的基本机制，Java 类库为我们提供了一些具体集合类型的参考实现，根据对数据组织及使用的不同需求，只需要实现不同的接口即可。Java 类库还为我们提供了一些抽象类，提供了集合类型功能的部分实现，我们也可以在这个基础上去进一步实现自己的集合类型。 Collection 接口迭代器我们先来看下这个接口的定义： 1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; 首先，它使用了一个类型参数；其次，它实现了 Iterable 接口，我们再来看下 Iterable 接口的定义： 123public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; 我们可以看到这个接口只定义了一个方法，这个方法要求我们返回一个实现了 Iterator 类型的对象，所以我们看下 Iterator 的定义： 12345public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125; 说到这里，我们简单地说一下迭代器（Iterator）这个东西。上面我们一共提到了两个和迭代器相关的接口：Iterable 接口和 Iterator 接口，从字面意义上来看，前者的意思是 “可迭代的”，后者的意思是 “迭代器。所以我们可以这么理解这两个接口：实现了 Iterable 接口的类是可迭代的；实现了 Iterator 接口的类是一个迭代器。 迭代器就是一个我们用来遍历集合中的对象的东西。也就是说，对于集合，我们不是像对原始类型数组那样通过数组索引来直接访问相应位置的元素，而是通过迭代器来遍历。这么做的好处是将对于集合类型的遍历行为与被遍历的集合对象分离，这样一来我们无需关心该集合类型的具体实现是怎样的。只要获取这个集合对象的迭代器, 便可以遍历这个集合中的对象了。而像遍历对象的顺序这些细节，全部由它的迭代器来处理。现在我们来梳理一下前面提到的这些东西：首先，Collection 接口实现了 Iterable 接口，这意味着所有实现了 Collection 接口的具体集合类都是可迭代的。那么既然要迭代，我们就需要一个迭代器来遍历相应集合中的对象，所以 Iterable 接口要求我们实现 iterator 方法，这个方法要返回一个迭代器对象。一个迭代器对象也就是实现了 Iterator 接口的对象，这个接口要求我们实现 hasNext()、next()、remove() 这三个方法。其中 hasNext 方法判断是否还有下一个元素（即是否遍历完对象了），next 方法会返回下一个元素（若没有下一个元素了调用它会引起抛出一个 NoSuchElementException 异常），remove 方法用于移除最近一次调用 next 方法返回的元素（若没有调用 next 方法而直接调用 remove 方法会报错）。我们可以想象在开始对集合进行迭代前，有个指针指向集合第一个元素的前面，第一次调用 next 方法后，这个指针会” 扫过” 第一个元素并返回它，调用 hasNext 方法就是看这个指针后面还有没有元素了。也就是说这个指针始终指向刚遍历过的元素和下一个待遍历的元素之间。通常，迭代一个集合对象的代码是这个样子的： 123456Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; iter = c.iterator();while (iter.hasNext()) &#123; String element = iter.next(); //do something with element&#125; 从 Java SE 5.0 开始，我们可以使用与以上代码段等价但是更加简洁的版本： 123for (String element : c) &#123; //do something with element&#125; 上面我们提到过 Iterator 接口的 remove 方法必须在 next 方法返回一个元素后才能调用，这对 Java 类库中为我们提供的实现了 Collection 接口的类来说是这样的。当然我们可以通过自己定义一个实现 Collection 接口的集合类来改变这一默认行为（除非有充足的理由，否则最好不要这样做）。 Collection 接口我们先来看一下它的官方定义： The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Setand List. 大概的意思就是：Collection 接口是集合层级结构的根接口。一个集合代表了一组对象，这组对象被称为集合的元素。一些集合允许重复的元素而其他不允许；一些是有序的而一些是无序的。Java 类库中并未提供任何对这个接口的直接实现，而是提供了对于它的更具体的子接口的实现（比如 Set 接口和 List 接口）。 我们知道，接口是一组对需求的描述，那么让我们看看 Collection 接口提出了哪些需求。Collection 接口中定义了以下方法： 123456789101112131415boolean add(E e) //向集合中添加一个元素，若添加元素后集合发生了变化就返回true，若没有发生变化，就返回false。(optional operation).boolean addAll(Collection&lt;? extends E&gt; c) //添加给定集合c中的所有元素到该集合中(optional operation).void clear() //(optional operation).boolean contains(Object o) //判断该集合中是否包含指定对象boolean containsAll(Collection&lt;?&gt; c)boolean equals(Object o)int hashCode()boolean isEmpty()Iterator&lt;E&gt; iterator()boolean remove(Object o) //移除给定对象的一个实例（有的具体集合类型允许重复元素） (optional operation).boolean removeAll(Collection&lt;?&gt; c) //(optional operation).boolean retainAll(Collection&lt;?&gt; c) //仅保留给定集合c中的元素(optional operation).int size()Object[] toArray()&lt;T&gt; T[] toArray(T[] a) 我们注意到有些方法后面注释中标注了 “optional operation”，意思是 Collection 接口的实现类究竟需不需要实现这个方法视具体情况而定。比如有些具体的集合类型不允许向其中添加对象，那么它就无需实现 add 方法。我们可以看到，Collection 对象必须实现的方法有：contains 方法、containsAll 方法、isEmpty 方法、iterator 方法、size 方法、两个 toArray 方法以及 equals 方法、hashCode 方法，其中最后两个方法继承自 Object 类。 我们来说一下两个 toArray 方法，它们的功能都是都是返回这个集合的对象数组。第二个方法接收一个 arrayToFill 参数，当这个参数数组足够大时，就把集合中的元素都填入这个数组（多余空间填 null）；当 arrayToFill 不够大时，就会创建一个大小与集合相同，类型与 arrayToFill 相同的数组，并填入集合元素。 Collection 接口的直接子接口主要有三个：List 接口、Set 接口和 Queue 接口。下面我们对它们进行逐一介绍。 List 接口我们同样先看下它的官方定义： An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list.Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. 大概意思是：List 是一个有序的集合类型（也被称作序列）。使用 List 接口可以精确控制每个元素被插入的位置，并且可以通过元素在列表中的索引来访问它。列表允许重复的元素，并且在允许 null 元素的情况下也允许多个 null 元素。 我们再来看下它定义了哪些方法： 123456ListIterator&lt;E&gt; listIterator();void add(int i, E element);E remove(int i);E get(int i);E set(int i, E element);int indexOf(Object element); 我们可以看到，列表支持对指定位置元素的读写与移除。我们注意到，上面有一个 listIterator 方法，它返回一个列表迭代器。我们来看一看 ListIterator 接口都定义了哪些方法： 12345678void add(E e) //在当前位置添加一个元素boolean hasNext() //返回ture如果还有下个元素（在正向遍历列表时使用）boolean hasPrevious() //反向遍历列表时使用E next() //返回下一个元素并将cursor（也就是我们上文提到的”指针“）前移一个位置int nextIndex() //返回下一次调用next方法将返回的元素的索引E previous() //返回前一个元素并将cursor向前移动一个位置int previousIndex() //返回下一次调用previous方法将返回的元素的索引void remove() //从列表中移除最近一次调用next方法或previous方法返回的元素void set(E e) //用e替换最近依次调用next或previous方法返回的元素 ListIterator 是 Iterator 的子接口，它支持像双向迭代这样更加特殊化的操作。综合以上，我们可以看到，List 接口支持两种访问元素的方式：使用列表迭代器顺序访问或者使用 get/set 方法随机访问。 Java 类库中常见的实现了 List 接口的类有：ArrayList， LinkedList，Stack，Vector，AbstractList，AbstractSequentialList 等等。 ArrayListArrayList 是一个可动态调整大小的数组，允许 null 类型的元素。我们知道，Java 中的数组大小在初始化时就必须确定下来，而且一旦确定就不能改变，这会使得在很多场景下不够灵活。ArrayList 很好地帮我们解决了这个问题，当我们需要一个能根据包含元素的多少来动态调整大小的数组时，那么 ArrayList 正是我们所需要的。 我们先来看看这个类的常用方法： 1234567891011121314boolean add(E e) //添加一个元素到数组末尾void add(int index, E element) //添加一个元素到指定位置void clear()boolean contains(Object o)void ensureCapacity(int minCapacity) //确保ArrayList至少能容纳参数指定数目的对象，若有需要会增加ArrayList实例的容量。E get(int index) //返回指定位置的元素int indexOf(Object o)boolean isEmpty()Iterator&lt;E&gt; iterator()ListIterator&lt;E&gt; listIterator()E remove(int index)boolean remove(Object o)E set(int index, E element)int size() 当我们插入了比较多的元素，导致 ArrayList 快要装满时，它会自动增长容量。ArrayList 内部使用一个 Object 数组来存储元素，自动增长容量是通过创建一个新的容量更大的 Object 数组，并将元素从原 Object 数组复制到新 Object 数组来实现的。若要想避免这种开销，在知道大概会容纳多少数据时，我们可以在构造时指定好它的大小以尽量避免它自动增长的发生；我们也可以调用 ensureCapacity 方法来增加 ArrayList 对象的容量到我们指定的大小。ArrayList 有以下三个构造器： 123ArrayList()ArrayList(Collection&lt;? extends E&gt; c)ArrayList(int initialCapacity) //指定初始capacity，即内部Object数组的初始大小 LinkedList 类LinkedList 类代表了一个双向链表，允许 null 元素。这个类同 ArrayList 一样，不是线程安全的。这个类中主要有以下的方法： 123456void addFirst(E element);void addLast(E element);E getFirst();E getLast();E removeFirst();E removeLast(); 这些方法的含义正如它们的名字所示。LinkedList 作为 List 接口的实现类，自然包含了 List 接口中定义的 add 等方法。LinkedList 的 add 方法实现有以下两种： 12boolean add(E e) //把元素e添加到链表末尾void add(int index, E element) //在指定索引处添加元素 LinkedList 的一个缺陷在于它不支持对元素的高效随机访问，要想随机访问其中的元素，需要逐个扫描直到遇到符合条件的元素。只有当我们需要减少在列表中间添加或删除元素操作的代价时，可以考虑使用 LinkedList。 Set 接口Set 接口与 List 接口的重要区别就是它不支持重复的元素，至多可以包含一个 null 类型元素。Set 接口定义的是数学意义上的 “集合” 概念。Set 接口主要定义了以下方法： 1234567891011boolean add(E e)void clear()boolean contains(Object o)boolean isEmpty()boolean equals(Object obj)Iterator&lt;E&gt; iterator()boolean remove(Object o)boolean removeAll(Collection&lt;?&gt; c)int size()Object[] toArray()&lt;T&gt; T[] toArray(T[] a) Set 接口并没有显式要求其中的元素是有序或是无序的，它有一个叫做 SortedSet 的子接口，这个接口可以用来实现对 Set 元素的排序，SortedSet 还有叫做 NavigableSet 的子接口，这个接口定义的方法可以在有序 Set 中进行查找和遍历。Java 类库中实现了 Set 接口的类主要有：AbstractSet，HashSet，TreeSet，EnumSet，LinkedHashSet 等等。其中，HashSet 与 TreeSet 都是 AbstractSet 的子类。那么，为什么 Java 类库要提供 AbstractSet 这个抽象类呢？答案是为了让我们在自定义实现 Set 接口的类时不必 “从零开始”，AbstractSet 这个抽象类已经为我们实现了 Set 接口中的一些常规方法，而一些灵活性比较强的方法可以由我们自己来定义，我们只需要继承 AbstractSet 这个抽象类即可。类似的抽象类还有很多，比如我们上面提到的实现了 List 接口的 AbstractList 抽象类就是 LinkedList 和 ArrayList 的父类。Java 官方文档中提到，HashSet 和 TreeSet 分别基于 HashMap 和 TreeMap 实现（我们在后面会简单介绍 HashMap 和 TreeMap），他们的区别在于 Set 接口是一个对象的集（数学意义上的” 集合“），Map&lt;K, V &gt; 是一个键值对的集合。而且由于它们分别是对 Set 和 Map&lt;K, V &gt; 接口的实现，相应添加与删除元素的方法也取决于具体接口的定义。 Queue 接口Queue 接口是对队列这种数据结构的抽象。一般的队列实现允许我们高效的在队尾添加元素，在队列头部删除元素（First in, First out)。Queue 接口还有一个名为 Deque 的子接口，它允许我们高效的在队头或队尾添加 / 删除元素，实现了 Deque 的接口的集合类即为双端队列的一种实现（比如 LinkedList 就实现了 Deque 接口）。Queue 接口定义了以下方法： 123456boolean add(E e) //添加一个元素到队列中，若队列已满会抛出一个IllegalStateException异常E element() //获取队头元素boolean offer(E e) //添加一个元素到队列中，若队列已满返回falseE peek() //获取队头元素，若队列为空返回nullE poll() //返回并移除队头元素，若队列为空返回nullE remove() //返回并移除队头元素 我们注意观察下上面的方法：add 与 offer，element 与 peek，remove 与 poll 看似是三对儿功能相同的方法。它们之间的重要区别在于前者若操作失败会抛出一个异常，后者若操作失败会从返回值体现出来（比如返回 false 或 null），我们可以根据具体需求调用它们中的前者或后者。 实现 Queue 接口的类主要有：AbstractQueue， ArrayDeque， LinkedList，PriorityQueue，DelayQueue 等等。关于它们具体的介绍可参考官方文档或相关的文章。 Map 接口我们先来看下它的定义： An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.The Mapinterface provides three collection views, which allow a map’s contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map’s collection views return their elements. Some map implementations, like the TreeMapclass, make specific guarantees as to their order; others, like the HashMapclass, do not. 大概意思是这样的：一个把键映射到值的对象被称作一个 Map 对象。映射表不能包含重复的键，每个键至多可以与一个值关联。Map 接口提供了三个集合视图（关于集合视图的概念我们下面会提到）：键的集合视图、值的集合视图以及键值对的集合视图。一个映射表的顺序取决于它的集合视图的迭代器返回元素的顺序。一些 Map 接口的具体实现（比如 TreeMap）保证元素有一定的顺序，其它一些实现（比如 HashMap）则不保证元素在其内部有序。 也就是说，Map 接口定义了一个类似于 “字典” 的规范，让我们能够根据键快速检索到它所关联的值。我们先来看看 Map 接口定义了哪些方法： 1234567891011void clear()boolean containsKey(Object key) //判断是否包含指定键boolean containsValue(Object value) //判断是否包含指定值boolean isEmpty()V get(Object key) //返回指定键映射的值V put(K key, V value) //放入指定的键值对V remove(Object key)int size()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Set&lt;K&gt; keySet()Collection&lt;V&gt; values() 后三个方法在我们下面介绍集合视图时会具体讲解。 Map 接口的具体实现类主要有：AbstractMap，EnumMap，HashMap，LinkedHashMap，TreeMap。HashTable。 HashMap我们看一下 HashMap 的官方定义： HashMap&lt;K, V&gt; 是基于哈希表这个数据结构的 Map 接口具体实现，允许 null 键和 null 值。这个类与 HashTable 近似等价，区别在于 HashMap 不是线程安全的并且允许 null 键和 null 值。由于基于哈希表实现，所以 HashMap 内部的元素是无序的。HashMap 对与 get 与 put 操作的时间复杂度是常数级别的（在散列均匀的前提下）。对 HashMap 的集合视图进行迭代所需时间与 HashMap 的 capacity（bucket 的数量）加上 HashMap 的尺寸（键值对的数量）成正比。因此，若迭代操作的性能很重要，不要把初始 capacity 设的过高（不要把 load factor 设的过低）。 有两个因素会影响一个 HashMap 对象的性能：intial capacity（初始容量）和 load factor（负载因子）。intial capacity 就是 HashMap 对象刚创建时其内部的哈希表的 “桶” 的数量（请参考哈希表的定义）。load factor 等于 maxSize / capacity，也就是 HashMap 所允许的最大键值对数与桶数的比值。增大 load factor 可以节省空间但查找一个元素的时间会增加，减小 load factor 会占用更多的存储空间，但是 get 与 put 的操作会更快。当 HashMap 中的键值对数量超过了 maxSize（即 load factor 与 capacity 的乘积），它会再散列，再散列会重建内部数据结构，桶数（capacity）大约会增加到原来的两倍。 HashMap 默认的 load factor 大小为 0.75，这个数值在时间与空间上做了很好的权衡。当我们清楚自己将要大概存放多少数据时，也可以自定义 load factor 的大小。 HashMap 的构造器如下： 1234HashMap()HashMap(int initialCapacity)HashMap(int initialCapacity, float loadFactor)HashMap(Map&lt;? extends K,? extends V&gt; m) //创建一个新的HashMap，用m的数据填充 常用方法如下： 1234567891011void clear()boolean containsKey(Object key)boolean containsValue(Object value)V get(Object key)V put(K key, V value)boolean isEmpty()V remove(Object key)int size()Collection&lt;V&gt; values()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()Set&lt;K&gt; keySet() 它们的功能都很直观，更多的使用细节可以参考 Java 官方文档，这里就不贴上来了。这里简单地提一下 WeakHashMap，它与 HashMap 的区别在于，存储在其中的 key 是 “弱引用” 的，也就是说，当不再存在对 WeakHashMap 中的键的外部引用时，相应的键值对就会被回收。关于 WeakHashMap 和其他类的具体使用方法及注意事项，大家可以参考官方文档。下面我们来简单地介绍下另一个 Map 接口的具体实现——TreeMap。 TreeMap它的官方定义是这样的： TreeMap&lt;K, V&gt; 一个基于红黑树的 Map 接口实现。TreeMap 中的元素是有序的，排序的依据是存储在其中的键的 natural ordering（自然序，也就是数字从小到大，字母的话按照字典序）或者根据在创建 TreeMap 时提供的 Comparator 对象，这取决于使用了哪个构造器。TreeMap 的 containsKey, get, put 和 remove 操作的时间复杂度均为 log(n)。 TreeMap 有以下构造器： 1234TreeMap() //使用自然序对其元素进行排序TreeMap(Comparator&lt;? super K&gt; comparator) //使用一个比较器对其元素进行排序TreeMap(Map&lt;? extends K,? extends V&gt; m) //构造一个与映射表m含有相同元素的TreeMap，用自然序进行排列TreeMap(SortedMap&lt;K,? extends V&gt; m) //构造一个与有序映射表m含有相同元素及元素顺序的TreeMap 它的常见方法如下： 12345678910111213141516Map.Entry&lt;K,V&gt; ceilingEntry(K key) //返回一个最接近且大于等于指定key的键值对。K ceilingKey(K key)void clear()Comparator&lt;? super K&gt; comparator() //返回使用的比较器，若按自然序则返回nullboolean containsKey(Object key)boolean containsValue(Object value)NavigableSet&lt;K&gt; descendingKeySet() //返回一个包含在TreeMap中的键的逆序的NavigableSet视图NavigableMap&lt;K,V&gt; descendingMap()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()Map.Entry&lt;K,V&gt; firstEntry() //返回键最小的键值对Map.Entry&lt;K,V&gt; floorEntry(K key) //返回一个最接近指定key且小于等于它的键对应的键值对K floorKey(K key)V get(Object key)Set&lt;K&gt; keySet()Map.Entry&lt;K,V&gt; lastEntry() //返回与最大的键相关联的键值对K lastKey() 建议大家先了解下红黑树这个数据结构的原理及实现（可参考算法（第 4 版） (豆瓣)），然后再去看官方文档中关于这个类的介绍，这样学起来会事半功倍。 最后再简单地介绍下 NavigableMap&lt;K, V&gt; 这个接口： 实现了这个接口的类支持一些 navigation methods，比如 lowerEntry（返回小于指定键的最大键所关联的键值对），floorEntry（返回小于等于指定键的最大键所关联的键值对），ceilingEntry（返回大于等于指定键的最小键所关联的键值对）和 higerEntry（返回大于指定键的最小键所关联的键值对）。一个 NavigableMap 支持对其中存储的键按键的递增顺序或递减顺序的遍历或访问。NavigableMap&lt;K, V&gt; 接口还定义了 firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 等方法，以准确获取指定位置的键值对。 总的来说，NavigableMap&lt;K, V&gt; 接口正如它的名字所示，支持我们在映射表中” 自由的航行 “，正向或者反向迭代其中的元素并获取我们需要的指定位置的元素。TreeMap 实现了这个接口。 视图（View）与包装器下面我们来解决一个上面遗留的问题，也就是介绍一下集合视图的概念。Java 中的集合视图是用来查看集合中全部或部分数据的一个”窗口 “，只不过通过视图我们不仅能查看相应集合中的元素，对视图的操作还可能会影响到相应的集合。通过使用视图可以获得其他的实现了 Map 接口或 Collection 接口的对象。比如我们上面提到的 TreeMap 和 HashMap 的 keySet() 方法就会返回一个相应映射表对象的视图。也就是说，keySet 方法返回的视图是一个实现了 Set 接口的对象，这个对象中又包含了一系列键对象。 轻量级包装器Arrays.asList 会发挥一个包装了 Java 数组的集合视图（实现了 List 接口）。请看以下代码： 1234567public static void main(String[] args) &#123; String[] strings = &#123;"first", "second", "third"&#125;; List&lt;String&gt; stringList = Arrays.asList(strings); String s1 = stringList.get(0); System.out.println(s1); stringList.add(0, "new first");&#125; 以上代码会编译成功，但是在运行时会抛出一个 UnsupportedOperationException 异常，原因是调用了改变列表大小的 add 方法。Arrays.asList 方法返回的封装了底层数组的集合视图不支持对改变数组大小的方法（如 add 方法和 remove 方法）的调用（但是可以改变数组中的元素）。实际上，这个方法调用了以下方法： 1Collections.nCopies(n, anObject); 这个方法会返回一个实现了 List 接口的不可修改的对象。这个对象包含了 n 个元素（anObject）。 子范围我们可以为很多集合类型建立一个称为子范围（subrange）的集合视图。例如以下代码抽出 group 中的第 10 到 19 个元素（从 0 开始计数）组成一个子范围： 1List subgroup = group.subList(10, 20); //group为一个实现了List接口的列表类型 List 接口所定义的操作都可以应用于子范围，包括那些会改变列表大小的方法，比如以下方法会把 subgroup 列表清空，同时 group 中相应的元素也会从列表中移除： 1subgroup.clear(); 对于实现了 SortedSet 接口的有序集或是实现了 SortedMap&lt;K, V &gt; 接口的有序映射表，我们也可以为他们创建子范围。SortedSet 接口定义了以下三个方法： 123SortedSet&lt;E&gt; subSet(E from, E to); SortedSet&lt;E&gt; headSet(E to);SortedSet&lt;E&gt; tailSet(E from); SortedMap 也定义了类似的方法： 123SortedMap&lt;K, V&gt; subMap(K from, K to);SortedMap&lt;K, V&gt; headMap(K to);SortedMap&lt;K, V&gt; tailMap(K from); 不可修改的视图Collections 类中的一些方法可以返回不可修改视图（unmodifiable views)： 123456Collections.unmodifiableCollectionCollections.unmodifiableListCollections.unmodifiableSetCollections.unmodifiableSortedSetCollections.unmodifiableMapCollections.unmodifiableSortedMap 同步视图若集合可能被多个线程并发访问，那么我们就需要确保集合中的数据不会被破坏。Java 类库的设计者使用视图机制来确保常规集合的线程安全。比如，我们可以调用以下方法将任意一个实现了 Map 接口的集合变为线程安全的： 1Map&lt;String, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;()); 被检验视图我们先看一下这段代码： 123ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;();ArrayList rawList = strings;rawList.add(new Date()); 在以上代码的第二行，我们把泛型数组赋值给了一个原始类型数组，这通常只会产生一个警告。而第三行我们往 rawList 中添加一个 Date 对象时，并不会产生任何错误。因为 rawList 内部存储的实际上是 Object 对象，而任何对象都可以转换为 Object 对象。那么我们怎么避免这一问题呢，请看以下代码： 1234ArrayList&lt;String&gt; strings = new ArrayList&lt;String&gt;();List&lt;String&gt; safeStrings = Collections.checkedList(strings, String.class);ArrayList rawList = safeStrings;rawList.add(new Date()); //Checked list throws a ClassCastException 在上面，我们通过包装 strings 得到一个被检验视图 safeStrings。这样在尝试添加非 String 对象时，便会抛出一个 ClassCastException 异常。 集合视图的本质集合视图本身不包含任何数据，它只是对相应接口的包装。集合视图所支持的所有操作都是通过访问它所关联的集合类实例来实现的。我们来看看 HashMap 的 keySet 方法的源码： 12345678910111213141516171819202122232425262728293031323334353637public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks; return (ks = keySet) == null ? (keySet = new KeySet()) : ks;&#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125;&#125; 我们可以看到，实际上 keySet() 方法返回一个内部 final 类 KeySet 的实例。我们可以看到 KeySet 类本身没有任何实例变量。我们再看 KeySet 类定义的 size() 实例方法，它的实现就是通过直接返回 HashMap 的实例变量 size。还有 clear 方法，实际上调用的就是 HashMap 对象的 clear 方法。 keySet 方法能够让你直接访问到 Map 的键集，而不需要复制数据或者创建一个新的数据结构，这样做往往比复制数据到一个新的数据结构更加高效。考虑这样一个场景：你需要把一个之前创建的数组传递给一个接收 List 参数的方法，那么你可以使用 Arrays.asList 方法返回一个包装了数组的视图（这需要的空间复杂度是常数级别的），而不用创建一个新的 ArrayList 再把原数组中的数据复制过去。 Collections 类我们要注意到 Collections 类与 Collection 接口的区别：Collection 是一个接口，而 Collections 是一个类（可以看做一个静态方法库）。下面我们看一下官方文档对 Collections 的描述： Collections 类包含了大量用于操作或返回集合的静态方法。它包含操作集合的多态算法，还有包装集合的包装器方法等等。这个类中的所有方法在集合或类对象为空时均会抛出一个 NullPointerException。 关于 Collections 类中的常用方法，我们上面已经做了一些介绍，更加详细的介绍大家可以参考 Java 官方文档。 总结关于 Java 集合框架，我们首先应该把握住几个核心的接口，请看下图： 我们还要了解到这些接口描述了一组什么样的机制，然后以此作为出发点，去了解具体哪些类实现了哪些机制。像这样自顶向下的学习，我们很快就能掌握常见集合类的用法。对于一些我们平常经常使用的类，我们还可以阅读一下它的源码，了解它的实现细节，这样我们以后使用起来会更加得心应手。不过阅读一些集合类（比如 TreeMap、HashMap）的源码需要我们具备一定的数据结构与算法的基础知识，这方面推荐阅读 算法（第 4 版） (豆瓣)。 参考资料 《Java 核心技术（卷一）》 What is a view of a collection? Java SE 7 Docs 总结： 概念：• Java 集合类库将接口与实现分离，接口定义增删改查等方法，具体分为集合和映射两种基本接口 (Collection 和 Map)。Collection 接口实现了 Iterable 接口，往下又分为 List、Set 和 Queue，Set 往下有 SortSet 等；Map 下有 SortedMap 等 (都是接口)。RandomAccess 接口用于判断该集合是否支持高效的随机访问。• 集合没有 key 值，映射有 key 和 value。集合的实现可以使用具体的数据结构来存储数据，每种数据结构的特点不同。注意 Tree、优先级队列等是随机插入，按指定顺序输入；而 Linked 是按插入顺序输出。• 常用的几种具体集合和映射：ArrayList、LinkedList、HashSet、TreeSet、LinkedHashSet、LinkedBlockingDeque 等 (Collection 集合)；HashMap、LinkedHashMap、WeadHashMap 等 (Map 映射)。• Java 集合接口可以定义不同的实现，不同实现使用不同的数据结构，各种数据结构有自己的特点，另外结合泛型、迭代器，因此可以定义各种不同的数据存储方式。接口从Collection-&gt;List等有不同等级，每层接口定义的方法不同，逐步完善。中间也提供了一些抽象父类完成了一些基本实现，如元素默认判等使用equals()方法，因此 Set 也要求我们自定义equals()方法。 接口 List 可以添加重复元素，是有序的；Set 不能添加重复元素，是无序的。所以元素被访问的顺序取决于集合类型。 迭代器：• Java 的迭代器位于两个元素之间，调用next()时，迭代器越过下一个元素，并返回刚刚越过的元素。调用remove()时将删除上次调用next()越过的那个元素。调用remove()之前没有调用next()是不合法的 (不能连续两次调用 remove())。• add()方法插入元素到光标之前。add()方法依赖于迭代器位置，remove()方法依赖于迭代器状态。迭代器可以并发读，要控制并发写。listIterator 的set()方法用一个新元素的值取代越过返回的那个元素，可返回局部迭代器。 集 set 中要适当的定义集的equals()方法，如只要两个集包含数据相同的元素 (不要求顺序相同，不要求是同一个对象)，就认为是相等的。相等的两个集合要求要有相同的散列码 hashCode(注意是子元素这一层定义 equals()、hashCode() 等方法，集合这一层的 equals()里根据子元素再自定义判等)。 List 是有序集合，访问可以通过迭代器顺序访问或通过下标随机访问，但是不同数据结构随机访问性能差别很大，如随机插入、删除使用 LinkedList(双向链表结构，数据保存在节点中，每个节点保存着前驱和后继的节点，便于插入删除；但是随机访问要挨个移动指针，因此不支持快速随机访问)；随机查询使用 ArrayList，可以通过索引来访问 (动态数组结构，支持二分查找随机访问，中间增删要移动和赋值数据，效率低，需要把插入位置后所有元素往后移动)。因此 ArrayList 使索引访问更快，LinkedList 最好使用迭代器遍历。数组动态查询之所以快是因为开辟连续的内存地址存储数据，找到一个位置就能知道其他位置，也因此是有界的，且动态插入效率低；而链表是将数据放在节点中，真正的数据内存地址不需连续，因此随机查询效率低，每次都要找出内存地址，但是随机插入高效，只需要改节点的指针即可，也满足了无界。 LinkedList 列表的get()方法实际上做了微小的优化，如果索引大于size()/2的话就从列表尾端开始搜索元素。但是 for 循环中的list.get(i)是效率很低的，每次都要从头遍历，因此随机查询不建议使用 LinkedList。插入时add()方法默认插入到尾部，插入中间可以用add(i)或迭代器listIterable.add()插入 (依赖光标位置)，listIterable 迭代器也能返回局部迭代列表。 Vector 类和 HashTable 类的方法都是同步的，可以线程安全的访问对象，但是因此效率比较低。不考虑线程安全的话建议使用 ArrayList 和 HashMap。 散列表：提供快速查找的数据结构，为每一个对象计算一个整数，称为散列码，散列码是由对象的实例域产生的一个整数。Java 中散列表用链表数组实现，每个列表被称为桶。查找表中对象的位置，先计算散列码，与桶的总数取余，结果就是保存这个元素的桶的索引，因此只需要在这个桶中找数据即可。 桶中已有一个元素的情况称为 “散列冲突” 或“哈希冲突”，这时默认策略是按列表继续往后放元素 (也有策略是寻找下一个桶)，桶满时(有个默认桶满值如 8) 会从列表变为平衡二叉树(树结构查询更快)。如果散列表太满(不论元素在哪个桶中，总的 size / 总桶数大于填充因子就算满了)，就需要再散列(以 2 的倍数扩桶)。创建一个桶更多的表将所有元素插入到这个新表中，丢弃原来的表。装填因子决定何时对散列表再散列，默认为 0.75。 所谓 Set 是无序的，因为算出的桶索引是无序的，add 的元素不一定在哪个索引下；另外 Set 无重复元素因为hashCode()算出的桶索引基本不会一样，如果一样了，还会继续判equals()是否一致，一致则覆盖，否则往后链表里加。 queals()方法和hashCode()的定义必须兼容，如果x.equals(y)为 true，x.hashCode()也必须等于y.hashCode()。 树集 TreeSet 是一个有序集合，按任意顺序插入，迭代器遍历时会顺序输出，排序使用红黑树实现。使用树集必须能够比较元素，因此元素必须实现 Comparator 接口或构造方法中传入一个 Comparator。将一个元素插入到树中比插入到散列集要稍微慢一点点，但是检查数组或链表中的重复元素，树稍微快一点，所以单个桶满会将链表变二叉树。 队列接口可以在尾部添加元素，在头部删除元素，不可在中间插入，并且可以查找队列中元素的个数。队列接口的实现方式通常有循环数组 (有界) 和列表 (无界) 两种方式。 优先级队列的元素可以按任意方式插入，却总是按排序的顺序进行检索。内部使用堆 (可自我调整的二叉树，每次插入完就已经是有序的了) 来存储数据，迭代并不是按照元素顺序访问，而删除却总是删除掉优先级最小的那个元素，也需要提供 Comparator。多用于任务调度中任务队列的实现。 映射：不同于集合直接存放精确数据副本，而是用来存放键值对。通用分为 HashMap 和 TreeMap，散列映射对键进行散列，树映射用键的整体顺序来排序。get()时没有对应键的信息，则返回null；键可以为 null，值不能为 null；重复调用put()方法会覆盖掉上一次的值，put()方法返回上一次的旧值 (没有返回 null)。 视图：集合框架认为映射本身不是一个集合，但它的视图是实现了 Collection 接口或某个子接口的对象。有三种：键集 (Set)、值集合 (Collection)、键 / 值对集 (Set)。KeySet 并不是 HashSet 或 TreeSet，只是实现了 Set 接口的某个类对象。既然是集合，就有迭代器，但是仅对原映射集可删除不能增加。 WeakedHashMap 弱散列映射解决映射强引用问题，当元素只被散列条目引用时，会将其加入到弱引用队列，等待垃圾回收机制将其回收。LinkedHashMap/Set 可以记录插入顺序，但是使用访问顺序进行迭代 (同一个桶中元素被访问后会从当前节点删除加入到链表尾部)，且重写removeEldestEntry()方法可以实现类似 LRU 算法的 Map，不过这种迭代顺序的影响只有发生散列冲突时才能看出来。 Collections 的静态方法synchronizedMap()方法可以将任意一个映射表转成线程安全的 Map。不管是集合还是映射，是有并发问题的，不可一个迭代器正在修改，另一个迭代器在读，会抛出异常。 Collections 的sort()方法可以进行排序，shuffle()方法可以进行乱序，binarySearch()方法进行二分查找等，类似 Arrays 的一些方法。 属性映射 Property 是一种特殊的映射结构，键值都是字符串，可以load(InputStream is)加载，也可store(OutputStream out,String str)写出。 栈 Stack 后进先出，有push()、pop()、peek()等方法，注意pop()和peek()如果站内无元素是会抛异常。 位集 BitSet 可高效存储位序列，元素包装在字节里，比 ArrayList 存 Boolean 效率高。 几种数据结构比较：• 数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)。• 链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)。• 二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。• 哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。 HashMap 的实现原理：内部采用散列表进行存储，散列表数据结构为数组 + 链表，数组保证快速定位，链表保证哈希冲突 (策略有开放地址法、再散列函数法和链地址法)。JDK1.7 中默认容量 16，链表变树临界值 8，填充因子 0.75，size表示当前 Entry 总数 (不管是单桶还是多桶中)，threshold表示临界扩容桶值。在第一次put()中才给table赋值，hash()对 key 值取 hashCode 进行一系列异或位移操作保证均匀分布，indexFor()这里要求桶数每次都是 2 的幂，这样桶数 - 1 后二进制一定是全 1，不管是直接计算索引值还是再散列时对之前的所有元素重新计算 index 时，需要尽可能快，而 hashCode 不论多大与全 1 进行&amp;运算时，前面全部是非，裁掉了，后面得出的结果就是余数大小，小小算法有点叼 (位运算性能更高吧)。一般来说，对单桶，大于链表变树临界值则将链表变为树结构 (树的查询更快)，对多桶，总数大于threshold临界值则需扩容，但是桶总数 64 之前，该链表变树时优先扩容，桶数大于 64 之后再该变树变树该扩容扩容，可能是优先尽量避免哈希冲突吧。重点：都很重要 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-1%2F</url>
    <content type="text"><![CDATA[见《java核心技术》笔记各章后总结 在看完java集合框架源码和多线程内容后会总结该部分。 参考：https://www.cnblogs.com/BYRans/p/Java.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（7~8章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-4%2F</url>
    <content type="text"><![CDATA[第七章：异常、断言和日志7.1 处理错误需要关注的问题 用户输入错误 设备错误 物理限制 代码错误 7.1.1 异常分类 派生于 RuntimeException 的异常包含下面几种情况: 错误的类型转换 数组访问越界 访问 null 指针 不是派生于 RuntimeException 的异常包括 试图在文件尾部后面读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在 7.1.2 声明受检查异常 使用 throws 关键字，在方法的首部同所有的异常类。每个异常类之间用逗号隔开。 7.1.3 使用 throws new Exception();7.1.4 创建异常类派生于 Exception 类或派生于 Exception 的子类 7.2 捕获异常7.2.1 捕获异常123try&#123;&#125; catch (Exception e)&#123;&#125; 7.2.2 捕获多个异常 Java 7 以后，在 catch 子句中可以捕获多个异常. 使用 | 7.2.3 再次抛出异常与异常链 在 catch 子句中，可以改变异常的类型，进行再次抛出 7.2.4 finally 子句 不管异常是否被捕获，finally 子句中的代码都被执行。 12345678InputStream in = new FileInputStream("c:\\a.txt");try&#123; try&#123; &#125; finally &#123; &#125;&#125; catch(IOException e) &#123; //异常处理的语句&#125; 7.2.5 带资源的 try 语句前提：资源属于实现了 AutoCloseable 接口的类 12try(Resourse res = ...) &#123;&#125; 7.2.6 分析堆栈轨迹元素 getStackTrace 方法，可以得到 stackTraceelElement 对象的一个数组，可以在你的程序中分析这个对象数组。 7.3 使用异常机制的技巧 异常处理不能代替简单的测试 不要过分的细化异常 利用异常层次结构 不要压制异常 在检测时，“苛刻” 比放任要好 不要羞于传递异常 7.4 使用断言 (JDK 自带的，基本不使用)7.4.1 断言的概念断言机制允许在测试期间向代码中插入一些检查语句，使用关键字 assert. 7.4.2 启用和禁用断言 在默认情况下，断言被禁用。使用 java -ea: 选项启用 7.4.3 使用断言完成参数检查7.4.4 为文档假设使用断言7.5 记录日志7.5.1 基本日志 使用全局日志记录器 (global logger) Logger.getGlobal().info(、、、); 7.5.2 高级日志 日志级别: 七种 SEVRE WARNING INFO CONFIG FINE FINER FINEST 7.5.3 修改日志管理器配置7.5.4 本地化7.5.5 处理器7.5.6 过滤器7.5.7 格式化器7.5.8 日志记录说明总结 总结： 所有的异常类都是由 Throwable 继承而来，下层分为 Error 和 Exception，Exception 又分为 IOException 和 RuntimeException。只有 IOException 是受查异常 (代码提示的异常)，其余都是非受查异常 (平时的崩溃，自己无法控制)。 Error 是 Java 形式内部错误和资源耗尽错误，我们无能为力；而程序中如果出现了 RuntimeException，那一定是程序员自己的问题。对于异常要么 throws 抛出去给别人处理，要么try catch自己处理。一个方法必须声明所有可能抛出的受查异常，而非受查异常是不可控的，应该避免。 子类覆盖超类的方法时，子类声明的受查异常不能比超类中声明的更通用；若超类中没有抛出任何受查异常，子类也不能抛出。 异常可以捕获也可以继续抛出，应该捕获那些知道应该如何处理的异常，而将那些不知道怎样处理的继续抛出 (如工具类中的异常抛出，由调用者自己来分别处理)。 catch 语句中可以继续抛出异常，并将原始异常设置为新异常的原因initCause()，可以让用户抛出子系统中的高级异常，而不会丢失原异常的细节。 try 语句中可以只有 finally 而没有 catch 块，不管异常是否被捕获，finally 语句块都会被执行，finally 语句在方法返回前被执行，所以不要在 finally 中写 return 语句，它会覆盖掉原方法中的 return。 堆栈轨迹 (stack trace) 是一个方法调用过程的列表，它包含了程序执行过程中方法的调用位置。t.getStackTrace()可以获取到一个 StackTraceElementp[] 数组，它包含了方法的 name、className 和调用行 lineNumber 等信息。 一般我们给Thread.setDefaultUnchaughtExceptionHandler()后，在程序非受查崩溃时会回调到 Handler 的uncaughtException(thread,throwable)，在这里可以将throwable.printStackTrace(writer)输出到文件里，然后将文件上传服务器帮助我们分析程序崩溃。 断言：• 定义：断言机制允许在程序测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检查语句会自动被移除。• 表现形式：assert 条件 / assert 条件: 表达式。• 开启断言：默认下断言是被禁用的，启用或禁用断言是类加载器 (ClassLoader) 的功能。启用或禁用使用java -ea/-da，可针对整个项目或某个特定 class 或 package 作用域。• 作用：断言相当于自己做了一层判断，如果符合预期则没什么，如果不符合预期会自动抛出一个 AssertionError 的非受查异常，不用在方法上自己去写 throw 了。重点：264 异常分类、捕获异常 第八章：泛型程序设计（了解） 泛型程序设计指编写的代码可以被许多不同类型的对象所重用，使程序具有更好的可读性和安全性。 泛型变量指域和局部变量及方法的返回类型。泛型可以用于类中也可用于方法中，泛型方法中的类型变量放在修饰符后面，返回类型的前面。 泛型可以用extends关键字指定子类型来做限制，可以 extends 多个类型，用&amp;符间隔。 类型擦除：虚拟机中没有泛型类型对象，把泛型类加载到虚拟机中后，所有定义的泛型 T 都会被擦除成原始类型。有限定类型的话擦除类型变量替换为限定类型 (extends 多继承时取第一个类型 因此标签接口尽量往后放)，无限定类型的话为 Object。 类型擦除与多态的冲突：由于泛型擦除，一个泛型类指向其子类的引用，子类中如果对父类的方法重载 (其实重载不了，父类参数是擦除后的 Object，子类是具体的类型)，在调用方法时，其实先调了父类的方法 (Object 类型)，然后参数强转桥接到了子类的重载方法 (具体类型)。严格上说不能重载，因此子类里是有两个方法的 (可查看子类. class 文件)。 Java 泛型转换总结：• 虚拟机中无泛型，只有普通类和方法；• 所有的参数类型都要用它们的限定类型替换；• 桥方法被合成用来保持多态；为保持类型安全性，必要时插入强制类型转换。 泛型约束：• 不能用类型参数代替基本类型；• 类型检测只会检测原始类型；• 不能实例化参数化类型数组 (不安全)；• 不能实例化类型变量；• 不能在静态域或方法中引用类型变量；• 不能抛出和捕获泛型异常。 泛型之间无联系，不论S与T有什么联系，Pair&lt;S&gt;与Pair&lt;T&gt;无任何联系。Class 类本身是泛型，如String.class是一个Class&lt;String&gt;的实例。 通配符类型中，允许类型参数变化。有&lt;? super X&gt;与&lt;? extends X&gt;，带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。 泛型 与通配符 &lt;?&gt; 的区别：泛型 T 指定一种类型参数的表示，实例化时是什么就是什么；通配符? 代表一种限制，只要符合条件类型是什么都行，可以有多种。重点：P316 泛型擦除 P330 通配符 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射由浅入深 | 进阶必备]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18-2%2F</url>
    <content type="text"><![CDATA[一、Java 反射机制 Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 反射机制很重要的一点就是 “运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。换句话说，Java 程序可以加载一个运行时才得知名称的 .class 文件，然后获悉其完整构造，并生成其对象实体、或对其 fields（变量）设值、或调用其 methods（方法）。 不知道上面的理论你能否明白，反正刚接触反射时我一脸懵比，后来写了几个例子之后：哦~~ 原来是这个意思！ 若暂时不明白理论没关系，先往下看例子，之后再回来看相信你就能明白了。 二、使用反射获取类的信息为使得测试结果更加明显，我首先定义了一个 FatherClass 类（默认继承自 Object 类），然后定义一个继承自 FatherClass 类的 SonClass 类，如下所示。可以看到测试类中变量以及方法的访问权限不是很规范，是为了更明显得查看测试结果而故意设置的，实际项目中不提倡这么写。 FatherClass.java 123456public class FatherClass &#123; public String mFatherName; public int mFatherAge; public void printFatherMsg()&#123;&#125;&#125; SonClass.java 123456789101112131415161718192021222324252627public class SonClass extends FatherClass&#123; private String mSonName; protected int mSonAge; public String mSonBirthday; public void printSonMsg()&#123; System.out.println("Son Msg - name : " + mSonName + "; age : " + mSonAge); &#125; private void setSonName(String name)&#123; mSonName = name; &#125; private void setSonAge(int age)&#123; mSonAge = age; &#125; private int getSonAge()&#123; return mSonAge; &#125; private String getSonName()&#123; return mSonName; &#125;&#125; 1. 获取类的所有变量信息12345678910111213141516171819202122232425/** * 通过反射获取类的所有变量 */private static void printFields()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的变量 // 包括本类声明的和从父类继承的 Field[] fields = mClass.getFields(); //2.2 获取所有本类声明的变量（不问访问权限） //Field[] fields = mClass.getDeclaredFields(); //3\. 遍历变量并输出变量信息 for (Field field :fields) &#123; //获取访问权限并输出 int modifiers = field.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //输出变量的类型及变量名 System.out.println(field.getType().getName() + " " + field.getName()); &#125;&#125; 以上代码注释很详细，就不再解释了。需要注意的是注释中 2.1 的 getFields() 与 2.2 的 getDeclaredFields() 之间的区别，下面分别看一下两种情况下的输出。看之前强调一下：SonClass extends FatherClass extends Object ： 调用 getFields() 方法，输出 SonClass 类以及其所继承的父类 ( 包括 FatherClass 和 Object ) 的 public 方法。注：Object 类中没有成员变量，所以没有输出。 1234类的名称：obj.SonClasspublic java.lang.String mSonBirthdaypublic java.lang.String mFatherNamepublic int mFatherAge 调用 getDeclaredFields() ， 输出 SonClass 类的所有成员变量，不问访问权限。 1234类的名称：obj.SonClassprivate java.lang.String mSonNameprotected int mSonAgepublic java.lang.String mSonBirthday 2. 获取类的所有方法信息123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 通过反射获取类的所有方法 */private static void printMethods()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的方法 //包括自己声明和从父类继承的 Method[] mMethods = mClass.getMethods(); //2.2 获取所有本类的的方法（不问访问权限） //Method[] mMethods = mClass.getDeclaredMethods(); //3.遍历所有方法 for (Method method : mMethods) &#123; //获取并输出方法的访问权限（Modifiers：修饰符） int modifiers = method.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //获取并输出方法的返回值类型 Class returnType = method.getReturnType(); System.out.print(returnType.getName() + " " + method.getName() + "( "); //获取并输出方法的所有参数 Parameter[] parameters = method.getParameters(); for (Parameter parameter: parameters) &#123; System.out.print(parameter.getType().getName() + " " + parameter.getName() + ","); &#125; //获取并输出方法抛出的异常 Class[] exceptionTypes = method.getExceptionTypes(); if (exceptionTypes.length == 0)&#123; System.out.println(" )"); &#125; else &#123; for (Class c : exceptionTypes) &#123; System.out.println(" ) throws " + c.getName()); &#125; &#125; &#125;&#125; 同获取变量信息一样，需要注意注释中 2.1 与 2.2 的区别，下面看一下打印输出： 调用 getMethods() 方法获取 SonClass 类所有 public 访问权限的方法，包括从父类继承的。打印信息中，printSonMsg() 方法来自 SonClass 类， printFatherMsg() 来自 FatherClass 类，其余方法来自 Object 类。 123456789101112类的名称：obj.SonClasspublic void printSonMsg( )public void printFatherMsg( )public final void wait( ) throws java.lang.InterruptedExceptionpublic final void wait( long arg0,int arg1, ) throws java.lang.InterruptedExceptionpublic final native void wait( long arg0, ) throws java.lang.InterruptedExceptionpublic boolean equals( java.lang.Object arg0, )public java.lang.String toString( )public native int hashCode( )public final native java.lang.Class getClass( )public final native void notify( )public final native void notifyAll( ) 调用 getDeclaredMethods() 方法 打印信息中，输出的都是 SonClass 类的方法，不问访问权限。 123456类的名称：obj.SonClassprivate int getSonAge( )private void setSonAge( int arg0, )public void printSonMsg( )private void setSonName( java.lang.String arg0, )private java.lang.String getSonName( ) 三、访问或操作类的私有变量和方法在上面，我们成功获取了类的变量和方法信息，验证了在运行时 动态的获取信息 的观点。那么，仅仅是获取信息吗？我们接着往后看。 都知道，对象是无法访问或操作类的私有变量和方法的，但是，通过反射，我们就可以做到。没错，反射可以做到！下面，让我们一起探讨如何利用反射访问 类对象的私有方法 以及修改 私有变量或常量。 老规矩，先上测试类。 注： 请注意看测试类中变量和方法的修饰符（访问权限）； 测试类仅供测试，不提倡实际开发时这么写 : ) TestClass.java 123456789101112public class TestClass &#123; private String MSG = "Original"; private void privateMethod(String head , int tail)&#123; System.out.print(head + tail); &#125; public String getMsg()&#123; return MSG; &#125;&#125; 3.1 访问私有方法以访问 TestClass 类中的私有方法 privateMethod(...) 为例，方法加参数是为了考虑最全的情况，很贴心有木有？先贴代码，看注释，最后我会重点解释部分代码。 1234567891011121314151617181920212223242526272829/** * 访问对象的私有方法 * 为简洁代码，在方法上抛出总的异常，实际开发别这样 */private static void getPrivateMethod() throws Exception&#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有方法 //第一个参数为要获取的私有方法的名称 //第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null //方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125; Method privateMethod = mClass.getDeclaredMethod("privateMethod", String.class, int.class); //3\. 开始操作方法 if (privateMethod != null) &#123; //获取私有方法的访问权 //只是获取访问权，并不是修改实际权限 privateMethod.setAccessible(true); //使用invoke反射调用私有方法 //privateMethod是获取到的私有方法 //testClass要操作的对象 //后面两个参数传实参 privateMethod.invoke(testClass, "Java Reflect ", 666); &#125;&#125; 需要注意的是，第 3 步中的 setAccessible(true) 方法，是获取私有方法的访问权限，如果不加会报异常 IllegalAccessException，因为当前方法访问权限是 “private” 的，如下： 1java.lang.IllegalAccessException: Class MainClass can not access a member of class obj.TestClass with modifiers "private" 正常运行后，打印如下，调用私有方法成功： 1Java Reflect 666 3.2 修改私有变量以修改 TestClass 类中的私有变量 MSG 为例，其初始值为 “Original” ，我们要修改为 “Modified”。老规矩，先上代码看注释。 12345678910111213141516171819202122232425262728/** * 修改对象私有变量的值 * 为简洁代码，在方法上抛出总的异常 */private static void modifyPrivateFiled() throws Exception &#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3\. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 此处代码和访问私有方法的逻辑差不多，就不再赘述，从输出信息看出 修改私有变量 成功： 12Before Modify：MSG = OriginalAfter Modify：MSG = Modified 3.3 修改私有常量在 3.2 中，我们介绍了如何修改私有 变量，现在来说说如何修改私有 常量， 01. 真的能修改吗？常量是指使用 final 修饰符修饰的成员属性，与变量的区别就在于有无 final 关键字修饰。在说之前，先补充一个知识点。 Java 虚拟机（JVM）在编译 .java 文件得到 .class 文件时，会优化我们的代码以提升效率。其中一个优化就是：JVM 在编译阶段会把引用常量的代码替换成具体的常量值，如下所示（部分代码）。 编译前的 .java 文件： 123456//注意是 String 类型的值private final String FINAL_VALUE = "hello";if(FINAL_VALUE.equals("world"))&#123; //do something&#125; 编译后得到的 .class 文件（当然，编译后是没有注释的）： 12345private final String FINAL_VALUE = "hello";//替换为"hello"if("hello".equals("world"))&#123; //do something&#125; 但是，并不是所有常量都会优化。经测试对于 int 、long 、boolean 这些基本类型 JVM 会优化，而对于 Integer 、Long 、Boolean 这种包装类型，或者其他诸如 Date 、Object 类型则不会被优化。 总结来说：对于基本类型的静态常量，JVM 在编译阶段会把引用此常量的代码替换成具体的常量值。 这么说来，在实际开发中，如果我们想修改某个类的常量值，恰好那个常量是基本类型的，岂不是无能为力了？反正我个人认为除非修改源码，否则真没办法！ 这里所谓的无能为力是指：我们在程序运行时刻依然可以使用反射修改常量的值（后面会代码验证），但是 JVM 在编译阶段得到的 .class 文件已经将常量优化为具体的值，在运行阶段就直接使用具体的值了，所以即使修改了常量的值也已经毫无意义了。 下面我们验证这一点，在测试类 TestClass 类中添加如下代码： 1234567//String 会被 JVM 优化private final String FINAL_VALUE = "FINAL";public String getFinalValue()&#123; //剧透，会被优化为: return "FINAL" ,拭目以待吧 return FINAL_VALUE;&#125; 接下来，是修改常量的值，先上代码，请仔细看注释： 12345678910111213141516171819202122232425262728293031323334353637/** * 修改对象私有常量的值 * 为简洁代码，在方法上抛出总的异常，实际开发别这样 */private static void modifyFinalFiled() throws Exception &#123; //1\. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2\. 获取私有常量 Field finalField = mClass.getDeclaredField("FINAL_VALUE"); //3\. 修改常量的值 if (finalField != null) &#123; //获取私有常量的访问权 finalField.setAccessible(true); //调用 finalField 的 getter 方法 //输出 FINAL_VALUE 修改前的值 System.out.println("Before Modify：FINAL_VALUE = " + finalField.get(testClass)); //修改私有常量 finalField.set(testClass, "Modified"); //调用 finalField 的 getter 方法 //输出 FINAL_VALUE 修改后的值 System.out.println("After Modify：FINAL_VALUE = " + finalField.get(testClass)); //使用对象调用类的 getter 方法 //获取值并输出 System.out.println("Actually ：FINAL_VALUE = " + testClass.getFinalValue()); &#125;&#125; 上面的代码不解释了，注释巨详细有木有！特别注意一下第 3 步的注释，然后来看看输出，已经迫不及待了，擦亮双眼： 123Before Modify：FINAL_VALUE = FINALAfter Modify：FINAL_VALUE = ModifiedActually ：FINAL_VALUE = FINAL 结果出来了: 第一句打印修改前 FINAL_VALUE 的值，没有异议； 第二句打印修改后常量的值，说明FINAL_VALUE确实通过反射修改了； 第三句打印通过 getFinalValue() 方法获取的 FINAL_VALUE 的值，但还是初始值，导致修改无效！ 这结果你觉得可信吗？什么，你还不信？问我怎么知道 JVM 编译后会优化代码？那要不这样吧，一起来看看 TestClass.java 文件编译后得到的 TestClass.class 文件。为避免说代码是我自己手写的，我决定不粘贴代码，直接截图： TestClass.class 文件 看到了吧，有图有真相，getFinalValue() 方法直接 return &quot;FINAL&quot;！同时也说明了，程序运行时是根据编译后的 .class 来执行的。 顺便提一下，如果你有时间，可以换几个数据类型试试，正如上面说的，有些数据类型是不会优化的。你可以修改数据类型后，根据我的思路试试，看输出觉得不靠谱就直接看 .classs 文件，一眼就能看出来哪些数据类型优化了 ，哪些没有优化。下面说下一个知识点。 02. 想办法也要修改！不能修改，这你能忍？别着急，不知你发现没，刚才的常量都是在声明时就直接赋值了。你可能会疑惑，常量不都是在声明时赋值吗？不赋值不报错？当然不是啦。 方法一 事实上，Java 允许我们声明常量时不赋值，但必须在构造函数中赋值。你可能会问我为什么要说这个，这就解释： 我们修改一下 TestClass 类，在声明常量时不赋值，然后添加构造函数并为其赋值，大概看一下修改后的代码（部分代码 ）： 1234567891011public class TestClass &#123; //...... private final String FINAL_VALUE; //构造函数内为常量赋值 public TestClass()&#123; this.FINAL_VALUE = "FINAL"; &#125; //......&#125; 现在，我们再调用上面贴出的修改常量的方法，发现输出是这样的： 123Before Modify：FINAL_VALUE = FINALAfter Modify：FINAL_VALUE = ModifiedActually ：FINAL_VALUE = Modified 纳尼，最后一句输出修改后的值了？对，修改成功了！想知道为啥，还得看编译后的 TestClass.class 文件的贴图，图中有标注。 解释一下：我们将赋值放在构造函数中，构造函数是我们运行时 new 对象才会调用的，所以就不会像之前直接为常量赋值那样，在编译阶段将 getFinalValue() 方法优化为返回常量值，而是指向 FINAL_VALUE ，这样我们在运行阶段通过反射修改敞亮的值就有意义啦。但是，看得出来，程序还是有优化的，将构造函数中的赋值语句优化了。再想想那句 程序运行时是根据编译后的 .class 来执行的 ，相信你一定明白为什么这么输出了！ 方法二 请你务必将上面捋清楚了再往下看。接下来再说一种改法，不使用构造函数，也可以成功修改常量的值，但原理上都一样。去掉构造函数，将声明常量的语句改为使用三目表达式赋值： 12private final String FINAL_VALUE = null == null ? "FINAL" : null; 其实，上述代码等价于直接为 FINAL_VALUE 赋值 “FINAL”，但是他就是可以！至于为什么，你这么想：null == null ? &quot;FINAL&quot; : null 是在运行时刻计算的，在编译时刻不会计算，也就不会被优化，所以你懂得。 总结来说，不管使用构造函数还是三目表达式，根本上都是避免在编译时刻被优化，这样我们通过反射修改常量之后才有意义！好了，这一小部分到此结束！ 最后的强调： 必须提醒你的是，无论直接为常量赋值 、 通过构造函数为常量赋值 还是 使用三目运算符，实际上我们都能通过反射成功修改常量的值。而我在上面说的修改 “成功” 与否是指：我们在程序运行阶段通过反射肯定能修改常量值，但是实际执行优化后的 .class 文件时，修改的后值真的起到作用了吗？换句话说，就是编译时是否将常量替换为具体的值了？如果替换了，再怎么修改常量的值都不会影响最终的结果了，不是吗？。 其实，你可以直接这么想：反射肯定能修改常量的值，但修改后的值是否有意义？ 03. 到底能不能改？到底能不能改？也就是说反射修改后到底有没有意义？ 如果你上面看明白了，答案就简单了。俗话说 “一千句话不如一张图”，下面允许我用不太规范的流程图直接表达答案哈。 注：图中 “没法修改” 可以理解为 “能修改值但没有意义”；”可以修改” 是指 “能修改值且有意义”。 判断能不能改 四、总结好了，本次记录就到这儿了，突然不知不觉发现写了好多，感谢耐心听我叨逼完。我想这篇博客如果你认真的看完，肯定会有收获的！最后，因为内容较多，知识点较多，如果文中有任何错误或欠妥的地方，还望指正。欢迎留言交流！ 原文：https://juejin.im/post/598ea9116fb9a03c335a99a4]]></content>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第6章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-3%2F</url>
    <content type="text"><![CDATA[第六章：接口、lambda 表达式与内部类6.1 接口6.1.1 接口概念在 Java 中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。例如：Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了 Comparable 接口。 12345//这是 Comparable 的代码public interface Comparable&lt;T&gt;&#123; int compareTo(T other);&#125; 接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字 public。接口可以定义常量，接口绝不能含有实例域。 Comparable int compareTo(T other)：建议实现用这个对象与 other 进行比较。如果这个对象小于 other 则返回负值；如果相等则返回 0；否则返回正值。 Arrays static void sort(Object[] a)：使用 mergesort 算法对数组 a 中的元素进行排序。要求数组中的元素必须属于实现了 Comparable 接口的类，并且元素之间必须是可比较的。 Integer &amp; Double static int compare(int x, int y) static int compare(double x, double y) x y 返回 1 6.1.2 接口的特性接口不是类，尤其不能使用 new 实例化一个接口。然而，尽管不能构造接口的对象，却能声明接口的变量：Comparable x;接口变量必须引用了实现接口的类对象：x = new Employee()接下来，可以使用 instanceof 检测一个对象是否实现了某个特定的接口if(anObject instanceof Comparable)接口可以实现继承，而且可以多继承。虽然在接口中不能包含实例域或静态方法，却可以包含常量，接口中的域将被自动设为 public static final。尽管每个类只能拥有一个父类，但却可以实现多个接口。 6.1.3 接口与抽象类接口与抽象类的目的差不多，都想让实现类实现自己的抽象方法，但 Java 是单继承的，如果没有接口，只有抽象类，那一个类继承完抽象类后，就不能再继承其他类了，所以接口显得更加灵活。 6.1.4 静态方法在 Java8 中，允许在接口中添加静态方法。 6.1.5 默认方法可以为接口方法提供一个默认实现。必须用 default 修饰符标记这个方法。不过一般没有什么作用，因为实现了接口的类往往会重新实现这个方法，如果设置了 default，那么在实现接口的时候就不会强制要求你实现这个抽象方法了。 123default int compareTo(Object other) &#123; return 0; &#125; 6.1.6 解决默认方法冲突如果先在一个接口中将一个方法定义为默认方法，然后又在父类或另一个接口中定义了同样的方法，会发生什么情况？ 父类优先。如果父类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。 接口冲突。如果一个父接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须 override 这个方法来解决冲突。 12345678910111213141516//两个接口，同样的方法，一个设置为 default public interface Named &#123; default String getName() &#123; return &quot;d&quot;; &#125;&#125;interface Person &#123; String getName();&#125;//当你同时实现这两个接口的时候，编译器会强制要求你实现一个 getName() 方法//而不是直接使用 Named 的 default 方法class Student implements Named,Person&#123;&#125; 那么父类和接口拥有同样的方法会发生什么呢？ 123456789101112131415public interface Named &#123; default String getName() &#123; return &quot;d&quot;; &#125;&#125;public class Student extends Person implements Named &#123;&#125;class Person &#123; public String getName() &#123; return &quot;superClass&quot;; &#125;&#125; 此时的话，是 “类优先” 的，无论 Named 的方法加不加 default，父类的方法都会 override 接口的方法。 6.2 接口示例6.2.1 接口与回调回调 (callback) 是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。 6.2.2 Comparator(比较器) 接口之前我们已经了解了如何对一个对象数组排序，前提是这些对象是实现了 Comparator 接口的类的实例。例如，可以对一个字符串数组排序，因为 String 类实现了 Comparable&lt;String&gt;，而且 String.compareTo 方法可以对字典顺序比较字符串。 1234567public static void main(String[] args) &#123; String[] staff = &#123; "fgfgfgf", "v", "zdgdgdgdgdgdgdg", "adgdgdgfgdgdgdgdgdg", "d", "m", "q" &#125;; Arrays.sort(staff); System.out.println(Arrays.toString(staff)); &#125; //[adgdgdgfgdgdgdgdgdg, d, fgfgfgf, m, q, v, zdgdgdgdgdgdgdg] //是用字典顺序规律排序的，无视长度 假设我们现在希望用长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序，如果要实现这种情况，可以选用 Arrays.sort 方法的第二个版本，有一个数组和一个比较器 (comparator) 作为参数，comparator 是实现了 Comparator 接口的类的实例。 12345678910111213141516171819public class LengthComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String s, String t1) &#123; return s.length() - t1.length(); &#125;&#125;public class EmployeeSortTest &#123; public static void main(String[] args) &#123; String[] staff = &#123; "fgfgfgf", "v", "zdgdgdgdgdgdgdg", "adgdgdgfgdgdgdgdgdg", "d", "m", "q" &#125;; Arrays.sort(staff); System.out.println(Arrays.toString(staff)); Arrays.sort(staff, new LengthComparator()); System.out.println(Arrays.toString(staff)); &#125;&#125;//[adgdgdgfgdgdgdgdgdg, d, fgfgfgf, m, q, v, zdgdgdgdgdgdgdg]//[d, m, q, v, fgfgfgf, zdgdgdgdgdgdgdg, adgdgdgfgdgdgdgdgdg] 6.2.3 对象克隆本节会讨论 Cloneable 接口，这个接口指示一个类提供了一个安全的 clone 方法。(克隆并不太常见，可以稍作了解，等真正需要时再深入学习)。先来回忆为一个包含对象引用的变量建立副本时会发生什么。原变量和副本都是同一个对象的引用。这说明，任何一个变量改变都会影响另一个变量。 123Employee original = new Employee("John Public", 50000); Employee copy = original; copy.raiseSalary(10); 此时，改变 copy 的状态，就会改变 original 的状态。如果我们希望 copy 是一个新对象，它的初始状态与 original 相同，但是之后它们各自会有自己不同的状态，这种情况下就可以使用 clone 方法。 1234Employee original = new Employee("John Public", 50000); Employee copy =original.clone(); copy.raiseSalary(10); //此时 original 不会发生改变 不过并没有这么简单。clone 方法是 Object 的一个 protected 方法，如果我们使用从 Object 继承得到的 clone 方法，从 A 克隆出一个 B 的话，它们的域如果都是基本数据类型的话，那么是可以实现互不干涉的，但是假设它们的域中包含引用对象，那么 A 和 B 的引用对象域仍然会存在共享的情况。这种默认的 clone 操作叫做浅拷贝，存在缺陷。不过，通常子对象都是可变的，必须重新定义 clone 方法来建立一个深拷贝，同时克隆所有子对象。对于一个类需要确定： 默认的 clone 方法是否满足要求； 是否可以在可变的子对象上调用 clone 来修补默认的 clone 方法； 是否不该使用 Clone。如果选择第 1 项或第 2 项，类必须： 实现 Cloneable 接口 重新定义 clone 方法，并指定 public 修饰符。Cloneable 接口是 Java 提供的一组标记接口 (tagging interface) 之一。也可以称为记号接口 (marker interface)。 即使 clone 的浅拷贝用法也能够满足要求，还是需要实现 Cloneable 接口，将 clone 重新定义为 public，再调用 super.clone()。下面是个例子。 123456class Employee implements Cloneable&#123;@Override public Employee clone() throws CloneNotSupportedException &#123; return (Employee) super.clone(); &#125; &#125; 下面来看一个深拷贝的 clone 方法的例子： 123456@Overridepublic CloneTest clone() throws CloneNotSupportedException &#123; CloneTest copy = (CloneTest) super.clone(); copy.mEmployee = mEmployee.clone(); return copy;&#125; 另外，所有数组类型都有一个 public 的 clone 方法，而不是 protected。可以用这个方法建立一个新数组，包含原数组所有元素的副本，例如： 123int[] luckyNumbers= &#123;2,3,5,7,11,13&#125;int[] cloned = luckyNumbers.clone();cloned[5] = 12; //不会改变 luckyNumbers[5] 的数值 6.3 lambda 表达式了解如何使用 lambda 表达式采用一种简洁的语法定义代码块，以及如何编写处理 lambda 表达式的代码。 6.3.1 为什么引入lambda表达式lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。在 Java 中，不能直接传递代码块。必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。lambda 的设计，是为了解决 Java 如何做到函数式编程。 6.3.2 lambda 表达式的语法(String first, String second) -&gt; first.length() - second.length()参数，箭头 → 以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 {} 中，并包含显式的 return 语句。例如： 123456(String first, String second) -&gt;&#123; if(first.length() &lt; second.length()) return -1; else if(first.length() &gt; second.length()) return 1; else return 0;&#125; 即使 lambda 表达式没有参数，仍然要提供空括号，就像无参数方法一样 1() -&gt; &#123;for (int i=100;i&gt;=0;i--) System.out.println(i);``&#125; 如果可以推导出一个 lambda 表达式的参数类型，则可以忽略其类型。例如： 1Comparator&lt;String&gt; comp = (first, second) -&gt;first.length() - second.length(); 在这里，编译器可以推导出 first 和 second 必然是字符串，因为这个 lambda 表达式将赋给一个字符串比较器。如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号； 1ActionListener listener = event -&gt; System.out.println(&quot;The time is&quot; +new Date()&quot;); 无需指定 lambda 表达式的返回类型。lambda 表达式的返回类型总是由上下文推导得出。(String first, String second) -&gt; first.length() - second.length()，可以在需要 int 类型结果的上下文中使用。 1234567891011public static void main(String[] args) &#123; String[] planets = new String[] &#123; "Mercury", "Venus", "Earth", "Jupiter", "Saturn", "Uranus", "Neptune" &#125;; System.out.println(Arrays.toString(planets)); System.out.println("Sorted in dictionary order:"); Arrays.sort(planets); System.out.println(Arrays.toString(planets)); System.out.println("Sorted by length"); Arrays.sort(planets, (first, second) -&gt; first.length() - second.length()); System.out.println(Arrays.toString(planets)); &#125; 6.3.3 函数式接口对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式。这种接口称为函数式接口 (functionnal interface)。最好把 lambda 表达式看作是一个函数，而不是一个对象，另外要接受 lambda表达式可以传递到函数式接口。lambda 表达式可以转换为接口，这一点让 lambda 表达式很有吸引力。 12//这是将 lambda 转换为函数式接口的例子BiFunction&lt;String, Integer, Boolean&gt; comp = (name, age) -&gt; name.length() &gt; age; ArrayList 类有一个 removeIf 方法，它的参数就是一个 Predicate。public interface Predicate&lt;T&gt; {boolean test(T t);}，这也是一个函数式接口，所以我们可以使用 lambda。 1234567891011121314ArrayList&lt;String&gt; a = new ArrayList&lt;&gt;(); a.add(null); a.add(null); a.add(null); a.add(null); a.add("dsada"); a.add("czxzd"); a.add("gadga"); a.add("zcbzc"); a.removeIf(e -&gt; e == null); for (int i = 0; i &lt; a.size(); i++) &#123; System.out.println(a.get(i)); &#125; //Predicate 的泛型是根据 ArrayList 的泛型的，这里的代码就是将 ArrayList 中的 null 值都删除了。 6.3.4 方法引用有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。Timer t = new Timer(10000,System.out::println), 等价于 x -&gt; System.out.println(x)再来看一个例子，假设你想对字符串排序，而不考虑字母的大小写。可以传递以下方法表达式：Arrays.sort(strings,String::compareToIgonreCase)从这些例子可以看出，要用 :: 操作符分隔方法名与对象或类名。主要有 3 种情况： object::instanceMethod Class::staticMethod Class::instanceMethod在前 2 种情况种，方法引用等价于提供方法参数的 lambda 表达式。前面已经提到，System.out::println 等价于 x -&gt; System.out.println(x)。类似地，Math::pow 等价于 (x,y) -&gt;Math.pow(x,y)。对于第 3 种情况，第 1 个参数会成为方法的目标。例如，String::compareToIgnoreCase 等同于 (x,y) -&gt; x.compareToIgnoreCase(y)。可以在方法引用中使用 this 参数。例如，this::equals 等同于 x-&gt; this.equals(x)。使用 super 也是合法的。下面的方法表达式super:instanceMethod 6.3.5 构造器引用构造器引用与方法引用很类似，只不过方法名为 new。例如，Person::new 是 Person 构造器的一个引用。哪一个构造器呢？这取决于上下文。 12345678public static void main(String[] args) &#123; ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); Stream&lt;Person&gt; stream = names.stream().map(Person::new); &#125;&#125;class Person &#123; Person(String name) &#123; 重点是 map 方法会为各个列表元素调用 Person(String) 构造器。可以用数组类型建立构造器引用。例如，int[]::new 是一个构造器引用，它有一个参数：即数组的长度。这等价于 lambda 表达式 x -&gt; new int[x]。 123456@FunctionalInterface interface Fuck &#123; int[] createIntegerArray(int length);&#125;public static void main(String[] args) &#123; Fuck fuck = int[]::new; &#125; Java 有一个限制，无法构造泛型类型 T 的数组。数组构造器引用对于客服这个限制很有用。表达式 new T[n] 会产生错误，因为这会改为 new Object[n]。不过 toArray 有一个重载方法，引用一个函数式接口，解决了这个问题。 1&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; var1); 6.3.6 变量作用域通常，你可能希望能够在 lambda 表达式中访问外围方法或类中的变量。 12345public static void repeatMessage(String test, int delay) &#123; ActionListener listener = event -&gt; System.out.println(test);//这里只是实现了接口的方法而已，并没有马上调用 test = "Change";//当我们改变test值的时候，编译器会报错 &#125; Variable used in lambda expression should be final or effectively final lambda 表达式有 3 个部分： 一个代码块 参数 自由变量的值，这是指非参数而且不在代码中定义的变量。在我们的代码中，lambda 有 1 个自由变量 test。表示lambda的数据结构必须存储自由变量的值。在这里就是字符串 test。我们说它被 lambda 捕获 (captured)。例如，可以把一个 lambda 转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中。关于代码块以及自由变量值有一个术语：闭包 (closure)，在 Java 中，lambda 表达式就是闭包。在 lambda 中，只能引用值不会改变的变量，也不能在 lambda 中改变自由变量的值。在一个 lambda 中使用 this 关键字时，是指创建这个 lambda 的方法的 this 参数。 12345678910public class Application()&#123; public void init() &#123; ActionListener listener = event -&gt; &#123; System.out.println(this.toString()); &#125; &#125;&#125; 这里会调用 Application 对象的 toString 方法，而不是 ActionListener 实例的方法。 6.3.7 处理 lambda 表达式下面来看如何编写方法处理 lambda 表达式。使用 lambda 的重点是延迟执行 (deferred execution)。之所以希望以后再执行代码，这有很多原因 在一个单独的线程中运行代码 多次运行代码 在算法适当位置运行代码 发生某种情况执行代码，点击了一个按钮，数据到达，等等 只在必要时才运行代码可以为你自己设计的函数式接口打上 @FunctionalInterface 标记。 6.4 内部类内部类 (inner class) 是定义在另一个类中的类，为什么要使用内部类呢？ 内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据。 内部类可以对同一个包中的其他类隐藏起来 当想要定义一个回调函数且不想编写大量代码时，使用匿名 (anonymous) 内部类比较便捷。 6.4.1 使用内部类访问对象状态1234567891011121314151617181920public class TalkingClock &#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) &#123; this.interval = interval; this.beep = beep; &#125; public void start() &#123; &#125; public class TimePrinter implements ActionListener &#123; String name; @Override public void actionPerformed(ActionEvent actionEvent) &#123; &#125; &#125;&#125; 需要注意，这里的 TimePrinter 类位于 TalkingClock 类内部。这并不意味着每个 TalkingClock 都有一个 TimePrinter 实例域。TimePrinter 是内部类，内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。这个引用在内部类的定义中是不可见的，我们可以将外围类对象的引用假想为 outer，那么当我们在 TimePrinter 类中使用 beep 变量时，与 outer.beep 是等价的。 6.4.2 内部类的特殊语法规则OuterClass.this 表示外部类引用。例如：TalkingClock.this.beep反过来，可以采用下列语法格式更加明确地编写内部对象的构造器ActionListener listener = this.new TimePrinter();如果 TimePrinter 是一个公有内部类，我们就可以在任何地方创建内部类的对象。 123TalkingClock clock = new TalkingClock(1000, true); clock.start(); TalkingClock.TimePrinter a = clock.new TimePrinter(); 在外部类的作用域之外，可以这样引用内部类：OuterClass.InnerClass。 6.4.3 内部类是否有用，必要和安全内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $ 分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。 6.4.4 局部内部类如果仔细阅读以下之前的实例代码会发现，TimePrinter 这个类名字只在 start 方法中创建这个类型的对象时使用了一次。当遇到这类情况时，可以在一个方法中定义局部类。 1234567891011public void start() &#123; class TimePrinter implements ActionListener &#123; String name; @Override public void actionPerformed(ActionEvent actionEvent) &#123; System.out.println("At the tone, the time is" + new Date()); if (beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125; &#125; 局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。局部类有一个优势，对外部世界可以完全地隐藏起来。 6.4.5 由外部方法访问变量局部类不仅能够访问包含它们的外部类，还可以访问局部变量，不过那些局部变量必须事实上为 final。 6.4.6 匿名内部类假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类 (anonymous inner class)。通用的语法格式为： 1234new SuperType(construction parameters)&#123; inner class methods and date&#125; 还可以这样构造一个数组列表 1init(new ArrayList&lt;String&gt;() &#123;&#123;add(&quot;Harry&quot;);add(&quot;Tony&quot;);&#125;&#125;); 6.4.7 静态内部类有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并需要内部类引用外部类对象，为此，可以将内部类声明为 static，以便取消产生的引用。 6.5 代理proxy，利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才由必要使用。 6.5.1 何时使用代理假设由一个表示接口的 Class 对象，它的确切类型在编译时无法指定，要想构造一个实现这些接口的类，就需要使用 newInstance 方法或反射找出这个类的构造器。但是，不能实例化一个接口，需要在程序处于运行状态时定义一个新类。代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有下列方法： 指定接口所需要的全部方法 Object 类中的全部方法，例如，toString、equals 等。然而，不能在运行时定义这些方法的新代码，而是要提供一个调用处理器 (invocation handler)。是实现了 InvocationHandler 接口的类对象。在这个接口中只有一个方法：Object invoke(Object proxy,Method method, Object[] args) 6.5.2 创建代理对象要想创建一个代理对象，需要使用 Proxy 类的 newProxyInstance 方法。这个方法需要三个参数。 一个类加载器 一个 Class 对象数组，每个元素都是需要实现的接口 一个调用处理器 123456789101112131415161718192021222324252627282930313233343536public class ProxyTest &#123; public static void main(String[] args) &#123; Object[] elements = new Object[1000]; for (int i = 0; i &lt; elements.length; i++) &#123; Integer value = i + 1; InvocationHandler handler = new TraceHandler(value); Object proxy = Proxy.newProxyInstance(null, new Class[] &#123; Comparable.class &#125;, handler); elements[i] = proxy; &#125; Integer key = new Random().nextInt(elements.length) + 1; int result = Arrays.binarySearch(elements,key); if(result&gt;=0)System.out.println(elements[result]); &#125;&#125;class TraceHandler implements InvocationHandler &#123; private Object target; public TraceHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; System.out.print(target); System.out.print(&quot;.&quot; + method.getName() + &quot;(&quot;); if (objects != null) &#123; for (int i = 0; i &lt; objects.length; i++) &#123; System.out.print(objects[i]); if (i &lt; objects.length - 1) System.out.print(&quot;,&quot;); &#125; &#125; System.out.println(&quot;)&quot;); return method.invoke(target, objects); &#125;&#125; 总结 接口有三个主要作用：①定义 / 描述统一的的业务方法规范，作为参数，传递实现类给别人调用；②自己默认实现好逻辑交给他人备用，在该回调的时候触发回调；③作为标签接口，标注某一种类型，如 Serializable、Cloneable 等。 接口中的所有实例域属于 public static final 的，所有方法属于 public 的，不能含有实例域。接口和抽象类的本质区别是接口是为了描述一组行为，抽象类是实现，可作为父类完成一部分统一功能，可变部分交给子类去实现。 Java8 中允许接口含有静态方法。default 关键字提供默认方法，提供默认方法后实现类就可以不用全实现每个方法，可以复写该实现的方法。 方法冲突时两个原则：①超类和接口的默认方法冲突时，始终超类优先；②两个接口的默认方法冲突时，只要有其中任一个方法被默认实现了，子类就要选择性复写该方法 (Person.super.getName())，会影响到每个接口。 对象的拷贝：引用赋值指创建一个栈内存引用，指向一个堆内存实际对象，然后另一个引用也指向这个堆内存，那么修改堆内存的对象对两个引用都是有影响的；拷贝是指完全克隆出一个独立的堆内存对象，这样修改旧不影响两个引用了。• 浅拷贝：对象的基本数据类型可以拷贝，但是子引用类型没有被拷贝，还是同一个引用，两个引用还是会共享一些信息，修改时会影响两个引用。• 深拷贝：对象的基本数据类型和引用数据类型都被拷贝，改变 clone 对象的值不会影响原对象。 对象的克隆：• Object 的clone()方法是 protected 的，默认是浅拷贝，返回 Object。如果对象想实现克隆，需要实现 Cloneable 接口和重写 clone() 方法，指定为 public，且手动实现深拷贝，创建所有子引用类型并返回。• Cloneable 只是一个标记接口，没有任何方法，实现它只是为了标记一下该类具有克隆能力，instanceof可以通过。实现深拷贝的话该类和类中的引用类型都要实现 Cloneable 接口。• 即使clone()的默认浅拷贝可以实现需求，也得重写改为 public 才能调用，一般可以先super.clone()拿到原父类返回的浅拷贝引用，再重定义对象里每个引用变量的值 (实现深拷贝)，并返回这个克隆对象。ps：使用 Gson 序列化反序列化也能实现克隆功能。 lambda 表达式：• lambda 表达式是一个可传递的代码块，可以在以后反复执行一次或多次，用于代替只有一个方法的接口。表现形式：参数，箭头(-&gt;)以及一个表达式。(没有参数要提供空 ()，只有一个参数可不带 ()，表达式多行可用 {}，不用指定返回类型)• lambda 表达式中不能只在一个分支返回值而在其他分支不返回。lambda 表达式中引用的外部自由变量的值必须是不可改变的。lambda 表达式中 this 关键字指的是外围原对象 this。• lambda 表达式表现的就是一个函数式接口，但 Java 是不能直接传递方法的引用的，其实还是封装了一层，内部应该也是传递对象的引用。 方法的引用：&quot;::&quot;操作符分割对象或类名与方法名，如Class::Method/object::Method。构造器引用如Class::new。 内部类：• 定义：表示一种类之间的嵌套关系，而不是对象。解决命名控制和访问控制问题。内有内部类可以是私有的，外部类必须是包可见性或共有的。• 构造方式：Outer.inner in = new Outer.inner()或Outer.inner = outer.new Inner()。• 特点：可以访问自身数据域，也可访问外围数据域；内部类中所有静态域必须是 final 类型的；内部类初始化时都会包含一个外部类的隐式引用，以便访问外部类的域和方法，因此说内部类会持有外部类的引用。• 由于内部类会持有外部类的引用，因此在 Activity 中一般定义 Handler 的时候，如果进行耗时操作，handler 中持有外部 Activity，且 Handler 不会被销毁，这就可能会引起内存泄露 (Act 该销毁却没被销毁)。• 特殊：局部内部类是定义在方法中的，不能有任何修饰符，对外部世界完全隐藏，访问的外部类实例域必须是 final 的 (匿名内部类也是)。• 匿名内部类多用于传递方法参数中的接口，无构造方法，需要在后面加 {}内实现内部需要实现的方法。ArrayList 的双括号初始化 {{ }} 可构造出有初始化数据的 List。• 静态内部类不需要引用外围类对象，将内部类声明为 static，可以取消产生的引用。如果内部类不需要访问外围类的实例域，最好声明为静态内部类。静态内部类可以有静态域和方法。 动态代理 (proxy)：• 定义：可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用，代理类可以在运行时创建全新的类。• 作用：代理的作用的是中间层，代理的是接口、方法，而不是对象，对于原本的对象和原方法的实现逻辑是可有可无的。代理的 invocationHandler 拿到方法后可以自己做逻辑处理，因此代理就是一个使用过程中的中间层替换作用。• 应用场景：①只有接口，没有实现类时 (编译期还不知道要怎么实现) 时，使用代理可以动态创建出这些接口的实现类，在每个接口方法被调用时，动态去实现相应的业务逻辑。如 Retrofit 中对 Api 类的解析。②如果某个接口已经有实现类，并在工厂方法中返回了该实现类，如果需要对原本的实现逻辑前后加一些自己的业务逻辑，可以在工厂方法中 Proxy.newInsrance 创建代理类，实现自己新增的一些逻辑后将代理类返回，这时候可以把原来的类作为参数传入 invocationHandler，原本的处理逻辑还是用原来的类去执行的。③我们可以模仿 Retrofit，定义业务接口，通过注解添加各种动态业务条件，然后在代理类invoke()中分析方法并做各种动态处理，提高了业务逻辑的灵活性。• 使用：Proxy.newInstance(Classloader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)。InvocationHandler 中的invoke()方法会统一所有接口方法的调用回调，在此能拿到 method 以及参数 args，可以做自己对方法的实现逻辑。如果需要用到原对象和实现逻辑，可以把原对象也传进来。• 特点：①代理类一旦被创建就和普通类没啥区别了；代理类本身只有一个实例域——调用处理器，因此任何附加数据和原对象实例都要传到调用处理器中去使用。②代理类一定是 public 和 final，可以用 isProxyClass() 方法检测一个特定的 Class 对象是否代表一个代理类。重点：P225 对象的克隆 P258 代理 注意：代理与反射的区别是，反射构建对象时已经有该类的，只是动态去创建一个已存在类的实例；而代理是针对接口的，编译时还没该接口的具体实现类，因此动态去构建实现类和方法的实现逻辑，所有接口方法的分析都做好了放到 invoke 里的 method 里了，相当于在方法调用处加了统一的监听。 参考：https://www.jianshu.com/p/559d35944079https://www.kancloud.cn/zhangzihao/read-java-core/352483]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第5章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-2%2F</url>
    <content type="text"><![CDATA[第五章：继承（inheritance）利用继承，我们可以基于已存在的类构造一个新类。本章还会介绍反射 (reflection) 的概念，反射是指在程序运行期间发现更多的类及其属性的能力。 5.1 类、超类和子类继承主要是为了重用代码，也表明了 is-a 的关系。 5.1.1 定义子类关键字 extends 表示继承。 1234public class Manager extends Employee&#123;&#125; 可以用下面几个单词来表示父类和子类 父类：superclass、base class、parent class 子类：subclass、derived class、childclass在 Java 中，子类的功能往往比父类的功能强大。应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。 5.1.2 覆盖方法当子类从父类继承得到的方法，并不适用于子类的时候，就需要使用覆盖 (override)。super 关键字可以帮助我们在子类中调用父类的方法 (因为父类的方法会被继承，而我们将继承的方法重写了，这时候方法名是相同，但执行的代码不同，所以需要用到 super)，如 super.doSomething()。在覆盖一个方法的时候，子类方法不能低于父类方法的可见性。 5.1.3 子类构造器当调用子类构造器时，如果没有显式地使用 super(name,salary,year,month) 来执行父类的构造器，那么就会隐式地调用父类无参的构造器。使用 super 调用构造器的语句必须是子类构造器的第一条语句。一个对象变量可以指示多种实际类型的现象被称为多态 (polymorphism)。在运行时能够自动地选择调用哪个方法的现象称为 动态绑定 (dynamic binding)。 5.1.4 继承层次一个父类可以有多个子类，但一个子类只能继承一个父类。 5.1.5 多态多态的特性表明程序中出现父类对象的任何地方都可以用子类对象置换。但反过来是不行的。 5.1.7 阻止继承：final 类和方法有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。类中特定的方法也可以被声明为 final。如果这样做，子类就不能 override 这个方法。(final 类中的所有方法自动地成为 final 方法，不过全局变量是不会变成 final 的)。将方法或类声明为 final 的主要目的是：确保它们不会在子类中改变语义，例如一个变量是 String 对象的引用，那么它一定是一个 String 对象，而不可能是其他类的对象。 5.1.8 强制类型转换将一个类型强制转换成另外一个类型的过程被称为类型转换。将一个子类的引用赋值给一个父类的变量，编译器是允许的。但将一个父类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查。我们可以通过 instanceof 来检查。 5.1.9 抽象类为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的，除了抽象方法之外，抽象类还可以包含具体数据和具体方法。例如 Person 类还保存着姓名和一个返回姓名的具体方法。 1234567891011121314public abstract class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; //抽象方法 public abstract String getDescription(); //普通方法 public String getName() &#123; return name; &#125;&#125; extends 抽象类有两种方法： 在抽象类中定义部分抽象方法或不定义抽象方法，这样必须将子类也标记为抽象类 定义全部的抽象方法，这样一来，子类就不是抽象的了。抽象类不能被实例化。但是可以创建一个具体子类的对象。Person p = new Student(&quot;Bob&quot;,&quot;CS&quot;); 5.1.10 受保护访问大家都指定，最好将类中的全局变量标记为 private，而方法标记为 public。然而，有些时候，人们希望父类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为 protected。下面归纳一下 Java 用于控制可见性的 4 个访问修饰符： 仅对本类可见：private 对所有类可见：public 对本包和所有子类可见：protected 对本包可见：default 不需要修饰符 5.2 Object 所有类的超类在 Java 中，每个类都是由它扩展而来的，但是并不需要这样写：public class Employee extends Object如果没有明确地指出超类，Object 就被认为是这个类的超类。在 Java 中，只有基本类型 (primitive types) 不是对象。例如数值、字符和布尔类型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都 extends Object。 1234int a = 1; int[] staff = new int[10]; Object obj2 = a;//其实是将 int 先自动转换为 Integer，然后才成功赋值的。 Object obj = staff; 5.2.1 equals 方法Object 中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用，如果具有，则相等，然而对于大多数类来说，这样的比较不是很有意义，比如两个 Person 类，当我们进行 equlas 的时候，我们希望比较它们的状态，比如姓名，薪水等。我们可以 override 从 Object 继承得到的 equals 方法。 12345678public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return name.equals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.equals(other.hireDay); &#125; //这样写是有漏洞的，因为 name 和 hireDay 是String 类型，可能为null，如果为null，调用equals方法的话就会崩溃，我们可以利用 Object.equals 方法改写。 Object.equals 的另一个 overload 形式是：Object.equals(Object a,Object b) 如果两个参数都为 null，方法将返回 true。如果其中一个参数为 null，则返回 false；否则，如果两个参数都不为 null，则调用 a.equals(b)。利用这个方法，我们可以进行改写。 1return Object.equlas(name,other.name)&amp;&amp;salary==other.salary&amp;&amp;Object.equlas(hireDay,other.hireDay); 5.2.2 相等测试与继承如果隐式和显式的参数不属于同一个类，那么 euqals 方法将如何处理呢？在前面的例子中，如果发现 类不匹配，equals 方法就返回 false。但是许多程序员喜欢使用 instanceof 检测：if(!(otherObject instanceof Employee)) return false;，这是不推荐的写法。Java 要求 equal 方法具有下面的特性： 自反性：对于任何非空引用 x，x.equals(x) 应该返回 true。 对称性：对于任何引用 x 和 y，当且仅当 y.equals(x) 返回 true，x.equals(y) 也应该返回 true 传递性：对于任何引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，x.equals(z) 也应该返回 true。 一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。 对于任意非空引用 x，x.equals(null) 应该返回 false。如果子类能够拥有自己的相等概念，则对称性需要将强制采用 getClass 进行检测。如果由父类决定相等概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。 下面给出编写一个完美的 equals 方法的建议： 显式参数命名为 otherObject，稍后需要将它转换成另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象 if(this == otherObject) return true 检测 otherObject 是否为 null，如果为 null，返回 false。这项检测是很必要的。if (otherObject ==nul )return false; 可选 getClass 或 instanceof 将 otherObject 转换为相应的类类型变量：ClassName other = (ClassName) otherObject 开始比较全局变量。对于数组类型的域，可以使用静态的 Arrays.equals 方法检测相应的数组元素是否相等。 5.2.3 hashCode 方法散列码 (hash code) 是由对象导出的一个整型值。散列码没有规律。如果 x 和 y 是两个不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。如果重新定义 equals 方法，就必须重新定义 hashCode 方法，以便用户可以将对象插入到散列表中。hashCode 方法应该返回一个 int 值 (也可以是附属)，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。 12345public class Employee&#123; public int hashCode()&#123; return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode() &#125;&#125; 下面我们还可以优化一下，使用 Objects.hashCode 方法为对象计算 hash 值，避免空指针。使用基本数据类型对象的静态方法来避免创建多余的对象。 123456public int hashCode()&#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);&#125; 还有更好的写法return Objects.hash(name,salary,hireDay)Equals 和 hashCode 的定义必须一致，如果 x.equals(y) 返回 true，那么 x.hashCode() 就必须与 y.hashCode() 具有相同的值。如果存在数组类型的变量，可以使用静态的 Arrays.hashCode 方法计算一个 hashCode 值，这个散列码由数组元素的散列码组成。Objects API： int hashCode() static int hash(Object… objects) static int hashCode(Object a)，如果为 null 返回 0基本数据类型的对象，Integer|Double… static int hashCode()Arrays API static int hashCode(type[] a) 5.2.4 toString 方法Object 中还有一个重要的方法，就是 toString 方法，它用于返回表示对象值的字符串。一般的格式是：类的名字，随后是一对方括号括起来的域值。下面是 Employee 类中的 toString 方法的实现，我们可以调用 getClass().getName() 获得类名的字符串，而不是将类名硬加到 toString 方法中。 12345678public String toString()&#123; return getClass().getName() + &quot;[name=&quot; + name + &quot;,salary=&quot; + salary + &quot;,hireDay=&quot;+ hireDay + &quot;]&quot;;&#125; Object 类的 toString 方法则是打印类名 + hashCode 值。数组就是继承了 Object.toString 方法，所以如果想获取数组的元素，则可以使用 Arrays.toString；多维数组使用 Arrays.deepToString。 Object &amp;&amp; Class API Object: Class getClass() 返回包含对象信息的类对象 boolean equals(Object otherObject) String toString() Class String getName() 返回这个类的名字 Class getSuperclass() 以 Class 对象的形式返回这个类的超类信息 5.3 泛型数组列表ArrayList 是一个典型的数组列表，如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用 ensureCapacity 方法：staff.ensureCapacity(100)，另外，还可以把初始容量传递给 ArrayList 构造器 ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100)，size 方法将返回数组列表中包含的实际元素数目。例如：staff.size()，一旦能够确认数组列表的大小不再发生变化，就可以调用 trimToSize 方法，这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数量。垃圾回收器将回收多余的存储空间。 5.3.1 访问数组列表元素使用 get 和 set 方法实现访问或改变数组元素的操作，而不使用人们喜欢 [] 语法格式。staff.set(i,harry)使用 add 方法为数组添加新元素，而不要使用 set 方法，它只能替换数组中已经存在的元素内容。下面这个技巧可以一举二得，既可以灵活地扩展数组，又可以方便地访问数组元素。首先，创建一个数组，并添加所有的元素。 123456ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;();while(...)&#123; x = ...; list.add(x);&#125; 执行完上述操作之后，使用 toArray 方法将数组元素拷贝到一个数组中。 12X[] a = new X[list.size()];list.toArray(a); 除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素，使用带索引参数的 add 方法。同样地，也可以从数组列表中间删除一个元素。 123456//addint n = staff.size()/ 2staff.add(n,e);//removeEmployee e = staff.remove(n); 为了插入一个新元素，位于 n 之后的所有元素都要向后移动一个位置。如果删除，位于这个位置之后的所有元素都要向前移动一个位置，并且数组大小减 1。所以对于数组实施插入和删除元素的操作其效率比较低。如果元素数过多，且经常需要在中间位置插入、删除元素，就应该考虑使用链表了。可以使用 for each 循环遍历数组列表。 5.3.2 类型化与原始数组列表的兼容性在确保安全的情况下，可以使用 @SuppressWarnings(&quot;unchecked&quot;) 标记这个变量能够接收类型转换。 5.4 对象包装器与自动装箱有时，需要将 int 这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。这些类称为 包装器 (wrapper) (如 Integer - int)。wrapper 是不可变的，一旦构造了 wrapper，就不允许更改包装在其中的值。同时 wrapper 是 final 修饰的，不能定义它们的子类。int 是无法作为泛型参数的，所以我们可以使用 ArrayList&lt;Integer&gt;。幸运的是，有一个很有用的特性，例如 123456list.add(3)//这行代码将会自动变换成list.add(Integer.valueOf(3)); //这种变化被称为 autoboxing//相对的，也有一种情况叫自动拆箱int n = list.get(i);//这行代码将会自动变换成int n = list.get(i).intValue() 一般我们要比较 wrapper 对象的时候，习惯用 equals ，不过 autoboxing 规范要求：boolean、byte、char &lt;=127，介于 -128 ~ 127 之间的 shore 和 int 被包装到固定的对象中，所以下面代码： 1234567Integer a= 100;Integer b = 100;System.out.println(a==b) //trueInteger a= 200;Integer b = 200;System.out.println(a==b) //false Integer API int intValue() static String toString(int i) static String toString(int i, int radix) static int parseInt(String s) static int parseInt(String s,int radix) static Integer valueOf(String s) static Integer valueOf(String s,int radix) NumberFormat Number parse(String s) 5.5 参数可变的方法现在的 Java 版本提供了可以用可变的参数数量调用的方法 (有时称为 “变参” 方法)。具体的形式如下 12345678public static double max(double.. values)&#123; double largest = Double.NEGATIVE_INFINITY; for (double v : values) if (v &gt; largest) largest = v; return largest;&#125;//其过程就向给 max 方法传入了一个数组， 5.6 枚举类public enum Size {SMALL, MEDIUM,LARGE,EXTRA_LARGE};实际上，这个声明定义的类型是一个类，它刚好有 4 个实例，在此尽量不要构造新对象。因此，在比较两个枚举类型的值时，永远不需要调用 equals，而直接使用 “==” 就可以了。如果需要的话，可以在枚举类型中添加一些构造器，方法和域。当然，构造器只是在构造枚举常量的时候被调用。下面是一个实例： 12345678910111213public enum Size &#123; SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;), EXTRA_LARGE(&quot;XL&quot;); private String abbreviation; Size(String abbreviation) &#123; this.abbreviation = abbreviation; &#125; public String getAbbreviation() &#123; return abbreviation; &#125;&#125; 所有的枚举类型都是 Enum 类的子类。它们继承了这个类的许多方法。其中最有用的一个是 toString，这个方法能够返回枚举常量名。例如，Size.SMALL.toString() 将返回字符串 SMALL。toString 的逆方法是静态方法 valueOf。例如，语句：Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;);。每个枚举类型都有一个静态的 values 方法，它将返回一个包含全部枚举值的数组。例如：Size[] values = Size.values();，ordinal 方法返回 enum 声明中枚举常量的位置，位置从 0 开始计数。例如：Size.MEDIUM.ordinal() 返回 1。 static Enum valueOf(Class enumClass,String name) String toString() int ordinal() int compareTo(E other) // 如果枚举常量出现在 other 之前，则返回一个负值；如果 this==other，则返回 0；否则，返回正值。枚举常量的出现次序在 enum 声明中给出。 5.7 反射反射库 (reflection library) 提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。能够分析类能力的程序称为反射 (reflection)。反射机制可以用来： 在运行时分析类的能力。 在运行时查看对象，例如，编写一个 toString 方法供所有类使用。 实现通用的数组操作代码 利用 Method 对象。 5.7.1 Class 类在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。然而，可以通过专门的 Java 类访问这些信息。保存这些信息的类被称为 Class，Object 类中的 getClass() 方法将会返回一个 Class 类型的实例。获取到 Class 类型的实例后，可以使用 getName，这个方法将返回类的名字。如果类在一个包里，包的名字也作为类名的一部分： 123Person p = new Person(); Class clazz = p.getClass(); System.out.println(clazz.getName());//com.example.Person 还可以调用静态方法 forName 获得类名对应的 Class 对象 12Class clazz = Class.forName(&quot;com.example.Person&quot;);//这个方法会产生异常，需要除了 System.out.println(clazz.getName()); 获得 Class 类对象的第三种方法非常简单。如果 T 是任意的 Java 类型 (或 void 关键字),T.class 将代表匹配的类对象。例如： 1Class clazz = Person.class; 一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int 不是类，但 int.class 是一个 Class 类型的对象。虚拟机为每个类型管理一个 Class 对象。因此，可以使用 == 运算符实现两个类对象比较的操作。例如： 1234Person p = new Person(); if(Person.class==p.getClass())&#123; System.out.println(&quot;HelloWorld&quot;); &#125; 还有一个很有用的方法 newInstance()，可以用来动态地创建一个类的实例。例如： 12Person p = new Person();Person b = p.getClass().newInstance(); newInstance 方法调用默认的构造器 (空参的构造器) 初始化新创建的对象。如果这个类没有默认的构造器，就会抛出一个异常。如果需要创建的类提供参数，必须使用 Constructor 类中的 newInstance 方法。 123Constructor c =Person.class.getDeclaredConstructor(String.class,int.class); Person b = (Person)c.newInstance(&quot;张子浩&quot;,123); System.out.println(b.name); 5.7.2 捕获异常异常有两种类型：未检查异常和已检查异常。对于已检查异常，编译器将会检查是否提供了处理器。然而，有很多常见的异常，例如，访问 null 引用，都属于未检查异常。 5.7.3 利用反射分析类的能力下面介绍反射机制最重要的内容 - 检查类的结构在 java.lang.reflect 包中有三个类 Field、Method 和 Constructor 分别描述类的域、方法和构造器。这三个类都有一个叫做 getName 的方法，用来返回项目的名称。Field 类有一个 getType 方法，用来返回描述域所属类型的 Class 对象。Method 和 Constructor 类有能够报告参数类型的方法，Method 类还有一个可以报告返回类型的方法。这三个类还有一个叫 getModifiers 的方法，它将返回一个整型数值，用不同的位开关描述 public 和 static 这样的修饰符使用情况。另外，还可以利用 java.lang.reflect 包中的 Modifier 类的静态方法分析 getModifiers 返回的整型数值。例如，可以使用 Modifier 类中的 isPublic、isPrivate 或 isFinal 判断方法或构造器是否是 public、private 或 final。我们需要做的全部工作就是调用 Modifier 类的相应方法，并对返回的整型数值进行分析，另外，还可以利用 Modifier.toString 方法将修饰符打印出来。Class 类中的 getFields、getMethods 和 getConstructor 方法将分别返回类提供的 public 域、方法和构造器数组，其中包括父类的公有成员。Class 类的 getDeclaredFields、getDeclaredMethods 和 getDeclaredConstructors 分别返回类中声明的所有全局变量、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。下面的代码可以完整打印出一个类的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; Scanner in = new Scanner(System.in); System.out.println(&quot;Enter class name (e.g. java.util.Date):&quot;); name = in.next(); try &#123; Class cl = Class.forName(name); Class supercl = cl.getSuperclass(); String modifiers = Modifier.toString(cl.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.println(&quot;class &quot; + name); if (supercl != null &amp;&amp; supercl != Object.class) &#123; System.out.print(&quot; extends &quot; + supercl.getName()); &#125; System.out.print(&quot;\n&#123;\n&quot;); printConstructors(cl); System.out.println(); printMethods(cl); System.out.println(); printFields(cl); System.out.println(&quot;&#125;&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void printConstructors(Class cl) &#123; Constructor[] constructors = cl.getDeclaredConstructors(); for (Constructor c : constructors) &#123; String name = c.getName(); System.out.print(&quot; &quot;); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.print(name + &quot;(&quot;); Class[] parameterTypes = c.getParameterTypes(); for (int j = 0; j &lt; parameterTypes.length; j++) &#123; if (j &gt; 0) System.out.print(&quot;,&quot;); System.out.print(parameterTypes[j].getName()); &#125; System.out.println(&quot;);&quot;); &#125; &#125; public static void printMethods(Class cl) &#123; Method[] methods = cl.getDeclaredMethods(); for (Method m : methods) &#123; Class retType = m.getReturnType(); String name = m.getName(); System.out.print(&quot; &quot;); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;); Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) System.out.print(&quot; ,&quot;); System.out.print(paramTypes[j].getName()); &#125; System.out.println(&quot;);&quot;); &#125; &#125; public static void printFields(Class cl) &#123; Field[] fields = cl.getDeclaredFields(); for (Field f : fields) &#123; System.out.print(&quot; &quot;); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;); System.out.println(f.getName() + &quot; ;&quot;); &#125; &#125;&#125; Class&amp;Field&amp;Method&amp;Constructor&amp;Modifier API Class Field[] getFields() Field[] getDeclaredFields() Method[] getMethods() Method[] getDeclaredMethods() Constructor[] getConstructor() Constructor[] getDeclaredConstructor() Field &amp; Method &amp; Constructor Class getDeclaringClass() Class[] getExceptionTypes() Field 无这个方法 int getModifiers() String getName() Class[] getParameterTypes() Field 无这个方法 Class getReturnType() 只有在 Method 类中 Modifier static String toString(int modifiers) static boolean isAbstract(int modifiers) static boolean isFinal(int modifiers) static boolean isInterface(int modifiers) static boolean isNative(int modifiers) static boolean isPrivate(int modifiers) static boolean isProtected(int modifiers) static boolean isPublic(int modifiers) static boolean isStatic(int modifiers) static boolean isStrict(int modifiers) static boolean isSynchronized(int modifiers) static boolean isVolatile(int modifiers) 5.7.4 在运行时使用反射分析对象在编写程序时，如果知道想要查看的域名和类型，查看指定的域是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的对象域。 1234567Person p = new Person(&quot;bob&quot;); Class cl = p.getClass(); Field f = cl.getDeclaredField(&quot;name&quot;); f.setAccessible(true);//设置访问权限 f.set(p,&quot;zzzz&quot;);//可以将 p 的值进行替换 Object v = f.get(p);//可以获取 p 的值 System.out.println(v+&quot;&quot;); setAccessible 是 AccessibleObject 类中的一个方法，它是 Field、Method 和 Constructor 类的公共父类。 AccessibleObject &amp; Class &amp; Field API AccessibleObject void setAccessible(boolean flag) boolean isAccessible static void setAccessible(AccessibleObject[] array,boolean flag); Class Field getField(String name) Field[] getField() Field getDeclaredField(String name) Field[] getDeclaredFields() Field Object get(Object obj) void set(Object ob,Object newValue) 5.7.5 使用反射编写泛型数组代码java.lang.reflect 包中的 Array 类允许动态地创建数组。例如，将这个特性应用到 Array 类中的 copyOf 方法实现中。关于 Java 数组类型的转换：Java 数组会记住每个元素的类型，将一个 Employee[] 临时地转换成 Object[] 数组，然后再把它转换回来是可以的，但一个从开始就是 Object[] 数组却永远也不能转换成 Employee[] 数组。为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。 12345678910111213Employee[] a = new Employee[100]...//array is fulla = Arrays.copyOf(a,2*a.length);//正确的转换Class cl = a.getClass(); if (!cl.isArray()) return null; Class componentType = cl.getComponentType(); int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); return newArray; 5.7.6 调用任意方法反射机制允许你调用任意方法。Method 类中有一个 invoke 方法，它允许调用包装在当前 Method 对象中的方法。invoke 方法的形式是 Object invoke(Object obj,Object.. args)第一个参数是隐式参数，其余的对象提供了显式参数，对于静态方法，第一个参数可以被忽略，即可以将它设置为 null。获得 Method 对象的方法是 Method getMethod(String name, Class... parameterTypes)，下面是代码演示： 123456789101112131415161718192021222324252627public class CopyOfTest &#123; public static void main(String[] args) throws Exception &#123; Method square = CopyOfTest.class.getMethod("square", double.class); Method sqrt = Math.class.getMethod("sqrt", double.class); printTable(1,10,10,square); printTable(1,10,10,sqrt); &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from, double to, int n, Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for (double x = from; x &lt;= to; x += dx) &#123; try &#123; double y = (Double) f.invoke(null, x); System.out.printf("%10.4f | %10.4f%n", x, y); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 5.8 继承的设计技巧 将公共操作和域放在父类 不要使用受保护的域 使用继承实现 is-a 的关系 除非所有继承的方法都有意义，否则不要使用继承 在 override 方法时，不要改变预期的行为 使用多态，而非类型信息 不要过多地使用反射 总结： 总结： 反射：指在程序运行期间发现更多的类及其属性的能力。 super 不是一个对象的引用，不能将其赋给另一个对象变量，它只是一个指示编译器调用超类方法的关键字。构造方法中 super 语句必须放到第一行。 若子类构造器没有显示调用父类的构造器，则系统自动调用父类的无参构造器；若父类没有无参构造器 (有其他构造器)，子类也没显示调用父类其他构造器，则编译报错。 系统在运行时能自动选择调用哪个方法的现象称为动态绑定 (重写的调用 系统知道引用类型是谁就行)；编译时就能知道该调用那个方法称为静态绑定 (如 privite/static/final 方法)。 Java 中只能单继承，但是继承链可以是有多层。 可以将一个子类实例赋值给超类变量 (向下转型)；不能将一个超类实例直接赋值给子类变量 (需要强制类型转换)。 子类重写 (覆盖) 方法中，可见性不能低于超类，若是 final 方法将不能被重写(覆盖)，不想它们在子类中改变语义。 包含一个或多个 abstract 方法的类必须被声明为抽象类；抽象类可以有自己的实例域和方法，子类必须重写父类的所有抽象方法，否则自己还是个抽象类；抽象类不能被实例化，只能实例化为具体的自类。 Object 类是所有类的超类，可以用它引用任何类型的变量，Java 中只有基本数据类型不是对象。 equals()方法默认判断的是内存地址，在子类定义 equals 方法时，首先调用超类的 equals，如果失败直接返回 false，然后再逐一对比子类自己的每个实例域。如果重新定义equals()方法就必须重新定义hashCode()方法，保证 hashCode 相同则对象就相等，为了插入到散列表中的验证。 Objects.equals(a,b)方法可避免两个变量都为 null 引起的问题；Arrays.equals()方法可以检测两个数组是否相等 (已重写判断每位是否相等的逻辑，类似 String.equals())。 散列码 (hash code) 是由对象导出的一个整型值，是无规律的，每个对象的默认散列码是对象的存储地址。两个相等的对象要求返回相等的散列码(内存地址都一样了，指向同一个堆对象，所以可以用来判断对象相等)。 ArrayList 是一个泛型类，动态数组实现，动态查询时效率高，但是在中间插入和删除效率就不行了 (后面的所有元素都要做位移)，动态插入删除链表 LinkedList 效率高一些，只修改那个元素前后的指针即可。 Java 中所有基本数据类型都有一个与之对应的类称为包装器，一旦构造是不许更改的，在许多场景下可以自动装箱与拆箱。== 判断的是地址。装箱和拆箱是编译器认可的，而不是虚拟机。 反射：能够在运行时动态分析类的能力，构造类，调用类的方法的行为。可使用 Class 类的newInstance()方法来动态构造类，Method 的invoke()来动态调用方法。 Class 类：• 定义：在程序运行期间，Java 运行时系统始终为所有对象维护着一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类，虚拟机利用运行时类型信息来选择相应的方法执行。独立于对象，存储着类的各种信息 (构造器 / 域 / 方法)。• 获取方式：①Object.class(只能获取到该类的 class 不区分父类子类引用)②obj.getClass()(当前 obj 的 class 区分父类子类)③Class.forName(pkgClassName)(动态获取 class 可能不存在 反射一般用的多)• 使用方法：Class 的newInstance()方法调用默认的构造器 (无参构造器) 动态创建一个类的实例，如果这个类没有默认构造器，则必须使用 Constructor 类中的newInstance()中带参数的构造方法。• 特点：一个 Class 对象实际上表示的是一个类型，而这个类型未必是一种类。例如，int 不是类，int.class 是一个 Class 类型的对象。Class 类实际上是一个泛型类。虚拟机为每个类型管理一个 Class 对象，可用obj.getClass()==Object.class来比较。 反射相关类：• 在 java.lang.reflect 包中有三个常用类：Field、Method 和 Constructor 分别用于描述类的域、方法和构造器。它们包含了一系列方法来分析类的各种属性和能力。外加一个 Modifier 类判断修饰符用，AccessibleObject 三者公有的超类。• 以上三个类有着公有的超类，以及各自的一些方法。getFields()方法返回类及其父类的公有域；getDeclaredFields()方法返回类的全部域，不包括父类。• 如果 f 是一个 Field 类型的对象，obj 是某个包含 f 域的类的对象，f.get(obj) 将返回一个对象 (Object 类型 基本类型则返回包装器)，其值为 obj 域的当前值 (就类似拷贝一个域的对象而已)。• f.set(obj,value) 可以将 obj 对象的 f 域设置成新值。基本数据类型的域获取域使用如getDouble()方法返回包装器。 反射机制默认行为受限于 Java 的访问控制，可以调用setAccessible()方法来为反射对象设置可访问标志。setAccessible()其实是 AccessibleObject 中的方法，它是 Field、Method 和 Constructor 的公有超类。 ObjectAnalyzer 将记录已经被访问过的对象。如：new ObjectAnalyzer().toString(this)。 反射常用方法：• Class 的getMethod(String name,Class&lt;?&gt;... parameterTypes)方法返回一个 method 类 (可以传入 class… 也可传入 new Class[]{} 数组)；• Method 类中的invoke(Object o,Object... args)方法调用包装在当前 Method 对象中的方法 (可以传入 obj… 也可传入 new Object[]{} 数组)，如果返回类型是基本类型，invoke 方法返回其包装器类型；对于静态方法，可以把null作为隐式参数传入；显示参数没有的话也传 null。 程序中不要过多的使用反射，反射会影响性能，并且编译器很难发现程序错误，只有在运行时才会发现并导致异常。 反射创建数组：• java.lang.reflect 包中的 Array 类允许动态构建数组，Java 数组会记住每个元素的类型 (创建时指定)，可以将一个特定数组临时转为 Object[]，然后可以强转回来，如果一开始就是个 Object[]，则不能强转。• Array.newInstance(componentType,newLength) 方法动态创建数组，getComponentType()是 Class 的方法，getLength()是 Array 的方法。创建得到的是 Object 数组，可以强转回来。Arrays.copyOf()底层就是这么做的。 注意：int[] 可以转为 Object，而不能转为 Object[]。 重写、重载、覆盖、多态的区别：• 重写 (覆盖)：方法级别的概念；@Override，出现在子类中，方法名和参数类型完全相同，子类重新实现父类定义的函数；但是访问权限不能小于父类的，抛出的的异常也不能大于父类；静态方法不能被重写为非静态方法。• 重载：方法级别的概念；@Overload，出现在父类中，方法名相同，参数不同，类似多态的不同实现。不能通过访问权限、返回类型和抛出异常不同来重载。• 多态：类级别的概念；父类的引用 -&gt; 子类的实例，使得父类可以调用子类中更多的方法。继承是子类使用父类的方法，而多态是父类调用子类的方法。重点：P166 Object、equals 方法 P190 反射 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第4章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19-1%2F</url>
    <content type="text"><![CDATA[第四章：对象与类4.1 面向对象程序设计概述面向对象程序设计，简称 OOP。Java 是完全面向对象的，必须熟悉 OOP 才能够编写 Java 程序。 4.1.1 类class 是构造对象的模板或蓝图，由类构造 (construct) 对象的过程称为创建类的实例 (instance)。封装 (encapsulation，有时称为数据隐藏)，对象中的数据称为实例域 (instance field)，操作数据的过程称为方法 (method)。对于每个特定的类实例都有一组特定的实例域值。这些值的集合就是这个对象的当前状态 (state)。实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。OOP 的另一个原则就是可以通过扩展一个类来建立另外一个新的类，在 Java 中，所有的类都源自于 Object。通过扩展一个类来建立另外一个类的过程称为继承 (inheritance)。 4.1.2 对象对象的三个主要特性 对象的行为 (behavior)：可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态 (state)：当施加那些方法时，对象如何响应？ 对象标识 (identity)：如何辨别具有相同行为与状态的不同对象？ 4.1.3 识别类识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。 4.1.4 类之间的关系 依赖：uses-a 一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 聚合：has-a 一个类的对象包含另一个类的对象 继承：is-a 一个类是另一个类的子类或者父类，类之间进行了扩展。 4.2 使用预定义类Java 中没有类就不能做任何事情，然而，并不是所有的类都具有面向对象特征。例如 Math 类，在程序中，可以使用 Math 类的方法，只需要知道方法名和参数，而不必了解它的具体实现过程，这正是封装的关键所在，但是 Math 类只封装了功能，它不需要也不必隐藏数据，由于没有数据，因此也不必担心生成对象以及初始化实例域。 4.2.1 对象与对象变量要想使用对象，必须首先构造对象，并指定其初始状态。然后，对对象应用方法。在 Java 中，使用构造器 (constructor) 构造新实例，构造器是一种特殊的方法，用来构造并初始化对象。构造器的名字应该与类名相同，要想构造一个类的对象，需要在构造器前面加上 new 操作符。new Date()`System.out.println(new Date());String s = new Date().toString();在上述例子种，构造的对象仅使用了一次，如果希望多次使用，需要将对象存放在一个变量中。Date birthday = new Date();`一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。 4.2.2 Java 类库中的 LocalDate 类Date 类用来表示时间点，LocalDate 用来表示大家熟悉的日历表达法。LocalDate.now()// 2017-07-08还可以调用 LocalDate.of(1999,12,6) 方法来构造对应一个特定日期的对象。一旦有了一个 LocalDate 对象，可以使用方法 geetYear 、getMonthValue、getDayOfMonth得到年、月、日。下列的方法可以得到未来的日期或者过去的日期。 123LocalDate c = LocalDate.now();//c 是当前时间System.out.println(c.plusDays(1));//明天System.out.println(c.plusDays(-1));//昨天 4.2.2 更改器方法与访问器方法Java 库的一个较早版本曾经有另一个类来处理日历，名为 GregorianCalendar 与 c.plusDays(1) 不同，GregorianCalendar.add 方法与 plusDays 方法功能差不多，但是是一个更改器方法 (mutator method)。调用这个方法后，GregorianCalendar 对象的状态会改变。 1234GregorianCalendar c = new GregorianCalendar(1999,1,10);c.add(Calendar.YEAR, 1);int year = c.get(Calendar.YEAR);System.out.println(year); 相反，只访问对象而不修改对象的方法有时称为访问器方法 (accessor method)。例如 LocalDate.get 和 GregorianCalendar.get 。 下面的代码可以构建一个当月的日历。 1234567891011121314151617181920212223242526272829303132333435//带 * 号表示今天Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7 8* 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ------------------------------------LocalDate date = LocalDate.now(); int month = date.getMonthValue();// 7 int today = date.getDayOfMonth();// 8 date = date.minusDays(today - 1);// 返回到月初 DayOfWeek weekday = date.getDayOfWeek();// 得到星期几 int value = weekday.getValue();//得到月初的星期 System.out.println(&quot;Mon Tue Wed Thu Fri Sat Sun&quot;);//先打印好星期行 for (int i = 1; i &lt; value; i++) &#123;//控制 1 出现的位置 System.out.print(&quot; &quot;); &#125; while (date.getMonthValue() == month) &#123;// System.out.printf(&quot;%3d&quot;, date.getDayOfMonth());//打印1 if (date.getDayOfMonth() == today) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; System.out.print(&quot; &quot;); &#125; date = date.plusDays(1); if (date.getDayOfWeek().getValue() == 1) &#123; System.out.println(); &#125; &#125; LocalDate API LocalTime now() LocalTime of(int year, int month, int day) int getYear() int getMonthValue() int getDayOfMonth() DayOfWeek getDayOfWeek LocalDate plusDays(int n) LocalDate minusDays(int n) 4.3 用户自定义类要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有 main 方法。 4.3.1 Employee 类123456789101112class ClassName&#123; field; field; ... constructor1 constructor2 ... method1 method2 ...&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Demo01 &#123; public static void main(String[] args) throws Exception &#123; Employee[] staff = new Employee[3]; staff[0] = new Employee(&quot;Carl Cracker&quot;, 75000, 1987, 12, 15); staff[1] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1); staff[2] = new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15); for (Employee e : staff) &#123; e.raiseSalary(5); &#125; for(Employee e :staff)&#123; System.out.println(&quot;+e.getHireDay()); &#125; &#125;&#125;class Employee &#123; private String name; private double salary; private LocalDate hireDay; //constructor public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; // a method public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125;&#125; 当我们的 .java 文件包含 2 个类的时候，我们编译时可以采用这两种方法 12javac Employee*.java //可以使用通配符，所有与通配符匹配的源文件都将被编译成类文件javac Demo01.java //Java编译器会自动搜索使用的Employee类，并编译 4.3.4 从构造器开始1234567public Employee(String n, double s, int year, int month, int day)&#123; name = n ; salary = s; LocalDate hireDay = LocalDate.of(year,month,day);&#125;构造器与类同名，构造器与其他的方法有一个重要的不同。构造器总是伴随着 new 操作符的执行被调用，而不能对一个已经存在的对象调用 constructor 来达到重新设置实例域的目的，例如`james.Employee(&quot;James Bond&quot;,250000,1950,1,1)`//ERROR,会产生编译错误。 构造器的基本特点： 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有 0 个、1 个或多个参数 构造器没有返回值 构造器总是伴随着 new 操作一起调用 4.3.5 隐式参数与显式参数12345678public void raiseSalary(double byPercent)&#123; double raise = salary * byPercent / 100 salary +=raise; //salary的前面省略了参数， //完整的写法是 double raise = number007.salary * byPercent / 100 number007.salary +=raise;&#125; raiseSalary 有两个参数，第一个参数称为隐式参数 (implicit) 参数，是出现在方法名前的 Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式 (explicit) 参数。隐式参数也被称为方法调用的目标或接收者。在每个方法中，关键字 this 表示隐式参数。如果需要的话，可以用下列方式编写 raiseSalary 方法： 1234public void raiseSalary(double Percent)&#123; double raise = this.salary * byPercent / 100; salary +=raise;&#125; 4.3.6 封装的优点使用 public get 方法来代替 public name，将全局变量设置为 private 可以防止受到外界的破坏。注意：不要编写返回引用可变对象的 get 方法，因为它本身是可变的话，会破坏封装性，我们应该只能通过 set 方法来改变对象的状态，如果必须要这样做，那么我们可以使用 clone。 123456class Employee&#123; public Date getHireDay() &#123; return (Date) hireDay.clone(); &#125;&#125; 4.3.7 基于类的访问权限123public boolean equals(Employee other) &#123; return name.equals(other.name); &#125; 这段代码中 Employee 类的 name 变量是 private 修饰的，other.name 意味着我们访问了另一个对象的 private 属性，这与我们之前说的是对不起来的，其原因是： other 是 Employee 类对象，而 Employee 类的方法可以访问 Employee 类的任何一个对象的私有域。 4.3.8 私有方法有时，可能希望将一个计算代码划分为若干个独立的赋值方法。通常，这些辅助方法不应该成为公有接口的一部分，最好将这样的方法设计为 private。 4.3.9 final实例域构造对象时必须初始化这样的域，也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。如果将 final 用在一个可变对象上，那么 final 只表示该变量的对象引用不会更改，对象本身是可以更改的。 4.4 静态域与静态方法 static4.4.1 静态域如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。static 修饰的属性属于类，而不属于任何独立的对象。 4.4.2 静态常量静态变量用得比较少，但静态常量却使用得比较多。例如 Math.PI 123public class Math&#123; public static final double PI = 3.14159265358979323846;&#125; 这样做的好处就是，我们可以不需要构建 Math 的对象，直接通过 Math.PI 来进行访问，同时，设置为 fanal，避免了被修改的问题。 4.4.3 静态方法静态方法是一种不能向对象实施操作的方法，例如，Math 类的 pow 方法就是一个静态方法。Math.pow(x,a)，在运算时，不使用任何 Math 对象。换句话说，没有隐式的参数。可以认为静态方法是没有 this 参数的方法，这也说明了为什么静态方法无法调用非静态变量。在下面两种情况下使用静态方法： 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供，例如：Math.pow 一个方法只需要访问类的静态域，例如：Employee.getNextId 4.4.4 工厂方法静态方法还有另外一种常见的用途。类似 LocalDate 和 NumberFormat 的类使用静态工程方法 (factory method) 来构造对象。 12345NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(); NumberFormat percentFormatter = NumberFormat.getPercentInstance(); double x = 0.1; System.out.println(currencyFormatter.format(x)); // ￥0.10 System.out.println(percentFormatter.format(x)); // 10% 为什么 NumberFormat 不利用 构造器 来完成这些操作呢？ 无法命名构造器，构造器的名字必须要和类名一样，但是，这里希望将得到的货币实例和百分比实例采用不同的名字。 当使用构造器时，无法改变所构造的对象类型，而 Factory 方法将返回一个 DecimalFormat 类对象，这是 NumberFormat 的子类。 4.4.5 main 方法需要注意，不需要使用对象调用静态方法。例如，不需要构造 Math 类对象就可以调用 Math.pow。每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。例如，可以在 Employee 类中添加一个 main 方法，如果想要独立地测试 Employee 类，只需要执行 java Employee，如果 Employee 类是一个更大型应用程序的一部分，就可以使用下面这条语句运行程序 java Application，Employee 类的 main 方法永远不会执行。 4.5 方法参数按值调用 (call by value) 表示方法接收的是调用者提供的值。而按引用调用 (call by reference) 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。call by 是一个标准的计算机科学术语。Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。 1234567//假定一个方法：试图将参数值增加至3倍public static void tripleValue(double x)&#123; x = 3 * x ;&#125;double percent = 10;tripleValue(percent) 不过，并没有实现把参数增加到 3 倍。让我们一步步来细化： x 被初始化为 percent 值的一个拷贝 (也就是 10) x 被乘以 3 后等于 30，但是 percent 还是 10 这个方法结束之后，参数变量 x 不再使用然后，方法参数共有两种类型： 基本数据类型 (数字、布尔值) 对象引用下面这段代码实现了当对象引用作为参数的时候，方法修改了参数。 12345public static void tripleDSalary(Employee x)&#123; x.raiseSalary(200);&#125;harry = new Employee(...);tripleSalary(harry) 具体的执行过程是： x 被初始化为 harry 值的拷贝，这是一个对象的引用 raiseSalary 方法应用于这个对象引用。x 和 harry 同时引用的那个 Employee 对象的 salary 提高了 200% 方法结束后，参数变量 x 不再使用，当然，对象变量 harry 继续引用那个薪金增至 3 倍的雇员对象。下面总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数 (即数值型或布尔型) 一个方法可以改变一个对象参数的状态 一个方法不能让对象参数引用一个新的对象 4.6 对象构造由于对象构造非常重要，所以 Java 提供了多种编写构造器的机制。 4.6.1 重载有些类有多个 constructor，例如，可以如下构造一个空的 StringBuilder 对象。StringBuilder messages = new StringBuilder();或者，可以指定一个初始字符串：StringBuilder todoList = new StringBuilder(&quot;To do:\n&quot;);这种特征叫做重载 (overloading)。如果多个方法有相同的名字、不同的参数，便产生了 overload。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。要注意的是，重载与返回值无关，也就是说，不能有方法名相同，参数相同，返回值类型不相同的两个方法。 4.6.2 默认域初始化如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值；数值为 0、布尔值为 false、对象引用为 null。 1这是全局变量与局部变量的主要不同点。必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的全局变量，将会被自动初始化为默认值 (0、false或null)。 4.6.3 无参数的构造器只有当类没有提供任何构造器时，系统才会提供一个默认的无参构造器。 4.6.4 显式域初始化123class Employee&#123; private String name =&quot;&quot;;&#125; 在执行构造器之前，会先执行显式赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方法特别有用。 4.6.5 参数名在编写很小的构造器时，常常在参数命名上出现错误。通常，参数用单个字符命名，但是我们推荐这样做： 123456789public Employee(String aName, double aSalary)&#123; name = aName; salary = aSalary;&#125;public Employee(String name, double salary)&#123; this.name = name; this.salary = salary;&#125; 4.6.6 调用另一个构造器关键字 this 引用方法的隐式参数。然而，这个关键字还有另外一个含义。如果构造器的第一个语句形如 this(...)，这个构造器将调用同一个类的另一个构造器。下面是个典型的例子： 12345public Employee(double s)&#123; //call Employee(String, double) this(&quot;Employee #&quot;+nextId,s); nextId++:&#125; 4.6.7 初始化块前面已经讲过两种初始化数据域的方法： 在构造器中设置值 在声明中赋值实际上，Java 还有第三种机制，称为初始化块 (initialization block)。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如， 12345678910111213141516171819202122232425class Employee&#123; private static int nextId; private int id; private String name; private double salary; &#123; d = nextId; nextId++: &#125; public Employee(String n, double s) &#123; name = n ; salary = s; &#125; public Employee() &#123; name = &quot;&quot;; salary = 0; &#125;&#125; 通常会直接将初始化代码放在构造器中。由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱，下面是具体处理步骤： 所有数据域被初始化为默认值 (0、false 或 null)。 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。 执行这个构造器的主体。还可以使用静态代码块，在类第一次加载的时候，将会进行静态域的初始化。 Random API Random() // 构造一个新的随机数生成器 int nextInt(int n)// 返回一个 0~ n-1 之间的随机数 4.6.8 对象析构域 finalize 方法由于 Java 有自动的垃圾回收器，不需要人工回收内存，所以 Java 不支持析构器。 4.7 包Java 允许使用 包 (package) 将类组织起来，借助于包可以方便地组织自己的代码。使用包的主要原因是确保类名的唯一性。 4.7.1 类的导入一个类可以使用所属包中的所有类，以及其他包中的公有类 (public class)，我们可以采用两种方式访问另一个包中的共有类。第一种方式是在每个类名之前添加完整的包名。 1java.time.LocalDate today = java.time.LocalDate.now(); 这样比较麻烦，我们推荐使用 import 导包，import 语句应该位于源文件的顶部 (但位于 package 语句的后面)。例如，可以使用下面这条语句导入 java.util 包种所有的类。import java.util.*;，也可以导入特定的类 import java.time.LocalDate; 4.7.2 静态导入import 不仅可以导入类，还增加导入静态方法和静态域的功能。例如：import static java.lang.System.*;我们就可以使用 System 类的静态方法和静态域，而不必加类名前缀： 123out.println(&quot;Goodbye,World!&quot;);//还可以导入特定的方法或域import static java.lang.System.out; 4.7.3 将类放入包中要想将一个类放入包中，必须将包的名字放在源文件的开头，包中定义类的代码之前。 1234package com.horstmann.corejava;public class Employee&#123;&#125; 4.7.4 包作用域标记为 public 的部分可以被任意的类使用；标记为 private 的部分只能被定义它们的类使用。如果没有指定，则为 default，表示可以被同一个包中的所有方法访问。 4.9 文档注释JDK 包含一个很有用的工具，叫做 javadoc。它可以由源文件生成一个 HTML 文档。如果在源代码种 添加以专用的 /** 开始注释，那么可以很容易地生成一个看上去具有专业水准的文档。 4.9.1 注释的插入javadoc 从下面几个特性种抽取信息： 包 公有类与接口 公有的和受保护的构造器及方法 公有的和受保护的域每个 /** */文档注释在标记之后紧跟着自由格式文档。标记由 @ 开始，如 @author 或 @param。在自由格式文本中，可以使用 HTML 修饰符，例如：&lt;em&gt; &lt;/em&gt;，&lt;strong&gt; &lt;/strong&gt;。 4.9.2 类注释类注释必须放在 import 语句之后，类定义之前。 12345678package com.example;/** * Afdfsdfsdfsdf * sdfsdfsdfsdfs * fsdfdssfsdfsf */public class PackageTest &#123; 4.9.3 方法注释每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记： @param 变量描述 @return 描述 @throws 类描述下面是一个方法注释的实例： 123456789/** * 我用来说明方法的概要 * @param s 我用来说明参数的作用 * @param g 我用来说明参数的作用 * @return 我用来说明返回值的作用 */ public int gogogo(String s , int g )&#123; return 4; &#125; 4.9.4 域注释只需要对公有域 (通常指的是静态常量) 建立文档。例如 1234/** * 我用来说明常量作用 */public static final int YEAR = 5; 4.9.5 通用注释下面的标记可以用在类文档的注释中。 @author 姓名，将产生一个 “author” 条目，可以使用多个。 @version 版本，这个标记将产生一个 “version” 条目 @since 这个标记将产生一个 “since” 条目，这里的 text 可以是对引入特性的版本描述。 @deprecated 这个标记将对类、方法或变量添加一个不再使用的注释。 @see 引用，它可以用于类中，也可以用于方法中。它有三种情况 package.class#feature label &lt;a href=&quot;...&quot;&gt;label&lt;/a&gt; “text”@see 的第一种情况最常见。只要提供类、方法或变量的名字，javadoc 就在文档中插入一个超链接。例如：@see com.horstmann.corejava.Employee#raiseSalary(double)@see com.example.GoGoGo#fuck(String)@see GoGoGo#fuck(String) 也可以省略包名。如果 @see 标记后面有一个 &lt; 字符，许久需要指定一个超链接，可以超链接到任何 URL。 12see &lt;a href =&quot;wwww.baidu.com&quot;&gt;百度&lt;/a&gt;@see &quot;百度&quot; 如果愿意的话，还可以在注释中的任何位置放置指向其他类或方法的超级链接，以及插入一个专用的标记，例如：{@link GoGoGo#fuck(String) label} 4.9.6 包与概述注解类、方法、变量的注释都可以放置在 Java 源文件中，但是要想产生包注释，就需要在每一个包目录中添加一个单独的文件。可以有如下两个选择： 提供一个以 package.html 命名的 HTML 文件。在标记 &lt;body&gt;..&lt;/body&gt; 之间的所有文本都会被抽取出来。 提供一个以 package-info.java 命名的 Java 文件。这个文件必须包含一个初始的以 /** */界定的 Javadoc 注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。还可以为所有的源文件提供一个概述性的注释，这个注释将被放置在一个名为 overview.html 的文件中，这个文件位于包含所有源文件的父目录中。标记 &lt;body&gt;..&lt;/body&gt; 之间的所有文件将被抽取出来。当用户从导航栏中选择 “Overview” 时，就会显示出这些注释内容。 4.10 类设计技巧 一定要保证数据私有：将全局变量设置为 private。 一定要对数据初始化 不要在类中使用过多的基本类型 不是所有的变量都需要 get、set 方法 将职责过多的类进行分解 类名和方法名要能够体现它们的职责 优先使用不可变的类 总结： OOP 对象的三个主要特征：行为 (方法)、状态 (方法的执行结果)、标识 (多态)。 类之间常见的关系：依赖 (uses-a)、聚合 (has-a)、继承 (is-a)。 一个对象变量并没有实际包含一个对象，而是引用一个对象。任何对象变量的值都是对存储在另一个地方的一个对象的引用，实际的对象在堆内存中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。 有时候多态的实现可以使用工厂方法来实现。 所有的 Java 对象都是在堆中构造的，构造器伴随着 new 操作符一起使用，不能在构造器中定义与实例域重名的局部变量。 方法中的显示参数指传参，隐式参数指方法的主体类，即调用对象本身 (this)，如data.getTime()中的 data。 对一个对象进行数据域的拷贝可以用 Object 的clone()方法，不要直接返回一个类的引用本身。 final 实例域在构造器执行之后一定是赋上值的且不可改变；static 域属于类，不属于任何独立的对象。 类的成员方法可以访问静态变量，静态方法不能访问成员变量 (肯定了)。 方法参数分为按值传递和按引用传递：值传递不可改变原值，因为先拷贝再处理；引用传递虽然也拷贝了一份，但是是浅拷贝，指向同一个内存地址，因此可以改变引用的状态。 方法总结 (两种传递)：• 方法不能改变基本数据类型的参数 (值传递，会拷贝)。• 方法可以改变一个对象的状态 (值传递，浅拷贝，改变了实际的堆里对象状态)。• 方法不能让对象参数引用一个新的对象 (会拷贝，只要不改变对象状态，只修改引用没用，因为方法结束时变量拷贝被丢弃，原引用还是不会变)。 当且仅当类没有任何构造方法时，系统会为之创建一个无参构造方法；否则必须使用自己定义的构造方法。 初始化块会在构造类对象时被执行，先运行初始化块，然后才运行构造器主体部分。 类的加载顺序：静态变量、静态初始化块 (先父后子) -&gt; 实例变量、实例初始化块 (先父后子) -&gt; 构造器 (先父后子)。 finalize()方法会在垃圾回收器清除对象之前被调用；import 导入包时，可以导入包、类和静态方法和静态变量。 几个概念区别：• 重写 (覆盖)(override) 指方法名和参数完全相同；• 重载 (overload) 指方法名相同参数不同；• 多态 (polymorphlism) 是针对类来说的指父类的多种实现。 包权限优先级：public(任何地方) &gt; protected(本包和其他包自类) &gt; default(本包) &gt; private(本类)。 只有 public 级别的方法可以在 new 出来的对象中去显式调用，否则都不行 (只能在类中和子类中自己使用)。重点：P112 静态域、静态方法 P123 对象构造 注意：instanceof 关键字 运行时指出对象是否是一个特定类的实例 (它是判断不出来接口、继承等关系中的子类和父类的，都会返回 true)；需要判断具体类时使用. class 进行比较。 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（第3章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-19%2F</url>
    <content type="text"><![CDATA[第三章：Java 基本程序设计结构3.1 一个简单的 Java 应用程序12345public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;We will not use &apos;Hello, World!&apos;&quot;); &#125;&#125; Java 区分大小写，如果出现了大小写拼写错误 (例如，将 main 拼写为 Main)，程序将无法运行。public 被称为访问修饰符，用于控制程序的其他部分对这段代码的访问级别。class 表明 Java 程序中的全部内容都包含在类中，Java 应用程序中的全部内容都必须放置在类中。FirstSample 就是类名，定义类名的规则是：必须以字母开头，后面可以跟字母与数字的任意组合，长度基本没有限制，但是不能与 Java 保留字重名 (比如取个类名叫 public)，类名不强制大写，但是标准的命名规范中规定需要大写，即约定俗成。骆驼命名法 (驼峰命名法)：如果名字中包含了多个单词，则每个单词的第一个字母应该大写。源文件的文件名必须与 public 类的名字相同，并用 .java 作为扩展名。当我们执行编译命令的时候，Java 虚拟机会找到类中的 main 方法，并开始执行，所以在 .java 文件中必须要又一个 main 方法。如何执行这段 Java 代码：编写 .java 文件 —-&gt; 利用 Java 编译器 —-&gt; 生成 .class 字节码文件 —-&gt; 启动 Java 虚拟机 —-&gt;Java 虚拟机找到 main() 方法，开始执行。 123&#123; System.out.println(&quot;We will not use &apos;Hello, World!&apos;&quot;);&#125; { }一对大括号代表了方法体的开始与结束，在 Java 中，每个语句必须要用分号结束，回车不代表结束。 3.2 注释Java 的注释不会出现在可执行程序中，因此，可以在源程序中添加任意多的注释，在 Java 中，有 3 种标记注释的方式。 / / ：适用于一段较长的注释，需要注意，无法嵌套使用 /* /：可以用来自动地生成文档 3.3 数据类型Java 是一种强类型语言，必须为每个变量声明一种类型。在 Java 中有 8 种基本类型：4 种整型，2 种浮点型，1 种用于表示 Unicode 编码的字符单元的字符类型 char，和一种用于表示真值的 boolean 类型 (String 和 数组都是对象)。 3.3.1整型：用于表示没有小数部分的数值，它允许是负数取值范围 -2^(位 - 1) —–2^(位 - 1)-1 一个字节代表 8 位 类型 存储需求 取值范围 具体值 int 4 字节 -2 的 32 次方~ 2 的 32 次方 - 1 -2147483646-2147483647(正好超过 20 亿) short 2 字节 -2 的 16 次方~ 2 的 16 次方 - 1 -32768~32767 long 8 字节 -2 的 64 次方~ 2 的 64 次方 - 1 -9223372036854775808~9223372036854775807 byte 1 字节 -2 的 8 次方~ 2 的 8 次方 - 1 -128~127 在 Java 中，整型的范围与运行 Java 代码的机器无关。长整型数值后面有一个 L 后缀，从 Java7 开始，加上前缀 0b 或 0B 就可以写二进制数。如 0b1001 就代表 9，还可以为数字字面量加下划线，如用 1_000_000 表示一百万，更加可读，编译器会去掉这些下划线。 12System.out.println(0b1001); // result : 9System.out.println(1_000_000); // result :1000000 3.3.2 浮点类型用于表示有小数部分的数值。Java 中有两种浮点类型。 类型 存储需求 取值范围 float 4 字节 -1.7 乘以 10 的 38 次方~ 1.7 乘以 10 的 38 次方 double 8 字节 -3.4 乘以 10 的 308 次方~ 3.4 乘以 10 的 308 次方 double 表示这种类型的数值精度是 float 类型的两倍 (也有人称之为双精度数值)，float 类型的数值后有一个后缀 F 或 f，没有后缀的默认为 double 类型，double 类型也可以加后缀 D 或 d 。注意浮点类型计算存在误差，是因为浮点数值采用二进制系统表示，在二进制系统中无法精确地表示分数 1/10 ，可以使用 BigDecimal 类代替实现。 12System.out.println(2.0-1.1);result : 0.8999999999999999 3.3.3 char 类型char 类型用于表示单个字符，不过现在有些变化，有些 Unicode 字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值。&#39;A&#39; 与 &quot;A&quot; 不同，前者是编码值为 65 所对应的字符常量，后者是包含一个字符 A 的字符串。char 类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff 。下面这行代码是符合语法标准的，\u005B 表示 [ ，\u005D 表示 ]。Unicode 转义序列会在解析代码之前得到处理。 1public static void main(String\u005B\u005D args) &#123;&#125; Java 中可以使用 \u + Unicode编码来进行转义，如 \u0022，除了这个以外，还有一些特殊的转义序列 转义序列 名称 Unicode 值 \b 退格 \u0008 \t 制表 \u0009 \n 换行 \u000a \r 回车 \u000d \” 双引号 \u0022 \’ 单引号 \u0027 \ 反斜杠 \u005c 3.3.5 boolean 类型boolean(布尔) 类型有两个值：false 和 true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。 3.4 变量在 Java 中，每个变量都一个类型 (type)。在声明变量时，变量的类型位于变量名之前，例如： 123double salary;int vacationDays;boolean done; 变量名必须要以字母开头，并由字母或数字组成的序列，不过这里的 “字母” 的概念不单指英文字母，字母包括 A~Z，a~z，_，$，或在某种语言中表示字母的任何 Unicode 字符，比如德国人就可以在变量名中使用字母 ä。 3.4.2 常量在 Java 中，利用关键字 final 指示常量，例如final int cout = 3 ;关键字 final 表示这个变量只能被赋值一次，一旦被赋值之后，就不能够再修改了，习惯上，常量名使用全大写。声明在类中，用 static final 声明的变量，也被称为类常量 3.5 运算符在 Java 中，使用算术运算符 +，-，*，/，表示加减乘除运算，当参与 / 运算的两个操作数都是整数时，表示整数触发；否则表示浮点除法。整数的求余操作 (有时称为取模)，用 % 表示。 1234a = 15 , b = 2 a/b=7a%b = 1;a=15.0a/b = 7.5 3.5.1 数学函数与常量在 Math 类中包含了各种各样的数学函数，比如这里有一个计算数值平方根的方法 123double x = 4;double y = Math.sqrt(x);// sqrt 接受一个 double 值System.out.println(y); 幂运算的方法 12// y 的值为 x 的 a 次幂，同样接受 double 值。double y = Math.pow(x,a); 3.5.2 数值类型之间的转换如果两个操作数中有一个是 double 类型，另一个操作数就会转换为 double 类型。否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。否则，如果其中一个操作数是 long 类型，另一个操作数将会转换为 long 类型。否则，两个操作数都将被转换为 int 类型。 3.5.4 结合赋值和运算符“+=”，“-=”，“*=”，“%=”，这些都是在赋值中使用二元运算符，但是不会改变数据的类型，例如： 123int x =2 ;x+=3.5;此时等价于： x = (int)(x+3.5)//先变成 double ，再被转换为 int 3.5.5 自增与自减运算符++n，n++，是两种不同的含义，如果把加号放在前缀，那么则会先自增，再运算表达式的值；如果放在后缀，那么则会先运算表达式的值，再自增。另外，++4，是错误的，自增与自减运算符只能用于变量，不能是数值。 1234567int a = 2;int c = 3;System.out.println(a++);System.out.println(++c);--------------------------24 3.5.6 关系和 boolean 运算符 == ：检测相等性 !=：检测不相等 &lt;，&gt;，&lt;=，&gt;=：小于，大于，小于等于，大于等于 &amp;&amp;：采用短路的做法，如果前者为 false ，则不计算后者 ||：采用短路的做法，如果前者为 true ，则不计算后者 ？： ：三元运算符，condition? expression1：expression2，如果 condition 为 true，就为第一个表达式的值，反之则为第二个表达式的值。 3.5.7 位运算符 &amp;：&amp; 在运算的时候，将 2 个数字的二进制做比较，当 2 个数字的值都为 1 时，才为 1，否则就是 0 |：数值运算符的时候 同样是比较 2 进制，当有一个数为 1，那么就取 1 ^：数值运算符的时候 同样是比较 2 进制， 只能有 1 个 1，那就取 1 ~：取反值 ：补最左边的数位时，会根据符号位， 符号是 1 就填充 1，符号是 0，就填充 0; &lt;&lt;：左移 &gt;&gt;&gt;：无符号右移: 对于正数 有符号与无符号的右移没有区别。 对于负数 来说，不管你是 0 还是 1，都会用 0 去补位 不管是正数还是负数，在底层，都是以补码的性质来存的1 1 1 1 1 1 1 1第一位是符号位，符号位是 0，就是正数，符号位是 1，就是负数00001010从最后一位开始计算 2 的 0 次方，2 的 1 次方，2 的 2 次方，2 的三次方 —-对于正数来说。原码，反码，补码 三码合一。负数的原码， 把最高位的 0 改为 1原码变为反码：各个位除符号位外取反，即 0 变成 1，1 变成 0反码变成补码 在反码的基础上 +1 3.5.8 括号与运算符级别如果不使用括号，就按照给出的运算符优先级次序进行计算，同一个级别的运算符按照从左到右的次序进行是计算 (除了右结合运算符)， 运算符 结合性 [] .()(方法调用) 从左向右 ! ~ ++ – +(一元运算) -(一元运算) ()(强制类型转换) new 从右向左 * / % 从左向右 +(正) -(负) 从左向右 &lt;&lt;&gt;&gt; &gt;&gt;&gt; 从左向右 &lt;&lt;=&gt; &gt;= instanceof 从左向右 == != 从左向右 &amp; 从左向右 ^ 从左向右 从左向右 &amp;&amp; 从左向右 逻辑或 从左向右 ?: 从右向左 = += -= *= /= %= &amp;= ^= &lt;&lt;=&gt;&gt;= &gt;&gt;&gt;= 从右向左 3.6 字符串Java 字符串就是 Unicode 字符序列，同时在标准 Java 类库中提供了一个预定义类 String substring()方法：可以从一个较大的字符串提取出一个字串 1234String greeting = &quot;Hello&quot;;String s = greeting.substring(0,3); result : Hel substring(a,b);//一般子串的长度就是 b-a 拼接：当将一个字符串与一个非字符串的值进行拼接时，后者会被转换为字符串。如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态 join 方法： 1234String all = String.join(&quot;-&quot;,&quot;name&quot;,&quot;age&quot;,&quot;school&quot; );System.out.println(all);result:name-age-school 不可变字符串在 Java 中，如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是：不能改变对象内的成员变量，其中基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。同时要区分对象和对象的引用 123456String abc = &quot;Hello&quot;;abc = &quot;GoGoGo&quot;;System.out.println(abc);------------GoGoGo//这里要说明的是，abc 只是一个 String 对象的引用，并不是对象本身，引用里面存放了它所指向的对象的地址，通过这个地址可以访问对象，这里其实是创建了一个新的 String 对象 &quot;GoGoGo&quot;，然后 abc 重新指向了这个对象。 3.6.4 检测字符串是否相等使用 equals 方法检测两个字符串是否相等，s.equals(t)，如果字符串 s 与字符串 t 相等，则返回 true，否则，返回 false。s 和 t 可以是字符串变量，也可以是字符串字面量： 123String abc = &quot;Hello&quot;;abc.equals(&quot;Hello&quot;);&quot;Hello&quot;.equals(abc); 如果你希望检测两个字符串是否相等，而不区分大小写，可以使用 equalsIgnoreCase 方法。不能使用== 来比较字符串是否相同，因为 == 比较的是变量的内存地址，而不是变量的值。 3.6.5 空串与 Null 串空串 “” 是长度为 0 的字符串，可以调用以下代码检查一个字符串是否为空。 12if(str.length()==0)if(str.equals(&quot;&quot;)) 空串是一个 Java 对象，有自己的串长度 (0) 和内容 (空) ，不过 String 变量还可以存放一个特殊值：null，表示目前没有任何对象与该变量关联，要检查一个字符串是否为 null，可以使用以下条件：if (str == null)有时要检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：if (str !=null &amp;&amp; str.length() != 0) 3.6.7 String API boolean equals(Object other) boolean equalsIgnoreCase(String other) boolean startWith(String prefix) 如果字符串以 prefix 开头，则返回 true boolean endsWith(String suffix) 如果字符串以 suffix 结尾，则返回 true int indexOf(String str) int indexOf(String str，int fromIndex) int indexOf(int cp) int indexOf(int cp，int fromIndex) int lastIndexOf(String str) int lastIndexOf(String str，int fromIndex) int lastIndexOf(int cp) int lastIndexOf(int cp，int fromIndex) length() String replace(CharSequence oldString，CharSequence newString)，可以用 String 或 StringBuilder 对象作为 CharSequence 参数。 String substring(int beginIndex) String substring(int beginIndex，int endIndex) String toLowerCase() 转换为小写 String toUpperCase() 转换为大写 String trim() 这个字符串将删除原始字符串头部和尾部的空格 String join(CharSequence delimiter，CharSequence… elements) 3.6.9 构建字符串如果单纯用 String 来拼接字符串，每次连接字符串都会构建一个新的 String 对象，既耗时，又浪费空间，使用 StringBuilder 就可以避免这个问题的发生。 12345//构建一个空的字符串构建器 StringBuilder builder = new StringBuilder(); builder.append("Hello"); builder.append("World"); String completedString = builder.toString(); StringBuilder 的前身是 StringBuffer，StringBuffer 的效率略低，但是允许采用多线程的方式执行添加或删除字符的操作，如果所有字符串都再一个单线程中编辑，则应该使用 StringBuilder，这两个类的 API 是相同的。 StringBuilder() int length() StringBuilder append(String str) StringBuilder append(char c) StringBuilder insert(int offset,String str) StringBuilder insert(int offset,Char c) StringBuilder delete(int startIndex,int endIndex) String toString() 3.7 输入输出java.lang 不需要 import 加载。System.out 是标准输出流，System.in 是标准输入流，要想通过控制台输入，首先要构造一个 Scanner 对象，并与 System.in 关联。 1Scanner scanner = new Scanner(System.in); 1234scanner.nextLine()//读取输入的整行信息。scanner.next()//读取一个单词scanner.nextInt()//读取一个整数scanner.nextDouble()//读取一个浮点数 因为 Scanner 输入是可见的，所以不适用于从控制台读取密码。Java SE 6 引入了 Console 类来实现这个目的，想要读取一个密码，可以采用下列代码： 1234//在使用 Eclipse 或其他 IDE 的情况下，是无法获取 Console实例的Console cons =System.console();String userName = cons.readLine(&quot;User name:&quot;);char[] passWord = cons.readPassword(&quot;PassWord:&quot;); ScannerAPI Scanner(InputStream in) 用给定的输入流创建一个 Scanner 对象 String nextLine() String next() int nextInt() double nextDouble() boolean hesNext() boolean hasNextInt() boolean hasNextDouble() 3.7.2 格式化输出System.out.printf 沿用了 C 语言库函数中的 printf 方法，可以设置多个参数，例如： 123String name = &quot;Pudge&quot;; int age = 15; System.out.printf(&quot;Hello,%s. Next year,you&apos;ll be %d&quot;, name, age); 每一个以 % 字符开始的格式说明符都用相应的参数替换。个数说明符尾部的转换符将指示被格式化的数值类型： d 十进制整数 g 通用浮点数 s 字符串 c 字符 b 布尔用于 printf 的标志 $ 给定被格式化的参数索引，例如：%1$d printf 用于输出，可以使用 String.format 方法来创建一个格式化的字符串，而不打印输出。 3.7.3 文件输入与输出PrintWriter 3.8 控制流程Java 使用条件语句和循环结构确定控制流程。 3.8.1 块作用域块 (block，又复合语句)：由一对大括号括起来的若干条简单的 Java 语句。block 确定了变量的作用域。一个 block 可以嵌套在另一个 block 中， 12345678//在 main 方法块中嵌套另一个语句块的实例public static void main(String[] args) throws Exception &#123; int n; &#123; int k; &#125; &#125; 但是，不能在嵌套的两个块中声明同名的变量，例如下面的代码就又错误。 1234567public static void main(String[] args) throws Exception &#123; int n; &#123; int k; int n;//不能声明同名变量 &#125; &#125; 3.8.2 条件语句格式为 if(condition) statement，条件用括号括起来。else 子句与最邻近的 if 构成一组，例如：if (x&lt;=0) { if (x==0) sign = 0; else sign = -1;} 3.8.3 循环while (condition) statement，while 循环语句会首先检测循环条件，因此，循环体中的代码有可能不被执行。do/while 可以保证循环体至少执行一次，则应该将检测条件放在最后，语法格式为 do statement while (condition)，这种循环语句先执行语句 (通常是一个语句块)，再检测循环条件；然后重复语句，再检测循环条件，以此类推。for 循环是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或类似的变量来控制迭代次数。 123for (int i = 1; i&lt;=10; i++)&#123;System.out.println(i);&#125; 3.8.5 switch 语句switch 语句将从与选项值相匹配的 case 标签处开始执行，直到遇到 break 语句，或者执行到 switch 语句的结束处为止。如果没有相匹配的 case 标签，而有 default 子句，就执行这个子句。case 标签可以是： 类型为 char、byte、short、int 的常量表达式 枚举常量 从 Java 7 开始，case 标签还可以是字符串字面量 1234567//如果想让几个 case 执行相同的语句switch(name)&#123;case &quot;yes&quot;:case &quot;no&quot;: //sthbreak;&#125; 3.8.6 中断控制流程语句break 也可以中断循环或者条件语句，Java 还提供了一种带标签的 break 语句，用于跳出多重嵌套的循环语句。break 会跳出一个循环体，但假设这个循环体被外层循环嵌套，那么 break 是无法跳出外层循环的。continue 将控制转移到最内层循环的首部 (跳过本次循环)，同样的，continue 也可以使用标签机制。 3.9 大数值如果基本的整数和浮点数精度不能够满足需求，那么可以使用 java.math 包中的两个很有用的类：BigInteger 和 BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger 实现了任意精度的整数运算，BigDecimal 实现了任意精度的浮点数运算。 12345//使用静态的 valueOf 方法可以将普通的数值转换为大数值//不能使用+、-、*等运算符，需要使用add、multiply方法BigInteger a = BigInteger.valueOf(100);BigInteger c = a.add(b) // c = a + b BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); d = c *(b + 2); BigInteger API BigInteger add(BigInteger other)// 加法 BigInteger subtract(BigInteger other)// 减法 BigInteger multiply(BigInteger other)// 乘法 BigInteger divide(BigInteger other)// 除法 BigInteger mod(BigInteger other)// 取余 int compareTo(BigInteger other)// 比较，相等则返回 0，大于则返回 1，小于则返回 -1 BigDecimal API BigDecimal add(BigDecimal other) BigDecimal subtract(BigDecimal other) BigDecimal multiply(BigDecimal other) BigDecimal divide(BigDecimal other , RoundingMode mode)// 需要给出舍入方式，如 RoundingMode.HALF_UP 是在学校中学习的四舍五入方式 int compareTo(BigDecimal other) static BigDecimal valueOf(long x) static BigDecimal valueOf(long x, int scale)// x / 10^scale 3.10 数组是一种数据结构，用来存储同一类型值的集合。可以使用这两种形式来声明数组： 12int[] a ; int a[] ; 创建数组时，数字数组的初始值为 0，boolean 数组的初始值为 false。对象数组的初始值为 null。一旦创建了数组，那么数组的大小就不能再改变了。 3.10.1 for each 循环用来依次处理数组中的每个元素 (其他类型的元素集合亦可) 而不必为指定下标值而分心。for(variable : collection) statementcollection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象 (如 ArrayList)。如果想要快速打印一个数组的话，可以使用 Arrays.toString 方法。 3.10.2 数组初始化以及匿名数组int[] smallPrimes = {2,3,5,7,11,13} 这是一种简化书写形式，甚至可以初始化一个匿名的数组 new int[] {17, 19, 23, 29, 31, 37} 3.10.3 数组拷贝在 Java 中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组。这里要区别直接赋值与 copyOf 方法的区别。 12345678910111213141516171819public static void main(String[] args) throws Exception &#123; //声明三个数组 int[] a = &#123; 1, 2, 3, 4 &#125;; int[] b; int[] c; //直接赋值,a和b引用同一个数组,那么修改b,a也会受影响 b=a; b[0]=5; //此时把a再拷贝给c,如果a受影响,那么c[0]==5,反之c[0]==1 c =Arrays.copyOf(a, a.length); System.out.println(Arrays.toString(c)); //那么改变c的值,会影响a吗? c[0]=6; System.out.println(Arrays.toString(a)); &#125;------------------result:[5, 2, 3, 4][5, 2, 3, 4] 3.10.4 命令行参数main 方法中接收一个参数 String[] args，如果我们不使用任何 IDE，那么我们可以这样传递参数： 1234567891011121314151617181920212223//调用虚拟机运行 Java 程序//java 类名 参数1 参数2 参数3... //java FirstSample -g cruel worldpublic class FirstSample &#123; public static void main(String[] args) throws Exception &#123; if (args.length == 0 || args[0].equals(&quot;-h&quot;)) System.out.print(&quot;Hello,&quot;); else if (args[0].equals(&quot;-g&quot;)) ; System.out.print(&quot;Goodbye,&quot;); for (int i = 1; i &lt; args.length; i++) &#123; System.out.print(&quot; &quot; + args[i]); &#125; System.out.println(&quot;!&quot;); &#125;&#125;result ---------------------Goodbye, cruel world! 3.10.5 数组排序要想对数值型数组进行排序，可以使用 Arrays 类中的 sort 方法，这个方法使用了优化的快速排序算法。Math.random 方法将返回一个 0 到 1 之间 (包含 0，不包含 1) 的随机浮点数。 12345678910111213141516171819//小型抽奖。public static void main(String[] args) throws Exception &#123; int[] numbers = new int[20]; int[] result = new int[5]; for(int i =0;i&lt;numbers.length;i++)&#123; numbers[i] = i+1; &#125; int n = numbers.length; for(int i = 0;i&lt;result.length;i++)&#123; int r = (int)(Math.random() * n);//0&lt;=n&lt;19 result[i] = numbers[r];//19 numbers[r] = numbers[n-1];//把最后一位数字赋值给抽到过的数字。 n--;//18 &#125; Arrays.sort(result); for(int r:result)&#123; System.out.println(r); &#125; &#125; Arrays API String toString(type[] a) 返回包含数组数值的字符串 type copyOf(type[] a , int length) type copyRange(type[] a, int start, int end) end 终止下标 (不包含) void sort(type[] a ) int binarySearch(type[] a , type v) int binarySearch(type[] a, int start, int end, type v) 采用二分搜索算法查找值 v vod fill(type[] a, type v) 将数组的所有数据元素值设置为 v boolean equals(type[] a, type[] b) 如果两个数组大小相同，并且下标相同的元素都对应相等，返回 true。 String Arrays.deepToString(a) 打印一个二维数组列表 3.10.6 多维数组适用于表示表格或更加复杂的排列形式。多维数组又被称为叫二维数组，与一般数组的初始化方式相同 12345678double[][] balances;int[][] magicSquare = &#123; &#123;16,3,2,16&#125;, &#123;5,10,11,8&#125;, &#123;9,6,7,12&#125;, &#123;4,15,14,1&#125;&#125;//可以通过 magicSquare[][]的方式来访问。 要想循环遍历其中的数据，我们有这种嵌套循环的方法： 123456for(double[] row : a)&#123; for(double value : row) do something with value&#125;//如果要打印列表Arrays.deepToString(a) 3.10.7 不规则数组由于二维数组可以看成是数组的每个元素是数组，所以可以进行数组换行。 123double[] temp = balances[i]balances[i] = balances[i + 1]//把balances[i] 和 balances[i + 1]数据进行交换balances[i + 1] = temp 总结 总结： Java 是强类型语言，有 8 种基本数据类型：4 种整型、2 种浮点型、1 种字符型、1 种布尔型。分别为：byte、short、int、long、float、double、char、boolean。 占用字节数：byte:1 字节、short：2 字节、int：4 字节、long：8 字节、float：4 字节、double：8 字节。Java 中所有数值类型所占字节数量与平台无关。 byte 与 char 区别：• byte 是有符号型，char 是无符号型；byte 占 1 字节，8 位，表示 - 127 到 128，char 占 2 字节，16 位，表示 0~65536。• byte 可以初始化为数字或字符，最终表示的是数值，char 可以初始化为数字或字符，最终表示的是字符。• char 可以表示中文，byte 不可以；对于英文可以相互转化，byte 代表的是 ASCII 码，char 代表对应的字符。 注意不要用浮点型来进行金融计算，如（2.0-1.1=0.89999…），因为二进制无法精确表示 1/10；尽量不要在程序中使用 char 类型。 码点是指一个编码表中某个字符对应的代码值，在 Unicode 标准中采用 16 进制书写，并加上前缀 U+。UTF-16 编码采用不同长度表示码点，每个字符用 16 位表示，通常被称为代码单元，辅助字符一般采用一对连续的代码单元进行编码。因此最好别用 char 类型。 一个字符串与非字符串的值拼接时，后者会被转为字符串。 格式化输出：(&quot;%1$d,%2$s&quot;,99,&quot;abc&quot;)-&gt; 输出(99，abc)；% 是格式化关键字，$ 表示参数索引。索引必须在 % 后面，以 $ 结尾，以 1 开头。 &amp;&amp; 的优先级高于 ||，+= 是右结合运算符。a+=b+=c，会先进行 b+=c，然后在 +=a。 C++ 中可以在嵌套语句块中定义重名变量，内层会覆盖外层变量，但是 Java 不可以。 else 语句与相邻最近的一个 if 语句为一对。 case 标签可以是 char、byte、short、int、枚举常量和 String(Java SE7 后支持)。 break：跳出循环体；签名定义好标签 break label 可以跳出多层嵌套循环；continue：不执行后面的逻辑，直接进行下一次循环。 数组是一种数据结构，用来存储同一类型值的集合。创建数组时，数值型初始化为 0、布尔型初始化为 false、对象型初始化为 null。一旦创建后就不能改变它的大小了。 创建数组三种方法：• int[] a = new int[10];• int[] a = {1,2,3};• int[] a = new int[]{1,2,3}。 打印数组：Arrays.toString(a)；打印多维数组：Arrays.deepToString(a)。 数组的Arrays.copyOf()方法拷贝一个新的引用；Arrays.sort()方法使用了优化的快速排序算法来排序数组；Arrays.binarySearch()采取二分查找算法查询指定值。还有fill()、qeuals()等方法。 Arrays 具有封装好的许多静态方法提供给我们对数组进行使用。如toString()、copyOf()、copyOfRange()、sort()、binarySearch()、fill()、equals()等，更多 api 见 P85。 参考：https://www.jianshu.com/p/559d35944079https://ctolib.com/topics-35864.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java核心技术 卷一（1~2章） 笔记总结]]></title>
    <url>%2F2018%2F03%2F18%2F2018-03-18%2F</url>
    <content type="text"><![CDATA[第一章：Java 程序设计概述1.2 Java语言的设计特性 简单性 Java语法剔除了C++中很少或难以理解的特性，没有头文件，指针运算，结构等，语法相对纯净。 另一个简单是小，Java支持嵌入式，可在小型机器上运行，基本解释器和类仅40KB，再加上类库和对线程的支持也不过175KB。当然现在用于类库的扩大，有了独立专用的较小类库Java微型版(Java Micro Edition)用于嵌入式设备。 面向对象 简单说，面向对象设计是一种程序设计技术，重点关注数据(即对象)和对象的接口。本质上Java的面向对象能力与 C++一样，主要不同点在于多继承，Java取而代之的是简单的接口概念，并提供了更丰富的运行时自省功能。 网络功能(分布式) Java拥有扩展的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java程序可通过URL打开和访问网络对象，十分便捷。 健壮性 Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性，Java编译器能够检测许多其他语言仅在运行时刻才能检测出来的问题 安全性 Java在设计时就注意防范诸如运行时堆栈溢出，破坏自己的进程空间之外的内存，未经授权读写文件等问题。不可信代码将在沙箱中运行。 体系结构中立 体现了一处编译，到处运行的思想。编译器编译的字节码，可以在不同处理器上运行，而与计算机体系结构无关，只要有Java运行时系统就可以运行，可以通过Java虚拟机翻译成机器码，即即时编译。 可移植性 Java 中的 int 永远是 32 位，int 的大小不低于 short int，不高于 long int。C/C++ 中 int 可能是 16 位也可能是 32 位，或是编译器提供商指定的其他大小。 与C/C++不同，Java没有“可依赖具体实现”的地方，其基本数据类型的大小以及有关运算都做了明确说明。在Java中，数据类型具有固定大小，二进制数据以固定格式进行存储和传输(消除了字节顺序的困扰)，字符串用标准Unicode格式存储，这消除移植代码问题。 解释性 Java解释器可以在任何移植了解释器的机器上执行Java字节码。 高性能 字节码可以(在运行时刻)动态地翻译成对应运行此应用特定CPU的机器码。依赖虚拟机的即时编译或即时编译器。 多线程 多线程可以带来更好的交互响应和实时行为。在底层，主流平台的线程实现机制各不相同，但Java在不同机器上，调用多线程的代码完全相同，把多线程的实现交给底层的操作系统或线程库来完成。 动态性 相对C/C++，Java库中自由地添加新方法和实例变量，对客户端不会有影响，尤其是正在运行的程序时。 1.5 关于Java的常见误解 Java是HTML的扩展 Java是一种程序设计语言，HTML是一种描述网页结构的方式。二者没有共同之处。 使用XML，所以不需要Java XML是一种描述数据的方式，可以使用任何程序设计语言来处理XML数据，Java API对XML处理提供了很好的支持，也有很多XML第三方工具采用Java编写。 Java将成为适用于所有平台的通用性编程语言 理论上可能，实际上难度很大，Java在服务器端变成和跨平台客户端应用领域比较有优势 Java只不过一种程序设计语言 程序设计语言的成功取决于其支撑系统的能力或者解决问题的能力，而非语法，Java减少指针错误，编程效率更高，这并非Java成功的全部原因。 Java是解释型的，对关键应用程序速度太慢了 早期Java是解释型的，现在Java虚拟机采用即时编译器，运行速度和C++差不多。PS:现在随着计算机性能提升，解释性语言或者编译型语言对运行效率的影响已经很小了。 JavaScript是Java的简易版 JavaScript是一种网页中使用的脚本语言，其语法类似Java，除此之外再无关系。 第二章：Java 程序设计环境Java 程序执行流程下面这幅图简单说明了 Java 程序的执行过程。 Java 工具简介下面简单介绍一下 Java 的一些工具。 JVM JVM（Java Virtual Machine），Java 虚拟机 JVM 是 Java 平台无关性实现的关键 JDK JDK（Java Development Kit），Java 语言的软件开发工具包。 两个主要的组件1 javac – 编译器，将源程序转成字节码2 java – 运行编译后的 java 程序（.class 后缀的） JRE JRE（Java Runtime Environment），Java 运行环境 包括 Java 虚拟机（JVM），Java 核心类库和支持文件 如果只需要运行 Java 程序，下载并安装 JRE 即可 JDK、JRE、JVM 三者关系用下面一幅图表示 概括一下就是 JRE = JVM + JavaSE 标准类库 JDK = JRE + 开发工具集（例如 javac 编译工具等） Java 平台分类最后再补充的就是 Java 平台分类，Java 平台可以分成下面三类 JavaSE主要用于开发桌面程序，也称为 Java 标准版。 JavaEE主要用于 Web 程序开发，也称为 Java 企业版。 JavaME主要用于移动设备的开发，也称为 Java 微型版。不过自从 Android 和 iOS 兴起后它就用的很少了。 参考：https://www.jianshu.com/p/559d35944079第1章：http://xuer80.com/2017/11/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/第2章：https://www.jianshu.com/p/3dd960faf7ff]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“大话架构”阿里架构师分享的Java程序员需要突破的技术要点]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-4%2F</url>
    <content type="text"><![CDATA[一、源码分析源码分析是一种临界知识，掌握了这种临界知识，能不变应万变，源码分析对于很多人来说很枯燥，生涩难懂。 源码阅读，我觉得最核心有三点：技术基础 + 强烈的求知欲 + 耐心。 我认为是阅读源码的最核心驱动力。我见到绝大多数程序员，对学习的态度，基本上就是这几个层次 (很偏激哦)： 1、只关注项目本身，不懂就 baidu 一下。 2、除了做好项目，还会阅读和项目有关的技术书籍，看 wikipedia。 3、除了阅读和项目相关的书外，还会阅读 IT 行业的书，比如学 Java 时，还会去了解函数语言，如 LISP。 4、找一些开源项目看看，大量试用第三方框架，还会写写 demo。 5、阅读基础框架、J2EE 规范、Debug 服务器内核。 大多数程序都是第 1 种，到第 5 种不光需要浓厚的兴趣，还需要勇气：我能读懂吗？其实，你能够读懂的 耐心，真的很重要。因为你极少看到阅读源码的指导性文章或书籍，也没有人要求或建议你读。你读的过程中经常会卡住，而一卡主可能就陷进了迷宫。这时，你需要做的，可能是暂时中断一下，再从外围看看它：如 API 结构、框架的设计图。 下图是我总结出目前最应该学习的源码知识点： 二、分布式架构分布式系统是一个古老而宽泛的话题，而近几年因为 “大数据” 概念的兴起，又焕发出了新的青春与活力。除此之外，分布式系统也是一门理论模型与工程技法并重的学科内容。相比于机器学习这样的研究方向，学习分布式系统的同学往往会感觉：“入门容易，深入难”。的确，学习分布式系统几乎不需要太多数学知识。 分布式系统是一个复杂且宽泛的研究领域，学习一两门在线课程，看一两本书可能都是不能完全覆盖其所有内容的。 总的来说，分布式系统要做的任务就是把多台机器有机的组合、连接起来，让其协同完成一件任务，可以是计算任务，也可以是存储任务。如果一定要给近些年的分布式系统研究做一个分类的话，我个人认为大概可以包括三大部分： 分布式存储系统 分布式计算系统 分布式管理系统 下图是我总结近几年目前分布式最主流的技术： 三、微服务当前微服务很热，大家都号称在使用微服务架构，但究竟什么是微服务架构？微服务架构是不是发展趋势？对于这些问题，我们都缺乏清楚的认识。 为解决单体架构下的各种问题，微服务架构应运而生。与其构建一个臃肿庞大、难以驯服的怪兽，还不如及早将服务拆分。微服务的核心思想便是服务拆分与解耦，降低复杂性。微服务强调将功能合理拆解，尽可能保证每个服务的功能单一，按照单一责任原则（Single Responsibility Principle）明确角色。 将各个服务做轻，从而做到灵活、可复用，亦可根据各个服务自身资源需求，单独布署，单独作横向扩展。 下图是我总结出微服务需要学习的知识点： 四、性能优化不管是应付前端面试还是改进产品体验，性能优化都是躲不开的话题。 优化的目的是让用户有 “快” 的感受，那如何让用户感受到快呢？ 加载速度真的很快，用户打开输入网址按下回车立即看到了页面加载速度并没有变快，但用户感觉你的网站很快性能优化取决于多个因素，包括垃圾收集、虚拟机和底层操作系统（OS）设置。有多个工具可供开发人员进行分析和优化时使用，你可以通过阅读 Java Tools for Source Code Optimization and Analysis 来学习和使用它们。 必须要明白的是，没有两个应用程序可以使用相同的优化方式，也没有完美的优化 java 应用程序的参考路径。使用最佳实践并且坚持采用适当的方式处理性能优化。想要达到真正最高的性能优化，你作为一个 Java 开发人员，需要对 Java 虚拟机（JVM）和底层操作系统有正确的理解。 以上五大知识体系是我从业多年总结出来的经验，都是当前最主流的技术。想学习这些技术的朋友可以加群：478030634。群里会分享这些技术知识点供大家学习免费下载 下图是我总结性能优化应该学习理解的几大知识体系： 五、Java 工程化工欲善其事，必先利其器，不管是小白，还是资深开发，都需要先选择好的工具。提升开发效率何团队协作效率。让自己有更多时间来思考。 “大话架构” 阿里架构师分享的 Java 程序员需要突破的技术要点 原文：https://segmentfault.com/a/1190000013561054]]></content>
      <tags>
        <tag>待阅</tag>
        <tag>架构</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试中并发类问题的准备和学习]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-3%2F</url>
    <content type="text"><![CDATA[声明：本文主要讨论的是后端Java开发职位的面试 主题 又到面试季了，从课程的群里，看到许多同学分享了自己的面试题目，我也抽空在网上搜索了一些许多公司使用的面试题，目前校招和社招的面试题基本都集中在几个大方向上，主要是：Java基础、并发、JVM、算法、数据库、一些框架、分布式集群 等。这里呢，单独就面试中的【并发】问题的准备和学习发表一下个人的见解。 现状 关于对并发的学习和理解，通过和许多学员沟通及大家在课程群里的反馈，总结一下，主要包含以下几种： 完全不知道并发的存在 知道并发要学，但是不知道该学习什么 知道并发重要，自己买相关书籍学，但是看完了还是懵懵懂懂 知道并发重要，自己查资料学了一些，许多都学会了，但总能发现不会的，不知道并发到底都要学什么 已经完成进阶，并发的问题了然于胸，这样的学员目前很少 首先说一下，为什么Java面试要考并发，而且并发相关的题目占比又是那么的高。对并发有一定了解的同学，应该都知道，大家平时 只要做Java项目就会涉及到并发 ，个别同学说自己从没接触过并发，这只是个人还没意识到而已。当你定义好一个可以调用的接口时，这时其实就已经和并发有关系了，因为任何一个接口都可能同时被请求多次。当你在项目中已经可以熟练的使用synchronized、volatile、static、final这些基本的Java关键字时，其实你对并发已经有一些基础了。大家总说的：面试造火箭、入职拧螺丝，其实有一部分原因也是因为你还没意识到面试考的这些东西其实一直就伴随着你的日常开发。 我不自量力的去列一下并发涉及到的关键字、类及可以考察的知识点：CPU缓存、Java内存模型JMM、atomic、AtomicInteger、AtomicLong、LongAdder、AtomicReference、AtomicBoolean、CAS原理、Unsafe、synchronized、volatile、final、static、ThreadLocal、AQS、J.U.C、CountDownLatch、Semaphore、CyclicBarrier、ReentrantLock、ReentrantReadWriteLock、StampLock、Condition、FutureTask、Fork/Join、BlockingQueue、ThreadPoolExecutor、ExecutorService、Thread、Runnable、Future、Callable、HashMap、 HashTable、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、RateLimiter、SimpleDateFormat、StringBuffer、StringBuilder、ArrayList、Vector、HashSet、ConcurrentSkipListSet、Collections.synchronizedXXX、Guava Cache、Redis … 我尝试去写出脑海里与并发有关的类和名词，我发现根本写！不！完！是的，并发的知识太多了，以致于很难给出一个完整的囊括。 因此呢，如果你盲目的一个知识点一个知识的去学，你就会发现你怎么都学不完，也很难在脑海里形成一个完整的知识体系，带来的最直接结果就是，你每次去面试时都要去把并发相关的再过一下，生怕自己被问到还没接触的。这时候，你要做的就是，先要在脑海里有一个完整的并发知识体系，然后根据这个体系去不断完善这个体系里每个模块的细节。 并发 关于并发的学习，可以从JDK提供的并发包为核心开始，许多其他的类和封装都是对其进行扩展或者补充，我们来看一下Java并发包(java.util.concurrent包，简称J.U.C)的构成： J.U.C核心由5大块组成：atomic包、locks包、collections包、tools包（AQS）、executor包（线程池）。大家平时遇到许多并发相关的类都可以从这里找到。但是呢，要想系统的掌握并发，不能是打开J.U.C这个包，挨个类去看，这里只是提供了五大块，代表核心的五个方向。要想系统的学习并发，还需要从并发的角度学习，过程中覆盖J.U.C的这些知识。这里我直接给出并发的学习步骤图（包含对当前面试常见考点的覆盖，比如对HashMap和ConcurrentHashMap的源码分析）： 这个之前呢，还需要对Java并发的基础进行细致的学习，比如CPU缓存和Java内存模型（JMM），许多关键字比如volatile、synchronized等的特性都是在JMM里规定好的。 高并发 我们这篇手记题目里提到的并发其实包含两部分：并发和高并发。手记讲到现在，其实我们讲的都是两部分里的第一部分：并发。那么并发和高并发到底有什么区别呢？许多学员对这两个概念都是模糊的，我简单做一下区分。 当我们说多线程并发时，其实我们更多的是讨论多个线程操作了相同的资源，这时我们讨论点更多的是落在保证线程安全以及合理分配和使用资源上。而高并发主要指系统运行过程中遇到“短时间内遇到大量操作请求”的情况，主要发生在系统集中收到大量请求（例如：12306的抢票情况；天猫双十一活动）。当我们说高并发时，我们谈的是是如何提高现有程序的性能，更多的是对高并发场景的一些解决方案，思路啦、手段等等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等。这里呢，我直接给出高并发场景通常都会考虑的一些解决思路和手段： 结尾 如何有效的准备面试中并发类问题，我已经给出我的理解。希望这些能帮大家在脑海里建立起大致的并发知识体系，然后根据这个知识体系有针对性的的去准备面试。预祝大家能高分通过面试，拿到高薪！ 当然，光提概念光看图是没用的，还需要大家根据这些提纲去实际学习相关的知识点和类才行。我已经准备好了这些实际知识点学习的流程，相信聪明的你已经知道该怎么办了~ 原文地址 https://www.imooc.com/article/23969]]></content>
      <tags>
        <tag>并发</tag>
        <tag>面试</tag>
        <tag>待阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典Java面试题95道]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-2%2F</url>
    <content type="text"><![CDATA[1、面向对象的特征有哪些方面？ 答：面向对象的特征主要有以下几个方面： 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java 与模式》或《设计模式精解》中关于桥梁模式的部分）。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 2、访问修饰符 public,private,protected, 以及不写（默认）时的区别？ 类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。 3、String 是最基本的数据类型吗？ 答：不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。 4、float f=3.4; 是否正确？ 答: 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float)3.4; 或者写成 float f =3.4F; 5、short s1 = 1; s1 = s1 + 1; 有错吗? short s1 = 1; s1 += 1; 有错吗？ 答：对于 short s1 = 1; s1 = s1 + 1; 由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。而 short s1 = 1; s1 += 1; 可以正确编译，因为 s1+= 1; 相当于 s1 = (short)(s1 + 1); 其中有隐含的强制类型转换。 6、Java 有没有 goto？ 答：goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。（根据 James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字） 7、int 和 Integer 有什么区别？ 答：Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱 / 拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 12345678910class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示： 123456789public class Test03 &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 如果不明就里很容易认为两个输出要么都是 true 要么都是 false。首先需要注意的是 f1、f2、f3、f4 四个变量都是 Integer 对象引用，所以下面的 == 运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf，如果看看 valueOf 的源代码就知道发生了什么。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; IntegerCache 是 Integer 的内部类，其代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 简单的说，如果整型字面量的值在 - 128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的 Integer 对象，所以上面的面试题中 f1==f2 的结果是 true，而 f3==f4 的结果是 false。 提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。 8、&amp; 和 &amp;&amp; 的区别？ 答：&amp; 运算符有两种用法：(1) 按位与；(2) 逻辑与。&amp;&amp; 运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。&amp;&amp; 之所以称为短路运算是因为，如果 &amp;&amp; 左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用 &amp;&amp; 而不是 &amp;，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用 &amp; 运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 补充：如果你熟悉 JavaScript，那你可能更能感受到短路运算的强大，想成为 JavaScript 的高手就先从玩转短路运算开始吧。 9、解释内存中的栈 (stack)、堆(heap) 和方法区 (method area) 的用法。 答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”hello” 和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。 String str = new String(“hello”);上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而 “hello” 这个字面量是放在方法区的。 补充 1：较新版本的 Java（从 Java 6 的某个更新开始）中，由于 JIT 编译器的发展和 “逃逸分析” 技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。 补充 2：运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的。 看看下面代码的执行结果是什么并且比较一下 Java 7 以前和以后的运行结果是否一致。 123456String s1 = new StringBuilder(&quot;go&quot;) .append(&quot;od&quot;).toString();System.out.println(s1.intern() == s1);String s2 = new StringBuilder(&quot;ja&quot;) .append(&quot;va&quot;).toString();System.out.println(s2.intern() == s2); 10、Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少？ 答：Math.round(11.5) 的返回值是 12，Math.round(-11.5) 的返回值是 - 11。四舍五入的原理是在参数上加 0.5 然后进行下取整。 11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？ 答：在 Java 5 以前，switch(expr) 中，expr 只能是 byte、short、char、int。从 Java 5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 12、用最有效率的方法计算 2 乘以 8？ 答： 2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。 补充：我们为编写的类重写 hashCode 方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择 31 这个数？前两个问题的答案你可以自己百度一下，选择 31 是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于 (num &lt;&lt; 5) - num，左移 5 位相当于乘以 2 的 5 次方再减去自身就相当于乘以 31，现在的 VM 都能自动完成这个优化。 1234567891011121314151617181920212223242526272829303132333435363738394041public class PhoneNumber &#123; private int areaCode; private String prefix; private String lineNumber; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + areaCode; result = prime * result + ((lineNumber == null) ? 0 : lineNumber.hashCode()); result = prime * result + ((prefix == null) ? 0 : prefix.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PhoneNumber other = (PhoneNumber) obj; if (areaCode != other.areaCode) return false; if (lineNumber == null) &#123; if (other.lineNumber != null) return false; &#125; else if (!lineNumber.equals(other.lineNumber)) return false; if (prefix == null) &#123; if (other.prefix != null) return false; &#125; else if (!prefix.equals(other.prefix)) return false; return true; &#125;&#125; 13、数组有没有 length() 方法？String 有没有 length() 方法？ 答：数组没有 length() 方法，有 length 的属性。String 有 length() 方法。JavaScript 中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。 14、在 Java 中，如何跳出当前的多重嵌套循环？ 答：在最外层循环前加一个标记如 A，然后用 break A; 可以跳出多重循环。（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++ 中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好） 15、构造器（constructor）是否可被重写（override）？ 答：构造器不能被继承，因此不能被重写，但可以被重载。 16、两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对？ 答：不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1) 如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；(2) 如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 补充：关于 equals 和 hashCode 方法，很多 Java 程序都知道，但很多人也就是仅仅知道而已，在 Joshua Bloch 的大作《Effective Java》（很多软件公司，《Effective Java》、《Java 编程思想》以及《重构：改善既有代码质量》是 Java 程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍 equals 方法的：首先 equals 方法必须满足自反性（x.equals(x) 必须返回 true）、对称性（x.equals(y) 返回 true 时，y.equals(x) 也必须返回 true）、传递性（x.equals(y) 和 y.equals(z) 都返回 true 时，x.equals(z) 也必须返回 true）和一致性（当 x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y) 应该得到同样的返回值），而且对于任何非 null 值的引用 x，x.equals(null) 必须返回 false。实现高质量的 equals 方法的诀窍包括：1. 使用 == 操作符检查 “参数是否为这个对象的引用”；2. 使用 instanceof 操作符检查 “参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性；5. 重写 equals 时总是要重写 hashCode；6. 不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉 @Override 注解。 17、是否可以继承 String 类？ 答：String 类是 final 类，不可以被继承。 补充：继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。 18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是按值传递还是按引用传递？ 答：是按值传递。Java 语言的方法调用只支持参数的按值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但在方法内部对对象引用的改变是不会影响到被调用者的。C++ 和 C# 中可以通过传引用或传输出参数来改变传入的参数的值。在 C# 中可以编写如下所示的代码，但是在 Java 中却做不到。 12345678910111213141516171819using System;namespace CS01 &#123; class Program &#123; public static void swap(ref int x, ref int y) &#123; int temp = x; x = y; y = temp; &#125; public static void Main (string[] args) &#123; int a = 5, b = 10; swap (ref a, ref b); // a = 10, b = 5; Console.WriteLine (&quot;a = &#123;0&#125;, b = &#123;1&#125;&quot;, a, b); &#125; &#125;&#125; 说明：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++ 转型为 Java 程序员的开发者无法容忍。 19、String 和 StringBuilder、StringBuffer 的区别？ 答：Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。 面试题 1 - 什么情况下用 + 运算符进行字符串连接比调用 StringBuffer/StringBuilder 对象的 append 方法连接字符串性能更好？ 面试题 2 - 请说出下面程序的输出。 12345678910111213141516class StringEqualTest &#123; public static void main(String[] args) &#123; String s1 = &quot;Programming&quot;; String s2 = new String(&quot;Programming&quot;); String s3 = &quot;Program&quot;; String s4 = &quot;ming&quot;; String s5 = &quot;Program&quot; + &quot;ming&quot;; String s6 = s3 + s4; System.out.println(s1 == s2); System.out.println(s1 == s5); System.out.println(s1 == s6); System.out.println(s1 == s6.intern()); System.out.println(s2 == s2.intern()); &#125;&#125; 补充：解答上面的面试题需要清除两点：1. String 对象的 intern 方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与 String 对象的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2. 字符串的 + 操作其本质是创建了 StringBuilder 对象进行 append 操作，然后将拼接后的 StringBuilder 对象用 toString 方法处理成 String 对象，这一点可以用 javap -c StringEqualTest.class 命令获得 class 文件对应的 JVM 字节码指令就可以看出来。 20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 面试题：华为的面试题中曾经问过这样一个问题 - “为什么不能根据返回类型来区分重载”，快说出你的答案吧！ 因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。 例如： 12float max(int a, int b);int max(int a, int b); 当调用 max(1, 2); 时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。 21、描述一下 JVM 加载 class 文件的原理机制？ 答：JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的. class 文件中的数据读入到内存中，通常是创建一个字节数组读入. class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2) 如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）； Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap； System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中加载类，是用户自定义加载器的默认父加载器。 22、char 型变量中能不能存贮一个中文汉字，为什么？ 答：char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。 补充：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于 C 程序员来说，要完成这样的编码转换恐怕要依赖于 union（联合体 / 共用体）共享内存的特征来实现了。 23、抽象类（abstract class）和接口（interface）有什么异同？ 答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 24、静态嵌套类 (Static Nested Class) 和内部类（Inner Class）的不同？ 答：Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 扑克类（一副扑克） * */public class Poker &#123; private static String[] suites = &#123;&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;&#125;; private static int[] faces = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13&#125;; private Card[] cards; /** * 构造器 * */ public Poker() &#123; cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) &#123; for(int j = 0; j &lt; faces.length; j++) &#123; cards[i * 13 + j] = new Card(suites[i], faces[j]); &#125; &#125; &#125; /** * 洗牌 （随机乱序） * */ public void shuffle() &#123; for(int i = 0, len = cards.length; i &lt; len; i++) &#123; int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; &#125; &#125; /** * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) &#123; return cards[index]; &#125; /** * 卡片类（一张扑克） * [内部类] * */ public class Card &#123; private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) &#123; this.suite = suite; this.face = face; &#125; @Override public String toString() &#123; String faceStr = &quot;&quot;; switch(face) &#123; case 1: faceStr = &quot;A&quot;; break; case 11: faceStr = &quot;J&quot;; break; case 12: faceStr = &quot;Q&quot;; break; case 13: faceStr = &quot;K&quot;; break; default: faceStr = String.valueOf(face); &#125; return suite + faceStr; &#125; &#125;&#125; 测试代码： 1234567891011121314class PokerTest &#123; public static void main(String[] args) &#123; Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A &#125;&#125; 面试题 - 下面的代码哪些地方会产生编译错误？ 123456789101112class Outer &#123; class Inner &#123;&#125; public static void foo() &#123; new Inner(); &#125; public void bar() &#123; new Inner(); &#125; public static void main(String[] args) &#123; new Inner(); &#125;&#125; 注意：Java 中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中 foo 和 main 方法都是静态方法，静态方法中没有 this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： 1new Outer().new Inner(); 25、Java 中会存在内存泄漏吗，请简单描述。 答：理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。例如 Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。 123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.EmptyStackException;public class MyStack&lt;T&#123; private T[] elements; private int size = 0; private static final int INIT_CAPACITY = 16; public MyStack() &#123; elements = (T[]) new Object[INIT_CAPACITY]; &#125; public void push(T elem) &#123; ensureCapacity(); elements[size++] = elem; &#125; public T pop() &#123; if(size == 0) throw new EmptyStackException(); return elements[--size]; &#125; private void ensureCapacity() &#123; if(elements.length == size) &#123; elements = Arrays.copyOf(elements, 2 * size + 1); &#125; &#125;&#125; 上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的 pop 方法却存在内存泄露的问题，当我们用 pop 方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发 Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成 OutOfMemoryError。 26、抽象的（abstract）方法是否可同时是静态的（static）, 是否可同时是本地方法（native），是否可同时被 synchronized 修饰？ 答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 27、阐述静态变量和实例变量的区别。 答：静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。 28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？ 答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。 29、如何实现对象克隆？ 答：有两种方式： 1). 实现 Cloneable 接口并重写 Object 类中的 clone() 方法； 2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下： 1234567891011121314151617181920212223242526import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T extends SerializableT clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 &#125;&#125; 下面是测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.io.Serializable;/** * 人类 * @author nnngu * */class Person implements Serializable &#123; private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) &#123; this.name = name; this.age = age; this.car = car; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return &quot;Person []&quot;; &#125;&#125;/** * 小汽车类 * @author nnngu * */class Car implements Serializable &#123; private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) &#123; this.brand = brand; this.maxSpeed = maxSpeed; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, maxSpeed=&quot; + maxSpeed + &quot;]&quot;; &#125;&#125;class CloneTest &#123; public static void main(String[] args) &#123; try &#123; Person p1 = new Person(&quot;郭靖&quot;, 33, new Car(&quot;Benz&quot;, 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand(&quot;BYD&quot;); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 30、GC 是什么？为什么要有 GC？ 答：GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显式操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显式的垃圾回收调用。 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的 Java 进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和清除，但是 Java 对其进行了改进，采用 “分代式垃圾收集”。这种方法会根据 Java 对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。 与垃圾回收相关的 JVM 参数： -Xms / -Xmx — 堆的初始大小 / 堆的最大大小 -Xmn — 堆中年轻代的大小 -XX:-DisableExplicitGC — 让 System.gc() 不产生任何作用 -XX:+PrintGCDetails — 打印 GC 的细节 -XX:+PrintGCDateStamps — 打印 GC 操作的时间戳 -XX:NewSize / XX:MaxNewSize — 设置新生代大小 / 新生代最大大小 -XX:NewRatio — 可以设置老生代和新生代的比例 -XX:PrintTenuringDistribution — 设置每次新生代 GC 后输出幸存者乐园中对象年龄的分布 -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值 -XX:TargetSurvivorRatio：设置幸存区的目标使用率 31、String s = new String(“xyz”); 创建了几个字符串对象？ 答：两个对象，一个是静态区的 “xyz”，一个是用 new 创建在堆上的对象。 32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 答：接口可以继承接口，而且支持多重继承。抽象类可以实现 (implements) 接口，抽象类可继承具体类也可以继承抽象类。 举一个多继承的例子，我们定义一个动物（类）既是狗（父类 1）也是猫（父类 2），两个父类都有 “叫” 这个方法。那么当我们调用 “叫” 这个方法时，它就不知道是狗叫还是猫叫了，这就是多重继承的冲突。而接口没有具体的方法实现，所以多继承接口也不会出现这种冲突。 33、一个 “.java” 源文件中是否可以包含多个类（不是内部类）？有什么限制？ 答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。 34、Anonymous Inner Class(匿名内部类) 是否可以继承其它类？是否可以实现接口？ 答：可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来实现事件监听和回调。 35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。 36、Java 中的 final 关键字有哪些用法？ 答：(1) 修饰类：表示该类不能被继承；(2) 修饰方法：表示方法不能被重写；(3) 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 37、指出下面程序的运行结果。 123456789101112131415161718192021222324252627282930class A &#123; static &#123; System.out.print(&quot;1&quot;); &#125; public A() &#123; System.out.print(&quot;2&quot;); &#125;&#125;class B extends A&#123; static &#123; System.out.print(&quot;a&quot;); &#125; public B() &#123; System.out.print(&quot;b&quot;); &#125;&#125;public class Hello &#123; public static void main(String[] args) &#123; A ab = new B(); ab = new B(); &#125;&#125; 答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。 提示：如果不能给出此题的正确答案，说明之前第 21 题 Java 类加载机制还没有完全理解，赶紧再看看吧。 38、数据类型之间的转换： 如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？ 答： 调用基本数据类型对应的包装类中的方法 parseXXX(String) 或 valueOf(String) 即可返回相应基本类型； 一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用 String 类中的 valueOf() 方法返回相应字符串 39、如何实现字符串的反转及替换？ 答：方法很多，可以自己写实现也可以使用 String 或 StringBuffer/StringBuilder 中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示： 12345public static String reverse(String originStr) &#123; if(originStr == null || originStr.length() &lt;= 1) return originStr; return reverse(originStr.substring(1)) + originStr.charAt(0);&#125; 40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？ 答：代码如下所示： 12String s1 = &quot;你好&quot;;String s2 = new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;); 41、日期和时间： 如何取得年月日、小时分钟秒？如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？如何取得某月的最后一天？如何格式化日期？ 答： 问题 1：创建 java.util.Calendar 实例，调用其 get() 方法传入不同的参数即可获得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTimel 来获取，代码如下所示。 1234567891011121314151617181920public class DateTimeTest &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.println(cal.get(Calendar.YEAR)); System.out.println(cal.get(Calendar.MONTH)); // 0 - 11 System.out.println(cal.get(Calendar.DATE)); System.out.println(cal.get(Calendar.HOUR_OF_DAY)); System.out.println(cal.get(Calendar.MINUTE)); System.out.println(cal.get(Calendar.SECOND)); // Java 8 LocalDateTime dt = LocalDateTime.now(); System.out.println(dt.getYear()); System.out.println(dt.getMonthValue()); // 1 - 12 System.out.println(dt.getDayOfMonth()); System.out.println(dt.getHour()); System.out.println(dt.getMinute()); System.out.println(dt.getSecond()); &#125;&#125; 问题 2：以下方法均可获得该毫秒数。 123Calendar.getInstance().getTimeInMillis();System.currentTimeMillis();Clock.systemDefaultZone().millis(); // Java 8 问题 3：代码如下所示。 12Calendar time = Calendar.getInstance();time.getActualMaximum(Calendar.DAY_OF_MONTH); 问题 4：利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的 format(Date) 方法可将日期格式化。Java 8 中可以用 java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。 123456789101112131415161718import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.format.DateTimeFormatter;import java.util.Date;class DateFormatTest &#123; public static void main(String[] args) &#123; SimpleDateFormat oldFormatter = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); Date date1 = new Date(); System.out.println(oldFormatter.format(date1)); // Java 8 DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;); LocalDate date2 = LocalDate.now(); System.out.println(date2.format(newFormatter)); &#125;&#125; 补充：Java 的时间日期 API 一直以来都是被诟病的东西，为了解决这一问题，Java 8 中引入了新的时间日期 API，其中包括 LocalDate、LocalTime、LocalDateTime、Clock、Instant 等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。 42、打印昨天的当前时刻。 123456789import java.util.Calendar;class YesterdayCurrent &#123; public static void main(String[] args)&#123; Calendar cal = Calendar.getInstance(); cal.add(Calendar.DATE, -1); System.out.println(cal.getTime()); &#125;&#125; 在 Java 8 中，可以用下面的代码实现相同的功能。 1234567891011import java.time.LocalDateTime;class YesterdayCurrent &#123; public static void main(String[] args) &#123; LocalDateTime today = LocalDateTime.now(); LocalDateTime yesterday = today.minusDays(1); System.out.println(yesterday); &#125;&#125; 43、比较一下 Java 和 JavaSciprt。 答：JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。 下面对两种语言间的异同作如下比较： 基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率） 强类型变量和弱类型变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行时检查推断其数据类型。 代码格式不一样。补充：上面列出的四点是网上流传的所谓的标准答案。其实 Java 和 JavaScript 最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在 Java 中类（class）是一等公民，而 JavaScript 中函数（function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda 函数和闭包（closure），当然 Java 8 也开始支持函数式编程，提供了对 Lambda 表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。 44、什么时候用断言（assert）？ 答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表达式的值为 false，那么系统会报告一个 AssertionError。断言的使用如下面的代码所示： 1assert(a 0); // throws an AssertionError if a &lt;= 0 断言可以有两种形式： 1234assert Expression1;assert Expression1 : Expression2 ;Expression1 应该总是产生一个布尔值。Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。 要在运行时启用断言，可以在启动 JVM 时使用 - enableassertions 或者 - ea 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 - da 或者 - disableassertions 标记。要在系统类中启用或禁用断言，可使用 - esa 或 - dsa 标记。还可以在包的基础上启用或者禁用断言。 注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。 45、Error 和 Exception 有什么区别 #？ 答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。 面试题：2005 年摩托罗拉的面试中曾经问过这么一个问题 “If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项 a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java 程序在运行时也可能会遭遇 StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是 c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示： 123456class StackOverflowErrorTest &#123; public static void main(String[] args) &#123; main(null); &#125;&#125; 提示：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）。 46、try{} 里有一个 return 语句，那么紧跟在这个 try 后的 finally{} 里的代码会不会被执行，什么时候被执行，在 return 前还是后? 答：会执行，在方法返回前执行。 注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C# 中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse 中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。 47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？ 答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。一般情况下是用 try 来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try 用来指定一块预防所有异常的程序；catch 子句紧跟在 try 块后面，用来指定你想要捕获的异常的类型；throw 语句用来明确地抛出一个异常；throws 用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally 为确保一段代码不管发生什么异常状况都要被执行；try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常栈中，直到所有的 try 语句都完成。如果下一级的 try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者最终将异常抛给 JVM。 48、运行时异常与受检异常有何异同？ 答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用给出了以下指导原则： 不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常） 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 优先使用标准的异常 每个方法抛出的异常都要有文档 保持异常的原子性 不要在 catch 中忽略掉捕获到的异常 49、列出一些你常见的运行时异常？ 答： ArithmeticException（算术异常） ClassCastException （类转换异常） IllegalArgumentException （非法参数异常） IndexOutOfBoundsException （下标越界异常） NullPointerException （空指针异常） SecurityException （安全异常） 50、阐述 final、finally、finalize 的区别。 答： final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方法也同样只能使用，不能在子类中被重写。 finally：通常放在 try…catch… 的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。 finalize：Object 类中定义的方法，Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。 51、类 ExampleA 继承 Exception，类 ExampleB 继承 ExampleA。 有如下代码片断： 1234567try &#123; throw new ExampleB(&quot;b&quot;)&#125; catch（ExampleA e）&#123; System.out.println(&quot;ExampleA&quot;);&#125; catch（Exception e）&#123; System.out.println(&quot;Exception&quot;);&#125; 请问执行此段代码的输出是什么？ 答：输出：ExampleA。（根据里氏代换原则 [能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常） 面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书） 12345678910111213141516171819202122232425class Annoyance extends Exception &#123;&#125;class Sneeze extends Annoyance &#123;&#125;class Human &#123; public static void main(String[] args) throws Exception &#123; try &#123; try &#123; throw new Sneeze(); &#125; catch ( Annoyance a ) &#123; System.out.println(&quot;Caught Annoyance&quot;); throw a; &#125; &#125; catch ( Sneeze s ) &#123; System.out.println(&quot;Caught Sneeze&quot;); return ; &#125; finally &#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;&#125; 52、List、Set、Map 是否继承自 Collection 接口？ 答：List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。 53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。 答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 补充：遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，Properties 是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个 Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中的 Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或 Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun 公司的工程师们也会犯这种低级错误，让人唏嘘不已。 54、Collection 和 Collections 的区别？ 答：Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。 55、List、Map、Set 三个接口存取元素时，各有什么特点？ 答：List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals() 方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 56、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort() 方法如何比较元素？ 答：TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo() 方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象必须实现 Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。例子 1： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Student implements Comparable&lt;Student&#123; private String name; // 姓名 private int age; // 年龄 public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student []&quot;; &#125; @Override public int compareTo(Student o) &#123; return this.age - o.age; // 比较年龄(年龄的升序) &#125;&#125;import java.util.Set;import java.util.TreeSet;class Test01 &#123; public static void main(String[] args) &#123; Set&lt;Studentset = new TreeSet&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) set.add(new Student(&quot;Hao LUO&quot;, 33)); set.add(new Student(&quot;XJ WANG&quot;, 32)); set.add(new Student(&quot;Bruce LEE&quot;, 60)); set.add(new Student(&quot;Bob YANG&quot;, 22)); for(Student stu : set) &#123; System.out.println(stu); &#125;// 输出结果: // Student [name=Bob YANG, age=22]// Student [name=XJ WANG, age=32]// Student [name=Hao LUO, age=33]// Student [name=Bruce LEE, age=60] &#125;&#125; 例子 2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Student &#123; private String name; // 姓名 private int age; // 年龄 public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; /** * 获取学生姓名 */ public String getName() &#123; return name; &#125; /** * 获取学生年龄 */ public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;Student []&quot;; &#125;&#125;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;class Test02 &#123; public static void main(String[] args) &#123; List&lt;Studentlist = new ArrayList&lt;&gt;(); // Java 7的钻石语法(构造器后面的尖括号中不需要写类型) list.add(new Student(&quot;Hao LUO&quot;, 33)); list.add(new Student(&quot;XJ WANG&quot;, 32)); list.add(new Student(&quot;Bruce LEE&quot;, 60)); list.add(new Student(&quot;Bob YANG&quot;, 22)); // 通过sort方法的第二个参数传入一个Comparator接口对象 // 相当于是传入一个比较对象大小的算法到sort方法中 // 由于Java中没有函数指针、仿函数、委托这样的概念 // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调 Collections.sort(list, new Comparator&lt;Student() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getName().compareTo(o2.getName()); // 比较学生姓名 &#125; &#125;); for(Student stu : list) &#123; System.out.println(stu); &#125;// 输出结果: // Student [name=Bob YANG, age=22]// Student [name=Bruce LEE, age=60]// Student [name=Hao LUO, age=33]// Student [name=XJ WANG, age=32] &#125;&#125; 57、Thread 类的 sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别? 答：sleep() 方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第 66 题中的线程状态转换图）。wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。时下很时髦的 Node.js 就采用了单线程异步 I/O 的工作模式。 58、线程的 sleep() 方法和 yield() 方法有什么区别？ 答： ① sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（ready）状态； ③ sleep() 方法声明抛出 InterruptedException，而 yield() 方法没有声明任何异常； ④ sleep() 方法比 yield() 方法（跟操作系统 CPU 调度相关）具有更好的可移植性。 59、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？ 答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。 60、请说出与线程同步以及线程调度相关的方法。 答： wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 补充：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition() 方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire() 方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release() 方法）。 下面的例子演示了 100 个线程同时向一个银行账户中存入 1 元钱，在没有使用同步机制和使用同步机制情况下的执行情况。 银行账户类： 123456789101112131415161718192021222324252627282930/** * 银行账户 * @author nnngu * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 存钱线程类： 1234567891011121314151617181920/** * 存钱线程 * @author nnngu * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; account.deposit(money); &#125;&#125; 测试类： 1234567891011121314151617181920import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test01 &#123; public static void main(String[] args) &#123; Account account = new Account(); ExecutorService service = Executors.newFixedThreadPool(100); for(int i = 1; i &lt;= 100; i++) &#123; service.execute(new AddMoneyThread(account, 1)); &#125; service.shutdown(); while(!service.isTerminated()) &#123;&#125; System.out.println(&quot;账户余额: &quot; + account.getBalance()); &#125;&#125; 在没有同步的情况下，执行结果通常是显示账户余额在 10 元以下，出现这种状况的原因是，当一个线程 A 试图存入 1 元的时候，另外一个线程 B 也能够进入存款的方法中，线程 B 读取到的账户余额仍然是线程 A 存入 1 元钱之前的账户余额，因此也是在原来的余额 0 上面做了加 1 元的操作，同理线程 C 也会做类似的事情，所以最后 100 个线程执行结束时，本来期望账户余额为 100 元，但实际得到的通常在 10 元以下（很可能是 1 元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案： 在银行账户的存款（deposit）方法上加同步（synchronized）关键字 123456789101112131415161718192021222324252627282930/** * 银行账户 * @author nnngu * */public class Account &#123; private double balance; // 账户余额 /** * 存款 * @param money 存入金额 */ public synchronized void deposit(double money) &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch(InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 在线程调用存款方法时对银行账户进行同步 12345678910111213141516171819202122/** * 存钱线程 * @author nnngu * */public class AddMoneyThread implements Runnable &#123; private Account account; // 存入账户 private double money; // 存入金额 public AddMoneyThread(Account account, double money) &#123; this.account = account; this.money = money; &#125; @Override public void run() &#123; synchronized (account) &#123; account.deposit(money); &#125; &#125;&#125; 通过 Java 5 显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 银行账户 * * @author nnngu * */public class Account &#123; private Lock accountLock = new ReentrantLock(); private double balance; // 账户余额 /** * 存款 * * @param money * 存入金额 */ public void deposit(double money) &#123; accountLock.lock(); try &#123; double newBalance = balance + money; try &#123; Thread.sleep(10); // 模拟此业务需要一段处理时间 &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; balance = newBalance; &#125; finally &#123; accountLock.unlock(); &#125; &#125; /** * 获得账户余额 */ public double getBalance() &#123; return balance; &#125;&#125; 按照上述三种方式对代码进行修改后，重写执行测试代码 Test01，将看到最终的账户余额为 100 元。当然也可以使用 Semaphore 或 CountdownLatch 来实现同步。 61、编写多线程程序有几种实现方式？ 答：Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一种是实现 Runnable 接口。两种方式都要通过重写 run() 方法来定义线程的行为，推荐使用后者，因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其他类了，显然使用 Runnable 接口更为灵活。 补充：Java 5 以后创建线程还有第三种方式：实现 Callable 接口，该接口中的 call 方法可以在线程执行结束时产生一个返回值，代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;class MyTask implements Callable&lt;Integer&#123; private int upperBounds; public MyTask(int upperBounds) &#123; this.upperBounds = upperBounds; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for(int i = 1; i &lt;= upperBounds; i++) &#123; sum += i; &#125; return sum; &#125;&#125;class Test &#123; public static void main(String[] args) throws Exception &#123; List&lt;Future&lt;Integer&gt;list = new ArrayList&lt;&gt;(); ExecutorService service = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; i++) &#123; list.add(service.submit(new MyTask((int) (Math.random() * 100)))); &#125; int sum = 0; for(Future&lt;Integerfuture : list) &#123; // while(!future.isDone()) ; sum += future.get(); &#125; System.out.println(sum); &#125;&#125; 62、synchronized 关键字的用法？ 答：synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用 synchronized(对象) { … } 定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。在第 60 题的例子中已经展示了 synchronized 关键字的用法。 63、举例说明同步和异步。 答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。 64、启动一个线程是调用 run() 还是 start() 方法？ 答：启动一个线程是调用 start() 方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run() 方法是线程启动后要进行回调（callback）的方法。 65、什么是线程池（thread pool）？ 答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是” 池化资源” 技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 Java 5 + 中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 里面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。第 60 题的例子中演示了通过 Executors 工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用 newFixedThreadPool 方法来创建线程池，这样能获得更好的性能。 66、线程的基本状态以及状态之间的关系？ 答： 说明：其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait() 方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了 sleep() 方法或 join() 方法等待休眠或其他线程结束，或是因为发生了 I/O 中断。 67、简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？ 答：Lock 是 Java 5 以后引入的新的 API，和关键字 synchronized 相比主要相同点：Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。 68、Java 中如何实现序列化，有什么意义？ 答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object) 方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第 29 题）。 69、Java 中有几种类型的流？ 答：字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承于 Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于 Java 的 I/O 需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外 Java 中的流不同于 C# 的是它只有一个维度一个方向。 面试题 - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案） 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public final class MyUtil &#123; private MyUtil() &#123; throw new AssertionError(); &#125; public static void fileCopy(String source, String target) throws IOException &#123; try (InputStream in = new FileInputStream(source)) &#123; try (OutputStream out = new FileOutputStream(target)) &#123; byte[] buffer = new byte[4096]; int bytesToRead; while((bytesToRead = in.read(buffer)) != -1) &#123; out.write(buffer, 0, bytesToRead); &#125; &#125; &#125; &#125; public static void fileCopyNIO(String source, String target) throws IOException &#123; try (FileInputStream in = new FileInputStream(source)) &#123; try (FileOutputStream out = new FileOutputStream(target)) &#123; FileChannel inChannel = in.getChannel(); FileChannel outChannel = out.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(4096); while(inChannel.read(buffer) != -1) &#123; buffer.flip(); outChannel.write(buffer); buffer.clear(); &#125; &#125; &#125; &#125;&#125; 注意：上面用到 Java 7 的 TWR，使用 TWR 后可以不用在 finally 中释放外部资源 ，从而让代码更加优雅。 70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。 答：代码如下： 12345678910111213141516171819202122232425262728293031323334353637import java.io.BufferedReader;import java.io.FileReader;public final class MyUtil &#123; // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯) private MyUtil() &#123; throw new AssertionError(); &#125; /** * 统计给定文件中给定字符串的出现次数 * * @param filename 文件名 * @param word 字符串 * @return 字符串在文件中出现的次数 */ public static int countWordInFile(String filename, String word) &#123; int counter = 0; try (FileReader fr = new FileReader(filename)) &#123; try (BufferedReader br = new BufferedReader(fr)) &#123; String line = null; while ((line = br.readLine()) != null) &#123; int index = -1; while (line.length() &gt;= word.length() &amp;&amp; (index = line.indexOf(word)) &gt;= 0) &#123; counter++; line = line.substring(index + word.length()); &#125; &#125; &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return counter; &#125;&#125; 71、如何用 Java 代码列出一个目录下所有的文件？ 答： 如果只要求列出当前文件夹下的文件，代码如下所示： 12345678910111213import java.io.File;class Test12 &#123; public static void main(String[] args) &#123; File f = new File(&quot;/Users/nnngu/Downloads&quot;); for(File temp : f.listFiles()) &#123; if(temp.isFile()) &#123; System.out.println(temp.getName()); &#125; &#125; &#125;&#125; 如果需要对文件夹继续展开，代码如下所示： 1234567891011121314151617181920212223242526import java.io.File;class Test12 &#123; public static void main(String[] args) &#123; showDirectory(new File(&quot;/Users/nnngu/Downloads&quot;)); &#125; public static void showDirectory(File f) &#123; _walkDirectory(f, 0); &#125; private static void _walkDirectory(File f, int level) &#123; if(f.isDirectory()) &#123; for(File temp : f.listFiles()) &#123; _walkDirectory(temp, level + 1); &#125; &#125; else &#123; for(int i = 0; i &lt; level - 1; i++) &#123; System.out.print(&quot;\t&quot;); &#125; System.out.println(f.getName()); &#125; &#125;&#125; 在 Java 7 中可以使用 NIO.2 的 API 来做同样的事情，代码如下所示： 12345678910111213141516class ShowFileTest &#123; public static void main(String[] args) throws IOException &#123; Path initPath = Paths.get(&quot;/Users/nnngu/Downloads&quot;); Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println(file.getFileName().toString()); return FileVisitResult.CONTINUE; &#125; &#125;); &#125;&#125; 72、用 Java 的套接字编程实现一个多线程的回显（echo）服务器。 答： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class EchoServer &#123; private static final int ECHO_SERVER_PORT = 6789; public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) &#123; System.out.println(&quot;服务器已经启动...&quot;); while(true) &#123; Socket client = server.accept(); new Thread(new ClientHandler(client)).start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private static class ClientHandler implements Runnable &#123; private Socket client; public ClientHandler(Socket client) &#123; this.client = client; &#125; @Override public void run() &#123; try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter pw = new PrintWriter(client.getOutputStream())) &#123; String msg = br.readLine(); System.out.println(&quot;收到&quot; + client.getInetAddress() + &quot;发送的: &quot; + msg); pw.println(msg); pw.flush(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意：上面的代码使用了 Java 7 的 TWR 语法，由于很多外部资源类都间接的实现了 AutoCloseable 接口（单方法回调接口），因此可以利用 TWR 语法在 try 结束的时候通过回调的方式自动调用外部资源类的 close() 方法，避免书写冗长的 finally 代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户 I/O 操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。 下面是一段回显客户端测试代码： 12345678910111213141516171819202122import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class EchoClient &#123; public static void main(String[] args) throws Exception &#123; Socket client = new Socket(&quot;localhost&quot;, 6789); Scanner sc = new Scanner(System.in); System.out.print(&quot;请输入内容: &quot;); String msg = sc.nextLine(); sc.close(); PrintWriter pw = new PrintWriter(client.getOutputStream()); pw.println(msg); pw.flush(); BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println(br.readLine()); client.close(); &#125;&#125; 如果希望用 NIO 的多路复用套接字实现服务器，代码如下所示。NIO 的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;public class EchoServerNIO &#123; private static final int ECHO_SERVER_PORT = 6789; private static final int ECHO_SERVER_TIMEOUT = 5000; private static final int BUFFER_SIZE = 1024; private static ServerSocketChannel serverChannel = null; private static Selector selector = null; // 多路复用选择器 private static ByteBuffer buffer = null; // 缓冲区 public static void main(String[] args) &#123; init(); listen(); &#125; private static void init() &#123; try &#123; serverChannel = ServerSocketChannel.open(); buffer = ByteBuffer.allocate(BUFFER_SIZE); serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT)); serverChannel.configureBlocking(false); selector = Selector.open(); serverChannel.register(selector, SelectionKey.OP_ACCEPT); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private static void listen() &#123; while (true) &#123; try &#123; if (selector.select(ECHO_SERVER_TIMEOUT) != 0) &#123; Iterator&lt;SelectionKeyit = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); it.remove(); handleKey(key); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void handleKey(SelectionKey key) throws IOException &#123; SocketChannel channel = null; try &#123; if (key.isAcceptable()) &#123; ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel(); channel = serverChannel.accept(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; channel = (SocketChannel) key.channel(); buffer.clear(); if (channel.read(buffer) 0) &#123; buffer.flip(); CharBuffer charBuffer = CharsetHelper.decode(buffer); String msg = charBuffer.toString(); System.out.println(&quot;收到&quot; + channel.getRemoteAddress() + &quot;的消息：&quot; + msg); channel.write(CharsetHelper.encode(CharBuffer.wrap(msg))); &#125; else &#123; channel.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if (channel != null) &#123; channel.close(); &#125; &#125; &#125;&#125;import java.nio.ByteBuffer;import java.nio.CharBuffer;import java.nio.charset.CharacterCodingException;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.charset.CharsetEncoder;public final class CharsetHelper &#123; private static final String UTF_8 = &quot;UTF-8&quot;; private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder(); private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder(); private CharsetHelper() &#123; &#125; public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException&#123; return encoder.encode(in); &#125; public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException&#123; return decoder.decode(in); &#125;&#125; 73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？ 答：XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束，其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。对 XML 的解析主要有 DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和 StAX（Java 6 中引入的新的解析 XML 的方式，Streaming API for XML），其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构占用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）；SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问；顾名思义，StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程序能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新颖（SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 74、你在项目中哪些地方用到了 XML？ 答：XML 的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML 将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从 XML 文件中还原相关信息进行处理，XML 曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被 JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用 XML 来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在 XML 文件中，Java 的很多框架也是这么做的，而且这些框架都选择了 dom4j 作为处理 XML 的工具，因为 Sun 公司的官方 API 实在不怎么好用。 补充：现在有很多时髦的软件（如 Sublime）已经开始将配置文件书写成 JSON 格式，我们已经强烈的感受到 XML 的另一项功能也将逐渐被业界抛弃。 75、阐述 JDBC 操作数据库的步骤。 答：下面的代码以连接本机的 Oracle 数据库为例，演示 JDBC 操作数据库的步骤。 123456789101112131415161718192021222324252627282930加载驱动。Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);创建连接。Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;, &quot;scott&quot;, &quot;tiger&quot;);创建语句。PreparedStatement ps = con.prepareStatement(&quot;select * from emp where sal between ? and ?&quot;);ps.setInt(1, 1000);ps.setInt(2, 3000);执行语句。ResultSet rs = ps.executeQuery();处理结果。while(rs.next()) &#123; System.out.println(rs.getInt(&quot;empno&quot;) + &quot; - &quot; + rs.getString(&quot;ename&quot;));&#125;关闭资源。 finally &#123; if(con != null) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 提示：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。 76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？ 答：与 Statement 相比，①PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可能性）；②PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；③当批量处理 SQL 或频繁执行相同的查询时，PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的 SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。 补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。 77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ 答：要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize() 方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。 78、在进行数据库编程时，连接池有什么作用？ 答：由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在 Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等。 补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。 79、什么是 DAO 模式？ 答：DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO 模式实际上包含了两个模式，一是 Data Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。 80、事务的 ACID 是指什么？ 答： 原子性 (Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； 一致性 (Consistent)：事务结束后系统状态是一致的； 隔离性 (Isolated)：并发执行的事务彼此无法看到对方的中间状态； 持久性 (Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。补充：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题（第 1 类丢失更新和第 2 类丢失更新）。 脏读（Dirty Read）：A 事务读取 B 事务尚未提交的数据并在此基础上操作，而 B 事务执行回滚，那么 A 读取到的数据就是脏数据。 不可重复读（Unrepeatable Read）：事务 A 重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务 B 修改过了。 幻读（Phantom Read）：事务 A 重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务 B 提交的行。 第 1 类丢失更新：事务 A 撤销时，把已经提交的事务 B 的更新数据覆盖了。 第 2 类丢失更新：事务 A 覆盖事务 B 已经提交的数据，造成事务 B 所做的操作丢失。 数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。 直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析 SQL 语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92 标准定义了 4 个等级的事务隔离级别，如下表所示： 隔离级别 脏读 不可重复读 幻读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED 允许 允许 允许 不允许 允许 READCOMMITTED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZABLE 不允许 不允许 不允许 不允许 不允许 需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。 81、JDBC 中如何进行事务处理？ 答：Connection 提供了事务处理的方法，通过调用 setAutoCommit(false) 可以设置手动提交事务；当事务完成后用 commit() 显式提交事务；如果在事务处理过程中发生异常则通过 rollback() 进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。 82、JDBC 能否处理 Blob 和 Clob？ 答： Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Objec），因此其中 Blob 是为存储大的二进制数据而设计的，而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和 ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。下面的代码展示了如何使用 JDBC 操作 LOB： 下面以 MySQL 数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下： 123456create table tb_user(id int primary key auto_increment,name varchar(20) unique not null,photo longblob); 下面的 Java 代码向数据库中插入一条记录： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;class JdbcLobTest &#123; public static void main(String[] args) &#123; Connection con = null; try &#123; // 1\. 加载驱动（Java6以上版本可以省略） Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2\. 建立连接 con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;); // 3\. 创建语句对象 PreparedStatement ps = con.prepareStatement(&quot;insert into tb_user values (default, ?, ?)&quot;); ps.setString(1, &quot;郭靖&quot;); // 将SQL语句中第一个占位符换成字符串 try (InputStream in = new FileInputStream(&quot;test.jpg&quot;)) &#123; // Java 7的TWR ps.setBinaryStream(2, in); // 将SQL语句中第二个占位符换成二进制流 // 4\. 发出SQL语句获得受影响行数 System.out.println(ps.executeUpdate() == 1 ? &quot;插入成功&quot; : &quot;插入失败&quot;); &#125; catch(IOException e) &#123; System.out.println(&quot;读取照片失败!&quot;); &#125; &#125; catch (ClassNotFoundException | SQLException e) &#123; // Java 7的多异常捕获 e.printStackTrace(); &#125; finally &#123; // 释放外部资源的代码都应当放在finally中保证其能够得到执行 try &#123; if(con != null &amp;&amp; !con.isClosed()) &#123; con.close(); // 5\. 释放数据库连接 con = null; // 指示垃圾回收器可以回收该对象 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 83、简述正则表达式及其用途。 答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。 84、Java 中是如何支持正则表达式操作的？ 答：Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作，请参考下面面试题的代码。 面试题： - 如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市 (朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？ 1234567891011121314import java.util.regex.Matcher;import java.util.regex.Pattern;class RegExpTest &#123; public static void main(String[] args) &#123; String str = &quot;北京市(朝阳区)(西城区)(海淀区)&quot;; Pattern p = Pattern.compile(&quot;.*?(?=\\()&quot;); Matcher m = p.matcher(str); if(m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125; 说明：上面的正则表达式中使用了懒惰匹配和前瞻，如果不清楚这些内容，推荐读一下网上很有名的《正则表达式 30 分钟入门教程》。 85、获得一个类的类对象有哪些方式？ 答： 方法 1：类型. class，例如：String.class 方法 2：对象. getClass()，例如：”hello”.getClass() 方法 3：Class.forName()，例如：Class.forName(“java.lang.String”) 86、如何通过反射创建对象？ 答： 方法 1：通过类对象调用 newInstance() 方法，例如：String.class.newInstance() 方法 2：通过类对象的 getConstructor() 或 getDeclaredConstructor() 方法获得构造器（Constructor）对象并调用其 newInstance() 方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 87、如何通过反射获取和设置对象私有字段的值？ 答：可以通过类对象的 getDeclaredField() 方法获得字段（Field）对象，然后再通过字段对象的 setAccessible(true) 将其设置为可以访问，接下来就可以通过 get/set 方法来获取 / 设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如 ReflectionUtil.get(dog, “owner.car.engine.id”); 可以获得 dog 对象的主人的汽车的引擎的 ID 号。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.ArrayList;import java.util.List;/** * 反射工具类 * @author nnngu * */public class ReflectionUtil &#123; private ReflectionUtil() &#123; throw new AssertionError(); &#125; /** * 通过反射取对象指定字段(属性)的值 * @param target 目标对象 * @param fieldName 字段的名字 * @throws 如果取不到对象指定字段的值则抛出异常 * @return 字段的值 */ public static Object getValue(Object target, String fieldName) &#123; Class&lt;?clazz = target.getClass(); String[] fs = fieldName.split(&quot;\\.&quot;); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); target = f.get(target); clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); return f.get(target); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 通过反射给对象的指定字段赋值 * @param target 目标对象 * @param fieldName 字段的名称 * @param value 值 */ public static void setValue(Object target, String fieldName, Object value) &#123; Class&lt;?clazz = target.getClass(); String[] fs = fieldName.split(&quot;\\.&quot;); try &#123; for(int i = 0; i &lt; fs.length - 1; i++) &#123; Field f = clazz.getDeclaredField(fs[i]); f.setAccessible(true); Object val = f.get(target); if(val == null) &#123; Constructor&lt;?c = f.getType().getDeclaredConstructor(); c.setAccessible(true); val = c.newInstance(); f.set(target, val); &#125; target = val; clazz = target.getClass(); &#125; Field f = clazz.getDeclaredField(fs[fs.length - 1]); f.setAccessible(true); f.set(target, value); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 88、如何通过反射调用对象的方法？ 答：请看下面的代码： 12345678910import java.lang.reflect.Method;class MethodInvokeTest &#123; public static void main(String[] args) throws Exception &#123; String str = &quot;hello&quot;; Method m = str.getClass().getMethod(&quot;toUpperCase&quot;); System.out.println(m.invoke(str)); // HELLO &#125;&#125; 89、简述一下面向对象的 “六原则一法则”。 答： 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是 “高内聚”，写代码最终极的原则只有六个字 “高内聚、低耦合”，就如同葵花宝典或辟邪剑谱的中心思想就八个字 “欲练此功必先自宫”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫 “因为专注，所以专业”，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而混乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。） 里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A 关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到 “低耦合”，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web 开发中作为前端控制器的 Servlet 或 Filter 不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。） 90、简述一下你了解的设计模式。 答：所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 在 GoF 的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型 [对类的实例化过程的抽象化]、结构型 [描述如何将类或对象结合在一起形成更大的结构]、行为型 [对在不同的对象之间划分责任和算法的抽象化]）共 23 种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。 面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。 除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections 工具类和 I/O 系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。 91、用 Java 写一个单例类。 答： 饿汉式单例 1234567public class Singleton &#123; private Singleton()&#123;&#125; private static Singleton instance = new Singleton(); public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉式单例 12345678public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123;&#125; public static synchronized Singleton getInstance()&#123; if (instance == null) instance ＝ new Singleton(); return instance; &#125;&#125; 注意：实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring 的 IoC 容器可以为普通的类创建单例，它是怎么做到的呢？ 92、什么是 UML？ 答：UML 是统一建模语言（Unified Modeling Language）的缩写，它发表于 1997 年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用 UML 可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。 93、UML 中有哪些常用的图？ 答：UML 定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。 用例图： 类图： 时序图： 94、用 Java 写一个冒泡排序。 答：冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Comparator;/** * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换) * @author nnngu * */public interface Sorter &#123; /** * 排序 * @param list 待排序的数组 */ public &lt;T extends Comparable&lt;T&gt;void sort(T[] list); /** * 排序 * @param list 待排序的数组 * @param comp 比较两个对象的比较器 */ public &lt;Tvoid sort(T[] list, Comparator&lt;Tcomp);&#125;import java.util.Comparator;/** * 冒泡排序 * * @author nnngu * */public class BubbleSorter implements Sorter &#123; @Override public &lt;T extends Comparable&lt;T&gt;void sort(T[] list) &#123; boolean swapped = true; for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123; swapped = false; for (int j = 0; j &lt; len - i; ++j) &#123; if (list[j].compareTo(list[j + 1]) 0) &#123; T temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; swapped = true; &#125; &#125; &#125; &#125; @Override public &lt;Tvoid sort(T[] list, Comparator&lt;Tcomp) &#123; boolean swapped = true; for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123; swapped = false; for (int j = 0; j &lt; len - i; ++j) &#123; if (comp.compare(list[j], list[j + 1]) 0) &#123; T temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; swapped = true; &#125; &#125; &#125; &#125;&#125; 95、用 Java 写一个折半查找。 答：折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是 O(logN)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Comparator;public class MyUtil &#123; public static &lt;T extends Comparable&lt;T&gt;int binarySearch(T[] x, T key) &#123; return binarySearch(x, 0, x.length- 1, key); &#125; // 使用循环实现的二分查找 public static &lt;Tint binarySearch(T[] x, T key, Comparator&lt;Tcomp) &#123; int low = 0; int high = x.length - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;1; int cmp = comp.compare(x[mid], key); if (cmp &lt; 0) &#123; low= mid + 1; &#125; else if (cmp 0) &#123; high= mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1; &#125; // 使用递归实现的二分查找 private static&lt;T extends Comparable&lt;T&gt;int binarySearch(T[] x, int low, int high, T key) &#123; if(low &lt;= high) &#123; int mid = low + ((high - low) &gt;1); if(key.compareTo(x[mid])== 0) &#123; return mid; &#125; else if(key.compareTo(x[mid])&lt; 0) &#123; return binarySearch(x,low, mid - 1, key); &#125; else &#123; return binarySearch(x,mid + 1, high, key); &#125; &#125; return -1; &#125;&#125; 说明：上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用 (high+ low) / 2 的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high - low) / 2 或 low + (high – low) &gt;1 或(low + high) &gt;&gt;1（&gt;&gt;&gt; 是逻辑右移，是不带符号位的右移） 转载自：https://www.imooc.com/u/6457959/articles 本文永久更新地址：github.com/nnngu/Learn… 感谢整理者：nnngu]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>待阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 知识点总结69题+25题]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17-1%2F</url>
    <content type="text"><![CDATA[Spring 知识点总结69题1. 什么是 Spring？ Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。 2.Spring 有哪些优点？ 轻量级：Spring 在大小和透明性方面绝对属于轻量级的，基础版本的 Spring 框架大约只有 2MB。 控制反转 (IOC)：Spring 使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。 面向切面编程 (AOP)： Spring 支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。 容器：Spring 包含并管理应用程序对象的配置及生命周期。 MVC 框架：Spring 的 web 框架是一个设计优良的 web MVC 框架，很好的取代了一些 web 框架。 事务管理：Spring 对下至本地业务上至全局业务 (JAT) 提供了统一的事务管理接口。 异常处理：Spring 提供一个方便的 API 将特定技术的异常 (由 JDBC, Hibernate, 或 JDO 抛出) 转化为一致的、Unchecked 异常。 3.Spring 框架有哪些模块？ Spring 框架的基本模块如下所示： Core module Bean module Context module Expression Language module JDBC module ORM module OXM module Java Messaging Service(JMS) module Transaction module Web module Web-Servlet module Web-Struts module Web-Portlet module 4. 解释核心容器 (应用上下文) 模块 这是 Spring 的基本模块，它提供了 Spring 框架的基本功能。BeanFactory 是所有 Spring 应用的核心。Spring 框架是建立在这个模块之上的，这也使得 Spring 成为一个容器。 5.BeanFactory – BeanFactory 实例 BeanFactory 是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。 最常用的 BeanFactory 实现是 XmlBeanFactory 类。 6.XmlBeanFactory 最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory，它根据 XML 文件中定义的内容加载 beans。该容器从 XML 文件中读取配置元数据，并用它来创建一个完备的系统或应用。 7. 解释 AOP 模块 AOP 模块用来开发 Spring 应用程序中具有切面性质的部分。该模块的大部分服务由 AOP Aliance 提供，这就保证了 Spring 框架和其他 AOP 框架之间的互操作性。另外，该模块将元数据编程引入到了 Spring。 8. 解释抽象 JDBC 和 DAO 模块 通过使用抽象 JDBC 和 DAO 模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用 Spring 的 AOP 模块为 Spring 应用程序中的对象提供事务管理服务。 9. 解释对象 / 关系映射集成模块 Spring 通过提供 ORM 模块在 JDBC 的基础上支持对象关系映射工具。这样的支持使得 Spring 可以集成主流的 ORM 框架，包括 Hibernate, JDO, 及 iBATIS SQL Maps。Spring 的事务管理可以同时支持以上某种框架和 JDBC。 10. 解释 web 模块 Spring 的 web 模块建立在应用上下文 (application context) 模块之上，提供了一个适合基于 web 应用程序的上下文环境。该模块还支持了几个面向 web 的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。 11. 解释 Spring MVC 模块 Spring 提供 MVC 框架构建 web 应用程序。Spring 可以很轻松的同其他 MVC 框架结合，但 Spring 的 MVC 是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。 12.Spring 的配置文件 Spring 的配置文件是一个 XML 文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。 13.Spring IoC 容器是什么？ Spring IOC 负责创建对象、管理对象 (通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。 14.IOC 有什么优点？ IOC 或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或 JNDI 查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC 容器支持勤性单例及延迟加载服务。 15. 应用上下文是如何实现的？ FileSystemXmlApplicationContext 容器加载 XML 文件中 beans 的定义。XML Bean 配置文件的完整路径必须传递给构造器。 FileSystemXmlApplicationContext 容器也加载 XML 文件中 beans 的定义。注意，你需要正确的设置 CLASSPATH，因为该容器会在 CLASSPATH 中查看 bean 的 XML 配置文件。 WebXmlApplicationContext：该容器加载 xml 文件，这些文件定义了 web 应用中所有的 beans。 16.Bean Factory 和 ApplicationContext 有什么区别？ ApplicationContext 提供了一种解决文档信息的方法，一种加载文件资源的方式 (如图片)，他们可以向监听他们的 beans 发送消息。另外，容器或者容器中 beans 的操作，这些必须以 bean 工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了 MessageSource，该接口用于获取本地消息，实际的实现是可选的。 17.Spring 应用程序看起来像什么？ 一个定义功能的接口 实现包括属性，setter 和 getter 方法，功能等 Spring AOP Spring 的 XML 配置文件 使用该功能的客户端编程 依赖注入 18.Spring 中的依赖注入是什么？ 依赖注入作为控制反转 (IOC) 的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后 IOC 容器负责衔接。 19. 有哪些不同类型的 IOC(依赖注入)？ 构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。 Setter 方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用 bean 中的 setter 方法完成 Setter 方法依赖注入。 20. 你推荐哪种依赖注入？构造器依赖注入还是 Setter 方法依赖注入？ 你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用 setter 方法实现可选的依赖关系。 Spring Beans 21. 什么是 Spring Beans？ Spring Beans 是构成 Spring 应用核心的 Java 对象。这些对象由 Spring IOC 容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用 XML 文件中定义的 创建。 在 Spring 中创建的 beans 都是单例的 beans。在 bean 标签中有一个属性为”singleton”, 如果设为 true，该 bean 是单例的，如果设为 false，该 bean 是原型 bean。Singleton 属性默认设置为 true。因此，spring 框架中所有的 bean 都默认为单例 bean。 22.Spring Bean 中定义了什么内容？ Spring Bean 中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。 23. 如何向 Spring 容器提供配置元数据？ 有三种方式向 Spring 容器提供元数据: XML 配置文件 基于注解配置 基于 Java 的配置 24. 你如何定义 bean 的作用域？ 在 Spring 中创建一个 bean 的时候，我们可以声明它的作用域。只需要在 bean 定义的时候通过’scope’属性定义即可。例如，当 Spring 需要产生每次一个新的 bean 实例时，应该声明 bean 的 scope 属性为 prototype。如果每次你希望 Spring 返回一个实例，应该声明 bean 的 scope 属性为 singleton。 25. 说一下 Spring 中支持的 bean 作用域 Spring 框架支持如下五种不同的作用域： singleton：在 Spring IOC 容器中仅存在一个 Bean 实例，Bean 以单实例的方式存在。 prototype：一个 bean 可以定义多个实例。 request：每次 HTTP 请求都会创建一个新的 Bean。该作用域仅适用于 WebApplicationContext 环境。 session：一个 HTTP Session 定义一个 Bean。该作用域仅适用于 WebApplicationContext 环境. globalSession：同一个全局 HTTP Session 定义一个 Bean。该作用域同样仅适用于 WebApplicationContext 环境. bean 默认的 scope 属性是’singleton‘。 26.Spring 框架中单例 beans 是线程安全的吗？ 不是，Spring 框架中的单例 beans 不是线程安全的。 27. 解释 Spring 框架中 bean 的生命周期 Spring 容器读取 XML 文件中 bean 的定义并实例化 bean。 Spring 根据 bean 的定义设置属性值。 如果该 Bean 实现了 BeanNameAware 接口，Spring 将 bean 的 id 传递给 setBeanName() 方法。 如果该 Bean 实现了 BeanFactoryAware 接口，Spring 将 beanfactory 传递给 setBeanFactory() 方法。 如果任何 bean BeanPostProcessors 和该 bean 相关，Spring 调用 postProcessBeforeInitialization() 方法。 如果该 Bean 实现了 InitializingBean 接口，调用 Bean 中的 afterPropertiesSet 方法。如果 bean 有初始化函数声明，调用相应的初始化方法。 如果任何 bean BeanPostProcessors 和该 bean 相关，调用 postProcessAfterInitialization() 方法。 如果该 bean 实现了 DisposableBean，调用 destroy() 方法。 28. 哪些是最重要的 bean 生命周期方法？能重写它们吗？ 有两个重要的 bean 生命周期方法。第一个是 setup 方法，该方法在容器加载 bean 的时候被调用。第二个是 teardown 方法，该方法在 bean 从容器中移除的时候调用。 bean 标签有两个重要的属性 (init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring 也有相应的注解：@PostConstruct 和 @PreDestroy。 29. 什么是 Spring 的内部 bean？ 当一个 bean 被用作另一个 bean 的属性时，这个 bean 可以被声明为内部 bean。在基于 XML 的配置元数据中，可以通过把 元素定义在 或 &lt; constrtucor-arg &gt; 元素内部实现定义内部 bean。内部 bean 总是匿名的并且它们的 scope 总是 prototype。 30. 如何在 Spring 中注入 Java 集合类？ Spring 提供如下几种类型的集合配置元素： list 元素用来注入一系列的值，允许有相同的值。 set 元素用来注入一些列的值，不允许有相同的值。 map 用来注入一组” 键 - 值” 对，键、值可以是任何类型的。 props 也可以用来注入一组” 键 - 值” 对，这里的键、值都字符串类型。 31. 什么是 bean wiring？ Wiring，或者说 bean Wiring 是指 beans 在 Spring 容器中结合在一起的情况。当装配 bean 的时候，Spring 容器需要知道需要哪些 beans 以及如何使用依赖注入将它们结合起来。 32. 什么是 bean 自动装配？ Spring 容器可以自动配置相互协作 beans 之间的关联关系。这意味着 Spring 可以自动配置一个 bean 和其他协作 bean 之间的关系，通过检查 BeanFactory 的内容里没有使用 和 &lt; property &gt; 元素。 33. 解释自动装配的各种模式？ 自动装配提供五种不同的模式供 Spring 容器用来自动装配 beans 之间的依赖注入: no：默认的方式是不进行自动装配，通过手工设置 ref 属性来进行装配 bean。 byName：通过参数名自动装配，Spring 容器查找 beans 的属性，这些 beans 在 XML 配置文件中被设置为 byName。之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。 byType：通过参数的数据类型自动自动装配，Spring 容器查找 beans 的属性，这些 beans 在 XML 配置文件中被设置为 byType。之后容器试图匹配和装配和该 bean 的属性类型一样的 bean。如果有多个 bean 符合条件，则抛出错误。 constructor：这个同 byType 类似，不过是应用于构造函数的参数。如果在 BeanFactory 中不是恰好有一个 bean 与构造函数参数相同类型，则抛出一个严重的错误。 autodetect：如果有默认的构造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。 34. 自动装配有哪些局限性？ 自动装配有如下局限性： 重写：你仍然需要使用 和 &lt; property &gt; 设置指明依赖，这意味着总要重写自动装配。 原生数据类型: 你不能自动装配简单的属性，如原生类型、字符串和类。 模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。 35. 你可以在 Spring 中注入 null 或空字符串吗？ 完全可以。 Spring 注解 36. 什么是 Spring 基于 Java 的配置？给出一些注解的例子 基于 Java 的配置允许你使用 Java 的注解进行 Spring 的大部分配置而非通过传统的 XML 文件配置。 以注解 @Configuration 为例，它用来标记类，说明作为 beans 的定义，可以被 Spring IOC 容器使用。另一个例子是 @Bean 注解，它表示该方法定义的 Bean 要被注册进 Spring 应用上下文中。 37. 什么是基于注解的容器配置? 另外一种替代 XML 配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用 XML 描述 bean 之间的连线关系。 38. 如何开启注解装配？ 注解装配默认情况下在 Spring 容器中是不开启的。如果想要开启基于注解的装配只需在 Spring 配置文件中配置 context:annotation-config 元素即可。&lt;/context:annotation-config&gt; 39.@Required 注解 @Required 表明 bean 的属性必须在配置时设置，可以在 bean 的定义中明确指定也可通过自动装配设置。如果 bean 的属性未设置，则抛出 BeanInitializationException 异常。 40.@Autowired 注解 @Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像 @Required 一样自动装配 setter 方法、构造器、属性或者具有任意名称和 / 或多个参数的 PN 方法。 41. @Qualifier 注解 当有多个相同类型的 bean 而只有其中的一个需要自动装配时，将 @Qualifier 注解和 @Autowire 注解结合使用消除这种混淆，指明需要装配的 bean。 Spring 数据访问 42. 在 Spring 框架中如何更有效的使用 JDBC？ 使用 Spring JDBC 框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过 statements 和 queries 语句从数据库中存取数据。Spring 框架中通过使用模板类能更有效的使用 JDBC，也就是所谓的 JdbcTemplate(例子)。 43.JdbcTemplate JdbcTemplate 类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。 44.Spring 对 DAO 的支持 Spring 对数据访问对象 (DAO) 的支持旨在使它可以与数据访问技术 (如 JDBC, Hibernate 及 JDO) 方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。 45. 使用 Spring 可以通过什么方式访问 Hibernate？ 使用 Spring 有两种方式访问 Hibernate： 使用 Hibernate Template 的反转控制以及回调方法 继承 HibernateDAOSupport，并申请一个 AOP 拦截器节点 46.Spring 支持的 ORM Spring 支持一下 ORM： Hibernate iBatis JPA (Java -Persistence API) TopLink JDO (Java Data Objects) OJB 47. 如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？ 使用 Spring 的 SessionFactory 调用 LocalSessionFactory。结合过程分为以下三步： 配置 Hibernate SessionFactory 继承 HibernateDaoSupport 实现一个 DAO 使用 AOP 装载事务支持 48.Spring 支持的事务管理类型 Spring 支持如下两种方式的事务管理： 编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。 声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者 XML 配置管理事务。 49.Spring 框架的事务管理有哪些优点？ 它为不同的事务 API(如 JTA, JDBC, Hibernate, JPA, 和 JDO) 提供了统一的编程模型。 它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API(如 JTA). 它支持声明式事务管理。 它可以和 Spring 的多种数据访问技术很好的融合。 50. 你更推荐那种类型的事务管理？ 许多 Spring 框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理 (这种方式允许你通过代码控制业务)。 Spring 面向切面编程 (AOP) 51. 解释 AOP 面向切面编程, 或 AOP 允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。 52. 切面 (Aspect) AOP 的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组 API 提供 cross-cutting 功能。例如, 日志模块称为日志的 AOP 切面。根据需求的不同，一个应用程序可以有若干切面。在 Spring AOP 中，切面通过带有 @Aspect 注解的类实现。 53. 在 Spring AOP 中 concern 和 cross-cutting concern 的区别是什么？ Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern 可以定义为我们想要实现的功能。 Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于 Cross-cutting concern。 54. 连接点 (Join point) 连接点代表应用程序中插入 AOP 切面的地点。它实际上是 Spring AOP 框架在应用程序中执行动作的地点。 55. 通知 (Advice) 通知表示在方法执行前后需要执行的动作。实际上它是 Spring AOP 框架在程序执行过程中触发的一些代码。 Spring 切面可以执行一下五种类型的通知: before(前置通知)：在一个方法之前执行的通知。 after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 after-returning(后置通知)：在某连接点正常完成后执行的通知。 after-throwing(异常通知)：在方法抛出异常退出时执行的通知。 around(环绕通知)：在方法调用前后触发的通知。 56. 切入点 (Pointcut) 切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。 57. 什么是引入？ 引入允许我们在已有的类上添加新的方法或属性。 58. 什么是目标对象？ 被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。 59. 什么是代理？ 代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 60. 有几种不同类型的自动代理？ BeanNameAutoProxyCreator：bean 名称自动代理创建器 DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器 Metadata autoproxying：元数据自动代理 61. 什么是织入？什么是织入应用的不同点？ 织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。 62. 解释基于 XML Schema 方式的切面实现 在这种情况下，切面由使用 XML 文件配置的类实现。 63. 解释基于注解方式 (基于 @AspectJ) 的切面实现 在这种情况下 (基于 @AspectJ 的实现)，指的是切面的对应的类使用 Java 5 注解的声明方式。 Spring 的 MVC 框架 64. 什么是 Spring 的 MVC 框架？ Spring 提供了一个功能齐全的 MVC 框架用于构建 Web 应用程序。Spring 框架可以很容易的和其他的 MVC 框架融合 (如 Struts)，该框架使用控制反转(IOC) 将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。 65.DispatcherServlet Spring 的 MVC 框架围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。 66.WebApplicationContext WebApplicationContext 继承了 ApplicationContext，并添加了一些 web 应用程序需要的功能。和普通的 ApplicationContext 不同，WebApplicationContext 可以用来处理主题样式，它也知道如何找到相应的 servlet。 67. 什么是 Spring MVC 框架的控制器？ 控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。 68.@Controller annotation @Controller 注解表示该类扮演控制器的角色。Spring 不需要继承任何控制器基类或应用 Servlet API。 69.@RequestMapping annotation @RequestMapping 注解用于将 URL 映射到任何一个类或者一个特定的处理方法上。 原文链接： javacodegeeks 翻译： ImportNew.com - 人晓译文链接： http://www.importnew.com/11657.html spring面试总结25题1、什么是 spring 框架？Spring 框架有哪些主要模块？ Spring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。Spring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。 Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成,、Web、 AOP（面向切面编程）、工具、消息和测试模块。 2、使用 Spring 框架能带来哪些好处？下面列举了一些使用 Spring 框架带来的主要好处： Dependency Injection(DI) 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。 与 EJB 容器相比较，IoC 容器更加趋向于轻量级。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下进行应用程序的开发和发布就变得十分有利。 Spring 并没有闭门造车, Spring 利用了已有的技术如 ORM 框架 logging 框架、J2EE、Quartz 和 JDK Timer, 以及其他视图技术. Spring 框架是按照模块的形式来组织的. 由包和类的编号就可以看出其所属的模块, 开发者仅仅需要选用他们需要的模块即可。 要测试一项用 Spring 开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。 Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 web 框架的选择上提供了一个除了主流框架 比如 Struts、过度设计的、不流行 web 框架的以外的有力选项。 Spring 提供了一个便捷的事务管理接口，适用于小型的本地事物处理 (比如在单 DB 的环境下) 和复杂的共同事物处理 (比如利用 JTA 的复杂 DB 环境)。 3、什么是控制反转 (IOC)? 什么是依赖注入?控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常 是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的 情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联 关系的定义抽象化。而绑定的过程是通过 “依赖注入” 实现的。 控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。 这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的 情况下，框架又怎么知道要创建哪个组件？ 在 Java 中依然注入有以下三种实现方式： 构造器注入 Setter 方法注入 接口注入 4、请解释下 Spring 框架中的 IoC?Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了 Spring 框架 IoC 容器的基础。 BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对 BeanFactory(是一个子接口) 进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成， 也提供了处理 message resource 的机制 (用于国际化)、事件传播以及应用层的特别配置， 比如针对 Web 应用的 WebApplicationContext。 org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。 BeanFactory 接口是 Spring IoC 容器的核心接口。 5、BeanFactory 和 ApplicationContext 有什么区别?BeanFactory 可以理解为含有 bean 集合的工厂类. BeanFactory 包含了种 bean 的定义, 以便在接收到客户端请求时将对应的 bean 实例化. BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。 BeanFactory 还包含了 bean 生命周期的控制, 调用客户端的初始化方法 (initialization methods) 和销毁方法(destruction methods)。 从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。 但 application context 在此基础上还提供了其他的功能。 1、提供了支持国际化的文本消息 2、统一的资源文件读取方式 3、已在监听器中注册的 bean 的事件 以下是三种较常见的 ApplicationContext 实现方式： 1、ClassPathXmlApplicationContext: 从 classpath 的 XML 配置文件中读取上下文, 并生成上下文定义. 应用程序上下文从程序环境变量中取得. 1ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); 2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。 1ApplicationContext context = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;); 3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。 6、Spring 有几种配置方式?将 Spring 配置到应用开发中有以下三种方式： 1、基于 XML 的配置 2、基于注解的配置 3、基于 Java 的配置 7、如何用基于 XML 配置的方式配置 Spring?在 Spring 框架中，依赖和服务需要在专门的配置文件来实现，我常用的 XML 格式的配置文件。 这些配置文件的格式通常用开头，然后一系列的 bean 定义和专门的应用配置选项组成。 SpringXML 配置的主要目的时候是使所有的 Spring 组件都可以用 xml 文件的形式来进行配置。 这意味着不会出现其他的 Spring 配置类型 (比如声明的方式或基于 Java Class 的配置方式) Spring 的 XML 配置方式是使用被 Spring 命名空间的所支持的一系列的 XML 标签来实现的。 Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。 1234567&lt;beans&gt; &lt;!-- JSON Support --&gt; &lt;bean /&gt; &lt;bean /&gt; &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;&lt;/beans&gt; 下面这个 web.xml 仅仅配置了 DispatcherServlet, 这件最简单的配置便能满足应用程序配置运行时组件的需求。 123456789101112131415&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 8、如何用基于 Java 配置的方式配置 Spring?Spring 对 Java 配置的支持是由 @Configuration 注解和 @Bean 注解来实现的。由 @Bean 注解的方法将会实例化、 配置和初始化一个新对象，这个对象将由 Spring 的 IoC 容器来管理。@Bean 声明所起到的作用与 元素类似。 被 @Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被 @Configuration 声明的类可以 通过在同一个类的内部调用 @bean 方法来设置嵌入 bean 的依赖关系。 最简单的 @Configuration 声明类请参考下面的代码： 1234567@Configurationpublic class AppConfig&#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 对于上面的 @Beans 配置文件相同的 XML 配置文件如下： 123&lt;beans&gt; &lt;bean id=&quot;myService&quot; class=&quot;com.howtodoinjava.services.MyServiceImpl&quot;/&gt;&lt;/beans&gt; 上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化 12345public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff();&#125; 要使用组件组建扫描，仅需用 @Configuration 进行注解即可: 12345@Configuration@ComponentScan(basePackages = &quot;com.howtodoinjava&quot;)public class AppConfig &#123; ...&#125; 在上面的例子中，com.acme 包首先会被扫到，然后再容器内查找被 @Component 声明的类， 找到后将这些类按照 Sring bean 定义进行注册。 如果你要在你的 web 应用开发中选用上述的配置的方式的话, 需要用 AnnotationConfigWebApplicationContext 类来读取配置文件， 可以用来配置 Spring 的 Servlet 监听器 ContrextLoaderListener 或者 Spring MVC 的 DispatcherServlet。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;web-app&gt; &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext instead of the default XmlWebApplicationContext --&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Configuration locations must consist of one or more comma- or space-delimited fully-qualified @Configuration classes. Fully-qualified packages may also be specified for component-scanning --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.howtodoinjava.AppConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext instead of the default XmlWebApplicationContext --&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- Again, config locations must consist of one or more comma- or space-delimited and fully-qualified @Configuration classes --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.howtodoinjava.web.MvcConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 9、怎样用注解的方式配置 Spring？Spring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML 方式的 bean 描述， 可以将 bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。 注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。 注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。 如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 123456&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- bean definitions go here --&gt;&lt;/beans&gt; 在 context:annotation-config/ 标签配置完成以后, 就可以用注解的方式在 Spring 中向属性、方法和构造方法中自动装配变量。 下面是几种比较重要的注解类型： 1、@Required：该注解应用于设值方法。 2、@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 3、@Qualifier：该注解和 @Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。 4、JSR-250 Annotations：Spring 支持基于 JSR-250 注解的以下注解,@Resource、@PostConstruct 和 @PreDestroy。 10、请解释 Spring Bean 的生命周期?Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。 同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。 Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调 (call back) 方法组成。 1、初始化之后调用的回调方法。 2、销毁之前调用的回调方法。 Spring 框架提供了以下四种方式来管理 bean 的生命周期事件： InitializingBean 和 DisposableBean 回调接口 针对特殊行为的其他 Aware 接口 Bean 配置文件中的 Custom init() 方法和 destroy() 方法 @PostConstruct 和 @PreDestroy 注解方式 使用 customInit() 和 customDestroy() 方法管理 bean 生命周期的代码样例如下： 1234&lt;beans&gt; &lt;bean id=&quot;demoBean&quot; class=&quot;com.howtodoinjava.task.DemoBean&quot; init-method=&quot;customInit&quot; destroy-method=&quot;customDestroy&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 11、Spring Bean 的作用域之间有什么区别？Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的, 但是为了避免混淆, 还是让我们来解释一下： 1、singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例， 单例的模式由 bean factory 自身来维护。 2、prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。 3、request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例, 在请求完成以后, bean 会失效并被垃圾回收器回收. 4、Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。 5、global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。 如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。 全局作用域与 Servlet 中的 session 作用域效果相同。 12、什么是 Spring inner beans?在 Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean 声明为内部 bean。 内部 bean 可以用 setter 注入 “属性” 和构造方法注入 “构造参数” 的方式来实现。 比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个 Person 的实例， 然后在 Customer 内部使用。 123456789101112131415public class Customer&#123; private Person person; //Setters and Getters&#125;public class Person&#123; private String name; private String address; private int age; //Setters and Getters&#125; 内部 bean 的声明方式如下： 12345678910&lt;bean id=&quot;CustomerBean&quot; class=&quot;com.howtodoinjava.common.Customer&quot;&gt; &lt;property &gt; &lt;!-- This is inner bean --&gt; &lt;bean class=&quot;com.howtodoinjava.common.Person&quot;&gt; &lt;property /&gt; &lt;property /&gt; &lt;property /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 13、Spring 框架中的单例 Beans 是线程安全的么?Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。 但实际上，大部分的 Spring bean 并没有可变的状态 (比如 Serview 类和 DAO 类), 所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状态的话 (比如 View Model 对象)，就需要自行保证线程安全。 最浅显的解决办法就是将多态 bean 的作用域由 “singleton” 变更为 “prototype”。 14、请举例说明如何在 Spring 中注入一个 Java Collection?Spring 提供了以下四种集合类的配置元素： &lt;list&gt;:该标签用来装配可重复的 list 值。 &lt;set&gt;:该标签用来装配没有重复的 set 值。 &lt;map&gt;:该标签可用来注入键和值可以为任何类型的键值对。 &lt;props&gt;:该标签支持注入键和值都是字符串类型的键值对。 下面看一下具体的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;beans&gt; &lt;!-- Definition for javaCollection --&gt; &lt;bean id=&quot;javaCollection&quot; class=&quot;com.howtodoinjava.JavaCollection&quot;&gt; &lt;!-- java.util.List --&gt; &lt;property &gt; &lt;list&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- java.util.Set --&gt; &lt;property &gt; &lt;set&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- java.util.Map --&gt; &lt;property &gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt; &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt; &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt; &lt;entry key=&quot;4&quot; value=&quot;UK&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- java.util.Properties --&gt; &lt;property &gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 15、如何向 Spring Bean 中注入一个 Java.util.Properties?第一种方法是使用如下面代码所示的&lt;props&gt; 标签： 1234567891011&lt;bean id=&quot;adminUser&quot; class=&quot;com.howtodoinjava.common.Customer&quot;&gt; &lt;!-- java.util.Properties --&gt; &lt;property &gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 也可用 “util:” 命名空间来从 properties 文件中创建出一个 propertiesbean，然后利用 setter 方法注入 bean 的引用。 16、请解释 Spring Bean 的自动装配?在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的 关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。 自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。 下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配： 1&lt;bean id=&quot;employeeDAO&quot; class=&quot;com.howtodoinjava.EmployeeDAOImpl&quot; autowire=&quot;byName&quot; /&gt; 除了 bean 配置文件中提供的自动装配模式，还可以使用 @Autowired 注解来自动装配指定的 bean。 在使用 @Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。 1&lt;context:annotation-config /&gt; 也可以通过在配置文件中配置 AutowiredAnnotationBeanPostProcessor 达到相同的效果。 1&lt;bean class =&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt; 配置好以后就可以使用 @Autowired 来标注了。 1234@Autowiredpublic EmployeeDAOImpl ( EmployeeManager manager ) &#123; this.manager = manager;&#125; 17、请解释自动装配模式的区别?在 Spring 框架中共有 5 种自动装配，让我们逐一分析。 1、no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean 定义中用标签明确的设置依赖关系。 2、byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时， 容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 3、byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时， 容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 4、constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的 bean， 如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。 5、autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器， 如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 byType 的自动装配方式。 18、如何开启基于注解的自动装配？要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现： 1、引入配置文件中的下引入 context:annotation-config 123&lt;beans&gt; &lt;context:annotation-config /&gt;&lt;/beans&gt; 2、在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor 123&lt;beans&gt; &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;&lt;/beans&gt; 19、请举例解释 @Required 注解?在产品级别的应用中，IoC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一 就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置 “dependency-check” 来解决这个问题。 在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正确配置。或者你宁可验证某个 bean 的特定属性是否被正确的设置。即使是用 “dependency-check” 属性也不能很好的解决这个问题, 在这种情况下, 你需要使用 @Required 注解。 需要用如下的方式使用来标明 bean 的设值方法。 123456789101112131415public class EmployeeFactoryBean extends AbstractFactoryBean&lt;Object&gt;&#123; private String designation; public String getDesignation() &#123; return designation; &#125; @Required public void setDesignation(String designation) &#123; this.designation = designation; &#125; //more code here&#125; RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被 @Required 注解的 bean 属性是否被正确的设置了。 在使用 RequiredAnnotationBeanPostProcesso 来验证 bean 属性之前，首先要在 IoC 容器中对其进行注册： 1&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot; /&gt; 但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个 BeanInitializationException 异常。 20、请举例解释 @Autowired 注解?@Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像 @Required 注解、 构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。 比如，可以在设值方法上使用 @Autowired 注解来替代配置文件中的 元素。 当 Spring 容器在 setter 方法上找到 @Autowired 注解时，会尝试用 byType 自动装配。 当然我们也可以在构造方法上使用 @Autowired 注解。带有 @Autowired 注解的构造方法意味着 在创建一个 bean 时将会被自动装配，即便在配置文件中使用 元素。 12345678910111213public class TextEditor &#123; private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker)&#123; System.out.println(&quot;Inside TextEditor constructor.&quot; ); this.spellChecker = spellChecker; &#125; public void spellCheck()&#123; spellChecker.checkSpelling(); &#125;&#125; 下面是没有构造参数的配置方式： 12345678910111213&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- Definition for textEditor bean without constructor-arg --&gt; &lt;bean id=&quot;textEditor&quot; class=&quot;com.howtodoinjava.TextEditor&quot;&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=&quot;spellChecker&quot; class=&quot;com.howtodoinjava.SpellChecker&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 21、请举例说明 @Qualifier 注解?@Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。 下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。 12345public class Customer&#123; @Autowired private Person person;&#125; 下面我们要在配置文件中来配置 Person 类。 123456789&lt;bean id=&quot;customer&quot; class=&quot;com.howtodoinjava.common.Customer&quot; /&gt;&lt;bean id=&quot;personA&quot; class=&quot;com.howtodoinjava.common.Person&quot; &gt; &lt;property /&gt;&lt;/bean&gt;&lt;bean id=&quot;personB&quot; class=&quot;com.howtodoinjava.common.Person&quot; &gt; &lt;property /&gt;&lt;/bean&gt; Spring 会知道要自动装配哪个 person bean 么? 不会的，但是运行上面的示例时，会抛出下面的异常： 123Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.howtodoinjava.common.Person] is defined: expected single matching bean but found 2: [personA, personB] 要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean： 123456public class Customer&#123; @Autowired @Qualifier(&quot;personA&quot;) private Person person;&#125; 22、构造方法注入和设值注入有什么区别?请注意以下明显的区别： 1、在设值注入方法支持大部分的依赖注入，如果我们仅需要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。 对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入， 因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 2、设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话， 那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。 3、在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。 而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 4、在设值注入时如果对象 A 和对象 B 互相依赖，在创建对象 A 时 Spring 会抛出 sObjectCurrentlyInCreationException 异常， 因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题， 因对象的设值方法是在对象被创建之前被调用的。 23、Spring 框架中有哪些不同类型的事件?Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。 我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件, 如果一个 bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。 12345678public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt;&#123; @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; //process event &#125;&#125; Spring 提供了以下 5 中标准的事件： 1、上下文更新事件 (ContextRefreshedEvent)：该事件会在 ApplicationContext 被初始化或者更新时发布。 也可以在调用 ConfigurableApplicationContext 接口中的 refresh() 方法时被触发。 2、上下文开始事件 (ContextStartedEvent)：当容器调用 ConfigurableApplicationContext 的 Start() 方法开始 / 重新开始容器时触发该事件。 3、上下文停止事件 (ContextStoppedEvent)：当容器调用 ConfigurableApplicationContext 的 Stop() 方法停止容器时触发该事件。 4、上下文关闭事件 (ContextClosedEvent)：当 ApplicationContext 被关闭时触发该事件。 容器被关闭时，其管理的所有单例 Bean 都被销毁。 5、请求处理事件 (RequestHandledEvent)：在 Web 应用中，当一个 http 请求（request）结束触发该事件。 除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。 12345678public class CustomApplicationEvent extends ApplicationEvent&#123; public CustomApplicationEvent ( Object source, final String msg ) &#123; super(source); System.out.println(&quot;Created a Custom event&quot;); &#125;&#125; 为了监听这个事件，还需要创建一个监听器： 1234567public class CustomEventListener implements ApplicationListener &lt; CustomApplicationEvent &gt;&#123; @Override public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123; //handle event &#125;&#125; 之后通过 applicationContext 接口的 publishEvent() 方法来发布自定义事件。 12CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext, &quot;Test message&quot;);applicationContext.publishEvent(customEvent); 24、FileSystemResource 和 ClassPathResource 有何区别?在 FileSystemResource 中需要给出 spring-config.xml 文件在你项目中的相对路径或者绝对路径。 在 ClassPathResource 中 spring 会在 ClassPath 中自动搜寻配置文件，所以要把 ClassPathResource 文件放在 ClassPath 下。 如果将 spring-config.xml 保存在了 src 文件夹下的话，只需给出配置文件的名称即可，因为 src 文件夹是默认。 简而言之，ClassPathResource 在环境变量中读取配置文件，FileSystemResource 在配置文件中读取配置文件。 25、Spring 框架中都用到了哪些设计模式？Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的： 1、代理模式—在 AOP 和 remoting 中被用的比较多。 2、单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。 3、模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 4、前端控制器—Spring 提供了 DispatcherServlet 来对请求进行分发。 5、视图帮助 (View Helper)—Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。 6、依赖注入—贯穿于 BeanFactory / ApplicationContext 接口的核心理念。 7、工厂模式—BeanFactory 用来创建对象的实例。 原文:http://blog.csdn.net/a724888/article/details/68925151]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记五]]></title>
    <url>%2F2018%2F03%2F17%2F2018-03-17%2F</url>
    <content type="text"><![CDATA[第5章 构建Spring Web应用本章内容： 映射请求到Spring控制器 透明的绑定表单数据 校验表单提交 系统面临的挑战：状态管理、工作流、以及验证都是需要解决的重要特性。HTTP协议的无状态决定了这些问题都不是那么容易解决。 Spring的Web框架就是为了帮你解决这些关注点而设计的。Spring MVC基于模型-视图-控制器(Model-View-Controller MVC)模式实现的，他能够帮你构建向Spring框架那样灵活和松耦合的Web应用程序。 在本章中，将会介绍Spring MVC Web框架，并使用新的Spring MVC注解来构建处理各种Web请求、参数、和表单输入的控制器。 5.1 Spring MVC起步Spring将请求在调度Servlet、处理器映射(Handler Mappering)、控制器以及视图解析器(View resolver)之间移动，每一个Spring MVC中的组件都有特定的目的，并且也没那么复杂。 让我们看一下，请求是如何从客户端发起，经过Spring MVC中的组件，最终返回到客户端 5.1.1 跟踪Spring MVC每当用户在Web浏览器中点击链接或提交表单的时候，请求就开始工作了。请求是一个十分繁忙的家伙，从离开浏览器开始到获取响应返回，它会经历很多站，在每站都会留下一些信息，同时也会带上一些信息。 Spring工作流程描述原文在这里 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获； DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法） 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； ViewResolver 结合Model和View，来渲染视图 将渲染结果返回给客户端。 图片参考这里 Spring工作流程描述 为什么Spring只使用一个Servlet(DispatcherServlet)来处理所有请求？ 详细见J2EE设计模式-前端控制模式 Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler? 符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。 1、请求旅程的第一站是Spring的DispatcherServlet。与大多数基于Java的Web框架一样，Spring MVC所有的请求都会通过一个前端控制器(front contrller)Servlet.前端控制器是常用Web应用程序模式。在这里一个单实例的Servlet将请求委托给应用的其他组件来执行实际的处理。在Spring MVC中，DisPatcherServlet就是前端控制器。 2、DisPactcher的任务是将请求发送Spring MVC控制器(controller).控制器是一个用于处理请求的Spring组件。在典型的应用中可能会有多个控制器，DispatcherServlet需要知道应该将请求发送给那个哪个控制器。所以Dispactcher以会查询一个或 多个处理器映射(Handler mapping),来确定请求的下一站在哪里。处理映射器根据请求携带的 URL信息来进行决策。 3、一旦选择了合适的控制器，DispatcherServlet会将请求发送给选中的控制器。到了控制器，请求会卸下其负载(用户提交的信息)并耐心等待控制器处理这些信息。(实际上，设计良好的控制器 本身只是处理很少，甚至不处理工作，而是将业务逻辑委托给一个或多个服务器对象进行处理) 4、控制器在完成处理逻辑后，通常会产生一些信息。这些 信息需要返回给 用户，并在浏览器上显示。这些信息被称为模型(Model),不过仅仅给用户返回原始的信息是不够的—-这些信息需要以用户友好的方式进行格式化，一般会是HTML。所以，信息需要发送一个视图(View),通常会是JSP。 5、 控制器做的最后一件事就是将模型打包，并且表示出用于渲染输出的视图名。它接下来会将请求连同模型和视图发送回DispatcherServlet。 6、这样，*控制器就不会与特定的视图相耦合**传递给控制器的视图名并不直接表示某个特定的jsp。实际上，它甚至并不能确定视图就是JSP。相反，它仅仅传递了一个逻辑名称，这个名字将会用来查找产生结果的真正视图。DispatcherServlet将会使用视图解析器(View resolver),来将逻辑视图名称匹配为一个特定的视图实现，他可能也可能不是JSP 7、虽然DispatcherServlet已经知道了哪个驶入渲染结果、那请求的任务基本上也就完成了，它的最后一站是试图的实现。在这里它交付给模型数据。请求的任务就结束了。视图将使用模型数据渲染输出。这个输出通过响应对象传递给客户端(不会像听上去那样硬编码) 可以看到，请求要经过很多步骤，最终才能形成返回给客户端的响应，大多数的 步骤都是在Spirng框架内部完成的。 5.1.2 搭建Spring MVC借助于最近几个Spring新特性的功能增强，开始使用SpringMVC变得非常简单了。使用最简单的方式配置Spring MVC；所要实现的功能仅限于运行我们所创建的控制器。 配置DisPatcherServlet DispatcherServlet是Spirng MVC的核心，在这里请求会第一次接触到框架，它要负责将请求路由到其他组件之中。 按照传统的方式，像DispatcherServlet这样的Servlet会配置在web.xml中。这个文件会放到应用的war包中。当然这是配置DispatcherServlet方法之一。借助于Servlet 3规范和Spring 3.1 的功能增强，这种方式已经不是唯一的方案来。 我们会使用Java将DispatcherServlet配置在Servlet容器中。而不会在使用web.xml文件 12345678910111213141516public class SpitterWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected String[] getServletMappings() &#123; //将DispatcherServlet映射到“/” return new String[]&#123;"/"&#125;; &#125; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt; [] &#123;RootConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt; [] &#123; WebConfig.class&#125;; &#125;&#125; 我们只需要知道扩展AbstractAnnotationConfigDispatcherServletInitializer的任意类都会自动的配置Dispatcherservlet和Spring应用上下文，Spirng的应用上下文会位于应用程序的Servlet上下文之中 在Servlet3.0环境中，容器会在类路径中 查找实现javax.servlet.ServletContainerInitialzer接口的类，如果能发现的话，就会用它来配置Servlet容器。 Spring提供了这个接口的实现名为SpringServletContainnerInitialzer,这个类反过来又会查找实现WebApplicationInitialzer的类，并将配置的任务交给他们来完成。Spring 3.2引入了一个遍历的WebApplicationInitialzer基础实现也就是AbstractAnnotationConfigDispatcherServletInitializer因为我们的Spittr-WebApplicationInitialzer扩展了AbstractAnnotationConfigDispatcherServletInitializer,(同时也就实现了WebApplicationInitialzer),因此当部署Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文 第一个方法getServletMappings(),它会将一个或多个路径映射到DispatcherServlet上，在本示例中，它映射的是“/”，表示它是应用默认的Servlet，它会处理应用的所有请求。 为了理解其他两个方法，我们首先需要理解DispatcherServlet和一个Servlet监听器(也就是ContextLoaderListener)的关系。 当DispatcherServlet启动的时候，它会创建应用上下文，并加载配置文件或配置类中声明的bean。在上面那个程序中的getServletConfigClasses()方法中，我们要求DispatcherServlet加载应用上下文时，使用定义在WebConfig配置类(使用Java配置)中的bean 但在Spring Web应用中，通常还会有另外一个应用上下文。另外这个就是由ContextLoaderListener创建. 我们希望DispatcherServlet加载包含Web组件的bean，如控制器，视图解析器，以及处理器映射，而ContextLoaderListener要加载应用中的其他bean。这些bean通常 是驱动应用后端的中间层和数据层组件。 实际上AbstractAnnotationConfigDispatcherServletInitializer会同时创建DispatcherServlet和ContextLoaderListener。getServletConfigClasses()方法会返回带有@Configuration注解的类将会用来定义DispatcherSerle应用上下文中的bean，getRootConfigClasses()会返回带有@Configuration注解的类将会用来配置ContextLoaderListener创建的应用上下文。 如果有必要两个可以同时存在，wex.xml和 AbstractAnnotationConfigDispatcherServletInitializer,但其实没有必要。 如果按照这种方式配置DispatcherServlet，而不是使用Web.xml的话，那么唯一的问题在于它能部署到支持Servlet3.0的服务器上才可以正常工作，如Tomcat7或更高版本，Servlet3.0规范在2009年12月份就发布了， 如果没有支持Servlet3.0，那别无选择了，只能使用web.xml配置类。 启用Spring MVC 我们有多种方式来启动DispatcherServlet，与之类似，启用Spring MVC组件的方式也不止一种，以前Spring是XMl进行配置的，你可以选择mvc:annotation-driver启用注解驱动的Spring MVC。 在第七章的时候会介绍mvc:annotaion-driver,现在会让Spring MVC搭建的过程尽可能简单，并基于Java进行配置。 我们所能创建最简单的Spring MVC配置就是一个带有@EnableWebMvc注解的类1234567import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@EnableWebMvcpublic class WebConfig &#123;&#125; 这可以运行起来，它的确能够启用Spring MVC，但还有不少问题要解决。 1、没有配置视图解析器，如果这样的话，Spring默认会使用BeanNameView-Resolver，这个视图解析器会查找ID与视图名称匹配的bean，并且查找的bean要实现View接口，它以这样的方式来解析视图。 2、没有启用组件扫描。这样的结果就是，Spirng只能找到显示声明在配置类中的控制器。 3、这样配置的话，DispatcherServlet会映射为默认的Servlet，所以他会处理所有的请求，包括对静态资源的请求，如图片 和样式表(在大多数情况下，这可能并不是你想要的结果)。 因此我们需要在WebConfig这个最小的Spring MVC配置上再加一些内容，从而让他变得真正实用。 12345678910111213141516171819202122@Configuration@EnableWebMvc //启用Spring MVC@ComponentScan("com.guo.spittr.web") //启用组件扫描public class WebConfig extends WebMvcConfigurerAdapter &#123; @Bean public ViewResolver viewResolver () &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); //配置JSP视图解析器 resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; @Override //我们要求DispatcherServlet将静态资源的请求转发到Servlet容器中默认的Servlet上， //而不是使用DispatcherServlet本来来处理此类请求。 public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; //配置静态资源的处理 configurer.enable(); &#125;&#125; 第一件需要注意的是WebConfig现在添加了@ComponentScan注解，此时将会扫描com.guo.spittr.web包来查找组件。稍后你会看到，我们编写的控制器将会带有@Controller注解，这会使其成为组件扫描时的候选bean。因此，我们不需要在配置类中显示声明任何的控制器。 接下来，我们添加了一个ViewResolver bean，更具体的将是InternalResourceViewResolver。将会在第6章更为详细的讨论视图解析器。我们只需要知道他会去查找jsp文件，在查找的时候，它会在视图名称上加一个特定的前缀和后缀。(例如：名为home的视图会被解析为/WEB-INF/views/home.jsp) 最后新的WebConfig类还扩展里WebMvcConfigurerAdapter并重写了其configureDefaultServletHandling()方法,通过调用DefaultServletHandlerConfigurer的enable()方法，我们要求DispatcherServlet将静态资源的请求转发到Servlet容器中默认的Servlet上，而不是使用DispatcherServlet本来来处理此类请求。 WebConfig已经就绪，那么RootConfig呢？因为本章聚焦于Web开发，而Web相关的配置通过DisPatcherServlet创建的应用上下文都已经配好了，因此现在的RootConfig相对很简单： 123456789101112131415import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ComponentScan.Filter;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.web.servlet.config.annotation.EnableWebMvc;/** * Created by guo on 23/2/2018. */@Configuration@ComponentScan(basePackages = &#123;"com.guo.spittr"&#125;, excludeFilters = &#123; @Filter(type = FilterType.ANNOTATION,value = EnableWebMvc.class)&#125;)public class RootConfig &#123;&#125; 唯一需要注意的是RootConfig使用了@ComponentScan注解，这样的话，我们就有很多机会用非Web的组件来完善RootConfig。 5.1.3 Spittr应用简介为了实现在线社交的功能，我们将要构造一个简单的微博(microblogging)应用，在很多方面，我们所构建的应用于最早的微博应用Twitter很类似，在这个过程中，我们会添加一些小的变化。当然我们使用Spirng技术来构建这个应用。 因为从Twitter借鉴了灵感并通过Spring来进行实现，所以它就有了一个名字：Spitter。 Spittr应用有两个基本的领域概念：Spitter(应用的用户)和Spittle(用户发布的简短状态更新)。当我们在书中完善Spittr应用的功能时，将会介绍这两个概念。在本章中，我们会构建应用的Web层，创建展现Spittle的控制器以及处理用户注册为Spitter的表单。 舞台已经搭建完成了，我们已经配置了DispatcherServlet，启用了基本的Spring MVC组件，并确定了目标应用。让我们进入本章的核心内容：使用Spring MVC 控制器处理Web请求。 5.2 编写 基本的控制器在SpringMVC中，控制器只是在方法上添加了@RequestMapping注解的类，这个注解声明了他们所要处理的请求。 开始的时候，我们尽可能简单，假设控制器类要处理对/的请求，并对渲染应用的首页。 123456789101112131415import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;/** * Created by guo on 24/2/2018. * 首页控制器 */@Controllerpublic class HomeController &#123; @RequestMapping(value = "/",method = RequestMethod.GET) //处理对“/”的Get请求 public String home() &#123; return "home"; //视图名为home &#125;&#125; 写完测试了下，好使， 你可能注意到第一件事就是HomeController带有@Controller注解，很显然这个注解是用来声明控制器的，但实际上这个注解对Spirng MVC 本身影响不大。 @Controller是一个构造型(stereotype)的注解。它基于@Component注解。在这里，它的目的就是辅助实现组件扫描。因为homeController带有@Controller注解，因此组件扫描器会自动去找到HomeController，并将其声明为Spring应用上下文中的bean。1234567Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller &#123; String value() default "";&#125; 其实你可以让HomeController带有@Component注解，它所实现的效果是一样的。但是在表意性上可能差一些，无法确定HomeController是什么组件类型。 HomeController唯一的一个方法，也就是Home方法，带有@RequestMapping注解，他的Value属性指定了这个方法所要处理的请求路径，method属性细化了它所能处理的HTTP方法，在本例中，当收到对‘/’的HTTP GET请求时，就会调用home方法。 home()方法其实并没有做太多的事情，它返回一个String类型的“home”，这个String将会被Spring MVC 解读为要渲染的视图名称。DispatcherServlet会要求视图解析器将这个逻辑名称解析为实际的视图。 鉴于我们配置InternalResourceViewResolver的方式，视图名“home”将会被解析为“/WEB-INF/views/home.jsp” Spittr应用的首页，定义为一个简单的JSP123456789101112131415&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ page session="false" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Spitter&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="&lt;c:url value="/resources/style.css" /&gt;" &gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to Spitter&lt;/h1&gt; &lt;a href="&lt;c:url value="/spittles" /&gt;"&gt;Spittles&lt;/a&gt; | &lt;a href="&lt;c:url value="/spitter/register" /&gt;"&gt;Register&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 测试控制器最直接的办法可能是构建并部署应用，然后通过浏览器对其进行访问，但是自动化测试可能会给你更快的反馈和更一致的独立结果，所以，让我们编写一个针对HomeController的测试 5.2.1 测试控制器编写一个简单的类来测试HomoController。12345678910import static org.junit.Assert.*;import org.junit.Test;public class HomeControllerTest &#123; @Test public void testHomePage() throws Exception &#123; HomeController controller = new HomeController(); assertEquals("home",controller.home()); &#125;&#125; 在测试中会直接调用home()方法，并断言返回包含 “home”值的String类型。它完全没有站在Spring MVC控制器的视角进行测试。这个测试没有断言当接收到针对“/”的GET请求时会调用home()方法。因为它返回的值就是“home”，所以没有真正判断home是试图的名称。 不过从Spring 3.2开始，我们可以按照控制器的方式进行测试Spring MVC中的控制器了。而不仅仅是POJO进行测试。Spring现在包含了一种mock Spirng MVC 并针对控制器执行 HTTP请求的机制。这样的话，在测试控制器的时候，就没有必要在启动Web服务器和Web浏览器了。 为了阐述如何测试Spirng MVC 容器，我们重写了HomeControllerTest并使用Spring MVC 中新的测试特性。 123456789101112131415161718import org.junit.Test;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.setup.MockMvcBuilders.*;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;/** * Created by guo on 24/2/2018. */public class HomeControllerTest1 &#123; @Test //大家在测试的时候注意静态导入的方法 public void testHomePage() throws Exception &#123; HomeController controller = new HomeController(); MockMvc mockMvc = standaloneSetup(controller).build(); //搭建MockMvc mockMvc.perform(get("/")) //对“/”执行GET请求， .andExpect(view().name("home")); //预期得到home视图 &#125;&#125; 这次我们不是直接调用home方法并测试它的返回值，而是发起了对”/“的请求，并断言结果视图的名称为home，它首先传递一个HomeController实例到MockMvcBuilders.strandaloneSetup()并调用build()来构建MockMvc实例，然后它使用MockMvc实例执行针对“/”的GET请求，并设置 期望得到的视图名称。 5.2.2 定义类级别的请求处理。现在，已经为HomeController编写了测试，那么我们可以做一些重构。并通过测试来保证不会对功能造成什么破坏。我们可以做的就是拆分@RequestMapping，并将其路径映射部分放到类级别上 12345678@Controller@RequestMapping("/")public class HomeController &#123; @RequestMapping(method = RequestMethod.GET) //处理对“/”的Get请求 public String home() &#123; return "home"; //视图名为home &#125;&#125; 在这个新版本的HomeController中，路径被转移到类级别的@RequestMapping上，而HTTP方法依然映射在方法级别上。当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上，处理器方法上的@RequestMapping注解会对类级别上的@RequestMapping的声明进行补充。 就HomeController而言，这里只有一个控制器方法，与类级别的@RequestMapping合并之后，这个方法的@RequestMapping表明home()将会处理对 “/”路径的GET请求。 有了测试，所以可以确保在这个过程中，没有对原有的功能造成破坏。 当我们修改@RequestMapping时，还可以对HomeController做另一个变更。@RequestMapping的value接受一个String类型的数组。到目前为止，我们给它设置的都是一个String类型的‘/’。但是，我们还可以将它映射到对“/Homepage”的请求，只需要将类级别的@RequestMapping改动下 12345@Controller@RequestMapping(&#123;"/","/Homepage"&#125;)public class HomeController &#123; ...&#125; 现在，HomeController的home()方法可以被映射到对“/”和“/homepage”的GET请求上。 5.2.3 传递模型数据到视图中到目前为止，就编写超级简单的控制器来说，HomeController已经是一个不错的样例了，但是大多数的控制器并不是那么简单。在Spring应用中，我们需要有一个页面展示最近提交的Spittle列表。因此，我们需要有一个新的方法来处理这个页面。 首先需要定义一个数据访问的Repository，为了实现解耦以及避免陷入数据库访问的细节中，我们将Repository定义为一个接口，并在稍后实现它(第十章)，此时，我们只需要一个能够获取Spittle列表的Repository，123456789package com.guo.spittr.data;import com.guo.spittr.Spittle;import java.util.List;/** * Created by guo on 24/2/2018. */public interface SpittleRepository &#123; List&lt;Spittle&gt; finfSpittles(long max, int count);&#125; findSpittles()方法接受两个参数，其中max参数代表所返回的Spittle中，Spittle ID属性的最大值，而count参数表明要返回多少个Spittle对象，为了获得最新的20个Spittle对象，我们可以这样调用方法。 1List&lt;Spittle&gt; recent = SpittleRepository.findSpittles(long.MAX_VALUE(),20) 它的属性包括消息内容，时间戳，以及Spittle发布时对应的经纬度。 12345678910111213141516171819202122232425262728293031public class Spittle &#123; private final Long id; private final String message; private final Date time; private Double latitude; private Double longitude; public Spittle(String message, Date time) &#123; this(null, message, time, null, null); &#125; public Spittle(Long id, String message, Date time, Double longitude, Double latitude) &#123; this.id = id; this.message = message; this.time = time; this.longitude = longitude; this.latitude = latitude; &#125; //Getter和Setter略 @Overridepublic boolean equals(Object that) &#123; return EqualsBuilder.reflectionEquals(this, that, "id", "time");&#125;@Overridepublic int hashCode() &#123; return HashCodeBuilder.reflectionHashCode(this, "id", "time");&#125; 需要注意的是，我们使用Apache Common Lang包来实现equals()和hashCode()方法，这些方法除了常规的作用以外，当我们为控制器的处理器方法编写测试时，它们也是有用的。 既然我们说到了测试，那么我们继续讨论这个话题，并为新的控制器方法编写测试， 123456789101112131415161718192021222324252627@Test public void houldShowRecentSpittles() throws Exception &#123; List&lt;Spittle&gt; expectedSpittles = createSpittleList(20); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findSpittles(Long.MAX_VALUE, 20)) .thenReturn(expectedSpittles); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller) .setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")) .build(); mockMvc.perform(get("/spittles")) .andExpect(view().name("spittles")) .andExpect(model().attributeExists("spittleList")) .andExpect(model().attribute("spittleList", hasItems(expectedSpittles.toArray()))); &#125;/.................佩服老外，测试代码一大堆，省略了好多，好好研究下，..................../ private List&lt;Spittle&gt; createSpittleList(int count) &#123; List&lt;Spittle&gt; spittles = new ArrayList&lt;Spittle&gt;(); for (int i=0; i &lt; count; i++) &#123; spittles.add(new Spittle("Spittle " + i, new Date())); &#125; return spittles; &#125;&#125; 测试首先会创建SpittleRepository接口的mock实现，这个实现会从他的findSpittles()方法中返回20个Spittle对象，然后将这个Repository注入到一个新的SpittleController实例中，然后创建MockMvc并使用这个控制器。 需要注意的是这个测试在MockMvc构造器上调用了setSingleView().这样的话，mock框架就不用解析控制器中的视图名了。在很多场景中，其实没必要这么做，但是对于这个控制器方法，视图和请求路径非常相似，这样按照默认的驶入解析规则，MockMvc就会发生失败，因为无法区分视图路径和控制器的路径，在这个测试中，构建InternalResourceViewResolver时所设置的路径是无关紧要的，但我们将其设置为InternalResourceViewResolver一致。 这个测试对“/spittles”发起Get请求，然后断言视图的名称为spittles并且模型中包含名为spittleList的属性，在spittleList中包含预期的内容。 当然如果此时运行测试的话，它将会失败。他不是运行失败，而是编译的时候就失败，这是因为我们还没编写SpittleController。 123456789101112131415@Controller@RequestMapping("/spittles")public class SpittleController &#123; private SpittleRepository spittleRepository; @Autowired public SpittleController(SpittleRepository spittleRepository) &#123; //注入SpittleRepository this.spittleRepository = spittleRepository; &#125; @RequestMapping(method = RequestMethod.GET) public String spittles(Model model) &#123; model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名 &#125;&#125; 我们可以看到SpittleController有一个构造器，这个构造器使用@Autowired注解，用来注入SpittleRepository。这个SpittleRepository随后又在spittls()方法中，用来获取最新的spittle列表。 需要注意的是我们在spittles()方法中给定了一个Model作为参数。这样，spittles()方法就可以将Repository中获取到的Spittle列表填充到模型中，Model实际上就是一个Map(也就是key-value的集合)它会传递给视图，这样数据就能渲染到客户端了。当调用addAttribute()方法并且指定key的时候，那么key会根据值的对象类型来推断确定。 sittles()方法最后一件事是返回spittles作为视图的名字，这个视图会渲染模型。 如果你希望显示模型的key的话，也可以指定，123456@RequestMapping(method = RequestMethod.GET)public String spittles(Model model) &#123; model.addAttribute("spittleList", spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名&#125; 如果你希望使用非Spring类型的话，那么可以使用java.util.Map来代替Model123456@RequestMapping(method = RequestMethod.GET)public String spittles(Map model) &#123; model.addAttribute("spittleList", spittleRepository.findSpittles(Long.MAX_VALUE,20)); // 将spittle添加到视图 return "spittles"; // 返回视图名&#125; 既然我们现在提到了各种可替代方案，那下面还有另外一种方式来编写spittles()方法 1234@RequestMapping(method = RequestMethod.GET)public List&lt;String&gt; spittles() &#123; return spittleRepository.findSpittles(Long.MAX_VALUE,20));&#125; 这个并没有返回值，也没有显示的设定模型，这个方法返回的是Spittle列表。。当处理器方法像这样返回对象或集合时，这个值会放到模型中，模型的key会根据其类型推断得出。在本示例中也就是(spittleList) 逻辑视图的名称也会根据请求的路径推断得出。因为这个方法处理针对“/spittles”的GET请求，因此视图的名称将会是spittles，（去掉开头的线。） 不管使用哪种方式来编写spittles()方法，所达成的结果都是相同的。模型会存储一个Spittle列表，ket为spittleList，然后这个列表会发送到名为spittles的视图中。视图的jsp会是“/WEB-INF/views/spittles.jsp” 现在数据已经放到了模型中，在JSP中该如何访问它呢？实际上，当视图是JSP的时候，模型数据会作为请求属性放入到请求之中(Request) ,因此在spittles.jsp文件中可以使用JSTL(JavaServer Pages Standard Tag Library) 的&lt;c:forEach&gt;标签渲染spittle列表。 123456789&lt;c:forEach items="$&#123;spittleList&#125;" var="spittle" &gt; &lt;li id="spittle_&lt;c:out value="spittle.id"/&gt;"&gt; &lt;div class="spittleMessage"&gt;&lt;c:out value="$&#123;spittle.message&#125;" /&gt;&lt;/div&gt; &lt;div&gt; &lt;span class="spittleTime"&gt;&lt;c:out value="$&#123;spittle.time&#125;" /&gt;&lt;/span&gt; &lt;span class="spittleLocation"&gt;(&lt;c:out value="$&#123;spittle.latitude&#125;" /&gt;, &lt;c:out value="$&#123;spittle.longitude&#125;" /&gt;)&lt;/span&gt; &lt;/div&gt; &lt;/li&gt;&lt;/c:forEach&gt; 尽管SpittleController很简单，但是它依然比homeController更进一步，不过，SpittleController和HomeController都没有处理任何形式的输入。现在，让我们扩展SpittleContorller，让它从客户端接受一些输入。 5.3 接受请求的输入Spring MVC 允许以多种方法将客户端中的数据传送到控制器的处理器方法中 查询数据(Query Parameter) 表单参数(Form Parameter) 路径变量(Path Variable) 作为开始，先来看下如何处理带有查询参数的请求，这也是客户端往服务器发送数据时，最简单和最直接的方法。 5.3.1 处理查询参数在Spittr应用中，可能需要处理的一件事就是展现分页的Spittle列表，如果你想让用户每次查看某一页的Spittle历史，那么就需要提供一种方式让用户传递参数进来，进而确定展现那些Spittle列表。 为了实现这个分页功能，我们编写的处理方法要接受两个参数 before参数 (表明结果中所有的SPittle的ID均在这个值之前) count参数(彪悍在结果中要包含的Spittle数量) 为了实现这个功能，我们将程序修改为spittles()方法替换为使用before参数和count参数的新spittles()方法。 首先添加一个测试，这个测试反映了xinspittles()方法的功能 123456789101112131415161718@Testpublic void shouldShowPagedSpittles() throws Exception &#123; List&lt;Spittle&gt; expectedSpittles = createSpittleList(50); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findSpittles(238900, 50)) .thenReturn(expectedSpittles); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller) .setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")) .build(); mockMvc.perform(get("/spittles?max=238900&amp;count=50")) .andExpect(view().name("spittles")) .andExpect(model().attributeExists("spittleList")) .andExpect(model().attribute("spittleList", hasItems(expectedSpittles.toArray())));&#125; 这个测试方法关键点在于同时传入了max和count参数，它测试了这些参数存在时的处理方法，而另一个则测试了没有这些参数的情景。 在这个测试之后，我们就能确保不管控制器发生了什么样的变化，它都能够处理这两种类型的请求。 123456@RequestMapping(method = RequestMethod.GET)public List&lt;Spittle&gt; spittles( @RequestParam(value = "max") long max, @RequestParam(value = "count") int count) &#123; return spittleRepository.findSpittles(max, count);&#125; SittleController中的处理器方法同时要处理有参数和没参数的场景，那我们需要对其进行修改，让它能接受参数。同时如果这些参数在请求中不存在的话，就是用默认值Long.MAX_VALUE和20.@RequestParam注解的defaultValue属性可以完成这个任务。 123456@RequestMapping(method=RequestMethod.GET)public List&lt;Spittle&gt; spittles( @RequestParam(value="max", defaultValue=MAX_LONG_AS_STRING) long max, @RequestParam(value="count", defaultValue="20") int count) &#123; return spittleRepository.findSpittles(max, count);&#125; 现在如果max如果没有参数指定的话，它将会是Long的最大值。 因为查询参数都是String 类型 ，因此defaultValue属性需要String类型， 1private static final String MAX_LONG_AS_STRING = long.toString(Long.MAX.VALUE) 请求中的查询参数是往控制器中传递信息的常用手段。另外一种方式就是将传递的参数作为请求路径的一部分。 5.3.2 通过路径参数接受输入假设我们的应用程序需要根据给定的ID来展现某一个Spittle记录。其中一种方案就是编写处理器方法，通过使用@RequestParam注解，让它接受ID作为查询参数。 123456@RequestMapping(value="/show",method = RequestMethod.GET)public String showSpittle( @RequestParam("spittle_id") long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; 在理想情况下，要识别资源应用应该通过URL路径来标识，而不是通过查询参数。对“/spittles/12345”发起请求要优于对“/spittles/show?spittle_id=12345”发起的请求。前者能识别出要查询的资源，而后者描述的是带有参数的一个操作——本质上是通过HTTP发起的RPC。 既然已经以面向资源的控制器作为目标，那我们将这个需求转化为一个测试。 1234567891011121314@Testpublic void testSpittle() throws Exception &#123; Spittle expectedSpittle = new Spittle("Hello", new Date()); SpittleRepository mockRepository = mock(SpittleRepository.class); when(mockRepository.findOne(12345)).thenReturn(expectedSpittle); SpittleController controller = new SpittleController(mockRepository); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(get("/spittles/12345")) .andExpect(view().name("spittle")) //断言图片的名称为spittle .andExpect(model().attributeExists("spittle")) //预期Spittle放到了模型之中 .andExpect(model().attribute("spittle", expectedSpittle));&#125; 这个测试构建了一个mockRepository，一个控制器和MockMvc 到目前为止，我们所编写的控制器，所有的方法都映射到了静态定义好的路径上，还需要包含变量部分 为了实现这种路径变量，Spring MVC允许我们在@RequestMapping路径中添加占位符，占位符的名称需要({..}),路径中的其他部分要与所处理的请求完全匹配，但是占位符可是是任意的值。 12345@RequestMapping(value="/&#123;spittleId&#125;",method = RequestMethod.GET)public String showSpittle(@PathVariable("spittleId") long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; @PathVariable(“spittleId”) 表明在请求路径中，不管占位符部分的值是什么都会传递给处理器方法的showSpittle参数中。 也可以去掉这个value的值，因为方法的参数碰巧与占位符的名称相同。12345@RequestMapping(value="/&#123;spittleId&#125;",method = RequestMethod.GET)public String showSpittle(@PathVariable long spittleId, Model model) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; 如果传递请求中少量的数据，那查询参数和路径变量是合适的，但通常我们还需要传递很多的数据，(表单数据)，那么查询显得有些笨拙和受限制了。 5.4 处理表单Web应用的功能不局限于为用户推送内容，大多数的应用允许用户填充表单，并将数据提交回应用中，通过这种方式实现与用户的交互。 使用表单分为两个方面：展现表单以及处理用户通过表单提交的数据。在Spittr应用中，我们需要有个表单让用户进行注册，SitterController是一个新的控制器，目前只有一个请求处理的方法来展现注册表单。 123456789@Controller@RequestMapping("/spitter")public class SpitterController &#123; //处理对“/spitter/register” @RequestMapping(value = "/register",method = RequestMethod.GET) public String showRegistrationForm() &#123; return "registerForm"; &#125;&#125; 测试展现表单的控制器方法(老外每次都测试) 12345678@Testpublic void shouldShowRegistration() throws Exception &#123; SpitterController controller = new SpitterController(); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(get("/spitter/register")) .andExpect(view().name("registerForm"));&#125;&#125; 这个JSP必须包含一个HTML标签，123456&lt;form method="POST" name="spittleForm"&gt; &lt;input type="hidden" name="latitude"&gt; &lt;input type="hidden" name="longitude"&gt; &lt;textarea name="message" cols="80" rows="5"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type="submit" value="Add" /&gt;&lt;/form&gt; 需要注意的是这里的标签中并没有设置action属性。在这种情况下，当表单体提交的时，它会提交到与展现时相同的URL路径上，它会提交到“/spitter/reqister”上。 这意味着需要在服务器端编写该HTTP POST请求。 5.4.1 编写处理表单的处理器当处理注册表单的POST请求时，控制器需要接受表单数据，并将表单数据保存为Spitter对象。最后为了防止重复提交(用户刷新页面)，应该将浏览器重定向到新创建用户的基本信息页面。 1234567891011121314151617181920@Testpublic void shouldProcessRegistration() throws Exception &#123; SpitterRepository mockRepository = mock(SpitterRepository.class); Spitter unsaved = new Spitter("jbauer", "24hours", "Jack", "Bauer", "jbauer@ctu.gov"); Spitter saved = new Spitter(24L, "jbauer", "24hours", "Jack", "Bauer", "jbauer@ctu.gov"); when(mockRepository.save(unsaved)).thenReturn(saved); SpitterController controller = new SpitterController(mockRepository); MockMvc mockMvc = standaloneSetup(controller).build(); mockMvc.perform(post("/spitter/register") .param("firstName", "Jack") .param("lastName", "Bauer") .param("username", "jbauer") .param("password", "24hours") .param("email", "jbauer@ctu.gov")) .andExpect(redirectedUrl("/spitter/jbauer")); verify(mockRepository, atLeastOnce()).save(unsaved);&#125; 希望大家也可以学会这样方式 在构建完SpitterRepository的mock实现以及所要执行的控制器和MockNvc之后，shouldProcessRegistration()对“/spitter/register”发起了一个POST请求，作为请求的一部分，用户信息以参数的形式放到request中，从而模拟提交的表单。 12345678910111213141516171819202122232425/** * Created by guo on 24/2/2018. */@Controller@RequestMapping("/spitter")public class SpitterController &#123; private SpitterRepository spitterRepository; @Autowired public SpitterController(SpitterRepository spitterRepository) &#123; //注入SpiterRepository this.spitterRepository = spitterRepository; &#125; @RequestMapping(value = "/register", method = RequestMethod.GET) public String showRegistrationForm() &#123; return "registerForm"; &#125; @RequestMapping(value = "/register",method = RequestMethod.POST) public String procesRegistration(Spitter spitter) &#123; spitterRepository.save(spitter); //保存Spitter return "redirect:/spitter/" + spitter.getUsername(); //重定向到基本信息页面 &#125;&#125; 返回一个String类型，用来指定视图。但是这个视图格式和以前有所不同。这里不仅返回了视图的名称供视图解析器查找目标视图，而且返回的值还带有重定向的格式return &quot;redirect:/spitter/&quot; 当看到视图格式中有“redirect：”前缀时，它就知道要将其解析为重定向的规则，而不是试图的名称。在本例中，它将会重定向到基本信息的页面。 需要注意的是除了可以“redirect”还可以识别“forward：”前缀，请求将会前(forward)往指定的URL路径，而不再是重定向。 在SpitterController中添加一个处理器方法，用来处理对基本信息页面的请求。 123456@RequestMapping(value = "/&#123;username&#125;",method = RequestMethod.GET)public String showSpitterProfile(@PathVariable String username, Model model) &#123; Spitter spitter = spitterRepository.findByUsername(username); model.addAttribute(spitter); return "profile";&#125; spitterRepository通过用户获取一个Spitter对象，showSpitterProfile()方法得到这个对象并将其添加到模型中，然后返回profile。也就是基本信息页面的逻辑视图。 123456&lt;body&gt; &lt;h1&gt;Your Profile&lt;/h1&gt; &lt;c:out value="$&#123;spitter.username&#125;" /&gt;&lt;br/&gt; &lt;c:out value="$&#123;spitter.firstName&#125;" /&gt; &lt;c:out value="$&#123;spitter.lastName&#125;" /&gt;&lt;br/&gt; &lt;c:out value="$&#123;spitter.email&#125;" /&gt;&lt;/body&gt; 注意：这里使用H2数据库，太有用了。123456789101112131415@Configurationpublic class DataConfig &#123; @Bean public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("schema.sql") .build(); &#125; @Bean public JdbcOperations jdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 如果表单中没有发送username或password，会发生什么情况呢？或者名字太长，由会怎么样？，接下来，让我们看一下为表单添加校验，而从避免数据呈现不一致性。 5.4.2 校验表单如果用户在提交表单的时候，username和password为空的话，那么将会导致在新建Spitter对象中，username和password是空的String。如果不处理，将会出项安全问题。 同时我们应该阻止用户提交空的名字。限制这些输入的长度。 从Spring 3.0 开始，在Spring MVC中提供了java校验的API的支持。只需要在类路径下包含这个JavaAPI的实现即可。比如Hibernate validator. Java校验API定义了多个注解，这些注解可以用在属性上，从而限制这些属性的值。 @Size :所注解的元素必须是String、集合、或数组，并且长度要符合要求 @Null ：所注解的值必须为Null @NotNull ：所注解的元素不能为Null。 @Max ：所注解的必须是数字，并且值要小于等于给定制。 @Min @Past ：所注解的元素必须是一个已过期的日期 @Future ：必须是一个将来的日期 @Pattern：必须匹配给定的正则表达式 1234567891011121314151617181920212223242526public class Spitter &#123; private Long id; @NotNull @Size(min=5, max=16) private String username; @NotNull @Size(min=5, max=25) private String password; @NotNull @Size(min=2, max=30) private String firstName; @NotNull @Size(min=2, max=30) private String lastName; @NotNull @Email private String email; 忽略其他方法。&#125; 1234567891011@RequestMapping(value="/register", method=POST) //老外喜欢静态导入特性public String processRegistration( @Valid Spitter spitter, //校验Spitter输入 Errors errors) &#123; if (errors.hasErrors()) &#123; return "registerForm"; //如果校验出现错误，则重新返回表单 &#125; spitterRepository.save(spitter); return "redirect:/spitter/" + spitter.getUsername();&#125; Spitter参数添加了@Valid注解，这会告诉Spring，需要确保这个对象满足校验限制。 如果表单出错的话，那么这些错误可以通过Errors进行反问。 很重要一点需要注意的是：Errors参数要紧跟在带有Valid注解参数的后面。@Valid注解所标注的就是要校验的参数。 如果没有错误的话，Spitter对象将会通过Repository进行保存，控制器会像之前那样重定向到基本信息页面。 5.5 小节在本章中，我们为编写应用程序的Web部分开来一个好头，可以看到Spring有一个强大而灵活的Web框架。借助于注解，Spring MVC 提供了近似于POJO的开发模式，这使得开发处理请求的控制器变得简单，同时也易于测试。 当编写控制器的处理方法时，Spring MVC及其灵活。概括来讲，如果你的处理器方法需要内容的话，只需将对应的对象作为参数，而他不需要的内容，则没有必要出现在参数列表中。这样，就为请求带来了无限的可能性，同时还能保持一种简单的编程模型。 尽管本章中很多内容都是关于控制器的请求处理的，但是渲染响应也同样重要，我们通过使用JSP的方式，简单了解了如何为控制器编写视图，但是，就Spring MVC视图来说，它并不是本章所看到的简单JSP。 在接下来的第6章，我们将会更深入的学习Spring视图，包括如何在JSP中使用Spring标签库，还会学习如何借助于Apache Tiles为视图添加一致的结构。同时，还会了解Thymeleaf，这是一个很有意思的JSP替代方法，Spring为其提供了内置的支持。 参考：https://github.com/guoxiaoxu/SpringInActionPractice]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记四]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16-1%2F</url>
    <content type="text"><![CDATA[第四章 面向切面的Spring本章主要内容： 面向切面编程的基本原理 通过POJO创建切面 使用@Aspect注解 为AspectJ切面注入依赖。 在软件开发中，散布于应用中多出功能被称为横切关注点(crosscutting concern)。通常来讲横切关注点从概念上是与应用的业务逻辑分离的。但往往是耦合在一起的，把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)所要解决的问题。 依赖注入(DI)管理我们的应用对象，DI有助于应用对象之间解耦。而AOP可以实现横切关注点与它们所影响的对象之间的耦合。 4.1 什么是面向切面编程切面能够帮我们模块化横切关注点。简而言之，横切关注点可以被描述为影响应用多处的功能。例如 安全，事务、日志等功能。 如果要重用对象的话，最常见的面向对象技术是继承、委托、组合。但是，如果整个应用中都使用相同的基类，继承往往会导致一个脆弱的对象体系。而使用委托可能需要委托对象进行复杂的调用。 切面提供了取代继承和委托的另一种可选方案。在使用面向切面编程时，我们仍然在一个地方定义通知功能，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面(aspect). 这样做带来两个好处：每个关注点都集中到一个地方，而不是分散到多处代码中：其次，服务模块更简洁，因为它只包含了主要关注点(核心功能)的代码。而次要关注的代码被移到切面中了。 4.1.1 定义AOP术语描述切面的常用术语有：通知(advice)、切点(pointcut)、连接点。 通知(advice)通知定义了切面是什么以及何时使用。除了描述切面要完成的工作外，通知还解决了何时执行这个工作问题。它应该在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？ Spring切面可以应用5中类型的通知： 前置通知(Before):在目标方法被调用之前调用通知功能。 后置通知(After):在目标方法完成之后调用通知 返回通知(After-returning):在目标方法成功执行之后调用通知 异常通知(After-throwing):在目标方法抛出异常后调用通知 环绕通知(Around):在被通知方法调用之前和调用之后执行自定义的行为 连接点我们的应用可能有数以千计的时机应用通知，这些时机被称为连接点。连接点是在应用执行过程中能够插入的一个点。这个点可以是调用方法时，抛出异常时，甚至修改一个字段时。切面可以利用这些点插入到应用的正常流程之中，并添加新的行为。 切点如果说通知定义了切面的的“什么”和“何时”，那么切点定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。 切面切面是通知和切点的结合。通知和切点通过定义了切面的全部 内容——他是什么，在什么时候和在哪里完成其功能。 引入引入允许我们向现有的类添加新的方法或者属性。 织入织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象。在目标对象的生命周期里有多个点可以进行织入： 编译期：切面在目标类编译时被织入。Aspect的织入编译器就是以这种方式织入切面的。 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载(Classloader)，它可以在目标类被引入之前增强该目标类的字节码(CGlib) 运行期：切面在应用运行时的某个时刻被织入。AOP会为目标对象创建一个代理对象。Spring AOP就是以这种方式织入切面的。 通知包含了需要用于多个应用对象的横切关注点。连接点是程序执行过程中能够应用通知的所有点。切点定义了通知被应用的具体位置(在哪些连接点)，其中关键是切点定义了哪些连接点会得到通知。 4.1.2 Spring对AOP的支持并不是所有的AOP框架都是相同的，他们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别的通知，而另一些只支持与方法调用相关的连接点。它们织入切面的方式和时机也有所不同。但是，无论如何，创建切点来定义切面所织入的连接点是AOP的基本功能。 **Spring提供了4种类型的AOP支持： 基于代理的经典Spring AOP（不推荐） 纯POJO切面 @AspectJ注解驱动的切面 注入式AspectJ切面** 前三种都是Spirng AOP实现的变体，Spring AOP构建在动态代理基础上。因此，Spring对AOP的支持局限于方法拦截。 引入了简单的声明式AOP与基于注解的AOP之后，Spring经典的看起来就显得非常笨拙和过于复杂话，直接使用ProxyFactory bean 会让人感觉厌烦。 借助于Spring的aop命名空间，我们可以将纯POJO转为切面。 Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP，但是编程模型几乎与编写成熟的AspectJ注解切面完全一致。这种AOP风格的好处在于能够不使用XML来完成功能。 Spring通知是Java编写的Spring所创建的通知都是用标准的Java类编写的，定义通知所应用的切点通常会使用注解或在Spring配置文件里采用XML来编写 Spring在运行时通知对象 通知带代理类中包裹切面，Spring在运行时把切面织入到Spring所管理的bean中。代理类封装了目标类，并拦截被通知方法的调用。再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。直到应用需要被代理bean时，Spring才会创建代理对象。如果使用ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有的bean的时候，Spring才会创建被代理的对象。因为Spirng运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。 Spring只支持方法级别的连接点Spring基于动态代理，所以Spring只支持方法连接点。方便拦截可以满足大部分的需求。 4.2 通过切点来选择连接点切点用于准确定位应该在什么地方应用切面的通知。通知和切点是切面最基本的元素。 Spring仅支持AspectJ切点指示器的一个子集。Spring是基于代理的，而某些切点表达式是基于代理的AOP无关的。 Spring支持的指示器，只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。这说明execution指示器是我们在编写切点定义时最主要的指示器。 4.2.1编写切点为了阐述Spring中的切面， 我们需要有个主题来定义切面的切点。 1234package com.guo.cocert;public interface Performance &#123; public void perform();&#125; 1execution(* concert.Performance.perform(..)) 我们使用execution()指示器选择Performance的perform()方法，方法表达式以”*”号开始，表明了我们不关心方法返回值的类型。然后指明了全限定类名和方法名，对于方法参数列表，我们使用了两个点号(..)表明切点要选择任意的perform()方法，无论该方法的入参是什么。 现在假设我们需要配置的切点仅匹配concert包，可以使用within()指示器 1execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*) 因为“&amp;”在XMl中有特殊的含义，所以在Spring和XML配置中，描述切点时，可以使用and代替“&amp;&amp;”。 4.2.2 在切点中选择beanSpring引入了一个新的bean()指示器，它允许我们在切点表达式中使用bean的ID来标识bean。bean()使用bean ID 或 bean 名称作为参数来限制切点只匹配特定的bean。 1execution(* concert.Performance.perform(..)) and bean("woodsotck") 也可以这样 1execution(* concert.Performance.perform(..)) and ！bean("woodsotck") 切面的通知会被编织到所有ID不为woodsotck的bean中。 4.3.1 定义切面如果一场演出没有观众的话，那不能称之为演出。对不对？从演出的角度来看，观众是非常 重要的，但是对演出本身的功能来讲，它并不是核心，这是一个单独的关注点。因此，将观 众定义为一个切面，并将其应用到演出上就是较为明智的做法。 下面展现了Audience类，它定义了我们所需的一个切面 1234567891011121314151617181920212223242526272829package com.spring.sample.concert;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class Audience &#123; @Before("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void silenceCellPhones() &#123; System.out.println("Silencing cell phones"); &#125; @Before("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void takeSeats() &#123; System.out.println("Taking seats"); &#125; @AfterReturning("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void applause() &#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; @AfterThrowing("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void demandRefund() &#123; System.out.println("Demand a refund"); &#125;&#125; Audience类使用@AspectJ注解进行了标注。该注解表明Audience不仅仅是一个POJO， 还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。 Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众 要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出 很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的 话，观众会要求退款（demandRefund()）。 可以看到，这些方法都使用了通知注解来表明它们应该在什么时候调用。AspectJ提供了五个 注解来定义通知，如表4.2所示。 你可能已经注意到了，所有的这些注解都给定了一个切点表达式作为它的值，同时，这四个 方法的切点表达式都是相同的。其实，它们可以设置成不同的切点表达式，但是在这里，这 个切点表达式就能满足所有通知方法的需求。让我们近距离看一下这个设置给通知注解的切 点表达式，我们发现它会在Performance的perform()方法执行时触发。 相同的切点表达式我们重复了四遍，这可真不是什么光彩的事情。这样的重复让人感觉有些 不对劲。如果我们只定义这个切点一次，然后每次需要的时候引用它，那么这会是一个很好 的方案。 幸好，我们完全可以这样做：@Pointcut注解能够在一个@AspectJ切面内定义可重用的 切点。接下来的程序清单4.2展现了新的Audience，现在它使用了@Pointcut。 1234567891011121314151617181920212223242526272829package com.spring.sample.concert;import org.aspectj.lang.annotation.*;@Aspectpublic class Audience &#123; @Pointcut("execution(* com.spring.sample.concert.Performance.perform( .. ))") public void performance() &#123;&#125; @Before("performance()") public void silenceCellPhones() &#123; System.out.println("Silencing cell phones"); &#125; @Before("performance()") public void takeSeats() &#123; System.out.println("Taking seats"); &#125; @AfterReturning("performance()") public void applause() &#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; @AfterThrowing("performance()") public void demandRefund() &#123; System.out.println("Demand a refund"); &#125;&#125; 除了作为标记的 performance() 方法，Audience 类完全是一个 POJO，因此它也可以像普通 Java 类一样使用： 1234@Beanpublic Audience audience() &#123; return new Audience();&#125; 到此为止，Audience 仅仅是位于 Spring 容器中的一个 bean，即使它被 AspectJ 注解修饰，如果没有别的配置解释这个注解，并创建能够将它转换成切面的代理，则它不会被当做切面使用。 如果你使用 JavaConfig，则可以通过类级别的 @EnableAspectJAutoProxy 注解开启自动代理机制，例子代码如下所示： 12345678910111213141516package com.spring.sample.concert;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration@EnableAspectJAutoProxy //开启AspectJ的自动代理机制@ComponentScanpublic class ConcertConfig &#123; @Bean public Audience audience() &#123; //定义Audience的bean return new Audience(); &#125;&#125; 如果你使用 XML 配置，则可以使用 &lt;aop: aspectj-autoproxy /&gt; 元素开启 AspectJ 的自动代理机制，对应的配置代码如下： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.spring.sample.concert&quot; /&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;bean class=&quot;com.spring.sample.concert.Audience&quot; /&gt;&lt;/beans&gt; 无论使用 JavaConfig 还是 XML 配置文件，AspectJ 的自动代理机制使用由 @Aspect 注解修饰的 bean 为那些被切点指定的 beans 创建代理。在这个例子中，将会为 Performance 接口创建代理，并在 perform() 方法调用前或者调用后应用切面中的通知方法。 特别要记住：Spring 中的 AspectJ 自动代理机制本质上还是 Spring 中基于代理的切面，因此，虽然你使用了 @Aspect 注解，但是仍然仅能支持函数调用级别的拦截。如果你希望使用 AspectJ 的功能，那么你得使用 AspectJ 的运行时并且不要使用 Spring 创建基于代理的切面。 环绕通知（around advice）与其他通知类型不同，因此值得用一小节单独论述。 4.3.2 创建环绕通知环绕通知是最为强大的通知类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起 来。实际上就像在一个通知方法中同时编写前置通知和后置通知。 为了阐述环绕通知，我们重写Audience切面。这次，我们使用一个环绕通知来代替之前多 个不同的前置通知和后置通知。 12345678910111213141516171819202122package com.spring.sample.concert;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;@Aspectpublic class Audience &#123; @Pointcut(&quot;execution(* com.spring.sample.concert.Performance.perform( .. ))&quot;) public void performance() &#123;&#125; @Around(&quot;performance()&quot;) public void watchPerformance(ProceedingJoinPoint joinPoint) &#123; try &#123; System.out.println(&quot;Silencing cell phones&quot;); System.out.println(&quot;Taking seats&quot;); joinPoint.proceed(); System.out.println(&quot;CLAP CLAP CLAP!!!&quot;); &#125; catch (Throwable e) &#123; System.out.println(&quot;Demanding a refund&quot;); &#125; &#125;&#125; @Around 注解表示 watchPerformance() 方法将作为环绕通知应用在与切点——performance() 匹配的方法上。这个方法实现的效果跟之前的四个函数完全相同，但是有一点不同，即该函数有一个参数——ProceedingJoinPoint 实例，这里需要通过这个参数主动调用业务函数——joinPoint.proceed();。在环绕通知中必须调用 proceed() 方法，如果没有，则应用的执行会阻塞在通知方法中。 你还可以在一个通知中多次调用 proceed() 方法，从而可以实现重试逻辑——业务逻辑可能失败，可以限定失败重试的次数。 4.3.3 处理通知中的参数截止目前为止，我们编写的切面都非常简单——没有接收输入参数。仅有的例外是环绕通知中需要使用 ProceedingJoinPoint 参数，除此之外其他通知都没有携带任何参数传入被通知的方法中，那是因为 perform() 方法本身不需要任何参数。 如果你的切面要通知的是一个带参数的函数？切面是否能访问传入函数的参数并使用它们？举个例子说明，BlankDisc 类中有一个 play() 方法，该方法的功能是遍历所有的 tracks 并利用每个 track 对象调用 playTrack() 方法。 1234567891011121314151617181920212223242526272829303132package com.spring.sample.soundsystem;import org.springframework.stereotype.Component;import java.util.List;@Componentpublic class BlankDisc implements CompactDisc &#123; private String title; private String artist; private List&lt;String&gt; tracks; public BlankDisc() &#123; &#125; public BlankDisc(String artist, String title, List&lt;String&gt; tracks) &#123; this.artist = artist; this.title = title; this.tracks = tracks; &#125; public void play() &#123; System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist); for (String track: tracks) &#123; System.out.println(&quot;-Track: &quot; + track); &#125; &#125; public void playTrack(int num) &#123; System.out.println(&quot;-Track: &quot; + tracks.get(num)); &#125; //setter和getter在此处省略&#125; 现在你希望记录每个 track 被调用的次数，一种方法是直接修改 playTrack() 方法，通过一个全局变量（例如 Map 数据结构）记录每个 track 被调用的次数。但是，track-counting 这个逻辑跟 play track 实际上是两个不同的关注点，因此应该考虑通过 AOP 实现。 首先定义一个切面，即 TrackCounter 类，并在 playTrack() 方法出进行通知，代码可列举如下： 1234567891011121314151617181920212223242526package com.spring.sample.soundsystem;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import java.util.HashMap;import java.util.Map;@Aspectpublic class TrackCounter &#123; private Map&lt;Integer, Integer&gt; trackCounts = new HashMap&lt;Integer, Integer&gt;(); @Pointcut( &quot;execution(* com.spring.sample.soundsystem.CompactDisc.playTrack( .. )) &quot; + &quot;&amp;&amp; args(trackNumber)&quot;) public void trackPlayed(int trackNumber) &#123;&#125; @Before(&quot;trackPlayed(trackNumber)&quot;) public void countTrack(int trackNumber) &#123; int currentCount = getPlayCount(trackNumber); trackCounts.put(trackNumber, currentCount + 1); &#125; public int getPlayCount(int trackNumber) &#123; return trackCounts.containsKey(trackNumber) ？ trackCounts.get(trackNumber) : 0; &#125;&#125; 跟上一小节创建的切面类似，首先利用 @Pointcut 注解定义一个切点，然后利用 @Before 注解定义前置通知。不同的地方在于切点的定义，除了指定被通知的方法，还指定了被通知方法需要的参数 trackNumber。下图展示如何理解切点的定义。 关键在于 args(trackNumber) 标识符，这表示每个传入业务函数 playTrack() 的 int 参数也将被传入通知，而且，args() 中参数的名称必须跟切点方法的签名中的参数名称相同，例如： 1234@Pointcut( &quot;execution(* com.spring.sample.soundsystem.CompactDisc.playTrack( .. )) &quot; + &quot;&amp;&amp; args(ex)&quot;)public void trackPlayed(int ex) &#123;&#125; 同样，@Before 注解中利用切点函数定义的参数名称，也必须与通知方法签名中的参数完全相同，例如： 12345@Before(&quot;trackPlayed(duqi)&quot;)public void countTrack(int duqi) &#123; int currentCount = getPlayCount(duqi); trackCounts.put(duqi, currentCount + 1);&#125; 然后在 Spring 的配置文件中配置 BlankDisc 和 TrackCounter，并开启 AspectJ 自动代理机制，配置文件代码如下： 1234567891011121314151617181920212223242526272829303132package com.spring.sample.soundsystem;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;import java.util.ArrayList;import java.util.List;@Configuration@EnableAspectJAutoProxypublic class TrackCounterConfig &#123; @Bean public CompactDisc sgtPeppers() &#123; BlankDisc cd = new BlankDisc(); cd.setTitle(&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;); cd.setArtist(&quot;The Beatles&quot;); List&lt;String&gt; tracks = new ArrayList&lt;String&gt;(); tracks.add(&quot;Sgt. Pepper&apos;s Lonely Hearts Club Band&quot;); tracks.add(&quot;With a Little Help from My Friends&quot;); tracks.add(&quot;Lucky in the Sky with Diamonds&quot;); tracks.add(&quot;Getting Better&quot;); tracks.add(&quot;Fixing a Hole&quot;); tracks.add(&quot;testtest&quot;); tracks.add(&quot;hhhhhhhhhh&quot;); cd.setTracks(tracks); return cd; &#125; @Bean public TrackCounter trackCounter() &#123; return new TrackCounter(); &#125;&#125; 最后，为了验证我们的想法，需要写个单元测试用例进行验证，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738package com.spring.sample.soundsystem;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.*;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = TrackCounterConfig.class)public class TrackCounterTest &#123; @Autowired private CompactDisc cd; @Autowired private TrackCounter counter; @Test public void testTrackCounter() &#123; cd.playTrack(0); cd.playTrack(1); cd.playTrack(2); cd.playTrack(2); cd.playTrack(2); cd.playTrack(2); cd.playTrack(6); cd.playTrack(6); assertEquals(1, counter.getPlayCount(0)); assertEquals(1, counter.getPlayCount(1)); assertEquals(4, counter.getPlayCount(2)); assertEquals(0, counter.getPlayCount(3)); assertEquals(0, counter.getPlayCount(4)); assertEquals(0, counter.getPlayCount(5)); assertEquals(2, counter.getPlayCount(6)); &#125;&#125; TrackCounter 这个切面可以在显存函数的基础上进行进一步封装，不过除了函数封装，还可以利用切面给被通知的对象引入新的功能。 4.3.4 使用基于注解的切面引入新功能在一些动态语言（Ruby、Groovy）中，存在开放类的特性，这种特性支持在不修改原来类或者对象的基础上为该类添加新方法。不过，Java 不是动态语言，一旦一个类被编译，你几乎不能再对它进行修改。 不过，仔细思考下，上述说的这个需求：在不修改原有类的基础上为该类添加新方法，这不正是切面可以完成的工作么？在上个小节的例子中我们是为原有类的方法添加了新的功能，同样，也可以为原来的类添加新的方法。这里通过 AOP 引出一个新的概念引入（introductions），即通过切面为 Spring 的 beans 增加新方法。 Spring 中切面的本质就是一个代理对象，这个代理对象与目前对象实现同一个接口。既然如此，那么可以扩展一下，如果代理对象实现新的接口呢？这样被这个切面通知的 bean 就好像又实现了一个新的接口——增加了新的功能，即使底层并没有修改原来的类。下图展示了这个思路： 当 introduced 接口的某个方法被调用时，代理对象会把这个调用委托给一个实现了该 introduced 接口的对象。对于外部而言，就好像一个 bean 实现了多个接口。 举个例子，假设你要把下面这个 Encoreable 接口引入给 Performance 接口的任何实现。 123public interface Encoreable &#123; void performEncore();&#125; 你当然可以让原来 Performance 接口的实现也同时实现这个接口，但是关键是并不是所有的 Performance 实现都需要引入 Encoreable；而且，从应用维护的角度看，全部修改 Performance 的实现容易引入新的 bug；另外，如果 Performance 接口来自第三方库，你也没有办法接触到源码。 那么利用 Spring AOP 如何操作呢？首先准备一个 introduced 接口的默认实现类，代码如下： 1234567package com.spring.sample.concert;public class DefaultEncoreable implements Encoreable &#123; public void performEncore() &#123; System.out.println(&quot;perform the encore!&quot;); &#125;&#125; 然后新建一个切面，即 EncoreableIntroducer 类，代码列举如下： 1234567891011package com.spring.sample.concert;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.DeclareParents;@Aspectpublic class EncoreableIntroducer &#123; @DeclareParents(value = &quot;com.spring.sample.concert.Performance+&quot;, defaultImpl = DefaultEncoreable.class) public static Encoreable encoreable;&#125; EncoreableIntroducer 是一个切面，但和之前学过的切面不同在于它没有定义各种通知，它通过 @DeclareParents 注解将 Encoreable 接口引入到 Performance 接口的实现中。 @DeclareParents注解由三部分组成： value属性指定了哪种类型的bean要引入该接口。在本例中，也就是所有实现 Performance的类型。（标记符后面的加号表示是Performance的所有子类型，而 不是Performance本身。） defaultImpl属性指定了为引入功能提供实现的类。在这里，我们指定的 是DefaultEncoreable提供实现。 @DeclareParents注解所标注的静态属性指明了要引入了接口。在这里，我们所引入 的是Encoreable接口。 跟其他切面的用法类似，需要在 Spring 应用上下文中定义 EncoreableIntroducer bean，如果使用 JavaConfig，则代码如下： 1234@Beanpublic EncoreableIntroducer encoreableIntroducer() &#123; return new EncoreableIntroducer();&#125; Spring 的自动代理机制从这里获取这个 bean。当 Spring 发现一个被 @Aspect 注解修饰的 bean，就会自动为它创建一个代理对象，负责将外部的函数调用委托给目标 bean 或者新引入接口的实现，至于由哪个实现负责执行，取决于这个函数属于原接口还是新引入的接口。 书中没有的如果这个小节只说到这，你可能会有疑惑，那你说的这个引入新接口这么牛，什么场景下怎么使用呢？针对这个疑惑，我写了一个单元测试，代码如下： 12345678910111213141516171819202122package com.spring.sample.soundsystem;import com.spring.sample.concert.ConcertConfig;import com.spring.sample.concert.Encoreable;import com.spring.sample.concert.Performance;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = ConcertConfig.class)public class EncoreIntroducerTest &#123; @Autowired private Performance musicPerformance; @Test public void testEncore() &#123; Encoreable encoreable = (Encoreable)musicPerformance; //使用方法 encoreable.encore(); &#125;&#125; 可以看到，本来 musicPerformance 是 Performance 的实现，通过强转，我可以调用新接口中的方法了，而且没有修改原来的类和接口；而中间负责将函数调用委托给不同的实现对象的任务就是由切面自动完成。 4.4 在XML中声明切面之前，有这样一条原则：那就是基于注解的配置要优于Java的配置，基于Java的配置要优于XMl的配置，但是，如果你需要声明切面，但是又不能为通知类添加注解的时候 ，那么就必须转向XML配置了。 在Spring的aop命名空间中，提供了多个元素用来在XML中声明切面， 4.4.1 声明前置通知和后置通知我们会使用Spring aop命名空间中的一些元素，将没有注解的Aurience类转为切面 12345678910111213&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:before pointcut="execution(* * concert.Performance.perform(..))" method="silenceCellIphones"/&gt; &lt;aop:before pointcut="execution(* * concert.Performance.perform(..))" method="takeSeats"/&gt; &lt;aop:after-returning pointcut="execution(* * concert.Performance.perform(..))" method="applause"/&gt; &lt;aop:after-throwing pointcut="execution(* * concert.Performance.perform(..))" method="demandRefund"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 第一需要注意的就是大多数AOP配置元素必须在aop:config元素的上下文中使用。 在所有的通知元素中，pointcut属性定义了通知所应用的切点，它的值是使用AspectJ切点表达式语法所定义的切点。 在基于Aspectj注解的通知中，当发现在这些类型的重复时，使用@Pointcut注解来消除这些重复的内容。 如下的XMl配置展示了如何将通用的切点表达式抽取到一个切点声明中，这样，这个声明就能在所有的通知元素中使用了 1234567891011121314&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:pointcut id="performance" expression="execution(* * concert.Performance.perform(..))" /&gt; &lt;aop:before pointcut="" method="silenceCellIphones"/&gt; &lt;aop:before pointcut-ref="performance" method="takeSeats"/&gt; &lt;aop:after-returning pointcut-ref="performance" method="applause"/&gt; &lt;aop:after-throwing pointcut-ref="performance" method="demandRefund"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 现在的切点是一个地方定义的，并且被多个通知元素所引用，aop:pointcut元素定义了一个id为performance的切点，同时修改所有的通知元素，用pointcut0ref来引用这个命名切点。 4.4.2 声明环绕通知例如，假设除了进场关闭手机和表演结束后鼓掌，我们还希望观众确保一直关注演出，并报 告每个参赛者表演了多长时间。使用前置通知和后置通知实现该功能的唯一方式是在前置通 知中记录开始时间并在某个后置通知中报告表演耗费的时间。但这样的话我们必须在一个成 员变量中保存开始时间。因为Audience是单例的，如果像这样保存状态的话，将会存在线 程安全问题。 相比于前置通知和后置通知，环绕通知在这点上有明显的优势。使用环绕通知，我们可以完成前置通知和后置通知所实现的相同功能，而且只需要在一个方法中实现。因为整个通知逻辑都是在一个方法中实现的。 12345678&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:pointcut id="performance" expression="execution(* * concert.Performance.perform(..))" /&gt; &lt;aop:around pointcut-ref="performance" method="watchPerformance"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 像其他通知的XML元素一样，aop:around指定了一个切点和一个通知方法的名字。 4.4.3 为通知传递参数12 区别在于切点表达式中包含了一个参数，这个参数传递到通知方法中。还有区别就是这里使用了and关键字 4.4.4 通过切面引入新的功能借助于AspectJ的@DeclareParents注解为被通知的方法引入新的方法。但是AOP引入并不是Aspectj特有的。使用Spring aop命名空间中的aop:declare-parents元素，我们可以实现相同的功能 12345678&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;!--引用audience Bean--&gt; &lt;aop:declare-parents types-matching="concert.Performance" implement-interface="concert.Encoreable" default-impl="concert.DefaoultEncoreable" &lt;/aop:aspect&gt; &lt;/aop:config&gt; 4.5 注入AspectJ切面虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP是一个功能比较弱的AOP解决方案，ASpect提供了Spring AOP 所不能支持的许多类型的切点。 Spring不能像之前那样使用声明来创建一个实例—-它已经在运行时由AspectJ创建完成了，Spring需要通过工厂方法获取切面的引用。然后像元素规定的那样在该对象上执行依赖注入 4.6 小节(重点中的重点)AOP是面向对象编程的一个强大补充，通过AspectJ，我们现在可以把之前分散在应用各处的行为放入可重用的模块中。我们显示地声明在何处如何应用该行为。这样有效减少了代码冗余，并让我们的类关注自身的主要功能。 Spring提供了一个AOP框架，让我们把切面插入到方法执行的周围。现在我们已经学会了如何把通知织入前置，后置和环绕方法的调用中，以及为处理异常增加自定义行为。 关于在Spirng应用中如何使用切面 ，我们可以有多种选择。通过使用@AspectJ注解和简化的配置命名空间，在Spring中装配通知和切点变得非常简单 最后，当Spring不能满足需求时，我们必须转向更为强大的AspectJ。对于这些场景，我们了解了如何使用Spring为AspectJ切面注入依赖。 此时此刻，我们已经覆盖了Spring框架的基础知识，了解到如何配置Spring容器以及如何为Spring管理的对象应用切面，这些技术为创建高内聚，低耦合的应用奠定了坚实的基础。 从下一章开始，首先看到的是如何使用Spring构建Web应用。。 参考：https://github.com/guoxiaoxu/SpringInActionPracticehttps://www.jianshu.com/p/8b95db8d7a1f]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记三]]></title>
    <url>%2F2018%2F03%2F16%2F2018-03-16%2F</url>
    <content type="text"><![CDATA[第三章 高级装配本章内容： Spring profile 条件化的bean声明 自动装配与歧义性 bean的作用域 Spring表达式语言 本章中所介绍的技术也许你不会天天用到，但这并不意味着它们的价值会因此降低 3.1环境与profile在软件开发的时候，有一个很大的挑战就是将应用从一个环境迁移到另外一个环境。开发阶段中，某些环境相关的做法可能并不适合迁移到生产环境中，甚至即便迁移过去也无法工作。数据库配置、加密算法以及外部系统的集成是跨环境部署 在开发环境中，我们可能会使用切入式数据库，并预先加载测试数据。在Spring配置类中，可能会在一个带有@Bean注解的方法上使用EmbededDataBaseBuilder: 12345678@Bean(destroyMethod="shutdown")public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build();&#125; 这会创建一个类型为javax.sql.dataSource的bean，使用EmbededDatabaseBuilder会搭建一个切入式的Hypersonic数据库，它的模式(schema)定义izaischema.sql中，测试数据则是通过test-data.sql。 当你在开发环境中集成测试或者启动应用进行手动测试的时候非常有用。每次启动它的时候，都能让数据库处于一个给定的状态 尽管创建的DataSource非常适合于开发环境中，但是对于生产环境来说，这是一个糟糕的选择。在生产环境中你可能希望使用JNDI从容器中获取一个DataSource。 12345678@Beanpublic DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject();&#125; 通过JNDI获取的DataSource能够让容器决定如何创建这个DataSource，甚至包括切换为容器管理的连接池，即便如此，JNDI管理的Datasource更加适合与生产环境，对于简单的集成和开发测试来说，这会带来不必要的复杂性。 同时，在QA环境中，你可以选择完全不同的DataSource配置，可以配置为Commons DBCP连接池。 1234567891011@Bean(destroyMethod = "close")public DataSource dataSourceAO() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl("jdbc:h2:tcp://dbserver/～/test"); dataSource.setDriverClassName("org.h2.Driver"); dataSource.setUsername("guo"); dataSource.setPassword("guo"); dataSource.setInitialSize(20); dataSource.setMaxActive(30); return dataSource;&#125; 看起来简单的DataSource实际上并不是那么简单。它表现了在不同环境中某个bean会有所不同。我们必须有一种方式来配置DataSource，使其在每种环境下都会选择最为合适的配置。 其中一种方式就是在单独的配置类(或XML)中配置每个bean，然后在构造阶段确定要使用哪一个配置编译到可部署的环境中。这种方式的问题在于要为每种环境重新构建应用，当从开发阶段迁移到QA阶段时，重新构造也算不上什么大问题。但是，从QA阶段迁移到生产环境阶段时，重新构建可能引入BUG并且会在QA团队的成员中带来不安的情绪 3.1.1 配置profile beanSpring并不是在构造的时候做出这样的决策，而是到运行时再来确定，这样的结果就是在同一个部署单元能够适应所有的环境，没有必要重新构建. Spring引入了bean profile的功能，要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署到每个环境时，要确保对应的profile处于激活状态。 在Java配置中，可以使用@profile注解指定某个bean属于哪一个profile。 123456789101112@Configuration@Profile("dev")public class DataSourceConfig &#123; @Bean(destroyMethod="shutdown") public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build(); &#125;&#125; 需要注意的是@Profile注解应用到了类级别啥概念，它会告诉Spring这个配置来中的bean只有在dev profile激活时才创建。如果dev profile没有激活的话，那么带有@Bean注解的方法都会被忽略。 同时你可能需要一个适用于生产环境的配置 12345678910111213@Configuration@Profile("prod")public class DataSourceConfig &#123; @Bean public DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125;&#125; 在Spring3.1，只能在类级别上使用@Profile注解，不过在Spring3.2开始，你也可以在方法级别上使用@Profile注解，与@Bean注解一同使用，这样的话，就能将两个bean的声明放在同一个配置类中。 123456789101112131415161718192021222324252627282930313233343536/** * Created by guo on 22/2/2018. */@Configurationpublic class DataSourceConfig &#123; @Bean(destroyMethod="shutdown") @Profile("dev") public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build(); &#125; @Bean @Profile("prod") public DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125; @Bean(destroyMethod = "close") public DataSource dataSourceAO() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl("jdbc:h2:tcp://dbserver/～/test"); dataSource.setDriverClassName("org.h2.Driver"); dataSource.setUsername("guo"); dataSource.setPassword("guo"); dataSource.setInitialSize(20); dataSource.setMaxActive(30); return dataSource; &#125;&#125; 尽管每个DataSource bean 都被声明在一个profile中，并且只能当规定的profile激活时，相应的bean才会被创建，但是可能会有其他的bean并没有声明到一个给定的profile范围内。没有指定的profile的bean都会创建，与激活哪个profile没有关系 在XMl中配置profile我们也可以通过元素的profil属性，在XML中配置profile bean。 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ................................................................ &lt;beans profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; &lt;jdbc:script location="classpath:schema.sql" /&gt; &lt;jdbc:script location="classpath:test-data.sql" /&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile="qa"&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:url="jdbc:h2:tcp://dbserver/～/test" p:driverClassName="org.h2.Driver" p:username="guo" p:password="guo" p:initialSize="20" p:maxActive="39"/&gt; &lt;/beans&gt; &lt;beans profile="prod"&gt; &lt;jee:jndi-lookup id="dataSource" lazy-init="true" jndi-name="jdbc/myDatabase" resource-ref="true" proxy-interface="javax.sql.DataSource" /&gt; &lt;/beans&gt;&lt;/beans&gt; 除了所有的bean定义到同一个XML文件中，这种配置方式与定义单独的XML文件中实际效果是一样的。在运行时，只会创建一个bean，这取决于处于激活状态的是哪一个profile 3.1.2激活profileSpring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：sring.profiles.active和spring.profiles.default。如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active的话，那么Spring将会查找spring.profiles.default的值。如果两者都没有的话，那就没有激活的profile。 有多种方式来设置这两个属性 作为DispatcherServlet的初始化参数 作为Web的应用上下文参数 作为JNDI条目 作为环境变量 作为JVM的系统属性 在集成测试类上 作者喜欢的一种方式是使用DisPatcherServlet的参数将spring.profiles.default设置为开发环境，会在Servlet上下文中进行设置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;taotao-rest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--为上下文设置默认的profile--&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- springmvc的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;taotao-rest&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+"-servlet.xml" --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--为Servlet设置默认的profile--&gt; &lt;init-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;taotao-rest&lt;/servlet-name&gt; &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 按照这种方式设置spring.profiles.default,所有开发人员能从版本控制软件中获得应用的程序源码，并使用开发环境的设置(如切入式数据库)运行代码而不需要任何额外的设置。 当应用程序部署到QA、生产、或其他环境中时，负责部署的人根据情况使用系统属性、环境变量、或JNDI设置spring.profiles.active即可。当设置spring.profiles.avtive后，至于spring.profiles.default设置成什么已经无所谓了：系统会优先使用spring.profiles.active中设置的profile 使用profi进行测试当运行集成测试时，通常会希望采用与生产环境相同的配置进行测试。但是，如果配置中的bean定义在了profile中，那么在测试运行时，我们就需要有一种方式来启动profile Spring提供了@ActiveProfiles注解，可以用它来指定运行测试时要激活哪个profile。在集成测试时，通常想要激活的是开发环境的profile。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import static org.junit.Assert.*;public class DataSourceConfigTest &#123; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = DataSourceConfig.class) @ActiveProfiles("dev") public static class DevDataSource&#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbededDatasourcr() &#123; JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query("select id, name from Things", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong("id") + ":" + rs.getString("name"); &#125; &#125;); assertEquals(1,results.size()); assertEquals("1:A",results.get(0)); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes=DataSourceConfig.class) @ActiveProfiles("prod") public static class ProductionDataSourceTest &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; // 应该是Null ，因为在JNDI中没有配置数据源 assertNull(dataSource); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:datasource-config.xml") @ActiveProfiles("dev") public static class DevDataSourceTest_XMLConfig &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; assertNotNull(dataSource); JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query("select id, name from Things", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong("id") + ":" + rs.getString("name"); &#125; &#125;); assertEquals(1, results.size()); assertEquals("1:A", results.get(0)); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:datasource-config.xml") @ActiveProfiles("prod") public static class ProductionDataSourceTest_XMLConfig &#123; @Autowired(required=false) private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; // 应该是Null ，因为在JNDI中没有配置数据源 assertNull(dataSource); &#125; &#125;&#125; 在条件化创建bean，Spring的profil机制是一种很好的方法，这里的条件要基于哪个profile处于激活状态来判断。Spring 4.0中提供了一种更为通用的机制来实现条件化的bean定义，这这种机制之中，条件化 完全由你来取定，Spring 4 和@Conditional注解定义条件化的bean。 3.2 条件化的bean假设你希望一个或所个bean只有在类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才创建，我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。 在Spring 4之前，很难实现这种级别的条件化配置，但是Spring 4.0 引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。 下面我们就根据环境变量中有没有magic变量来决定是否创建MagicBean: 1234567891011121314151617package com.cache.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;import com.cache.conditional.MagicExistsConditional;import com.cache.service.MagicBean;@Configurationpublic class ConditionalConfig &#123; @Bean @Conditional(MagicExistsConditional.class) //条件化的创建bean public MagicBean magicBean() &#123; return new MagicBean(); &#125;&#125; 可以看到MagicBean是否创建取决于@Conditional(MagicExistsConditional.class)中的情况，那么给@Conditional中的参数又是什么类型的呢，请看： 12345678910111213141516package com.cache.conditional;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class MagicExistsConditional implements Condition&#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment evn = context.getEnvironment(); return evn.containsProperty("magic"); &#125;&#125; 如你所见，设置给@Conditional的类可以是任意实现了Condition接口的的类型。而实现这个接口只需要实现matches方法，如果matches方法返回 true 就创建该 bean，如果返回 false 则不创建 bean，上例中我们就是根据环境变量中是否存在magic变量，来决定matches的返回值，进而决定是否创建MagicBean的。上例中我们只是使用到了ConditionContext的到Environment, 但Condition实现的考量因素可能会比这多的多。maches()方法会得到ConditionContext和AnnotatedTypeMetadata对象用来做决策。其实ConditionContext是一个接口： 1234567891011121314151617181920package org.springframework.context.annotation;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.core.env.Environment;import org.springframework.core.io.ResourceLoader;public interface ConditionContext &#123; BeanDefinitionRegistry getRegistry(); ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); ClassLoader getClassLoader();&#125; 通过 ConditionContext，我们可以做到如下几点： 方法 作用 getRegistry() 借助返回的 BeanDefinitionRegistry 检查 bean 的定义 getBeanFactory() 借助返回的 ConfigrableListableBeanFactory 检查是否存在，甚至检查 bean 的属性 getEnvironment() 借助返回 Environment 检查环境变量是否存在以及读取它的值是什么 getResourceLoader() 读取并检查它返回的 ResourceLoader 所加载的资源 getClassLoader() 借助它的返回的 ClassLoader 加载并检查类是否存在 AnnotatedTypeMetadata则能够让我们检查带有 @Bean 注解的方法上是否有其他注解： 1234567891011121314151617181920package org.springframework.core.type;import java.util.Map;import org.springframework.util.MultiValueMap;public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String annotationType); Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType); Map&lt;String, Object&gt; getAnnotationAttributes(String annotationType, boolean classValuesAsString); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String annotationType, boolean classValuesAsString);&#125; 借助 isAnnotated() 方法，我们能够判断带有 @Bean 注解的方法是不是还有其他特定的注解。借助其他的方法，我们能够检查 @Bean 注解的方法上其他注解的属性。下面我们来看一下 Spring 4 使用 @Conditional 对 @Profile 的重构： 123456789101112131415161718192021package org.springframework.context.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.env.AbstractEnvironment;import org.springframework.core.env.ConfigurableEnvironment;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@Conditional(ProfileCondition.class)public @interface Profile &#123; String[] value();&#125; @Profile的实现定义使用了，@Conditional注解和Condition接口，如下，ProfileCondition实现了Condition，并在matches方法中做出了是否创建@Profile的决策： 1234567891011121314151617181920212223242526package org.springframework.context.annotation;import org.springframework.core.type.AnnotatedTypeMetadata;import org.springframework.util.MultiValueMap;class ProfileCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if (context.getEnvironment() != null) &#123; MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if (attrs != null) &#123; for (Object value : attrs.get("value")) &#123; if (context.getEnvironment().acceptsProfiles(((String[]) value))) &#123; return true; &#125; &#125; return false; &#125; &#125; return true; &#125;&#125; 我们可以看到，ProfileCondition通过AnnotatedTypeMetadata得到了用于 @Profile 注解的所有属性。借助该信息，他会明确地检查 value 属性，该属性包含了 bean 的 profile 名称。然后根据ConditionContext得到的Environment 来检查【借助acceptsProfiles()方法】该profile是否处于激活状态。 3.3 处理自动装配的歧义性之前，我们已经看到了如何使用自动装配让Spirng完全负责将bean引用注入到构造函数和属性中，自动装配能够提供很大的帮助，因为它会减少装配应用程序组件时所需的显示配置的数量。 不过仅有一个bean匹配所需的结果时，自动装配才是有效的。如果不仅一个bean能够匹配结果的话，这种歧义性会阻碍Spring自动装配属性、构造器或方法参数 为了阐述自动装配的歧义性，假设我们提供@Autowired注解标注了setDessert方法 1234@Autowiredpublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; Dessert是一个接口，并且有三个类实现了这个接口 12345678@Componentpublic class Cake implements Dessert &#123;...&#125;@Componentpublic class Cookies implements Dessert &#123; ...&#125;@Componentpublic class IceCream implements Dessert &#123;...&#125; 因为这三个实现均使用@Component注解，在组件进行扫描的时候，能够发现他们并将其创建为Spring应用上下文里面的bean，然后，当Spring试图自动装配的setDessert()中的Dessert参数时，它们并没有唯一、无歧义的可选值。 Spring此时别无选择，只好宣告失败并抛出异常，更准确的将。Spring会抛出：NoUniqueBeanDefinitionException 当Spring发生歧义时，Spring提供了多种可选方案来解决这样的问题。你可以将可选bean的某一个设为首选(primary)的bean，或者使用限定符(qualifier)来帮助Spring将可选的bean的范围缩小到只有一个bean。 3.3.1 表示首选的bean在声明bean的时候，通过将一个可选的bean设置为首选(primary)bean能够避免自动装配时的歧义性。当遇到歧义性的时候，Spring将会使用首选的bean，而不是其它可选的bean。 假设冰激凌就是你最喜欢的甜点，在Spring中，可以通过@Primary来表达最喜欢的方案。@Primary能够与@Componnet组合用在组件扫描的bean上，也可以与@Bean组合用在Java配置的声明中。123@Component@Primarypublic class IceCream implements Dessert &#123;...&#125; 或者你通过JavaConfig显示配置地声明IceCream， 12345@Bean@Primarypublic Dessert IceCream() &#123; return new IceCream();&#125; 如果你喜欢使用XML配置bean的话，同样可以实现这样的功能。 123&lt;bean id="ceCream" class="com.guo.IceCream" primary="true"/&gt; 如果你标注了两个或者多个首选bean，那么就无法工作了。 123@Component@Primarypublic class Cake implements Dessert &#123; ...&#125; 就解决歧义性问题而言，限定符是一种更为强大的机制 3.2.2 限定自动装配的bean设置首选bean的局限性在于@Primary无法将可选方案的范围限定到唯一一个无歧义的选项中。它只能表示一个优先的可选方案。 Spring的限定符能够在所有可选的bean上进行缩小范围的操作，最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小范围。 @Qualifier注解是使用限定符的主要方式。它可以与@Autowired和Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。例如,我们确保要将IceCream注入到setDessert()之中。 12345@Autowired@Qualifier("iceCream")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; @Qualifier(“iceCream”)指向的是组件扫描时所创建的bean，并且这个bean是IceCream的实例。更具体一点：@Qualifier(“iceCream”)所引用的bean要具有String类型的“iceCream”作为限定符。没有没有则和ID一样。 基于默认的bean ID作为限定符是非常简单的，但这有可能会引入一些问题。如果你重构了IceCrean类，将其重名为“Gelato”的话，那此时会发生什么情况？如果是这样的话，bean的默认ID和默认的限定符会变为gelato，这就无法匹配setDessert()方法中的限定符，自动装配会失败。 这里的问题在于setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会导致限定符失败。 创建自定义的限定符我们可以为bean设置自己的限定符，而不是依赖于将ID作为限定符。在这里所需要做的就是在bean声明上加@Qualifier注解。 123@Component@Qualifier("cold")public class IceCream implements Dessert &#123;...&#125; 在这种情况下，cold限定符分配了IceCream bean。因为它没耦合类名，因此你可以随意重构IceCream，而不必担心会破坏自动装配。 在注入的地方，只要引用cold限定符就可以了 12345@Autowired@Qualifier("cold")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; 值得一提的是，当通过Java配置显式定义bean的时候i@Qualifier也可以与@Bean注解一起。 12345@Bean@Qualifierpublic Dessert dessert () &#123; return new IceCream();&#125; 当使用自定义的@Qualifier值时，最佳实践是为bean选择特征性或描述性的术语，而不是使用随意的名字。 使用自定义的限定符注释面向特性的限定符要比基于bean ID的限定符更好一些。但是如果多个bean都具备这个相同的特性的话，这种做法也会出现问题。 这里只有一个小问题：Java不允许在同一个条目上重复出现相同类型的多个注解。如果你试图这样做的话，编译器将会出错。 但是我们可以创建 自定义的注解，借助这样的注解来表达bean所希望限定的特性。这里需要做的就是创建一个注解，它本身要使用@Qualifier注解来标注。 1234@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface cold &#123;&#125; 当你不想用 @Qualifier注解的时候，可以类似的创建@Sort、@Crispy和@Fruity。通过在定义时添加@Qualifier注解。它就具有了@Qualifier注解的特性。 现在我们重新看一下IceCream，并为其添加@Cold和@Creamy注解 1234@Component@Clod@Creamypublic class IceCream implements Dessert &#123;...&#125; 类似的，Popsicle类可以添加@Cold和@Fruity注解 1234@Component@cold@Fruitypublic class Popsicle implements Dessert &#123;...&#125; 最终，在注入点，我们使用必要的限定符注解进行任意组合，从而将可选的范围缩小到只有一个bean满足需求。 为了得到IceCream bean 和 setDessert()方法可以这样使用注解： 123456@Autowired@Cold@Creamypublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; 通过声明自定义的限定符注解，我们可以同时使用多个限定符，不会再有Java编译器的限制或错误，与此同时，相对于原始的@Qualifier并借助于String类型来指定限定符，自定义的注解也是类型安全的。 在本节和前节中，我们讨论了几种通过自定义注解扩展Spring的方式，为了创建自定义的条件化注解，我们建议一个新的注解并在这个注解上添加了Conditional，为了创建自定义的限定符注解，我们创建一个新的注解并在这个注解上添加了@Qualifer。这种技术可以用到很多Spring注解中，从而能够将他们组合在一起形成特定目标的自定义注解。 3.4 bean的作用域默认情况下，Spring应用上下文中所有的bean都是作为以单例(singleton)的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多次，每次所注入的都是同一个bean。 在大多数情况下，单例bean是很理想的方案，初始化和垃圾回收对象实例所带来的成本只有一些小规模任务。在这些任务中，让对象保持无状态并且在应用中反复使用这些对象可能并不合理。 有时候可能发现，你所使用的类是异变的(mutable)，它们会保持一些状态，因此重复使用时不安全的。在这种情况下将class声明为单例的bean就不是什么好主意了。因为会污染对象，稍后重用的时候会出现意想不到的问题。 Spring定义了多种作用域可以基于这些作用域创建bean，包括： 单例(singleton):在整个应用中，只创建bean的一个实例 原型(prototype):每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例 会话(Session):在Web应用中，每个会话创建一个bean实例 请求(Request):在Web应用中，为每个请求创建一个bean实例。 单例是默认的作用域，但是正如之前所述，对于异变的类型，这并不适合。如果要选择其他作用域，要使用@Scope注解，它可以与@Component或@Bean一起使用。 如果你使用组件扫描来发现bean和生命bean，那么你可以在bean的类上使用@Scope注解，并将其声明为原型bean 1234@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class NotePad &#123;&#125; 在这里，使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常量设置了原型作用域。你当然可以使用@Scope(“prototype”),但是使用SCOPE_PROTOTYPE常量更加安全并且不易出错。 如果你想在JavaConfig中将NotePad声明为原型bean，那么可以组合使用@Scope和@Bean来指定所需的作用域 12345@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public NotePad notepad &#123; return new NotePad();&#125; 如果你想使用XMl来配置bean的话，你可以使用bean元素的scope属性来设置作用域123&lt;bean id="notepad" class="com.guo.myapp.NotePad" scope="prototype" 不管你使用哪种方式来声明作用域，每次注入或从Spirng应用上下文中检索该bean的时候，都会创建新的实例。这样导致的结果就是每次操作都能得到自己的NotePad实例。 3.4.1 使用会话和请求作用域在Web应用中，如果能够实例化在会话和请求范围内共享的bean，那将是非常有价值的事。例如：在典型的电子商务中，可能会有一个bean代表用户的购物车，如果这个购物车是单例的话，那么 将导致所有的用户都会像同一个购物车中添加商品。另一方面，如果购物车是原型作用域，那么在应用中某一个地方往购物车添加商品，在应用的另外一个地方可能就不可用了。因为这里注入的是另外一个原型作用域的购物车。就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大，要指定会话作用域，我们可以使用@Scope注解，它的使用方式和原型作用域是相同的。 1234@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public ShoppingCart cart() &#123;...&#125; 这里我们将value设置成WebapplicationConext.SCOPE.SESSION。这会告诉Spring为Web应用中的每个会话创建一个ShoppingCart。 需要注意跌是，@Scope同时还有另外一个ProxyMode属性，它被设置成了ScopeProxyMode.INTERFACES。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。在描述ProxyMode属性之前，我们先来看下proxyMode所解决问题的场景。 假设我们要将ShoppingCart bean 注入到单例StoreService bean的Setter方法中 1234567@Componentpublic class StoreService &#123;@Autowiredpublic void setShoppingCart(ShoppingCart shoppingCart) &#123; this.shoppingCart = shoppingCart;&#125;&#125; 因为StoreService是一个单例bean，会在Spring应用上下文加载的时候创建，当它创建的时候，Spring会试图将ShoppingCart注入到SetShoppingCart方法中，但是ShoppingCart是会话作用域的，此时并不存在。直到用户进入系统，创建了会话之后，才会出现ShoppingCart实例。 另外系统中将会有多个实例：每个用户一个。我们并不想让Spirng注入到某个固定的ShoppingCart实例到StoreService中，我们希望的是当StoreService处理购物车的时候，他所用使用的ShoppingCart实例恰好是当前会话所对应的一个。 Spring并不会将实例的ShoppingCart bean注入到StoreService，Spring会注入一个到ShoppingCart的代理。这个代理会暴露于ShoppingCart相同的方法。所以StoreService就会认为他是一个购物车。 但是当StoreService调用ShoppingCart的方法方法时，代理会对其进行解析，并将调用委托给会话作用域内真正的ShoppingCart。 现在我们带着这个 作用域的理解，讨论一下ProxyMode属性，如配置所示，proxyMode属性被设置成了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean 如果ShoppingCart是接口，而不是类的话，这是可以的，但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了，此时，它必须使用CGLIB来生成基于类的代理。所以，如果bean类型是具体的类的话，我们必须要将ProxyMode属性设置为ScopedProxyMOde.TARGET_CLASS.以此来表明要以生成目标类 扩展的方法创建代理。 尽管，我主要关注量会话作用域，但是请求作用域的bean会面临相同的装配问题，因此，请求作用域的bean应该也以作用域代理的方式进行注入 3.4.2 在XML中声明作用域代理如果你需要使用XML来声明会话或请求作用域的bean，那么就不能使用@Scope注解及其ProxyMode属性了元素能够设置bean的作用域，但是该怎样设置代理模式呢？ 要使用代理模式，我们需要使用Spring aop命名空间的一个新元素： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bean id="cart" class="com.guo.myapp.ShoppingCart" scope="session"&gt; &lt;aop:scoped-proxy/&gt;&lt;/bean&gt; aop:scoped-proxy是与@Scope注解的proxyMode属性功能相同的SpringXML配置元素，它会告诉Spring为bean创建一个作用域代理。默认情况下，它会使用CGLIB创建目标的代理。但是我们可以将proxy-target-class的属性设置为false，进而要求它生成基于接口的代理。 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bean id="cart" class="com.guo.myapp.ShoppingCart" scope="session"&gt; &lt;aop:scoped-proxy proxy-target-class = "false"/&gt;&lt;/bean&gt; 为了使用aop:scoped-proxy元素，必须在XML配置中声明Spring的aop命名空间： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; Spring高级配置的另一个可选方案：Spring表达式语言(Spring Expression Language) 3.5 运行时注入当讨论依赖注入的时候，我们通常讨论的是将一个bean引入到另一个bean的属性或构造器参数中。它通常来讲指的是将一个对象与另一个对象关联起来 但bean装配的另一个方面指的是将一个值注入到bean的属性或构造器参数中。 有时候硬编码是可行的，但有时候我们可能会希望避免硬编码。而是让这些值在运行时在确定，为了实现这些功能，Spring提供了运行时求值的方式： 属性占位符(Property placeholder) Spring表达式语言(SpEL) 这两种技术的用法是类似的，不过他们的目的和行为是有所差别的。 3.5.1 注入外部的值在Spring中，处理外部值的最简单方式就是声明属性源，并通过Spring的Enviroment来检索属性。 一个基本的Spring配置类，他使用外部的属性来装配BlankDisc bean。 12345678910111213@Configuration@PropertySource("classpath:/com/guo/soundsystem/app.properties")public class EnvironmentConfig &#123; @Autowired private Environment env; @Bean public BlankDisc blankDisc() &#123; return new BlankDisc( env.getProperty("disc.title"), env.getProperty("disc.artist")); &#125;&#125; @PropertySource 引用了类路径中一个名为app.properties的文件 这个属性文件加载到Spring的Environment中，同时blackDisc()方法中，会创建一个新的BlankDisc，它的构造参数是从属性文件中获取的，而这是通过getProperty()实现的。 深入学习Spirng的EnvironmentgetProperty() 方法并不是获取属性值的唯一方法，getProperty()方法有四个重载的变种形式 1234567891011121314151617181920package org.springframework.core.env;/** * Interface for resolving properties against any underlying source. * * @author Chris Beams * @since 3.1 * @see Environment * @see PropertySourcesPropertyResolver */public interface PropertyResolver &#123; String getProperty(String key); String getProperty(String key, String defaultValue); &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType); &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue); 前两种形式的getProperty()方法会返回String类型的值，但是你可以稍微对@Bean方法修改一些，这样在指定属性不存在的时候，会使用一个默认值。 123456@Beanpublic BlankDisc blankDisc() &#123; return new BlankDisc( env.getProperty("disc.title","guo go go"), env.getProperty("disc.artist","UU"));&#125; 剩下的两种getProperty()方法与前面的两种非常类似，但是他们不会将所有的值都视为String类型。假设你要获取的值所代表的连接池中所维持的连接数量，如果我们从属性文件中得到的是一个String类型的值，那么在使用之前还需要将其转化为Interge类型，但是如果使用重载的形式，就能非常便利的解决这个问题。 12int connectionCount = env.getProperty("db.connection.count",Interge.class,30); Environment还提供了几个与属性相关的方法，如果你在使用getProperty()方法的时候没有默认值，并且这个属性没有定义的话，获取到的值是null，如果你希望这个属性必须定义，那么可以使用getRequiredProperty()， 123456@Beanpublic BlankDisc blankDisc() &#123; return new BlankDisc( env.getRequiredProperty("disc.title"), env.getRequiredProperty("disc.artist"));&#125; 在这里，如果disc.title或者disc属性没有定义的话，将会抛出lllegalStateException异常 如果想要检查一个元素是否存在的话，可以调用Envrionment的contaiinsProperty()方法 1boolean titleeExists = env.containsProperty("disc.title"); 如果想将属性解析为类的话，可以使用getPropertyAsClass()方法 1Class&lt;CompactDisc&gt; cdClass = env.getPropertyAsClass("disc.class",CompactDisc.class); 除了属性的功能外，Environment还提供 一些方法来检查哪些Profile处于激活状态 12345678public interface Environment extends PropertyResolver &#123; String[] getActiveProfiles(); //返回激活profile名称的数组 String[] getDefaultProfiles(); //返回默认profile名称的数组 boolean acceptsProfiles(String... profiles); //如果environment支持给定的profile，则返回true&#125; 直接从Environment中检索属性是非常方便的，尤其是在Java配置中装配bean的时候，但是Spring也提供了通过占位符装配属性的方式，这些占位符的值会来源于一个属性源。 解析属性占位符Spring一直支持将属性定义到外部的属性配置文件中，并使用占位符值将其插入到Spring bean中， 123&lt;bean class="com.guo.soundsystem.BlankDisc" c:_0 = "$&#123;disc.title&#125;" c:_1 = "$&#123;disc.artist&#125;"/&gt; 按照这种方式，XML配置没有使用任何硬编码的值，它的值是从配置文件以外的一个源中解析得到的。 如果我们依赖于组件扫描和自动装配来创建和初始化应用组件的话，那么就没有占位符的配置文件了，在这种情况下，我们可以使用@Value注解，它的使用方式与@Autowired注解非常类似。 在BlankDisc类中，构造器可以改成如下显示： 123456public BlankDisc( @Value("$&#123;disc.title&#125;")String title, @Value("$&#123;disc.artist&#125;") String artist) &#123; this.title = title; this.artist = artist;&#125; 为了使用占位符，我们必须要配置一个PropertyPlaceholderConfigurer bean， 从Spring3.1开始，推荐使用propertySourcesPlaceholderConfigurer，因为它能够基于Spirnig Environment 及其属性源来加载占位符。 1234@Beanpublic static propertyplaceholderConfigurer placeholderConfigurer() &#123; return new propertyplaceholderConfigurer();&#125; 如果你想使用XML配置的话，Spring Context命名空间中的context:propertyplaceholder元素会为你生成 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;context:property-placeholder location="com/soundsystem/app.properties" /&gt;&lt;/beans&gt; 解析外部属性能够将值的处理推迟到运行时，但是它的关注点在于根据名称解析来自于Spring Environment和属性源的属性。而Spring表达式语言提供了一种更为通用的方式在运行时计算所要注入的值。 3.5.2 使用Spring表达式语言进行装配Spring3 引入了 Spring 表达式语言（Spring Expression Language，SpEL），它能够以一种强大和简介的方式将值装配到 bean 属性和构造器参数中。SpEL 拥有很多特性，包括： *使用 bean 的 ID 来引用 bean； *调用方法和访问对象的属性； *对值进行算数、关系和逻辑运算； *正则表达式匹配； *集合操作。 SpEL 不仅能够用在依赖注入中，在其他的一些方面也有很大用处。如 Spring Security 支持使用 SpEL 表达式定义安全限制工作。在 Spring MVC 应用中使用 Thymeleaf 模板作为视图的话，那么这些模板可以使用 SpEL 表达式引用模型数据。SpEL 表达式要放到”#{…}” 之中，这与属性占位符有些类似，属性占位符需要放到”${…}” 之中。下面是几个简单的 SpEL 样例，这些例子可以我们帮助编写自己的表达式。 SpEL样例需要了解的第一件事情就是SpEL表达式要放到“#{ … }”之中，这与属性占位符有些类 似，属性占位符需要放到“${ … }”之中。下面所展现的可能是最简单的SpEL表达式了： 1#&#123;1&#125; 表达式中只有字面量 1，当然它的计算结果就是 1 1#&#123;T(System).currentTimeMillis()&#125; ：它的最终结果是计算表达式的那一刻当前时间的毫秒数。T() 表达式会将 java.lang.System 视为 Java 中对应的类，因此可以调用其 static 修饰的 currentTimeMillis() 方法。 1#&#123;sgtPeppers.artist&#125; ：引用 ID 为 sgtPeppers 的 bean 的 artist 属性。 1#&#123;systemProperties[‘disc.title’]&#125; ：通过 systemProperties 对象引用系统属性。 在 bean 装配时使用 SpEL 表达式 如果通过组件扫描创建 bean 的话，在注入属性和构造器参数时，我们可以使用 @Value 注解，这与之前看到的属性占位符非常类似。不过，我们将用 SpEL 表达式替代属性占位符。例如，下面的样例展现了 BlankDisc，它会从系统属性中获取专辑名称和艺术家的名字： 12345public BlankDisc(@Value("#&#123;systemProperties['disc.title']&#125;") String title, @Value("#&#123;systemProperties['disc.artist']&#125;") String artist)&#123; this.title=title; this.artist=artist;&#125; 在 XML 配置中，你可以将 SpEL 表达式传入或的 value 属性中，或者将其作为 p - 命名空间或 c - 命名空间条目的值。例如，在如下 BlankDisc bean 的 XML 声明中，构造器参数就是通过 SpEL 表达式设置的： 1234&lt;bean id=&quot;sgtPeppers&quot; class=&quot;soundsystem.BlankDisc&quot; c:_title=&quot;#&#123;systemProperties[&apos;disc.title&apos;]&#125;&quot; c:_artist=&quot;#&#123;systemProperties[&apos;disc.artist&apos;]&#125;&quot; /&gt; 上面已经看过了几个简单的样例，也学习了如何将 SpEL 解析得到的值注入到 bean 中，下面将是 SpEL 所支持的基础表达式学习。 表示字面值SpEL 表达式可以用来表示各种类型的字面量，如：正数：#{1}、浮点数：#{3.14159}、String：#{‘Hello’}、布尔型：#{true}，用 SpEL 表示字面量并没有太大用处，但是要记住一点，更有意思的 SpEL 表达式是由更简单的表达式组成的，因此了解在 SpEL 中如何使用字面量还是很有用处的。但组合更为复杂的表达式时，你迟早会用到它们。 引用 bean、属性和方法SpEL 能做的另一件基础的侍寝就是通过 ID 引用其他的 bean。例如，你可以使用 SpEL 将一个 bean 装配到另一个 bean 的属性中，此时要使用 bean ID 作为 SpEL 表达式（在本例中，也就是 sgtPeppers）： 1#&#123;sgtPeppers&#125; 现在，假设我们想在一个表达式中引用 sgtPeppers 的 artist 属性： 1#&#123;sgtPeppers.artist&#125; 表达式主体的第一部分引用了一个 ID 为 sgtPeppers 的 bean，分隔符之后是对 artist 属性的引用。除了引用属性之外，我们还可以调用 bean 上的方法。例如，假设有另外一个 bean，它的 ID 为 artistSelector，我们可以在 SpEL 表达式中按照如下的方式来调用 bean 的 selectArtist() 方法： 1#&#123;artistSelector.selectArtist()&#125; 对于被调用方法的返回值来说，我们同样可以调用它的方法。如果 selectArtist() 方法返回的是一个 String，那么可以调用 toUpperCase() 将整个艺术家的名字改为大写字母形式： 1#&#123;artistSelector.selectArtist().toUpperCase()&#125; 如果 selectArtist() 的返回值不是 null 的话，这没有什么问题。为了避免出现 NullPointerException，我们可以使用类型安全的运算符： 1#&#123;artistSelector.selectArtist()?.toUpperCase()&#125; 与之前只是使用点号（.）来访问 toUpperCase()方法不同，现在我们使用了 “？.” 运算符。这个运算符能够在访问它右边的内容之前，确保它对应的元素不是 null。所以，如果 selectArtist()的返回值是 null 的话，那么 SpEL 将不会调用 toUpperCase()方法。表达式的返回值会是 null。 在表达式中使用类型如果要在 SpEL 中访问类作用域的方法和常量的话，要依赖 T() 这个关键的运算符。例如，为了在 SpEL 中表达 Java 的 Math 类，需要按照如下的方式使用 T() 运算符： 12#&#123;T(java.lang.Math).random&#125; //引用Math类的随机数方法#&#123;T(java.lang.Math).PI&#125; //引用Math类的常量 这里所示的T()运算符的结果会是一个Class对象，代表了java.lang.Math。如果需要 的话，我们甚至可以将其装配到一个Class类型的bean属性中。但是T()运算符的真正价值 在于它能够访问目标类型的静态方法和常量。 SpEL 运算符SpEL 提供了多个运算符，这些运算符可以用在 SpEL 表达式的值上。下表为用来操作表达式值的 SpEL 运算符： 下面这个例子作为使用上述运算符的一个简单样例： 1#&#123;2*T(java.lang.Math).PI*circle.radius&#125; 在这里 PI 的值乘以 2，然后再乘以 radius 属性的值，这个属性来源于 ID 为 circle 的 bean。实际上它计算了圆的周长。当使用 String 类型的值时，“+” 运算符执行的是连接操作，与在 Java 中是一样的： 1#&#123;disc.title+&apos;by&apos;+disc.artist&#125; SpEL 同时还提供了比较运算符，用来在表达式中对值进行比较。注意在上表中，比较运算符有两种形式：符号形式和文本形式。例如： 123#&#123;counter.total==100&#125;//等同于下面的表达式#&#123;counter.total eq 100&#125; SpEL 还提供了三元运算符（ternary），它与 Java 中的三元运算符非常类似。例如，如下的表达式会判断如果 scoreboard.score&gt;1000 的话，计算结果为 String 类型的 “Winner！”，否则，结果为 “Loser”： 1#&#123;scoreboard.score&gt;1000 ? &quot;Winner!&quot;:&quot;Loser&quot;&#125; 三元运算符的一个常见场景就是检查 null 值，并用一个默认值来代替 null。例如，如下的表达式会判断 disc.title 的值是不是 null，如果是 null 的话，那么表达式的计算结果就会是 “The Value Is Null”: 1#&#123;disc.title ?: &apos;The Value Is Null&apos;&#125; 这种表达式通常称为 Elvis 运算符。这个奇怪名称的来历是，当使用符号来表示表情时，问号看起来很像是猫王（Elvis Presley）的头发。 计算正则表达式当处理文本时，又是检查文本是否匹配某种模式是非常有用的。SpEL 通过 matches 运算符支持表达式中的模式匹配。matches 运算符对 String 类型的文本（作为左边参数）应用正则表达式（作为右边参数）。matches 的运算结果会返回一个 Boolean 类型的值：如果与正则表达式相匹配，则返回 true，否则返回 false。加入我们想判断一个字符是否包含有效的邮件地址。在这个场景下，我们可以使用 matches 运算符，如下所示： 1#&#123;admin.email matches &apos;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-+\\.com]&apos;&#125; 计算集合SpEL 中最令人旌旗的一些技巧是与集合和数组有关的。最简单的事情可能就是引用列表中的一个元素了。 1#&#123;jukebox.songs[4].title&#125; 这个表达式会计算 songs 集合汇总第五个元素的 title 属性，这个集合来源于 ID 为 jukebox bean。SpEL 还提供了查询运算符（.?[])，它会用来对集合进行过滤，得到集合的一个子集。作为阐述的样例，假设你希望得到 jukebox 中 artist 属性为 Aerosmith 的所有歌曲。如下的表单时就使用查询运算符得到了结果： 1#&#123;jukebox.songs.?[artist eq &apos;Aeronsmith&apos;]&#125; 可以看到，选择运算符在它的方括号中接收另一个表达式。SpEL 还提供了另外两个查询运算符：”.^[]“和”.$[]“，它们分别用来在集合中查询第一个匹配项和最后一个匹配项。例如，下面的表达式会查找列表中第一个 artist 属性为 Aerosmith 的歌曲： 1#&#123;jukebox.songs.^[artist eq &apos;Aerosmith&apos;]&#125; 最后 SpEL 还提供了投影运算符（.![]），它会从集合的每个成员中选择特定的属性放到另外一个集合中。作为样例，假设我们不想要歌曲对象的集合，而是所有歌曲名称的集合。如下的表达式会将 title 属性投影到一个新的 String 类型的集合中： 1#&#123;jukebox.songs.![title]&#125; 实际上，投影操作可以与其他任意的 SpEL 运算符一起使用。比如，我们可以使用如下的表达式获得 Aerosmith 所有歌曲的名称列表： 1#&#123;jukebox.songs.?[artist eq &apos;Aerosmith&apos;].![title]&#125; 我们所介绍的只是 SpEL 功能的一个皮毛，但已经能够让我们对 SpEL 有一个大致的了解了，当需要用到的时候再去深入学习。在动态注入值到 Spring Bean 时，SpEL 是一种很便利和强大的方式。我们又时会忍不住编写很复杂的表达式。但需要注意的是，不要让你的表达式太智能了。你的表达式越智能，对它的测试就越重要。SpEL 毕竟只是 String 类型的值，可能测试起来很困难。鉴于这一点，我建议尽可能让表达式保持简洁，这样测试不会是什么大问题。 3.6 小节1、学习了Spring profile，解决了Spring bean 要跨各种部署环境的通用问题。Profile bean 是在运行时条件化创建bean的一种方式，但在Spring4中提供了@Conditional注解和SpringCondition接口的实现。 2、解决两种自动装配歧义的方法，首选bean以及限定符。 3、Spring嫩那个狗让bean以单例，原型、会话、请求作用域的方式来创建。 4、简单的学习了SpEl，它能够在运行时计算要注入的bean属性的值。 依赖注入能够将组件以及协作的其他组件解耦，AOP有利于将应用组件与跨多个组件的任务进行解耦。 参考：https://github.com/guoxiaoxu/SpringInActionPracticehttps://www.jianshu.com/p/850c2a2a7a6b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记二]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-2%2F</url>
    <content type="text"><![CDATA[Spring 之旅第 2 章 Spring之旅装配Bean本章内容： 声明bean 构造器注入和Setter方法注入 装配bean 控制bean的创建和销毁 在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。创建应用对象之间的协作关系的行为通常称为装配(wiring),这就是依赖注入的本质。 2.1 Spring配置的可选方案Spring容器负责创建应用程序中的bean，并通过DI来协调这些对象之间的关系。你只需要告诉Spring要创建那些bean，并且如何组织在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制： XML中进行显示配置 在Java中进行显示配置 隐式的bean发现机制自动装配 建议使用：自动装配机制，显示配置越少越好。当你必须显示配置时，推荐使用类型安全并且比XML更加强大的JavaConfig。最后只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应用使用XML 2.2 自动化装配BeanSpring从两个角度来实现自动化装配： 组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的bean 自动装配(autowiring):Spirng自动满足bean之间的依赖 组件扫描和自动装配组合在一起就能发挥出强大的威力，他们能够将你的显示配置降低到最少。 2.2.1 创建被发现的beanCD为我们阐述了DI是如何运行提供了一个很好的样例，如果你不讲CD插入(注入)到CD播放器中，那么CD播放器其实没有太大的用处。CD播放器依赖于CD才能完成他的使命 程序2.1 123public interface CompactDisc &#123; void play();&#125; CompactDisc的具体内容不重要，重要的是你将其定义为一个接口，作为接口，它定义了CD播放器对一盘CD所能进行的操作。它将CD播放器的任意实现与CD本身耦合降低到了最小的程度 程序2.2 123456789101112/** * Created by guo on 21/2/2018. */@Component //表明该类会作为组件类public class SgtPeppers implements CompactDisc &#123; private String title = "sgt. pepper lonely Hearts Club Band"; private String artist = "The Beatles"; @Override public void play() &#123; System.out.println("Playing" + title + "by" + artist); &#125;&#125; SgtPeppers类上使用了@Component注解，这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。没有必要显示配置他。不过组件扫描默认是不开启的，需要显示配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean。 程序2.3 1234@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125; 类CDPlayConfig通过Java代码定义了Spring的装配规则。@ComPonentScan注解可以能够在Spring中启动组件扫描。如果没有其他配置，@ComponentScan默认会扫描与配置类相同的包。Spring将会扫描这个包以及这个包下所有的子包。查找带有@Component注解的类。这样就能发现CompactDisc，并且会在Spring中自动创建一个bean。 使用XMl来启用组件扫描的话，可以使用Spring context命名空间的context:component-scan元素， 程序2.4 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"..... &lt;context:component-scan base-package="com.guo.soundsystem" /&gt;&lt;/beans&gt; 尽管我们可以通过XMl的方案来启用组件扫描，但是在后面的讨论中，更多的还是会使用基于Java的配置。 为了测试组件扫描功能 创建一个简单的JUnit测试，它会创建Spring上下文，并判断CompactDisc是不是真的创建出来了。 程序2.5 123456789101112131415161718192021222324package com.guo.soundsystem;import com.guo.soundsystem.CDPlayerConfig;import com.guo.soundsystem.CompactDisc;import static org.junit.Assert.*; //这里使用了静态导入import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayConfig.class)public class CDPlayTest &#123; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull() &#123; assertNotNull(cd); &#125;&#125; CDPlayerTest使用了Spring的SpringJUnitClassRunner，以便在测试开始的时候自动创建Spring的上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置.带有@Autowired注解，以便将CompactDisc bean注入到测试代码中，最后断言cd属性不为null，就意味着Spirng能够发现CompactDisc类，自动在Spring应用上下文中将其创建为bean并将其注入到测试代码中。 2.2.2 为组件扫描的bean命名Spring应用上下文中所有bean都会给定一个ID。尽管没有明确为SgtPeppers bean 设置ID，但Spring会根据类名为其指定一个ID，这个ID所给定的ID为sgtPeppers，也就是将类名的第一个字母变为小写。 如果想设置不同的ID，所需要做的就是将期望的ID作为值传递给@Component注解 1234@COmponent("lonelyHeartsClub")public class SgtPeppers implements CompactDisc &#123; ...&#125; 还有另外一种为bean命名的方式，这种方式不使用@Component注解，而是使用Java依赖注入规范(Java Dependency Injection) 中所提供的@Named注解为bean设置ID： 12345import javax.inject.Named@Named("lonelyHeartsClub")public class SgtPeppers implements CompactDisc &#123; ...&#125; Spring支持将@named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，他们是可以互相替换的。 《Spring 实战》作者更喜欢@Component注解，而对于@Named。。。感觉名字起的很不好 2.2.3 设置组件扫描的基础包到目前为止，我们没有为@ComponentScan设置任何属性，这意味着，按照默认规则，它会以配置类所在的包作为基础包(base package) 来 扫描组件，有一个原因会促使我们明确的设置基础包，那就是我们要将配置类放在单独的包中，使其与其他应用代码区分开来。 为了指定不同的基础包，你所需要做的就是在@ComponentScan的Value属性中指明包的名称123@Configuration@Componentscan("com.guo.soundsystem")public class CDPlayerConfig&#123;&#125; 如果你想更加清晰的表明你所设置的是基础包，那么你可以通过basePackages属性来进行设置123@Configuration@Componentscan(basePackages="com.guo.soundsystem")public class CDPlayerConfig&#123;&#125; @basePackages属性使用的是复数形式，以为这可以设置多个基础包，只需要将basePackages属性设置为要扫描包的一个数组就可以123@Configuration@Componentscan(basePackages=&#123;"com.guo.soundsystem","com.guo.video"&#125;)public class CDPlayerConfig&#123;&#125; 在上面所有的例子中，所设置的基础包都是以String类型表示的，作者认为这是可以的，但是这种方式是类型不安全的，如果你要重构代码的话，那么你所指定的基础包可能就会出现错误。 除了将包设置为简单的String类型之外，@ComponentScan还提供了另外一种方式，那就是将其设置为包中所包含的类或接口 123@Configuration@Componentscan(basePackageClasses=&#123;CDPlayer.class,DVDPlayer.class&#125;)public class CDPlayerConfig&#123;&#125; 尽管在样例中，为basePackageClasses设置的是组件类，但是可以考虑在包中创建一个用来扫描的空标记接口。通过标记接口的方式，你依然能够保持对重构友好的接口的引用，但是可以避免引用任何实际的应用程序代码。 在你的应用程序中，如果所有的对象都是独立的，彼此之间没有任何依赖，就像SgtPeppers bean 这样，那么你需要的可能就是组件扫描而已。但是很多对象会依赖其他的对象才能完成任务。这样的话我们就需要有一种方式能够将组件扫描到的bean和他们的依赖装配在一起：自动装配 2.2.4 通过为bean添加注解实现自动装配自动装配就是让Spring自动满足bean依赖的一种方法，在满足的依赖的过程中，会在Spring应用上下文寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以将可以借助于Spring提供的@Autowired注解。 123456789101112@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; @Override public void play() &#123; cd.play(); &#125;&#125; 在构造器上添加了@Autowired注解，这表明当Spring创建CDPlayer bean时，会通过这个构造器来实例化并且传入一个可设置给CompactDisc类型的bean @Autowired注解不仅可以用于构造器上，还能用在属性Setter方法上， 1234@Autowiredpublic void setCompactDisc(CompactDisc cd)｛ this.cd = cd;｝ 在Spring初始化bean之后，它会尽可能去满足bean的依赖，依赖是通过带有@Autowired注解的方法进行生命的， 实际上，Setter方法并没有什么特殊之处。@Autowired可以用在类的任何方法上，1234@Autowiredpublic void insertDisc(CompactDisc cd)｛ this.cd = cd;｝ 不管是构造器、Setter方法还是其他方法，Spring购汇尝试满足方法参数上所申明的依赖。假如有且只有一个满足需求依赖的话，那么这个bean将会被装配进来， 如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常，为了避免异常的出现，你可以将@Autowired的required属性设置为false 1234@Autowired(required=false)public CDPlayer(CompactDisc cd) &#123; this.cd = cd;&#125; 将required设置为false时，Spring会尝试执行自动装配，但如果没有匹配的bean，Spring将会让这个bean处于未装配的状态，需要谨慎对待，如果你的代码中没有进行null检查的话，这个处于未装配的属性可能会出现NullPointerException。 如果有多个bean满足依赖关系时，Spirng将会抛出异常，表明没有明确指定要选择安格bean进行装配。 @ Autowired是Spring特有的注解，如果你不喜欢在代码中使用@Autowired，那么你可以考虑使用@Inject 123456789101112@Namedpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc cd; @Inject public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; @Override public void play() &#123; cd.play(); &#125;&#125; @Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解，在Spring自动装配中，Spirng同时支持@Inject和@Autowired，作者没有特别的偏向性。根据自己的情况，选择合适自己的，推荐使用@Autowired。 2.2.5 验证自动装配1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest &#123; @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Autowired private MediaPlayer player; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull() &#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals( "Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n", log.getLog()); &#125;&#125; 在测试代码中使用System.out.println()是稍微有些棘手的是，该样例中使用了StandardOutputStreamLog，这是来源于System Rules 库的一个JUnit规则，该规则能够基于控制台的输出编写断言。 2.3通过Java代码装配bean尽管在很多常见喜爱通过组件扫描和自动装配实现了Spring的自动装配是更为推荐的方式，但有时候自动化配置的方案是行不通的，因此需要明确配置Spring.比如你将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的。 在这种情况下，你必须使用显示装配方式，在进行显示装配的时候，有两种方案可以选择。Java和XML。 作者认为:在进行显示配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好 因为它是Java代码，就像应用程序中的其他代码一样。 同时，JavaConfig与其他的Java代码由有所区别，在概念上，他与应用程序中的业务逻辑和领域代码是不同的。JavaConfig是配置代码。这意着它不应该包含任何业务逻辑，JavaConfig也不应该侵入到业务逻辑代码中。通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。 2.3.1 创建配置类。12345678import org.springframework.context.annotation.Configuration;/** * Created by guo on 21/2/2018. */@Configurationpublic class CDPlayerConfig &#123;&#125; 创建JavaConfig类的关键点在于为其添加@Configuration注解，表明该类是一个配置类。该类应该包含在Spring应用上下文中如何创建bean的细节 尽管我们可以同时使用组件扫描和显示配置，但在本节中更关注显示配置，因此将CDPlayerConfig中的@ComponentScan注解移除了。此时在运行会抛出org.springframework.beans.factory.BeanCreationException: Error creating bean with name异常。测试希望被注入的CDPlayer和CompactDisc，但这些bean根本没有创建，因为组件扫描不会发现它们。 2.3.2 声明简单的bean要在JavaConfig中声明bean，需要编写一个方法，这个方法会创建锁需要类型的实例，然后给这个方法添加@Bean注解。 1234567@Configurationpublic class CDPlayerConfig &#123; @Bean public CompactDisc sgtPeppers() &#123; return new SgtPeppers(); &#125;&#125; @Bean注解会告诉Spirng这个方法将返回一个对象，该对象要注册为Spring应用上下文中的bean，方法中最终产生了bean实例的逻辑。 默认情况下，bean的ID与带有@Bean注解的方法名是一样的，如果你想重命名该方面，也可以通过name属性指定一个不同的名字 1234567@Configurationpublic class CDPlayerConfig &#123; @Bean(name="lonelyHeartsClub") public CompactDisc sgtPeppers() &#123; return new SgtPeppers(); &#125;&#125; 在一组CD中随机选择一个CompactDisc来播放 12345678910111213@Beanpublic CompactDisc randomBeatlesCD() &#123; int choice = (int)Math.foloor(Math.random() * 4); if (choice == 0) &#123; return new SgtPeppers(); &#125;else if (choice == 1) &#123; return new WhiteAlbum(); &#125;else if (choice == 2) &#123; new HardDaysNight(); &#125;else &#123; return new Revolver(); &#125;&#125; 2.3.3 借助JavaConfig实现注入在JavaConfig中最简单方式就是引用创建bean的方法，1234@Beanpublic CDPlayer cdPlayer() &#123; return new CDPlayer(sgtPeppers);&#125; cdPlayer()方法相sgtPepper()方法一样，同样使用了@Bean注解，表明这个方法会创建一个bean实例并嫁将其注入到Spring应用上下文中。所创建的bean ID为cdPlayer，与方法名字相同。 通过调用方法来引用bean的方式有点令人困惑，其实还有一种理解起来更为简单的方式 1234@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc);&#125; 在这里cdPlayer方法请求一个compactDisc作为参数，当Spring调用cdPlayer创建的CDPlayer bean 时，它会自动装配一个CompactDisc到配置方法中，然后，方法体就可以按照合适的方式来使用它。借助于这种技术，cdPlayer也可以将CompactDisc注入到CDPlayer的构造器中，而不用明确引用CompactDisc的@Bean方法。 通过这种方式引用其他的bean是最佳的选择。因为它不会要求将CompactDisc申明到同一个配置类中。实际上它可以通过组件扫描能够自动发现或者通过XML来进行配置。你可以将配置分散到多个配置类、XML文件以及自动扫描和装配的bean中，只要功能完整即可。 另外需要提醒的是，我们在这里使用CDPlayer的构造器实现了DI功能，但是我们完全可以采用其他风格的DI配置，比如你想通过Setter方法来注入CompactDisc的话，可以这样做 123456@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) &#123; CDPlayer cdPlayer new CDPlayer(compactDisc); cdPlayer.setCompactDisc(compactDisc); return cdPlayer;&#125; 再次强调一遍，带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例，构造器和Setter方法只是@Bean方法的两个简单样例。这里存在的可能性仅仅受到了Java语言的限制。 2.4 通过XML装配bean（不推荐使用）在Spring刚刚出现的时候，XMl是描述配置的主要方式。在Spring的名义下，我们创建了无数行XML代码。在一定程度上，Spring成为了XMl配置的同义词。现在需要明确的是XML不再是配置Spring的唯一可选方案。Spring现在有了强大的自动配置和基于Java的配置，Xml不应该在是你的第一选择了。 本节的内容只是用来帮助你维护已有的XML配置，在完成新的Spring工作时，希望你会使用自动化配置和Java配置 2.4.1 创建XML配置规范在使用XMl为Spring装配bean之前你需要创建一个新的配置规范。在使用JavaConfig的时候，你需要创建一个带有@Configuration注解的类，而在XML配置中，需要创建一个XMl文件，并且要以元素为根 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- configuration details go here --&gt;&lt;/beans&gt; 已经有一个合法的Spring XMl配置文件。不过它是一个没有任何用处的配置，因为它没有申明任何bean。为了给予它生命，重新创建一下CD样例，只不过这次选择XML配置，而不是使用JavaConfig和自动化装配。 2.4.2 声明一个简单的bean要在基于XML的Spring中声明一个bean，需要使用Spring-beans模式中的另一个元素 类似于JavaConfig中的@Bean注解。 1&lt;bean class="com.guo.soundsystem.SgtPeppers"/&gt; 这里声明了一个简单的bean，创建这个bean的类通过class属性来指定的并且要使用全限定类名。 因为没有明确给Id，所以这个bean将要根据全限定名来进行命名。 尽管自动化的bean命名方式非常方便，但如果你稍后需要引用它的话，那么自动产生的名字就没有多大用处了。因此，通常来讲更好的办法就是借助于id属性。为每个bean设置一个你自己选择的名字 1&lt;bean id="compactDisc" class="com.guo.soundsystem.SgtPeppers"/&gt; 第一件需要注意的事情就是你不在需要直接负责创建SgtPeppers的实例，在基于JavaConfig的配置中，我们需要这样做。当Spring发现这个元素时，它会调用SgtPeppers的默认构造器来创建bean。在Xml配置中，bean的创建显得更加被动，不过，它它没有javaConfig那样强大，在JavaConfig中，你可以通过任何可以想象到的方法来创建bean实例。 另一个需要注意的是，在这个简单的声明中，我们将bean的类型以字符串的形式设置在了 class属性中。谁能确保设置给Class属性的值是真正的类呢？Spring的XMl配置并不能从编译器的类型检查张宏收益，即便它所引用的是实际的类型，如果你重命名了会发生什么呢？ 以上介绍的只是JavaConfig要优于XML配置的部分原因。在你的应用选择配置风格时，要记住XMl配置的这些缺点。 2.4.3 借助于构造器注入 初始化 bean在Spring XMl配置中，只有一种声明bean的方式，使用元素并制定calss属性，Sprng会从这里获取必要的信息来创建bean。 在XMl中声明DI时，会有多种可选的配置风格和方案。具体到构造器注入，有两种基本的配置方案可供选择 元素 使用Spring3.0所引入的c-命名空间 两者的区别在很大程度就是是否冗余长烦琐。元素比使用c-命名空间会更加冗长。从而导致XMl更加难以读懂。另外有些事情可以做到，但是使用c-命名空间却无法实现。 构造器注入Bean引用123&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer"&gt; &lt;constructor-arg ref="compactDisc"/&gt;&lt;/bean&gt; 当Spring遇到这个bean元素时，它会创建一个CDPlayer实例 。元素会告知Spring要将一个ID为compactDisc的bean引用传递到CDPlayer的构造器中 作为替代方案，你也可以使用Spring的c-命名空间。c-命名空间实在Spring3.0中引入的，它是在XMl中更为简单的描述构造器参数的方式，要使用他的话，必须在XMl的顶部声明其模式 ， 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 在c-命名空间和模式声明之后，就可以使用它来声明构造器参数了 12&lt;bean id="compactDisc" class="com.guo.soundsystem.cdPlayer" c:cd-ref="compactDisc" /&gt; 将字面量注入到构造器中迄今为止，我们所作的DI通常指的都是类型的装配—也就是将对象的引用装配到依赖于他的其他对象之中。而有些时候我们需要做的只是将一个字面量值来配置对象，为了阐述这一点，假设你要创建CompactDisc的一个新实现 。 1234567891011121314151617/** * Created by guo on 21/2/2018. */public class BlankDisc implements CompactDisc &#123; private String title; private String artist; public BlankDisc(String title, String artist) &#123; this.title = title; this.artist = artist; &#125; @Override public void play() &#123; System.out.println("Playing " + title + " by " + artist); &#125;&#125; 在SgtPeppers中，唱片名称和艺术家的名字都是硬编码的。但是这个CompactDisc实现与之不同，它更加灵活。像现实中的空磁盘一样，它可以设置成你想要的艺术家和唱片名。 1234&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;constructor-arg value="The Beatles"/&gt;&lt;/bean&gt; 使用value属性，通过该属性表明给定的值要以字面量的形式注入到构造器中。 装配集合如果使用CompactDisc为真正的CD建模，那么它也应该有磁道列表的概念。 123456789101112&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;constructor-arg value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;constructor-arg value="The Beatles"/&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;11&lt;/value&gt; &lt;value&gt;22&lt;/value&gt; &lt;value&gt;33&lt;/value&gt; &lt;value&gt;44&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 其中，元素是的子元素。这表明一个包含值的列表将会传递给构造器中，其中元素用来指定列表中的每一个元素。 与之类似的，我们也可以使用元素替代,实现bean引用列表的装配 和元素区别不大，其中重要的不同在于当Spring创建要装配集合的时候，所创建的是java.util.Set还是java.util.List。如果是Set的话，所有重复元素会被忽略掉，存放顺序也不会得到保证。不过无论在哪中情况下，和都可以用来装配List、Set甚至数组。 在装配集合方面，比c-命名空间的属性更有优势。使用c-命名空间的属性却无法实现装配集合的功能 与其不厌其烦的花时间讲述如何使用XML进行 构造器注入，还不如看一下如何使用XML来装配属性 2.4.4 设置属性到目前为止，CDPlayer和BlanckDisc类完全是通过构造器注入的，没有使用属性的Setter方法，接下来，我们就看看如何使用Sprng XML配置实现属性注入， 该选择构造器注入还是熟悉注入呢？作为一个通用的规则，我倾向于对强依赖使用构造器注入，而对可选性的依赖使用属性注入。 对于CDPlayer来讲，它对CompactDisc是强依赖还是可选依赖可能会有些争议。 Spring在创建bean的时候不会有任何问题，但是CDPlayTest会因为出现NullPointException而导致测试失败，因为我们并没有出入CDPlayer的compactDisc属性。不过按照下面的方式修改XML，就能解决该问题 123&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer"&gt; &lt;propert name="compactDisc" ref="compactDisc"/&gt;&lt;/bean&gt; 元素为属性的Setter方法所提供的功能与元素为构造器所提供的功能是一样的。在本例中，它它引用了ID为compactDisc的bean，(通过ref属性)，并将其注入到compactDisc属性中(通过setCompactDisc()方法)。 Spring为元素通过了c-命名空间作为替代方案，与之类似的，Spring提供了更加简洁的p-命名空间，作为元素的替代方案。为了启用p-，必须在XML文件织哦你与其他命名空间一起对其进行声明。 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 我们可以使用p-命名空间，按照以下的方式装配compactDisc属性 12&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" p:compactDisc-ref="compactDisc"/&gt; 首先属性的名字使用了”p：”前缀，表明我们设置的是一个属性。接下来就要注入属性名。 将字面量注入到属性中123456789101112&lt;bean id="compactDisc1" class="com.guo.soundsystem.BlankDisc"&gt; &lt;propert value="Sgt. Peppers Lonely Hearts Club band"/&gt; &lt;propert value="The Beatles"/&gt; &lt;propert&gt; &lt;list&gt; &lt;value&gt;11&lt;/value&gt; &lt;value&gt;22&lt;/value&gt; &lt;value&gt;33&lt;/value&gt; &lt;value&gt;44&lt;/value&gt; &lt;/list&gt; &lt;/propert&gt;&lt;/bean&gt; 需要注意的是**我们不能使用p-命名空间来装配集合，没有遍历的方式使用p-命名空间 util-命名空间所提供的功能之一就是util:list元素它会创建一个列表的bean，借助util:list，我们可以将磁道列表转移到BlackDisc bean之外。并将其声明到单独的bean之中。 123456789101112131415&lt;util:list id="trackList"&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;value&gt;She's Leaving Home&lt;/value&gt; &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt; &lt;value&gt;Within You Without You&lt;/value&gt; &lt;value&gt;When I'm Sixty-Four&lt;/value&gt; &lt;value&gt;Lovely Rita&lt;/value&gt; &lt;value&gt;Good Morning Good Morning&lt;/value&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band (Reprise)&lt;/value&gt; &lt;value&gt;A Day in the Life&lt;/value&gt;&lt;/util:list&gt; 在需要的时候，你可能会用到util-命名空间中的部分成员。 Spring util-命名空间中的元素 util:constant :引用某个类型的public static 域，并将其暴露为bean util:list:创建一个java.util.List类型的bean，其中包含值和引用 util:map :创建一个java.util.Map类型的bean，其中包含值或引用。 util:properties :创建一个java.util.properteis类型的bean。 util：set： 创建一个java.util.Set类型的bean，其中包含值或引用。 2.5导入和混合配置在典型的Spring应用中，我们可能同时使用自动化和显示配置。即便你更喜欢通过JavaConfig实现显示配置，但有时候XML确实最佳的方案。 幸好在Spring中，这些配置方案不是互斥的，你尽可以将JavaConfig的组件扫描和自动装配或XMl配置混合在一起。 关于混合配置，第一件事需要了解的就是在自动装配时，它并不在意要装配的bean来自哪里。自动装配的时候会考虑Spring容器中所有的bean，不管他在JavaConfig中还是在XMl中声明的还是通过组件扫描获取到的。 2.5.1 在JavaConfig中引用XML配置将设bean很多，所能实现的一种方案就是将BlankIDisc从CDPlayerConfig中拆分出来，定义到它自己的CDConfig中。 1234567@Configurationpublic class CDConfig &#123; @Bean public CompactDisc compactDisc () &#123; return new SgtPeppers(); &#125;&#125; compactDisc方法已经从CDPlayerConfig中移除了，我们需要有一种方式将这两个类组合在一起。一种方式就是在CDPlayerConfig中使用@Import注解导入CDConfig。 1234567891011/** * Created by guo on 21/2/2018. */@Configuration@Import(CDConfig.class)public class CDPlayerConfig &#123; @Bean public CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc); &#125;&#125; 或者采用一个更好的办法，也就是不再CDPlayerConfig中使用@Import，而是创建一个更高级别的SoundSystemConfig，在这个类中使用@Import将两个配置组合在一起： 本人：内心还在想什么好方法，确实是更好的办法。 1234@Configuration@Import(&#123;CDPlayerConfig.class,CDConfig.class&#125;)public class SoundSystemConfig &#123;&#125; 不管采用哪种方式，我们都将CDplayer的配置与BlankDisk的配置分开了。现在，我们假设(基于某种原因)希望通过XML来配置BlackDisc， 123456789101112131415&lt;bean id="compactDisc" class="com.guo.soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt; &lt;value&gt;With a Little Help from My Friends&lt;/value&gt; &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt; &lt;value&gt;Getting Better&lt;/value&gt; &lt;value&gt;Fixing a Hole&lt;/value&gt; &lt;!-- ...other tracks omitted for brevity... --&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 现在BlankDisc配置在了XML中，我们该如何让Spring同时加载它和其他基于Java的配置呢？ 答案是@ImportResource注解。假设BlankDisc定义在名为cd-config.xml的文件中，该文件位于根路径下，那么可以修改SoundSystemConfig让他使用@ImportResource注解 12345@Configuration@Import(CDPlayerConfig.class)@ImportResource("classpath:cd-config.xml")public class SoundSystemConfig &#123;&#125; 两个bean–配置在JavaConfig中的CDPlayer以及配置在XMl中BlankDisc — 都会被加载到Spring容器中，因为CDPlayere中带有@Bean注解的方法接受一个CompactDisc作为参数。因此BlankDisc将会被装配进来，此时与他是通过XML配置的没有任何关系。 让我们继续这个练习，但是这一次，我们需要在XMl中引用JavaConfig声明的bean 2.5.2 在XML配置中引用JavaConfig假设你正在使用Spring基于XML的配置，并且你已经意识到XML逐渐变得无法控制。 在JavaConfig配置中，我们已经展现了如何使用@Import和@ImportResource来拆分JavaConfig类，在XML中，我们可以使用import元素来拆分XML配置。 比如假设你希望将BlankDiscbean拆分到自己的配置文件中，该文件名为cd-config.xml. 1234&lt;import resource="cd-config.xml"/&gt;&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" c:cd-ref="compactDisc" /&gt; 现在假设不再将BlankDisc配置在XXMl中，而是将其配置到JavaConfig中，CDPlay继续配置在XML中， 为了将JavaConfig类导入到XMl配置中，我们可以这样声明bean： 1234&lt;bean class="com.guo.soundsystem.CDConfig"/&gt;&lt;bean id="cdPlayer" class="com.guo.soundsystem.CDPlayer" c:cd-ref="compactDisc" /&gt; 采用这样的方式，两种配置–其中一种使用XML描述，另一个使用Java描述—被组合在一起了。类似的，你还希望声明一个更高级被的层次的配置文件，这个文件不声明任何bean，只是负责将两个或 多个配置文件组合在一起。 123&lt;bean class="com.guo.soundsystem.CDConfig"/&gt;&lt;import resource="cdplayer-config.xml"/&gt; 不管使用XMl还是JavaConfig进行装配，我通常都会创建一个根配置，也就是这里展现的这样，这个配置文件会将两个或更多的装配类和/或XML文件组合起来。我也会在根配置中启用组件扫描(通过context:component-scan或@ComponentScan)，你会在本书中很多的例子中看到这种技术。 2.6 小节Spring的核心是Spring容器。容器负责管理应用中组件的生命周期，它会创建这些组件并保证他们的依赖能够得到满足，这样的话，组件才能完成预定的任务。 在本章中，我们看到了Spring中装配bean的三种方式：自动化装配、基于Java的显示配置、以及基于XML的显示配置。不管你采用什么方式，这些技术都描述了Spring应用中的组件以及这些组件之间的关系**。 我同时建议你尽可能使用自动化配置，以避免显示配置所带来的维护成本。但是，如果你确实需要显示的配置Spring的话，应该优先选择基于Java的配置，它比基于XML的配置更加强大、类型安全、并且易于重构。 在本书中的栗子中，当决定如何装配组件时，我都会遵循这样的指导意见。 因为依赖注入是Spring中非常重要的组成部分，所以本章中介绍的技术在本书中所有的地方都会用到。基于这些基础知识，下一章将会介绍一些更为高级的bean装配技术，这些技术能够让你更加充分地发挥Spring容器的威力 参考：https://github.com/guoxiaoxu/SpringInActionPractice]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring实战笔记一]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15%2F</url>
    <content type="text"><![CDATA[Spring 之旅第 1 章 Spring之旅本章内容： Spring 的 bean 容器 介绍 Spring 的核心模块 更为强大的 Spring 生态系统 Spring 的新功能 1.1 简化 Java 开发为了降低 Java 开发的复杂性，Spring 采取了以下 4 种关键策略： 基于 POJO 的轻量级和最小入侵性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程： 通过切面和模板减少样板代码； 1.1.1 激发 POJO 的潜力尽管简单，但 POJO 一样可以拥有魔力，Spring 赋予 POJO 魔力的方式之一就是通过 DI 来装配它们。 1.1.2 依赖注入(DI,Dependenc Injection)依赖注入现在已经演变成一项复杂的编程技巧或设计模式的理念 按照传统的做法，每个对象负责管理与自己相互协作的对象的引用 (即它所依赖的对象)，这就会导致高度耦合和难以测试的代码。 程序1.2 1234567891011121314/** * damsel表示：少女 */public class DamselRescuingKnight implements Knight &#123; private RescueDamselQuest quest; public DamselRescuingKnight ( RescueDamselQuest quest) &#123; //与RescueDamselQuest紧耦合 this.quest = new RescueDamselQuest(); &#125; @Override public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; DamselRescueingKnight 在它的构造函数中自行创建了 RescueDamselQuest。这使得两者紧紧的耦合在一起。因此极大的限制了骑士执行探险的能力。在这样一个测试中 ，你必须保证当骑士 embarkOnQuest 方法被调用的时候，探险 embark 方法也要被调用。但是没有一个简单明了的方式能够测试。 通过 DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候设定，对象无需自行创建或管理他们的依赖关系，依赖关系将被自动注入到需要它们的对象中。 依赖注入会将所依赖的关系自动交给目标对象，而不是让对象自己去获取依赖 BraveKnight 足够灵活可以接受任何赋予他的探险任务。 程序1.3 1234567891011121314public class BraveKnight implements Knight &#123; public Quest quest; public BraveKnight(Quest quest&#123; //Quest被注入进来 this.quest = quest; &#125; @Override public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; 不同于之前的 DamselRescuingKnight，BraveKnight 没有自行创建探险任务，而是在构造的时候把探险任务作为构造参数传入。这是依赖注入的方式之一，即构造注入 (constructor injection). 需要注意的是，传入的探险类型是一个 Quest，也就是所有的探险任务都必须实现的一个接口。所以 BraveKnight 能够响应 RescueDamselQuest、SlayDragonQuest、MakeRoundTableRounderQuesst 等任意的 Quest 实现。 这里的要点是 BraveKnight 没有有特定的 Quest 实现发生耦合。对他来说，被要求挑战的探险任务只要实现了 Quest 接口，那么具体的是那种类型就无关紧要了。这就是 DI 带来最大的收益——松耦合。如果一个对象只通过接口 (而不是具体的实现或初始化过程) 来表明依赖关系，那么这种依赖就能够在对象本身毫不情况的情况下，用不同的具体实例进行替换。 对依赖进行替换的一个最常用方法就是在测试的时候使用 mock 实现。 程序1.4 123456789101112import static org.mockito.Mockito.*;public class BraveKnightTest &#123; @Test public void knightShouldEmbarkQuest() &#123; Quest mockQuest = mock(Quest.class); //创建mock Quest BraveKnight knight = new BraveKnight(mockQuest); //注入mock Quest； knight.embarkOnQuest(); verify(mockQuest,times(1)).embark(); &#125;&#125; 可以通过 mock 框架 Mockito 去创建一个 Quest 接口的 mock 实现。通过这个 mock 对象，就可以创建一个新的 BraveKnight 实例，并通过构造器注入到这个 mock Quest。当调用 embarkOnQUest 方法时，你可以要求 Mockito 框架验证 Quest 的 mock 实现的 embark 方法仅仅被调用了一次。 将 Quest 注入到 Knight 中 希望 BraveKnight 所进行的探险任务是杀死一只怪龙， 程序1.5 123456789public class SlayDragonQuest implements Quest &#123; private PrintStream stream; public SlayDragonQuest(PrintStream stream) &#123; this.stream = stream; &#125; @Override public void embark() &#123; stream.println("Embarking on quest to slay the dragon!!,顺便还可以学英语，一举两得。"); &#125; SlayDragonQuest 实现类 Quest 接口，这样它就适合注入到 BraveKnight 中了，与其他样例不同的是，SlayDragonQuest 没有使用 System.out.println();, 而是在构造方法中请求一个更为通用的 PrintStream。 创建应用组件之间协作的行为成为装配。Spring 有多种装配 Bean 的方式，采用 XML 是一种常用的方式。 knights.xml，该文件将 BraveKnight，SlayDragonQuest 和 PrintStream 装配到一起。 程序1.6 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="knight" class="guo.knights.BraveKnight"&gt; &lt;!--注入Quest bean--&gt; &lt;constructor-arg ref="quest"/&gt; &lt;/bean&gt; &lt;!--创建SlayDragonQuest--&gt; &lt;bean id="quest" class="guo.knights.SlayDragonQuest"&gt; &lt;constructor-arg value="#&#123;T(System).out&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在这里，BraveKnight 和 SlayDragonQuest 被声明为 Spring 中的 bean。就 BraveKnight bean 来讲，他在构造时传入对 SlayDragonQuest bean 的引用，将其作为构造器参数。同时，SlayDragonQuest bean 的声明使用了 Spring 表达式语言 (Spring Expression Language)，将 System.out(一个 PrintStream) 传入到了 SlayDragonQuest 的构造器中， 在 SpEL 中, 使用 T() 运算符会调用类作用域的方法和常量. 例如, 在 SpEL 中使用 Java 的 Math 类, 我们可以像下面的示例这样使用 T() 运算符： T(java.lang.Math) T() 运算符的结果会返回一个 java.lang.Math 类对象. Spring 提供了基于 Java 的配置可作为 XML 的替代方案。 程序1.7 12345678910111213141516171819202122import guo.knights.BraveKnight;import guo.knights.Knight;import guo.knights.Quest;import guo.knights.SlayDragonQuest;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Created by guo on 20/2/2018. */@Configurationpublic class KnightConfig &#123; @Bean public Knight knight() &#123; return new BraveKnight(quest()); &#125; @Bean public Quest quest() &#123; return new SlayDragonQuest(System.out); &#125;&#125; 不管使用的是基于 XML 的配置还是基于 Java 的配置，DI 所带来的收益都是相同的。尽管 BraveKnight 依赖于 Quest，但是它并不知道传递给它的是什么类型的 Quest，与之类似，SlayDragonQuest 依赖于 PrintStream，但是编译时，并不知道 PrintStream 长啥样子。只有 Spring 通过他的配置，能够了解这些组成部分是如何装配起来的。这样就可以在不改变 所依赖的类的情况下，修改依赖关系。 接下来，我们只需要装载 XML 配置文件，并把应用启动起来。 Spring 通过应用上下文 (Application context) 装载 bean 的定义，并把它们组装起来。Spring 应用上下文全权负责对象的创建个组装，Spring 自带了多种应用上下文的实现，他们之间的主要区别仅仅在于如何加载配置。 因为 knights.xml 中的 bean 是使用 XML 文件进行配置的，所以选择 ClassPathXmlApplicationContext 作为应用上下文相对是比较合适的。该类加载位于应用程序类路径下的一个或多个 Xml 配置文件。 程序1.8 12345678910111213public class KnightMain &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("spring/knights.xml"); //加载Sprinig应用上下文 Knight knight = context.getBean(Knight.class); //获取knight bean knight.embarkOnQuest(); //使用knight调用方法 context.close(); //关闭应用上下文 &#125;&#125; 这里的 main() 方法基于 knight.xml 文件创建了 spring 应用上下文。随后他调用该应用上下文获取一个 ID 为 knighht 的 bean。得到 Knighht 对象的引用后，只需要简单调用 embarkOnQuest 方法就可以执行所赋予的探险任务了。只有 knights.xml 知道哪个骑士执行力那种任务。 1.1.3 应用切面DI 能够让相互协作的软件组件保持松耦合，而面向切面编程 (aspect-oriented programming AOP) 允许你把遍布应用各处的功能分离出来形成可重用的组件。 面向切面编程往往被定义为促使软件系统实现关注点的分离一项技术, 系统由许多不同的组件组成，每个组件各负责一特定的功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理、和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中。这些系统通常被称为横切关注点。，因此他们会跨越系统多个组件。 AOP 能使这些服务模块化，并以声明的方式将它们应用到它们要影响的组件中去。所造成的结果就是这些组件会更加关注自身的业务，总之 AOP 能确保 POJO 的简单性。 我们可以把切面想象为覆盖在很多组件之上的一个外壳。应用是由哪些实现各自业务功能模块组成的，借助 AOP， 可以使用各种功能层去包裹核心业务层，, 这些层以声明的方式灵活的应用到系统中，你的核心应用甚至根本不知道他们的存在。这是一个非常强大的理念，可以将安全，事务，日志关注点与核心业务相分离。** 程序1.9 12345678910111213141516171819/** * Created by guo on 20/2/2018. * 咏游诗人，作为骑士的一个切面 */public class Minstrel &#123; private PrintStream stream; public Minstrel(PrintStream stream) &#123; this.stream = stream; &#125; public void singBeforeQuest() &#123; stream.println("Fa la la ,the Knight is so brabe"); //探险之前调用 &#125; public void singAfterQuest() &#123; stream.println("Tee hee hhe,the brave knight " + "did embark on a quest"); //探险之后调用 &#125;&#125; Minstrel 只有两个简单的方法的类，在骑士执行每一个探险任务之前，singBeforeQuest() 被调用；在骑士完成探险任务之后，singAfterQuest() 方法被调用。在这两种情况下，Minstrel 都会通过一个 PrintStream 类来歌颂骑士的事迹，这个类通过构造器注入进来。 但利用 AOP，你可以声明咏游诗人西部歌颂骑士的 探险事迹，而骑士本身不直接访问 Minstrel 的方法 要将 Minstrel 抽象为一个切面，你所需要做的事情就是在一个 Spring 配置文件中声明它，， 程序1.11 123456789101112131415&lt;bean id="minstrel" class="guo.knights.Minstrel"&gt; &lt;constructor-arg value="#&#123;T(System).out&#125;"/&gt; &lt;!--声明Minstrel bean--&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect ref="minstrel"&gt; &lt;aop:pointcut id="embark" expression="execution(* * .embarkOnQuest(..))"/&gt; &lt;!--定义切点--&gt; &lt;aop:before pointcut-ref="embark" method="singBeforeQuest"/&gt; &lt;!-- 声明前置通知--&gt; &lt;aop:after pointcut-ref="embark" method="singAfterQuest"/&gt; &lt;!-- 声明后置通知--&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 这里使用了 Spring 的 aop 配置命名空间把 Minstrel 声明为一个切面。 在这两种方式中，pointcut-ref 属性都引用列名为为 “embark” 的切入点，该切入点实在前面的元素中定义的，并配置 expression 属性来选择所应用的通知。表达式的语法采用的是 aspectJ 的切点表达式语言。 Minstrel 仍然是一个 POJO，没有任何代码表明它要被作为一个切面使用，其次最重要的是 Minstrel 可以被应用到 BraveKnight 中，而 BraveKnight 不需要显示的调用它，实际上，BraveKnight 完全不知道 MInstrel 的存在 1.1.4 小节作者已经为我们展示了 Spring 通过面向 POJO 编程、DI、切面、模板技术来简化 Java 开发中的复杂性。在这个工程中，展示了基于 XML 的配置文件中如何配置 bean 和切面，但这些文件是如何加载的呢？他们被加载到哪里呢？接下来让我们了解下 Spring 容器，这是应用中的所有 bean 所驻留的地方。 1.2 容纳你的Bean在基于Spring的应用中，你的应用对象存在于Spring容器(container)中.Spring负责创建对象，装配它，并管理它们的整个生命周期，从生存到死亡(new 到finalize())。 首先重要的是了解容纳对象的容器。理解容器将有助于理解对象是如何创建的。 容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件爱你之间的联系。这些对象更简单干净、更容易理解，更易于重用并且易于进行单元测试。 Spring容器并不只是只有一个，Spring自带了多个容器实现，可以归纳为两种不同的类型： Bean工厂。由org.springframework.beans.factory.BeanFactory接口定义的。是最简单的容器。 应用上下文 由org.springframework.context.applicationContext接口定义的。基于BeanFactory构建，并提供应用框架级别的服务，例如：从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听器。 应用上下文比Bean工厂更受欢迎。bean工厂对于大多数应用来说太低级了。 1.2.1使用应用上下文Spring自带了多种应用上下文： AnonotationConfigApplicationContext：从一个或多个基于Java的配置文件类中加载Spring应用上下文 AnnotationConfigWebApplicationContext：从一个或多个基于Java配置类加载SpringWeb应用上下文 ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源 FileSystemXmlapplicationContext：从文件系统下的一个或多个XMl配置文件中加载上下文定义 XmlWebapplicationContext：从web应用下的一个或多个XML配置文件中加载上下文定义 无论是从文件系统中装配应用上下文还是从类路径下装配应用上下文，将bean加载到bean工厂的过程都是相似的。 加载一个FileSystemXmlApplicationContext: 在文件系统的路径下查找knight.xml 12ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml"); 也可以使用ClassPathXmlApplicationContext: 所有的类路径下查找knight.xml12ApplicationContext context = new ClassPathXmlApplicationCOntext("knight.xml"); 也可以从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext 12ApplicationContext context = new AnonotationConfigApplicationContext( com.guo.knights.config.KnightConfig.class); 应用上下文准备就绪之后，我们就可以调用上下文的getBean()方法从Spring容器中获取bean。 1.2.2 bean的生命周期在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后bean就可以使用了。一旦bean不再使用，则由JCM自动进行垃圾回收。 相比之下，Spring容器中的bean声明周期就显得复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。 在bean工厂执行力若干启动步骤； 1、Spring对bean进行实例化 2、Spring将值和 bean的引用注入到bean对应的属性中。 3、如果bean实现类beanNameAware接口，Spring将bean的ID传给setBean-Name()方法 4、如果bean实现类BeanFactoryAware接口，Spirng将调用setBeanFatory()方法，将BeanFactory容器实例传入。 5、如果bean实现类applicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传递进来。 6、如果bean实现类BeanPostProcessor接口，Spring将调用它们的postProcessBeforInitialization()方法 7、如果bean实现类InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法，如果类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用。 8、如果bean实现类BeanPostProcessor接口，Spring将调用它们的PostProcessAfterInitialization()方法 9、此时，bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁。 10、如果bean实现类DisPosableBean接口，Spring将调用他的destroy()接口方法。同样，如果bean使用destroy-mothod声明销毁方法，该方法也会被调用。 1.3俯瞰Spring风景线Spring实际上的功能超乎你的想象 1.3.1 Spring模块这些模块依据其所属的功能划分为6类不同的功能，总而言之，这些模块为开发企业及应用提供了所需的一切 。但是你也不必将应用建立在整个Spring框架上，你可以自由的选择合适自身应用需求的Spring模块：当Spring不能满足需求时，完全可以考虑其他选择，事实上，Spring甚至提供了与其他的第三方框架和类库的集成点,这样你就不需要自己编写代码了。 Spring核心容器 容器是Spring最核心的部分，它管理者Spring应用中bean的创建、配置、管理。在该模块中，包括了Spring bean工厂，它为Spring提供了DI的功能，甚至bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。 所有的Spring模块都构建于核心容器之上。当你配置应用时，其实你隐式的使用率这些类。 SpringAOP模块在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦，借助于AOP，可以将遍布系统的应用的关注点(例如：事务，安全，日志)从它们所应用的对象中解耦出来。 数据访问与集成 使用JDBC编写代码通常会导致大量的样式代码，Spring的JDBC和DAO模块抽象类这些样板代码，是我们的数据库代码变得简单明了。还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，以后我们再也不需要解释那些隐晦专有的SQL信息了。 Spring提供了ORM模块，Spring的ORM模块建立在DAO的支持之上，并为多个ORM框架提供了一种构建DAO的简便方式 。Spring没有尝试去创建自己的ORM解决方，而是对许多流行的ORM框架进行了集成。包括Hibernater、Java Persisternce API、Java Data Object 和mybatis。Spring的事务管理支持所有的ORM框架以及JDBC。 Web与远程调用MVC(Model-View-Controller)模块是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离，Java从来不缺少MVC框架，Apache的struts2、JSF、WebWorks都是可选的最流行的MVC框架。Spring远程调用功能集成了RMI(Remote mehtod Invocation)、Hessian、CXF。Spring还提供了暴露和使用RESTAPI的良好支持。 InstrumentationSpring的Instrumentation模块提供了为JVM添加代理(agent)的功能.具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件时被类加载器加载的一样。 Testing通过该模块，你会发现Spring为JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象事项，对于继承测试，该模块为加载Spring应用上下文中的bean集合以及与Spirng上下文中的bean进行交互提供了支持。 1.3.2 Spring Portfolio如果仅仅停留在和性的Spring框架层面，我们将错过Spring Portlio所提供的巨额财富。整个Spirng Portlio包括多个构建与核心Spring框架之上的框架和类库。概括的来讲，整个Spring Portlio几乎为每一个领域的Java开发都提供了Spring编程模型 Spring Web Flow:是建立与Spring MVC框架之上，它为基于流程的会话式Web应用(购物车、向导功能)提供了支持。 Spirng Security:安全度与许多应用都是一个非常关键的切面。利用SpringAOP，SpringSecurity为Spring应用提供了声明式的安全机制。 Spring Data：使得在Spring中使用任何数据库都变得非常容易。一种新的数据库种类，通常被称为NoSQL数据库，提供了使用数据的新方法，为所中数据库提供了一种自动化的Repository机制，它负责为你创建Repository的实现 Spring Boot： Spring极大的简化了众多编程的任务，减少甚至消除了很多样板式代码。Spring Boot大量依赖于自动配置技术，它能够消除大部分Spring配置。还提供了多个Starter项目，不管你是用Maven还是Gradle，这都能减少Spring的工程构建文件的大小。 1.4 Spring的新功能1.4.1 Spring3.1新特性Spring 3.1带来了多项有用的新特性 和增强，其中有很多都是关于如何简化个改善配置的。除此之外，Spring3.1还提供了声明式缓存的支持以及众多针对SpringMVC的的功能增强。 借助于profile，就能根据应用布置在什么环境之中选择不同的数据源 基于Java配置，Spring3.1增加了多个enable注解，启用Spring特定功能 对声明式缓存的支持，能够 使用简单的注解声明缓存的边界和规则， 开始支持Servlet3.0，包括在基于Java的配置中 申明Servlet和Filter，而不再借助于web.xml 1.4.2 Spring 3.2新特性Spring 3.2主要关注Spring MVC的一个发布版本。 Spring MVC 3.2带来如下的功能提升 控制器(Controller)可以使Servlet3.0异步请求，允许在一个独立的线程中处理请求，从而就爱那个Servlet线程解放出来处理更多的请求 @Autowired、@Value、@Bean注解能够作为元注解。用于创建自定义的注解和bean的申明注解 Spring的声明式缓存提供了对JCache0.5的支持。 1.4.3 Spring 4.0新特性 Spring提供了对WebSocket编程的支持， 新的消息模块， 支持Java8的新特性，比如：Lambda，函数式， 为 Groovy开发的应用程序提供了更加顺畅的编程体验 添加了条件化创建bean的功能 Spring4.0包含了Spring RestTemplate的一个新的异步实现。它会立即返回并且允许在操作完成后执行回调 添加了对多项JEE规范的支持，包括JMS 2.0 、JTA1.2 JPA 2.1 1.4.4 Spring 5.0新特性 在Spring Framework代码中使用JDK 8特性 响应式编程是Spring Framework 5.0最重要的功能之一 除了响应式特性之外，Spring 5还提供了一个函数式Web框架。 Spring Framework 5.0 引入了对 JetBrains Kotlin 语言的支持。 1.5 小节Spring致力于简化企业级开发Java开发、促进代码的松耦合。成功的关键在于依赖注入和AOP。 DI是组装应用对象的一种方式，借助于这种方式对象无需知道依赖来自于何处或者依赖的具体实现方式。不同于自己获取依赖对象，对象会在运行期赋予它们所依赖的对象。依赖对象通常会通过接口了解所注入的对象，这样的话就能确保低耦合。 除了DI，还简单介绍了Spring对AOP的支持，AOP可以帮助应用将散落在各处的逻辑汇集于一处——切面。当Spring装配bean的时候，这些切面能够运行期编织起来，这样就能呢个非常有效的赋予bean新功能。 依赖注入和AOP是Spring框架最核心的部分，只有理解了如何应用Spring是最关键的功能。你才有能力使用Spring框架的其他功能。 参考：https://juejin.im/post/5a8bef5c6fb9a06350151fa3]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《重构》阅读笔记 - 代码的坏味道]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-1%2F</url>
    <content type="text"><![CDATA[重复代码（Duplicated Code）如果你在一个以上的地方看到相同的程序结构，那么可以肯定：设法将它们合而为一，程序会变得更美好！你需要决定这个重复的代码放在哪里比较合适，并确保它被安置之后就不会在别的地方再次出现。 过长函数（Long Method）程序越长越难以理解。现代 OO 语言几乎完全免去了进程内的函数调用开销，因此，你应该积极地分解函数。我们应该遵循原则：每当需要以注释来说明点什么的时候，我们就需要把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。如何确定需要提炼哪一段代码：寻找注释、条件表达式、循环。 过大的类（Large Class）如果你发现一个类试图做太多事情，其内部就会出现很多不相关的实例变量，此时这个类的职责就不明确了。 过长参数列（Long Parameter List）太长的参数队列难以理解，太多参数的接口对于使用者来说十分不友好，而且容易出错。如果可以使用一个对象代替参数列表，那么就应该这么做。 发散式变化（Divergent Change） VS 霰弹式修改（Shotgun Surgery）一旦需要修改，我们希望只在系统的一个地方进行修改，否则，就属于两种非常相似的坏味道的一种：如果某个类经常因为不同的原因在不同的地方发生变化，那么 Divergent Change 就出现了；如果系统每遇到一个小变化，就需要在多个不同的类内进行许多小修改，这属于 Shotgun Surgery。Divergent Change 是指 “一个类受多种变化的影响”，Shotgun Surgery 则指的是 “一种变化引发多个类的修改”。 平行继承体系（Parallel Inheritance Hierarchies）这其实是 Shotgun Surgery 的特殊情况——每当你为某个类添加一个子类，你也必须为它的兄弟类加一个子类。如果你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，就属于这种情况。 依恋情结（Feature Envy）面向对象的精髓在于：“将数据和对数据的操作行为包装在一起”。有一种气味是：函数对某个类的兴趣高过自己所处的类的兴趣。有很多时候，我们看到一个函数为了计算某个值，从另一个对象那儿调用了几乎半打的取值函数。最根本的原则是：将总是一起变化的东西放在一起。 数据泥团（Data Clumps）你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些绑在一起出现的数据真应该拥有属于它们自己的对象。减少字段和参数的个数，当然可以去除一些坏味道，但更重要的是：一旦拥有新对象，你就有机会寻找 Feature Envy，这可以帮你指出能够移至新类中的种种方法。 基本类型偏执（Primitive Obsession）对象技术的新手通常不愿意在小任务上运用对象——例如结合数值和币种的 Money 类、由一个起始值和一个结束值构成的 Range 类、电话号码或邮政号码等的特殊字符串。 switch 语句（Switch Statements）从本质上讲，switch 语句的问题在于重复，面向对象的多态特性可以优雅地解决这个问题。如果你只是在单一函数内有些选择事例，那么用多态就属于杀鸡用牛刀了，这种情况下 Replace Parameter with Explicit Methods 是个不错的选择，如果你的选择之一是 null，记得使用 Introduce Null Object。 多余的类（Lazy Class）你所创建的每一个类，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个类的所得不值得其身价，就应该消除这个类。 过度设计（Speculative Generality）当有人说 “噢，我想我们有一天需要做这个事情”，并因此而企图以各种各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。软件设计不可过度设计，否则会使得系统难以理解和维护。 令人迷惑的暂时字段（Temporary Field）有时你会看到这样的现象：类内的某个实例变量仅为某种特定情况而设。这样的代码不易理解，因为通常认为对象在所有时候都需要它的所有变量。 过度耦合的消息链（Message Chains）如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象…… 这就是消息链。实际代码中你看到的可能是一长串 getXXX() 调用，意味着客户代码将与查找目标对象过程中的导航结构紧密耦合，一旦对象间的关系发生任何变化，客户端就会受到影响。 中间人（Middle Man）对象的基本特征之一是封装——对外部世界隐藏其内部细节。封装往往伴随着委托，比如你问主管是否有时间参加一个会议，他就把这个消息 “委托” 给他的记事簿，然后才能回答你——你没有必要这位主管到底是使用传统记事簿或电子记事簿或秘书来记录自己的约会。但是，不要过度使用委托——你也许会看到某个类有一半接口都委托给其他类。 狎昵关系（Inappropriate Intimacy）类与类之间过分紧密的关系必须拆散——可以引入第三方类或者利用委托。 异曲同工的类（Alternative Classes with Different Interfaces）如果两个函数做同一件事，却有着不同的签名，请运用 Rename Method 根据它们的用途重新命名。但这往往不够，请反复运用 Move Method 将某些行为移入类，知道这两个函数的协议一致为止。如果你必须移动大量代码才可以完成这个工作，那还不如直接构建一个父类。 不完美的库类（Incomplete Library Class）复用常常被认为是面向对象技术的终极目标。很多第三方库提供的接口经常不能恰如其分得满足我们的需求，这时候就需要对第三方接口做一层转换，或者给它添加一定的行为。 数据类（Data Class）所谓 Data Class，指的是：这种类拥有一些字段，以及用于访问（读、写）的函数，除此之外啥都没有。这样的类只是一种不会说话的数据容器，它们一定被其他类过分细碎得控制着。Data Class 就像小孩子，作为一个起点很好，但若要让它们像成熟的对象那样参与整个系统的工作，它们就必须承担一定责任。但是，在 Spring 框架开发中，我们经常需要定义很多 domain 对象。 被拒绝的遗嘱（Refused Request）子类应该继承超类的函数和数据，但如果它们不想或者不需要继承，又该怎么办呢？按照传统说法，这就意味着继承体系的设计错误。你需要为这个子类新建一个兄弟类，然后让父类只包括两个子类共享的部分。一般而言，这就足够了，但是如果子类不愿意支持超类提供的接口，则说明不能使用继承处理，应该使用委托。 过多的注释（Comments）常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。当你需要些注释时，要先尝试重构下代码，争取让代码拥有自说明性。 参考：https://www.jianshu.com/p/41e889181536?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[instanceof 运算符用法]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14-1%2F</url>
    <content type="text"><![CDATA[运算符是双目运算符, 左面的操作元是一个对象, 右面是一个类. 当 左面的对象是右面的类创建的对象时, 该运算符运算的结果是 true, 否则是 false 例如 a instanceof A如果 a 是类 A 的实例，就返回 true，否则的话，就返回 false。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455interface A&#123; &#125; class B implements A&#123; &#125; class C extends B&#123; &#125; public class Iinstanceof &#123; public static void main(String[] args) &#123; A ab=new B(); A ac=new C(); B bc=new C(); B bb=new B(); C cc=new C(); //对象实现一个接口，用这个对象和这个接口进行instanceof判断，都为true。 System.out.println(&quot;ab instanceof A=&quot;+(ab instanceof A)); System.out.println(&quot;ac instanceof A=&quot;+(ac instanceof A)); System.out.println(&quot;bc instanceof A=&quot;+(bc instanceof A)); System.out.println(&quot;bb instanceof A=&quot;+(bb instanceof A)); System.out.println(&quot;cc instanceof A=&quot;+(cc instanceof A)); //对象和父类进行instanceof判断，都为true System.out.println(&quot;ab instanceof B=&quot;+(ab instanceof B)); System.out.println(&quot;ac instanceof B=&quot;+(ac instanceof B)); System.out.println(&quot;bc instanceof B=&quot;+(bc instanceof B)); System.out.println(&quot;bb instanceof B=&quot;+(bb instanceof B)); System.out.println(&quot;cc instanceof B=&quot;+(cc instanceof B)); //对象和他的子类进行instanceof判断为false System.out.println(&quot;ab instanceof C=&quot;+(ab instanceof C)); System.out.println(&quot;ac instanceof C=&quot;+(ac instanceof C)); System.out.println(&quot;bc instanceof C=&quot;+(bc instanceof C)); System.out.println(&quot;bb instanceof C=&quot;+(bb instanceof C)); System.out.println(&quot;cc instanceof C=&quot;+(cc instanceof C)); &#125; &#125; [java] view plain copy//程序输出： ab instanceof A=true ac instanceof A=true bc instanceof A=true bb instanceof A=true cc instanceof A=true ab instanceof B=true ac instanceof B=true bc instanceof B=true bb instanceof B=true cc instanceof B=true ab instanceof C=false ac instanceof C=true bc instanceof C=true bb instanceof C=false cc instanceof C=true 参考：http://blog.csdn.net/cnmilan/article/details/41696093http://blog.csdn.net/cntanghai/article/details/6096976https://zhidao.baidu.com/question/1175062948955268939.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析Java对象的hashCode和hashCode在HashMap的底层数据结构的应用]]></title>
    <url>%2F2018%2F03%2F14%2F2018-03-14%2F</url>
    <content type="text"><![CDATA[一、java对象的比较 等号(==)： 对比对象实例的内存地址（也即对象实例的ID），来判断是否是同一对象实例；又可以说是判断对象实例是否物理相等； equals()： 对比两个对象实例是否相等。 当对象所属的类没有重写根类Object的equals()方法时，equals()判断的是对象实例的ID（内存地址），是否是同一对象实例；该方法就是使用的等号(==)的判断结果，如Object类的源代码所示： Java代码 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 当对象所属的类重写equals()方法（可能因为需要自己特有的“逻辑相等”概念)时，equals()判断的根据就因具体实现而异，有些类是需要比较对象的某些值或内容，如String类重写equals()来判断字符串的值是否相等。判断逻辑相等。 hashCode(): 计算出对象实例的哈希码，并返回哈希码，又称为散列函数。根类Object的hashCode()方法的计算依赖于对象实例的D（内存地址），故每个Object对象的hashCode都是唯一的；当然，当对象所对应的类重写了hashCode()方法时，结果就截然不同了。 二、Java的类为什么需要hashCode？—hashCode的作用，从Java中的集合的角度看。 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是 Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。哈希算法也称为散列算法，当集合要添加新的元素时，将对象通过哈希算法计算得到哈希值（正整数），然后**将哈希值和集合（数组）长度进行&amp;运算**，得到该对象在该数组存放的位置索引。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就表示发生冲突了，散列表对于冲突有具体的解决办法，但最终还会将新元素保存在适当的位置。 这样一来，实际调用equals方法比较的次数就大大降低了，几乎只需要一两次。 简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！ 三、Java 对象的equal方法和hashCode方法的关系 首先，Java对象相同指的是两个对象通过eqauls方法判断的结果为true Java对象的eqauls方法和hashCode方法是这样规定的： 1、相等**（相同）**的对象必须具有相等的哈希码（或者散列码）。 2、如果两个对象的hashCode相同，它们并不一定相同。 以下是Object对象API关于equal方法和hashCode方法的说明： If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.（如果两个对象根据equals（object）方法相等，则对这两个对象中的每个对象调用hashcode方法必须产生相同的整数结果。） It is not required that if two objects are unequal according to the equals(java.lang.Object)) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.（如果两个对象根据equals（java.lang.object）方法不相等，则不要求在两个对象中的每一个上调用hashcode方法都必须产生不同的整数结果。但是，程序员应该意识到，为不等对象生成不同的整数结果可能会提高散列表的性能。） 以上API说明是对之前2点的官方详细说明 关于第一点，相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？ 想象一下，假如两个Java对象A和B，A和B相等（eqauls结果为true），但A和B的哈希码不同，则A和B存入HashMap时的哈希码计算得到的HashMap内部数组位置索引可能不同，那么A和B很有可能允许同时存入HashMap，显然相等/相同的元素是不允许同时存入HashMap，HashMap不允许存放重复元素。 关于第二点，两个对象的hashCode相同，它们并不一定相同 也就是说，不同对象的hashCode可能相同；假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突。 四、深入解析HashMap类的底层数据结构 Map接口 Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。 Hashtable类 Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。 Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”： Hashtable numbers = new Hashtable(); numbers.put(“one”, new Integer(1)); numbers.put(“two”, new Integer(2)); numbers.put(“three”, new Integer(3)); 要取出一个数，比如2，用相应的key： Integer n = (Integer)numbers.get(“two”); System.out.println(“two = ” + n); 1. HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 2. HashMap的数据结构：HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。首先，HashMap类的属性中定义了Entry类型的数组。Entry类实现java.ultil.Map.Entry接口，同时每一对key和value是作为Entry类的属性被包装在Entry的类中。 如图所示，HashMap的数据结构： HashMap的部分源码如下： Java代码 123456789101112131415/** * The table, resized as necessary. Length MUST Always be a power of two. * 长度必须是2的n次方 */transient Entry[] table; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; ……&#125; 可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。table数组的元素是Entry类型的。每个 Entry元素其实就是一个key-value对，并且它持有一个指向下一个 Entry元素的引用，这就说明table数组的每个Entry元素同时也作为某个Entry链表的首节点，指向了该链表的下一个Entry元素，这就是所谓的“链表散列”数据结构，即数组和链表的结合体。 3. HashMap的存取实现： 1) 添加元素： 当我们往HashMap中put元素的时候，先根据key的重新计算元素的hashCode，根据hashCode得到这个元素在table数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 HashMap的部分源码如下： Java代码 123456789101112131415161718192021222324252627 public V put(K key, V value) &#123; // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 如果发现 i 索引处的链表的某个Entry的hash和新Entry的hash相等且两者的key相同，则新Entry覆盖旧Entry，返回。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null;&#125; 2) 读取元素： 有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 HashMap的部分源码如下： 12345678910111213public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; 3) 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。 五、**实现**相等的对象必须具有相等的哈希码 如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。 同时复写equals方法和hashCode方法,必须保证“相等的对象必须具有相等的哈希码”，也就是当两个对象通过equals()比较的结果为true时，这两个对象调用hashCode（）方法生成的哈希码必须相等。 如何保证相等，可以参考下面的方法： 复写equals方法和hashCode方法时，equals方法的判断根据和计算hashCode的依据相同。如String的equals方法是比较字符串每个字符，String的hashCode也是通过对该字符串每个字符的ASC码简单的算术运算所得，这样就可以保证相同的字符串的hashCode相同且equals()为真。 String类的equals方法的源代码： Java代码 123456789101112131415161718192021222324252627282930313233343536/** * Compares this string to the specified object. The result is &#123;@code * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code * String&#125; object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the given object represents a &#123;@code String&#125; * equivalent to this string, &#123;@code false&#125; otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125;return false;&#125; Sring类的hashCode方法计算hashCode的源代码： 123456789101112131415161718192021222324252627 /** * Returns a hash code for this string. The hash code for a * &lt;code&gt;String&lt;/code&gt; object is computed as * &lt;blockquote&gt;&lt;pre&gt; * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * &lt;/pre&gt;&lt;/blockquote&gt; * using &lt;code&gt;int&lt;/code&gt; arithmetic, where &lt;code&gt;s[i]&lt;/code&gt; is the * &lt;i&gt;i&lt;/i&gt;th character of the string, &lt;code&gt;n&lt;/code&gt; is the length of * the string, and &lt;code&gt;^&lt;/code&gt; indicates exponentiation. * (The hash value of the empty string is zero.) * * @return a hash code value for this object. */ public int hashCode() &#123;int h = hash; int len = count;if (h == 0 &amp;&amp; len &gt; 0) &#123; int off = offset; char val[] = value; for (int i = 0; i &lt; len; i++) &#123; h = 31*h + val[off++]; &#125; hash = h; &#125; return h; &#125; 参考：http://kakajw.iteye.com/blog/935226]]></content>
      <tags>
        <tag>hashCode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机 知识点总结&面试题]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-1%2F</url>
    <content type="text"><![CDATA[1. 内存模型以及分区，需要详细到每个区放什么。 运行时数据区域：虚拟机栈，本地方法栈，程序计数器，堆，方法区，具体如图所示： 2.2.1 程序计数器（Program Counter Register） 概述：当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有2.无内存溢出：此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 概述：每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆的唯一目的就是存储对象的实例。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。 Eden 区的对象都是朝生夕死，发生 minor gc 的时候会清除 eden 区和 survival 区的，把存活的对象移到另一个 Survival 区，该 survial 区由老年代保证。当在年轻代中对象经过多次 minor gc 以后还存活，达到老年代的年纪，就会移动到老年代，还有就是大对象在年轻代无法存储，直接转到老年代，还有可能因为担保而进入老年代的 3. 对象创建方法，对象的内存分配，对象的访问定位 1 对象的创建包括三步骤： ①当遇到 new 命令的时候，会在常量池中检查该对象的符号引用是否存在，不存在则进行类的加载，否则执行下一步 ②分配内存，将将要分配的内存都清零。 ③虚拟机进行必要的设置，如设置 hashcode，gc 的分代年龄等，此时会执行命令在执行之前所有的字段都为 0，执行指令以后，按照程序顺序进行初始化字段。 2：对象的内存分配：包括对象头，实例数据，对齐填充 ①对象头: 包括对象的 hascode，gc 分代年龄，锁状态标等。 ②实例数据: 也就是初始化以后的对象的字段的内容，包括父类中的字段等 ③对齐填充：对象的地址是 8 字节，虚拟机要求对象的大小是对象的整数倍 (1 倍或者两倍)。因此就会有空白区。 3：对象的访问： hotspot 中 是采用对象直接指向对象地址的方式（这样的方式访问比较快）（还有一种方式就是句柄，也就是建一张表维护各个指向各个地址的指针，然后给指针设置一个句柄 （别名），然后引用直接指向这个别名，就可以获得该对象，这种的优势就是，实例对象地址改变了，只要修改句柄池中的指针就可以了，而不用引用本身不会发生改变）。 4.GC 的两种判别方法：引用计数与引用链 引用计数 给一个对象设置一个计数器，当被引用一次就加 1，当引用失效的时候就减 1，如果该对象长时间保持为 0 值，则该对象将被标记为回收。优点：算法简单，效率高，缺点：很难解决对象之间的相互循环引用问题。 引用链： 现在主流的 gc 都采用可达性分析算法来判断对象是否已经死亡。可达性分析：通过一系列成为 GC Roots 的对象作为起点，从这些起点向下搜索，搜索所走过的路径成为引用链，当一个对象到引用链没有相连时，则判断该对象已经死亡。 可作为 gc roots 的对象： 虚拟机栈（本地方法表）中引用的对象（因为在栈内，被线程引用），方法区中类静态属性引用的对象，方法区中常量引用的（常量存放在常量池中，常量池是方法区的一部分）对象，native 方法引用的对象 引用计数和引用链是只是用来标记，判断一个对象是否失效，而不是用来清除 5.GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？3.3.1 标记 - 清除算法 (Mark-Sweep) 最基础的收集算法。其它算法都是基于这种思路并对其不足进行改进而得到的。 标记 - 清除算法将垃圾回收分为两个阶段： ①. 标记阶段：首先标记出所有需要回收的对象。 如何标记，在上面的 “判断对象是否存活” 里有讲过 ②. 清除阶段：标记完成后，统一回收被标记的对象缺点： ①. 效率问题：标记清除过程效率都不高。 ②. 空间问题：标记清除之后会产生大量的不连续的内存碎片 (空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。） 3.3.2 复制算法 (Copying)为了解决 mark-sweep 算法的效率问题 算法思想： 1). 将现有的内存空间分为两块，每次只使用其中一块. 2). 当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。 3). 再把已使用过的内存空间一次清理掉。 优点： 1). 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 2). 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 2.3 缺点： 1). 内存减少为原来的一半，太浪费了。 2). 对象存活率较高的时候就要执行较多的复制操作，效率变低。 3). 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。2.4. 演进 并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 EdenSpace 和两块较小的 SurvivorSpace JavaHeap 内存回收模型（当前商业虚拟机大多使用此算法回收新生代） jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 3.3.3 标记 - 整理算法 (Mark-Compact) 由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 算法思想 1). 标记阶段：首先标记出所有需要回收的对象。与 “标记 - 清除” 一样 2). 让存活的对象向内存的一段移动。 3). 直接清理掉边界以外的内存。 由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记 - 清理算法或标记 - 清除算法。 3.3.4 代收集算法 (Generational Collecting) 当前的商业虚拟机的垃圾收集都采用，把 Java 堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。 优化收集方法： 优化收集方法：对复制算法的优化：并不是将两块内存分配同等大小，可以将存活率低的区域大一些，而让回收后存活的对象所占的区域小一些，不够的内存由老年代的内存来保证，这样复制算法的空闲的空间减少了。两个 survival 区域目的是为了减少风险，有一个 survivor 区要参与回收，也要参与存储，只要只有 10% 的空间浪费，同时也减少对老年代的依赖。 6.GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。 （见书上3.5） 串行的，也就是采用单线程（比较老了），分类：serial new（收集年轻代，复制算法）和 serial old（收集老年代，标记整理），缺点：单线程，进行垃圾回收时暂时所有的用户线程。优点：实现简单。 并行的，采用多线程，对于年轻代有两个： parallel new（简称 ParNew）（参考 serial new 的多线程版本）和 parallel scavenge；parallel scavenge 是一个针对年轻代的垃圾回收器，采用复制算法，主要的优点是进行垃圾回收时不会停止用户线程（不会发生 stop all world）老年代回收器也有两种：Parallel old 是 parallel scavenge 的老年代设计的。CMS（并发标记清除）采用标记清除算法，采用这种的优点就是快咯，因此会尽快的进行回收，减少停顿时间。 高级杀手：G1 收集器，年轻代和老年代通吃，最新一代的技术。面向服务器端的垃圾收集器（并行 + 并发的垃圾收集器）。 7.Minor GC 与 Full GC 分别在什么时候发生? Minor GC 发生：当 jvm 无法为新的对象分配空间的时候就会发生 minor gc，所以分配对象的频率越高，也就越容易发生 minor gc。 Full GC：发生 GC 有两种情况，①当老年代无法分配内存的时候，会导致 MinorGC,②当发生 Minor GC 的时候可能触发 Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不能清除自己要担保多少空间，因此采取采用动态估算的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次 Minor GC 以后，存活的对象剧增（假设小对象），此时老年代并没有满，但是此时平均值增加了，会造成发生 Full GC 8. 类加载的五个过程：加载、验证、准备、解析、初始化。 加载： 加载有两种情况，①当遇到 new 关键字，或者 static 关键字的时候就会发生（他们对应着对应的指令）如果在常量池中找不到对应符号引用时，就会发生加载 ，②动态加载，当用反射方法（如 class.forName(“类名”)），如果发现没有初始化，则要进行初始化。（注：加载的时候发现父类没有被加载，则要先加载父类） 验证： 这一阶段的目的是确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全（虽然编译器会严格的检查 java 代码并生成 class 文件，但是 class 文件不一定都是通过编译器编译，然后加载进来的，因为虚拟机获取 class 文件字节流的方式有可能是从网络上来的，者难免不会存在有人恶意修改而造成系统崩溃的问题，class 文件其实也可以手写 16 进制，因此这是必要的） 准备： 该阶段就是为对象分派内存空间，然后初始化类中的属性变量，但是该初始化只是按照系统的意愿进行初始化，也就是初始化时都为 0 或者为 null。因此该阶段的初始化和我们常说初始化阶段的初始化时不一样的 解析： 解析就是虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用其实就是 class 文件常量池中的各种引用，他们按照一定规律指向了对应的类名，或者字段，但是并没有在内存中分配空间，因此符号因此就理解为一个标示，而在直接引用直接指向内存中的地址 初始化： 简单讲就是执行对象的构造函数，给类的静态字段按照程序的意愿进行初始化，注意初始化的顺序。（此处的初始化由两个函数完成，一个是, 初始化所有的类变量（静态变量），该函数不会初始化父类变量，还有一个是实例初始化函数, 对类中实例对象进行初始化，此时要如果有需要，是要初始化父类的） 9. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。 类 加载器的工作过程：如果一个类加载器收到类类加载的请求，他首先不会自己去加载这个类，而是把类委派个父类加载器去完成，因此所有的请求最终都会传达到顶 层的启动类加载器中，只有父类反馈无法加载该类的请求（在自己的搜索范围类没有找到要加载的类）时候，子类才会试图去加载该类。 10. 分派：静态分派与动态分派: 静态分派和动态分派都是多态的内容，多态的实现依赖于编译阶段和运行时阶段：在编译阶段主要表现在静态分派， 静态分派就是通过静态类型和方法参数个数来选择哪一个方法版本，这就是主要体现了方法的重载；因为他在编译的时候就能确定调用哪一个函数，所以叫静态分派。 在运行时阶段体现在动态分派（动态绑定），也就是当一个父类引用指向子类对象，通过该父类引用去调用一个该方法，由于在编译阶段生产的调用函数代码的字节码指向的是父类（静态类型）被调用方法，并不知道具体要去调用哪一个实际类型的方法，因 此会发生这样一个过程，虚拟机找到操作数栈中位于栈顶获取该操作数所指向的类，然后到常量池中去搜索与被调用的方法匹配的方法名和描述符，如果找到， 就进行权限校验（校验失败就抛出异常），如果可以访问，则返回该方法的符号引用，并转换成直接引用，调用该执行，如果找不到就到父类中去找，然后重复上面 动作，最后找不到就抛出异常。 对动态绑定的优化：由于要去常量池中搜索每一类的方法名和描述符，因此效率比较低，所以最后进行了优化，就是在方法区为每一类维护一张虚方法表或者接口方法表（虚表中存放了该方法的实际入口地址），让该类的所有方法都维护进去（包括父类的方法），因此要查找方法名的时候，直接去该虚表中去搜索到该方法名对应的直接地址然后执行。对于没有被重写的方法，直接存放父类的入口地址，如果该方法被重写，在存放子类的方法入口地址。 参考:http://blog.csdn.net/qq_30000411/article/details/60334051 JDK 是什么 JRE 是什么 Java 历史版本的特性 Java Version SE 50 Java Version SE 6 Java Version SE 7 Java 8 运行时数据区域包括哪些 程序计数器线程私有 Java 虚拟机栈线程私有 本地方法栈线程私有 Java 堆线程共享 方法区线程共享 运行时常量池 Java 中对象访问是如何进行的 如何判断对象是否死去 什么是引用计数法 引用计数法的缺点 什么是根搜索算法 Java 的 4 种引用方式 强引用 软引用 弱引用 虚引用 有哪些垃圾收集算法 标记 - 清除算法 Mark-Sweep 什么是标记 - 清除算法 有什么缺点 复制算法 Copying- 新生代 优点 缺点 应用 标记 - 整理算法 Mark-Compact - 老年代 分代收集算法 Minor GC 和 Full GC 有什么区别 Java 内存 为什么要将堆内存分区 堆内存分为哪几块 分代收集算法 内存分配有哪些原则 Young Generation Space 采用复制算法 Tenure Generation Space 采用标记 - 整理算法 Permanent Space Class 文件 Java 虚拟机的平台无关性 Class 文件的组成 魔数与 Class 文件的版本 类加载器 类加载器的作用是什么 类加载器有哪些 类加载机制 什么是双亲委派模型 为什么要使用双亲委派模型组织类加载器之间的关系 什么是类加载机制 虚拟机和物理机的区别是什么 运行时栈帧结构 Java 方法调用 什么是方法调用 Java 的方法调用有什么特殊之处 Java 虚拟机调用字节码指令有哪些 虚拟机是如何执行方法里面的字节码指令的 解释执行 基于栈的指令集和基于寄存器的指令集 什么是基于栈的指令集 什么是基于寄存器的指令集 基于栈的指令集的优缺点 Javac 编译过程分为哪些步骤 什么是即时编译器 解释器和编译器 为什么要采用分层编译 分层编译器有哪些层次 编译对象与触发条件 热点代码有哪些 如何判断一段代码是不是热点代码 HotSpot 虚拟机使用第二种有两个计数器 方法调用计数器统计方法 有哪些经典的优化技术即时编译器 公共子表达式消除 数组边界检查消除 方法内联 逃逸分析 如果对象不会逃逸到方法或线程外可以做什么优化 Java 与 CC 的编译器对比 物理机如何处理并发问题 Java 内存模型 什么是 Java 内存模型 Java 内存模型的目标 主内存与工作内存 内存间的交互操作 原子性可见性有序性 volatile 什么是 volatile 为什么基于 volatile 变量的运算在并发下不一定是安全的 为什么使用 volatile 并发与线程 并发与线程的关系 什么是线程 实现线程有哪些方式 Java 线程的实现 Java 线程调度 什么是线程调度 线程调度有哪些方法 线程安全的定义 Java 语言操作的共享数据包括哪些 不可变 如何实现线程安全 阻塞同步互斥同步 非阻塞同步 锁优化是在 JDK 的那个版本 为什么要提出自旋锁 自旋锁的原理 自旋的缺点 什么是自适应自旋 锁消除 锁粗化 轻量级锁 偏向锁 JDK 是什么？JDK 是用于支持 Java 程序开发的最小环境。 Java 程序设计语言 Java 虚拟机 Java API 类库 JRE 是什么？JRE 是支持 Java 程序运行的标准环境。 Java SE API 子集 Java 虚拟机 Java 历史版本的特性？Java Version SE 5.0 引入泛型； 增强循环，可以使用迭代方式； 自动装箱与自动拆箱； 类型安全的枚举； 可变参数； 静态引入； 元数据（注解）； 引入 Instrumentation。 Java Version SE 6 支持脚本语言； 引入 JDBC 4.0 API； 引入 Java Compiler API； 可插拔注解； 增加对 Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos 和 LDAP(Lightweight Directory Access Protocol) 的支持； 继承 Web Services； 做了很多优化。 Java Version SE 7 switch 语句块中允许以字符串作为分支条件； 在创建泛型对象时应用类型推断； 在一个语句块中捕获多种异常； 支持动态语言； 支持 try-with-resources； 引入 Java NIO.2 开发包； 数值类型可以用 2 进制字符串表示，并且可以在字符串表示中添加下划线； 钻石型语法； null 值的自动处理。 Java 8 函数式接口 Lambda 表达式 接口的增强 运行时数据区域包括哪些？ 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 运行时常量池 直接内存 Java 中对象访问是如何进行的？1Object obj = new Object(); 对于上述最简单的访问，也会涉及到 Java 栈、Java 堆、方法区这三个最重要内存区域。 1Object obj 如果出现在方法体中，则上述代码会反映到 Java 栈的本地变量表中，作为 reference 类型数据出现。 1new Object() 反映到 Java 堆中，形成一块存储了 Object 类型所有对象实例数据值的内存。Java 堆中还包含对象类型数据的地址信息，这些类型数据存储在方法区中。 如何判断对象是否 “死去”？ 引用计数法 根搜索算法 什么是引用计数法？给对象添加一个引用计数器，每当有一个地方引用它，计数器就 + 1,；当引用失效时，计数器就 - 1；任何时刻计数器都为 0 的对象就是不能再被使用的。 引用计数法的缺点？很难解决对象之间的循环引用问题。 什么是根搜索算法？通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。 Java 的 4 种引用方式？在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为 强引用 Strong Reference 软引用 Soft Reference 弱引用 Weak Reference 虚引用 Phantom Reference 强引用1Object obj = new Object(); 代码中普遍存在的，像上述的引用。只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。 软引用用来描述一些还有用，但并非必须的对象。软引用所关联的对象，有在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围，并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存异常。提供了 SoftReference 类实现软引用。 弱引用描述非必须的对象，强度比软引用更弱一些，被弱引用关联的对象，只能生存到下一次垃圾收集发生前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。提供了 WeakReference 类来实现弱引用。 虚引用一个对象是否有虚引用，完全不会对其生存时间够成影响，也无法通过虚引用来取得一个对象实例。为一个对象关联虚引用的唯一目的，就是希望在这个对象被收集器回收时，收到一个系统通知。提供了 PhantomReference 类来实现虚引用。 有哪些垃圾收集算法？ 标记 - 清除算法 复制算法 标记 - 整理算法 分代收集算法 标记 - 清除算法（Mark-Sweep）什么是标记 - 清除算法？分为标记和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。 有什么缺点？1. 效率问题。标记和清除过程的效率都不高。2. 空间问题。标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致，程序分配较大对象时无法找到足够的连续内存，不得不提前出发另一次垃圾收集动作。 复制算法（Copying）- 新生代将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。 优点？复制算法使得每次都是针对其中的一块进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点？将内存缩小为原来的一半。在对象存活率较高时，需要执行较多的复制操作，效率会变低。 应用？商业的虚拟机都采用复制算法来回收新生代。因为新生代中的对象容易死亡，所以并不需要按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。每次使用 Eden 和其中的一块 Survivor。 当回收时，将 Eden 和 Survivor 中还存活的对象一次性拷贝到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。Hotspot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80% + 10%），只有 10% 的内存是会被 “浪费” 的。 标记 - 整理算法（Mark-Compact）- 老年代标记过程仍然与 “标记 - 清除” 算法一样，但不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。 分代收集算法根据对象的存活周期，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点，采用最适当的收集算法。 新生代：每次垃圾收集时会有大批对象死去，只有少量存活，所以选择复制算法，只需要少量存活对象的复制成本就可以完成收集。 老年代：对象存活率高、没有额外空间对它进行分配担保，必须使用 “标记 - 清理” 或 “标记 - 整理” 算法进行回收。 Minor GC 和 Full GC 有什么区别？Minor GC：新生代 GC，指发生在新生代的垃圾收集动作，因为 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般回收速度较快。Full GC：老年代 GC，也叫 Major GC，速度一般比 Minor GC 慢 10 倍以上。 Java 内存为什么要将堆内存分区？对于一个大型的系统，当创建的对象及方法变量比较多时，即堆内存中的对象比较多，如果逐一分析对象是否该回收，效率很低。分区是为了进行模块化管理，管理不同的对象及变量，以提高 JVM 的执行效率。 堆内存分为哪几块？ Young Generation Space 新生区（也称新生代） Tenure Generation Space 养老区（也称旧生代） Permanent Space 永久存储区 分代收集算法内存分配有哪些原则？ 对象优先分配在 Eden 大对象直接进入老年代 长期存活的对象将进入老年代 动态对象年龄判定 空间分配担保 Young Generation Space （采用复制算法）主要用来存储新创建的对象，内存较小，垃圾回收频繁。这个区又分为三个区域：一个 Eden Space 和两个 Survivor Space。 当对象在堆创建时，将进入年轻代的 Eden Space。 垃圾回收器进行垃圾回收时，扫描 Eden Space 和 A Suvivor Space，如果对象仍然存活，则复制到 B Suvivor Space，如果 B Suvivor Space 已经满，则复制 Old Gen 扫描 A Suvivor Space 时，如果对象已经经过了几次的扫描仍然存活，JVM 认为其为一个 Old 对象，则将其移到 Old Gen。 扫描完毕后，JVM 将 Eden Space 和 A Suvivor Space 清空，然后交换 A 和 B 的角色（即下次垃圾回收时会扫描 Eden Space 和 B Suvivor Space。 Tenure Generation Space（采用标记 - 整理算法）主要用来存储长时间被引用的对象。它里面存放的是经过几次在 Young Generation Space 进行扫描判断过仍存活的对象，内存较大，垃圾回收频率较小。 Permanent Space存储不变的类定义、字节码和常量等。 Class 文件Java 虚拟机的平台无关性 Class 文件的组成？Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目间没有任何分隔符。当遇到 8 位字节以上空间的数据项时，则会按照高位在前的方式分隔成若干个 8 位字节进行存储。 魔数与 Class 文件的版本每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的 Class 文件。OxCAFEBABE。 接下来是 Class 文件的版本号：第 5,6 字节是次版本号（Minor Version），第 7,8 字节是主版本号（Major Version）。 使用 JDK 1.7 编译输出 Class 文件，格式代码为： 前四个字节为魔数，次版本号是 0x0000，主版本号是 0x0033，说明本文件是可以被 1.7 及以上版本的虚拟机执行的文件。 33：JDK1.7 32：JDK1.6 31：JDK1.5 30：JDK1.4 2F：JDK1.3 类加载器类加载器的作用是什么？类加载器实现类的加载动作，同时用于确定一个类。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。即使两个类来源于同一个 Class 文件，只要加载它们的类加载器不同，这两个类就不相等。 类加载器有哪些？ 启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现（仅限于 HotSpot），是虚拟机自身的一部分。负责将存放在 \lib 目录中的类库加载到虚拟机中。其无法被 Java 程序直接引用。 扩展类加载器（Extention ClassLoader）由 ExtClassLoader 实现，负责加载 \lib\ext 目录中的所有类库，开发者可以直接使用。 应用程序类加载器（Application ClassLoader）：由 APPClassLoader 实现。负责加载用户类路径（ClassPath）上所指定的类库。 类加载机制什么是双亲委派模型？双亲委派模型（Parents Delegation Model）要求除了顶层的启动类加载器外，其余加载器都应当有自己的父类加载器。类加载器之间的父子关系，通过组合关系复用。工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有到父加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，子加载器才会尝试自己去加载。 为什么要使用双亲委派模型，组织类加载器之间的关系？Java 类随着它的类加载器一起具备了一种带优先级的层次关系。比如 java.lang.Object，它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此 Object 类在程序的各个类加载器环境中，都是同一个类。 如果没有使用双亲委派模型，让各个类加载器自己去加载，那么 Java 类型体系中最基础的行为也得不到保障，应用程序会变得一片混乱。 什么是类加载机制？Class 文件描述的各种信息，都需要加载到虚拟机后才能运行。虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 虚拟机和物理机的区别是什么？这两种机器都有代码执行的能力，但是： 物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面的。 虚拟机的执行引擎是自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。 运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构， 存储了方法的 局部变量表 操作数栈 动态连接 方法返回地址 每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 Java 方法调用什么是方法调用？方法调用唯一的任务是确定被调用方法的版本（调用哪个方法），暂时还不涉及方法内部的具体运行过程。 Java 的方法调用，有什么特殊之处？Class 文件的编译过程不包含传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这使得 Java 有强大的动态扩展能力，但使 Java 方法的调用过程变得相对复杂，需要在类加载期间甚至到运行时才能确定目标方法的直接引用。 Java 虚拟机调用字节码指令有哪些？ invokestatic：调用静态方法 invokespecial：调用实例构造器方法、私有方法和父类方法 invokevirtual：调用所有的虚方法 invokeinterface：调用接口方法 虚拟机是如何执行方法里面的字节码指令的？解释执行（通过解释器执行）编译执行（通过即时编译器产生本地代码） 解释执行当主流的虚拟机中都包含了即时编译器后，Class 文件中的代码到底会被解释执行还是编译执行，只有虚拟机自己才能准确判断。 Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译是半独立的实现。 基于栈的指令集和基于寄存器的指令集什么是基于栈的指令集？Java 编译器输出的指令流，里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。 计算 “1+1=2”，基于栈的指令集是这样的： 1234iconst_1iconst_1iaddistore_0 两条 iconst_1 指令连续地把两个常量 1 压入栈中，iadd 指令把栈顶的两个值出栈相加，把结果放回栈顶，最后 istore_0 把栈顶的值放到局部变量表的第 0 个 Slot 中。 什么是基于寄存器的指令集？最典型的是 x86 的地址指令集，依赖寄存器工作。计算 “1+1=2”，基于寄存器的指令集是这样的： 12mov eax, 1add eax, 1 mov 指令把 EAX 寄存器的值设为 1，然后 add 指令再把这个值加 1，结果就保存在 EAX 寄存器里。 基于栈的指令集的优缺点？优点： 可移植性好：用户程序不会直接用到这些寄存器，由虚拟机自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存）放到寄存器以获取更好的性能。 代码相对紧凑：字节码中每个字节就对应一条指令 编译器实现简单：不需要考虑空间分配问题，所需空间都在栈上操作 缺点： 执行速度稍慢 完成相同功能所需的指令数多 频繁的访问栈，意味着频繁的访问内存，相对于处理器，内存才是执行速度的瓶颈。 Javac 编译过程分为哪些步骤？ 解析与填充符号表 插入式注解处理器的注解处理 分析与字节码生成 什么是即时编译器？Java 程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为 “热点代码”（Hot Spot Code）。 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器成为即时编译器（Just In Time Compiler，JIT 编译器）。 解释器和编译器许多主流的商用虚拟机，都同时包含解释器和编译器。 当程序需要快速启动和执行时，解释器首先发挥作用，省去编译的时间，立即执行。 当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，可以提高执行效率。 如果内存资源限制较大（部分嵌入式系统），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时编译器的代码还能退回成解释器的代码。 为什么要采用分层编译？因为即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间越长。 分层编译器有哪些层次？分层编译根据编译器编译、优化的规模和耗时，划分不同的编译层次，包括： 第 0 层：程序解释执行，解释器不开启性能监控功能，可出发第 1 层编译。 第 1 层：也成为 C1 编译，将字节码编译为本地代码，进行简单可靠的优化，如有必要加入性能监控的逻辑。 第 2 层：也成为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 用 Client Compiler 和 Server Compiler 将会同时工作。用 Client Compiler 获取更高的编译速度，用 Server Compiler 获取更好的编译质量。 编译对象与触发条件热点代码有哪些？ 被多次调用的方法 被多次执行的循环体 如何判断一段代码是不是热点代码？要知道一段代码是不是热点代码，是不是需要触发即时编译，这个行为称为热点探测。主要有两种方法： 基于采样的热点探测，虚拟机周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是 “热点方法”。实现简单高效，但是很难精确确认一个方法的热度。 基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认为它是热点方法。 HotSpot 虚拟机使用第二种，有两个计数器： 方法调用计数器 回边计数器（判断循环代码） 方法调用计数器统计方法统计的是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器的热度衰减，这个时间就被称为半衰周期。 有哪些经典的优化技术（即时编译器）？ 语言无关的经典优化技术之一：公共子表达式消除 语言相关的经典优化技术之一：数组范围检查消除 最重要的优化技术之一：方法内联 最前沿的优化技术之一：逃逸分析 公共子表达式消除普遍应用于各种编译器的经典优化技术，它的含义是： 如果一个表达式E已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。没有必要重新计算，直接用结果代替E就可以了。 数组边界检查消除因为 Java 会自动检查数组越界，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑是一种性能负担。 如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组区间内，那么整个循环中就可以把数组的上下界检查消除掉，可以节省很多次的条件判断操作。 方法内联内联消除了方法调用的成本，还为其他优化手段建立良好的基础。 编译器在进行内联时，如果是非虚方法，那么直接内联。如果遇到虚方法，则会查询当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那么也可以内联，不过这种内联属于激进优化，需要预留一个逃生门（Guard 条件不成立时的 Slow Path），称为守护内联。 如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者的继承关系发现变化的类，那么内联优化的代码可以一直使用。否则需要抛弃掉已经编译的代码，退回到解释状态执行，或者重新进行编译。 逃逸分析逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法里面被定义后，它可能被外部方法所引用，这种行为被称为方法逃逸。被外部线程访问到，被称为线程逃逸。 如果对象不会逃逸到方法或线程外，可以做什么优化？ 栈上分配：一般对象都是分配在 Java 堆中的，对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。但是垃圾回收和整理都会耗时，如果一个对象不会逃逸出方法，可以让这个对象在栈上分配内存，对象所占用的内存空间就可以随着栈帧出栈而销毁。如果能使用栈上分配，那大量的对象会随着方法的结束而自动销毁，垃圾回收的压力会小很多。 同步消除：线程同步本身就是很耗时的过程。如果逃逸分析能确定一个变量不会逃逸出线程，那这个变量的读写肯定就不会有竞争，同步措施就可以消除掉。 标量替换：不创建这个对象，直接创建它的若干个被这个方法使用到的成员变量来替换。 Java 与 C/C++ 的编译器对比 即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力。 Java 语言虽然没有 virtual 关键字，但是使用虚方法的频率远大于 C++，所以即时编译器进行优化时难度要远远大于 C++ 的静态优化编译器。 Java 语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，使得全局的优化难以进行，因为编译器无法看见程序的全貌，编译器不得不时刻注意并随着类型的变化，而在运行时撤销或重新进行一些优化。 Java 语言对象的内存分配是在堆上，只有方法的局部变量才能在栈上分配。C++ 的对象有多种内存分配方式。 参考：http://blog.csdn.net/yano_nankai/article/details/50957578#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95mark-compact-%E8%80%81%E5%B9%B4%E4%BB%A3 待阅读：http://blog.csdn.net/maydaysar/article/details/56839617https://my.oschina.net/lock0818/blog/1502746https://www.jianshu.com/p/54eb60cfa7bdhttp://www.bijishequ.com/detail/397600?p=https://juejin.im/post/5a72d8136fb9a01cb9133c39https://github.com/devnan/java-studyhttp://www.importnew.com/23792.htmlhttp://blog.csdn.net/hipilee/article/details/78487848http://blog.csdn.net/hsk256/article/details/49104955 GC(垃圾处理机制)面试题: http://blog.csdn.net/nysyxxg/article/details/8789358http://blog.csdn.net/alwaystiys/article/details/22279181http://blog.csdn.net/nysyxxg/article/details/8789358 印象笔记中关于jvm的总结：待整理]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据分析准备：专题/竞赛/教学]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12%2F</url>
    <content type="text"><![CDATA[「需输入密码」 Decrypt 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]]></content>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之十二&十三]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-7%2F</url>
    <content type="text"><![CDATA[第五部分 高效并发第十二章 Java 内存模型与线程并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类 “压榨” 计算机运算能力的最有力武器。 12.1 概述 多任务处理在现代计算机操作系统中几乎已是一项必备的功能了； 除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景； 服务端是 Java 语言最擅长的领域之一，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持，幸好 Java 语言和虚拟机提供了许多工具，把并发编码的门槛降低了不少； 12.2 硬件的效率与一致性 绝大多数的运算任务不可能只靠处理器计算就能完成，处理器至少要与内存交互，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了； 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性；为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI、MOSI、Synapse、Firefly 及 Dragon Protocol 等； 本章将会多次提到内存模型一词，可以理解在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；不同架构的物理机器可以拥有不一样的内存模型，而 Java 虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问具有很高的可比性； 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的； 12.3 Java 内存模型Java 虚拟机规范中视图定义一种 Java 内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 12.3.1 主内存与工作内存 Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节；此处的变量与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享； Java 内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量； 这里所讲的主内存、工作内存与第二章所讲的 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的；线程、主内存和工作内存的关系如下所示： 12.3.2 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下八种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量的某些操作在某些平台允许有例外）： lock unlock read load use assign store write 基于理解难度和严谨性考虑，最新的 JSR-133 文档中，已经放弃采用这八种操作去定义 Java 内存模型的访问协议了，后面将会介绍一个等效判断原则 – 先行发生原则，用来确定一个访问在并发环境下是否安全； 12.3.3 对于 volatile 型变量的特殊规则 关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制； 当一个变量定义为 volatile 之后，它将具备两种特性：第一是保证此变量对所有线程的可见性，这里的可见性是指当一个线程修改了这个变量的值，新的值对于其他线程来说是可以立即得知的，而普通的变量的值在线程间传递均需要通过主内存来完成；另外一个是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致； volatile 变量在各个线程的工作内存中不存在一致性问题，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的； 在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：运算结果并不依赖变量的当前值或者能够确保只有单一的线程修改变量的值、变量不需要与其他的状态变量共同参与不变约束； volatile 变量读操作的性能消耗与普通变量几乎没有任何差别，但是写操作则可能会慢一些；不过大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求； 12.3.4 对于 long 和 double 型变量的特殊规则 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定； 但允许虚拟机选择把这些操作实现为具有原子性的操作，目前各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待； 12.3.5 原子性、可见性与有序性 原子性（Atomicity）：由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write；在 synchronized 块之间的操作也具备原子性； 可见性（Visibility）：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了 volatile 之外，Java 还有 synchronized 和 final 关键字能实现可见性； 有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性； 12.3.6 先行发生原则 先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等； 下面是 Java 内存模型下一些天然的先行发生关系：程序次序规则、管程锁定规则、volatile 变量规则、线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性； 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准； 12.4 Java 与线程12.4.1 线程的实现 线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度； Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的； 实现线程主要有三种方式：使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）、使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）和使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险）； 对于 Sun JDK 来说，它的 Windows 版与 Linux 版都是使用一对一的线程模型实现的，一条 Java 线程就映射到一条轻量级进程之中，因为 Windows 和 Linux 系统提供的线程模式就是一对一的； 12.4.2 Java 线程调度 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（线程的执行时间由线程本身来控制）和抢占式线程调度（线程由系统来分配执行时间，线程的切换不由线程本身来决定）； Java 语言一共设置了 10 个级别的线程优先级，不过线程优先级并不是太靠谱，原因就是操作系统的线程优先级不见得总是与 Java 线程的优先级一一对应，另外优先级还可能被系统自行改变； 12.4.3 状态转换 Java 语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。它们之间相互的转换关系如下所示： 12.5 本章小结本章我们首先了解了虚拟机 Java 内存模型的结构及操作，然后讲解了原子性、可见性、有序性在 Java 内存模型中的体现，最后介绍了先行发生原则的规则及使用。另外，我们还了解了线程在 Java 语言之中是如何实现的。 在本章主要介绍了虚拟机如何实现并发，而在下一章我们主要关注点将是虚拟机如何实现高效，以及虚拟机对我们编写的并发代码提供了什么样的优化手段。 第十三章 线程安全与锁优化13.1 概述 首先需要保证并发的正确性，然后在此基础上实现高效； 13.2 线程安全Brian Goetz 对线程安全有一个比较恰当的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 13.2.1 Java 语言中的线程安全 我们可以将 Java 语言中各个操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立； 不可变：不可变带来的安全性是最简单和最纯粹的，如 final 的基本数据类型；如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如 String 类的 substring、replace 方法；Number 类型的大部分子类都符合不可变要求的类型，但是 AtomicInteger 和 AtomicLong 则并非不可变的； 线程绝对安全：Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全；比如 java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了； 线程相对安全：是我们通常意义上所讲的线程安全，在 Java 语言中，大部分的线程安全类都属于这种类型； 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况； 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java 语言中很少出现； 13.2.2 线程安全的实现方法 互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用，而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式；Java 中最基本的互斥同步手段就是 synchronized 关键字，它对同一个线程来说是可重入的且会阻塞后面其他线程的进入；另外还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步，相比 synchronized 关键字 ReentrantLock 增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件； 非阻塞同步：互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略；随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步；Java 并发包的整数原子类，其中的 compareAndSet 和 getAndIncrement 等方法都使用了 Unsafe 类的 CAS 操作； 无同步方案：要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码； 13.3 锁优化13.3.1 自旋锁与自适应自旋 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力；另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁；为了让线程等待，我们只需让线程执行一个忙循环，这些技术就是所谓的自旋锁； 在 JDK 1.6 已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源； 在 JDK 1.6 中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定； 13.3.2 锁消除 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除； 锁消除的主要判断依据来源于逃逸分析的数据支持； 13.3.3 锁粗化 原则上总是推荐将同步块的作用范围限制得尽量小 – 只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁； 但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗； 13.3.4 轻量级锁 轻量级锁是 JDK 1.6 之中加入的新型锁机制，它是相对于使用操作系统互斥量来实现的传统锁而言的；它并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗； 要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从 HotSpot 虚拟机的对象的内存布局开始介绍；HotSpot 虚拟机的对象头分为两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄等，这部分官方称之为 Mark Word，是实现轻量级锁和偏向锁的关键，另外一部分用于存储指向方法区对象类型数据的指针； Mark Word 被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，在 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0；在其他状态（轻量级锁定、重量级锁定、GC 标志、可偏向）下对象的存储内容如下： 在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的 Mark Word 的拷贝（官方称之为 Displaced Mark Word）；然后虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果更新成功了那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位将转变为 “00”，即表示此对象处于轻量级锁定状态；如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了；如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为 “10”，Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进行阻塞状态； 轻量级锁能提升程序同步性能的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据； 13.3.5 偏向锁 偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能；如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了； 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 假设当前虚拟机启动了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为 “01”，即偏向模式；同时使用 CAS 操作把获取到这个锁的线程 ID 记录在对象的 Mark Word 之中；如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如上面介绍的轻量级锁那样执行；偏向锁、轻量级锁的状态转化以及对象 Mark Work 的关系如下图所示： 偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化； 本章小结本章介绍了线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运行原理，并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part7/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之十&十一]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-6%2F</url>
    <content type="text"><![CDATA[第四部分 程序编译与代码优化第十章 早期（编译器）优化10.1 概述 前端编译器（或叫编译器前端）：把.java 文件转变为.class 文件的过程，比如 Sun 的 javac、Eclipse JDT 中的 ECJ； 后端运行编译器（JIT 编译器）：把字节码转变为机器码的过程，比如 HotSpot VM 的 C1、C2 编译器； 静态提前编译器（AOT 编译器）：直接把 *.java 文件编译成本地机器代码的过程，比如 GNU Compiler for the Java； 本章主要针对第一类，把第二类的编译过程留到下一章讨论； javac 这类编译器对代码运行效率几乎没有任何优化措施，虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样那些不是由 javac 产生的 Class 文件也同样能享受到编译器优化所带来的好处； javac 做了许多针对 Java 语言编码过程的优化措施来改善程序员的编码风格和提高编码效率；可以说，Java 中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译器的优化过程对于程序编码来说关系更加密切； 10.2 javac 编译器javac 编译器本身就是一个由 Java 语言编写的程序，这为纯 Java 的程序员了解它的编译过程带来了很大的便利。 10.2.1 javac 的源码与调试 javac 的源码存放在 JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac，除了 JDK 自身的 API 外，就只引用了 JDK_SRC_HOME/langtools/src/share/classes/com/sun/* 里面的代码； 导入 javac 的源码后就可以运行 com.sun.tools.javac.Main 的 main 方法来执行编译了； javac 编译过程大概可以分为 3 个过程：解析与填充符号表过程、插入式注解处理器的注解处理过程、分析与字节码生成过程； 10.2.2 解析与填充符号表 解析步骤由 parseFiles 方法完成； 词法分析将源代码的字符流转变为标记（Token）集合，由 com.sun.tools.javac.parser.Scanner 类完成； 语法分析是根据 Token 序列构造抽象语法树（AST，一种用来描述程序代码语法结构的树形表示方式）的过程，由 com.sun.tools.javac.parser.Parser 类实现，AST 由 com.sun.tools.javac.tree.JCTree 类表示； 填充符号表：由 enterTrees 方法完成；符号表是由一组符号地址和符号信息构成的表格，所登记的信息在编译的不同阶段都要用到，在语义分析中用于语义检查，在目标代码生成时用于地址分配；由 com.sun.tools.javac.comp.Enter 类实现； 10.2.3 注解处理器 在 JDK 1.6 中实现了 JSR-269 规范，提供了一组插入式注解处理器的标准 API 在编译期间对注解进行处理，可以读取、修改、添加抽象语法树中的任意元素； 通过插入式注解处理器实现的插件在功能上有很大的发挥空间，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情； javac 中，在 initProcessAnnotations 初始化，在 processAnnotations 执行，如果有新的注解处理器，通过 com.sun.tools.javac.processing.JavacProcessingEnviroment 类的 doProcessing 方法生成一个新的 JavaCompiler 对象对编译的后续步骤进行处理； 10.2.4 语义分析与字节码生成 语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，主要包括标注检查、数据及控制流分析两个步骤； 解语法糖（Syntactic Sugar，添加的某种对语言功能没有影响但方便程序员使用的语法）：Java 中最常用的语法糖主要是泛型、变长参数、自动装箱等，他们在编译阶段还原回简单的基础语法结构；在 com.sun.tools.javac.comp.TransTypes 类和 com.sun.tools.javac.comp.Lower 类中完成； 字节码生成：javac 编译的最后一个阶段，不仅仅是把前面各个步骤所生成的信息转化为字节码写入到磁盘中，编译器还进行了少量的代码添加和转换工作（如实例构造器方法和类构造器方法）；由 com.sun.tools.javac.jvm.ClassWriter 类的 writeClass 方法输出字节码，生成最终的 Class 文件； 10.3 Java 语法糖的味道10.3.1 泛型与类型擦除 Java 语言的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型了，并且在相应的地方插入了强制转换，这种基于类型擦除的泛型实现是一种伪泛型； JCP 组织引入了 Signature 属性，它的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，这样我们就可以通过反射手段获取参数化类型； 10.3.2 自动装箱、拆箱与遍历循环 它们的实现比较简单，但却是 Java 语言里使用最多的语法糖； 10.3.3 条件编译 Java 语言之中并没有使用预处理器，因为 Java 编译器并非一个个地编译 Java 文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译； Java 语言可以使用条件为常量的 if 语句进行条件编译；编译器将会把分支中不成立的代码块消除掉； 10.4 实战：插入式注解处理器 实战目标：使用注解处理器 API 来编写一款拥有自己编码风格的校验工具； 代码实现：继承 javax.annotation.processing.AbstractProcessor，实现 process 方法，从第一个参数 annotations 获取此注解处理器所要处理的注解集合，从第二个参数 roundEnv 中访问到当前这个 Round 中的语法树节点；另外还有一个很常用的实例变量 processingEnv，它代表了注解处理器框架提供的一个上下文环境；可以配合使用的 @SupportedAnnotationTypes 和 @SupportedSourceVersion 注解； 10.5 本章小结本章我们从编译器源码实现的层次上了解了 javac 源代码编译为字节码的过程，分析了 Java 语言中多种语法糖的前因后果，并实战实习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。下一章我们将会介绍即时编译器的运作和优化过程。 第十一章 晚期（运行期）优化11.1 概述 为了提高热点代码的执行效率，在运行时虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（JIT）； JIT 不是虚拟机必需的，但是其编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分； 11.2 HotSpot 虚拟机内的即时编译器11.2.1 解释器与编译器 当程序需要迅速启动和执行的时候，解释器可以先发挥作用，省去编译的时间立即执行；在程序运行后，随着时间的推移，编译器把越来越多的代码编译成本地代码提升执行效率； HotSpot 虚拟机中内置了两个即时编译器，分别为 Client Compiler 和 Server Compiler，或简称为 C1 编译器和 C2 编译器；虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，也可以使用 “-client” 或“-server”参数去强制指定运行模式； 想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机还会逐渐启动分层编译的策略：第 0 层，程序解释运行；第 1 层，C1 编译；第 2 层，C2 编译； 实施分层编译后，Client Compiler 和 Server Compiler 将会同时工作，许多代码都可能会被多次编译，用 Client Compiler 获取更高的编译速度，用 Server Compiler 来获取更好的编译质量，在解释执行的时候也无须再承担性能收集监控信息的任务； 11.2.2 编译对象与触发条件 被 JIT 编译的热点代码有两类：被多次调用的方法、被多次执行的循环体；对于前者编译器会以整个方法作为编译对象，属于标准的 JIT 编译方式；对于后者尽管编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译对象，这种编译方式称之为栈上替换（OSR 编译）； 热点探测：基于采样的热点探测和基于计数器的热点探测，在 HotSpot 虚拟机中使用的是第二种，通过方法计数器和回边计数器进行热点探测。方法调用计数器触发的即时编译交互过程如下图所示： 11.2.3 编译过程 对于 Client Compiler 来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了很多耗时较长的全局优化手段；第一阶段一个平台独立的前端将字节码构造成一个高级中间代码表示（HIR），第二阶段一个平台相关的后端从 HIR 中产生低级中间代码表示（LIR），最后阶段是在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。其大致过程如下所示： Server Compiler 是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到 GNU C++ 编译器使用 - 02 参数时的优化强大，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实现如范围检查消除、空值检查消除等 Java 语言特性密切相关的优化技术； 11.2.4 查看及分析即时编译结果 本节的运行参数有一部分需要 Debug 或 FastDebug 版虚拟机的支持； 要知道某个方法是否被编译过，可以使用参数 - XX:+PrintCompilation 要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来； 还可以加上参数 - XX:+PrintInlining 要求虚拟机输出方法内联信息，输出内容如下： 除了查看那些方法被编译之外，还可以进一步查看即时编译器生成的机器码内容，这个需要结合虚拟机提供的反汇编接口来阅读； 11.3 编译优化技术11.3.1 优化技术概览 11.3.2 公共子表达式消除 如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成为了公共子表达式，只需要直接用前面计算过的表达式结果代替 E 就可以了； 11.3.3 数组边界检查消除 对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判断，对于拥有大量数组访问的程序代码无疑是一种性能负担； 11.3.4 方法内联 除了消除方法调用的成本外更重要的意义是为其他优化手段建立良好的基础； 为了解决虚方法的内联问题，引入了类型继承关系分析（CHA）技术和内联缓存（Inline Cache）来完成方法内联； 11.3.5 逃逸分析 逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用（方法逃逸），甚至还可能被外部线程所访问到（线程逃逸）；如果能证明一个对象不会逃逸到方法或线程之外，则可能为这个变量进行一些高效的优化，比如栈上分配（减轻垃圾收集的压力）、同步消除（读写不会有竞争）、标量替换； 11.4 Java 与 C/C++ 的编译器对比 Java 虚拟机的即时编译器与 C/C++ 的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些劣势：即时编译器运行占用用户程序运行时间、动态类型安全语言导致的频繁检查、运行时对方法接收者进行多态选择的频率大、可以动态扩展导致很多全局的优化难以运行、大部分对象在堆上分配导致垃圾收集机制的效率低； Java 语言的特性换取了开发效率的提升、还有许多优化是静态优化编译器不好做的，比如别名分析、还有一些以运行期性能监控为基础的优化措施如调用频率预测等； 11.5 本章小结本章我们着重了解了虚拟机的热点探测方法、HotSpot 的即时编译器、编译触发条件以及如何从虚拟机外部观察和分析 JIT 编译的数据和结果，还选择了集中场景的编译期优化技术进行讲解。对 Java 编译器的深入了解，有助于在工作中分辨哪些代码是编译器可以帮我们处理的，哪些代码需要自己调节以便更适合编译器的优化。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part6/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之九]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-5%2F</url>
    <content type="text"><![CDATA[第九章 类加载及执行子系统的案例与实战9.1 概述 在 Class 文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不多； 能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路； 9.2 案例分析9.2.1 Tomcat：正统的类加载器架构 Java Web 服务器：部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离又要可以互相共享；尽可能保证自身的安全不受部署的 Web 应用程序影响；要支持 JSP 生成类的热替换； 上图中，灰色背景的三个类加载器是 JDK 默认提供的类加载器，而 CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和 WebappClassLoader 是 Tomcat 自己定义的类加载器，分别加载 / common/（可被 Tomcat 和 Web 应用共用）、/server/（可被 Tomcat 使用）、/shared/（可被 Web 应用使用）和 / WebApp/WEB-INF/（可被当前 Web 应用使用）中的 Java 类库，Tomcat 6.x 把前面三个目录默认合并到一起变成一个 / lib 目录（作用同原先的 common 目录）； 9.2.2 OSGI：灵活的类加载架构 OSGI 的每个模块称为 Bundle，可以声明它所依赖的 Java Package（通过 Import-Package 描述），也可以声明它允许导出发布的 Java Package（通过 Export-Package 描述）； 除了更精确的模块划分和可见性控制外，引入 OSGI 的另外一个重要理由是基于 OSGI 的程序很可能可以实现模块级的热插拔功能； OSGI 的类加载器之间只有规则，没有固定的委派关系；加载器之间的关系更为复杂、运行时才能确定的网状结构，提供灵活性的同时，可能会产生许多的隐患； 9.2.3 字节码生成技术与动态代理的实现 在 Java 里面除了 javac 和字节码类库外，使用字节码生成的例子还有 Web 服务器中的 JSP 编译器、编译时植入的 AOP 框架和很常用的动态代理技术等，这里选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的； 动态代理的优势在于实现了在原始类和接口还未知的时候就确定类的代理行为，可以很灵活地重用于不同的应用场景之中； 以下的例子中生成的代理类 “$Proxy0.class” 文件可以看到代理为传入接口的每一个方法统一调用了 InvocationHandler 对象的 invoke 方法；其生成代理类的字节码大致过程其实就是根据 Class 文件的格式规范去拼接字节码； 9.2.4 Retrotranslator：跨越 JDK 版本 Retrotranslator 的作用是将 JDK 1.5 编译出来的 Class 文件转变为可以在 JDK 1.4 或 JDK 1.3 部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持 JDK 1.5 中新增的集合改进、并发包以及对泛型、注解等的反射操作； JDK 升级通常包括四种类型：编译器层面的做的改进、Java API 的代码增强、需要再字节码中进行支持的活动以及虚拟机内部的改进，Retrotranslator 只能模拟前两类，第二类通过独立类库实现，第一类则通过 ASM 框架直接对字节码进行处理； 9.3 实战：自己动手实现远程执行功能 目标：不依赖 JDK 版本、不改变原有服务端程序的部署，不依赖任何第三方类库、不侵入原有程序、临时代码的执行结果能返回到客户端； 思路：如何编译提交到服务器的 Java 代码（客户端编译好上传 Class 文件而不是 Java 代码）、如何执行编译之后的 Java 代码（要能访问其他类库，要能卸载）、如何收集 Java 代码的执行结果（在执行的类中把 System.out 的符号引用替换为我们准备的 PrintStream 的符号引用）； 具体实现：HotSwapClassLoader 用于实现同一个类的代码可以被多次加载，通过公开父类 ClassLoader 的 defineClass 实现；HackSystem 是为了替换 java.lang.System，它直接修改 Class 文件格式的 byte[] 数组中的常量池部分，将常量池中指定内容的 CONSTANT_Utf8_info 常量替换为新的字符串；ClassModifier 涉及对 byte[] 数组操作的部分，主要是将 byte[] 与 int 和 String 互相转换，以及把对 byte[] 数据的替换操作封装在 ByteUtils 类中；经过 ClassModifier 处理过的 byte[] 数组才会传给 HotSwapClassLoader.loadByte 方法进行类加载；而 JavaClassExecutor 是提供给外部调用的入口； 9.4 本章小结只有了解虚拟机如何执行程序，才能更好地理解怎样写出优秀的代码。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之八]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-4%2F</url>
    <content type="text"><![CDATA[第八章 虚拟机字节码执行引擎8.1 概述 执行引擎是 Java 虚拟机最核心的组成部分之一，区别于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行哪些不被硬件直接支持的指令集格式； 在虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，该模型成为各种虚拟机执行引擎的统一外观； 在不同的虚拟机实现里面，执行引擎在执行 Java 代码时可能会有解释执行和编译执行两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观来说是一致的：输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。 8.2 运行时栈帧结构 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素； 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程； 栈帧需要分配多少内存在编译时就完全确定并写入到方法表的 Code 属性之中了，不会受到程序运行期变量数据的影响； 对于执行引擎来说，在活动线程中只有位于栈顶的栈帧才算有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。 8.2.1 局部变量表 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，Code 属性的 max_locals 确定了该方法所需要分配的局部变量表的最大容量； 其容量以变量槽（Variable Slot）为最小单位，虚拟机规范允许 Slot 的长度随处理器、操作系统或虚拟机的不同而发生变化； 一个 Slot 可以存放一个 32 位以内的数据类型，包括 boolean、byte、char。short、int、float、reference 和 returnAddress 这八种类型；对于 64 位的数据类型（long 和 double），虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间； 8.2.2 操作数栈 也常称为操作栈，它是一个后入先出栈；Code 属性的 max_stacks 确定了其最大深度； 比如整数加法的字节码指令 iadd 在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个 int 型的数值，当执行这个指令时，会将这两个 int 值出栈并相加，然后将相加的结果入栈； 操作数栈中元素的类型必须与字节码指令的序列严格匹配； Java 虚拟机的解释执行引擎称为 “基于栈的执行引擎”，其中所指的栈就是操作数栈； 8.2.3 动态连接 每个栈帧都包含一个执行运行时常量池中该栈帧所属方法引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）； Class 文件的常量池的符号引用，有一部分在类加载阶段或者第一次使用时就转换为直接引用，这种称为静态解析，而另外一部分在每一次运行期间转换为直接引用，这部分称为动态连接； 8.2.4 方法返回地址 退出方法的方式：正常完成出口和异常完成出口； 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能只需的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数中，调整 PC 计数器的值以只需方法调用指令后面的一套指令等； 8.2.5 附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分完成取决于具体的虚拟机实现； 8.3 方法调用 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本即调用哪一个方法，暂时还不涉及方法内部的具体运行过程； Class 文件的编译过程中不报警传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂； 8.3.1 解析 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用称为解析； 在 Java 语言中符合编译器可知、运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类； 五条方法调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic； 解析调用是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用；而分派调用则可能是静态的也可能是动态的； 8.3.2 分派 静态分派：“Human man = new Man();” 语句中 Human 称为变量的静态类型，后面的 Man 称为变量的实际类型；静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译器可知的；而实际类型的变化在运行期才确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么；编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的；所有根据静态类型来定位方法执行版本的分派动作称为静态分派，其典型应用是方法重载； 动态分派：invokevirtual 指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质；我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派； 单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派分为单分派（根据一个宗量对目标方法进行选择）与多分派（根据多于一个宗量对目标方法进行选择）两种；今天的 Java 语言是一门静态多分派、动态单分派的语言； 虚拟机动态分派的实现：在方法区中建立一个虚方法表（Virtual Method Table），使用虚方法表索引来代替元数据查找以提高性能；方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化值后，虚拟机会把该类的方法表也初始化完毕； 8.3.3 动态类型语言支持 JDK 1.7 发布增加的 invokedynamic 指令实现了 “动态类型语言” 支持，也是为 JDK 1.8 顺利实现 Lambda 表达式做技术准备； 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器，比如 JavaScript、Python 等； Java 语言在编译期间就将方法完整的符号引用生成出来，作为方法调用指令的参数存储到 Class 文件中；这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息；而在 ECMAScript 等动态语言中，变量本身是没有类型的，变量的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型；变量无类型而变量值才有类型，这个特点也是动态类型语言的一个重要特征； JDK 1.7 实现了 JSR-292，新加入的 java.lang.invoke 包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法外，提供一种新的动态确定目标方法的机制，称为 MethodHandle； 从本质上讲，Reflection（反射）和 MethodHandle 机制都是在模拟方法调用，但 Reflection 是在模拟 Java 代码层次的方法调用，而 MethodHandle 是在模拟字节码层次的方法调用，前者是重量级，而后者是轻量级；另外前者只为 Java 语言服务，后者可服务于所有 Java 虚拟机之上的语言； 每一处含有 invokedynamic 指令的位置都称为 “动态调用点 (Dynamic Call Site)”，这条指令的第一个参数不再是代表符号引用的 CONSTANT_Methodref_info 常量，而是 CONSTANT_InvokeDynamic_info 常量（可以得到引导方法、方法类型和名称）； invokedynamic 指令与其他 invoke 指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定的； 8.4 基于栈的字节码解释执行引擎上节主要讲虚拟机是如何调用方法的，这节探讨虚拟机是如何执行方法中的字节码指令的。 8.4.1 解释执行 只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才比较确切； Java 语言中，javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程；因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现； 8.4.2 基于栈的指令集与基于寄存器的指令集 Java 编译器输出的指令集，基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，它们依赖操作数栈进行工作； 基于栈的指令集主要的优点是可移植性，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；主要缺点是执行速度相对来说会稍慢一点； 8.4.3 基于栈的解释器执行过程一段简单的算法代码 上述代码的字节码表示 123456789101112131415public int calc();Code:Stack=2, Locals=4, Args_size=10:bipush 1002:istore_13:sipush 2006:istore_27:sipush 30010:istore_311:iload_112:iload_213:iadd14:iload_315:imul16:ireturn javap 提示这段代码需要深度为 2 的操作数栈和 4 个 Slot 的局部变量空间，作者根据这些信息画了示意图来说明执行过程中的变化情况： 执行偏移地址为 0 的指令 执行偏移地址为 2 的指令 执行偏移地址为 11 的指令 执行偏移地址为 12 的指令 执行偏移地址为 13 的指令 执行偏移地址为 14 的指令 执行偏移地址为 16 的指令 注：上面的执行过程仅仅是一种概念模型，虚拟机中解析器和即时编译器会对输入的字节码进行优化。 8.5 本章小结本章分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码以及执行代码时涉及的内存结构。这第六、七、八三章中，我们针对 Java 程序是如何存储的、如何载入的以及如何执行的问题进行了讲解，下一章一起看看这些理论知识在具体开发中的经典应用。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记七：虚拟机类加载机制（重点）]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-3%2F</url>
    <content type="text"><![CDATA[第七章 虚拟机类加载机制（重点）7.1 概述 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成，这虽然增量一些性能开销，但是会为 Java 应用程序提供高度的灵活性。 7.2 类加载的时机 类的整个生命周期：加载、验证、准备、解析、初始化、使用和卸载；其中验证、准备和解析统称为连接； 虚拟机规范没有强制约束类加载的时机，但严格规定了有且只有 5 种情况必须立即对类进行初始化：遇到 new、getstatic、putstatic 和 invokestatic 指令；对类进行反射调用时如果类没有进行过初始化；初始化时发现父类还没有进行初始化；虚拟机启动指定的主类；动态语言中 MethodHandle 实例最后解析结果 REF_getStatic 等的方法句柄对应的类没有初始化时； 7.3 类加载的过程7.3.1 加载 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口； 7.3.2 验证 验证是连接阶段的第一步，其目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全； 验证阶段是非常重要的，这个阶段是否严谨决定了 Java 虚拟机是否能承受恶意代码的攻击； 校验动作：文件格式验证（基于二进制字节流）、元数据验证（对类的元数据语义分析）、字节码验证（对方法体语义分析）、符号引用验证（对类自身以外的信息进行匹配性校验）； 7.3.3 准备 正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在这个方法区中进行分配； 需要强调两点：这时候内存分配的仅包括类变量，而不包括类实例变量；这里所说的初始化通常情况下是数据类型的零值，真正的赋值是在初始化阶段，如果是 static final 的则是直接赋值； 7.3.4 解析 解析阶段是虚拟机将常量池内的符号引用（如 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等 7 种）替换为直接引用的过程； 符号引用可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中；而直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，它和虚拟机实现的内存布局相关，引用的目标必定以及在内存中存在； 对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可以对第一次解析的结果进行缓存； 7.3.5 初始化 是类加载过程的最后一步，真正开始执行类中定义的 Java 程序代码（或者说是字节码）； 初始化阶段是执行类构造器方法的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的； 方法与类的构造函数（或者说是实例构造器方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的方法执行之前，父类的方法已执行完毕； 执行接口的方法不需要先执行父接口的方法，只有当父接口中定义的变量使用时父接口才会初始化，接口的实现类在初始化时也一样不会执行接口的方法； 方法初始化是加锁阻塞等待的，应当避免在方法中有耗时很长的操作； 7.4 类加载器 虚拟机设计团队把类加载阶段的 “通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到虚拟机外部去实现，实现这个动作的代码模块称为类加载器； 这时 Java 语言的一项创新，也是 Java 语言流行的重要原因，在类层次划分、OSGI、热部署、代码加密等领域大放异彩； 7.4.1 类与类加载器 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每一个类加载器都拥有一个独立的类名称空间； 比较两个类是否相等（如 Class 对象的 equals 方法、isAssignableFrom 方法、isInstance 方法），只有在这两个类是由同一个类加载器加载的前提下才有意义； 7.4.2 双亲委派模型 三种系统提供的类加载器：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）； 双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器，这里一般不会以继承的关系来实现，而是使用组合的关系来复用父加载器的代码； 其工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载； 这样的好处是 Java 类随着它的类加载器具备了一种带有优先级的层次关系，对保证 Java 程序的稳定运作很重要； 实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass 方法中，逻辑清晰易懂； 7.4.3 破坏双亲委派模型 上一小节的双亲委派模型是 Java 设计者推荐给开发者的类加载器实现方法，但不是一个强制性的约束模型； 典型的两种情况：为了解决 JNI 接口提供者（SPI）引入的线程上下文类加载器；为了程序动态性加强的 OSGI 的 Bundle 类加载器； 7.5 本章小结本章介绍了类加载过程的加载、验证、准备、解析和初始化五个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。下一章将一起看看虚拟机如果执行定义在 Class 文件里的字节码。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/推荐扩展阅读：http://blog.csdn.net/javazejian/article/details/73413292]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记六：类文件结构（了解）]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-2%2F</url>
    <content type="text"><![CDATA[第三部分 虚拟机执行子系统第六章 类文件结构（了解）代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 6.1 概述由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。 6.2 无关性的基石 Java 刚诞生的宣传口号：一次编写，到处运行（Write Once, Run Anywhere）。其最终实现在操作系统的应用层：Sun 公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码。 字节码（ByteCode）是构成平台无关的基石； 另外虚拟机的语言无关性也越来越被开发者所重视，JVM 设计者在最初就考虑过实现让其他语言运行在 Java 虚拟机之上的可能性，如今已发展出一大批在 JVM 上运行的语言，比如 Clojure、Groovy、JRuby、Jython、Scala； 实现语言无关性的基础仍是虚拟机和字节码存储格式，Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与 Class 文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成 Class 文件，从而在虚拟机上运行。 6.3 Class 类文件的结构 Class 文件是一组以 8 个字节为基础单位的二进制流（可能是磁盘文件，也可能是类加载器直接生成的），各个数据项目严格按照顺序紧凑地排列，中间没有任何分隔符； Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，其中只有两种数据类型：无符号数和表； 无符号数属于基本的数据类型，以 u1、u2、u4 和 u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值； 表是由多个无符号数获取其他表作为数据项构成的复合数据类型，习惯以 “_info” 结尾； 无论是无符号数还是表，当需要描述同一个类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据未某一类型的集合。 下面我以自己本机写的一个简单的 Java 文件来学习其中各个部分的含义： 使用 javac 编译成 TestClass.class 文件，使用 16 进制打开： 使用 javap 命令输出 Class 文件信息： 6.3.1 魔数和版本 Class 文件的头 4 个字节，唯一作用是确定文件是否为一个可被虚拟机接受的 Class 文件，固定为 “0xCAFEBABE”。 第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号（0x0034 为 52，对应 JDK 版本 1.8）；能向下兼容之前的版本，无法运行后续的版本； 6.3.2 常量池 常量池可以理解为 Class 文件之中的资源仓库，是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项之一； 由于常量池中的常量数量不固定，因此需要在常量池前放置一项 u2 类型的数据来表示容量，该值是从 1 开始的，上图的 0x0013 为十进制的 19，代表常量池中有 18 项常量，索引值范围为 1~18； 常量池主要存放两大类常量：字面量（Literal，笔记接近 Java 的常量概念，比如文本字符串和 final 常量等）和符号引用（Symbolic References，主要包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）； Java 代码在 javac 编译时不会有 “连接” 这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接；所以在 Class 文件不会保存各个方法、字段和最终内存布局信息；当虚拟机运行时需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中； JDK 1.7 中常量池共有 14 种不同的表结构数据，这些表结构开始的第一位是一个 u1 类型的标志位，代表当前常量的类型，具体如下图所示： 之所以说常量池是最繁琐的数据就是因为这 14 种常量类型都有自己的结结构。可以结合下图中各个表结构的说明和之前使用 javap 解析的文件内容一起看。 第 1 项：0x0A（15 标志为方法句柄），0x0004（指向第 4 项的类描述符），0x000F（指向第 15 项的名称及类型描述符）； 第 2 项：0x09（9 标志为字段符号引用），0x0003（指向第 3 项类描述符），0x0010（指向第 16 项的名称及类型描述符）； 第 3 项：0x07（7 标志为类符号引用），0x0011（指向第 17 项全限定名常量项）； 第 4 项：0x07（7 标志为类符号引用），0x0012（指向第 18 项全限定名常量项）； 第 5 项：0x01（1 标志为 UTF - 字符串常量），0x0001（字符串占用 1 个字节），6D（字符 “m”）； 第 6 项：0x01（1 标志为 UTF - 字符串常量），0x0001（字符串占用 1 个字节），49（字符 “I”）； 第 7 项：0x01（1 标志为 UTF - 字符串常量），0x0006（字符串占用 6 个字节），3C 69 6E 69 74 3E（字符 “”）； 第 8 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），28 29 56（字符 “()V”）； 第 9 项：0x01（1 标志为 UTF - 字符串常量），0x0004（字符串占用 4 个字节），43 6F 64 65（字符 “Code”）； 第 10 项：0x01（1 标志为 UTF - 字符串常量），0x000F（字符串占用 15 个字节），4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65（字符 “LineNumberTable”）； 第 11 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），69 6E 63（字符 “inc”）； 第 12 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），28 29 49（字符 “()I”）； 第 13 项：0x01（1 标志为 UTF - 字符串常量），0x000A（字符串占用 10 个字节），53 6F 75 72 63 65 46 69 6C 65（字符 “SourceFile”）； 第 14 项：0x01（1 标志为 UTF - 字符串常量），0x000E（字符串占用 14 个字节），54 65 73 74 43 6C 61 73 73 2E 6A 61 76 61（字符 “TestClass.java”）； 第 15 项：0x0C（12 标志为名称和类型符号引用），0x0007（指向第 7 项名称常量项）， 0x0008（指向第 8 项描述符常量项）； 第 16 项：0x0C（12 标志为名称和类型符号引用），0x0005（指向第 5 项名称常量项）， 0x0006（指向第 6 项描述符常量项）； 第 17 项：0x01（1 标志为 UTF - 字符串常量），0x001F（字符串占用 31 个字节），63 6F 6D 2F 67 69 6E 6F 62 65 66 75 6E 6E 79 2F 63 6C 61 7A 7A 2F 54 65 73 74 43 6C 61 73 73（字符 “com/ginobefunny/clazz/TestClas”）； 第 18 项：0x01（1 标志为 UTF - 字符串常量），0x0010（字符串占用 16 个字节），6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74（字符 “java/lang/Object”）； 6.3.3 访问标志 紧接在常量池后面的是两个字节的访问标志，用于标识类或接口的访问信息； 访问标志一个有 16 个标志位，但目前只采用了其中 8 位，本例子中的 0x0021 标识为一个 public 的普通类； 6.3.4 类索引、父类索引与接口索引集合 类索引：u2 类型的数据，用于确定类的全限定名。本例子中为 0x0003，指向常量池中第 3 项； 父类索引：u2 类型的数据，用于确定父类的全限定名。本例子中为 0x0004，指向常量池中第 4 项； 接口索引计算器：u2 类型的数据，用于表示索引集合的容量。本例子中为 0x0000，说明没有实现接口； 接口索引集合：一组 u2 类型的数据的集合，用于确定实现的接口（对于接口来说就是 extend 的接口）。本例子不存在。 6.3.5 字段表集合 用于描述接口或者类中声明的变量，包括类级变量和实例级变量，但不包括方法内部声明的局部变量；它不会列出从父类和超类继承而来的字段； 0x0001 表示这个类只有一个字段表数据； 字段修饰符放在 access_flag 中，是一个 u2 的数据类型，0x0002 表示为 private 的属性； 字段名称 name_index，是一个 u2 的数据类型，0x0005 表示该属性的名称为常量池的第 5 项； 字段描述符 descriptor_index，是一个 u2 的数据类型，0x0006 表示该属性的描述符为常量池的第 6 项，其值 “I” 表示类型为整形； 字段属性计算器和属性集合：0x0000 表示该例子中不存在； 6.3.6 方法表集合 和字段表集合的方式几乎一样； 方法里面的代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 Code 的属性里面； 0x0002 表示这个类有两个方法表数据，分别是编译器添加的实例构造器和源码中的方式 inc()； 第一个方法的访问标志是 0x0001（public 方法），名称索引值为 0x0007（常量池第 7 项，“”），描述符索引值为 0x0008（常量池第 8 项，“()V”），属性表计算器为 0x0001（有一项属性），属性名称索引为 0x0009（常量池第 9 项，“Code”）； 根据 “6.3.7.1 Code 属性” 说明，属性值的长度为 23（0x0000001D 表示 29，但需要减去属性名称索引和属性长度固定的 6 个字节长度），操作数栈深度的最大值为 1（0x0001，虚拟机运行时根据这个值来分配栈帧中操作栈深度），局部变量表所需要的存储空间为 1 个 Slot（0x0001，Slot 是内存分配的最小单位），字节码长度为 5（0x00000005），分别为 2A（aload_0，将第 0 个 Slot 中为 reference 类型的本地变量推送到操作数栈顶）、B7（invokespecial，以栈顶的 reference 类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private 方法或者它父类的方法，后面接着一个 u2 的参数指向常量池的方法引用）、0x0001（表示常量池的第 1 项，即 Object 类的方法）、B1（对应的指令为 return，返回值为 void）；显式异常表为空（0x0000，计数器为 0）；该 Code 属性还内嵌 1 个属性（0x0001），属性的名称索引为 0x000A（即 “LineNumberTable” 属性，用于记录对应的代码行数），该内嵌属性的长度为 6（0x00000006），对应的行数信息为源码的第 3 行（0x000100000003）； 第二个方法的访问标志是 0x0001（public 方法），名称索引值为 0x000B（常量池第 11 项，“inc”），描述符索引值为 0x000C（常量池第 12 项，“()I”），属性表计算器为 0x0001（有一项属性），属性名称索引为 0x0009（常量池第 9 项，“Code”）； 根据 “6.3.7.1 Code 属性” 说明，属性值的长度为 25（0x0000001F 表示 31，但需要减去属性名称索引和属性长度固定的 6 个字节长度），操作数栈深度的最大值为 2（0x0002），局部变量表所需要的存储空间为 1 个 Slot（0x0001），字节码长度为 7（0x00000007），分别为 2A（aload_0）、B4（getfield，后面接着一个 u2 的参数指向常量池的属性引用）、0x0002（表示常量池的第 2 项，即 TestClass 类的 m 属性）、04（对应的指令为 iconst_1）、60（对应的指令为 iadd，整形求和）、AC（对应的指令为 ireturn，返回值为整形）；显式异常表为空（0x0000，计数器为 0）；该 Code 属性还内嵌 1 个属性（0x0001），属性的名称索引为 0x000A（即 “LineNumberTable” 属性，用于记录对应的代码行数），该内嵌属性的长度为 6（0x00000006），对应的行数信息为源码的第 8 行（0x000100000008）； 6.3.7 属性表集合 在 Class 文件、字段表、方法表都可以携带自己的属性表集合； 属性表集合的限制较为宽松，不再要求严格的顺序，只要属性名不重复即可； 以下是 Java 虚拟机规范里预定义的虚拟机实现应当能识别的属性： 接着我们的例子的 Class 文件还有最后一段：0x0001 表示该 Class 有一个属性，0x000D 表示属性名索引为第 13 项（对应 “SourceFile”），0x00000002 表示该属性长度为 2，0x000E 表示该类的 SourceFile 名称为第 14 项（对应 “TestClass.java”）。 6.3.7.1 Code 属性Java 程序方法体中的代码经过 javac 编译后，字节码指令存放在 Code 属性，其属性表结构如下： 6.3.7.2 Exceptions 属性方法描述时 throws 关键字后面列举的异常，和 Code 属性里的异常表不同。其属性表结构如下： 6.3.7.3 LineNumberTable 属性用于描述 Java 源码行号与字节码行号之间的对应关系，它不是必须的，可以通过 javac -g:none 取消该信息。没有该信息的影响是运行时抛异常不会显示出错的行号，在代码调试时无法按照源码行来设置断点。 6.3.7.4 LocalVariableTable 属性用于描述栈帧中局部变量与 Java 源码中定义的变量之间的关系，它不是运行时必须的，可以通过 javac -g:none 取消该信息。如果没有这个属性，所有的参数名称都会丢失，取之以 arg0、arg1 这样的占位符来替代。 其中 local_variable_info 项代表了一个栈帧与源码中局部变量的关联，如下所示： 6.3.7.5 SourceFile 属性用于记录生成这个 Class 的源码文件名称，这个属性也是可选的。 6.3.7.6 ConstantValue 属性作用是通知虚拟机自动为静态变量赋值，只有被 static 关键字修饰的变量才可以用这个属性。对于非 static 类型的变量的赋值是在实例构造器方法中进行的；而对于类变量有两种方式：在类构造器方法中或者使用 ConstantValue 属性。目前 Sun javac 编译器的选择是：同时使用 final 和 static 修饰的变量且为基本数据类型或 String 类型使用 ConstantValue 属性初始化，否则使用初始化。 6.3.7.7 InnerClass 属性用于记录内部类与宿主类之间的关联。 其中 number_of_class 代表需要记录多少个内部类信息，每个内部类的信息都由一个 inner_class_info 表进行描述。 6.3.7.8 Deprecated 及 Synthetic 属性Deprecated（不推荐使用）和 Synthetic（不是由 Java 源码直接产生编译器自行添加的，有两个例外是实例构造器和类构造器）这两个属性都属于布尔属性，只存在有和没有的区别，没有属性值的概念。在属性结构中 attribute_length 的数据值必须为 0x00000000。 6.3.7.9 StackMapTable 属性这是一个复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 6.3.7.10 Signature 属性一个可选的定长属性，在 JDK 1.5 发布后增加的，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，则 Signature 属性会为它记录泛型签名信息。这主要是因为 Java 的泛型采用的是擦除法实现的伪泛型，在字节码中泛型信息编译之后统统被擦除，在运行期无法将泛型类型与用户定义的普通类型同等对待。通过 Signature 属性，Java 的反射 API 能够获取泛型类型。 6.3.7.11 BootstrapMethods 属性一个复杂的变长属性，位于类文件的属性表中，用于保存 invokedynamic 指令引用的引导方法限定符。 6.4 字节码指令简介Java 虚拟机的指令由一个字节长度的、代表着特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。 在指令集中大多数的指令都包含了其操作所对应的数据类型信息，如 iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中。 加载和存储指令：iload/iload 等（加载局部变量到操作栈）、istore/istore 等（从操作数栈存储到局部变量表）、bipush/sipush/ldc/iconst_（加载常量到操作数栈）、wide（扩充局部变量表访问索引）； 运算指令：没有直接支持 byte、short、char 和 boolean 类型的算术指令而采用 int 代替；iadd/isub/imul/idiv 加减乘除、irem 求余、ineg 取反、ishl/ishr 位移、ior 按位或、iand 按位与、ixor 按位异或、iinc 局部变量自增、dcmpg/dcmpl 比较； 类型转换指令：i2b/i2c/i2s/l2i/f2i/f2l/d2i/d2l/d2f； 对象创建与访问指令：new 创建类实例、newarray/anewarray/multianewarray 创建数组、getfield/putfield/getstatic/putstatic 访问类字段或实例字段、baload/iaload/aaload 把一个数组元素加载到操作数栈、bastore/iastore/aastore 将一个操作数栈的值存储到数组元素中、arraylength 取数组长度、instanceof/checkcast 检查类实例类型； 操作数栈管理指令：pop/pop2 一个或两个元素出栈、dup/dup2 复制栈顶一个或两个数组并将复制值或双份复制值重新压力栈顶、swap 交互栈顶两个数值； 控制转移指令：ifeq/iflt/ifnull 条件分支、tableswitch/lookupswitch 复合条件分支、goto/jsr/ret 无条件分支； 方法调用和返回指令：invokevirtual/invokeinterface/invokespecial/invokestatic/invokedynamic 方法调用、ireturn/lreturn/areturn/return 方法返回； 异常处理指令：athrow 同步指令：monitorenter/monitorexit 6.5 公有设计和私有实现 Java 虚拟机的实现必须能够读取 Class 文件并精确实现包含在其中的 Java 虚拟机代码的含义； 但一个优秀的虚拟机实现，通常会在满足虚拟机规范的约束下具体实现做出修改和优化； 虚拟机实现的方式主要有两种：将输入的 Java 虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集或宿主主机 CPU 的本地指令集。 6.6 Class 文件结构的发展 Class 文件结构一直比较稳定，主要的改进集中向访问标志、属性表这些可扩展的数据结构中添加内容； Class 文件格式所具备的平台中立、紧凑、稳定和可扩展的特点，是 Java 技术体系实现平台无关、语言无关两项特性的重要支柱； 6.7 本章小结本章详细讲解了 Class 文件结构的各个部分，通过一个实例演示了 Class 的数据是如何存储和访问的，后面的章节将以动态的、运行时的角度去看看字节码在虚拟机执行引擎是怎样被解析执行的。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part4/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记五：案例分析]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-1%2F</url>
    <content type="text"><![CDATA[5.2 案例分析5.2.1 高性能硬件上的程序部署策略 背景：一个15万pv、天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个cpu,16GB物理内存，操作系统为 64位的 CentOS 5.4 ，Resin作为服务器。管理员选用了 64位的 jdk 1.5,通过-Xmx,-Xms 将堆固定在12GB，使用一段时间后，出现了卡B现象，长时间无响应。监控发现卡B是由于GC停顿导致的。虚拟机运行在Server模式，默认使用吞吐量优先收集器，一次回收12GB的堆，一次 Full Gc的时间高达 14秒，再加上程序设计的关系，访问文档中需要一次性把文档从磁盘中读取到内存，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有在Minor GC中清理掉。在这种情况下，即使有12GB的堆，内存也很快会被消耗殆尽，有次导致每隔十几分钟出现十几秒的卡B，令网站开发人员和管理人员感到郁闷。 分析：在高性能硬件上部署程序，目前主要有两种方式：1 通过 64位 JDK 来使用大内存。2 使用若干个32位虚拟机简历逻辑集群来利用硬件资源。 如果读者计划使用64位的JDK来管理大内存，还需要考虑下面可能面临的问题：1 内存回收导致的长时间停顿。2 现阶段，64位JDK的性能测试普遍地域32位JDK。3 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照(因为要产生十几GB乃至更大的dump文件)，即使产生了快照也几乎无法进行分析。4 相同的程序在64位JDK中消耗的内存一般比32位的JDK大，这是由指针膨胀以及数据类型对其补白等因素导致的。 考虑到以上几点因素，你可能会选择使用若干个虚拟机集群来利用硬件资源，具体做法是子啊一台物理机器上启动多个应用服务器进程，给每个服务器进程分配不同的端口，然后在前端大减一个负载均衡器，以反向代理的方式来分配访问请求。 这种部署方式可能会遇到下面的问题： 1 尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同事访问某个磁盘文件的话，很容易导致IO异常。 2 很难高效率的利用某些资源池，譬如连接池，一般都是在各个节点上简历自己的独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余，尽管可以使用集中式的JNDI，但这有一定的复杂性并且可能带来额外的性能代价。 3 各个节点仍然不可避免的收到32位的内存限制，在32位window平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些linux unix 系统(Solaris)可以提升到3GB乃至接近4Gb的内存，但32位中仍然接受最高4GB内存的限制。 4 大量使用本地缓存的应用，在逻辑集群中会造成大量的内存浪费，因为每个逻辑节点上都有一份缓存，这时可以考虑把本地缓存改为集中式缓存。 最终解决方案最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算(其中堆固定为1.5GB)，占用了10GB的内存。另外建立一个Apache服务作为前端均衡器代理访问门户。考虑到用户对响应较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较多提升。 5.2.2 集群间同步导致的内存溢出由于集群同步大量数据，导致数据过多，而超过内存限制。 心得： 发生 OOM 的时候自动生成堆 dump 文件可以加参数： -XX:+HeapDumpOnOutOfMemoryError 由于信息有传输失败需要重发的可能性，在确认所有注册的GMS(GroupMembership Service)的节点都收到正确的信息前，发送的信息必须在内存中保留。此MIS的服务端中有一个负责安全校验的全局Filter，每当接收请求时，均会更新 一次最后的操作时间，并且将这个时间同步到所有节点中，使得一个用户在一段时间内不能在多台机器上登录。在服务器使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间的网络交互非常频繁。 当网络情况不能满足传输要求时，重发数据在内存中不断地积累，很快就产生了内存溢出。 这个案例中的问题，既有JBossCache的缺陷，也有MIS系统实现方式上的缺陷。JBossCache官方的mailist中讨论过很多次类似的内存溢出异常问题，据说后续版本有了改进。而更重要的缺陷是这一类被集群共享的数据如果要使用类似JBossCache 这种集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动作不会耗费多少资源，但不应当有过于频繁的写操作，这会带来很大的网络同步的开销。 5.2.3 堆外内存导致的溢出错误当出现 OOM 的时候不得不考虑下堆外内存导致的错误。第 2 章的时候也提到过，出现堆外内存导致的 OOM 时，heap dump 是无效的。异常栈里面可以明显看到 DirectByteBuffer、NIO 等字样的时候就可以考虑是堆外内存溢出导致的问题了。 最佳实践：因此总内存在分配给 JAVA 堆的时候，也确保预留了足够的堆外内存。 重点知识： 堆外内存不足的时候不会执行主动触发 GC，只会抛一些 OOM 的错误。 堆外内存导致的 OOM，heap dump 是无效的 只能等老年代 full GC 的时候顺便回收下堆外空间 其他心得：如果内存不足时抛出 StackOverflowError（纵向上，无法分配栈帧）或者 OutOfMemoryError:unable to create native thread（横向上，无法建立新的线程），考虑增加 - Xss 5.2.4 外部命令导致系统缓慢避免在 Java 中使用 Runtime.getRuntime().exec() 方法来执行外部的 shell 脚本。这样的实现方式开销较大。如果频繁调用会给 CPU 和内存带来极大压力。 JVM 执行这个命令的过程： 克隆一个和当前虚拟机拥有一样环境变量的进程 勇这个心得进程去执行外部命令，最后再退出这个进程。 5.2.5 服务器 JVM 进程崩溃使用异步调用，但是被调用方和调用发速度不匹配导致大量等待的线程和 socket 连接。最后积压太多超过 JVM 承受能力使得虚拟机进程崩溃。 解决办法： 采用生产者、消费者模式的消息队列来实现 5.2.6 不恰当数据结构导致内存占用过大例如： HashMap &lt;long,long&gt;这个种类型，各种头部开销比内容 (两个 Long 类型) 开销都要大得多，导致空间利用率低。&lt;/long,long&gt; 5.2.7 由 Windows 虚拟内存导致的长时间停顿GUI 程序最小化的时候，他的工作内存被自动交换到磁盘的页面文件之中，这样发生 GC 时就又可能因为恢复页面文件的操作而导致不正常的 GC 停顿。 解决办法：加入参数 “-Dsum.awt.keepWorkingSetOnMinimize=true” 5.3 实战：IDEA 运行速度调优这个整个过程较长，可以看书 P142 页开始。 我这里仅仅记录下一些值得注意的点： hostSpot 虚拟机名字由来： 如果一段 JAVA 方法被调用次数达到一定程度，就会判断为热带码交给 JIT 编译器（Just in time compiler）编译为本地代码，提高运行速度。 visualVM 里面的 visualGC 插件还是很有用的 参考： http://ningg.top/tool-personal-intellij-idea-for-mac-optimize/ http://blog.csdn.net/zhouping118/article/details/78185362 http://blog.csdn.net/u013295276/article/details/78543190 参考：https://kaimingwan.com/post/books/shen-ru-li-jie-javaxu-ni-ji/di-wu-zhang-diao-you-an-li-fen-xi-yu-shi-zhan]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记四：JVM 小工具]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11%2F</url>
    <content type="text"><![CDATA[JVM 小工具在 ${JAVA_HOME}/bin / 目录下 Sun/Oracle 给我们提供了一些处理应用程序性能问题、定位故障的工具, 包含 bin 描述 功能 jps 打印 Hotspot VM 进程 VMID、JVM 参数、main()函数参数、主类名 / Jar 路径 jstat 查看 Hotspot VM 运行时信息 类加载、内存、GC[可分代查看]、JIT 编译 jinfo 查看和修改虚拟机各项配置 -flag name=value jmap heapdump: 生成 VM 堆转储快照、查询 finalize 执行队列、Java 堆和永久代详细信息 jmap -dump:live,format=b,file=heap.bin [VMID] jstack 查看 VM 当前时刻的线程快照: 当前 VM 内每一条线程正在执行的方法堆栈集合 Thread.getAllStackTraces()提供了类似的功能 javap 查看经 javac 之后产生的 JVM 字节码代码 自动解析.class文件, 避免了去理解 class 文件格式以及手动解析 class 文件内容 jcmd 一个多功能工具, 可以用来导出堆, 查看 Java 进程、导出线程信息、 执行 GC、查看性能相关数据等 几乎集合了 jps、jstat、jinfo、jmap、jstack 所有功能 jconsole 基于 JMX 的可视化监视、管理工具 可以查看内存、线程、类、CPU 信息, 以及对 JMX MBean 进行管理 jvisualvm JDK 中最强大运行监视和故障处理工具 可以监控内存泄露、跟踪垃圾回收、执行时内存分析、CPU 分析、线程分析… 4.2 JDK 命令行工具 名称 主要作用 jps JVM Process Status Tool，显示指定系统内所有 HotSpot 虚拟机进程 jstat JVM Statistics Monitoring Tool，用于手机 HotSpot 虚拟机各方面运行数据 jinfo Configuration Info For Java，显示虚拟机配置信息 jmap Memory Map For Java，生成虚拟机内存转储快照（heapdumap 文件） jhat JVM Heap Dump Brower，用于分析 heapdump 文件 jstack Stack Trace For Java，显示虚拟机线程快照 4.2.1 jps：虚拟机进程状况工具1jps [options] [hostid] 参数 功能 -q 只输出 LVMID，省略主类名称 -m 输出虚拟机进程启动时传递给主类 main() 函数的参数 -l 输出主类全名，如果进程执行的是 jar 包，输出 jar 路径 -v 输出虚拟机启动时的 JVM 参数 4.2.2 jstat：虚拟机统计信息监视工具主要查询 3 类信息： 类装载 垃圾收集 运行期编译 1jstat [ option vmid [interval [s|ms] [count]] ] 参数 功能 -class 监视类装载、卸载数量、总空间及类装载所耗费的时间 -gc 监视 Java 堆状况，包括 Eden 区，2 个 survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息 -gccapacity 与 - gc 基本相同，主要关注 Java 堆各个区域使用到的最大和最小空间 -gcutil 与 - gc 基本相同，主要关注已使用空间占总空间百分比 -gccause 与 - gcutil 基本相同，但是会额外输出导致上一次 gc 产生的原因 -gcnew 监视新生代 GC 状况 -gcnewcapacity 监视内容与 - gcnew 一样，主要关注使用到的最大和最小空间 -gcold 监视老年代 GC 情况 -gcoldcapacity -compiler 输出 JIT 编译器编译过的方法、耗时等信息 -printcompilation 输出已经被 JIT 编译的方法 4.2.3 jinfo：Java 配置信息工具1jinfo [option] pid 4.2.4 jmap：Java 内存映像工具1jmap [option] vmid 参数 功能 -dump 生成 Java 堆转储快照。格式：-dump:[live,]format=b,file=，其中 live 子参数说明是否只 dump 出存活的对象 -finalizerinfo 在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只在 Linux/Solaris 下有效 -heap 显示 Java 堆详细信息，如使用哪种回收期、参数配置、分代状况等。只在 Linux/Solaris 下有效 -histo 显示堆中对象统计信息，包括类、实例数量和合计总量 4.2.5 jhat：虚拟机堆转储快照分析工具4.2.6 jstack：Java 堆栈跟踪工具1jstack [option] vmid 参数 功能 -F 强制输出 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用了本地方法的话，可以显示 C/C++ 的堆栈 4.3 JDK 可视化工具4.3.1 JConsole：Java 监视与管理控制台4.3.2 VisualVm：多合一故障处理工具 下载地址：http://visualvm.github.io/download.html 插件中心：https://visualvm.github.io/pluginscenters.html 参考：https://www.jianshu.com/p/c56884715567?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记三（垃圾收集器与内存分配策略，重点）]]></title>
    <url>%2F2018%2F03%2F10%2F2018-03-10%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略（重点）3.2 判断对象是否存活3.2.1 引用计数算法 (Reference Counting) 非主流 3.2.2 可达性分析算法 (GC Roots Analysis) 主流用这个判断 在主流的商用程序语言中 (Java 和 C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，下图对象 object5, object6, object7 虽然有互相判断，但它们到 GC Roots 是不可达的，所以它们将会判定为是可回收对象。 在 Java 语言里，可作为 GC Roots 对象的包括如下几种： a. 虚拟机栈 (栈桢中的本地变量表) 中的引用的对象 b. 方法区中的类静态属性引用的对象 c. 方法区中的常量引用的对象 d. 本地方法栈中 JNI 的引用的对象 3.2.3 引用在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用：就是指在程序代码之中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。 3.2.4 finalize() 方法最终判定对象是否存活 即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑” 阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 标记的前提是对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链。1). 第一次标记并进行一次筛选。 筛选的条件是此对象是否有必要执行 finalize() 方法。 当对象没有覆盖 finalize 方法，或者 finzlize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”，对象被回收。 2). 第二次标记 如果这个对象被判定为有必要执行 finalize（）方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的 “执行” 是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象 finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。 Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模标记，如果对象要在 finalize（）中成功拯救自己—- 只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出 “即将回收” 的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。不过大家尽量避免使用这个方法流程图如下： 注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，因此第二段代码的自救行动失败了。 并且建议大家尽量避免使用它 GC 日志说明： GC 打印时间: [垃圾回收类型回收时间: [收集器名称: 年轻代回收前占用大小 -&gt;年轻代回收后占用大小 (年轻代当前容量), 年轻代局部 GC 时 JVM 暂停处理的时间] 堆空间 GC 前占用的空间 -&gt; 堆空间 GC 后占用的空间(堆空间当前容量),GC 过程中 JVM 暂停处理的时间]。 垃圾回收类型：分为 GC 和 Full GC. GC 一般为堆空间某个区发生了垃圾回收， Full GC 基本都是整个堆空间及持久代发生了垃圾回收，通常优化的目标之一是尽量减少 GC 和 Full GC 的频率。 收集器名称：一般都为收集器的简称或别名，通过收集器名称基本都能判断出那个区发生了 GC。 DefNew：年轻代（新生代）发生了 GC （若为 DefNew 可知当前 JVM 年轻代使用的串行收集器） ParNew：年轻代（新生代）发生了 GC （若为 ParNew 可知当前 JVM 年轻代使用了并行收集器） Tenured：老年代发生了 GC Perm：持久代发生了 GC 3.2.5回收方法区 Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价表” 一般比较低。 方法区中的垃圾回收主要是：废弃常量及无用类。判断常量是否废弃与判断堆中对象十分相似。例如，若常量池中存在字符串 “abc”，而系统中并没有任何 String 对象的值为“abc” 的，也就是没有任何对象引用它，那么它就可以被回收了。无用类的判定稍微复杂点，需要满足： 1). 该类的所有对象实例已经被回收，也就是 Java 堆中不存在该类的任何实例； 2). 加载该类的 ClassLoader 已经被回收； 3). 该类的类对象 Class 没有在任何地方被引用，无法使用反射来访问该类的方法。 当方法区中的类满足以上条件时，就可以对无用类进行回收了，这里说的仅仅是 “可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了各种配置，这里不多讲。 在大量使用反射、动态代理、CGLIB 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保存永久代不会溢出。 3.3 垃圾收集算法（本书重点中的重点）3.3.1 标记 - 清除算法 (Mark-Sweep) 最基础的收集算法。其它算法都是基于这种思路并对其不足进行改进而得到的。 标记 - 清除算法将垃圾回收分为两个阶段： ①. 标记阶段：首先标记出所有需要回收的对象。 如何标记，在上面的 “判断对象是否存活” 里有讲过 ②. 清除阶段：标记完成后，统一回收被标记的对象缺点： ①. 效率问题：标记清除过程效率都不高。 ②. 空间问题：标记清除之后会产生大量的不连续的内存碎片 (空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。） 3.3.2 复制算法 (Copying)为了解决 mark-sweep 算法的效率问题 算法思想： 1). 将现有的内存空间分为两块，每次只使用其中一块. 2). 当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。 3). 再把已使用过的内存空间一次清理掉。 优点： 1). 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 2). 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 2.3 缺点： 1). 内存减少为原来的一半，太浪费了。 2). 对象存活率较高的时候就要执行较多的复制操作，效率变低。 3). 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。2.4. 演进 并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 EdenSpace 和两块较小的 SurvivorSpace JavaHeap 内存回收模型（当前商业虚拟机大多使用此算法回收新生代） jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 3.3.3 标记 - 整理算法 (Mark-Compact) 由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 算法思想 1). 标记阶段：首先标记出所有需要回收的对象。与 “标记 - 清除” 一样 2). 让存活的对象向内存的一段移动。 3). 直接清理掉边界以外的内存。 由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记 - 清理算法或者标记整理算法。 3.3.4 代收集算法 (Generational Collecting) 当前的商业虚拟机的垃圾收集都采用，把 Java 堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。 3.4 HotSpot的算法实现3.4.1 枚举根节点可达性分析在执行 GC 的时候会停顿一下，如果引用关系不断变换的时候很难进行准确的可达性分析。目前虚拟机主要采用的是准确性 GC，虚拟机应该有办法知道哪些地方存着对象引用，在 HotSpot 的实现中，用一组叫做 OopMap 的数据结构来实现这个目的，在类加载完成后记录下对象内的数据类型与偏移量，在 JIT 编译 过程中记录下栈和寄存器中哪些位置是引⽤。 3.4.2 安全点导致 OopMap 变化的指令非常多，我们只在特定的地点做记录，我们把这些点叫做安全点，也就是说让所以线程（不包括 JNI 调用的线程）跑到最近的安全点再停顿下来，所以安全点不能让 GC 等待时间过长，也不能太频繁。这里我们分为两种方式 抢占式中断，在 GC 的时候停下所以线程，再让没有到安全点的跑到安全点，目前几乎没有虚拟机采用这种方式进行 GC 主动式中断，当 GC 需要中断线程的时候，在安全点上设置中断标 志，线程执⾏时主动轮询中断标志，发现标志为真时则主动中断挂 起线程。轮训标志的地方和安全点重合。 3.4.3 安全区域指线程在某⼀段代码⽚段中，引⽤关系不会发⽣变化，在这个区域中的任意点开始 GC 都是安全的。GC 的时候不用考虑处于安全区域的，当线程出安全区域的时候要检查是否 GC 完成了，在线程处于 blocked 或 sleep 状态⽆法跑到安全点时，采⽤安全区域可以避免 GC ⻓时间等待。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 3.5 垃圾收集器 如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。 GC实现目标: 准确、高效、低停顿、空闲内存规整. ————————–新生代收集器———————— 3.5.1 Serial 收集器Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在 JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。 特性：这个收集器是一个单线程的收集器，但它的 “单线程” 的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Stop The World 应用场景：Serial 收集器是虚拟机运行在 Client 模式下的默认新生代收集器。 优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 3.5.2 ParNew 收集器 特性：ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。 应用场景：ParNew 收集器是许多运行在 Server 模式下的虚拟机中首选的新生代收集器。 很重要的原因是：除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS 收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。 Serial 收集器 VS ParNew 收集器：ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。然而，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的有效利用还是很有好处的。 3.5.3 Parallel Scavenge 收集器 1. 特性： Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 应用场景：停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 对比分析： Parallel Scavenge 收集器 VS CMS 等收集器：Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为 “吞吐量优先” 收集器。 Parallel Scavenge 收集器 VS ParNew 收集器：Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别是它具有自适应调节策略。 GC 自适应的调节策略：Parallel Scavenge 收集器有一个参数 -XX:+UseAdaptiveSizePolicy。当这个参数打开之后，就不需要手工指定新生代的大小、Eden 与 Survivor 区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。 ————————- 老年代收集器—————————- 3.5.4 Serial Old 收集器 特性：Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记－整理算法。 应用场景： Client 模式Serial Old 收集器的主要意义也是在于给 Client 模式下的虚拟机使用。 Server 模式如果在 Server 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 3.5.5 Parallel Old 收集器 特性：Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记－整理” 算法。 应用场景：在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作）。由于老年代 Serial Old 收集器在服务端应用性能上的 “拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。直到 Parallel Old 收集器出现后，“吞吐量优先” 收集器终于有了比较名副其实的应用组合。 3.5.6 CMS(Concurrent Mark Sweep) 收集器 1. 特性： CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。 CMS 收集器是基于 “标记—清除” 算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤： 初始标记（CMS initial mark）初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要 “Stop The World”。 并发标记（CMS concurrent mark）并发标记阶段就是进行 GC Roots Tracing 的过程。 重新标记（CMS remark）重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要 “Stop The World”。 并发清除（CMS concurrent sweep）并发清除阶段会清除对象。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。 优点：CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。 缺点： CMS 收集器对 CPU 资源非常敏感其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU 数量 + 3）/ 4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大。 CMS 收集器无法处理浮动垃圾CMS 收集器无法处理浮动垃圾，可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为 “浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS 收集器会产生大量空间碎片CMS 是一款基于 “标记—清除” 算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。—————————新生代和老年代均适用——————— 3.5.7 G1 收集器 特性：G1（Garbage-First）是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。 并行与并发G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。 分代收集与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合与 CMS 的 “标记—清理” 算法不同，G1 从整体来看是基于 “标记—整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。 可预测的停顿这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。 在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。 G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 执行过程：G1 收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking）初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 3.5.8、GC 相关参数总结VM 常用参数整理 参数 描述 -Xms 最小堆大小 -Xmx 最大堆大小 -Xmn 新生代大小 -XX:PermSize 永久代大小 -XX:MaxPermSize 永久代最大大小 -XX:+PrintGC 输出 GC 日志 -verbose:gc - -XX:+PrintGCDetails 输出 GC 的详细日志 -XX:+PrintGCTimeStamps 输出 GC 时间戳 (以基准时间的形式) -XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息 -Xloggc:/path/gc.log 日志文件的输出路径 -XX:+PrintGCApplicationStoppedTime 打印由 GC 产生的停顿时间 垃圾收集器参数总结 参数 描述 -XX:+UseSerialGC Jvm 运行在 Client 模式下的默认值，打开此开关后，使用 Serial + Serial Old 的收集器组合进行内存回收 -XX:+UseParNewGC 打开此开关后，使用 ParNew + Serial Old 的收集器进行垃圾回收 -XX:+UseConcMarkSweepGC 使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收，Serial Old 作为 CMS 出现 “Concurrent Mode Failure” 失败后的后备收集器使用。 -XX:+UseParallelGC Jvm 运行在 Server 模式下的默认值，打开此开关后，使用 Parallel Scavenge + Serial Old 的收集器组合进行回收 -XX:+UseParallelOldGC 使用 Parallel Scavenge + Parallel Old 的收集器组合进行回收 -XX:SurvivorRatio 新生代中 Eden 区域与 Survivor 区域的容量比值，默认为 8，代表 Eden:Subrvivor = 8:1 -XX:PretenureSizeThreshold 直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 -XX:MaxTenuringThreshold 晋升到老年代的对象年龄，每次 Minor GC 之后，年龄就加 1，当超过这个参数的值时进入老年代 -XX:UseAdaptiveSizePolicy 动态调整 java 堆中各个区域的大小以及进入老年代的年龄 -XX:+HandlePromotionFailure 是否允许新生代收集担保，进行一次 minor gc 后, 另一块 Survivor 空间不足时，将直接会在老年代中保留 -XX:ParallelGCThreads 设置并行 GC 进行内存回收的线程数 -XX:GCTimeRatio GC 时间占总时间的比列，默认值为 99，即允许 1% 的 GC 时间，仅在使用 Parallel Scavenge 收集器时有效 -XX:MaxGCPauseMillis 设置 GC 的最大停顿时间，在 Parallel Scavenge 收集器下有效 -XX:CMSInitiatingOccupancyFraction 设置 CMS 收集器在老年代空间被使用多少后出发垃圾收集，默认值为 68%，仅在 CMS 收集器时有效，-XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSCompactAtFullCollection 由于 CMS 收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在 CMS 收集器时有效 -XX:+CMSFullGCBeforeCompaction 设置 CMS 收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与 UseCMSCompactAtFullCollection 参数一起使用 -XX:+UseFastAccessorMethods 原始类型优化 -XX:+DisableExplicitGC 是否关闭手动 System.gc -XX:+CMSParallelRemarkEnabled 降低标记停顿 -XX:LargePageSizeInBytes 内存页的大小不可设置过大，会影响 Perm 的大小，-XX:LargePageSizeInBytes=128m Client、Server 模式默认 GC 服务端 or 客户端 新生代 GC 方式 老年代和持久代 GC 方式 Client Serial 串行 GC Serial Old 串行 GC Server Parallel Scavenge 并行回收 GC Parallel Old 并行 GC Sun/oracle JDK GC 组合方式 参数 新生代 GC 方式 老年代和持久代 GC 方式 -XX:+UseSerialGC Serial 串行 GC Serial Old 串行 GC -XX:+UseParallelGC Parallel Scavenge 并行回收 GC Serial Old 并行 GC -XX:+UseConcMarkSweepGC ParNew 并行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时，采用 Serial Old 串行 GC -XX:+UseParNewGC ParNew 并行 GC Serial Old 串行 GC -XX:+UseParallelOldGC Parallel Scavenge 并行回收 GC Parallel Old 并行 GC -XX:+UseConcMarkSweepGC -XX:+UseParNewGC Serial 串行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时采用 Serial Old 串行 GC 常用的收集器组合 服务器 31 新生代 GC 策略 老年老代 GC 策略 说明 组合 1 Serial Serial Old Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。 组合 2 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。 组合 3 ParNew CMS 使用-XX:+UseParNewGC选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用 - XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用 ParNew GC 策略。 组合 4 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。 组合 5 Parallel Scavenge Serial Old Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 组合 6 Parallel Scavenge Parallel Old Parallel Old 是 Serial Old 的并行版本 组合 7 G1GC G1GC -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启；-XX:MaxGCPauseMillis =50 #暂停时间目标；-XX:GCPauseIntervalMillis =200 #暂停间隔目标；-XX:+G1YoungGenSize=512m #年轻代大小；-XX:SurvivorRatio=6 #幸存区比例 1. 与串行回收器相关的参数 -XX:+UseSerialGC: 在新生代和老年代使用串行回收器。 -XX:+SuivivorRatio: 设置 eden 区大小和 survivor 区大小的比例。 -XX:+PretenureSizeThreshold: 设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。 -XX:MaxTenuringThreshold: 设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。 2. 与并行 GC 相关的参数 -XX:+UseParNewGC: 在新生代使用并行收集器。 -XX:+UseParallelOldGC: 老年代使用并行回收收集器。 -XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。 -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。 -XX:GCTimeRatio: 设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 -XX:+UseAdaptiveSizePolicy: 打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 3. 与 CMS 回收器相关的参数 -XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS + 串行收集器。 -XX:+ParallelCMSThreads: 设定 CMS 的线程数量。 -XX:+CMSInitiatingOccupancyFraction: 设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。 -XX:+UseFullGCsBeforeCompaction: 设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 -XX:+CMSClassUnloadingEnabled: 允许对类元数据进行回收。 -XX:+CMSParallelRemarkEndable: 启用并行重标记。 -XX:CMSInitatingPermOccupancyFraction: 当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是 - XX:+CMSClassUnloadingEnabled 激活了)。 -XX:UseCMSInitatingOccupancyOnly: 表示只在到达阈值的时候，才进行 CMS 回收。 -XX:+CMSIncrementalMode: 使用增量模式，比较适合单 CPU。 4. 与 G1 回收器相关的参数 -XX:+UseG1GC：使用 G1 回收器。 -XX:+UnlockExperimentalVMOptions: 允许使用实验性参数。 -XX:+MaxGCPauseMills: 设置最大垃圾收集停顿时间。 -XX:+GCPauseIntervalMills: 设置停顿间隔时间。 5. 其他参数 -XX:+DisableExplicitGC: 禁用显示 GC。 3.6 内存分配与回收策略（重点） Java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题： 1). 给对象分配内存; 2). 回收分配给对象的内存。关于回收内存这一点请参考如下文章 内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为 “对象游离”。 Jvm 怎么判断对象可以回收了？ 1). 对象没有引用，被判定为 “死亡”（并不是这个对象被赋值为 null 之后就一定被标记为可回收） 2). 作用域发生未捕获异常 3). 程序在作用域正常执行完毕 4). 程序执行了 System.exit() 5). 程序发生意外终止（被杀进程等） 对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 分配前请先了解下新年代和老年代： 3.6.1 对象优先在 Eden 分配 前面的文章介绍过 Hotspot 虚拟机新生代内存布局及算法： a. 将新生代内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。b. 每次使用 Enden 和其中一块 Survivor。c. 当回收时，将 Eden 和使用中的 Sruvivor 中还存的对象一次性复制到另一块 Survivor；d. 然后清理掉 Eden 和使用过的 Survivor 空间；e. 后面就使用 Eden 和另一块 Survivior 空间，重复步骤 3。 默认 Eden：Survivor=8：1，即每次可以使用 90% 的空间，只有一块 Survivor 空间被浪费。 大多数情况下，对象在 Eden 区中分配；当 Eden 区没有足够空间进行分配时，JVM 将会发起一次 MinorGC(新生代 GC)。MinorGC 时，如果发现存活的对象无法全部放入 Servivor 空间，只好通过分配机制提前转入熬年老代中。 3.6.2 大对象直接进入老年代 所谓的大对象是指：需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。 大对象对虚拟机的内存分配来说就是一个坏消息，比遇到一个大对象更加坏的消息就是：遇到一群 “朝生夕灭” 的 “短命大对象”。 经常出现大对象容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。 所以我们应该避免创建大对象； “-XX:PretenureSizeThreshold”： 可以设置这个阀值，大于这个参数值的对象直接在年老代中分配。 默认为 0(无效)，且只对 Serail 和 ParNew 两款收集器有效。 如果需要使用该参数，可以考虑 ParNew+CMS 组合 长期存活的对象将进入年老代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.3 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.4 动态对象年龄判定JVM 为了更好适应不同程序，不是永远要求等到 MaxTenuringThreshold 参数设置的年龄。 如果在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，大于或等于该年龄的对象就可以直接进入年老代。 3.6.5 空间分配担保 当 Survivor 空间不够用时，需要依赖其他内存 (年老代) 进行分配担保(Hanle Promotion) 分配担保流程如下： a. 在发生 Minor GC 之前，JVM 首先检查年老代最大可用的连续空间是否大于新生所有对象的空间。 b. 如果大于，那么可以确保 Minor GC 是安全的。 c. 如果不大于，则 JVM 查看 HandlePromotionFailure 值是否允许担保失败。 d. 如果允许，将尝试进行一次 Minor GC，但这是有风险对的； e. 如果小于或 HandlePromotionFailure 值不允许冒险，那这时，要改为进行一次 Full GC； 尝试 Minor GC 的风险 – 担保失败： 因为尝试 Minor GC 前，无法知道存货的对象大小，所以使用历次晋升到年老代对象的平均大小作为经验值。 加入尝试的 Minor GC 最终存活的对象远远高于经验值的话，会导致担保失败 (Handle Promotion Failure)。 失败后只有重新发起一次 Full GC，这绕了一个大圈，代价较高。 但一般还是要开启 HandlePromotionFailure，避免 Full GC 过于频繁，而且担保失败概率还是比较低的。 JDK1.6 之后，JVM 代码中已经不再使用 HandlePromotionFailure 参数了… 规则变为： 只要年老代最大可用的连续空间大于新生所有对象的空间或历次晋升到年老代对象的平均大小，就会进行 MinorGC，否则进行 Full GC。 即年老代最大可用的连续空间小于新生所有对象空间时，不在检查 HandlePromotionFailure，而是直接检查历次晋升熬年老代对象的平均大小。 参考：http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/https://www.jianshu.com/p/50d5c88b272dhttp://blog.csdn.net/simba_cheng/article/details/78223010]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM参数调优]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09%2F</url>
    <content type="text"><![CDATA[常见配置汇总堆设置-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值.如:为3,表示年轻代与年老代比值为1:3,年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:3,表示Eden:Survivor=3:2,一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数.并行收集线程数.-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式.适用于单CPU情况.-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数. 参考：http://blog.csdn.net/xiajian2010/article/details/17376157]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理数据可视化]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[根据现有数据集进行数据表查询集构建： galleryproduction 左外联结 production: 1234SELECT scratch_api_production.id,scratch_api_galleryproduction.production_id,scratch_api_production.nameFROM scratch_api_galleryproduction LEFT JOIN scratch_api_productionON scratch_api_production.id=scratch_api_galleryproduction.production_id production 左外联结 user: 1234SELECT scratch_api_production.author_id,scratch_api_user.baseuser_ptr_id,scratch_api_user.sex,scratch_api_user.gradeFROM scratch_api_production LEFT JOIN scratch_api_user ON scratch_api_production.author_id=scratch_api_user.baseuser_ptr_id 再构建三联表： galleryproduction左外联结production左外联结user 三表联结查询模版： 123select username,psw,gname,tel from (t1 left join t2 on t1.t1_id=t2.t1_id) left join t3 on t1.t1_id=t3.t1_id 我根据业务流程实现的sql查询： 查询某专题活动中的所有信息 1234SELECT *FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 然后使用阿里云的DataV进行数据可视化: 需要对接接口： 查询点赞数最多作品排行： 12345SELECT scratch_api_production.like,scratch_api_production.name FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' AND sex='男'ORDER BY scratch_api_production.like DESC 查询结果集中的男女人数 123456789SELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='男'UNIONSELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='女' 查询某专题活动学校参与度排名 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询某专题活动中的参与性别 1234SELECT scratch_api_user.sexFROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' 查询年级占比 123456SELECT scratch_api_user.grade ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.grade is not NULLGROUP BY scratch_api_user.gradeorder by count(*) desc 查询学校占比 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询作品提交时间 12345SELECT DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") as '日期',count(*) as '当日投票数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1GROUP BY DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") 把地址转换成经纬度不要方，利用高德地图经纬度快速查询工具可以轻松地把任何地址转换成经纬度，可具体到门牌号喔，工具地址： 控制台 | 高德开放平台 | 高德地图API galleryproduction左外联结production左外联结user左外联结antlrscore 1234SELECT *FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idLEFT JOIN scratch_api_antlrscore ON scratch_api_production.id = scratch_api_antlrscore.production_id_id 查询某活动中CT评分整体情况 12 义乌市首届Scratch编程周实时数据状态网址(动态页面):http://datav.aliyun.com/share/07ef37b235d9763bd364f344912d1a05大数据可视化说明:大数据屏幕：1920*1080（可修改）最高实时更新频率：1min/次正常显示的预览效果参考（静态截图）：http://p4lmrb1gp.bkt.clouddn.com/15205615855957.jpg本机上如果不是上述参考效果请检查自己的浏览器如下:推荐电脑上预览：首选谷歌 Chrome 浏览器版本56以上，其他浏览器则需更新至最新版并开启极速（chrome内核）模式，不要使用IE浏览器，否则无法正常显示。不推荐手机上预览：无法按默认长宽比例展示 预览效果：]]></content>
      <tags>
        <tag>数据可视化</tag>
        <tag>DataV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记二：Java内存区域与内存溢出异常&实战（重点）]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-05-2%2F</url>
    <content type="text"><![CDATA[第二章 Java内存区域与内存溢出异常&amp;实战第二章结构： Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。参考：https://www.jianshu.com/p/989c90f339b9 2.2 运行时数据区域具体见下图： 2.2.1 程序计数器（Program Counter Register） 概述：该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有：因为 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。2.无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法（本地方法，一个调用非Java代码的接口），这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。（个人理解：参考C++理解是：当线程中调用native方法的时候，当前线程应当会被阻塞，重新启动一个新的线程，那么计数器为空则不会影响新线程的计数器，相互独立。当前线程应当会被阻塞，直到另外一个线程执行结束。当然参数也会被保留） 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 我们经常将 Java 内存分为堆内存（Heap）和栈内存（Stack），这种分法中所指的栈就是 Java 虚拟机栈，或者说是虚拟机栈中 局部变量表 部分。 概述：描述 Java 方法执行的内存模型，每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆是所有线程共享的一块内存区域，由虚拟机启动时创建，堆的唯一目的就是存储对象的实例。几乎所有的对象实例都在改内存区域分配，但是随着JIT编译器（即时编译）的发展及逃逸分析技术（分析指针的动态范围）的发展，栈上分配、标量替换导致堆分配不那么“绝对”了。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开。 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 内存：Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。 相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对 常量池的回收 和 类型的卸载。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。Class 文件中除了有类的（版本、字段、方法、接口）等描述信息外，还有一项信息就是常量池。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2.3 HotSpot 虚拟机对象探秘 这一部分内容将以 HotSpot 虚拟机和常用的内存区域 Java 堆为例，阐述对象分配、布局和访问的全过程。 2.3.1 对象的创建 概述：Java 是一门面向对象的编程语言，在 Java 程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个 new 关键字而已，而在虚拟机中对象的创建则分为以下几个步骤。 虚拟机遇到New指令 首先检查指令的参数能否在常量池中定位到一个类的符号引用 检查这个符号引用对应的类是否已被加载、解析、初始化过 没有加载，则需要先加载 为新生对象分配内存区域（指针碰撞&amp;空闲列表） 线程安全（方案1：对分配内存空间的动作同步；方案2：本地线程分配缓冲 TLAB） 对对象进行必要的设置 调用init方法 类加载概述：虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存概述：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。 分配方式：1.指针碰撞（Bump the Pointer）：假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。2.空闲列表（Free List）：如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。 同步控制概述：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。 方案一：对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。 初始化概述：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。作用：保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。 对象头（Object Header）概述：接下来，虚拟机要为对象头数据进行设置。（e.g. 对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄） init概述：在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，&lt;init&gt; 方法还没有被执行，所有的字段还为零值。 一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，将对象按照我们的意愿进行初始化，这样一个真正的对象才算完全产生。 2.3.2对象的内存布局 在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域。 对象头（存放对象自身的运行时数据&amp;类型指针） 实例数据 对齐填充 2.3.2.1 对象头（Header） HotSpot 虚拟机的对象头包括两部分信息，存储自身的运行时数据的（Mark Word） 和 类型指针。 第一部分：Mark Word 概述：用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。 内存：对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 HotSpot 虚拟机对象头 Mark Word 表如下 第二部分：类型指针 概述：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 Reminder并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。(见2.2.3节) 数组对象：如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。 2.3.2.2 实例数据（Instance Data） 概述：这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 存储顺序：这部分的存储顺序会受到虚拟机 分配策略参数（FieldsAllocationStyle） 和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles =&gt; ints =&gt; shorts/chars =&gt; bytes/booleans =&gt; oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 2.3.2.3 对齐填充（Padding） 概述：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 原理：由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 2.3.3 对象的访问定位 概述：建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以 对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有两种。 句柄访问：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。 直接指针：Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示。 比较：1.句柄访问：使用句柄访问的最大好处就是 reference 中存储的是 稳定的 句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。2.指针访问：使用直接访问最大的好处就是 速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 Sun HotSpot 使用的是第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 2.4 实战：OutOfMemoryError 异常 在 Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemory（OOM）异常的可能。 目的：1. 通过代码验证 Java 虚拟机规范中描述的各个运行时区域的存储内容。2. 遇到实际的内存溢出异常时，能根据异常的信息快速判断哪个区域的内存溢出。3. 了解什么样的代码可能会导致这些区域内存溢出，并了解如何处理。 VM Args 设置 Eclipse IDE：Debug Configurations =&gt; Java Application =&gt; YoungGenGC =&gt; Arguments 中的 VM arguments 中进行书写（书写参数以 - 开头，以空格分隔）。 控制台：直接跟在 Java 命令之后书写。 本人运行在 Mac 系统下，使用 IDEA 进行配置，步骤如下所示👇。 1\. 打开 Run Configurations（⌃ + ⌥ + R 选择 0 ）或者（⌘ + ⇧ + A 输入 run 选择 run…）。 2\. 点击并打开 VM options。 3\. 写入虚拟机启动参数。 4.Apply 并 Run。 2.4.1 - Java 堆溢出 概述：Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 测试环境： 12345-verbose:gc-Xms20M // 最小 GC 启动-Xmx20M // 最大 GC 启动-XX:+PrintGCDetails // 打印设置-XX:SurvivorRatio=8 // 存活对象比率 测试代码：HeapOOM 123456789101112131415import java.util.*;public class Main &#123; private static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 运行结果： 1java.lang.OutOfMemoryError: Java heap space 分析：Java 堆内存的 OOM 异常是时机应用中常见的内存溢出异常情况。当出现 Java 堆内存溢出时，异常堆栈信息 java.lang.OutOfMemoryError 会跟着进一步提示 Java heap space。 解决方式 堆转储快照：要解决这个区域的异常，一般的手段是先通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。 内存泄露：进一步通过工具查看泄露对象到 CG Roots 的引用链，于是就能找到内存泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄露代码的位置。 内存溢出：如果不存在泄露，换句话说，就是内存中的对象确实都必须还活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对象看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗。 2.4.2 - 虚拟机栈和本地方法栈溢出 概述：由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoos 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 -Xss 参数设定。关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常。 异常类型 发生条件 StackOverflowError 线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。 OutOfMemoryError 无法申请到足够的内存时抛出该异常。 这里把异常分为两种情况，看似更加严谨，但却存在一些相互重叠的地方：方栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事的两种描述而已。 2.4.2.1 - StackOverflowError 测试环境：在此测试中，将测试范围限制于单线程中操作。1. 使用 -Xss 参数减少栈内存容量，结果抛出 SOF 异常，异常出现时输出的堆栈深度相应缩小。2. 定义了大量的本地变量，增大此方法栈中本地变量表长度。结果抛出 SOF 异常时输出的堆栈深度相应缩小。 JavaVMStackSOF: 1234567891011121314151617181920212223242526//JavaVMStackSOF//VM Args: -Xss160k // 栈内存容量public class Main &#123; public static class JavaVMStackSOF&#123; private int stackLength = 1; public void stackLeak() &#123; stackLength++; stackLeak(); &#125; &#125; public static void main(String[] args) throws Throwable &#123; JavaVMStackSOF oom = new JavaVMStackSOF(); try &#123; oom.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println("Stack length: " + oom.stackLength); throw e; &#125; &#125;&#125; 运行结果 123Exception in thread &quot;main&quot; Stack length: 771java.lang.StackOverflowError at Main$JavaVMStackSOF.stackLeak(Main.java:8) 分析：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者确切地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 理解：操作系统分配给每个进程的内存是有限的，虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存 -Xms（最大堆容量） -MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略不计。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈瓜分了。每个线程分配到的栈容量越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。 探索：出现 SOF 异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的）达到 1000 - 2000 完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果建立过多线程导致内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过 减少最大堆 和 减少栈容量 来换更多的线程。 2.4.2.2 - OutOfMemoryError 测试环境注意：下面这块代码运行有风险，书上说在windows上会造成系统假死，我在mac上的IDEA上运行，也死机了，测了两次，都导致了系统假死。 JavaVMStackOOM 12345678910111213141516171819202122232425262728293031323334public class Main &#123; //VM Args: -Xss2M // 栈内存容量 //测试代码：创建线程导致内存溢出异常 private void dontStop() &#123; while (true) &#123; &#125; &#125; // 循环开启线程 public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; Main oom = new Main(); oom.stackLeakByThread(); &#125;&#125; 运行结果（参考别人的结果） 1Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread 这是mac死机时用手机照的(；′⌒`)cpu已爆表 2.4.3 - 方法区和运行时常量池溢出 概述：由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。 脑补：String.intern() 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。在 JDK1.6 以及之前的版本中，由于常量池分配在永久代内，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小名，从而间接限制其中常量池的容量。 2.4.3.1 - OutOfMemoryError 测试环境 12-XX:PermSize=10M // 方法区最小值-XX:MaxPermSize=10M // 方法区最大值 测试代码RuntimeConstantPoolOOM 12345678910111213package com.company.bupt;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); long i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 在JDK1.6上运行结果如下： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at com.company.bupt.Main.main(Main.java:10) 分析：从运行结果中可以看到，运行时常量池溢出，在 OutOfMemoryError 后面跟随的提示信息是 PermGen space，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分。 在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为JVM实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。 在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。 在JDK8之前的HotSpot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域。永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过‑XX:MaxPermSize 设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误(OOM)。 参考：Java永久代去哪儿了 http://www.infoq.com/cn/articles/Java-PERMGEN-Removed 总结：java jdk1.7中的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域，如果想了解更多可以参考：http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.htmlhttp://blog.csdn.net/zhyhang/article/details/17246223/ 在JDK1.7上测试 模拟了一下常量池的oom，突然发现设置的参数-XX:PermSize=10M -XX:MaxPermSize=10M不管用了，同时发现内存一直在上升，当上升到一个极值就会趋于平稳，然后再过一段时间会报：Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded这个异常是当GC的时间超过总运行时间的98%才会报的，是为了防止GC占用的时间过长。 运行结果 2.4.3.2 - String 常量池测试 使用 JDK1.7 运行这段程序就不会得到相同的结果，while 循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响。 测试代码RuntimeConstantPoolOOM1 12345678910111213package com.company.bupt;public class Main &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); &#125;&#125; 分析： JDK1.6：会得到两个 false，而在 JDK1.7 中运行，会得到一个 true 和一个 false。产生差异的原因是：是 JDK1.6 中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由 StringBuilder 创建的字符串实例在 Java 堆上，所以必然不是同一个引用，将返回 false JDK1.7：intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此 intern() 返回的引用和由 StringBuilder 创建的那个字符串实例是同一个。对 str2 比较返回 false 是因为 java 这个字符串在执行 StringBuilder.toString() 之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而 计算机软件 这个字符串是首次出现的，因此返回 true。 JVM启动的时候已经写到常量池里了，类似的还有’main’、’int’、’float’。参考：https://www.jianshu.com/p/b98851899f37 JDK1.7上测试结果: 12345678String str1 = new StringBuilder("jc").append( "vc" ).toString();//JVM不会自动加载jcvc，所以这个jcvc是首次出现的，返回true System.out.println(str1.intern()==str1); String str2=new StringBuilder("mai").append( "n" ).toString(); //main已经被自动加载了，不是首次出现，所以返回false System.out.println(str2.intern()==str2); String str3=new StringBuilder("in").append( "t" ).toString(); //flase System.out.println(str3.intern()==str3); String str4=new StringBuilder("flo").append( "at" ).toString(); //flase System.out.println(str4.intern()==str4); JDK1.6上测试上述代码则全返回是false 2.4.3.3 - 方法区溢出 方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本思路就是运行时产生大量的类去填满方法区，直到溢出。另外的，直接使用 Java SE API 也可以动态产生类（如反射时的 GeneratedConstorAccessor 和动态代理等）。 但在本次试验使用CGLIB直接操作字节码运行时，生成大量的动态类。 值得注意的是，当前主流的很多框架 如：Spring,Hibernate对类进行增强时，都会使用到类似CGLIB这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载如内存。 注意：项目必须引入asm-6.0.jar和cglib-3.2.6.jar，需要手动寻找引入 测试代码JavaMethodAreaOOM： 1234567891011121314151617181920212223242526272829303132333435package com.company.bupt;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 测试方法区内存溢出 * 方法区保存的是Class的相关信息，如类名，字段描述符等等，在这里使用cglib来创建大量的类信息来使方法区内存溢出 * * 异常信息为：java.lang.OutOfMemoryError: PermGen space * VM args:-XX:PermSize=10m -XX:MaxPermSize=10m * @author Tim * */public class Main &#123; public static void main(String[] args) &#123; while(true)&#123; Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125; static class OOMObject&#123; &#125;&#125; 以下是我的实测情况： 下列是在JDK1.6上测试得到的： 下列是在JDK1.7上测试得到的： 2.4.3.4 - 总结 方法区溢出是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量的 Class 的应用中，需要特别注意类的回收情况。这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 2.4.4 - 本机直接内存溢出 概述：DirectMemory 容量可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（-Xmx指定）一样，下面的测试代码越过了 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）。因为，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 unfase.allocateMemory()。 测试代码DirectMemoryOOM 12345678910111213141516171819202122package com.company.bupt;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M * @author zzm */public class Main &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 运行结果参考： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryErrorat sun.misc.Unsafe.allocateMemory(Native Method)at org.fenixsoft.oom.DMOOM.main(DMOOM.java:20) 以下是JDK1.6上实测：程序并没有报错 分析：由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看到明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，那就可以考虑检查一下是不是这方面的原因。 参考:https://www.jianshu.com/p/989c90f339b9]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记一：（实战）自己编译JDK]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-06%2F</url>
    <content type="text"><![CDATA[全书核心分布： 第一章 走近JAVA1.6 实战：自己编译JDK(已成功编译) 疑问： 将JDK源码进行编译是做了点什么？是将JDK中的.java文件编译成.class文件吗？ JDK中包含开发工具包和JVM，作者编译完JDK以后，用的还是原来包中的JVM吗？ 我们平常使用的JDK，例如JDK1.7中，里面的文件是以.java形式存在的还是以.class形式存在的，或者是以.java形式存在，要用的时候再用JVM去编译的?答： JDK是c/c++写的, 编译就是把JDK编译成可以运行的状态, 可运行的意思是指可以编译运行.java文件. 而一般情况下官方下载的JDK都是已经帮你编译好而已. 作者可以用自己编译的, 也可以用官方编译好的. 这个要看书中的说明了 JDK是c/c++写的, 里面和其他c++程序没什么区别, windows下面是一堆dll和一堆exe. 你说的.java文件是JDK的功能之一, 帮你编译java文件成class, JVM是运行class文件的容器 一 环境： 操作系统：CentOS6.8计划编译的jdk: openjdk7现成的jdk: java version “1.6.0_25”(Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode))jdk6下载链接如果你当前的系统版本不是这个，没关系，只要下载上述版本安装rpm（默认安装到/usr/java路径下）(不必配置环境变量)即可 二 编译前准备工作如下123456yum install -y mercurialyum install -y ant ant-nodepsyum install -y libX11* libX*yum install -y libXi-devel libXtst-devel libXt-devel freetype* yum install -y alsa-lib-devel cups-develyum install -y gcc gcc-c++ 三 下载计划编译的openjdk7(jdk源码网站：http://hg.openjdk.java.net/jdk7u/ ， 你值得收藏) 1234hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-devcd jdk7u-devchmod 755 get_source.sh ./get_source.sh 四 编译4.1准备好编译环境相关参数解释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export LANG=C#Bootstrap JDK的安装路径，必须设置export ALT_BOOTDIR=/export/servers/jdk1.6.0_25/#允许自动下载依赖export ALLOW_DOWNLOADS=true#并行编译的线数，设置和cpu的数量一致即可export HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2#比较本次build出来的映像与先前版本的差异，这对我们来说没有意义，export SKIP_COMPARE_IMAGES=true#使用预编译头文件，不加这个编译会更慢一些export USE_PRECOMPILED_HEADER=true#指定要编译的内容export BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=falseexport BUILD_JAXWS=falseexport BUILD_CORBA=false#要编译的版本#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueexport DEBUG_NAME=debug#可以避开javaws和浏览器Java插件之类的部分buildBUILD_DEPLOY=false#设置成false就不会build出包装包，因为包装包里有些奇怪的依赖#但是即使不build出它也已经能得到完整的JDK映像，所以还是别build它好了BUILD_INSTALL=false#编译结果存放的路径export ALT_OUTPUTDIR=/root/temp/jdk7u WARNINGS_ARE_ERRORS=#卸载环境变量，避免诡异的事情发生unset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS#make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 好了，我们将上面一系列的环境变量，创建环境文件VAR来统一管理吧vi VAR 12345678910111213141516171819202122232425262728293031323334353637383940export LANG=Cexport ALT_BOOTDIR=/usr/java/jdk1.6.0_25export ALLOW_DOWNLOADS=trueexport HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2export SKIP_COMPARE_IMAGES=trueexport USE_PRECOMPILED_HEADER=trueexport BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=trueexport BUILD_JAXWS=trueexport BUILD_CORBA=true#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueBUILD_DEPLOY=falseBUILD_INSTALL=falseexport ALT_OUTPUTDIR=/home/cloudpai/app/jdk7u #export CORBA_DIST=$ALT_OUTPUTDIR/corba/dist#export JAXP_DIST=$ALT_OUTPUTDIR/jaxp/dist#export JAXWS_DIST=$ALT_OUTPUTDIR/jaxws/distunset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS 使之生效. VAR 4.2检测设置是否全部正确make sanity当看到如下输出时则表示成功 123456789101112131415161718192021Build Machine Information: build machine = workstation.centos.vbirdBuild Directory Structure: CWD = /root/temp/jdk7u-dev TOPDIR = . LANGTOOLS_TOPDIR = ./langtools JAXP_TOPDIR = ./jaxp JAXWS_TOPDIR = ./jaxws CORBA_TOPDIR = ./corba HOTSPOT_TOPDIR = ./hotspot JDK_TOPDIR = ./jdk ……Sanity check passed. 4.3真正开始编译make (命令等同于make all) 成功的标志 12345678910111213#-- Build times ----------Target all_product_buildStart 2018-03-06 21:03:26End 2018-03-06 21:20:0900:02:02 corba00:05:08 hotspot00:00:16 jaxp00:00:19 jaxws00:08:34 jdk00:00:23 langtools00:16:43 TOTAL-------------------------make[1]: Leaving directory `/home/cloudpai/Downloads/jdk7u-dev' 4.4测试自己编译出来的jdk吧正确编译后，可以执行如下命令验证 1234[cloudpai@hadoop000 bin]$ /home/cloudpai/app/jdk7u/j2sdk-image/bin/java -versionopenjdk version "1.7.0-internal"OpenJDK Runtime Environment (build 1.7.0-internal-cloudpai_2018_03_06_21_03-b00)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) OK，到些就大功告成了。 五 可能出现的错误/usr/bin/ld: cannot find -lX11 collect2: ld returned 1 exit status解决办法yum install -y libX11* /bin/sh: line 0: cd: /NOT-SET/re/jdk/1.7.0/promoted/latest/binaries/linux-amd64: No such file or directory make[4]: *** [/root/temp/jdk7u/tmp/java/components_imported] Error 1解决办法VAR文件确认执行过了，正确的姿势. VAR 参考博客：http://blog.csdn.net/hl_java/article/details/76691321 由1.6.4得我们得到了自己的虚拟机1.7.0-internal-cloudpai_2018_03_06_21_03-b00 现在我们要将JVM运行起来： 在大多数时候，如果我们并不关心JDK中HotSpot虚拟机以外的内容，只想单独编译 HotSpot虚拟机的话（例如调试虚拟机时，每次改动程序都执行整个OpenJDK的Makefile，速 度肯定受不了），那么使用hotspot/make目录下的Makefile进行替换即可，其他参数设置与前 面是一致的，这时候虚拟机的输出结果存放在build/hotspot/outputdir/bsd_amd64_compiler2目录(在不同机器上，最后一个目录名称会有所差别，bsd表示Mac OS系统（内核为 FreeBSD），amd64表示是64位JDK（32位是x86），compiler2表示是Server VM（Client VM表 示是compiler1）。) 中，进入后可以见到以下几个目录。 在路径：/home/cloudpai/app/jdk7u/hotspot/outputdir/linux_amd64_compiler2 12345678910[cloudpai@hadoop000 linux_amd64_compiler2]$ lltotal 48drwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 debugdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 fastdebugdrwxrwxr-x. 7 cloudpai cloudpai 4096 Mar 6 21:06 generateddrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 jvmgdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 optimizeddrwxrwxr-x. 3 cloudpai cloudpai 20480 Mar 6 21:11 productdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 profiled-rw-rw-r--. 1 cloudpai cloudpai 1778 Mar 6 21:06 shared_dirs.lst 这些目录对应了不同的优化级别，优化级别越高，性能自然就越好，但是输出代码与源 码的差距就越大，难于调试，具体哪个目录有内容，取决于make命令后面的参数。 在编译结束之后、运行虚拟机之前，还要手工编辑目录下的env.sh文件，这个文件由编 译脚本自动产生，用于设置虚拟机的环境变量，里面已经发布了“JAVA_HOME、 CLASSPATH、HOTSPOT_BUILD_USER”3个环境变量， 还要在在product下边（看网上都是在jvmg下边，可我的jvmg下边没有gamma，不知道什么情况）的env.sh下加入： 123456export JAVA_HOME=/usr/java/jdk1.6.0_25export PATH=$JAVA_HOME/bin:$PATHLD_LIBRARY_PATH=.:$&#123;JAVA_HOME&#125;/jre/lib/amd64/native_threads:$&#123;JAVA_HOME&#125;/jre/lib/amd64:export LD_LIBRARY_PATH 然后执行以下命令启动虚拟机（这时的启动器名为gamma），输出版本号。 12source ./env.sh ./gamma -version 最后运行虚拟机成功！！ 12345[cloudpai@hadoop000 product]$ ./gamma -versionUsing java runtime at: /usr/java/jdk1.6.0_25/jrejava version &quot;1.6.0_25&quot;Java(TM) SE Runtime Environment (build 1.6.0_25-b06)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) 1.6.5 JVM 在IDE工具中进行源码调试注意这里是源码调试，是对1.6.4中计划编译的jdk源码进行操作: openjdk7（centos上的存储路径是/home/cloudpai/Downloads/jdk7u-dev） centos下安装NetBeans集成开发环境 官网下载地址：http://download.netbeans.org/netbeans/7.0.1/final/bundles/netbeans-7.0.1-ml-cpp-linux.sh 以netbeans-7.0.1-ml-cpp-linux.sh为例 首先，到NetBeans网站（http://netbeans.org/）上下载最新版的NetBeans（网上说7.0.1版本没问题，我就直接用这个版本了），下载时选择支持 C/C++开发的那个版本。 注意：不要在本地远程用SecureCRT输入命令啊，要在Linux下用终端输入命令： 1sh netbeans-7.0.1-ml-cpp-linux.sh 这样就会在centos中弹出安装界面： 配置好安装路径和IDE使用的java环境（注意与编译时的环境一致） 安装好以后，桌面上就有了NetBeans： 后续操作可以参考这个博客：使用Netbeans开发调试OpenJDK中的HotSpothttp://blog.csdn.net/pange1991/article/details/51580969 CentOS下安装NetBeans集成开发环境http://www.itboth.com/d/QriYZj/centos-java-windows-linux-netbeans]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java1.8 帮助文档]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05-1%2F</url>
    <content type="text"><![CDATA[java 1.6 帮助文档中文链接：http://download.csdn.net/detail/qw599186875/9608735英文Java1.8 帮助文档英文中文 – 谷歌版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-google/下载链接：http://download.csdn.net/detail/qw599186875/9802192]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站架构技能图谱（Java版）]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05%2F</url>
    <content type="text"><![CDATA[每天都要有进步！]]></content>
      <tags>
        <tag>Java</tag>
        <tag>图谱</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[workflow工作流]]></title>
    <url>%2F2018%2F03%2F04%2F2018-03-04%2F</url>
    <content type="text"><![CDATA[工作流脚本测试：测试成功~晚安~~]]></content>
      <tags>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scratch编程探究]]></title>
    <url>%2F2018%2F03%2F02%2F2018-03-02%2F</url>
    <content type="text"><![CDATA[转载自：儿童使用Scratch编程时，与程序员在工作中的编程有什么区别？ - Milo Yip的回答 - 知乎https://www.zhihu.com/question/42012520/answer/310430799]]></content>
      <tags>
        <tag>scratch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018拜年祭单品]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01-1%2F</url>
    <content type="text"><![CDATA[2018拜年祭单品传送门： 1.【逆浪千秋】av20204904 2.【如果我的一生只需要做一件事 — Bilibili Zeitgeist 2017】av20203478 3.【梦想小剧场-遗失的宝物】av20203610 4.【口袋竞技场ー冰与铁之歌】av20203938 5.【相遇day by day】av20203945 6.【上海一夜】av20204014 7.【神鬼恋曲】av20204051 8.【UP主的奇妙冒险之勇者传说】av20204517 9.【我的破烂之掀起波澜】av20204332 10.【palette】av20204403 11.【广告高手】av20204701 12.【滑稽君大冒险】av20204534 13.【journey】av20204614 14.【全靠我勤劳的手】av20204705 15.【演奏区的偷心计划】av20204824 16.【乒乓帝国】av20205319 17.【鬼畜大战之真相黎明】av20205316 18.【如何翻拍一个CG短片】av20205314 19.【坦克大战】av20205375 20.【星空花火】av20203411 彩蛋【举头三尺有神明】av16201808]]></content>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blogs 上的标签tag参数]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01%2F</url>
    <content type="text"><![CDATA[12345678910---title: Mac终端翻墙tags: Linux&amp;Unixcategories: Linux&amp;Unixcomments: trueabbrlink: 745a6d7date: 2016-11-24 18:26:33updated: 2016-11-24 18:26:33copyright: true---]]></content>
      <tags>
        <tag>mac</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要进行的改进]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[TODO： 测试git的备份功能 学习 Alfred workflow实现打开重启任意应用 脚本实现清理浏览器缓存]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog通过git备份与恢复的最优操作]]></title>
    <url>%2F2018%2F02%2F28%2Fblog%E9%80%9A%E8%BF%87git%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%9A%84%E6%9C%80%E4%BC%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引言：Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。特别简洁。 关于搭建的流程 创建仓库，http://CrazyMilk.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库； 在本地http://CrazyMilk.github.io 仓库新建一个文件后，进入文件中。在该文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 关于日常的改动流程 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的http://CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 其实只要把hexo和需要每个插件都写入到package.json中（平常安装时加–save参数会自动写入），那么git clone下来之后，只要一句npm install就能装好hexo和所有的依赖，开箱即用 ^_^ 迁移源码库一开始用了该方法，后来意识到备份到github分支的博客源码也是public的，后来改为备份到开源中国git私有库了 参考1：GitHub Pages + Hexo搭建博客参考2：使用hexo，如果换了电脑怎么更新博客？ - CrazyMilk的回答 - 知乎]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28-1%2F</url>
    <content type="text"><![CDATA[创建的仓库：默认master克隆的仓库：默认origin（源） git add 开始跟踪一个新文件git status显示git状态 git commit提交更新 git diff：比较工作区和缓存区的不同。git diff --cached：比较缓存区和仓库的不同。 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 git push [remote-name] [branch-name] 如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：git push origin master git log显示从最近到最远的提交日志。包含每个提交的SHA1校验和、作者的名字和邮箱、提交时间以及提交说明等。gitk使用图形化工具查阅提交历史 git commit --amend修改最后一次提交 git reset HEAD &lt;file&gt;...取消已经暂存的文件 Git 分支git branch创建一个新的分支 git commit -a -m &#39;made other changes&#39; 提交分支git mergetool调用一个可视化的合并工具并引导你解决所有冲突 git学习链接]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac使用]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28%2F</url>
    <content type="text"><![CDATA[Mac系统如何显示隐藏文件？以”.”开头的隐藏文件如何在MAC系统下显示？ 答：Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 显示 隐藏文件 1234567#显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool trueosascript -e 'tell application "Finder" to quit'#不显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool falseosascript -e 'tell application "Finder" to quit']]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客样式改进杂记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8D%9A%E5%AE%A2%E6%A0%B7%E5%BC%8F%E6%94%B9%E8%BF%9B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[评论区样式修改：文件位置：themes/next/source/css/_common/components/comments.styl 修改内容： 1234.comments &#123; background white; opacity:0.8;&#125; 移动端不加载背景图一点优化，移动端不加载背景图。在_layout.swig底部L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});标签前，加上移动端浏览器内核判断语句，当为PC端浏览器时，加载背景js 123456789101112131415161718192021222324252627&lt;!--移动端判断，是否引入背景--&gt;&lt;script&gt;var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123;//移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase() &#125; if(browser.versions.mobile || browser.versions.ios || browser.versions.android || browser.versions.iPhone || browser.versions.iPad)&#123; &#125;else&#123; document.write("&lt;script type=\'text/javascript\' src=\'/js/src/particle.js\'&gt;&lt;\/script&gt;"); &#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🎵记录点滴生活]]></title>
    <url>%2F2018%2F02%2F24%2F%F0%9F%8E%B5%E8%AE%B0%E5%BD%95%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[记录点滴生活《BINGBIAN病变》歌曲不错，曲调有些忧伤 [00:00.21]罗之豪 - BINGBIAN病变 [00:01.87]词：Cubi/Fi9 [00:02.76]曲：Jurrivh [00:03.72]混音：Fi9 [00:19.36][02:01.33][03:09.30]有天我睡醒看到我的身边没有你 [00:23.52][02:05.53][03:13.50]在我的右边是你曾经喜欢的玩具 [00:27.75][02:09.76][03:17.66]可当我站起身来在房间里寻找你 [00:32.04][02:14.00][03:21.93]留下的只有带着你味道的一封信 [00:36.50][02:18.48][03:26.35]就在昨天还一起看我们的照片 [00:40.47][02:22.48][03:30.46]可现在让我感觉像烂剧里的主演 [00:44.74][02:26.71][03:34.69]为什么这种事情会发生在我身边 [00:48.97][02:31.00][03:38.92]是不是老天没能看到对你的疯癫 [00:54.46]还想着 创造你的宇宙 [00:56.53]但现在 已经被我清空 [00:58.57]你让我 整个人都冰冻 [01:00.68]还怎么 再次为你心动 [01:02.88]Wake me 不是你的意愿 [01:04.97]离开我 开始新的起点 [01:07.12]可能我 还会对你贪恋 [01:09.30]谁让你 曾经让我疯癫 [01:11.18]疯癫 那也是过去的画面 [01:14.54]看往后的几天 [01:16.72]我猜你也不会出现 [01:18.78]我回想这几年 [01:20.93]就像是要命的病变 [01:23.16]你可能听不见 [01:25.16]来自我对你的挂念 [01:27.53]可能有点累 [01:28.85]觉得对不对这是第几次在为你宿醉 [01:31.98]没了我肩膀 [01:33.08]你在谁身旁买的礼物变成了灰 [01:35.99]曾经我多想 [01:37.25]把你变漂亮看着别人羡慕你的模样 [01:40.50]没关系有小熊陪着你看月亮 [01:44.40]我已经看到跟你断电的过程 [01:46.96]但我假装看不见 [01:48.76]是不是要我变得像个厉鬼 [01:50.96]才能进入你的世界 [01:52.95]为什么不说再见 [01:54.31]我猜你应该是不小心的忘记 [01:57.04]都无所谓也有点累 [01:59.09]也可以开始新的记忆 [02:35.19]我不能够停止啊 [02:37.43]这些年我对你的疯癫 [02:39.49]戴上那条围巾吧 [02:41.59]在每个寒风刺骨的冬天 [02:43.92]每次送你回家你抱着我 [02:45.63]不经意间又触碰到你的手 [02:48.10]你穿裙子眨眼睛 望着我 [02:50.52]让我每次心动的瞬间 [02:52.49]那条十字路口 [02:54.39]始终有你身上的气味 [02:57.00]车水马龙过后的路灯下的身影 [03:00.10]又会是谁 [03:00.83]他想说我真的 [03:02.01]喜欢你但是每次欲言又闭嘴 [03:05.57]那时荒唐的男孩 [03:07.64]又浑浊了几岁 var ap = new APlayer({ element: document.getElementById("aplayer5"), narrow: false, autoplay: false, showlrc: 2, music: { title: "BINGBIAN病变", author: "Cubi / Fi9江澈", url: "http://p4lmrb1gp.bkt.clouddn.com/Cubi,Aydo$,BRGang%20-%20BINGBIAN%E7%97%85%E5%8F%98.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/BINGBIAN%E7%97%85%E5%8F%98.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>音乐</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的blog自动发布脚本]]></title>
    <url>%2F2018%2F02%2F23%2Fmac%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[遇到的坑： -bash: ./install.sh: /bin/bash: bad interpreter: Operation not permitted出现这个问题的主要原因是：-rwxrwxrwx@ 文件的属性最后带个@，这个@代表的是更多的一些属性，具体含义不太清楚，但有它就是执行不了解决：可以用这个命令来去除这个属性：xattr -d com.apple.quarantine ./*后来进入目录发现目录下面的文件还是带有@属性，我们到根目录加一个-r就好了：xattr -d -r com.apple.quarantine ./* 我的blog自动发布脚本:blog_publish.sh 123456789#!/bin/bashsay "blogs updating"cd /Users/pailiu/Library/Mobile\ Documents/iCloud~com~coderforart~iOS~MWeb/Documents/mweb_documents_library/Bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo dsay "blogs published"rm -rf /Users/pailiu/Library/Caches/Google/Chrome/Profile\ 1/*open -a "/Applications/Google Chrome.app" 'http://cloudpai.site/'# hexo server]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客插入音频、视频]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为了避免后期外链失效，可以将视频、音频图片等资源传至七牛云等cdn服务器上，从中获取外链。 常用排版：居中： 1&lt;center&gt; &lt;/center&gt; 插入图片：有尺寸要求时： 1&lt;img src="http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg" width="80%" height="80%"&gt; 无尺寸要求时快速插入（md格式）： 1![](http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg) 插入音乐网易云音乐外链获取：见官网修改博客音乐播放器歌曲路径：/Blog/themes/hexo-theme-next-master/layout/_macro/sidebar.swig qq音乐外链获取： http://www.qqmusic.cc/插入音频播放器代码： 1&lt;audio src="http://mp3.qqmusic.cc/yq/211758246.mp3" controls="controls"&gt;&lt;/audio&gt; hexo-tag-aplayer：博客中插入自定义音乐 安装成功后，在 Markdown 文档中添加比如添加如下代码使用hexo-tag-aplayer 参数12345678title ：音乐标题author：音乐作者url：音乐文件网址picture_url：可选，音乐图片网址narrow：可选，窄款式autoplay：可选，自动播放音乐，不支持移动浏览器width:xxx：可选，前缀width:，播放器宽度（默认值：100％）lrc:xxx：可选，前缀lrc:，LRC文件url 示例: 1&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125; [ti:春意红包 (Vocaloid Ver.)] [ar:乐正绫/心华/洛天依] [al:春意红包] [by:] [offset:0] [00:00.29]春意红包 (Vocaloid Ver.) - 乐正绫/心华/洛天依 [00:00.89]词：泠鸢YOUSA [00:01.05]曲：Wing翼 [00:01.18]编曲：Wing翼 [00:01.95]小麦面包饺 喜色上眉梢 [00:05.78]点柳翠 画春晓 [00:08.85] [00:10.08]找旧样铜板穿一串吉兆 [00:14.20]把春意装满红包 [00:17.86] [00:37.11]廊下的小阿妹摇头晃脑 [00:41.25]望着瓦上的碎嘴家雀 [00:44.76] [00:45.56]问它们春日的鸟儿 何时才能到 [00:49.81] [00:50.35]穿街搜巷沿路找 [00:53.26] [00:53.76]看邻家的老人摘下毡帽 [00:57.88]虽是脱去冬衣还尚早 [01:01.89]宰鸡鸭 起炉灶 揭开自家陈酿 [01:07.91]偷偷尝一瓢 [01:09.81] [01:13.01]大鬼叫 小鬼叫 邪祟吓得跌倒 [01:16.73]该用什么清扫 锣鼓鞭炮 [01:20.58] [01:21.30]小孩儿 快来瞧 别再人堆胡闹 [01:24.85] [01:25.43]只有听话乖巧 来年才能长高 [01:29.08] [01:30.21]和纸浆 采朱砂 攒一摞春联叠好 [01:34.25]剪金花 染红料 [01:36.24]再糊一个四方小包 [01:37.98] [01:38.56]对花调 抄童谣 写一串吉祥安好 [01:42.51]扶正了封面 画上春来到 [01:46.14]一片翠色葱葱明快又跳跃 [01:50.13]几瓣海棠山茶花儿相映笑 [01:54.29]再蘸浓墨潦草添只燕子闹 [01:58.48]红绳绕 来封一个大红包 [02:02.83] [02:19.34]找一张晒烫的板凳歇脚 [02:22.80] [02:23.58]看你眼下又布满操劳 [02:27.59]编织橙黄蓝绿把烦恼全部忘掉 [02:32.00] [02:32.65]抬手捧一把红枣 [02:34.70] [02:35.97]骗怕生的小妹点灯睡觉 [02:40.05]会有鬼祟在夜晚来到 [02:43.55] [02:44.13]她慌张 我偷笑 连说不怕不怕 [02:50.16]让我去赶跑 [02:52.62] [02:55.34]左搭肩 右帮腔 [02:57.19]挤兑迟来的大忙人 [02:59.59]礼物未到 人怎能到 [03:03.02] [03:03.62]表嫂吵 大舅闹 连天地喳喳叫 [03:07.03] [03:07.71]我装作听不到 盘坐把碗沿敲 [03:11.35] [03:12.37]踩高跷 抓花包 撩一挂红衣鞭炮 [03:16.52]打年糕 串辣椒 [03:18.59]抹花我的胭脂粉膏 [03:20.67]侃八卦 讲小道 等杯中茶酒减少 [03:24.79]将手上红包 塞进你棉袄 [03:28.05] [03:28.60]你送吉祥如意 幸福快来到 [03:32.57]我送百年顺遂 不怕被火烧 [03:36.57]再求来年生辰 添一分美貌 [03:40.74]拱手摇 同鞠一躬对眼笑 [03:44.55] [03:47.29]小麦面包饺 喜色上眉梢 [03:51.29]点柳翠 画春晓 [03:55.45]找旧样铜板穿一串吉兆 [03:59.58]把春意赠与明朝 [04:03.12] [04:04.16]左搭肩 右帮腔 热闹话不见少 [04:08.24]你来蒸 我来挑 塞满嘴的玉米包 [04:12.41]干柴烧 火焰高 烦心事已寥寥 [04:16.05] [04:16.66]眯眼瞧 把红包塞进你棉袄 [04:20.59]一片翠色葱葱 明快又跳跃 [04:24.66]几瓣海棠山茶 花儿相映笑 [04:28.80]封着吉祥如意 幸福快来到 [04:32.97]红绳绕 拆开春意大红包 var ap = new APlayer({ element: document.getElementById("aplayer4"), narrow: false, autoplay: false, showlrc: 2, music: { title: "春意红包", author: "三无MarBlue,祖娅纳惜,泠鸢yousa", url: "http://p4lmrb1gp.bkt.clouddn.com/%E4%B8%89%E6%97%A0MarBlue,%E7%A5%96%E5%A8%85%E7%BA%B3%E6%83%9C,%E6%B3%A0%E9%B8%A2yousa%20-%20%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 播放列表123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; "narrow": false, // Optional, narrow style "autoplay": true, // Optional, autoplay song(s), not supported by mobile browsers "mode": "random", // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` "showlrc": 3, // Optional, show lrc, can be 1, 2, 3 "mutex": true, // Optional, pause other players when this player playing "theme": "#e6d0b2", // Optional, theme color, default: #b7daff "preload": "metadata", // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' "listmaxheight": "513px", // Optional, max height of play list "music": [ &#123; "title": "CoCo", "author": "Jeff Williams", "url": "caffeine.mp3", "pic": "caffeine.jpeg", "lrc": "caffeine.txt" &#125;, &#123; "title": "アイロニ", "author": "鹿乃", "url": "irony.mp3", "pic": "irony.jpg" &#125; ]&#125;&#123;% endaplayerlist %&#125; 插入视频：video 标签： 123&lt;video src="http://lxqncdn.miaopai.com/stream/BvmaXK2X49guVi4ehlOjjQ__.mp4" width="100%" height="100%" controls="controls"&gt;Your browser does not support the video tag.&lt;/video&gt; embed标签： 1&lt;embed src="http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA==/v.swf" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" allowFullScreen="true" mode="transparent" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; iframe标签： 1&lt;iframe height=498 width=510 src="http://player.youku.com/embed/XMTY1MTI3NjMyNA==" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
