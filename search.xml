<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-2%2F</url>
    <content type="text"><![CDATA[#]]></content>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机 知识点总结&面试题]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-1%2F</url>
    <content type="text"><![CDATA[1. 内存模型以及分区，需要详细到每个区放什么。 运行时数据区域：虚拟机栈，本地方法栈，程序计数器，堆，方法区，具体如图所示： 程序计数器： 线程私有的，他是一块较小的内存空间，他相当字节码于解释器中的指针，也就是该内存存放下一条即将执行指令的地址。字节码解释器就是通过改变 这个计数器的值来选择下一条即将执行的指令。每一个线程都有一个程序计数器（内存），这样线程切换的时候就能找到自己各个线程各自即将执行的下一条指令。 所以说是线程私有的。 java 虚拟机栈： 线程私有的，每一个方法在执行的时候就会创建一个栈帧来存放方法的局部变量，操作数栈，返回地址等，当方法执行完成的时候就释放该栈帧。栈帧: 虚拟机栈中是一栈帧为单位存储的，所以一个虚拟机栈中有很多栈帧，每一个栈帧中分为：局部变量区（存放方法的参数和局部变量），操作数栈，方法的返回地址，动态链接（一般解析解阶段是将部分符号引用转换成直接应用（类加载），而动态链接是另外一部分的符号引用转换成直接引用（运行时）） 本地方法栈： 线程私有，本地方法指的是那种不是用 java 语言写的方法，java 虚拟机栈只针 java 方法，而不是本地方法。hotspot 虚拟机支持别的语言写的方法在虚拟机上运行，本法方法栈和 java 虚拟机栈一样。只是他们服务的对象不一样而已，一个为 java 方法服务，一个为 native 方法服务。 Java 堆： 线程共享的，不过也可能为多个线程分配私有的 buffer，也就是每个线程有自己的缓存器，java 堆可以是物理上连续的，也可以是不连续的。java 堆是垃圾回收器管理的主要区域，所以也叫 gc 堆。java 堆可以分为：新生代和老年代 方法区： 线程共享的，可以理解为 gcc 中所所说的静态区，不过也不是确切的准确，因为在 hotspot 虚拟机中他存放的是类中静态变量和常量（注意是常量哦）。因为他能存储常量，所以还有存储常量的区域有一个特别的名称，叫做常量池（包括引用和基本数据类型的常量），方法区并不是堆，这一点和静态区很相似。所以别名叫 non-heap，java 堆中可以选择不实现 gc 回收，但是实际上呢还是会的，只能说垃圾回收器在这个区域不活跃而已，但是回收都是回收常量池中的常量，而不是静态变量。可以称为永久代。 运行时常量池： 他是方法区的一部分，但是和方法区的常量池有区别，他存放的常量是在运行时产生的，而不是编译时产生的。注意与普通方法区的区别 2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。 Eden 区的对象都是朝生夕死，发生 minor gc 的时候会清除 eden 区和 survival 区的，把存活的对象移到另一个 Survival 区，该 survial 区由老年代保证。当在年轻代中对象经过多次 minor gc 以后还存活，达到老年代的年纪，就会移动到老年代，还有就是大对象在年轻代无法存储，直接转到老年代，还有可能因为担保而进入老年代的 3. 对象创建方法，对象的内存分配，对象的访问定位 1 对象的创建包括三步骤： ①当遇到 new 命令的时候，会在常量池中检查该对象的符号引用是否存在，不存在则进行类的加载，否则执行下一步 ②分配内存，将将要分配的内存都清零。 ③虚拟机进行必要的设置，如设置 hashcode，gc 的分代年龄等，此时会执行命令在执行之前所有的字段都为 0，执行指令以后，安装程序的意愿进行初始化字段。 2：对象的内存分配：包括对象头，实例数据，对齐填充 ①对象头: 包括对象的 hascode，gc 分代年龄，锁状态标等。 ②实例数据: 也就是初始化以后的对象的字段的内容，包括父类中的字段等 ③对齐填充：对象的地址是 8 字节，虚拟机要求对象的大小是对象的整数倍 (1 倍或者两倍)。因此就会有空白区。 3：对象的访问： hotspan 中 是采用对象直接指向对象地址的方式（这样的方式访问比较快）（还有一种方式就是句柄，也就是建一张表维护各个指向各个地址的指针，然后给指针设置一个句柄 （别名），然后引用直接指向这个别名，就可以获得该对象，这种的优势就是，实例对象地址改变了，只要修改句柄池中的指针就可以了，而不用引用本身不会发生 改变）。 4.GC 的两种判别方法：引用计数于引用链 引用计数 给一个对象设置一个计数器，当被引用一次就加 1，当引用失效的时候就减 1，如果该对象长时间保持为 0 值，则该对象将被标记为回收。优点：算法简单，效率高，缺点：很难解决对象之间的相互循环引用问题。 引用链： 现在主流的 gc 都采用可达性分析算法来判断对象是否已经死亡。可达性分析：通过一系列成为 GC Roots 的对象作为起点，从这些起点向下搜索，搜索所走过的路径成为引用链，当一个对象到引用链没有相连时，则判断该对象已经死亡。 可作为 gc roots 的对象： 虚拟机栈（本地方法表）中引用的对象（因为在栈内，被线程引用），方法区中类静态属性引用的对象，方法区中常量引用的（常量存放在常量池中，常量池是方法区的一部分）对象，native 方法引用的对象 引用计数和引用链是只是用来标记，判断一个对象是否失效，而不是用来清除 5.GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？ 标记清除： 直接将要回收的对象标记，发送 gc 的时候直接回收：特点回收特别快，但是回收以后会造成很多不连续的内存空间，因此适合在老年代进行回收，CMS(current mark-sweep)，就是采用这种方法来会后老年代的。 标记整理： 就是将要回收的对象移动到一端，然后再进行回收，特点：回收以后的空间连续，缺点：整理要花一定的时间，适合老年代进行会后，parallel Old（针对 parallel scanvange gc 的） gc 和 Serial old 就是采用该算法进行回收的。 复制算法： 将内存划分成原始的是相等的两部分，每次只使用一部分，这部分用完了，就将还存活的对象复制到另一块内存，将要回收的内存全部清除。这样只要进行少量的赋值就能够完成收集。比较适合很多对象的回收，同时还有老年代对其进行担保。（serial new 和 parallel new 和 parallel scanvage） 优化手机方法： 优化收集方法：对复制算法的优化：并不是将两块内存分配同等大小，可以将存活率低的区域大一些，而让回收后存活的对象所占的区域小一些，不够的内存由老年代的内存来保证，这样复制算法的空闲的空间减少了。两个 survival 区域的是为了减少风险率，有一个 survivor 区要参与回收，也要参与存储，只要只有 10% 的空间浪费，同时也减少对老年代的依赖。 6.GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。 串行的，也就是采用单线程（比较老了），分类：serial new（收集年轻代，复制算法）和 serial old（收集老年代，标记整理），缺点：单线程，进行垃圾回收时暂时所有的用户线程。优点：实现简单。 并行的，采用多线程，对于年轻代有两个： parallel new（简称 ParNew）（参考 serial new 的多线程版本）和 parallel scavenge；parallel scavenge 是一个针对年轻代的垃圾回收器，采用复制算法，主要的优点是进行垃圾回收时不会停止用户线程（不会发生 stop all world）老年代回收器也有两种：Parallel old 是 parallel scavenge 的我老年代设计的。CMS（并发标记清除），他采用标记清除算法，采用这种的优点就是快咯，因此会尽快的进行回收，减少停顿时间。 高级杀手：G1 收集器，年轻代和老年代通吃，最新一代的技术。面向服务器端的垃圾收集器（并行 + 并发的垃圾收集器）。 7.Minor GC 与 Full GC 分别在什么时候发生? Minor GC 发生：当 jvm 无法为新的对象分配空间的时候就会发生 minor gc，所以分配对象的频率越高，也就越容易发生 minor gc。 Full GC：发生 GC 有两种情况，①当老年代无法分配内存的时候，会导致 MinorGC,②当发生 Minor GC 的时候可能触发 Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不能清除自己要担保多少空间，因此采取采用动态估算的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次 Minor GC 以后，存活的对象剧增（假设小对象），此时老年代并没有满，但是此时平均值增加了，会造成发生 Full GC 8. 类加载的五个过程：加载、验证、准备、解析、初始化。 加载： 加载有两种情况，①当遇到 new 关键字，或者 static 关键字的时候就会发生（他们对应着对应的指令）如果在常量池中找不到对应符号引用时，就会发生加载 ，②动态加载，当用反射方法（如 class.forName(“类名”)），如果发现没有初始化，则要进行初始化。（注：加载的时候发现父类没有被加载，则要先加载父类） 验证： 这一阶段的目的是确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全（虽然编译器会严格的检查 java 代码并生成 class 文件，但是 class 文件不一定都是通过编译器编译，然后加载进来的，因为虚拟机获取 class 文件字节流的方式有可能是从网络上来的，者难免不会存在有人恶意修改而造成系统崩溃的问题，class 文件其实也可以手写 16 进制，因此这是必要的） 准备： 该阶段就是为对象分派内存空间，然后初始化类中的属性变量，但是该初始化只是按照系统的意愿进行初始化，也就是初始化时都为 0 或者为 null。因此该阶段的初始化和我们常说初始化阶段的初始化时不一样的 解析： 解析就是虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用其实就是 class 文件常量池中的各种引用，他们按照一定规律指向了对应的类名，或者字段，但是并没有在内存中分配空间，因此符号因此就理解为一个标示，而在直接引用直接指向内存中的地址 初始化： 简单讲就是执行对象的构造函数，给类的静态字段按照程序的意愿进行初始化，注意初始化的顺序。（此处的初始化由两个函数完成，一个是, 初始化所有的类变量（静态变量），该函数不会初始化父类变量，还有一个是实例初始化函数, 对类中实例对象进行初始化，此时要如果有需要，是要初始化父类的） 9. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。 类 加载器的工作过程：如果一个类加载器收到类类加载的请求，他首先不会自己去加载这个类，而是把类委派个父类加载器去完成，因此所有的请求最终都会传达到顶 层的启动类加载器中，只有父类反馈无法加载该类的请求（在自己的搜索范围类没有找到要加载的类）时候，子类才会试图去加载该类。 10. 分派：静态分派与动态分派: 静态分派和动态分派都是多态的内容，多态的实现依赖于编译阶段和运行时阶段：在编译阶段主要表现在静态分派， 静态分派就是通过静态类型和方法参数个数来选择哪一个方法版本，这就是主要体现了方法的重载；因为他在编译的时候就能确定调用哪一个函数，所以叫静态分派。 在运行时阶段体现在动态分派（动态绑定），也就是当一个父类引用指向子类对象，通过该父类引用去调用一个该方法，由于在编译阶段生产的调用函数代码的字节码指向的是父类（静态类型）被调用方法，并不知道具体要去调用哪一个实际类型的方法，因 此会发生这样一个过程，虚拟机找到操作数栈中位于栈顶获取该操作数的指所指向的类，然后到常量池中去搜索与被调用的方法匹配的方法名和描述符，如果找到， 就进行权限校验（校验失败就抛出异常），如果可以访问，则返回该方法的符号引用，并转换成直接引用，调用该执行，如果找不到就到父类中去找，然后重复上面 动作，最后找不到就抛出异常。 对动态绑定的优化：由于要去常量池中搜索每一类的方法名和描述符，因此效率比较低，所以最后进行了优化，就是在方法区为每一类维护一张虚方法表或者接口方 法表（虚表中存放了该方法的实际入口地址），让该类的所有方法都维护进去（包括父类的方法），因此要查找方法名的时候，直接去该虚表中去搜索到该方法名对 应的直接地址然后执行。对于没有被重写的方法，直接存放父类的入口地址，如果该方法被重写，在存放子类的方法入口地址。 参考:http://blog.csdn.net/qq_30000411/article/details/60334051 JDK 是什么 JRE 是什么 Java 历史版本的特性 Java Version SE 50 Java Version SE 6 Java Version SE 7 Java 8 运行时数据区域包括哪些 程序计数器线程私有 Java 虚拟机栈线程私有 本地方法栈线程私有 Java 堆线程共享 方法区线程共享 运行时常量池 Java 中对象访问是如何进行的 如何判断对象是否死去 什么是引用计数法 引用计数法的缺点 什么是根搜索算法 Java 的 4 种引用方式 强引用 软引用 弱引用 虚引用 有哪些垃圾收集算法 标记 - 清除算法 Mark-Sweep 什么是标记 - 清除算法 有什么缺点 复制算法 Copying- 新生代 优点 缺点 应用 标记 - 整理算法 Mark-Compact - 老年代 分代收集算法 Minor GC 和 Full GC 有什么区别 Java 内存 为什么要将堆内存分区 堆内存分为哪几块 分代收集算法 内存分配有哪些原则 Young Generation Space 采用复制算法 Tenure Generation Space 采用标记 - 整理算法 Permanent Space Class 文件 Java 虚拟机的平台无关性 Class 文件的组成 魔数与 Class 文件的版本 类加载器 类加载器的作用是什么 类加载器有哪些 类加载机制 什么是双亲委派模型 为什么要使用双亲委派模型组织类加载器之间的关系 什么是类加载机制 虚拟机和物理机的区别是什么 运行时栈帧结构 Java 方法调用 什么是方法调用 Java 的方法调用有什么特殊之处 Java 虚拟机调用字节码指令有哪些 虚拟机是如何执行方法里面的字节码指令的 解释执行 基于栈的指令集和基于寄存器的指令集 什么是基于栈的指令集 什么是基于寄存器的指令集 基于栈的指令集的优缺点 Javac 编译过程分为哪些步骤 什么是即时编译器 解释器和编译器 为什么要采用分层编译 分层编译器有哪些层次 编译对象与触发条件 热点代码有哪些 如何判断一段代码是不是热点代码 HotSpot 虚拟机使用第二种有两个计数器 方法调用计数器统计方法 有哪些经典的优化技术即时编译器 公共子表达式消除 数组边界检查消除 方法内联 逃逸分析 如果对象不会逃逸到方法或线程外可以做什么优化 Java 与 CC 的编译器对比 物理机如何处理并发问题 Java 内存模型 什么是 Java 内存模型 Java 内存模型的目标 主内存与工作内存 内存间的交互操作 原子性可见性有序性 volatile 什么是 volatile 为什么基于 volatile 变量的运算在并发下不一定是安全的 为什么使用 volatile 并发与线程 并发与线程的关系 什么是线程 实现线程有哪些方式 Java 线程的实现 Java 线程调度 什么是线程调度 线程调度有哪些方法 线程安全的定义 Java 语言操作的共享数据包括哪些 不可变 如何实现线程安全 阻塞同步互斥同步 非阻塞同步 锁优化是在 JDK 的那个版本 为什么要提出自旋锁 自旋锁的原理 自旋的缺点 什么是自适应自旋 锁消除 锁粗化 轻量级锁 偏向锁 JDK 是什么？JDK 是用于支持 Java 程序开发的最小环境。 Java 程序设计语言 Java 虚拟机 Java API 类库 JRE 是什么？JRE 是支持 Java 程序运行的标准环境。 Java SE API 子集 Java 虚拟机 Java 历史版本的特性？Java Version SE 5.0 引入泛型； 增强循环，可以使用迭代方式； 自动装箱与自动拆箱； 类型安全的枚举； 可变参数； 静态引入； 元数据（注解）； 引入 Instrumentation。 Java Version SE 6 支持脚本语言； 引入 JDBC 4.0 API； 引入 Java Compiler API； 可插拔注解； 增加对 Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos 和 LDAP(Lightweight Directory Access Protocol) 的支持； 继承 Web Services； 做了很多优化。 Java Version SE 7 switch 语句块中允许以字符串作为分支条件； 在创建泛型对象时应用类型推断； 在一个语句块中捕获多种异常； 支持动态语言； 支持 try-with-resources； 引入 Java NIO.2 开发包； 数值类型可以用 2 进制字符串表示，并且可以在字符串表示中添加下划线； 钻石型语法； null 值的自动处理。 Java 8 函数式接口 Lambda 表达式 接口的增强 运行时数据区域包括哪些？ 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 运行时常量池 直接内存 程序计数器（线程私有）程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。 由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。 如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址； 如果正在执行的是 Native 方法，这个计数器的值为空。 程序计数器是唯一一个没有规定任何 OutOfMemoryError 的区域。 Java 虚拟机栈（线程私有）Java 虚拟机栈（Java Virtual Machine Stacks）是线程私有的，生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame），存储 局部变量表 操作栈 动态链接 方法出口 每一个方法被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 这个区域有两种异常情况： StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度 OutOfMemoryError：虚拟机栈扩展到无法申请足够的内存时 本地方法栈（线程私有）虚拟机栈为虚拟机执行 Java 方法（字节码）服务。 本地方法栈（Native Method Stacks）为虚拟机使用到的 Native 方法服务。 Java 堆（线程共享）Java 堆（Java Heap）是 Java 虚拟机中内存最大的一块。Java 堆在虚拟机启动时创建，被所有线程共享。 作用：存放对象实例。垃圾收集器主要管理的就是 Java 堆。Java 堆在物理上可以不连续，只要逻辑上连续即可。 方法区（线程共享）方法区（Method Area）被所有线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和 Java 堆一样，不需要连续的内存，可以选择固定的大小，更可以选择不实现垃圾收集。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。保存 Class 文件中的符号引用、翻译出来的直接引用。运行时常量池可以在运行期间将新的常量放入池中。 Java 中对象访问是如何进行的？1Object obj = new Object(); 对于上述最简单的访问，也会涉及到 Java 栈、Java 堆、方法区这三个最重要内存区域。 1Object obj 如果出现在方法体中，则上述代码会反映到 Java 栈的本地变量表中，作为 reference 类型数据出现。 1new Object() 反映到 Java 堆中，形成一块存储了 Object 类型所有对象实例数据值的内存。Java 堆中还包含对象类型数据的地址信息，这些类型数据存储在方法区中。 如何判断对象是否 “死去”？ 引用计数法 根搜索算法 什么是引用计数法？给对象添加一个引用计数器，每当有一个地方引用它，计数器就 + 1,；当引用失效时，计数器就 - 1；任何时刻计数器都为 0 的对象就是不能再被使用的。 引用计数法的缺点？很难解决对象之间的循环引用问题。 什么是根搜索算法？通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。 Java 的 4 种引用方式？在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为 强引用 Strong Reference 软引用 Soft Reference 弱引用 Weak Reference 虚引用 Phantom Reference 强引用1Object obj = new Object(); 代码中普遍存在的，像上述的引用。只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。 软引用用来描述一些还有用，但并非必须的对象。软引用所关联的对象，有在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围，并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存异常。提供了 SoftReference 类实现软引用。 弱引用描述非必须的对象，强度比软引用更弱一些，被弱引用关联的对象，只能生存到下一次垃圾收集发生前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。提供了 WeakReference 类来实现弱引用。 虚引用一个对象是否有虚引用，完全不会对其生存时间够成影响，也无法通过虚引用来取得一个对象实例。为一个对象关联虚引用的唯一目的，就是希望在这个对象被收集器回收时，收到一个系统通知。提供了 PhantomReference 类来实现虚引用。 有哪些垃圾收集算法？ 标记 - 清除算法 复制算法 标记 - 整理算法 分代收集算法 标记 - 清除算法（Mark-Sweep）什么是标记 - 清除算法？分为标记和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。 有什么缺点？1. 效率问题。标记和清除过程的效率都不高。2. 空间问题。标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致，程序分配较大对象时无法找到足够的连续内存，不得不提前出发另一次垃圾收集动作。 复制算法（Copying）- 新生代将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。 优点？复制算法使得每次都是针对其中的一块进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点？将内存缩小为原来的一半。在对象存活率较高时，需要执行较多的复制操作，效率会变低。 应用？商业的虚拟机都采用复制算法来回收新生代。因为新生代中的对象容易死亡，所以并不需要按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。每次使用 Eden 和其中的一块 Survivor。 当回收时，将 Eden 和 Survivor 中还存活的对象一次性拷贝到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。Hotspot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80% + 10%），只有 10% 的内存是会被 “浪费” 的。 标记 - 整理算法（Mark-Compact）- 老年代标记过程仍然与 “标记 - 清除” 算法一样，但不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。 分代收集算法根据对象的存活周期，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点，采用最适当的收集算法。 新生代：每次垃圾收集时会有大批对象死去，只有少量存活，所以选择复制算法，只需要少量存活对象的复制成本就可以完成收集。 老年代：对象存活率高、没有额外空间对它进行分配担保，必须使用 “标记 - 清理” 或 “标记 - 整理” 算法进行回收。 Minor GC 和 Full GC 有什么区别？Minor GC：新生代 GC，指发生在新生代的垃圾收集动作，因为 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般回收速度较快。Full GC：老年代 GC，也叫 Major GC，速度一般比 Minor GC 慢 10 倍以上。 Java 内存为什么要将堆内存分区？对于一个大型的系统，当创建的对象及方法变量比较多时，即堆内存中的对象比较多，如果逐一分析对象是否该回收，效率很低。分区是为了进行模块化管理，管理不同的对象及变量，以提高 JVM 的执行效率。 堆内存分为哪几块？ Young Generation Space 新生区（也称新生代） Tenure Generation Space 养老区（也称旧生代） Permanent Space 永久存储区 分代收集算法内存分配有哪些原则？ 对象优先分配在 Eden 大对象直接进入老年代 长期存活的对象将进入老年代 动态对象年龄判定 空间分配担保 Young Generation Space （采用复制算法）主要用来存储新创建的对象，内存较小，垃圾回收频繁。这个区又分为三个区域：一个 Eden Space 和两个 Survivor Space。 当对象在堆创建时，将进入年轻代的 Eden Space。 垃圾回收器进行垃圾回收时，扫描 Eden Space 和 A Suvivor Space，如果对象仍然存活，则复制到 B Suvivor Space，如果 B Suvivor Space 已经满，则复制 Old Gen 扫描 A Suvivor Space 时，如果对象已经经过了几次的扫描仍然存活，JVM 认为其为一个 Old 对象，则将其移到 Old Gen。 扫描完毕后，JVM 将 Eden Space 和 A Suvivor Space 清空，然后交换 A 和 B 的角色（即下次垃圾回收时会扫描 Eden Space 和 B Suvivor Space。 Tenure Generation Space（采用标记 - 整理算法）主要用来存储长时间被引用的对象。它里面存放的是经过几次在 Young Generation Space 进行扫描判断过仍存活的对象，内存较大，垃圾回收频率较小。 Permanent Space存储不变的类定义、字节码和常量等。 Class 文件Java 虚拟机的平台无关性 Class 文件的组成？Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目间没有任何分隔符。当遇到 8 位字节以上空间的数据项时，则会按照高位在前的方式分隔成若干个 8 位字节进行存储。 魔数与 Class 文件的版本每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的 Class 文件。OxCAFEBABE。 接下来是 Class 文件的版本号：第 5,6 字节是次版本号（Minor Version），第 7,8 字节是主版本号（Major Version）。 使用 JDK 1.7 编译输出 Class 文件，格式代码为： 前四个字节为魔数，次版本号是 0x0000，主版本号是 0x0033，说明本文件是可以被 1.7 及以上版本的虚拟机执行的文件。 33：JDK1.7 32：JDK1.6 31：JDK1.5 30：JDK1.4 2F：JDK1.3 类加载器类加载器的作用是什么？类加载器实现类的加载动作，同时用于确定一个类。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。即使两个类来源于同一个 Class 文件，只要加载它们的类加载器不同，这两个类就不相等。 类加载器有哪些？ 启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现（仅限于 HotSpot），是虚拟机自身的一部分。负责将存放在 \lib 目录中的类库加载到虚拟机中。其无法被 Java 程序直接引用。 扩展类加载器（Extention ClassLoader）由 ExtClassLoader 实现，负责加载 \lib\ext 目录中的所有类库，开发者可以直接使用。 应用程序类加载器（Application ClassLoader）：由 APPClassLoader 实现。负责加载用户类路径（ClassPath）上所指定的类库。 类加载机制什么是双亲委派模型？双亲委派模型（Parents Delegation Model）要求除了顶层的启动类加载器外，其余加载器都应当有自己的父类加载器。类加载器之间的父子关系，通过组合关系复用。工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有到父加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，子加载器才会尝试自己去加载。 为什么要使用双亲委派模型，组织类加载器之间的关系？Java 类随着它的类加载器一起具备了一种带优先级的层次关系。比如 java.lang.Object，它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此 Object 类在程序的各个类加载器环境中，都是同一个类。 如果没有使用双亲委派模型，让各个类加载器自己去加载，那么 Java 类型体系中最基础的行为也得不到保障，应用程序会变得一片混乱。 什么是类加载机制？Class 文件描述的各种信息，都需要加载到虚拟机后才能运行。虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 虚拟机和物理机的区别是什么？这两种机器都有代码执行的能力，但是： 物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面的。 虚拟机的执行引擎是自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。 运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构， 存储了方法的 局部变量表 操作数栈 动态连接 方法返回地址 每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 Java 方法调用什么是方法调用？方法调用唯一的任务是确定被调用方法的版本（调用哪个方法），暂时还不涉及方法内部的具体运行过程。 Java 的方法调用，有什么特殊之处？Class 文件的编译过程不包含传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这使得 Java 有强大的动态扩展能力，但使 Java 方法的调用过程变得相对复杂，需要在类加载期间甚至到运行时才能确定目标方法的直接引用。 Java 虚拟机调用字节码指令有哪些？ invokestatic：调用静态方法 invokespecial：调用实例构造器方法、私有方法和父类方法 invokevirtual：调用所有的虚方法 invokeinterface：调用接口方法 虚拟机是如何执行方法里面的字节码指令的？解释执行（通过解释器执行）编译执行（通过即时编译器产生本地代码） 解释执行当主流的虚拟机中都包含了即时编译器后，Class 文件中的代码到底会被解释执行还是编译执行，只有虚拟机自己才能准确判断。 Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译是半独立的实现。 基于栈的指令集和基于寄存器的指令集什么是基于栈的指令集？Java 编译器输出的指令流，里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。 计算 “1+1=2”，基于栈的指令集是这样的： 1234iconst_1iconst_1iaddistore_0 两条 iconst_1 指令连续地把两个常量 1 压入栈中，iadd 指令把栈顶的两个值出栈相加，把结果放回栈顶，最后 istore_0 把栈顶的值放到局部变量表的第 0 个 Slot 中。 什么是基于寄存器的指令集？最典型的是 x86 的地址指令集，依赖寄存器工作。计算 “1+1=2”，基于寄存器的指令集是这样的： 12mov eax, 1add eax, 1 mov 指令把 EAX 寄存器的值设为 1，然后 add 指令再把这个值加 1，结果就保存在 EAX 寄存器里。 基于栈的指令集的优缺点？优点： 可移植性好：用户程序不会直接用到这些寄存器，由虚拟机自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存）放到寄存器以获取更好的性能。 代码相对紧凑：字节码中每个字节就对应一条指令 编译器实现简单：不需要考虑空间分配问题，所需空间都在栈上操作 缺点： 执行速度稍慢 完成相同功能所需的指令熟练多 频繁的访问栈，意味着频繁的访问内存，相对于处理器，内存才是执行速度的瓶颈。 Javac 编译过程分为哪些步骤？ 解析与填充符号表 插入式注解处理器的注解处理 分析与字节码生成 什么是即时编译器？Java 程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为 “热点代码”（Hot Spot Code）。 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器成为即时编译器（Just In Time Compiler，JIT 编译器）。 解释器和编译器许多主流的商用虚拟机，都同时包含解释器和编译器。 当程序需要快速启动和执行时，解释器首先发挥作用，省去编译的时间，立即执行。 当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，可以提高执行效率。 如果内存资源限制较大（部分嵌入式系统），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时编译器的代码还能退回成解释器的代码。 为什么要采用分层编译？因为即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间越长。 分层编译器有哪些层次？分层编译根据编译器编译、优化的规模和耗时，划分不同的编译层次，包括： 第 0 层：程序解释执行，解释器不开启性能监控功能，可出发第 1 层编译。 第 1 层：也成为 C1 编译，将字节码编译为本地代码，进行简单可靠的优化，如有必要加入性能监控的逻辑。 第 2 层：也成为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。 用 Client Compiler 和 Server Compiler 将会同时工作。用 Client Compiler 获取更高的编译速度，用 Server Compiler 获取更好的编译质量。 编译对象与触发条件热点代码有哪些？ 被多次调用的方法 被多次执行的循环体 如何判断一段代码是不是热点代码？要知道一段代码是不是热点代码，是不是需要触发即时编译，这个行为称为热点探测。主要有两种方法： 基于采样的热点探测，虚拟机周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是 “热点方法”。实现简单高效，但是很难精确确认一个方法的热度。 基于计数器的热点探测，虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认为它是热点方法。 HotSpot 虚拟机使用第二种，有两个计数器： 方法调用计数器 回边计数器（判断循环代码） 方法调用计数器统计方法统计的是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器的热度衰减，这个时间就被称为半衰周期。 有哪些经典的优化技术（即时编译器）？ 语言无关的经典优化技术之一：公共子表达式消除 语言相关的经典优化技术之一：数组范围检查消除 最重要的优化技术之一：方法内联 最前沿的优化技术之一：逃逸分析 公共子表达式消除普遍应用于各种编译器的经典优化技术，它的含义是： 1如果一个表达式E已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成了公共子表达式。没有必要重新计算，直接用结果代替E就可以了。 数组边界检查消除因为 Java 会自动检查数组越界，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这无疑是一种性能负担。 如果数组访问发生在循环之中，并且使用循环变量来进行数组访问，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组区间内，那么整个循环中就可以把数组的上下界检查消除掉，可以节省很多次的条件判断操作。 方法内联内联消除了方法调用的成本，还为其他优化手段建立良好的基础。 编译器在进行内联时，如果是非虚方法，那么直接内联。如果遇到虚方法，则会查询当前程序下是否有多个目标版本可供选择，如果查询结果只有一个版本，那么也可以内联，不过这种内联属于激进优化，需要预留一个逃生门（Guard 条件不成立时的 Slow Path），称为守护内联。 如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接受者的继承关系发现变化的类，那么内联优化的代码可以一直使用。否则需要抛弃掉已经编译的代码，退回到解释状态执行，或者重新进行编译。 逃逸分析逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法里面被定义后，它可能被外部方法所引用，这种行为被称为方法逃逸。被外部线程访问到，被称为线程逃逸。 如果对象不会逃逸到方法或线程外，可以做什么优化？ 栈上分配：一般对象都是分配在 Java 堆中的，对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。但是垃圾回收和整理都会耗时，如果一个对象不会逃逸出方法，可以让这个对象在栈上分配内存，对象所占用的内存空间就可以随着栈帧出栈而销毁。如果能使用栈上分配，那大量的对象会随着方法的结束而自动销毁，垃圾回收的压力会小很多。 同步消除：线程同步本身就是很耗时的过程。如果逃逸分析能确定一个变量不会逃逸出线程，那这个变量的读写肯定就不会有竞争，同步措施就可以消除掉。 标量替换：不创建这个对象，直接创建它的若干个被这个方法使用到的成员变量来替换。 Java 与 C/C++ 的编译器对比 即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力。 Java 语言虽然没有 virtual 关键字，但是使用虚方法的频率远大于 C++，所以即时编译器进行优化时难度要远远大于 C++ 的静态优化编译器。 Java 语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，使得全局的优化难以进行，因为编译器无法看见程序的全貌，编译器不得不时刻注意并随着类型的变化，而在运行时撤销或重新进行一些优化。 Java 语言对象的内存分配是在堆上，只有方法的局部变量才能在栈上分配。C++ 的对象有多种内存分配方式。 物理机如何处理并发问题？运算任务，除了需要处理器计算之外，还需要与内存交互，如读取运算数据、存储运算结果等（不能仅靠寄存器来解决）。计算机的存储设备和处理器的运算速度差了几个数量级，所以不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache），作为内存与处理器之间的缓冲：将运算需要的数据复制到缓存中，让运算快速运行。当运算结束后再从缓存同步回内存，这样处理器就无需等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓存，它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存时，可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器访问缓存时遵循缓存一致性协议。同时为了使得处理器充分被利用，处理器可能会对输出代码进行乱序执行优化。Java 虚拟机的即时编译器也有类似的指令重排序优化。 Java 内存模型什么是 Java 内存模型？Java 虚拟机的规范，用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各个平台下都能达到一致的并发效果。 Java 内存模型的目标？定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。此处的变量包括实例字段、静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为这些是线程私有的，不会被共享，所以不存在竞争问题。 主内存与工作内存所以的变量都存储在主内存，每条线程还有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，不能直接读写主内存的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存。 内存间的交互操作一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存，Java 内存模型定义了 8 种操作： 原子性、可见性、有序性 原子性：对基本数据类型的访问和读写是具备原子性的。对于更大范围的原子性保证，可以使用字节码指令 monitorenter 和 monitorexit 来隐式使用 lock 和 unlock 操作。这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字。因此 synchronized 块之间的操作也具有原子性。 可见性：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取之前从主内存刷新变量值来实现可见性的。volatile 的特殊规则保证了新值能够立即同步到主内存，每次使用前立即从主内存刷新。synchronized 和 final 也能实现可见性。final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么其他线程中就能看见 final 字段的值。 有序性：Java 程序的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）；如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序和工作内存与主内存同步延迟线性）。 volatile什么是 volatile？关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。当一个变量被定义成 volatile 之后，具备两种特性： 保证此变量对所有线程的可见性。当一条线程修改了这个变量的值，新值对于其他线程是可以立即得知的。而普通变量做不到这一点。 禁止指令重排序优化。普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。 为什么基于 volatile 变量的运算在并发下不一定是安全的？volatile 变量在各个线程的工作内存，不存在一致性问题（各个线程的工作内存中 volatile 变量，每次使用前都要刷新到主内存）。但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。 为什么使用 volatile？在某些情况下，volatile 同步机制的性能要优于锁（synchronized 关键字），但是由于虚拟机对锁实行的许多消除和优化，所以并不是很快。 volatile 变量读操作的性能消耗与普通变量几乎没有差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 并发与线程并发与线程的关系？并发不一定要依赖多线程，PHP 中有多进程并发。但是 Java 里面的并发是多线程的。 什么是线程？线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O），又可以独立调度（线程是 CPU 调度的最基本单位）。 实现线程有哪些方式？ 使用内核线程实现 使用用户线程实现 使用用户线程 + 轻量级进程混合实现 Java 线程的实现操作系统支持怎样的线程模型，在很大程度上就决定了 Java 虚拟机的线程是怎样映射的。 Java 线程调度什么是线程调度？线程调度是系统为线程分配处理器使用权的过程。 线程调度有哪些方法？ 协同式线程调度：实现简单，没有线程同步的问题。但是线程执行时间不可控，容易系统崩溃。 抢占式线程调度：每个线程由系统来分配执行时间，不会有线程导致整个进程阻塞的问题。 虽然 Java 线程调度是系统自动完成的，但是我们可以建议系统给某些线程多分配点时间——设置线程优先级。Java 语言有 10 个级别的线程优先级，优先级越高的线程，越容易被系统选择执行。 但是并不能完全依靠线程优先级。因为 Java 的线程是被映射到系统的原生线程上，所以线程调度最终还是由操作系统说了算。如 Windows 中只有 7 种优先级，所以 Java 不得不出现几个优先级相同的情况。同时优先级可能会被系统自行改变。Windows 系统中存在一个 “优先级推进器”，当系统发现一个线程执行特别勤奋，可能会越过线程优先级为它分配执行时间。 线程安全的定义？当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。 Java 语言操作的共享数据，包括哪些？ 不可变 绝对线程安全 相对线程安全 线程兼容 线程对立 不可变在 Java 语言里，不可变的对象一定是线程安全的，只要一个不可变的对象被正确构建出来，那其外部的可见状态永远也不会改变，永远也不会在多个线程中处于不一致的状态。 如何实现线程安全？虚拟机提供了同步和锁机制。 阻塞同步（互斥同步） 非阻塞同步 阻塞同步（互斥同步）互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。Java 中最基本的同步手段就是 synchronized 关键字，其编译后会在同步块的前后分别形成 monitorenter 和 monitorexit 两个字节码指令。这两个字节码都需要一个 Reference 类型的参数指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那么这个对象就是 Reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去获取对应的对象实例或 Class 对象作为锁对象。在执行 monitorenter 指令时，首先要尝试获取对象的锁。 如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器 + 1；当执行 monitorexit 指令时将锁计数器 - 1。当计数器为 0 时，锁就被释放了。 如果获取对象失败了，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。 除了 synchronized 之外，还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步。ReentrantLock 比 synchronized 增加了高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，对处理执行时间非常长的同步块很有用。 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的。 非阻塞同步互斥同步最大的问题，就是进行线程阻塞和唤醒所带来的性能问题，是一种悲观的并发策略。总是认为只要不去做正确的同步措施（加锁），那就肯定会出问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。 锁优化是在 JDK 的那个版本？JDK1.6 的一个重要主题，就是高效并发。HotSpot 虚拟机开发团队在这个版本上，实现了各种锁优化： 适应性自旋 锁消除 锁粗化 轻量级锁 偏向锁 为什么要提出自旋锁？互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来很大压力。同时很多应用共享数据的锁定状态，只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。先不挂起线程，等一会儿。 自旋锁的原理？如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，让后面请求锁的线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放。为了让线程等待，我们只需让线程执行一个忙循环（自旋）。 自旋的缺点？自旋等待本身虽然避免了线程切换的开销，但它要占用处理器时间。所以如果锁被占用的时间很短，自旋等待的效果就非常好；如果时间很长，那么自旋的线程只会白白消耗处理器的资源。所以自旋等待的时间要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，那就应该使用传统的方式挂起线程了。 什么是自适应自旋？自旋的时间不固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果一个锁对象，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行，那么虚拟机认为这次自旋仍然可能成功，进而运行自旋等待更长的时间。 如果对于某个锁，自旋很少成功，那在以后要获取这个锁，可能省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机也会越来越聪明。 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。 程序员怎么会在明知道不存在数据竞争的情况下使用同步呢？很多不是程序员自己加入的。 锁粗化原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。 锁粗化就是增大锁的作用域。 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 偏向锁消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。即在无竞争的情况下，把整个同步都消除掉。这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。 参考：http://blog.csdn.net/yano_nankai/article/details/50957578#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95mark-compact-%E8%80%81%E5%B9%B4%E4%BB%A3 待阅读：http://blog.csdn.net/maydaysar/article/details/56839617https://my.oschina.net/lock0818/blog/1502746https://www.jianshu.com/p/54eb60cfa7bdhttp://www.bijishequ.com/detail/397600?p=https://juejin.im/post/5a72d8136fb9a01cb9133c39https://github.com/devnan/java-studyhttp://www.importnew.com/23792.htmlhttp://blog.csdn.net/hipilee/article/details/78487848http://blog.csdn.net/hsk256/article/details/49104955 GC(垃圾处理机制)面试题: http://blog.csdn.net/nysyxxg/article/details/8789358http://blog.csdn.net/alwaystiys/article/details/22279181http://blog.csdn.net/nysyxxg/article/details/8789358 印象笔记中关于jvm的总结：待整理]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据分析准备：scratch编程教育活动]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12%2F</url>
    <content type="text"><![CDATA[目的：从各个维度全方位地反映本次活动的成果。 活动前需要设计的数据采集点：统计本次活动学生参与总人数，总代码量。 参赛人群分析：地区占比，性别占比，年级占比，学校占比。 活动分析：点赞数，浏览数，参赛作品提交时间段分析，新增用户比（与往期活动纵向对比） 作品分析：关键在于如何确定优秀作品（计算思维评分和榜单排名（总点击量，总收藏量、权重用户收藏量，权重用户点击量）综合考虑），点赞排名，收藏排名，作品tags（在比赛中作品标签类别属于必填项，对于没有标记tags的作品，通过机器学习进行分类？？）类型比重分析，作品改编树关系网络分析 参赛学校分析：学校数据加权分析（需要获取参与其中的学校名单列表，对同一学校的所有作品的点赞数之和、浏览数之和进行排名）、学校总人数参与比重（需要获取当前学校学生总数）、教师参与度（本次活动指导教师占全体教师的比重，需要获取学校教师数量），学校之间距离远近（不是直线距离而是实际交通距离）与学校之间参与度之间的关系（互助，竞争关系？），学生作品水平与当地教育水平分布图（经济情况，教育机构分布情况，交通情况）之间的关系 学生分析：重点分析作品评分高，点赞排名和收藏排名靠前的学生群体（权重用户），建立这些学生之间的关系网络模型，分析该学生对不同作品的投稿数，确定用户画像（兴趣、爱好，创造性等指标，宏观分析用户编程习惯特征），横向对比同一班级的学生之间的兴趣爱好分布情况 班级分析：建立班级和教师关系模型，比如同一个老师教的不同班级学生（需要获取教师教课表（每名教师所带的班级统计信息）），班级课内学习成绩关系和活动参与程度的关系图（了解scratch编程是否有助于提高学生的学习能力，这个需要在时间上纵向开展，跟踪分析）。 教师分析：对相同指导教师的作品的统计分析：如作品整体水平、质量（点赞数，浏览数），建立优秀指导教师（优秀作品排名）之间（需要完善个人信息：教师年龄，性别）的关系网络分析模型 统计编程用时：这里需要增加一个统计学生累计编程时长的字段（有效时长指处于编程界面下鼠标键盘有操作的情况下）。后续功能可以累计增加经验值。 作品转化率：作品a被改编的次数/作品a被浏览次数 针对首次编程周活动统计中的问题提出的建议： 提交作品请不要使用“新项目”等默认名称 提交作品请选择作品标签类型（使用复选框，并增加提示信息） 请用户完善个人信息：性别，年级，生日，兴趣爱好（至少填写一个兴趣爱好，为了便于统计这个可以使用多选的方式进行填写，作为构建用户画像的参考之一） 明确本次参与活动是以第一学校还是第二课堂学校作为入口，老师要明确告知学生提交作品时所选的班级。 最终，宏观统计：总数aa个学校的bb个学生在累计yy小时创作了zz个作品，累计代码行数为nn。]]></content>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之十二&十三]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-7%2F</url>
    <content type="text"><![CDATA[第五部分 高效并发第十二章 Java 内存模型与线程并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类 “压榨” 计算机运算能力的最有力武器。 12.1 概述 多任务处理在现代计算机操作系统中几乎已是一项必备的功能了； 除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景； 服务端是 Java 语言最擅长的领域之一，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持，幸好 Java 语言和虚拟机提供了许多工具，把并发编码的门槛降低了不少； 12.2 硬件的效率与一致性 绝大多数的运算任务不可能只靠处理器计算就能完成，处理器至少要与内存交互，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了； 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性；为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI、MOSI、Synapse、Firefly 及 Dragon Protocol 等； 本章将会多次提到内存模型一词，可以理解在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；不同架构的物理机器可以拥有不一样的内存模型，而 Java 虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问具有很高的可比性； 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的； 12.3 Java 内存模型Java 虚拟机规范中视图定义一种 Java 内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 12.3.1 主内存与工作内存 Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节；此处的变量与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享； Java 内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量； 这里所讲的主内存、工作内存与第二章所讲的 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的；线程、主内存和工作内存的关系如下所示： 12.3.2 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下八种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量的某些操作在某些平台允许有例外）： lock unlock read load use assign store write 基于理解难度和严谨性考虑，最新的 JSR-133 文档中，已经放弃采用这八种操作去定义 Java 内存模型的访问协议了，后面将会介绍一个等效判断原则 – 先行发生原则，用来确定一个访问在并发环境下是否安全； 12.3.3 对于 volatile 型变量的特殊规则 关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制； 当一个变量定义为 volatile 之后，它将具备两种特性：第一是保证此变量对所有线程的可见性，这里的可见性是指当一个线程修改了这个变量的值，新的值对于其他线程来说是可以立即得知的，而普通的变量的值在线程间传递均需要通过主内存来完成；另外一个是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致； volatile 变量在各个线程的工作内存中不存在一致性问题，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的； 在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：运算结果并不依赖变量的当前值或者能够确保只有单一的线程修改变量的值、变量不需要与其他的状态变量共同参与不变约束； volatile 变量读操作的性能消耗与普通变量几乎没有任何差别，但是写操作则可能会慢一些；不过大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求； 12.3.4 对于 long 和 double 型变量的特殊规则 允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定； 但允许虚拟机选择把这些操作实现为具有原子性的操作，目前各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待； 12.3.5 原子性、可见性与有序性 原子性（Atomicity）：由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write；在 synchronized 块之间的操作也具备原子性； 可见性（Visibility）：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了 volatile 之外，Java 还有 synchronized 和 final 关键字能实现可见性； 有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性； 12.3.6 先行发生原则 先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等； 下面是 Java 内存模型下一些天然的先行发生关系：程序次序规则、管程锁定规则、volatile 变量规则、线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性； 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准； 12.4 Java 与线程12.4.1 线程的实现 线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度； Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的； 实现线程主要有三种方式：使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）、使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）和使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险）； 对于 Sun JDK 来说，它的 Windows 版与 Linux 版都是使用一对一的线程模型实现的，一条 Java 线程就映射到一条轻量级进程之中，因为 Windows 和 Linux 系统提供的线程模式就是一对一的； 12.4.2 Java 线程调度 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（线程的执行时间由线程本身来控制）和抢占式线程调度（线程由系统来分配执行时间，线程的切换不由线程本身来决定）； Java 语言一共设置了 10 个级别的线程优先级，不过线程优先级并不是太靠谱，原因就是操作系统的线程优先级不见得总是与 Java 线程的优先级一一对应，另外优先级还可能被系统自行改变； 12.4.3 状态转换 Java 语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。它们之间相互的转换关系如下所示： 12.5 本章小结本章我们首先了解了虚拟机 Java 内存模型的结构及操作，然后讲解了原子性、可见性、有序性在 Java 内存模型中的体现，最后介绍了先行发生原则的规则及使用。另外，我们还了解了线程在 Java 语言之中是如何实现的。 在本章主要介绍了虚拟机如何实现并发，而在下一章我们主要关注点将是虚拟机如何实现高效，以及虚拟机对我们编写的并发代码提供了什么样的优化手段。 第十三章 线程安全与锁优化13.1 概述 首先需要保证并发的正确性，然后在此基础上实现高效； 13.2 线程安全Brian Goetz 对线程安全有一个比较恰当的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 13.2.1 Java 语言中的线程安全 我们可以将 Java 语言中各个操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立； 不可变：不可变带来的安全性是最简单和最纯粹的，如 final 的基本数据类型；如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如 String 类的 substring、replace 方法；Number 类型的大部分子类都符合不可变要求的类型，但是 AtomicInteger 和 AtomicLong 则并非不可变的； 线程绝对安全：Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全；比如 java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了； 线程相对安全：是我们通常意义上所讲的线程安全，在 Java 语言中，大部分的线程安全类都属于这种类型； 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况； 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java 语言中很少出现； 13.2.2 线程安全的实现方法 互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用，而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式；Java 中最基本的互斥同步手段就是 synchronized 关键字，它对同一个线程来说是可重入的且会阻塞后面其他线程的进入；另外还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步，相比 synchronized 关键字 ReentrantLock 增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件； 非阻塞同步：互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略；随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步；Java 并发包的整数原子类，其中的 compareAndSet 和 getAndIncrement 等方法都使用了 Unsafe 类的 CAS 操作； 无同步方案：要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码； 13.3 锁优化13.3.1 自旋锁与自适应自旋 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力；另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁；为了让线程等待，我们只需让线程执行一个忙循环，这些技术就是所谓的自旋锁； 在 JDK 1.6 已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源； 在 JDK 1.6 中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定； 13.3.2 锁消除 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除； 锁消除的主要判断依据来源于逃逸分析的数据支持； 13.3.3 锁粗化 原则上总是推荐将同步块的作用范围限制得尽量小 – 只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁； 但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗； 13.3.4 轻量级锁 轻量级锁是 JDK 1.6 之中加入的新型锁机制，它是相对于使用操作系统互斥量来实现的传统锁而言的；它并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗； 要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从 HotSpot 虚拟机的对象的内存布局开始介绍；HotSpot 虚拟机的对象头分为两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄等，这部分官方称之为 Mark Word，是实现轻量级锁和偏向锁的关键，另外一部分用于存储指向方法区对象类型数据的指针； Mark Word 被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，在 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0；在其他状态（轻量级锁定、重量级锁定、GC 标志、可偏向）下对象的存储内容如下： 在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的 Mark Word 的拷贝（官方称之为 Displaced Mark Word）；然后虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果更新成功了那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位将转变为 “00”，即表示此对象处于轻量级锁定状态；如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了；如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为 “10”，Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进行阻塞状态； 轻量级锁能提升程序同步性能的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据； 13.3.5 偏向锁 偏向锁也是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能；如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了； 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 假设当前虚拟机启动了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为 “01”，即偏向模式；同时使用 CAS 操作把获取到这个锁的线程 ID 记录在对象的 Mark Word 之中；如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如上面介绍的轻量级锁那样执行；偏向锁、轻量级锁的状态转化以及对象 Mark Work 的关系如下图所示： 偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化； 本章小结本章介绍了线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运行原理，并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part7/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之十&十一]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-6%2F</url>
    <content type="text"><![CDATA[第四部分 程序编译与代码优化第十章 早期（编译器）优化10.1 概述 前端编译器（或叫编译器前端）：把.java 文件转变为.class 文件的过程，比如 Sun 的 javac、Eclipse JDT 中的 ECJ； 后端运行编译器（JIT 编译器）：把字节码转变为机器码的过程，比如 HotSpot VM 的 C1、C2 编译器； 静态提前编译器（AOT 编译器）：直接把 *.java 文件编译成本地机器代码的过程，比如 GNU Compiler for the Java； 本章主要针对第一类，把第二类的编译过程留到下一章讨论； javac 这类编译器对代码运行效率几乎没有任何优化措施，虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样那些不是由 javac 产生的 Class 文件也同样能享受到编译器优化所带来的好处； javac 做了许多针对 Java 语言编码过程的优化措施来改善程序员的编码风格和提高编码效率；可以说，Java 中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译器的优化过程对于程序编码来说关系更加密切； 10.2 javac 编译器javac 编译器本身就是一个由 Java 语言编写的程序，这为纯 Java 的程序员了解它的编译过程带来了很大的便利。 10.2.1 javac 的源码与调试 javac 的源码存放在 JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac，除了 JDK 自身的 API 外，就只引用了 JDK_SRC_HOME/langtools/src/share/classes/com/sun/* 里面的代码； 导入 javac 的源码后就可以运行 com.sun.tools.javac.Main 的 main 方法来执行编译了； javac 编译过程大概可以分为 3 个过程：解析与填充符号表过程、插入式注解处理器的注解处理过程、分析与字节码生成过程； 10.2.2 解析与填充符号表 解析步骤由 parseFiles 方法完成； 词法分析将源代码的字符流转变为标记（Token）集合，由 com.sun.tools.javac.parser.Scanner 类完成； 语法分析是根据 Token 序列构造抽象语法树（AST，一种用来描述程序代码语法结构的树形表示方式）的过程，由 com.sun.tools.javac.parser.Parser 类实现，AST 由 com.sun.tools.javac.tree.JCTree 类表示； 填充符号表：由 enterTrees 方法完成；符号表是由一组符号地址和符号信息构成的表格，所登记的信息在编译的不同阶段都要用到，在语义分析中用于语义检查，在目标代码生成时用于地址分配；由 com.sun.tools.javac.comp.Enter 类实现； 10.2.3 注解处理器 在 JDK 1.6 中实现了 JSR-269 规范，提供了一组插入式注解处理器的标准 API 在编译期间对注解进行处理，可以读取、修改、添加抽象语法树中的任意元素； 通过插入式注解处理器实现的插件在功能上有很大的发挥空间，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情； javac 中，在 initProcessAnnotations 初始化，在 processAnnotations 执行，如果有新的注解处理器，通过 com.sun.tools.javac.processing.JavacProcessingEnviroment 类的 doProcessing 方法生成一个新的 JavaCompiler 对象对编译的后续步骤进行处理； 10.2.4 语义分析与字节码生成 语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，主要包括标注检查、数据及控制流分析两个步骤； 解语法糖（Syntactic Sugar，添加的某种对语言功能没有影响但方便程序员使用的语法）：Java 中最常用的语法糖主要是泛型、变长参数、自动装箱等，他们在编译阶段还原回简单的基础语法结构；在 com.sun.tools.javac.comp.TransTypes 类和 com.sun.tools.javac.comp.Lower 类中完成； 字节码生成：javac 编译的最后一个阶段，不仅仅是把前面各个步骤所生成的信息转化为字节码写入到磁盘中，编译器还进行了少量的代码添加和转换工作（如实例构造器方法和类构造器方法）；由 com.sun.tools.javac.jvm.ClassWriter 类的 writeClass 方法输出字节码，生成最终的 Class 文件； 10.3 Java 语法糖的味道10.3.1 泛型与类型擦除 Java 语言的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型了，并且在相应的地方插入了强制转换，这种基于类型擦除的泛型实现是一种伪泛型； JCP 组织引入了 Signature 属性，它的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，这样我们就可以通过反射手段获取参数化类型； 10.3.2 自动装箱、拆箱与遍历循环 它们的实现比较简单，但却是 Java 语言里使用最多的语法糖； 10.3.3 条件编译 Java 语言之中并没有使用预处理器，因为 Java 编译器并非一个个地编译 Java 文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译； Java 语言可以使用条件为常量的 if 语句进行条件编译；编译器将会把分支中不成立的代码块消除掉； 10.4 实战：插入式注解处理器 实战目标：使用注解处理器 API 来编写一款拥有自己编码风格的校验工具； 代码实现：继承 javax.annotation.processing.AbstractProcessor，实现 process 方法，从第一个参数 annotations 获取此注解处理器所要处理的注解集合，从第二个参数 roundEnv 中访问到当前这个 Round 中的语法树节点；另外还有一个很常用的实例变量 processingEnv，它代表了注解处理器框架提供的一个上下文环境；可以配合使用的 @SupportedAnnotationTypes 和 @SupportedSourceVersion 注解； 10.5 本章小结本章我们从编译器源码实现的层次上了解了 javac 源代码编译为字节码的过程，分析了 Java 语言中多种语法糖的前因后果，并实战实习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。下一章我们将会介绍即时编译器的运作和优化过程。 第十一章 晚期（运行期）优化11.1 概述 为了提高热点代码的执行效率，在运行时虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（JIT）； JIT 不是虚拟机必需的，但是其编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分； 11.2 HotSpot 虚拟机内的即时编译器11.2.1 解释器与编译器 当程序需要迅速启动和执行的时候，解释器可以先发挥作用，省去编译的时间立即执行；在程序运行后，随着时间的推移，编译器把越来越多的代码编译成本地代码提升执行效率； HotSpot 虚拟机中内置了两个即时编译器，分别为 Client Compiler 和 Server Compiler，或简称为 C1 编译器和 C2 编译器；虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，也可以使用 “-client” 或“-server”参数去强制指定运行模式； 想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机还会逐渐启动分层编译的策略：第 0 层，程序解释运行；第 1 层，C1 编译；第 2 层，C2 编译； 实施分层编译后，Client Compiler 和 Server Compiler 将会同时工作，许多代码都可能会被多次编译，用 Client Compiler 获取更高的编译速度，用 Server Compiler 来获取更好的编译质量，在解释执行的时候也无须再承担性能收集监控信息的任务； 11.2.2 编译对象与触发条件 被 JIT 编译的热点代码有两类：被多次调用的方法、被多次执行的循环体；对于前者编译器会以整个方法作为编译对象，属于标准的 JIT 编译方式；对于后者尽管编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译对象，这种编译方式称之为栈上替换（OSR 编译）； 热点探测：基于采样的热点探测和基于计数器的热点探测，在 HotSpot 虚拟机中使用的是第二种，通过方法计数器和回边计数器进行热点探测。方法调用计数器触发的即时编译交互过程如下图所示： 11.2.3 编译过程 对于 Client Compiler 来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了很多耗时较长的全局优化手段；第一阶段一个平台独立的前端将字节码构造成一个高级中间代码表示（HIR），第二阶段一个平台相关的后端从 HIR 中产生低级中间代码表示（LIR），最后阶段是在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。其大致过程如下所示： Server Compiler 是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到 GNU C++ 编译器使用 - 02 参数时的优化强大，它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实现如范围检查消除、空值检查消除等 Java 语言特性密切相关的优化技术； 11.2.4 查看及分析即时编译结果 本节的运行参数有一部分需要 Debug 或 FastDebug 版虚拟机的支持； 要知道某个方法是否被编译过，可以使用参数 - XX:+PrintCompilation 要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来； 还可以加上参数 - XX:+PrintInlining 要求虚拟机输出方法内联信息，输出内容如下： 除了查看那些方法被编译之外，还可以进一步查看即时编译器生成的机器码内容，这个需要结合虚拟机提供的反汇编接口来阅读； 11.3 编译优化技术11.3.1 优化技术概览 11.3.2 公共子表达式消除 如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成为了公共子表达式，只需要直接用前面计算过的表达式结果代替 E 就可以了； 11.3.3 数组边界检查消除 对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判断，对于拥有大量数组访问的程序代码无疑是一种性能负担； 11.3.4 方法内联 除了消除方法调用的成本外更重要的意义是为其他优化手段建立良好的基础； 为了解决虚方法的内联问题，引入了类型继承关系分析（CHA）技术和内联缓存（Inline Cache）来完成方法内联； 11.3.5 逃逸分析 逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用（方法逃逸），甚至还可能被外部线程所访问到（线程逃逸）；如果能证明一个对象不会逃逸到方法或线程之外，则可能为这个变量进行一些高效的优化，比如栈上分配（减轻垃圾收集的压力）、同步消除（读写不会有竞争）、标量替换； 11.4 Java 与 C/C++ 的编译器对比 Java 虚拟机的即时编译器与 C/C++ 的静态优化编译器相比，可能会由于下列这些原因而导致输出的本地代码有一些劣势：即时编译器运行占用用户程序运行时间、动态类型安全语言导致的频繁检查、运行时对方法接收者进行多态选择的频率大、可以动态扩展导致很多全局的优化难以运行、大部分对象在堆上分配导致垃圾收集机制的效率低； Java 语言的特性换取了开发效率的提升、还有许多优化是静态优化编译器不好做的，比如别名分析、还有一些以运行期性能监控为基础的优化措施如调用频率预测等； 11.5 本章小结本章我们着重了解了虚拟机的热点探测方法、HotSpot 的即时编译器、编译触发条件以及如何从虚拟机外部观察和分析 JIT 编译的数据和结果，还选择了集中场景的编译期优化技术进行讲解。对 Java 编译器的深入了解，有助于在工作中分辨哪些代码是编译器可以帮我们处理的，哪些代码需要自己调节以便更适合编译器的优化。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part6/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之九]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-11-5%2F</url>
    <content type="text"><![CDATA[第九章 类加载及执行子系统的案例与实战9.1 概述 在 Class 文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不多； 能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路； 9.2 案例分析9.2.1 Tomcat：正统的类加载器架构 Java Web 服务器：部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离又要可以互相共享；尽可能保证自身的安全不受部署的 Web 应用程序影响；要支持 JSP 生成类的热替换； 上图中，灰色背景的三个类加载器是 JDK 默认提供的类加载器，而 CommonClassLoader、CatalinaClassLoader、SharedClassLoader 和 WebappClassLoader 是 Tomcat 自己定义的类加载器，分别加载 / common/（可被 Tomcat 和 Web 应用共用）、/server/（可被 Tomcat 使用）、/shared/（可被 Web 应用使用）和 / WebApp/WEB-INF/（可被当前 Web 应用使用）中的 Java 类库，Tomcat 6.x 把前面三个目录默认合并到一起变成一个 / lib 目录（作用同原先的 common 目录）； 9.2.2 OSGI：灵活的类加载架构 OSGI 的每个模块称为 Bundle，可以声明它所依赖的 Java Package（通过 Import-Package 描述），也可以声明它允许导出发布的 Java Package（通过 Export-Package 描述）； 除了更精确的模块划分和可见性控制外，引入 OSGI 的另外一个重要理由是基于 OSGI 的程序很可能可以实现模块级的热插拔功能； OSGI 的类加载器之间只有规则，没有固定的委派关系；加载器之间的关系更为复杂、运行时才能确定的网状结构，提供灵活性的同时，可能会产生许多的隐患； 9.2.3 字节码生成技术与动态代理的实现 在 Java 里面除了 javac 和字节码类库外，使用字节码生成的例子还有 Web 服务器中的 JSP 编译器、编译时植入的 AOP 框架和很常用的动态代理技术等，这里选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的； 动态代理的优势在于实现了在原始类和接口还未知的时候就确定类的代理行为，可以很灵活地重用于不同的应用场景之中； 以下的例子中生成的代理类 “$Proxy0.class” 文件可以看到代理为传入接口的每一个方法统一调用了 InvocationHandler 对象的 invoke 方法；其生成代理类的字节码大致过程其实就是根据 Class 文件的格式规范去拼接字节码； 9.2.4 Retrotranslator：跨越 JDK 版本 Retrotranslator 的作用是将 JDK 1.5 编译出来的 Class 文件转变为可以在 JDK 1.4 或 JDK 1.3 部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持 JDK 1.5 中新增的集合改进、并发包以及对泛型、注解等的反射操作； JDK 升级通常包括四种类型：编译器层面的做的改进、Java API 的代码增强、需要再字节码中进行支持的活动以及虚拟机内部的改进，Retrotranslator 只能模拟前两类，第二类通过独立类库实现，第一类则通过 ASM 框架直接对字节码进行处理； 9.3 实战：自己动手实现远程执行功能 目标：不依赖 JDK 版本、不改变原有服务端程序的部署，不依赖任何第三方类库、不侵入原有程序、临时代码的执行结果能返回到客户端； 思路：如何编译提交到服务器的 Java 代码（客户端编译好上传 Class 文件而不是 Java 代码）、如何执行编译之后的 Java 代码（要能访问其他类库，要能卸载）、如何收集 Java 代码的执行结果（在执行的类中把 System.out 的符号引用替换为我们准备的 PrintStream 的符号引用）； 具体实现：HotSwapClassLoader 用于实现同一个类的代码可以被多次加载，通过公开父类 ClassLoader 的 defineClass 实现；HackSystem 是为了替换 java.lang.System，它直接修改 Class 文件格式的 byte[] 数组中的常量池部分，将常量池中指定内容的 CONSTANT_Utf8_info 常量替换为新的字符串；ClassModifier 涉及对 byte[] 数组操作的部分，主要是将 byte[] 与 int 和 String 互相转换，以及把对 byte[] 数据的替换操作封装在 ByteUtils 类中；经过 ClassModifier 处理过的 byte[] 数组才会传给 HotSwapClassLoader.loadByte 方法进行类加载；而 JavaClassExecutor 是提供给外部调用的入口； 9.4 本章小结只有了解虚拟机如何执行程序，才能更好地理解怎样写出优秀的代码。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之八]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-4%2F</url>
    <content type="text"><![CDATA[第八章 虚拟机字节码执行引擎8.1 概述 执行引擎是 Java 虚拟机最核心的组成部分之一，区别于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行哪些不被硬件直接支持的指令集格式； 在虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，该模型成为各种虚拟机执行引擎的统一外观； 在不同的虚拟机实现里面，执行引擎在执行 Java 代码时可能会有解释执行和编译执行两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观来说是一致的：输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。 8.2 运行时栈帧结构 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素； 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程； 栈帧需要分配多少内存在编译时就完全确定并写入到方法表的 Code 属性之中了，不会受到程序运行期变量数据的影响； 对于执行引擎来说，在活动线程中只有位于栈顶的栈帧才算有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。 8.2.1 局部变量表 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，Code 属性的 max_locals 确定了该方法所需要分配的局部变量表的最大容量； 其容量以变量槽（Variable Slot）为最小单位，虚拟机规范允许 Slot 的长度随处理器、操作系统或虚拟机的不同而发生变化； 一个 Slot 可以存放一个 32 位以内的数据类型，包括 boolean、byte、char。short、int、float、reference 和 returnAddress 这八种类型；对于 64 位的数据类型（long 和 double），虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间； 8.2.2 操作数栈 也常称为操作栈，它是一个后入先出栈；Code 属性的 max_stacks 确定了其最大深度； 比如整数加法的字节码指令 iadd 在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个 int 型的数值，当执行这个指令时，会将这两个 int 值出栈并相加，然后将相加的结果入栈； 操作数栈中元素的类型必须与字节码指令的序列严格匹配； Java 虚拟机的解释执行引擎称为 “基于栈的执行引擎”，其中所指的栈就是操作数栈； 8.2.3 动态连接 每个栈帧都包含一个执行运行时常量池中该栈帧所属方法引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）； Class 文件的常量池的符号引用，有一部分在类加载阶段或者第一次使用时就转换为直接引用，这种称为静态解析，而另外一部分在每一次运行期间转换为直接引用，这部分称为动态连接； 8.2.4 方法返回地址 退出方法的方式：正常完成出口和异常完成出口； 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能只需的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数中，调整 PC 计数器的值以只需方法调用指令后面的一套指令等； 8.2.5 附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分完成取决于具体的虚拟机实现； 8.3 方法调用 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本即调用哪一个方法，暂时还不涉及方法内部的具体运行过程； Class 文件的编译过程中不报警传统编译的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂； 8.3.1 解析 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用称为解析； 在 Java 语言中符合编译器可知、运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类； 五条方法调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic； 解析调用是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用；而分派调用则可能是静态的也可能是动态的； 8.3.2 分派 静态分派：“Human man = new Man();” 语句中 Human 称为变量的静态类型，后面的 Man 称为变量的实际类型；静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译器可知的；而实际类型的变化在运行期才确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么；编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的；所有根据静态类型来定位方法执行版本的分派动作称为静态分派，其典型应用是方法重载； 动态分派：invokevirtual 指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质；我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派； 单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派分为单分派（根据一个宗量对目标方法进行选择）与多分派（根据多于一个宗量对目标方法进行选择）两种；今天的 Java 语言是一门静态多分派、动态单分派的语言； 虚拟机动态分派的实现：在方法区中建立一个虚方法表（Virtual Method Table），使用虚方法表索引来代替元数据查找以提高性能；方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化值后，虚拟机会把该类的方法表也初始化完毕； 8.3.3 动态类型语言支持 JDK 1.7 发布增加的 invokedynamic 指令实现了 “动态类型语言” 支持，也是为 JDK 1.8 顺利实现 Lambda 表达式做技术准备； 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器，比如 JavaScript、Python 等； Java 语言在编译期间就将方法完整的符号引用生成出来，作为方法调用指令的参数存储到 Class 文件中；这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息；而在 ECMAScript 等动态语言中，变量本身是没有类型的，变量的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型；变量无类型而变量值才有类型，这个特点也是动态类型语言的一个重要特征； JDK 1.7 实现了 JSR-292，新加入的 java.lang.invoke 包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法外，提供一种新的动态确定目标方法的机制，称为 MethodHandle； 从本质上讲，Reflection（反射）和 MethodHandle 机制都是在模拟方法调用，但 Reflection 是在模拟 Java 代码层次的方法调用，而 MethodHandle 是在模拟字节码层次的方法调用，前者是重量级，而后者是轻量级；另外前者只为 Java 语言服务，后者可服务于所有 Java 虚拟机之上的语言； 每一处含有 invokedynamic 指令的位置都称为 “动态调用点 (Dynamic Call Site)”，这条指令的第一个参数不再是代表符号引用的 CONSTANT_Methodref_info 常量，而是 CONSTANT_InvokeDynamic_info 常量（可以得到引导方法、方法类型和名称）； invokedynamic 指令与其他 invoke 指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定的； 8.4 基于栈的字节码解释执行引擎上节主要讲虚拟机是如何调用方法的，这节探讨虚拟机是如何执行方法中的字节码指令的。 8.4.1 解释执行 只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才比较确切； Java 语言中，javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程；因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现； 8.4.2 基于栈的指令集与基于寄存器的指令集 Java 编译器输出的指令集，基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，它们依赖操作数栈进行工作； 基于栈的指令集主要的优点是可移植性，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；主要缺点是执行速度相对来说会稍慢一点； 8.4.3 基于栈的解释器执行过程一段简单的算法代码 上述代码的字节码表示 123456789101112131415public int calc();Code:Stack=2, Locals=4, Args_size=10:bipush 1002:istore_13:sipush 2006:istore_27:sipush 30010:istore_311:iload_112:iload_213:iadd14:iload_315:imul16:ireturn javap 提示这段代码需要深度为 2 的操作数栈和 4 个 Slot 的局部变量空间，作者根据这些信息画了示意图来说明执行过程中的变化情况： 执行偏移地址为 0 的指令 执行偏移地址为 2 的指令 执行偏移地址为 11 的指令 执行偏移地址为 12 的指令 执行偏移地址为 13 的指令 执行偏移地址为 14 的指令 执行偏移地址为 16 的指令 注：上面的执行过程仅仅是一种概念模型，虚拟机中解析器和即时编译器会对输入的字节码进行优化。 8.5 本章小结本章分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码以及执行代码时涉及的内存结构。这第六、七、八三章中，我们针对 Java 程序是如何存储的、如何载入的以及如何执行的问题进行了讲解，下一章一起看看这些理论知识在具体开发中的经典应用。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之七（虚拟机类加载机制，重点）]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-3%2F</url>
    <content type="text"><![CDATA[第七章 虚拟机类加载机制（重点）7.1 概述 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成，这虽然增量一些性能开销，但是会为 Java 应用程序提供高度的灵活性。 7.2 类加载的时机 类的整个生命周期：加载、验证、准备、解析、初始化、使用和卸载；其中验证、准备和解析统称为连接； 虚拟机规范没有强制约束类加载的时机，但严格规定了有且只有 5 种情况必须立即对类进行初始化：遇到 new、getstatic、putstatic 和 invokestatic 指令；对类进行反射调用时如果类没有进行过初始化；初始化时发现父类还没有进行初始化；虚拟机启动指定的主类；动态语言中 MethodHandle 实例最后解析结果 REF_getStatic 等的方法句柄对应的类没有初始化时； 7.3 类加载的过程7.3.1 加载 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口； 7.3.2 验证 验证是连接阶段的第一步，其目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全； 验证阶段是非常重要的，这个阶段是否严谨决定了 Java 虚拟机是否能承受恶意代码的攻击； 校验动作：文件格式验证（基于二进制字节流）、元数据验证（对类的元数据语义分析）、字节码验证（对方法体语义分析）、符号引用验证（对类自身以外的信息进行匹配性校验）； 7.3.3 准备 正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在这个方法区中进行分配； 需要强调两点：这时候内存分配的仅包括类变量，而不包括类实例变量；这里所说的初始化通常情况下是数据类型的零值，真正的赋值是在初始化阶段，如果是 static final 的则是直接赋值； 7.3.4 解析 解析阶段是虚拟机将常量池内的符号引用（如 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等 7 种）替换为直接引用的过程； 符号引用可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中；而直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，它和虚拟机实现的内存布局相关，引用的目标必定以及在内存中存在； 对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可以对第一次解析的结果进行缓存； 7.3.5 初始化 是类加载过程的最后一步，真正开始执行类中定义的 Java 程序代码（或者说是字节码）； 初始化阶段是执行类构造器方法的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的； 方法与类的构造函数（或者说是实例构造器方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的方法执行之前，父类的方法已执行完毕； 执行接口的方法不需要先执行父接口的方法，只有当父接口中定义的变量使用时父接口才会初始化，接口的实现类在初始化时也一样不会执行接口的方法； 方法初始化是加锁阻塞等待的，应当避免在方法中有耗时很长的操作； 7.4 类加载器 虚拟机设计团队把类加载阶段的 “通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到虚拟机外部去实现，实现这个动作的代码模块称为类加载器； 这时 Java 语言的一项创新，也是 Java 语言流行的重要原因，在类层次划分、OSGI、热部署、代码加密等领域大放异彩； 7.4.1 类与类加载器 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每一个类加载器都拥有一个独立的类名称空间； 比较两个类是否相等（如 Class 对象的 equals 方法、isAssignableFrom 方法、isInstance 方法），只有在这两个类是由同一个类加载器加载的前提下才有意义； 7.4.2 双亲委派模型 三种系统提供的类加载器：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）； 双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器，这里一般不会以继承的关系来实现，而是使用组合的关系来复用父加载器的代码； 其工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载； 这样的好处是 Java 类随着它的类加载器具备了一种带有优先级的层次关系，对保证 Java 程序的稳定运作很重要； 实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass 方法中，逻辑清晰易懂； 7.4.3 破坏双亲委派模型 上一小节的双亲委派模型是 Java 设计者推荐给开发者的类加载器实现方法，但不是一个强制性的约束模型； 典型的两种情况：为了解决 JNI 接口提供者（SPI）引入的线程上下文类加载器；为了程序动态性加强的 OSGI 的 Bundle 类加载器； 7.5 本章小结本章介绍了类加载过程的加载、验证、准备、解析和初始化五个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。下一章将一起看看虚拟机如果执行定义在 Class 文件里的字节码。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part5/推荐扩展阅读：http://blog.csdn.net/javazejian/article/details/73413292]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之六]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-2%2F</url>
    <content type="text"><![CDATA[第三部分 虚拟机执行子系统第六章 类文件结构（了解）代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。 6.1 概述由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。 6.2 无关性的基石 Java 刚诞生的宣传口号：一次编写，到处运行（Write Once, Run Anywhere）。其最终实现在操作系统的应用层：Sun 公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码。 字节码（ByteCode）是构成平台无关的基石； 另外虚拟机的语言无关性也越来越被开发者所重视，JVM 设计者在最初就考虑过实现让其他语言运行在 Java 虚拟机之上的可能性，如今已发展出一大批在 JVM 上运行的语言，比如 Clojure、Groovy、JRuby、Jython、Scala； 实现语言无关性的基础仍是虚拟机和字节码存储格式，Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与 Class 文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成 Class 文件，从而在虚拟机上运行。 6.3 Class 类文件的结构 Class 文件是一组以 8 个字节为基础单位的二进制流（可能是磁盘文件，也可能是类加载器直接生成的），各个数据项目严格按照顺序紧凑地排列，中间没有任何分隔符； Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，其中只有两种数据类型：无符号数和表； 无符号数属于基本的数据类型，以 u1、u2、u4 和 u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值； 表是由多个无符号数获取其他表作为数据项构成的复合数据类型，习惯以 “_info” 结尾； 无论是无符号数还是表，当需要描述同一个类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据未某一类型的集合。 下面我以自己本机写的一个简单的 Java 文件来学习其中各个部分的含义： 使用 javac 编译成 TestClass.class 文件，使用 16 进制打开： 使用 javap 命令输出 Class 文件信息： 6.3.1 魔数和版本 Class 文件的头 4 个字节，唯一作用是确定文件是否为一个可被虚拟机接受的 Class 文件，固定为 “0xCAFEBABE”。 第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号（0x0034 为 52，对应 JDK 版本 1.8）；能向下兼容之前的版本，无法运行后续的版本； 6.3.2 常量池 常量池可以理解为 Class 文件之中的资源仓库，是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项之一； 由于常量池中的常量数量不固定，因此需要在常量池前放置一项 u2 类型的数据来表示容量，该值是从 1 开始的，上图的 0x0013 为十进制的 19，代表常量池中有 18 项常量，索引值范围为 1~18； 常量池主要存放两大类常量：字面量（Literal，笔记接近 Java 的常量概念，比如文本字符串和 final 常量等）和符号引用（Symbolic References，主要包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）； Java 代码在 javac 编译时不会有 “连接” 这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接；所以在 Class 文件不会保存各个方法、字段和最终内存布局信息；当虚拟机运行时需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中； JDK 1.7 中常量池共有 14 种不同的表结构数据，这些表结构开始的第一位是一个 u1 类型的标志位，代表当前常量的类型，具体如下图所示： 之所以说常量池是最繁琐的数据就是因为这 14 种常量类型都有自己的结结构。可以结合下图中各个表结构的说明和之前使用 javap 解析的文件内容一起看。 第 1 项：0x0A（15 标志为方法句柄），0x0004（指向第 4 项的类描述符），0x000F（指向第 15 项的名称及类型描述符）； 第 2 项：0x09（9 标志为字段符号引用），0x0003（指向第 3 项类描述符），0x0010（指向第 16 项的名称及类型描述符）； 第 3 项：0x07（7 标志为类符号引用），0x0011（指向第 17 项全限定名常量项）； 第 4 项：0x07（7 标志为类符号引用），0x0012（指向第 18 项全限定名常量项）； 第 5 项：0x01（1 标志为 UTF - 字符串常量），0x0001（字符串占用 1 个字节），6D（字符 “m”）； 第 6 项：0x01（1 标志为 UTF - 字符串常量），0x0001（字符串占用 1 个字节），49（字符 “I”）； 第 7 项：0x01（1 标志为 UTF - 字符串常量），0x0006（字符串占用 6 个字节），3C 69 6E 69 74 3E（字符 “”）； 第 8 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），28 29 56（字符 “()V”）； 第 9 项：0x01（1 标志为 UTF - 字符串常量），0x0004（字符串占用 4 个字节），43 6F 64 65（字符 “Code”）； 第 10 项：0x01（1 标志为 UTF - 字符串常量），0x000F（字符串占用 15 个字节），4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65（字符 “LineNumberTable”）； 第 11 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），69 6E 63（字符 “inc”）； 第 12 项：0x01（1 标志为 UTF - 字符串常量），0x0003（字符串占用 3 个字节），28 29 49（字符 “()I”）； 第 13 项：0x01（1 标志为 UTF - 字符串常量），0x000A（字符串占用 10 个字节），53 6F 75 72 63 65 46 69 6C 65（字符 “SourceFile”）； 第 14 项：0x01（1 标志为 UTF - 字符串常量），0x000E（字符串占用 14 个字节），54 65 73 74 43 6C 61 73 73 2E 6A 61 76 61（字符 “TestClass.java”）； 第 15 项：0x0C（12 标志为名称和类型符号引用），0x0007（指向第 7 项名称常量项）， 0x0008（指向第 8 项描述符常量项）； 第 16 项：0x0C（12 标志为名称和类型符号引用），0x0005（指向第 5 项名称常量项）， 0x0006（指向第 6 项描述符常量项）； 第 17 项：0x01（1 标志为 UTF - 字符串常量），0x001F（字符串占用 31 个字节），63 6F 6D 2F 67 69 6E 6F 62 65 66 75 6E 6E 79 2F 63 6C 61 7A 7A 2F 54 65 73 74 43 6C 61 73 73（字符 “com/ginobefunny/clazz/TestClas”）； 第 18 项：0x01（1 标志为 UTF - 字符串常量），0x0010（字符串占用 16 个字节），6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74（字符 “java/lang/Object”）； 6.3.3 访问标志 紧接在常量池后面的是两个字节的访问标志，用于标识类或接口的访问信息； 访问标志一个有 16 个标志位，但目前只采用了其中 8 位，本例子中的 0x0021 标识为一个 public 的普通类； 6.3.4 类索引、父类索引与接口索引集合 类索引：u2 类型的数据，用于确定类的全限定名。本例子中为 0x0003，指向常量池中第 3 项； 父类索引：u2 类型的数据，用于确定父类的全限定名。本例子中为 0x0004，指向常量池中第 4 项； 接口索引计算器：u2 类型的数据，用于表示索引集合的容量。本例子中为 0x0000，说明没有实现接口； 接口索引集合：一组 u2 类型的数据的集合，用于确定实现的接口（对于接口来说就是 extend 的接口）。本例子不存在。 6.3.5 字段表集合 用于描述接口或者类中声明的变量，包括类级变量和实例级变量，但不包括方法内部声明的局部变量；它不会列出从父类和超类继承而来的字段； 0x0001 表示这个类只有一个字段表数据； 字段修饰符放在 access_flag 中，是一个 u2 的数据类型，0x0002 表示为 private 的属性； 字段名称 name_index，是一个 u2 的数据类型，0x0005 表示该属性的名称为常量池的第 5 项； 字段描述符 descriptor_index，是一个 u2 的数据类型，0x0006 表示该属性的描述符为常量池的第 6 项，其值 “I” 表示类型为整形； 字段属性计算器和属性集合：0x0000 表示该例子中不存在； 6.3.6 方法表集合 和字段表集合的方式几乎一样； 方法里面的代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 Code 的属性里面； 0x0002 表示这个类有两个方法表数据，分别是编译器添加的实例构造器和源码中的方式 inc()； 第一个方法的访问标志是 0x0001（public 方法），名称索引值为 0x0007（常量池第 7 项，“”），描述符索引值为 0x0008（常量池第 8 项，“()V”），属性表计算器为 0x0001（有一项属性），属性名称索引为 0x0009（常量池第 9 项，“Code”）； 根据 “6.3.7.1 Code 属性” 说明，属性值的长度为 23（0x0000001D 表示 29，但需要减去属性名称索引和属性长度固定的 6 个字节长度），操作数栈深度的最大值为 1（0x0001，虚拟机运行时根据这个值来分配栈帧中操作栈深度），局部变量表所需要的存储空间为 1 个 Slot（0x0001，Slot 是内存分配的最小单位），字节码长度为 5（0x00000005），分别为 2A（aload_0，将第 0 个 Slot 中为 reference 类型的本地变量推送到操作数栈顶）、B7（invokespecial，以栈顶的 reference 类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private 方法或者它父类的方法，后面接着一个 u2 的参数指向常量池的方法引用）、0x0001（表示常量池的第 1 项，即 Object 类的方法）、B1（对应的指令为 return，返回值为 void）；显式异常表为空（0x0000，计数器为 0）；该 Code 属性还内嵌 1 个属性（0x0001），属性的名称索引为 0x000A（即 “LineNumberTable” 属性，用于记录对应的代码行数），该内嵌属性的长度为 6（0x00000006），对应的行数信息为源码的第 3 行（0x000100000003）； 第二个方法的访问标志是 0x0001（public 方法），名称索引值为 0x000B（常量池第 11 项，“inc”），描述符索引值为 0x000C（常量池第 12 项，“()I”），属性表计算器为 0x0001（有一项属性），属性名称索引为 0x0009（常量池第 9 项，“Code”）； 根据 “6.3.7.1 Code 属性” 说明，属性值的长度为 25（0x0000001F 表示 31，但需要减去属性名称索引和属性长度固定的 6 个字节长度），操作数栈深度的最大值为 2（0x0002），局部变量表所需要的存储空间为 1 个 Slot（0x0001），字节码长度为 7（0x00000007），分别为 2A（aload_0）、B4（getfield，后面接着一个 u2 的参数指向常量池的属性引用）、0x0002（表示常量池的第 2 项，即 TestClass 类的 m 属性）、04（对应的指令为 iconst_1）、60（对应的指令为 iadd，整形求和）、AC（对应的指令为 ireturn，返回值为整形）；显式异常表为空（0x0000，计数器为 0）；该 Code 属性还内嵌 1 个属性（0x0001），属性的名称索引为 0x000A（即 “LineNumberTable” 属性，用于记录对应的代码行数），该内嵌属性的长度为 6（0x00000006），对应的行数信息为源码的第 8 行（0x000100000008）； 6.3.7 属性表集合 在 Class 文件、字段表、方法表都可以携带自己的属性表集合； 属性表集合的限制较为宽松，不再要求严格的顺序，只要属性名不重复即可； 以下是 Java 虚拟机规范里预定义的虚拟机实现应当能识别的属性： 接着我们的例子的 Class 文件还有最后一段：0x0001 表示该 Class 有一个属性，0x000D 表示属性名索引为第 13 项（对应 “SourceFile”），0x00000002 表示该属性长度为 2，0x000E 表示该类的 SourceFile 名称为第 14 项（对应 “TestClass.java”）。 6.3.7.1 Code 属性Java 程序方法体中的代码经过 javac 编译后，字节码指令存放在 Code 属性，其属性表结构如下： 6.3.7.2 Exceptions 属性方法描述时 throws 关键字后面列举的异常，和 Code 属性里的异常表不同。其属性表结构如下： 6.3.7.3 LineNumberTable 属性用于描述 Java 源码行号与字节码行号之间的对应关系，它不是必须的，可以通过 javac -g:none 取消该信息。没有该信息的影响是运行时抛异常不会显示出错的行号，在代码调试时无法按照源码行来设置断点。 6.3.7.4 LocalVariableTable 属性用于描述栈帧中局部变量与 Java 源码中定义的变量之间的关系，它不是运行时必须的，可以通过 javac -g:none 取消该信息。如果没有这个属性，所有的参数名称都会丢失，取之以 arg0、arg1 这样的占位符来替代。 其中 local_variable_info 项代表了一个栈帧与源码中局部变量的关联，如下所示： 6.3.7.5 SourceFile 属性用于记录生成这个 Class 的源码文件名称，这个属性也是可选的。 6.3.7.6 ConstantValue 属性作用是通知虚拟机自动为静态变量赋值，只有被 static 关键字修饰的变量才可以用这个属性。对于非 static 类型的变量的赋值是在实例构造器方法中进行的；而对于类变量有两种方式：在类构造器方法中或者使用 ConstantValue 属性。目前 Sun javac 编译器的选择是：同时使用 final 和 static 修饰的变量且为基本数据类型或 String 类型使用 ConstantValue 属性初始化，否则使用初始化。 6.3.7.7 InnerClass 属性用于记录内部类与宿主类之间的关联。 其中 number_of_class 代表需要记录多少个内部类信息，每个内部类的信息都由一个 inner_class_info 表进行描述。 6.3.7.8 Deprecated 及 Synthetic 属性Deprecated（不推荐使用）和 Synthetic（不是由 Java 源码直接产生编译器自行添加的，有两个例外是实例构造器和类构造器）这两个属性都属于布尔属性，只存在有和没有的区别，没有属性值的概念。在属性结构中 attribute_length 的数据值必须为 0x00000000。 6.3.7.9 StackMapTable 属性这是一个复杂的变长属性，位于 Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 6.3.7.10 Signature 属性一个可选的定长属性，在 JDK 1.5 发布后增加的，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，则 Signature 属性会为它记录泛型签名信息。这主要是因为 Java 的泛型采用的是擦除法实现的伪泛型，在字节码中泛型信息编译之后统统被擦除，在运行期无法将泛型类型与用户定义的普通类型同等对待。通过 Signature 属性，Java 的反射 API 能够获取泛型类型。 6.3.7.11 BootstrapMethods 属性一个复杂的变长属性，位于类文件的属性表中，用于保存 invokedynamic 指令引用的引导方法限定符。 6.4 字节码指令简介Java 虚拟机的指令由一个字节长度的、代表着特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。 在指令集中大多数的指令都包含了其操作所对应的数据类型信息，如 iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中。 加载和存储指令：iload/iload 等（加载局部变量到操作栈）、istore/istore 等（从操作数栈存储到局部变量表）、bipush/sipush/ldc/iconst_（加载常量到操作数栈）、wide（扩充局部变量表访问索引）； 运算指令：没有直接支持 byte、short、char 和 boolean 类型的算术指令而采用 int 代替；iadd/isub/imul/idiv 加减乘除、irem 求余、ineg 取反、ishl/ishr 位移、ior 按位或、iand 按位与、ixor 按位异或、iinc 局部变量自增、dcmpg/dcmpl 比较； 类型转换指令：i2b/i2c/i2s/l2i/f2i/f2l/d2i/d2l/d2f； 对象创建与访问指令：new 创建类实例、newarray/anewarray/multianewarray 创建数组、getfield/putfield/getstatic/putstatic 访问类字段或实例字段、baload/iaload/aaload 把一个数组元素加载到操作数栈、bastore/iastore/aastore 将一个操作数栈的值存储到数组元素中、arraylength 取数组长度、instanceof/checkcast 检查类实例类型； 操作数栈管理指令：pop/pop2 一个或两个元素出栈、dup/dup2 复制栈顶一个或两个数组并将复制值或双份复制值重新压力栈顶、swap 交互栈顶两个数值； 控制转移指令：ifeq/iflt/ifnull 条件分支、tableswitch/lookupswitch 复合条件分支、goto/jsr/ret 无条件分支； 方法调用和返回指令：invokevirtual/invokeinterface/invokespecial/invokestatic/invokedynamic 方法调用、ireturn/lreturn/areturn/return 方法返回； 异常处理指令：athrow 同步指令：monitorenter/monitorexit 6.5 公有设计和私有实现 Java 虚拟机的实现必须能够读取 Class 文件并精确实现包含在其中的 Java 虚拟机代码的含义； 但一个优秀的虚拟机实现，通常会在满足虚拟机规范的约束下具体实现做出修改和优化； 虚拟机实现的方式主要有两种：将输入的 Java 虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集或宿主主机 CPU 的本地指令集。 6.6 Class 文件结构的发展 Class 文件结构一直比较稳定，主要的改进集中向访问标志、属性表这些可扩展的数据结构中添加内容； Class 文件格式所具备的平台中立、紧凑、稳定和可扩展的特点，是 Java 技术体系实现平台无关、语言无关两项特性的重要支柱； 6.7 本章小结本章详细讲解了 Class 文件结构的各个部分，通过一个实例演示了 Class 的数据是如何存储和访问的，后面的章节将以动态的、运行时的角度去看看字节码在虚拟机执行引擎是怎样被解析执行的。 参考：http://ginobefunny.com/post/deep_in_jvm_notes_part4/]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之五]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11-1%2F</url>
    <content type="text"><![CDATA[5.2 案例分析5.2.1 高性能硬件上的程序部署策略 背景：一个15万pv、天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个cpu,16GB物理内存，操作系统为 64位的 CentOS 5.4 ，Resin作为服务器。管理员选用了 64位的 jdk 1.5,通过-Xmx,-Xms 将堆固定在12GB，使用一段时间后，出现了卡B现象，长时间无响应。监控发现卡B是由于GC停顿导致的。虚拟机运行在Server模式，默认使用吞吐量优先收集器，一次回收12GB的堆，一次 Full Gc的时间高达 14秒，再加上程序设计的关系，访问文档中需要一次性把文档从磁盘中读取到内存，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有在Minor GC中清理掉。在这种情况下，即使有12GB的堆，内存也很快会被消耗殆尽，有次导致每隔十几分钟出现十几秒的卡B，令网站开发人员和管理人员感到郁闷。 分析：在高性能硬件上部署程序，目前主要有两种方式：1 通过 64位 JDK 来使用大内存。2 使用若干个32位虚拟机简历逻辑集群来利用硬件资源。 如果读者计划使用64位的JDK来管理大内存，还需要考虑下面可能面临的问题：1 内存回收导致的长时间停顿。2 现阶段，64位JDK的性能测试普遍地域32位JDK。3 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照(因为要产生十几GB乃至更大的dump文件)，即使产生了快照也几乎无法进行分析。4 相同的程序在64位JDK中消耗的内存一般比32位的JDK大，这是由指针膨胀以及数据类型对其补白等因素导致的。 考虑到以上几点因素，你可能会选择使用若干个虚拟机集群来利用硬件资源，具体做法是子啊一台物理机器上启动多个应用服务器进程，给每个服务器进程分配不同的端口，然后在前端大减一个负载均衡器，以反向代理的方式来分配访问请求。 这种部署方式可能会遇到下面的问题： 1 尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同事访问某个磁盘文件的话，很容易导致IO异常。 2 很难高效率的利用某些资源池，譬如连接池，一般都是在各个节点上简历自己的独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余，尽管可以使用集中式的JNDI，但这有一定的复杂性并且可能带来额外的性能代价。 3 各个节点仍然不可避免的收到32位的内存限制，在32位window平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些linux unix 系统(Solaris)可以提升到3GB乃至接近4Gb的内存，但32位中仍然接受最高4GB内存的限制。 4 大量使用本地缓存的应用，在逻辑集群中会造成大量的内存浪费，因为每个逻辑节点上都有一份缓存，这时可以考虑把本地缓存改为集中式缓存。 最终解决方案最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算(其中堆固定为1.5GB)，占用了10GB的内存。另外建立一个Apache服务作为前端均衡器代理访问门户。考虑到用户对响应较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较多提升。 5.2.2 集群间同步导致的内存溢出由于集群同步大量数据，导致数据过多，而超过内存限制。 心得： 发生 OOM 的时候自动生成堆 dump 文件可以加参数： -XX:+HeapDumpOnOutOfMemoryError 由于信息有传输失败需要重发的可能性，在确认所有注册的GMS(GroupMembership Service)的节点都收到正确的信息前，发送的信息必须在内存中保留。此MIS的服务端中有一个负责安全校验的全局Filter，每当接收请求时，均会更新 一次最后的操作时间，并且将这个时间同步到所有节点中，使得一个用户在一段时间内不能在多台机器上登录。在服务器使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间的网络交互非常频繁。 当网络情况不能满足传输要求时，重发数据在内存中不断地积累，很快就产生了内存溢出。 这个案例中的问题，既有JBossCache的缺陷，也有MIS系统实现方式上的缺陷。JBossCache官方的mailist中讨论过很多次类似的内存溢出异常问题，据说后续版本有了改进。而更重要的缺陷是这一类被集群共享的数据如果要使用类似JBossCache 这种集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动作不会耗费多少资源，但不应当有过于频繁的写操作，这会带来很大的网络同步的开销。 5.2.3 堆外内存导致的溢出错误当出现 OOM 的时候不得不考虑下堆外内存导致的错误。第 2 章的时候也提到过，出现堆外内存导致的 OOM 时，heap dump 是无效的。异常栈里面可以明显看到 DirectByteBuffer、NIO 等字样的时候就可以考虑是堆外内存溢出导致的问题了。 最佳实践：因此总内存在分配给 JAVA 堆的时候，也确保预留了足够的堆外内存。 重点知识： 堆外内存不足的时候不会执行主动触发 GC，只会抛一些 OOM 的错误。 堆外内存导致的 OOM，heap dump 是无效的 只能等老年代 full GC 的时候顺便回收下堆外空间 其他心得：如果内存不足时抛出 StackOverflowError（纵向上，无法分配栈帧）或者 OutOfMemoryError:unable to create native thread（横向上，无法建立新的线程），考虑增加 - Xss 5.2.4 外部命令导致系统缓慢避免在 Java 中使用 Runtime.getRuntime().exec() 方法来执行外部的 shell 脚本。这样的实现方式开销较大。如果频繁调用会给 CPU 和内存带来极大压力。 JVM 执行这个命令的过程： 克隆一个和当前虚拟机拥有一样环境变量的进程 勇这个心得进程去执行外部命令，最后再退出这个进程。 5.2.5 服务器 JVM 进程崩溃使用异步调用，但是被调用方和调用发速度不匹配导致大量等待的线程和 socket 连接。最后积压太多超过 JVM 承受能力使得虚拟机进程崩溃。 解决办法： 采用生产者、消费者模式的消息队列来实现 5.2.6 不恰当数据结构导致内存占用过大例如： HashMap &lt;long,long&gt;这个种类型，各种头部开销比内容 (两个 Long 类型) 开销都要大得多，导致空间利用率低。&lt;/long,long&gt; 5.2.7 由 Windows 虚拟内存导致的长时间停顿GUI 程序最小化的时候，他的工作内存被自动交换到磁盘的页面文件之中，这样发生 GC 时就又可能因为恢复页面文件的操作而导致不正常的 GC 停顿。 解决办法：加入参数 “-Dsum.awt.keepWorkingSetOnMinimize=true” 5.3 实战：IDEA 运行速度调优这个整个过程较长，可以看书 P142 页开始。 我这里仅仅记录下一些值得注意的点： hostSpot 虚拟机名字由来： 如果一段 JAVA 方法被调用次数达到一定程度，就会判断为热带码交给 JIT 编译器（Just in time compiler）编译为本地代码，提高运行速度。 visualVM 里面的 visualGC 插件还是很有用的 参考： http://ningg.top/tool-personal-intellij-idea-for-mac-optimize/ http://blog.csdn.net/zhouping118/article/details/78185362 http://blog.csdn.net/u013295276/article/details/78543190 参考：https://kaimingwan.com/post/books/shen-ru-li-jie-javaxu-ni-ji/di-wu-zhang-diao-you-an-li-fen-xi-yu-shi-zhan]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之四]]></title>
    <url>%2F2018%2F03%2F11%2F2018-03-11%2F</url>
    <content type="text"><![CDATA[JVM 小工具在 ${JAVA_HOME}/bin / 目录下 Sun/Oracle 给我们提供了一些处理应用程序性能问题、定位故障的工具, 包含 bin 描述 功能 jps 打印 Hotspot VM 进程 VMID、JVM 参数、main()函数参数、主类名 / Jar 路径 jstat 查看 Hotspot VM 运行时信息 类加载、内存、GC[可分代查看]、JIT 编译 jinfo 查看和修改虚拟机各项配置 -flag name=value jmap heapdump: 生成 VM 堆转储快照、查询 finalize 执行队列、Java 堆和永久代详细信息 jmap -dump:live,format=b,file=heap.bin [VMID] jstack 查看 VM 当前时刻的线程快照: 当前 VM 内每一条线程正在执行的方法堆栈集合 Thread.getAllStackTraces()提供了类似的功能 javap 查看经 javac 之后产生的 JVM 字节码代码 自动解析.class文件, 避免了去理解 class 文件格式以及手动解析 class 文件内容 jcmd 一个多功能工具, 可以用来导出堆, 查看 Java 进程、导出线程信息、 执行 GC、查看性能相关数据等 几乎集合了 jps、jstat、jinfo、jmap、jstack 所有功能 jconsole 基于 JMX 的可视化监视、管理工具 可以查看内存、线程、类、CPU 信息, 以及对 JMX MBean 进行管理 jvisualvm JDK 中最强大运行监视和故障处理工具 可以监控内存泄露、跟踪垃圾回收、执行时内存分析、CPU 分析、线程分析… 4.2 JDK 命令行工具 名称 主要作用 jps JVM Process Status Tool，显示指定系统内所有 HotSpot 虚拟机进程 jstat JVM Statistics Monitoring Tool，用于手机 HotSpot 虚拟机各方面运行数据 jinfo Configuration Info For Java，显示虚拟机配置信息 jmap Memory Map For Java，生成虚拟机内存转储快照（heapdumap 文件） jhat JVM Heap Dump Brower，用于分析 heapdump 文件 jstack Stack Trace For Java，显示虚拟机线程快照 4.2.1 jps：虚拟机进程状况工具1jps [options] [hostid] 参数 功能 -q 只输出 LVMID，省略主类名称 -m 输出虚拟机进程启动时传递给主类 main() 函数的参数 -l 输出主类全名，如果进程执行的是 jar 包，输出 jar 路径 -v 输出虚拟机启动时的 JVM 参数 4.2.2 jstat：虚拟机统计信息监视工具主要查询 3 类信息： 类装载 垃圾收集 运行期编译 1jstat [ option vmid [interval [s|ms] [count]] ] 参数 功能 -class 监视类装载、卸载数量、总空间及类装载所耗费的时间 -gc 监视 Java 堆状况，包括 Eden 区，2 个 survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息 -gccapacity 与 - gc 基本相同，主要关注 Java 堆各个区域使用到的最大和最小空间 -gcutil 与 - gc 基本相同，主要关注已使用空间占总空间百分比 -gccause 与 - gcutil 基本相同，但是会额外输出导致上一次 gc 产生的原因 -gcnew 监视新生代 GC 状况 -gcnewcapacity 监视内容与 - gcnew 一样，主要关注使用到的最大和最小空间 -gcold 监视老年代 GC 情况 -gcoldcapacity -compiler 输出 JIT 编译器编译过的方法、耗时等信息 -printcompilation 输出已经被 JIT 编译的方法 4.2.3 jinfo：Java 配置信息工具1jinfo [option] pid 4.2.4 jmap：Java 内存映像工具1jmap [option] vmid 参数 功能 -dump 生成 Java 堆转储快照。格式：-dump:[live,]format=b,file=，其中 live 子参数说明是否只 dump 出存活的对象 -finalizerinfo 在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只在 Linux/Solaris 下有效 -heap 显示 Java 堆详细信息，如使用哪种回收期、参数配置、分代状况等。只在 Linux/Solaris 下有效 -histo 显示堆中对象统计信息，包括类、实例数量和合计总量 4.2.5 jhat：虚拟机堆转储快照分析工具4.2.6 jstack：Java 堆栈跟踪工具1jstack [option] vmid 参数 功能 -F 强制输出 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用了本地方法的话，可以显示 C/C++ 的堆栈 4.3 JDK 可视化工具4.3.1 JConsole：Java 监视与管理控制台4.3.2 VisualVm：多合一故障处理工具 下载地址：http://visualvm.github.io/download.html 插件中心：https://visualvm.github.io/pluginscenters.html 参考：https://www.jianshu.com/p/c56884715567?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之三（垃圾收集器与内存分配策略，重点）]]></title>
    <url>%2F2018%2F03%2F10%2F2018-03-10%2F</url>
    <content type="text"><![CDATA[第三章 垃圾收集器与内存分配策略（重点）3.2 判断对象是否存活3.2.1 引用计数算法 (Reference Counting) 非主流 3.2.2 可达性分析算法 (GC Roots Analysis) 主流用这个判断 在主流的商用程序语言中 (Java 和 C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 (Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，下图对象 object5, object6, object7 虽然有互相判断，但它们到 GC Roots 是不可达的，所以它们将会判定为是可回收对象。 在 Java 语言里，可作为 GC Roots 对象的包括如下几种： a. 虚拟机栈 (栈桢中的本地变量表) 中的引用的对象 b. 方法区中的类静态属性引用的对象 c. 方法区中的常量引用的对象 d. 本地方法栈中 JNI 的引用的对象 3.2.3 引用在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用：就是指在程序代码之中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。 弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。 3.2.4 finalize() 方法最终判定对象是否存活 即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑” 阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 标记的前提是对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链。1). 第一次标记并进行一次筛选。 筛选的条件是此对象是否有必要执行 finalize() 方法。 当对象没有覆盖 finalize 方法，或者 finzlize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”，对象被回收。 2). 第二次标记 如果这个对象被判定为有必要执行 finalize（）方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的 Finalizer 线程去执行。这里所谓的 “执行” 是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象 finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致 F-Queue 队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。 Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模标记，如果对象要在 finalize（）中成功拯救自己—- 只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出 “即将回收” 的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。不过大家尽量避免使用这个方法流程图如下： 注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，因此第二段代码的自救行动失败了。 并且建议大家尽量避免使用它 GC 日志说明： GC 打印时间: [垃圾回收类型回收时间: [收集器名称: 年轻代回收前占用大小 -&gt;年轻代回收后占用大小 (年轻代当前容量), 年轻代局部 GC 时 JVM 暂停处理的时间] 堆空间 GC 前占用的空间 -&gt; 堆空间 GC 后占用的空间(堆空间当前容量),GC 过程中 JVM 暂停处理的时间]。 垃圾回收类型：分为 GC 和 Full GC. GC 一般为堆空间某个区发生了垃圾回收， Full GC 基本都是整个堆空间及持久代发生了垃圾回收，通常优化的目标之一是尽量减少 GC 和 Full GC 的频率。 收集器名称：一般都为收集器的简称或别名，通过收集器名称基本都能判断出那个区发生了 GC。 DefNew：年轻代（新生代）发生了 GC （若为 DefNew 可知当前 JVM 年轻代使用的串行收集器） ParNew：年轻代（新生代）发生了 GC （若为 ParNew 可知当前 JVM 年轻代使用了并行收集器） Tenured：老年代发生了 GC Perm：持久代发生了 GC 3.2.5回收方法区 Java 虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的 “性价表” 一般比较低。 方法区中的垃圾回收主要是：废弃常量及无用类。判断常量是否废弃与判断堆中对象十分相似。例如，若常量池中存在字符串 “abc”，而系统中并没有任何 String 对象的值为“abc” 的，也就是没有任何对象引用它，那么它就可以被回收了。无用类的判定稍微复杂点，需要满足： 1). 该类的所有对象实例已经被回收，也就是 Java 堆中不存在该类的任何实例； 2). 加载该类的 ClassLoader 已经被回收； 3). 该类的类对象 Class 没有在任何地方被引用，无法使用反射来访问该类的方法。 当方法区中的类满足以上条件时，就可以对无用类进行回收了，这里说的仅仅是 “可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了各种配置，这里不多讲。 在大量使用反射、动态代理、CGLIB 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保存永久代不会溢出。 3.3 垃圾收集算法（本书重点中的重点）3.3.1 标记 - 清除算法 (Mark-Sweep) 最基础的收集算法。其它算法都是基于这种思路并对其不足进行改进而得到的。 标记 - 清除算法将垃圾回收分为两个阶段： ①. 标记阶段：首先标记出所有需要回收的对象。 如何标记，在上面的 “判断对象是否存活” 里有讲过 ②. 清除阶段：标记完成后，统一回收被标记的对象缺点： ①. 效率问题：标记清除过程效率都不高。 ②. 空间问题：标记清除之后会产生大量的不连续的内存碎片 (空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。） 3.3.2 复制算法 (Copying)为了解决 mark-sweep 算法的效率问题 算法思想： 1). 将现有的内存空间分为两块，每次只使用其中一块. 2). 当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。 3). 再把已使用过的内存空间一次清理掉。 优点： 1). 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。 2). 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 2.3 缺点： 1). 内存减少为原来的一半，太浪费了。 2). 对象存活率较高的时候就要执行较多的复制操作，效率变低。 3). 如果不使用 50% 的对分策略，老年代需要考虑的空间担保策略。2.4. 演进 并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 EdenSpace 和两块较小的 SurvivorSpace JavaHeap 内存回收模型（当前商业虚拟机大多使用此算法回收新生代） jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 3.3.3 标记 - 整理算法 (Mark-Compact) 由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 算法思想 1). 标记阶段：首先标记出所有需要回收的对象。与 “标记 - 清除” 一样 2). 让存活的对象向内存的一段移动。 3). 直接清理掉边界以外的内存。 由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记 - 清理算法或者标记整理算法。 3.3.4 代收集算法 (Generational Collecting) 当前的商业虚拟机的垃圾收集都采用，把 Java 堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 “标记 - 清除” 或者 “标记 - 整理” 算法来进行回收。 3.4 HotSpot的算法实现3.4.1 枚举根节点可达性分析在执行 GC 的时候会停顿一下，如果引用关系不断变换的时候很难进行准确的可达性分析。目前虚拟机主要采用的是准确性 GC，虚拟机应该有办法知道哪些地方存着对象引用，在 HotSpot 的实现中，用一组叫做 OopMap 的数据结构来实现这个目的，在类加载完成后记录下对象内的数据类型与偏移量，在 JIT 编译 过程中记录下栈和寄存器中哪些位置是引⽤。 3.4.2 安全点导致 OopMap 变化的指令非常多，我们只在特定的地点做记录，我们把这些点叫做安全点，也就是说让所以线程（不包括 JNI 调用的线程）跑到最近的安全点再停顿下来，所以安全点不能让 GC 等待时间过长，也不能太频繁。这里我们分为两种方式 抢占式中断，在 GC 的时候停下所以线程，再让没有到安全点的跑到安全点，目前几乎没有虚拟机采用这种方式进行 GC 主动式中断，当 GC 需要中断线程的时候，在安全点上设置中断标 志，线程执⾏时主动轮询中断标志，发现标志为真时则主动中断挂 起线程。轮训标志的地方和安全点重合。 3.4.3 安全区域指线程在某⼀段代码⽚段中，引⽤关系不会发⽣变化，在这个区域中的任意点开始 GC 都是安全的。GC 的时候不用考虑处于安全区域的，当线程出安全区域的时候要检查是否 GC 完成了，在线程处于 blocked 或 sleep 状态⽆法跑到安全点时，采⽤安全区域可以避免 GC ⻓时间等待。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 3.5 垃圾收集器 如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。 GC实现目标: 准确、高效、低停顿、空闲内存规整. ————————–新生代收集器———————— 3.5.1 Serial 收集器Serial 收集器是最基本、发展历史最悠久的收集器，曾经（在 JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。 特性：这个收集器是一个单线程的收集器，但它的 “单线程” 的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Stop The World 应用场景：Serial 收集器是虚拟机运行在 Client 模式下的默认新生代收集器。 优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 3.5.2 ParNew 收集器 特性：ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。 应用场景：ParNew 收集器是许多运行在 Server 模式下的虚拟机中首选的新生代收集器。 很重要的原因是：除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS 收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。 Serial 收集器 VS ParNew 收集器：ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 Serial 收集器。然而，随着可以使用的 CPU 的数量的增加，它对于 GC 时系统资源的有效利用还是很有好处的。 3.5.3 Parallel Scavenge 收集器 1. 特性： Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 应用场景：停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 对比分析： Parallel Scavenge 收集器 VS CMS 等收集器：Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为 “吞吐量优先” 收集器。 Parallel Scavenge 收集器 VS ParNew 收集器：Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别是它具有自适应调节策略。 GC 自适应的调节策略：Parallel Scavenge 收集器有一个参数 -XX:+UseAdaptiveSizePolicy。当这个参数打开之后，就不需要手工指定新生代的大小、Eden 与 Survivor 区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。 ————————- 老年代收集器—————————- 3.5.4 Serial Old 收集器 特性：Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记－整理算法。 应用场景： Client 模式Serial Old 收集器的主要意义也是在于给 Client 模式下的虚拟机使用。 Server 模式如果在 Server 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 3.5.5 Parallel Old 收集器 特性：Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记－整理” 算法。 应用场景：在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器外别无选择（Parallel Scavenge 收集器无法与 CMS 收集器配合工作）。由于老年代 Serial Old 收集器在服务端应用性能上的 “拖累”，使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合“给力”。直到 Parallel Old 收集器出现后，“吞吐量优先” 收集器终于有了比较名副其实的应用组合。 3.5.6 CMS(Concurrent Mark Sweep) 收集器 1. 特性： CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。 CMS 收集器是基于 “标记—清除” 算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤： 初始标记（CMS initial mark）初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要 “Stop The World”。 并发标记（CMS concurrent mark）并发标记阶段就是进行 GC Roots Tracing 的过程。 重新标记（CMS remark）重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要 “Stop The World”。 并发清除（CMS concurrent sweep）并发清除阶段会清除对象。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。 优点：CMS 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。 缺点： CMS 收集器对 CPU 资源非常敏感其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU 数量 + 3）/ 4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大。 CMS 收集器无法处理浮动垃圾CMS 收集器无法处理浮动垃圾，可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为 “浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS 收集器会产生大量空间碎片CMS 是一款基于 “标记—清除” 算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC。—————————新生代和老年代均适用——————— 3.5.7 G1 收集器 特性：G1（Garbage-First）是一款面向服务端应用的垃圾收集器。HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。 并行与并发G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。 分代收集与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合与 CMS 的 “标记—清理” 算法不同，G1 从整体来看是基于 “标记—整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。 可预测的停顿这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。 在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。 G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 执行过程：G1 收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking）初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）筛选回收阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 3.5.8、GC 相关参数总结VM 常用参数整理 参数 描述 -Xms 最小堆大小 -Xmx 最大堆大小 -Xmn 新生代大小 -XX:PermSize 永久代大小 -XX:MaxPermSize 永久代最大大小 -XX:+PrintGC 输出 GC 日志 -verbose:gc - -XX:+PrintGCDetails 输出 GC 的详细日志 -XX:+PrintGCTimeStamps 输出 GC 时间戳 (以基准时间的形式) -XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息 -Xloggc:/path/gc.log 日志文件的输出路径 -XX:+PrintGCApplicationStoppedTime 打印由 GC 产生的停顿时间 垃圾收集器参数总结 参数 描述 -XX:+UseSerialGC Jvm 运行在 Client 模式下的默认值，打开此开关后，使用 Serial + Serial Old 的收集器组合进行内存回收 -XX:+UseParNewGC 打开此开关后，使用 ParNew + Serial Old 的收集器进行垃圾回收 -XX:+UseConcMarkSweepGC 使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收，Serial Old 作为 CMS 出现 “Concurrent Mode Failure” 失败后的后备收集器使用。 -XX:+UseParallelGC Jvm 运行在 Server 模式下的默认值，打开此开关后，使用 Parallel Scavenge + Serial Old 的收集器组合进行回收 -XX:+UseParallelOldGC 使用 Parallel Scavenge + Parallel Old 的收集器组合进行回收 -XX:SurvivorRatio 新生代中 Eden 区域与 Survivor 区域的容量比值，默认为 8，代表 Eden:Subrvivor = 8:1 -XX:PretenureSizeThreshold 直接晋升到老年代对象的大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 -XX:MaxTenuringThreshold 晋升到老年代的对象年龄，每次 Minor GC 之后，年龄就加 1，当超过这个参数的值时进入老年代 -XX:UseAdaptiveSizePolicy 动态调整 java 堆中各个区域的大小以及进入老年代的年龄 -XX:+HandlePromotionFailure 是否允许新生代收集担保，进行一次 minor gc 后, 另一块 Survivor 空间不足时，将直接会在老年代中保留 -XX:ParallelGCThreads 设置并行 GC 进行内存回收的线程数 -XX:GCTimeRatio GC 时间占总时间的比列，默认值为 99，即允许 1% 的 GC 时间，仅在使用 Parallel Scavenge 收集器时有效 -XX:MaxGCPauseMillis 设置 GC 的最大停顿时间，在 Parallel Scavenge 收集器下有效 -XX:CMSInitiatingOccupancyFraction 设置 CMS 收集器在老年代空间被使用多少后出发垃圾收集，默认值为 68%，仅在 CMS 收集器时有效，-XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSCompactAtFullCollection 由于 CMS 收集器会产生碎片，此参数设置在垃圾收集器后是否需要一次内存碎片整理过程，仅在 CMS 收集器时有效 -XX:+CMSFullGCBeforeCompaction 设置 CMS 收集器在进行若干次垃圾收集后再进行一次内存碎片整理过程，通常与 UseCMSCompactAtFullCollection 参数一起使用 -XX:+UseFastAccessorMethods 原始类型优化 -XX:+DisableExplicitGC 是否关闭手动 System.gc -XX:+CMSParallelRemarkEnabled 降低标记停顿 -XX:LargePageSizeInBytes 内存页的大小不可设置过大，会影响 Perm 的大小，-XX:LargePageSizeInBytes=128m Client、Server 模式默认 GC 服务端 or 客户端 新生代 GC 方式 老年代和持久代 GC 方式 Client Serial 串行 GC Serial Old 串行 GC Server Parallel Scavenge 并行回收 GC Parallel Old 并行 GC Sun/oracle JDK GC 组合方式 参数 新生代 GC 方式 老年代和持久代 GC 方式 -XX:+UseSerialGC Serial 串行 GC Serial Old 串行 GC -XX:+UseParallelGC Parallel Scavenge 并行回收 GC Serial Old 并行 GC -XX:+UseConcMarkSweepGC ParNew 并行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时，采用 Serial Old 串行 GC -XX:+UseParNewGC ParNew 并行 GC Serial Old 串行 GC -XX:+UseParallelOldGC Parallel Scavenge 并行回收 GC Parallel Old 并行 GC -XX:+UseConcMarkSweepGC -XX:+UseParNewGC Serial 串行 GC CMS 并发 GC 当出现 “Concurrent Mode Failure” 时采用 Serial Old 串行 GC 常用的收集器组合 服务器 31 新生代 GC 策略 老年老代 GC 策略 说明 组合 1 Serial Serial Old Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。 组合 2 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。 组合 3 ParNew CMS 使用-XX:+UseParNewGC选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用 - XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用 ParNew GC 策略。 组合 4 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。 组合 5 Parallel Scavenge Serial Old Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 组合 6 Parallel Scavenge Parallel Old Parallel Old 是 Serial Old 的并行版本 组合 7 G1GC G1GC -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启；-XX:MaxGCPauseMillis =50 #暂停时间目标；-XX:GCPauseIntervalMillis =200 #暂停间隔目标；-XX:+G1YoungGenSize=512m #年轻代大小；-XX:SurvivorRatio=6 #幸存区比例 1. 与串行回收器相关的参数 -XX:+UseSerialGC: 在新生代和老年代使用串行回收器。 -XX:+SuivivorRatio: 设置 eden 区大小和 survivor 区大小的比例。 -XX:+PretenureSizeThreshold: 设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。 -XX:MaxTenuringThreshold: 设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。 2. 与并行 GC 相关的参数 -XX:+UseParNewGC: 在新生代使用并行收集器。 -XX:+UseParallelOldGC: 老年代使用并行回收收集器。 -XX:ParallelGCThreads：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。 -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。 -XX:GCTimeRatio: 设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 -XX:+UseAdaptiveSizePolicy: 打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 3. 与 CMS 回收器相关的参数 -XX:+UseConcMarkSweepGC: 新生代使用并行收集器，老年代使用 CMS + 串行收集器。 -XX:+ParallelCMSThreads: 设定 CMS 的线程数量。 -XX:+CMSInitiatingOccupancyFraction: 设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68%。 -XX:+UseFullGCsBeforeCompaction: 设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 -XX:+CMSClassUnloadingEnabled: 允许对类元数据进行回收。 -XX:+CMSParallelRemarkEndable: 启用并行重标记。 -XX:CMSInitatingPermOccupancyFraction: 当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是 - XX:+CMSClassUnloadingEnabled 激活了)。 -XX:UseCMSInitatingOccupancyOnly: 表示只在到达阈值的时候，才进行 CMS 回收。 -XX:+CMSIncrementalMode: 使用增量模式，比较适合单 CPU。 4. 与 G1 回收器相关的参数 -XX:+UseG1GC：使用 G1 回收器。 -XX:+UnlockExperimentalVMOptions: 允许使用实验性参数。 -XX:+MaxGCPauseMills: 设置最大垃圾收集停顿时间。 -XX:+GCPauseIntervalMills: 设置停顿间隔时间。 5. 其他参数 -XX:+DisableExplicitGC: 禁用显示 GC。 3.6 内存分配与回收策略（重点） Java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题： 1). 给对象分配内存; 2). 回收分配给对象的内存。关于回收内存这一点请参考如下文章 内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为 “对象游离”。 Jvm 怎么判断对象可以回收了？ 1). 对象没有引用，被判定为 “死亡”（并不是这个对象被赋值为 null 之后就一定被标记为可回收） 2). 作用域发生未捕获异常 3). 程序在作用域正常执行完毕 4). 程序执行了 System.exit() 5). 程序发生意外终止（被杀进程等） 对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 分配前请先了解下新年代和老年代： 3.6.1 对象优先在 Eden 分配 前面的文章介绍过 Hotspot 虚拟机新生代内存布局及算法： a. 将新生代内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。b. 每次使用 Enden 和其中一块 Survivor。c. 当回收时，将 Eden 和使用中的 Sruvivor 中还存的对象一次性复制到另一块 Survivor；d. 然后清理掉 Eden 和使用过的 Survivor 空间；e. 后面就使用 Eden 和另一块 Survivior 空间，重复步骤 3。 默认 Eden：Survivor=8：1，即每次可以使用 90% 的空间，只有一块 Survivor 空间被浪费。 大多数情况下，对象在 Eden 区中分配；当 Eden 区没有足够空间进行分配时，JVM 将会发起一次 MinorGC(新生代 GC)。MinorGC 时，如果发现存活的对象无法全部放入 Servivor 空间，只好通过分配机制提前转入熬年老代中。 3.6.2 大对象直接进入老年代 所谓的大对象是指：需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。 大对象对虚拟机的内存分配来说就是一个坏消息，比遇到一个大对象更加坏的消息就是：遇到一群 “朝生夕灭” 的 “短命大对象”。 经常出现大对象容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。 所以我们应该避免创建大对象； “-XX:PretenureSizeThreshold”： 可以设置这个阀值，大于这个参数值的对象直接在年老代中分配。 默认为 0(无效)，且只对 Serail 和 ParNew 两款收集器有效。 如果需要使用该参数，可以考虑 ParNew+CMS 组合 长期存活的对象将进入年老代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.3 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄 (Age) 计数器，其计算流程如下： a. 在 Enden 区中分配的对象，经 Minor GC 之后还存活，就复制移动到 Survivor 区，年龄为 1； b. 而后每经历一次 Minor GC 后还存活，在 Survivor 区复制移动一次，年龄就增加 1 岁。 c. 如果年龄达到一定程度，就晋升到年老代中。 “-XX:MaxTenuringThreshold”： 设置新生代对象晋升年老代的年龄阀值，默认为 15 3.6.4 动态对象年龄判定JVM 为了更好适应不同程序，不是永远要求等到 MaxTenuringThreshold 参数设置的年龄。 如果在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，大于或等于该年龄的对象就可以直接进入年老代。 3.6.5 空间分配担保 当 Survivor 空间不够用时，需要依赖其他内存 (年老代) 进行分配担保(Hanle Promotion) 分配担保流程如下： a. 在发生 Minor GC 之前，JVM 首先检查年老代最大可用的连续空间是否大于新生所有对象的空间。 b. 如果大于，那么可以确保 Minor GC 是安全的。 c. 如果不大于，则 JVM 查看 HandlePromotionFailure 值是否允许担保失败。 d. 如果允许，将尝试进行一次 Minor GC，但这是有风险对的； e. 如果小于或 HandlePromotionFailure 值不允许冒险，那这时，要改为进行一次 Full GC； 尝试 Minor GC 的风险 – 担保失败： 因为尝试 Minor GC 前，无法知道存货的对象大小，所以使用历次晋升到年老代对象的平均大小作为经验值。 加入尝试的 Minor GC 最终存活的对象远远高于经验值的话，会导致担保失败 (Handle Promotion Failure)。 失败后只有重新发起一次 Full GC，这绕了一个大圈，代价较高。 但一般还是要开启 HandlePromotionFailure，避免 Full GC 过于频繁，而且担保失败概率还是比较低的。 JDK1.6 之后，JVM 代码中已经不再使用 HandlePromotionFailure 参数了… 规则变为： 只要年老代最大可用的连续空间大于新生所有对象的空间或历次晋升到年老代对象的平均大小，就会进行 MinorGC，否则进行 Full GC。 即年老代最大可用的连续空间小于新生所有对象空间时，不在检查 HandlePromotionFailure，而是直接检查历次晋升熬年老代对象的平均大小。 参考：http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/https://www.jianshu.com/p/50d5c88b272dhttp://blog.csdn.net/simba_cheng/article/details/78223010]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM参数调优]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09%2F</url>
    <content type="text"><![CDATA[常见配置汇总堆设置-Xms:初始堆大小-Xmx:最大堆大小-XX:NewSize=n:设置年轻代大小-XX:NewRatio=n:设置年轻代和年老代的比值.如:为3,表示年轻代与年老代比值为1:3,年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:3,表示Eden:Survivor=3:2,一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数.并行收集线程数.-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式.适用于单CPU情况.-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数. 参考：http://blog.csdn.net/xiajian2010/article/details/17376157]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理数据可视化]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[根据现有数据集进行数据表查询集构建： galleryproduction 左外联结 production: 1234SELECT scratch_api_production.id,scratch_api_galleryproduction.production_id,scratch_api_production.nameFROM scratch_api_galleryproduction LEFT JOIN scratch_api_productionON scratch_api_production.id=scratch_api_galleryproduction.production_id production 左外联结 user: 1234SELECT scratch_api_production.author_id,scratch_api_user.baseuser_ptr_id,scratch_api_user.sex,scratch_api_user.gradeFROM scratch_api_production LEFT JOIN scratch_api_user ON scratch_api_production.author_id=scratch_api_user.baseuser_ptr_id 再构建三联表： galleryproduction左外联结production左外联结user 三表联结查询模版： 123select username,psw,gname,tel from (t1 left join t2 on t1.t1_id=t2.t1_id) left join t3 on t1.t1_id=t3.t1_id 我根据业务流程实现的sql查询： 查询某专题活动中的所有信息 1234SELECT *FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 然后使用阿里云的DataV进行数据可视化: 需要对接接口： 查询点赞数最多作品排行： 12345SELECT scratch_api_production.like,scratch_api_production.name FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' AND sex='男'ORDER BY scratch_api_production.like DESC 查询结果集中的男女人数 123456789SELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='男'UNIONSELECT sex as 性别, COUNT(sex) AS '人数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 AND sex='女' 查询某专题活动学校参与度排名 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询某专题活动中的参与性别 1234SELECT scratch_api_user.sexFROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' 查询年级占比 123456SELECT scratch_api_user.grade ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.grade is not NULLGROUP BY scratch_api_user.gradeorder by count(*) desc 查询学校占比 123456SELECT scratch_api_user.school_id ,COUNT(*)FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1 and scratch_api_user.school_id is not NULLGROUP BY scratch_api_user.school_idorder by count(*) desc 查询作品提交时间 12345SELECT DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") as '日期',count(*) as '当日投票数'FROM (scratch_api_galleryproduction LEFT JOIN scratch_api_production ON scratch_api_galleryproduction.production_id=scratch_api_production.id)LEFT JOIN scratch_api_user ON scratch_api_production.author_id = scratch_api_user.baseuser_ptr_idWHERE scratch_api_galleryproduction.gallery_id = 'c8d29756ce4d4e72900dcee34b3b6925' and scratch_api_galleryproduction.admin_checked = 1GROUP BY DATE_FORMAT(scratch_api_production.update_time,"%Y/%m/%e") 把地址转换成经纬度不要方，利用高德地图经纬度快速查询工具可以轻松地把任何地址转换成经纬度，可具体到门牌号喔，工具地址： 控制台 | 高德开放平台 | 高德地图API 义乌市首届Scratch编程周实时数据状态网址(动态页面):http://datav.aliyun.com/share/07ef37b235d9763bd364f344912d1a05大数据可视化说明:大数据屏幕：1920*1080（可修改）最高实时更新频率：1min/次正常显示的预览效果参考（静态截图）：http://p4lmrb1gp.bkt.clouddn.com/15205615855957.jpg本机上如果不是上述参考效果请检查自己的浏览器如下:推荐电脑上预览：首选谷歌 Chrome 浏览器版本56以上，其他浏览器则需更新至最新版并开启极速（chrome内核）模式，不要使用IE浏览器，否则无法正常显示。不推荐手机上预览：无法按默认长宽比例展示 预览效果：]]></content>
      <tags>
        <tag>数据可视化</tag>
        <tag>DataV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之二（Java内存区域与内存溢出异常&实战，重点）]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-05-2%2F</url>
    <content type="text"><![CDATA[第二章 Java内存区域与内存溢出异常&amp;实战第二章结构： Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。参考：https://www.jianshu.com/p/989c90f339b9 2.2 运行时数据区域具体见下图： 2.2.1 程序计数器（Program Counter Register） 概述：该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有：因为 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。2.无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法（本地方法，一个调用非Java代码的接口），这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError情况的区域。（个人理解：参考C++理解是：当线程中调用native方法的时候，当前线程应当会被阻塞，重新启动一个新的线程，那么计数器为空则不会影响新线程的计数器，相互独立。当前线程应当会被阻塞，直到另外一个线程执行结束。当然参数也会被保留） 2.2.2 Java 虚拟机栈（Java Virtual Machine Stacks） 我们经常将 Java 内存分为堆内存（Heap）和栈内存（Stack），这种分法中所指的栈就是 Java 虚拟机栈，或者说是虚拟机栈中 局部变量表 部分。 概述：描述 Java 方法执行的内存模型，每个方法从调用直至执行的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。2.2.3 本地方法栈（Native Method Stack） 概述：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 2.2.4 Java 堆（Java Heap） java堆是所有线程共享的一块内存区域，由虚拟机启动时创建，堆得唯一目的就是存储对象的实例。几乎所有的对象实例都在改内存区域分配，但是随着JIT编译器（即时编译）的发展及逃逸分析技术（分析指针的动态范围）的发展，栈上分配、标量替换导致堆分配不那么“绝对”了。 作用：此区域唯一的目的就是存放对象实例。 特点：1.被所有线程共享。2.在虚拟机启动时创建。 异常类型 发生条件 OutOfMemoryError 在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。 划分：更好的回收内存或分配内存【新生代（Eden、From Survivor、To Survivor）】【老年代】 新生代：主要存放应用程序中生命周期短的内存对象，经常被回收 老生代：主要存放应用程序中生命周期长的内存对象 可物理上不连续，逻辑上连续，通过-Xmx,-Xms来控制堆的扩展。 2.2.5 方法区（Method Area） 概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开。 作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。 特点：线程共享。 异常 异常类型 发生条件 OutOfMemoryError 当方法区无法满足内存分配需求时，抛出该异常。 内存：Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。 相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对 常量池的回收 和 类型的卸载。 2.2.6 运行时常量池（Runtime Constant Pool） 概述：方法区的一部分。Class 文件中除了有类的（版本、字段、方法、接口）等描述信息外，还有一项信息就是常量池。 作用：用于存放编译器生成的各种 字面量 和 符号引用。 动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。 异常 异常类型 发生条件 OutOfMemoryError 因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。 2.2.7 直接内存（Direct Memory） 概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 异常 异常类型 发生条件 OutOfMemoryError 直接内存并不受java堆大小的限制，只是受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。 2.3 HotSpot 虚拟机对象探秘 这一部分内容将以 HotSpot 虚拟机和常用的内存区域 Java 堆为例，阐述对象分配、布局和访问的全过程。 2.3.1 对象的创建 概述：Java 是一门面向对象的编程语言，在 Java 程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个 new 关键字而已，而在虚拟机中对象的创建则分为以下几个步骤。 虚拟机遇到New指令 首先检查指令的参数能否在常量池中定位到一个类的符号引用 检查这个符号引用对应的类是否已被加载、解析、初始化过 没有加载，则需要先加载 为新生对象分配内存区域（指针碰撞&amp;空闲列表） 线程安全（方案1：对分配内存空间的动作同步；方案2：本地线程分配缓冲 TLAB） 对对象进行必要的设置 调用init方法 类加载概述：虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存概述：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。 分配方式：1.指针碰撞（Bump the Pointer）：假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。2.空闲列表（Free List）：如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。 同步控制概述：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。 方案一：对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。 初始化概述：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。作用：保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。 对象头（Object Header）概述：接下来，虚拟机要为对象头数据进行设置。（e.g. 对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄） init概述：在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，&lt;init&gt; 方法还没有被执行，所有的字段还为零值。 一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，将对象按照我们的意愿进行初始化，这样一个真正的对象才算完全产生。 2.3.2对象的内存布局 在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域。 对象头（存放对象自身的运行时数据&amp;类型指针） 实例数据 对齐填充 2.3.2.1 对象头（Header） HotSpot 虚拟机的对象头包括两部分信息，存储自身的运行时数据的（Mark Word） 和 类型指针。 第一部分：Mark Word 概述：用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。 内存：对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 HotSpot 虚拟机对象头 Mark Word 表如下 第二部分：类型指针 概述：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 Reminder并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。(见2.2.3节) 数组对象：如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。 2.3.2.2 实例数据（Instance Data） 概述：这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 存储顺序：这部分的存储顺序会受到虚拟机 分配策略参数（FieldsAllocationStyle） 和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles =&gt; ints =&gt; shorts/chars =&gt; bytes/booleans =&gt; oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 2.3.2.3 对齐填充（Padding） 概述：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 原理：由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 2.3.3 对象的访问定位 概述：建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以 对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有两种。 句柄访问：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。 直接指针：Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示。 比较：1.句柄访问：使用句柄访问的最大好处就是 reference 中存储的是 稳定的 句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。2.指针访问：使用直接访问最大的好处就是 速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 Sun HotSpot 使用的是第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 2.4 实战：OutOfMemoryError 异常 在 Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemory（OOM）异常的可能。 目的：1. 通过代码验证 Java 虚拟机规范中描述的各个运行时区域的存储内容。2. 遇到实际的内存溢出异常时，能根据异常的信息快速判断哪个区域的内存溢出。3. 了解什么样的代码可能会导致这些区域内存溢出，并了解如何处理。 VM Args 设置 Eclipse IDE：Debug Configurations =&gt; Java Application =&gt; YoungGenGC =&gt; Arguments 中的 VM arguments 中进行书写（书写参数以 - 开头，以空格分隔）。 控制台：直接跟在 Java 命令之后书写。 本人运行在 Mac 系统下，使用 IDEA 进行配置，步骤如下所示👇。 1\. 打开 Run Configurations（⌃ + ⌥ + R 选择 0 ）或者（⌘ + ⇧ + A 输入 run 选择 run…）。 2\. 点击并打开 VM options。 3\. 写入虚拟机启动参数。 4.Apply 并 Run。 2.4.1 - Java 堆溢出 概述：Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 测试环境： 12345-verbose:gc-Xms20M // 最小 GC 启动-Xmx20M // 最大 GC 启动-XX:+PrintGCDetails // 打印设置-XX:SurvivorRatio=8 // 存活对象比率 测试代码：HeapOOM 123456789101112131415import java.util.*;public class Main &#123; private static class OOMObject &#123; &#125; public static void main(String[] args) &#123; List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true) &#123; list.add(new OOMObject()); &#125; &#125;&#125; 运行结果： 1java.lang.OutOfMemoryError: Java heap space 分析：Java 堆内存的 OOM 异常是时机应用中常见的内存溢出异常情况。当出现 Java 堆内存溢出时，异常堆栈信息 java.lang.OutOfMemoryError 会跟着进一步提示 Java heap space。 解决方式 堆转储快照：要解决这个区域的异常，一般的手段是先通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。 内存泄露：进一步通过工具查看泄露对象到 CG Roots 的引用链，于是就能找到内存泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄露代码的位置。 内存溢出：如果不存在泄露，换句话说，就是内存中的对象确实都必须还活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对象看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗。 2.4.2 - 虚拟机栈和本地方法栈溢出 概述：由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoos 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 -Xss 参数设定。关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常。 异常类型 发生条件 StackOverflowError 线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。 OutOfMemoryError 无法申请到足够的内存时抛出该异常。 这里把异常分为两种情况，看似更加严谨，但却存在一些相互重叠的地方：方栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事的两种描述而已。 2.4.2.1 - StackOverflowError 测试环境：在此测试中，将测试范围限制于单线程中操作。1. 使用 -Xss 参数减少栈内存容量，结果抛出 SOF 异常，异常出现时输出的堆栈深度相应缩小。2. 定义了大量的本地变量，增大此方法栈中本地变量表长度。结果抛出 SOF 异常时输出的堆栈深度相应缩小。 JavaVMStackSOF: 1234567891011121314151617181920212223242526//JavaVMStackSOF//VM Args: -Xss160k // 栈内存容量public class Main &#123; public static class JavaVMStackSOF&#123; private int stackLength = 1; public void stackLeak() &#123; stackLength++; stackLeak(); &#125; &#125; public static void main(String[] args) throws Throwable &#123; JavaVMStackSOF oom = new JavaVMStackSOF(); try &#123; oom.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println("Stack length: " + oom.stackLength); throw e; &#125; &#125;&#125; 运行结果 123Exception in thread &quot;main&quot; Stack length: 771java.lang.StackOverflowError at Main$JavaVMStackSOF.stackLeak(Main.java:8) 分析：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者确切地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 理解：操作系统分配给每个进程的内存是有限的，虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存 -Xms（最大堆容量） -MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略不计。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈瓜分了。每个线程分配到的栈容量越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。 探索：出现 SOF 异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的）达到 1000 - 2000 完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果建立过多线程导致内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过 减少最大堆 和 减少栈容量 来换更多的线程。 2.4.2.2 - OutOfMemoryError 测试环境注意：下面这块代码运行有风险，书上说在windows上会造成系统假死，我在mac上的IDEA上运行，也死机了，测了两次，都导致了系统假死。 JavaVMStackOOM 12345678910111213141516171819202122232425262728293031323334public class Main &#123; //VM Args: -Xss2M // 栈内存容量 //测试代码：创建线程导致内存溢出异常 private void dontStop() &#123; while (true) &#123; &#125; &#125; // 循环开启线程 public void stackLeakByThread() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; dontStop(); &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; Main oom = new Main(); oom.stackLeakByThread(); &#125;&#125; 运行结果（参考别人的结果） 1Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread 这是mac死机时用手机照的(；′⌒`)cpu已爆表 2.4.3 - 方法区和运行时常量池溢出 概述：由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。 脑补：String.intern() 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。在 JDK1.6 以及之前的版本中，由于常量池分配在永久代内，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小名，从而间接限制其中常量池的容量。 2.4.3.1 - OutOfMemoryError 测试环境 12-XX:PermSize=10M // 方法区最小值-XX:MaxPermSize=10M // 方法区最大值 测试代码RuntimeConstantPoolOOM 12345678910111213package com.company.bupt;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); long i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 在JDK1.6上运行结果如下： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at com.company.bupt.Main.main(Main.java:10) 分析：从运行结果中可以看到，运行时常量池溢出，在 OutOfMemoryError 后面跟随的提示信息是 PermGen space，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分。 在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为JVM实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。 在JDK7之前的HotSpot虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。 在JDK8之前的HotSpot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域。永久代一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过‑XX:MaxPermSize 设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误(OOM)。 参考：Java永久代去哪儿了 http://www.infoq.com/cn/articles/Java-PERMGEN-Removed 总结：java jdk1.7中的常量池移到了堆中，同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域，如果想了解更多可以参考：http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.htmlhttp://blog.csdn.net/zhyhang/article/details/17246223/ 在JDK1.7上测试 模拟了一下常量池的oom，突然发现设置的参数-XX:PermSize=10M -XX:MaxPermSize=10M不管用了，同时发现内存一直在上升，当上升到一个极值就会趋于平稳，然后再过一段时间会报：Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded这个异常是当GC的时间超过总运行时间的98%才会报的，是为了防止GC占用的时间过长。 运行结果 2.4.3.2 - String 常量池测试 使用 JDK1.7 运行这段程序就不会得到相同的结果，while 循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响。 测试代码RuntimeConstantPoolOOM1 12345678910111213package com.company.bupt;public class Main &#123; public static void main(String[] args) &#123; String str1 = new StringBuilder("计算机").append("软件").toString(); System.out.println(str1.intern() == str1); String str2 = new StringBuilder("ja").append("va").toString(); System.out.println(str2.intern() == str2); &#125;&#125; 分析： JDK1.6：会得到两个 false，而在 JDK1.7 中运行，会得到一个 true 和一个 false。产生差异的原因是：是 JDK1.6 中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由 StringBuilder 创建的字符串实例在 Java 堆上，所以必然不是同一个引用，将返回 false JDK1.7：intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此 intern() 返回的引用和由 StringBuilder 创建的那个字符串实例是同一个。对 str2 比较返回 false 是因为 java 这个字符串在执行 StringBuilder.toString() 之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而 计算机软件 这个字符串是首次出现的，因此返回 true。 JVM启动的时候已经写到常量池里了，类似的还有’main’、’int’、’float’。参考：https://www.jianshu.com/p/b98851899f37 JDK1.7上测试结果: 12345678String str1 = new StringBuilder("jc").append( "vc" ).toString();//JVM不会自动加载jcvc，所以这个jcvc是首次出现的，返回true System.out.println(str1.intern()==str1); String str2=new StringBuilder("mai").append( "n" ).toString(); //main已经被自动加载了，不是首次出现，所以返回false System.out.println(str2.intern()==str2); String str3=new StringBuilder("in").append( "t" ).toString(); //flase System.out.println(str3.intern()==str3); String str4=new StringBuilder("flo").append( "at" ).toString(); //flase System.out.println(str4.intern()==str4); JDK1.6上测试上述代码则全返回是false 2.4.3.3 - 方法区溢出 方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本思路就是运行时产生大量的类去填满方法区，直到溢出。另外的，直接使用 Java SE API 也可以动态产生类（如反射时的 GeneratedConstorAccessor 和动态代理等）。 但在本次试验使用CGLIB直接操作字节码运行时，生成大量的动态类。 值得注意的是，当前主流的很多框架 如：Spring,Hibernate对类进行增强时，都会使用到类似CGLIB这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载如内存。 注意：项目必须引入asm-6.0.jar和cglib-3.2.6.jar，需要手动寻找引入 测试代码JavaMethodAreaOOM： 1234567891011121314151617181920212223242526272829303132333435package com.company.bupt;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 测试方法区内存溢出 * 方法区保存的是Class的相关信息，如类名，字段描述符等等，在这里使用cglib来创建大量的类信息来使方法区内存溢出 * * 异常信息为：java.lang.OutOfMemoryError: PermGen space * VM args:-XX:PermSize=10m -XX:MaxPermSize=10m * @author Tim * */public class Main &#123; public static void main(String[] args) &#123; while(true)&#123; Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125; static class OOMObject&#123; &#125;&#125; 以下是我的实测情况： 下列是在JDK1.6上测试得到的： 下列是在JDK1.7上测试得到的： 2.4.3.4 - 总结 方法区溢出是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量的 Class 的应用中，需要特别注意类的回收情况。这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 2.4.4 - 本机直接内存溢出 概述：DirectMemory 容量可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（-Xmx指定）一样，下面的测试代码越过了 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）。因为，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 unfase.allocateMemory()。 测试代码DirectMemoryOOM 12345678910111213141516171819202122package com.company.bupt;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M * @author zzm */public class Main &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 运行结果参考： 123Exception in thread &quot;main&quot; java.lang.OutOfMemoryErrorat sun.misc.Unsafe.allocateMemory(Native Method)at org.fenixsoft.oom.DMOOM.main(DMOOM.java:20) 以下是JDK1.6上实测：程序并没有报错 分析：由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看到明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，那就可以考虑检查一下是不是这方面的原因。 参考:https://www.jianshu.com/p/989c90f339b9]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解java虚拟机》学习笔记之一]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-06%2F</url>
    <content type="text"><![CDATA[全书核心分布： 第一章 走近JAVA1.6 实战：自己编译JDK(已成功编译) 疑问： 将JDK源码进行编译是做了点什么？是将JDK中的.java文件编译成.class文件吗？ JDK中包含开发工具包和JVM，作者编译完JDK以后，用的还是原来包中的JVM吗？ 我们平常使用的JDK，例如JDK1.7中，里面的文件是以.java形式存在的还是以.class形式存在的，或者是以.java形式存在，要用的时候再用JVM去编译的?答： JDK是c/c++写的, 编译就是把JDK编译成可以运行的状态, 可运行的意思是指可以编译运行.java文件. 而一般情况下官方下载的JDK都是已经帮你编译好而已. 作者可以用自己编译的, 也可以用官方编译好的. 这个要看书中的说明了 JDK是c/c++写的, 里面和其他c++程序没什么区别, windows下面是一堆dll和一堆exe. 你说的.java文件是JDK的功能之一, 帮你编译java文件成class, JVM是运行class文件的容器 一 环境： 操作系统：CentOS6.8计划编译的jdk: openjdk7现成的jdk: java version “1.6.0_25”(Java HotSpot(TM) 64-Bit Server VM (build 20.0-b11, mixed mode))jdk6下载链接如果你当前的系统版本不是这个，没关系，只要下载上述版本安装rpm（默认安装到/usr/java路径下）(不必配置环境变量)即可 二 编译前准备工作如下123456yum install -y mercurialyum install -y ant ant-nodepsyum install -y libX11* libX*yum install -y libXi-devel libXtst-devel libXt-devel freetype* yum install -y alsa-lib-devel cups-develyum install -y gcc gcc-c++ 三 下载计划编译的openjdk7(jdk源码网站：http://hg.openjdk.java.net/jdk7u/ ， 你值得收藏) 1234hg clone http://hg.openjdk.java.net/jdk7u/jdk7u-devcd jdk7u-devchmod 755 get_source.sh ./get_source.sh 四 编译4.1准备好编译环境相关参数解释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export LANG=C#Bootstrap JDK的安装路径，必须设置export ALT_BOOTDIR=/export/servers/jdk1.6.0_25/#允许自动下载依赖export ALLOW_DOWNLOADS=true#并行编译的线数，设置和cpu的数量一致即可export HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2#比较本次build出来的映像与先前版本的差异，这对我们来说没有意义，export SKIP_COMPARE_IMAGES=true#使用预编译头文件，不加这个编译会更慢一些export USE_PRECOMPILED_HEADER=true#指定要编译的内容export BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=falseexport BUILD_JAXWS=falseexport BUILD_CORBA=false#要编译的版本#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueexport DEBUG_NAME=debug#可以避开javaws和浏览器Java插件之类的部分buildBUILD_DEPLOY=false#设置成false就不会build出包装包，因为包装包里有些奇怪的依赖#但是即使不build出它也已经能得到完整的JDK映像，所以还是别build它好了BUILD_INSTALL=false#编译结果存放的路径export ALT_OUTPUTDIR=/root/temp/jdk7u WARNINGS_ARE_ERRORS=#卸载环境变量，避免诡异的事情发生unset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS#make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 好了，我们将上面一系列的环境变量，创建环境文件VAR来统一管理吧vi VAR 12345678910111213141516171819202122232425262728293031323334353637383940export LANG=Cexport ALT_BOOTDIR=/usr/java/jdk1.6.0_25export ALLOW_DOWNLOADS=trueexport HOTSPOT_BUILD_JOBS=2export ALT_PATALLER_COMPILE_JOBS=2export SKIP_COMPARE_IMAGES=trueexport USE_PRECOMPILED_HEADER=trueexport BUILD_LANGTOOLS=trueexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport BUILD_JAXP=trueexport BUILD_JAXWS=trueexport BUILD_CORBA=true#export SKIP_DEBUG_BUILD=false#export SKIP_FASTDEBUG_BUILD=trueBUILD_DEPLOY=falseBUILD_INSTALL=falseexport ALT_OUTPUTDIR=/home/cloudpai/app/jdk7u #export CORBA_DIST=$ALT_OUTPUTDIR/corba/dist#export JAXP_DIST=$ALT_OUTPUTDIR/jaxp/dist#export JAXWS_DIST=$ALT_OUTPUTDIR/jaxws/distunset JAVA_HOMEunset CLASSPATHunset JAVA_OPTS 使之生效. VAR 4.2检测设置是否全部正确make sanity当看到如下输出时则表示成功 123456789101112131415161718192021Build Machine Information: build machine = workstation.centos.vbirdBuild Directory Structure: CWD = /root/temp/jdk7u-dev TOPDIR = . LANGTOOLS_TOPDIR = ./langtools JAXP_TOPDIR = ./jaxp JAXWS_TOPDIR = ./jaxws CORBA_TOPDIR = ./corba HOTSPOT_TOPDIR = ./hotspot JDK_TOPDIR = ./jdk ……Sanity check passed. 4.3真正开始编译make (命令等同于make all) 成功的标志 12345678910111213#-- Build times ----------Target all_product_buildStart 2018-03-06 21:03:26End 2018-03-06 21:20:0900:02:02 corba00:05:08 hotspot00:00:16 jaxp00:00:19 jaxws00:08:34 jdk00:00:23 langtools00:16:43 TOTAL-------------------------make[1]: Leaving directory `/home/cloudpai/Downloads/jdk7u-dev' 4.4测试自己编译出来的jdk吧正确编译后，可以执行如下命令验证 1234[cloudpai@hadoop000 bin]$ /home/cloudpai/app/jdk7u/j2sdk-image/bin/java -versionopenjdk version "1.7.0-internal"OpenJDK Runtime Environment (build 1.7.0-internal-cloudpai_2018_03_06_21_03-b00)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) OK，到些就大功告成了。 五 可能出现的错误/usr/bin/ld: cannot find -lX11 collect2: ld returned 1 exit status解决办法yum install -y libX11* /bin/sh: line 0: cd: /NOT-SET/re/jdk/1.7.0/promoted/latest/binaries/linux-amd64: No such file or directory make[4]: *** [/root/temp/jdk7u/tmp/java/components_imported] Error 1解决办法VAR文件确认执行过了，正确的姿势. VAR 参考博客：http://blog.csdn.net/hl_java/article/details/76691321 由1.6.4得我们得到了自己的虚拟机1.7.0-internal-cloudpai_2018_03_06_21_03-b00 现在我们要将JVM运行起来： 在大多数时候，如果我们并不关心JDK中HotSpot虚拟机以外的内容，只想单独编译 HotSpot虚拟机的话（例如调试虚拟机时，每次改动程序都执行整个OpenJDK的Makefile，速 度肯定受不了），那么使用hotspot/make目录下的Makefile进行替换即可，其他参数设置与前 面是一致的，这时候虚拟机的输出结果存放在build/hotspot/outputdir/bsd_amd64_compiler2目录(在不同机器上，最后一个目录名称会有所差别，bsd表示Mac OS系统（内核为 FreeBSD），amd64表示是64位JDK（32位是x86），compiler2表示是Server VM（Client VM表 示是compiler1）。) 中，进入后可以见到以下几个目录。 在路径：/home/cloudpai/app/jdk7u/hotspot/outputdir/linux_amd64_compiler2 12345678910[cloudpai@hadoop000 linux_amd64_compiler2]$ lltotal 48drwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 debugdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 fastdebugdrwxrwxr-x. 7 cloudpai cloudpai 4096 Mar 6 21:06 generateddrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 jvmgdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 optimizeddrwxrwxr-x. 3 cloudpai cloudpai 20480 Mar 6 21:11 productdrwxrwxr-x. 2 cloudpai cloudpai 4096 Mar 6 21:06 profiled-rw-rw-r--. 1 cloudpai cloudpai 1778 Mar 6 21:06 shared_dirs.lst 这些目录对应了不同的优化级别，优化级别越高，性能自然就越好，但是输出代码与源 码的差距就越大，难于调试，具体哪个目录有内容，取决于make命令后面的参数。 在编译结束之后、运行虚拟机之前，还要手工编辑目录下的env.sh文件，这个文件由编 译脚本自动产生，用于设置虚拟机的环境变量，里面已经发布了“JAVA_HOME、 CLASSPATH、HOTSPOT_BUILD_USER”3个环境变量， 还要在在product下边（看网上都是在jvmg下边，可我的jvmg下边没有gamma，不知道什么情况）的env.sh下加入： 123456export JAVA_HOME=/usr/java/jdk1.6.0_25export PATH=$JAVA_HOME/bin:$PATHLD_LIBRARY_PATH=.:$&#123;JAVA_HOME&#125;/jre/lib/amd64/native_threads:$&#123;JAVA_HOME&#125;/jre/lib/amd64:export LD_LIBRARY_PATH 然后执行以下命令启动虚拟机（这时的启动器名为gamma），输出版本号。 12source ./env.sh ./gamma -version 最后运行虚拟机成功！！ 12345[cloudpai@hadoop000 product]$ ./gamma -versionUsing java runtime at: /usr/java/jdk1.6.0_25/jrejava version &quot;1.6.0_25&quot;Java(TM) SE Runtime Environment (build 1.6.0_25-b06)OpenJDK 64-Bit Server VM (build 24.80-b07, mixed mode) 1.6.5 JVM 在IDE工具中进行源码调试注意这里是源码调试，是对1.6.4中计划编译的jdk源码进行操作: openjdk7（centos上的存储路径是/home/cloudpai/Downloads/jdk7u-dev） centos下安装NetBeans集成开发环境 官网下载地址：http://download.netbeans.org/netbeans/7.0.1/final/bundles/netbeans-7.0.1-ml-cpp-linux.sh 以netbeans-7.0.1-ml-cpp-linux.sh为例 首先，到NetBeans网站（http://netbeans.org/）上下载最新版的NetBeans（网上说7.0.1版本没问题，我就直接用这个版本了），下载时选择支持 C/C++开发的那个版本。 注意：不要在本地远程用SecureCRT输入命令啊，要在Linux下用终端输入命令： 1sh netbeans-7.0.1-ml-cpp-linux.sh 这样就会在centos中弹出安装界面： 配置好安装路径和IDE使用的java环境（注意与编译时的环境一致） 安装好以后，桌面上就有了NetBeans： 后续操作可以参考这个博客：使用Netbeans开发调试OpenJDK中的HotSpothttp://blog.csdn.net/pange1991/article/details/51580969 CentOS下安装NetBeans集成开发环境http://www.itboth.com/d/QriYZj/centos-java-windows-linux-netbeans]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java1.8 帮助文档]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05-1%2F</url>
    <content type="text"><![CDATA[java 1.6 帮助文档中文链接：http://download.csdn.net/detail/qw599186875/9608735英文Java1.8 帮助文档英文中文 – 谷歌版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-google/下载链接：http://download.csdn.net/detail/qw599186875/9802192]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站架构技能图谱（Java版）]]></title>
    <url>%2F2018%2F03%2F05%2F2018-03-05%2F</url>
    <content type="text"><![CDATA[每天都要有进步！]]></content>
      <tags>
        <tag>java</tag>
        <tag>图谱</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[workflow工作流]]></title>
    <url>%2F2018%2F03%2F04%2F2018-03-04%2F</url>
    <content type="text"><![CDATA[工作流脚本测试：测试成功~晚安~~]]></content>
      <tags>
        <tag>workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scratch编程探究]]></title>
    <url>%2F2018%2F03%2F02%2F2018-03-02%2F</url>
    <content type="text"><![CDATA[转载自：儿童使用Scratch编程时，与程序员在工作中的编程有什么区别？ - Milo Yip的回答 - 知乎https://www.zhihu.com/question/42012520/answer/310430799]]></content>
      <tags>
        <tag>scratch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018拜年祭单品]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01-1%2F</url>
    <content type="text"><![CDATA[2018拜年祭单品传送门： 1.【逆浪千秋】av20204904 2.【如果我的一生只需要做一件事 — Bilibili Zeitgeist 2017】av20203478 3.【梦想小剧场-遗失的宝物】av20203610 4.【口袋竞技场ー冰与铁之歌】av20203938 5.【相遇day by day】av20203945 6.【上海一夜】av20204014 7.【神鬼恋曲】av20204051 8.【UP主的奇妙冒险之勇者传说】av20204517 9.【我的破烂之掀起波澜】av20204332 10.【palette】av20204403 11.【广告高手】av20204701 12.【滑稽君大冒险】av20204534 13.【journey】av20204614 14.【全靠我勤劳的手】av20204705 15.【演奏区的偷心计划】av20204824 16.【乒乓帝国】av20205319 17.【鬼畜大战之真相黎明】av20205316 18.【如何翻拍一个CG短片】av20205314 19.【坦克大战】av20205375 20.【星空花火】av20203411 彩蛋【举头三尺有神明】av16201808]]></content>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blogs 上的标签tag参数]]></title>
    <url>%2F2018%2F03%2F01%2F2018-03-01%2F</url>
    <content type="text"><![CDATA[12345678910---title: Mac终端翻墙tags: Linux&amp;Unixcategories: Linux&amp;Unixcomments: trueabbrlink: 745a6d7date: 2016-11-24 18:26:33updated: 2016-11-24 18:26:33copyright: true---]]></content>
      <tags>
        <tag>mac</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要进行的改进]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[TODO： 测试git的备份功能 学习 Alfred workflow实现打开重启任意应用 脚本实现清理浏览器缓存]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac使用]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28%2F</url>
    <content type="text"><![CDATA[Mac系统如何显示隐藏文件？以”.”开头的隐藏文件如何在MAC系统下显示？ 答：Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。 显示 隐藏文件 1234567#显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool trueosascript -e 'tell application "Finder" to quit'#不显示全部文件defaults write com.apple.finder AppleShowAllFiles -bool falseosascript -e 'tell application "Finder" to quit']]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog通过git备份与恢复的最优操作]]></title>
    <url>%2F2018%2F02%2F28%2Fblog%E9%80%9A%E8%BF%87git%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E7%9A%84%E6%9C%80%E4%BC%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[引言：Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。这个时候就可以用分支的思路！一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。特别简洁。 关于搭建的流程 创建仓库，http://CrazyMilk.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库； 在本地http://CrazyMilk.github.io 仓库新建一个文件后，进入文件中。在该文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo g -d生成网站并部署到GitHub上。这样一来，在GitHub上的http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 关于日常的改动流程 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）； 在本地新拷贝的http://CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 其实只要把hexo和需要每个插件都写入到package.json中（平常安装时加–save参数会自动写入），那么git clone下来之后，只要一句npm install就能装好hexo和所有的依赖，开箱即用 ^_^ 迁移源码库一开始用了该方法，后来意识到备份到github分支的博客源码也是public的，后来改为备份到开源中国git私有库了 参考1：GitHub Pages + Hexo搭建博客参考2：使用hexo，如果换了电脑怎么更新博客？ - CrazyMilk的回答 - 知乎]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2018%2F02%2F28%2F2018-02-28-1%2F</url>
    <content type="text"><![CDATA[创建的仓库：默认master克隆的仓库：默认origin（源） git add 开始跟踪一个新文件git status显示git状态 git commit提交更新 git diff：比较工作区和缓存区的不同。git diff --cached：比较缓存区和仓库的不同。 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 git push [remote-name] [branch-name] 如果要把本地的 master 分支推送到 origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：git push origin master git log显示从最近到最远的提交日志。包含每个提交的SHA1校验和、作者的名字和邮箱、提交时间以及提交说明等。gitk使用图形化工具查阅提交历史 git commit --amend修改最后一次提交 git reset HEAD &lt;file&gt;...取消已经暂存的文件 Git 分支git branch创建一个新的分支 git commit -a -m &#39;made other changes&#39; 提交分支git mergetool调用一个可视化的合并工具并引导你解决所有冲突 git学习链接]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客样式改进杂记]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%8D%9A%E5%AE%A2%E6%A0%B7%E5%BC%8F%E6%94%B9%E8%BF%9B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[评论区样式修改：文件位置：themes/next/source/css/_common/components/comments.styl 修改内容： 1234.comments &#123; background white; opacity:0.8;&#125; 移动端不加载背景图一点优化，移动端不加载背景图。在_layout.swig底部L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});标签前，加上移动端浏览器内核判断语句，当为PC端浏览器时，加载背景js 123456789101112131415161718192021222324252627&lt;!--移动端判断，是否引入背景--&gt;&lt;script&gt;var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123;//移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase() &#125; if(browser.versions.mobile || browser.versions.ios || browser.versions.android || browser.versions.iPhone || browser.versions.iPad)&#123; &#125;else&#123; document.write("&lt;script type=\'text/javascript\' src=\'/js/src/particle.js\'&gt;&lt;\/script&gt;"); &#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🎵记录点滴生活]]></title>
    <url>%2F2018%2F02%2F24%2F%F0%9F%8E%B5%E8%AE%B0%E5%BD%95%E7%82%B9%E6%BB%B4%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[记录点滴生活《BINGBIAN病变》歌曲不错，曲调有些忧伤 [00:00.21]罗之豪 - BINGBIAN病变 [00:01.87]词：Cubi/Fi9 [00:02.76]曲：Jurrivh [00:03.72]混音：Fi9 [00:19.36][02:01.33][03:09.30]有天我睡醒看到我的身边没有你 [00:23.52][02:05.53][03:13.50]在我的右边是你曾经喜欢的玩具 [00:27.75][02:09.76][03:17.66]可当我站起身来在房间里寻找你 [00:32.04][02:14.00][03:21.93]留下的只有带着你味道的一封信 [00:36.50][02:18.48][03:26.35]就在昨天还一起看我们的照片 [00:40.47][02:22.48][03:30.46]可现在让我感觉像烂剧里的主演 [00:44.74][02:26.71][03:34.69]为什么这种事情会发生在我身边 [00:48.97][02:31.00][03:38.92]是不是老天没能看到对你的疯癫 [00:54.46]还想着 创造你的宇宙 [00:56.53]但现在 已经被我清空 [00:58.57]你让我 整个人都冰冻 [01:00.68]还怎么 再次为你心动 [01:02.88]Wake me 不是你的意愿 [01:04.97]离开我 开始新的起点 [01:07.12]可能我 还会对你贪恋 [01:09.30]谁让你 曾经让我疯癫 [01:11.18]疯癫 那也是过去的画面 [01:14.54]看往后的几天 [01:16.72]我猜你也不会出现 [01:18.78]我回想这几年 [01:20.93]就像是要命的病变 [01:23.16]你可能听不见 [01:25.16]来自我对你的挂念 [01:27.53]可能有点累 [01:28.85]觉得对不对这是第几次在为你宿醉 [01:31.98]没了我肩膀 [01:33.08]你在谁身旁买的礼物变成了灰 [01:35.99]曾经我多想 [01:37.25]把你变漂亮看着别人羡慕你的模样 [01:40.50]没关系有小熊陪着你看月亮 [01:44.40]我已经看到跟你断电的过程 [01:46.96]但我假装看不见 [01:48.76]是不是要我变得像个厉鬼 [01:50.96]才能进入你的世界 [01:52.95]为什么不说再见 [01:54.31]我猜你应该是不小心的忘记 [01:57.04]都无所谓也有点累 [01:59.09]也可以开始新的记忆 [02:35.19]我不能够停止啊 [02:37.43]这些年我对你的疯癫 [02:39.49]戴上那条围巾吧 [02:41.59]在每个寒风刺骨的冬天 [02:43.92]每次送你回家你抱着我 [02:45.63]不经意间又触碰到你的手 [02:48.10]你穿裙子眨眼睛 望着我 [02:50.52]让我每次心动的瞬间 [02:52.49]那条十字路口 [02:54.39]始终有你身上的气味 [02:57.00]车水马龙过后的路灯下的身影 [03:00.10]又会是谁 [03:00.83]他想说我真的 [03:02.01]喜欢你但是每次欲言又闭嘴 [03:05.57]那时荒唐的男孩 [03:07.64]又浑浊了几岁 var ap = new APlayer({ element: document.getElementById("aplayer1"), narrow: false, autoplay: false, showlrc: 2, music: { title: "BINGBIAN病变", author: "Cubi / Fi9江澈", url: "http://p4lmrb1gp.bkt.clouddn.com/Cubi,Aydo$,BRGang%20-%20BINGBIAN%E7%97%85%E5%8F%98.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/BINGBIAN%E7%97%85%E5%8F%98.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的blog自动发布脚本]]></title>
    <url>%2F2018%2F02%2F23%2Fmac%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[遇到的坑： -bash: ./install.sh: /bin/bash: bad interpreter: Operation not permitted出现这个问题的主要原因是：-rwxrwxrwx@ 文件的属性最后带个@，这个@代表的是更多的一些属性，具体含义不太清楚，但有它就是执行不了解决：可以用这个命令来去除这个属性：xattr -d com.apple.quarantine ./*后来进入目录发现目录下面的文件还是带有@属性，我们到根目录加一个-r就好了：xattr -d -r com.apple.quarantine ./* 我的blog自动发布脚本:blog_publish.sh 123456789#!/bin/bashsay "blogs updating"cd /Users/pailiu/Library/Mobile\ Documents/iCloud~com~coderforart~iOS~MWeb/Documents/mweb_documents_library/Bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo dsay "blogs published"rm -rf /Users/pailiu/Library/Caches/Google/Chrome/Profile\ 1/*open -a "/Applications/Google Chrome.app" 'http://cloudpai.site/'# hexo server]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客插入音频、视频]]></title>
    <url>%2F2018%2F02%2F22%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为了避免后期外链失效，可以将视频、音频图片等资源传至七牛云等cdn服务器上，从中获取外链。 常用排版：居中： 1&lt;center&gt; &lt;/center&gt; 插入图片：有尺寸要求时： 1&lt;img src="http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg" width="80%" height="80%"&gt; 无尺寸要求时快速插入（md格式）： 1![](http://p4lmrb1gp.bkt.clouddn.com/15194033640468.jpg) 插入音乐网易云音乐外链获取：见官网修改博客音乐播放器歌曲路径：/Blog/themes/hexo-theme-next-master/layout/_macro/sidebar.swig qq音乐外链获取： http://www.qqmusic.cc/插入音频播放器代码： 1&lt;audio src="http://mp3.qqmusic.cc/yq/211758246.mp3" controls="controls"&gt;&lt;/audio&gt; hexo-tag-aplayer：博客中插入自定义音乐 安装成功后，在 Markdown 文档中添加比如添加如下代码使用hexo-tag-aplayer 参数12345678title ：音乐标题author：音乐作者url：音乐文件网址picture_url：可选，音乐图片网址narrow：可选，窄款式autoplay：可选，自动播放音乐，不支持移动浏览器width:xxx：可选，前缀width:，播放器宽度（默认值：100％）lrc:xxx：可选，前缀lrc:，LRC文件url 示例: 1&#123;% aplayer &quot;Caffeine&quot; &quot;Jeff Williams&quot; &quot;caffeine.mp3&quot; &quot;picture.jpg&quot; &quot;lrc:caffeine.txt&quot; %&#125; [ti:春意红包 (Vocaloid Ver.)] [ar:乐正绫/心华/洛天依] [al:春意红包] [by:] [offset:0] [00:00.29]春意红包 (Vocaloid Ver.) - 乐正绫/心华/洛天依 [00:00.89]词：泠鸢YOUSA [00:01.05]曲：Wing翼 [00:01.18]编曲：Wing翼 [00:01.95]小麦面包饺 喜色上眉梢 [00:05.78]点柳翠 画春晓 [00:08.85] [00:10.08]找旧样铜板穿一串吉兆 [00:14.20]把春意装满红包 [00:17.86] [00:37.11]廊下的小阿妹摇头晃脑 [00:41.25]望着瓦上的碎嘴家雀 [00:44.76] [00:45.56]问它们春日的鸟儿 何时才能到 [00:49.81] [00:50.35]穿街搜巷沿路找 [00:53.26] [00:53.76]看邻家的老人摘下毡帽 [00:57.88]虽是脱去冬衣还尚早 [01:01.89]宰鸡鸭 起炉灶 揭开自家陈酿 [01:07.91]偷偷尝一瓢 [01:09.81] [01:13.01]大鬼叫 小鬼叫 邪祟吓得跌倒 [01:16.73]该用什么清扫 锣鼓鞭炮 [01:20.58] [01:21.30]小孩儿 快来瞧 别再人堆胡闹 [01:24.85] [01:25.43]只有听话乖巧 来年才能长高 [01:29.08] [01:30.21]和纸浆 采朱砂 攒一摞春联叠好 [01:34.25]剪金花 染红料 [01:36.24]再糊一个四方小包 [01:37.98] [01:38.56]对花调 抄童谣 写一串吉祥安好 [01:42.51]扶正了封面 画上春来到 [01:46.14]一片翠色葱葱明快又跳跃 [01:50.13]几瓣海棠山茶花儿相映笑 [01:54.29]再蘸浓墨潦草添只燕子闹 [01:58.48]红绳绕 来封一个大红包 [02:02.83] [02:19.34]找一张晒烫的板凳歇脚 [02:22.80] [02:23.58]看你眼下又布满操劳 [02:27.59]编织橙黄蓝绿把烦恼全部忘掉 [02:32.00] [02:32.65]抬手捧一把红枣 [02:34.70] [02:35.97]骗怕生的小妹点灯睡觉 [02:40.05]会有鬼祟在夜晚来到 [02:43.55] [02:44.13]她慌张 我偷笑 连说不怕不怕 [02:50.16]让我去赶跑 [02:52.62] [02:55.34]左搭肩 右帮腔 [02:57.19]挤兑迟来的大忙人 [02:59.59]礼物未到 人怎能到 [03:03.02] [03:03.62]表嫂吵 大舅闹 连天地喳喳叫 [03:07.03] [03:07.71]我装作听不到 盘坐把碗沿敲 [03:11.35] [03:12.37]踩高跷 抓花包 撩一挂红衣鞭炮 [03:16.52]打年糕 串辣椒 [03:18.59]抹花我的胭脂粉膏 [03:20.67]侃八卦 讲小道 等杯中茶酒减少 [03:24.79]将手上红包 塞进你棉袄 [03:28.05] [03:28.60]你送吉祥如意 幸福快来到 [03:32.57]我送百年顺遂 不怕被火烧 [03:36.57]再求来年生辰 添一分美貌 [03:40.74]拱手摇 同鞠一躬对眼笑 [03:44.55] [03:47.29]小麦面包饺 喜色上眉梢 [03:51.29]点柳翠 画春晓 [03:55.45]找旧样铜板穿一串吉兆 [03:59.58]把春意赠与明朝 [04:03.12] [04:04.16]左搭肩 右帮腔 热闹话不见少 [04:08.24]你来蒸 我来挑 塞满嘴的玉米包 [04:12.41]干柴烧 火焰高 烦心事已寥寥 [04:16.05] [04:16.66]眯眼瞧 把红包塞进你棉袄 [04:20.59]一片翠色葱葱 明快又跳跃 [04:24.66]几瓣海棠山茶 花儿相映笑 [04:28.80]封着吉祥如意 幸福快来到 [04:32.97]红绳绕 拆开春意大红包 var ap = new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 2, music: { title: "春意红包", author: "三无MarBlue,祖娅纳惜,泠鸢yousa", url: "http://p4lmrb1gp.bkt.clouddn.com/%E4%B8%89%E6%97%A0MarBlue,%E7%A5%96%E5%A8%85%E7%BA%B3%E6%83%9C,%E6%B3%A0%E9%B8%A2yousa%20-%20%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.mp3", pic: "http://p4lmrb1gp.bkt.clouddn.com/%E6%98%A5%E6%84%8F%E7%BA%A2%E5%8C%85.jpg", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 播放列表123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; "narrow": false, // Optional, narrow style "autoplay": true, // Optional, autoplay song(s), not supported by mobile browsers "mode": "random", // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation` "showlrc": 3, // Optional, show lrc, can be 1, 2, 3 "mutex": true, // Optional, pause other players when this player playing "theme": "#e6d0b2", // Optional, theme color, default: #b7daff "preload": "metadata", // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto' "listmaxheight": "513px", // Optional, max height of play list "music": [ &#123; "title": "CoCo", "author": "Jeff Williams", "url": "caffeine.mp3", "pic": "caffeine.jpeg", "lrc": "caffeine.txt" &#125;, &#123; "title": "アイロニ", "author": "鹿乃", "url": "irony.mp3", "pic": "irony.jpg" &#125; ]&#125;&#123;% endaplayerlist %&#125; 插入视频：video 标签： 123&lt;video src="http://lxqncdn.miaopai.com/stream/BvmaXK2X49guVi4ehlOjjQ__.mp4" width="100%" height="100%" controls="controls"&gt;Your browser does not support the video tag.&lt;/video&gt; embed标签： 1&lt;embed src="http://player.youku.com/player.php/Type/Folder/Fid/27690810/Ob/1/sid/XMTY1MTI3NjMyNA==/v.swf" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" allowFullScreen="true" mode="transparent" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; iframe标签： 1&lt;iframe height=498 width=510 src="http://player.youku.com/embed/XMTY1MTI3NjMyNA==" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
