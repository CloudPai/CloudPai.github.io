<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="源码,SpringSession," />





  <link rel="alternate" href="/atom.xml" title="CloudPai" type="application/atom+xml" />






<meta name="description" content="Spring Session 主要解决了分布式场景下 Session 的共享问题，本文将从 Spring Session 的源码出发，来讨论一些 Session 设计的细节。 Spring Session 数据结构解读想象一个场景，现在一到面试题呈现在你面前，让你从零开始设计一个 Session 存储方案，你会怎么回答？ 说白了就是让你设计一套数据结构存储 Session，并且我相信提出这个问题">
<meta name="keywords" content="源码,SpringSession">
<meta property="og:type" content="article">
<meta property="og:title" content="从Spring-Session源码看Session机制的实现细节">
<meta property="og:url" content="http://cloudpai.site/2018/05/24/2018-05-24-1/index.html">
<meta property="og:site_name" content="CloudPai">
<meta property="og:description" content="Spring Session 主要解决了分布式场景下 Session 的共享问题，本文将从 Spring Session 的源码出发，来讨论一些 Session 设计的细节。 Spring Session 数据结构解读想象一个场景，现在一到面试题呈现在你面前，让你从零开始设计一个 Session 存储方案，你会怎么回答？ 说白了就是让你设计一套数据结构存储 Session，并且我相信提出这个问题">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/20180524215356.png">
<meta property="og:updated_time" content="2018-05-24T13:55:21.344Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从Spring-Session源码看Session机制的实现细节">
<meta name="twitter:description" content="Spring Session 主要解决了分布式场景下 Session 的共享问题，本文将从 Spring Session 的源码出发，来讨论一些 Session 设计的细节。 Spring Session 数据结构解读想象一个场景，现在一到面试题呈现在你面前，让你从零开始设计一个 Session 存储方案，你会怎么回答？ 说白了就是让你设计一套数据结构存储 Session，并且我相信提出这个问题">
<meta name="twitter:image" content="http://p4lmrb1gp.bkt.clouddn.com/20180524215356.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'TZAS2SFOJR',
      apiKey: 'e2a9cd036eede8026382b302001ec261',
      indexName: 'cloudpai_blogs_search',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cloudpai.site/2018/05/24/2018-05-24-1/"/>





  <title>从Spring-Session源码看Session机制的实现细节 | CloudPai</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-114643720-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CloudPai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间轴
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>




 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cloudpai.site/2018/05/24/2018-05-24-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CloudPai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudPai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">从Spring-Session源码看Session机制的实现细节</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T21:39:23+08:00">
                2018-05-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-05-24T21:55:21+08:00">
                2018-05-24
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/24/2018-05-24-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/24/2018-05-24-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,606
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="/assets/js/APlayer.min.js"> </script><p>Spring Session 主要解决了分布式场景下 Session 的共享问题，本文将从 Spring Session 的源码出发，来讨论一些 Session 设计的细节。</p>
<h3 id="Spring-Session-数据结构解读"><a href="#Spring-Session-数据结构解读" class="headerlink" title="Spring Session 数据结构解读"></a><a href="#Spring-Session-数据结构解读" title="Spring Session 数据结构解读"></a>Spring Session 数据结构解读</h3><p>想象一个场景，现在一到面试题呈现在你面前，让你从零开始设计一个 Session 存储方案，你会怎么回答？</p>
<p>说白了就是让你设计一套数据结构存储 Session，并且我相信提出这个问题时，大多数读者脑海中会浮现出 redis，设计一个 map，使用 ttl 等等，但没想到的细节可能会更多。先来预览一下 Spring Session 的实际数据结构是什么样的（使用 spring-session-redis 实现），当我们访问一次集成了 Spring Session 的 web 应用时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloworld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">  session.setAttribute(<span class="string">"name"</span>,<span class="string">"xu"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello.html"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在 Redis 中看到如下的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A) &quot;spring:session:sessions:39feb101-87d4-42c7-ab53-ac6fe0d91925&quot;</span><br><span class="line">B) &quot;spring:session:expirations:1523934840000&quot;</span><br><span class="line">C) &quot;spring:session:sessions:expires:39feb101-87d4-42c7-ab53-ac6fe0d91925&quot;</span><br></pre></td></tr></table></figure>
<p>这三种键职责的分析将会贯彻全文，为了统一叙述，在此将他们进行编号，后续简称为 A 类型键，B 类型键，C 类型键。先简单分析下他们的特点</p>
<ul>
<li>他们公用的前缀是 spring:session</li>
<li>A 类型键的组成是前缀 +”sessions”+sessionId，对应的值是一个 hash 数据结构。在我的 demo 中，其值如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;lastAccessedTime&quot;: 1523933008926,/*2018/4/17 10:43:28*/</span><br><span class="line">    &quot;creationTime&quot;: 1523933008926, /*2018/4/17 10:43:28*/</span><br><span class="line">    &quot;maxInactiveInterval&quot;: 1800,</span><br><span class="line">    &quot;sessionAttr:name&quot;: &quot;xu&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 creationTime（创建时间），lastAccessedTime（最后访问时间），maxInactiveInterval（session 失效的间隔时长） 等字段是系统字段，sessionAttr:xx 可能会存在多个键值对，用户存放在 session 中的数据如数存放于此。</p>
<p>A 类型键对应的默认 TTL 是 35 分钟。</p>
<ul>
<li>B 类型键的组成是前缀 +”expirations”+ 时间戳，无需纠结这个时间戳的含义，先卖个关子。其对应的值是一个 set 数据结构，这个 set 数据结构中存储着一系列的 C 类型键。在我的 demo 中，其值如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;expires:39feb101-87d4-42c7-ab53-ac6fe0d91925&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>B 类型键对应的默认 TTL 是 30 分钟</p>
<ul>
<li>C 类型键的组成是前缀 +”sessions:expires”+sessionId，对应一个空值，它仅仅是 sessionId 在 redis 中的一个引用，具体作用继续卖关子。</li>
</ul>
<p>C 类型键对应的默认 TTL 是 30 分钟。</p>
<h3 id="kirito-session-的天使轮方案"><a href="#kirito-session-的天使轮方案" class="headerlink" title="kirito-session 的天使轮方案"></a><a href="#kirito-session-的天使轮方案" title="kirito-session 的天使轮方案"></a>kirito-session 的天使轮方案</h3><p>介绍完 Spring Session 的数据结构，我们先放到一边，来看看如果我们自己设计一个 Session 方案，拟定为 kirito-session 吧，该如何设计。</p>
<p>kirito 的心路历程是这样的：“使用 redis 存 session 数据，对，session 需要有过期机制，redis 的键可以自动过期，肯定很方便。”</p>
<p>于是 kirito 设计出了 spring-session 中的 A 类型键，复用它的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;lastAccessedTime&quot;: 1523933008926,</span><br><span class="line">    &quot;creationTime&quot;: 1523933008926, </span><br><span class="line">    &quot;maxInactiveInterval&quot;: 1800,</span><br><span class="line">    key/value...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后对 A 类型的键设置 ttl A 30 分钟，这样 30 分钟之后 session 过期，0-30 分钟期间如果用户持续操作，那就根据 sessionId 找到 A 类型的 key，刷新 lastAccessedTime 的值，并重新设置 ttl，这样就完成了「续签」的特性。</p>
<p>显然 Spring Session 没有采用如此简练的设计，为什么呢？翻看 Spring Session 的文档</p>
<blockquote>
<p>One problem with relying on Redis expiration exclusively is that Redis makes no guarantee of when the expired event will be fired if the key has not been accessed. Specifically the background task that Redis uses to clean up expired keys is a low priority task and may not trigger the key expiration. For additional details see <a href="http://redis.io/topics/notifications" target="_blank" rel="noopener">Timing of expired events</a> section in the Redis documentation.</p>
</blockquote>
<p>大致意思是说，redis 的键过期机制不 “保险”，这和 redis 的设计有关，不在此拓展开，研究这个的时候翻了不少资料，得出了如下的总结：</p>
<ol>
<li>redis 在键实际过期之后不一定会被删除，可能会继续存留，但具体存留的时间我没有做过研究，可能是 1~2 分钟，可能会更久。</li>
<li>具有过期时间的 key 有两种方式来保证过期，一是这个键在过期的时候被访问了，二是后台运行一个定时任务自己删除过期的 key。划重点：<strong>这启发我们在 key 到期后只需要访问一下 key 就可以确保 redis 删除该过期键</strong></li>
<li>如果没有指令持续关注 key，并且 redis 中存在许多与 TTL 关联的 key，则 key 真正被删除的时间将会有显著的延迟！显著的延迟！显著的延迟！</li>
</ol>
<p>天使轮计划惨遭破产，看来单纯依赖于 redis 的过期时间是不可靠的，秉持着力求严谨的态度，迎来了 A 轮改造。</p>
<h3 id="A-轮改造—引入-B-类型键确保-session-的过期机制"><a href="#A-轮改造—引入-B-类型键确保-session-的过期机制" class="headerlink" title="A 轮改造—引入 B 类型键确保 session 的过期机制"></a><a href="#A-轮改造—引入-B-类型键确保-session-的过期机制" title="A 轮改造—引入 B 类型键确保 session 的过期机制"></a>A 轮改造—引入 B 类型键确保 session 的过期机制</h3><p>redis 的官方文档启发我们，可以启用一个后台定时任务，定时去删除那些过期的键，配合上 redis 的自动过期，这样可以双重保险。第一个问题来了，我们将这些过期键存在哪儿呢？不找个合适的地方存起来，定时任务到哪儿去删除这些应该过期的键呢？总不能扫描全库吧！来解释我前面卖的第一个关子，看看 B 类型键的特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring:session:expirations:1523934840000</span><br></pre></td></tr></table></figure>
<h4 id="时间戳的含义"><a href="#时间戳的含义" class="headerlink" title="时间戳的含义"></a><a href="#时间戳的含义" title="时间戳的含义"></a>时间戳的含义</h4><p>1523934840000 这明显是个 Unix 时间戳，它的含义是存放着这一分钟内应该过期的键，所以它是一个 set 数据结构。解释下这个时间戳是怎么计算出来的 org.springframework.session.data.redis.RedisSessionExpirationPolicy#roundUpToNextMinute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">roundUpToNextMinute</span><span class="params">(<span class="keyword">long</span> timeInMs)</span> </span>&#123;</span><br><span class="line">		Calendar date = Calendar.getInstance();</span><br><span class="line">		date.setTimeInMillis(timeInMs);</span><br><span class="line">		date.add(Calendar.MINUTE, <span class="number">1</span>);</span><br><span class="line">		date.clear(Calendar.SECOND);</span><br><span class="line">		date.clear(Calendar.MILLISECOND);</span><br><span class="line">		<span class="keyword">return</span> date.getTimeInMillis();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>还记得 lastAccessedTime=1523933008926，maxInactiveInterval=1800 吧，lastAccessedTime 转换成北京时间是: <code>2018/4/17 10:43:28</code>，向上取整是<code>2018/4/17 10:44:00</code>，再次转换为 Unix 时间戳得到 1523932980000，单位是 ms，1800 是过期时间的间隔，单位是 s，二者相加 1523932980000+1800*1000=1523934840000。这样 B 类型键便作为了一个「桶」，存放着这一分钟应当过期的 session 的 key。</p>
<h4 id="后台定时任务"><a href="#后台定时任务" class="headerlink" title="后台定时任务"></a><a href="#后台定时任务" title="后台定时任务"></a>后台定时任务</h4><p>org.springframework.session.data.redis.RedisSessionExpirationPolicy#cleanupExpiredSessions</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"$&#123;spring.session.cleanup.cron.expression:0 * * * * *&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanupExpiredSessions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.expirationPolicy.cleanExpiredSessions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台提供了定时任务去 “删除” 过期的 key，来补偿 redis 到期未删除的 key。方案再描述下，方便大家理解：取得当前时间的时间戳作为 key，去 redis 中定位到 spring:session:expirations:{当前时间戳} ，这个 set 里面存放的便是所有过期的 key 了。</p>
<h4 id="续签的影响"><a href="#续签的影响" class="headerlink" title="续签的影响"></a><a href="#续签的影响" title="续签的影响"></a>续签的影响</h4><p>每次 session 的续签，需要将旧桶中的数据移除，放到新桶中。验证这一点很容易。</p>
<p>在第一分钟访问一次 <a href="http://localhost:8080/helloworld" target="_blank" rel="noopener">http://localhost:8080/helloworld</a> 端点，得到的 B 类型键为：spring:session:expirations:1523934840000；第二分钟再访问一次 <a href="http://localhost:8080/helloworld" target="_blank" rel="noopener">http://localhost:8080/helloworld</a> 端点，A 类型键的 lastAccessedTime 得到更新，并且 spring:session:expirations:1523934840000 这个桶被删除了，新增了 spring:session:expirations:1523934900000 这个桶。当众多用户活跃时，桶的增删和以及 set 中数据的增删都是很频繁的。对了，没提到的一点，对应 key 的 ttl 时间也会被更新。</p>
<p>kirito-session 方案貌似比之前严谨了，目前为止使用了 A 类型键和 B 类型键解决了 session 存储和 redis 键到期不删除的两个问题，但还是存在问题的。</p>
<h3 id="B-轮改造—优雅地解决-B-类型键的并发问题"><a href="#B-轮改造—优雅地解决-B-类型键的并发问题" class="headerlink" title="B 轮改造—优雅地解决 B 类型键的并发问题"></a><a href="#B-轮改造—优雅地解决-B-类型键的并发问题" title="B 轮改造—优雅地解决 B 类型键的并发问题"></a>B 轮改造—优雅地解决 B 类型键的并发问题</h3><p>引入 B 类型键看似解决了问题，却也引入了一个新的问题：并发问题。</p>
<p>来看看一个场景：</p>
<p>假设存在一个 sessionId=1 的会话，初始时间戳为 1420656360000</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring:session:expirations:<span class="number">1420656360000</span> -&gt; [<span class="number">1</span>]</span><br><span class="line">spring:session:session:<span class="number">1</span> -&gt; &lt;session&gt;</span><br></pre></td></tr></table></figure>
<p>接下来迎来了并发访问，（用户可能在浏览器中多次点击）：</p>
<ul>
<li>线程 1 在第 2 分钟请求，产生了续签，session:1 应当从 1420656360000 这个桶移动到 142065642000 这个桶</li>
<li>线程 2 在第 3 分钟请求，也产生了续签，session:1 本应当从 1420656360000 这个桶移动到 142065648000 这个桶</li>
<li>如果上两步按照次序执行，自然不会有问题。但第 3 分钟的请求可能已经执行完毕了，第 2 分钟才刚开始执行。</li>
</ul>
<p>像下面这样：</p>
<p>线程 2 从第一分钟的桶中移除 session:1，并移动到第三分钟的桶中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:session:expirations:1420656360000 -&gt; []</span><br><span class="line">spring:session:session:1 -&gt; &lt;session&gt;</span><br><span class="line">spring:session:expirations:1420656480000 -&gt; [1]</span><br></pre></td></tr></table></figure>
<p>线程 1 完成相同的操作，它也是基于第一分钟来做的，但会移动到第二分钟的桶中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:session:expirations:1420656360000 -&gt; []</span><br><span class="line">spring:session:session:1 -&gt; &lt;session&gt;</span><br><span class="line">spring:session:expirations:1420656420000 -&gt; [1]</span><br></pre></td></tr></table></figure>
<p>最后 redis 中键的情况变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:session:expirations:1420656360000 -&gt; []</span><br><span class="line">spring:session:session:1 -&gt; &lt;session&gt;</span><br><span class="line">spring:session:expirations:1420656480000 -&gt; [1]</span><br><span class="line">spring:session:expirations:1420656420000 -&gt; [1]</span><br></pre></td></tr></table></figure>
<p>后台定时任务会在第 32 分钟扫描到 spring:session:expirations:1420656420000 桶中存在的 session，这意味着，本应该在第 33 分钟才会过期的 key，在第 32 分钟就会被删除！</p>
<p>一种简单的方法是用户的每次 session 续期加上分布式锁，这显然不能被接受。来看看 Spring Session 是怎么巧妙地应对这个并发问题的。</p>
<p><code>org.springframework.session.data.redis.RedisSessionExpirationPolicy#cleanExpiredSessions</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredSessions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">long</span> prevMin = roundDownMinute(now);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Cleaning up sessions expiring at "</span> + <span class="keyword">new</span> Date(prevMin));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取到 B 类型键</span></span><br><span class="line">   String expirationKey = getExpirationKey(prevMin);</span><br><span class="line">   <span class="comment">// 取出当前这一分钟应当过期的 session</span></span><br><span class="line">   Set&lt;Object&gt; sessionsToExpire = <span class="keyword">this</span>.redis.boundSetOps(expirationKey).members();</span><br><span class="line">   <span class="comment">// 注意：这里删除的是 B 类型键，不是删除 session 本身！</span></span><br><span class="line">   <span class="keyword">this</span>.redis.delete(expirationKey);</span><br><span class="line">   <span class="keyword">for</span> (Object session : sessionsToExpire) &#123;</span><br><span class="line">      String sessionKey = getSessionKey((String) session);</span><br><span class="line">      <span class="comment">// 遍历一下 C 类型的键</span></span><br><span class="line">      touch(sessionKey);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * By trying to access the session we only trigger a deletion if it the TTL is</span></span><br><span class="line"><span class="comment"> * expired. This is done to handle</span></span><br><span class="line"><span class="comment"> * https://github.com/spring-projects/spring-session/issues/93</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">touch</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 并不是删除 key，而只是访问 key</span></span><br><span class="line">   <span class="keyword">this</span>.redis.hasKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面逻辑主要是拿到过期键的集合（实际上是 C 类型的 key，但这里可以理解为 sessionId，C 类型我下面会介绍），此时这个集合里面存在三种类型的 sessionId。</p>
<ol>
<li>已经被 redis 删除的过期键。万事大吉，redis 很靠谱的及时清理了过期的键。</li>
<li>已经过期，但是还没来得及被 redis 清除的 key。还记得前面 redis 文档里面提到的一个技巧吗？我们在 key 到期后只需要访问一下 key 就可以确保 redis 删除该过期键，所以 redis.hasKey(key); 该操作就是为了触发 redis 的自己删除。</li>
<li>并发问题导致的多余数据，实际上并未过期。如上所述，第 32 分钟的桶里面存在的 session:1 实际上并不应该被删除，使用 touch 的好处便是我只负责检测，删不删交给 redis 判断。session:1 在第 32 分钟被 touch 了一次，并未被删除，在第 33 分钟时应当被 redis 删除，但可能存在延时，这个时候 touch 一次，确保删除。</li>
</ol>
<p>所以，源码里面特别强调了一下：要用 touch 去触发 key 的删除，而不能直接 del key。</p>
<blockquote>
<p>参考：<a href="https://github.com/spring-projects/spring-session/issues/93" target="_blank" rel="noopener">https://github.com/spring-projects/spring-session/issues/93</a></p>
</blockquote>
<h3 id="C-轮改造—增加-C-类型键完善过期通知事件"><a href="#C-轮改造—增加-C-类型键完善过期通知事件" class="headerlink" title="C 轮改造—增加 C 类型键完善过期通知事件"></a><a href="#C-轮改造—增加-C-类型键完善过期通知事件" title="C 轮改造—增加 C 类型键完善过期通知事件"></a>C 轮改造—增加 C 类型键完善过期通知事件</h3><p>虽然引入了 B 类型键，并且在后台加了定时器去确保 session 的过期，但似乎… emmmmm… 还是不够完善。在此之前，kirito-session 的设计方案中，存储 session 实际内容的 A 类型键和用于定时器确保删除的桶 B 类型键过期时间都是 30 分钟 (key 的 TTL 是 30 分钟)，注意一个细节，spring-session 中 A 类型键的过期时间是 35 分钟，比实际的 30 分钟多了 5 分钟，这意味着即便 session 已经过期，我们还是可以在 redis 中有 5 分钟间隔来操作过期的 session。于此同时，spring-session 引入了 C 类型键来作为 session 的引用。</p>
<p>解释下之前卖的第二个关子，C 类型键的组成为前缀 +”sessions:expires”+sessionId，对应一个空值，同时也是 B 类型键桶中存放的 session 引用，ttl 为 30 分钟，具体作用便是在自身过期后触发 redis 的 <a href="http://redis.io/topics/notifications" target="_blank" rel="noopener">keyspace notifications</a> 具体如何监听 redis 的过期事件简单介绍下：<code>org.springframework.session.data.redis.config.ConfigureNotifyKeyspaceEventsAction</code> 该类配置了相关的过期监听，并使用 <code>SessionExpiredEvent</code> 事件发放 session 的过期事件。为什么引入 C 类型键？keyspace notifications 只会告诉我们哪个键过期了，不会告诉我们内容是什么。<strong>关键就在于如果 session 过期后监听器可能想要访问 session 的具体内容，然而自身都过期了，还怎么获取内容</strong>。所以，C 类型键存在的意义便是解耦 session 的存储和 session 的过期，并且使得 server 获取到过期通知后可以访问到 session 真实的值。对于用户来说，C 类型键过期后，意味着登录失效，而对于服务端而言，真正的过期其实是 A 类型键过期，这中间会有 5 分钟的误差。</p>
<h3 id="一点点想法，担忧，疑惑"><a href="#一点点想法，担忧，疑惑" class="headerlink" title="一点点想法，担忧，疑惑"></a><a href="#一点点想法，担忧，疑惑" title="一点点想法，担忧，疑惑"></a>一点点想法，担忧，疑惑</h3><p>本文大概介绍了 Spring Session 的三种 key 的原因，理清楚其中的逻辑花了不少时间，项目改造正好涉及到相关的缓存值过期这一需求，完全可以参考 Spring Session 的方案。但担忧也是有的，如果真的只是 1~2 两分钟的延迟过期（对应 A 轮改造中遇到的问题），以及 1 分钟的提前删除（对应 B 轮改造中的并发问题）其实个人感觉没必要计较。从产品体验上来说，用户应该不会在意 32 分钟自动退出和 30 分钟退出，可以说 Spring Session 是为了严谨而设计了这一套方案，但引入了定时器和很多辅助的键值对，无疑对内存消耗和 cpu 消耗都是一种浪费。如果在生产环境大量使用 Spring Session，最好权衡下本文提及的相关问题。</p>
<h3 id="spring-session框架内部剖析"><a href="#spring-session框架内部剖析" class="headerlink" title="spring-session框架内部剖析"></a>spring-session框架内部剖析</h3><p><strong>1. 框架高层抽象结构图</strong></p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/20180524215356.png" alt=""></p>
<p><strong>2.spring-session 重写 servlet request 及 redis 实现存储相关问题</strong></p>
<blockquote>
<p>spring-session 无缝替换应用服务器的 request 大概原理是：<br>1. 自定义个 Filter，实现 doFilter 方法<br>2. 继承 HttpServletRequestWrapper 、HttpServletResponseWrapper 类，重写 getSession 等相关方法 (在这些方法里调用相关的 session 存储容器操作类)。<br>3. 在 第一步的 doFilter 中，new 第二步 自定义的 request 和 response 的类。并把它们分别传递 到 过滤器链<br>4. 把该 filter 配置到 过滤器链的第一个位置上</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line">/** 这个类是spring-session的1.30源码，也是实现上面第一到第三步的关键类 **/</span><br><span class="line">public class SessionRepositoryFilter&lt;S extends ExpiringSession&gt;</span><br><span class="line">        extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">   /**  session存储容器接口，redis、mongoDB、genfire等数据库都是实现该接口  **/</span><br><span class="line">    private final SessionRepository&lt;S&gt; sessionRepository;</span><br><span class="line"></span><br><span class="line">    private ServletContext servletContext;</span><br><span class="line">   /** </span><br><span class="line">      sessionID的传递方式接口。目前spring-session自带两个实现类</span><br><span class="line">      1.cookie方式 ：CookieHttpSessionStrategy</span><br><span class="line">      2.http header 方式：HeaderHttpSessionStrategy</span><br><span class="line">      当然，我们也可以自定义其他方式。</span><br><span class="line">    **/</span><br><span class="line">    private MultiHttpSessionStrategy httpSessionStrategy = new CookieHttpSessionStrategy();</span><br><span class="line"></span><br><span class="line">    public SessionRepositoryFilter(SessionRepository&lt;S&gt; sessionRepository) &#123;</span><br><span class="line">        if (sessionRepository == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;sessionRepository cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.sessionRepository = sessionRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHttpSessionStrategy(HttpSessionStrategy httpSessionStrategy) &#123;</span><br><span class="line">        if (httpSessionStrategy == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;httpSessionStrategy cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /** </span><br><span class="line">        通过前面的spring-session功能介绍，我们知道spring-session可以支持单浏览器多</span><br><span class="line">        session， 就是通过MultiHttpSessionStrategyAdapter来实现的。</span><br><span class="line">        每个浏览器拥有一个sessionID，但是这个sessionID拥有多个别名（根据浏览器的tab）。如：</span><br><span class="line">                别名1 sessionID</span><br><span class="line">                别名2 sessionID</span><br><span class="line">                ...</span><br><span class="line">                而这个别名通过url来传递，这就是单浏览器多session原理了</span><br><span class="line">                **/</span><br><span class="line">        this.httpSessionStrategy = new MultiHttpSessionStrategyAdapter(</span><br><span class="line">                httpSessionStrategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHttpSessionStrategy(MultiHttpSessionStrategy httpSessionStrategy) &#123;</span><br><span class="line">        if (httpSessionStrategy == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;httpSessionStrategy cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.httpSessionStrategy = httpSessionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">     /**</span><br><span class="line">    该方法相当于重写了doFilter，只是spring-session又做了多一层封装。</span><br><span class="line">    在这个方法里创建自定义的 request和response，然后传递到过滤器链filterChain</span><br><span class="line">     **/</span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">            HttpServletResponse response, FilterChain filterChain)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);</span><br><span class="line">                /**</span><br><span class="line">                spring-session重写的ServletRequest。这个类继承了HttpServletRequestWrapper </span><br><span class="line">                **/</span><br><span class="line">        SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryRequestWrapper(</span><br><span class="line">                request, response, this.servletContext);</span><br><span class="line">        SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryResponseWrapper(</span><br><span class="line">                wrappedRequest, response);</span><br><span class="line"></span><br><span class="line">        HttpServletRequest strategyRequest = this.httpSessionStrategy</span><br><span class="line">                .wrapRequest(wrappedRequest, wrappedResponse);</span><br><span class="line">        HttpServletResponse strategyResponse = this.httpSessionStrategy</span><br><span class="line">                .wrapResponse(wrappedRequest, wrappedResponse);</span><br><span class="line"></span><br><span class="line">        try &#123;  </span><br><span class="line">             /** </span><br><span class="line">             传递自定义 request和response到链中,想象下如果</span><br><span class="line">             该spring-sessionFilter位于过滤器链的第一个，那么后续的Filter，</span><br><span class="line">             以及到达最后的控制层所获取的 request和response，是不是就是我们自定义的了？</span><br><span class="line">             **/</span><br><span class="line">            filterChain.doFilter(strategyRequest, strategyResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            wrappedRequest.commitSession();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setServletContext(ServletContext servletContext) &#123;</span><br><span class="line">        this.servletContext = servletContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    这个就是Servlet response的重写类了</span><br><span class="line">     */</span><br><span class="line">    private final class SessionRepositoryResponseWrapper</span><br><span class="line">            extends OnCommittedResponseWrapper &#123;</span><br><span class="line"></span><br><span class="line">        private final SessionRepositoryRequestWrapper request;</span><br><span class="line"></span><br><span class="line">        SessionRepositoryResponseWrapper(SessionRepositoryRequestWrapper request,</span><br><span class="line">                HttpServletResponse response) &#123;</span><br><span class="line">            super(response);</span><br><span class="line">            if (request == null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;request cannot be null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            this.request = request;</span><br><span class="line">        &#125;</span><br><span class="line">         /** </span><br><span class="line">            这步是持久化session到存储容器，我们可能会在一个控制层里多次调用session的操作方法</span><br><span class="line">            如果我们每次对session的操作都持久化到存储容器，必定会带来性能的影响。比如redis</span><br><span class="line">            所以我们可以在整个控制层执行完毕了，response返回信息到浏览器时，才持久化session</span><br><span class="line">         **/</span><br><span class="line">        @Override</span><br><span class="line">        protected void onResponseCommitted() &#123;</span><br><span class="line">            this.request.commitSession();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    spring-session 的request重写类，这几乎是最重要的一个重写类。里面重写了获取getSession，Session等方法以及类</span><br><span class="line">     */</span><br><span class="line">    private final class SessionRepositoryRequestWrapper</span><br><span class="line">            extends HttpServletRequestWrapper &#123;</span><br><span class="line">        private Boolean requestedSessionIdValid;</span><br><span class="line">        private boolean requestedSessionInvalidated;</span><br><span class="line">        private final HttpServletResponse response;</span><br><span class="line">        private final ServletContext servletContext;</span><br><span class="line"></span><br><span class="line">        private SessionRepositoryRequestWrapper(HttpServletRequest request,</span><br><span class="line">                HttpServletResponse response, ServletContext servletContext) &#123;</span><br><span class="line">            super(request);</span><br><span class="line">            this.response = response;</span><br><span class="line">            this.servletContext = servletContext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Uses the HttpSessionStrategy to write the session id to the response and</span><br><span class="line">         * persist the Session.</span><br><span class="line">         */</span><br><span class="line">        private void commitSession() &#123;</span><br><span class="line">            HttpSessionWrapper wrappedSession = getCurrentSession();</span><br><span class="line">            if (wrappedSession == null) &#123;</span><br><span class="line">                   // session失效，删除cookie或者header</span><br><span class="line">                if (isInvalidateClientSession()) &#123;</span><br><span class="line">                    SessionRepositoryFilter.this.httpSessionStrategy</span><br><span class="line">                            .onInvalidateSession(this, this.response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                S session = wrappedSession.getSession();</span><br><span class="line">                SessionRepositoryFilter.this.sessionRepository.save(session);</span><br><span class="line">                if (!isRequestedSessionIdValid()</span><br><span class="line">                        || !session.getId().equals(getRequestedSessionId())) &#123;</span><br><span class="line">                // 把cookie或者header写回给浏览器保存  </span><br><span class="line">                SessionRepositoryFilter.this.httpSessionStrategy.onNewSession(session,</span><br><span class="line">                            this, this.response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        private HttpSessionWrapper getCurrentSession() &#123;</span><br><span class="line">            return (HttpSessionWrapper) getAttribute(CURRENT_SESSION_ATTR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void setCurrentSession(HttpSessionWrapper currentSession) &#123;</span><br><span class="line">            if (currentSession == null) &#123;</span><br><span class="line">                removeAttribute(CURRENT_SESSION_ATTR);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                setAttribute(CURRENT_SESSION_ATTR, currentSession);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">        public String changeSessionId() &#123;</span><br><span class="line">            HttpSession session = getSession(false);</span><br><span class="line"></span><br><span class="line">            if (session == null) &#123;</span><br><span class="line">                throw new IllegalStateException(</span><br><span class="line">                        &quot;Cannot change session ID. There is no session associated with this request.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // eagerly get session attributes in case implementation lazily loads them</span><br><span class="line">            Map&lt;String, Object&gt; attrs = new HashMap&lt;String, Object&gt;();</span><br><span class="line">            Enumeration&lt;String&gt; iAttrNames = session.getAttributeNames();</span><br><span class="line">            while (iAttrNames.hasMoreElements()) &#123;</span><br><span class="line">                String attrName = iAttrNames.nextElement();</span><br><span class="line">                Object value = session.getAttribute(attrName);</span><br><span class="line"></span><br><span class="line">                attrs.put(attrName, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SessionRepositoryFilter.this.sessionRepository.delete(session.getId());</span><br><span class="line">            HttpSessionWrapper original = getCurrentSession();</span><br><span class="line">            setCurrentSession(null);</span><br><span class="line"></span><br><span class="line">            HttpSessionWrapper newSession = getSession();</span><br><span class="line">            original.setSession(newSession.getSession());</span><br><span class="line"></span><br><span class="line">            newSession.setMaxInactiveInterval(session.getMaxInactiveInterval());</span><br><span class="line">            for (Map.Entry&lt;String, Object&gt; attr : attrs.entrySet()) &#123;</span><br><span class="line">                String attrName = attr.getKey();</span><br><span class="line">                Object attrValue = attr.getValue();</span><br><span class="line">                newSession.setAttribute(attrName, attrValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return newSession.getId();</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断session是否有效</span><br><span class="line">        @Override</span><br><span class="line">        public boolean isRequestedSessionIdValid() &#123;</span><br><span class="line">            if (this.requestedSessionIdValid == null) &#123;</span><br><span class="line">                String sessionId = getRequestedSessionId();</span><br><span class="line">                S session = sessionId == null ? null : getSession(sessionId);</span><br><span class="line">                return isRequestedSessionIdValid(session);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return this.requestedSessionIdValid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private boolean isRequestedSessionIdValid(S session) &#123;</span><br><span class="line">            if (this.requestedSessionIdValid == null) &#123;</span><br><span class="line">                this.requestedSessionIdValid = session != null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.requestedSessionIdValid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private boolean isInvalidateClientSession() &#123;</span><br><span class="line">            return getCurrentSession() == null &amp;&amp; this.requestedSessionInvalidated;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private S getSession(String sessionId) &#123;</span><br><span class="line">             // 从session存储容器中根据sessionID获取session</span><br><span class="line">            S session = SessionRepositoryFilter.this.sessionRepository</span><br><span class="line">                    .getSession(sessionId);</span><br><span class="line">            if (session == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            // 设置sesison的最后访问时间，以防过期</span><br><span class="line">            session.setLastAccessedTime(System.currentTimeMillis());</span><br><span class="line">            return session;</span><br><span class="line">        &#125;</span><br><span class="line">          /**</span><br><span class="line">          这个方法是不是很熟悉，下面还有个getSession()才更加熟悉。没错，就是在这里重新获取session方法  </span><br><span class="line">          **/</span><br><span class="line">        @Override</span><br><span class="line">        public HttpSessionWrapper getSession(boolean create) &#123;</span><br><span class="line">            //快速获取session，可以理解为一级缓存、二级缓存这种关系</span><br><span class="line">            HttpSessionWrapper currentSession = getCurrentSession();</span><br><span class="line">            if (currentSession != null) &#123;</span><br><span class="line">                return currentSession;</span><br><span class="line">            &#125;</span><br><span class="line">            //从httpSessionStratge里面根据cookie或者header获取sessionID</span><br><span class="line">            String requestedSessionId = getRequestedSessionId();</span><br><span class="line">            if (requestedSessionId != null</span><br><span class="line">                    &amp;&amp; getAttribute(INVALID_SESSION_ID_ATTR) == null) &#123;                                                                                     </span><br><span class="line">                //从存储容器获取session以及设置当次初始化属性                                            </span><br><span class="line">                S session = getSession(requestedSessionId);</span><br><span class="line">                if (session != null) &#123;</span><br><span class="line">                    this.requestedSessionIdValid = true;</span><br><span class="line">                    currentSession = new HttpSessionWrapper(session, getServletContext());</span><br><span class="line">                    currentSession.setNew(false);</span><br><span class="line">                    setCurrentSession(currentSession);</span><br><span class="line">                    return currentSession;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line"></span><br><span class="line">                    if (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                        SESSION_LOGGER.debug(</span><br><span class="line">                                &quot;No session found by id: Caching result for getSession(false) for this HttpServletRequest.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setAttribute(INVALID_SESSION_ID_ATTR, &quot;true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!create) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (SESSION_LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                SESSION_LOGGER.debug(</span><br><span class="line">                        &quot;A new session was created. To help you troubleshoot where the session was created we provided a StackTrace (this is not an error). You can prevent this from appearing by disabling DEBUG logging for &quot;</span><br><span class="line">                                + SESSION_LOGGER_NAME,</span><br><span class="line">                        new RuntimeException(</span><br><span class="line">                                &quot;For debugging purposes only (not an error)&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果该浏览器或者其他http访问者是初次访问服务器，则为他创建个新的session</span><br><span class="line">            S session = SessionRepositoryFilter.this.sessionRepository.createSession();</span><br><span class="line">            session.setLastAccessedTime(System.currentTimeMillis());</span><br><span class="line">            currentSession = new HttpSessionWrapper(session, getServletContext());</span><br><span class="line">            setCurrentSession(currentSession);</span><br><span class="line">            return currentSession;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public ServletContext getServletContext() &#123;</span><br><span class="line">            if (this.servletContext != null) &#123;</span><br><span class="line">                return this.servletContext;</span><br><span class="line">            &#125;</span><br><span class="line">            // Servlet 3.0+</span><br><span class="line">            return super.getServletContext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public HttpSessionWrapper getSession() &#123;</span><br><span class="line">            return getSession(true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String getRequestedSessionId() &#123;</span><br><span class="line">            return SessionRepositoryFilter.this.httpSessionStrategy</span><br><span class="line">                    .getRequestedSessionId(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">        HttpSession的重写类</span><br><span class="line">         */</span><br><span class="line">        private final class HttpSessionWrapper extends ExpiringSessionHttpSession&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">            HttpSessionWrapper(S session, ServletContext servletContext) &#123;</span><br><span class="line">                super(session, servletContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void invalidate() &#123;</span><br><span class="line">                super.invalidate();</span><br><span class="line">                SessionRepositoryRequestWrapper.this.requestedSessionInvalidated = true;</span><br><span class="line">                setCurrentSession(null);</span><br><span class="line">                SessionRepositoryFilter.this.sessionRepository.delete(getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redis 存储容器实现。<br>主要实现存储公共基础类 -&gt;FindByIndexNameSessionRepository , 里面主要有根据 indexName 从 redis 中查找 session、根据 sessionID 对 redis 中的 session 增删改查的方法。<br>关于 redis 的 session 存储容器，实际上 spring-session 是有些缺陷的。比如无法做到 session 的过期以及销毁的实时发布事件，以及 getCurrentSession 中可能存在的一些并发问题（小问题）。但整体来说还是可用性很高的，毕竟我们自己写一套这类框架成本很高。<br>以上只是针对 redis session 的存储容器，其他存储容器可能会比 redis 更好，比如 gemfire，至少在事件发布上是完整了（根据它实现了事件猜的）</p>
<hr>
<blockquote>
<p>参考：<br>从Spring-Session源码看Session机制的实现细节 程序猿DD<br><a href="http://blog.didispace.com/spring-session-source-learning-xjf/" target="_blank" rel="noopener">http://blog.didispace.com/spring-session-source-learning-xjf/</a><br>spring-session简介、使用及实现原理 - CSDN博客<br><a href="https://blog.csdn.net/wojiaolinaaa/article/details/62424642" target="_blank" rel="noopener">https://blog.csdn.net/wojiaolinaaa/article/details/62424642</a></p>
</blockquote>

      
    </div>
    
    
    


     
    
      <div>
        
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>

      </div>
    


    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    CloudPai
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://cloudpai.site/2018/05/24/2018-05-24-1/" title="从Spring-Session源码看Session机制的实现细节">http://cloudpai.site/2018/05/24/2018-05-24-1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    




    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/源码/" rel="tag"><i class="fa fa-tag"></i> 源码</a>
          
            <a href="/tags/SpringSession/" rel="tag"><i class="fa fa-tag"></i> SpringSession</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/24/2018-05-24/" rel="next" title="objectmapper详解">
                <i class="fa fa-chevron-left"></i> objectmapper详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/24/2018-05-24-2/" rel="prev" title="springmvc restful 教程">
                springmvc restful 教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>




  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg"
                alt="CloudPai" />
            
              <p class="site-author-name" itemprop="name">CloudPai</p>
              <p class="site-description motion-element" itemprop="description">加油(๑•̀ㅂ•́)و✧加油</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">236</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=240 src="//music.163.com/outchain/player?type=0&id=2113726971&auto=0&height=430"></iframe>
</div>
<!-- 459004290 -->




            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudPai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liupai024@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/57965969/doulists/all" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-book"></i>豆瓣</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/cloudPai/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-edit"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dlut.edu.cn/" title="DUT" target="_blank">DUT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bupt.edu.cn/" title="BUPT" target="_blank">BUPT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://campus.alibaba.com/index.htm" title="Alibaba Group" target="_blank">Alibaba Group</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Session-数据结构解读"><span class="nav-text">Spring Session 数据结构解读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kirito-session-的天使轮方案"><span class="nav-text">kirito-session 的天使轮方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-轮改造—引入-B-类型键确保-session-的过期机制"><span class="nav-text">A 轮改造—引入 B 类型键确保 session 的过期机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间戳的含义"><span class="nav-text">时间戳的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后台定时任务"><span class="nav-text">后台定时任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#续签的影响"><span class="nav-text">续签的影响</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-轮改造—优雅地解决-B-类型键的并发问题"><span class="nav-text">B 轮改造—优雅地解决 B 类型键的并发问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-轮改造—增加-C-类型键完善过期通知事件"><span class="nav-text">C 轮改造—增加 C 类型键完善过期通知事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一点点想法，担忧，疑惑"><span class="nav-text">一点点想法，担忧，疑惑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-session框架内部剖析"><span class="nav-text">spring-session框架内部剖析</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CloudPai</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">915.3k</span>
  
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">  </span>
</span>
</div>







  <div class="theme-info">&#12288;主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://cloudpai.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://cloudpai.site/2018/05/24/2018-05-24-1/';
          this.page.identifier = '2018/05/24/2018-05-24-1/';
          this.page.title = '从Spring-Session源码看Session机制的实现细节';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://cloudpai.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!-- <!-- <script src="https://cdn.bootcss.com/aplayer/1.6.0/APlayer.min.js"></script>

<script src="https://api.i-meto.com/music/player.js"></script> --> -->
  
  <!--移动端判断，是否引入背景-->
  <script>
  var browser={  
      versions:function(){   
             var u = navigator.userAgent, app = navigator.appVersion;   
             return {//移动终端浏览器版本信息
                  trident: u.indexOf('Trident') > -1, //IE内核
                  presto: u.indexOf('Presto') > -1, //opera内核
                  webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                  gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                  mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                  ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                  android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                  iPhone: u.indexOf('iPhone') > -1 , //是否为iPhone或者QQHD浏览器
                  iPad: u.indexOf('iPad') > -1, //是否iPad
                  webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
              };  
           }(),  
           language:(navigator.browserLanguage || navigator.language).toLowerCase()  
  }   
    if(browser.versions.mobile || browser.versions.ios || browser.versions.android ||   
      browser.versions.iPhone || browser.versions.iPad){        
               
    }else{
    document.write("<script type=\'text/javascript\'  src=\'/js/src/particle.js\'><\/script>");
    }
  </script>

  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>
</html>
