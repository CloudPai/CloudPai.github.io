<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="java,并发," />





  <link rel="alternate" href="/atom.xml" title="CloudPai" type="application/atom+xml" />






<meta name="description" content="github上的JAVA并发编程实战笔记code listing 英文版电子书 第五章 基础构建模块Building blocks5.1 同步容器类5.1.1 同步容器类的问题包括Vector和Hashtable，二者都是早期JDK的一部分，此外还包括封装类，比如Collections.synchronizedXXX等工厂方法创建的，他们的实现的方式都是把状态封装起来，并对每一个公有方法都进行同">
<meta name="keywords" content="java,并发">
<meta property="og:type" content="article">
<meta property="og:title" content="github上的JAVA并发编程实战笔记 参考">
<meta property="og:url" content="http://cloudpai.site/2018/03/19/2018-03-20-3/index.html">
<meta property="og:site_name" content="CloudPai">
<meta property="og:description" content="github上的JAVA并发编程实战笔记code listing 英文版电子书 第五章 基础构建模块Building blocks5.1 同步容器类5.1.1 同步容器类的问题包括Vector和Hashtable，二者都是早期JDK的一部分，此外还包括封装类，比如Collections.synchronizedXXX等工厂方法创建的，他们的实现的方式都是把状态封装起来，并对每一个公有方法都进行同">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://neoremind.com/wp-content/uploads/2016/09/java-7-concurrent-executors-uml-class-diagram-example.png">
<meta property="og:image" content="http://neoremind.com/wp-content/uploads/2016/09/java-7-concurrent-collections-uml-class-diagram-example.png">
<meta property="og:image" content="http://neoremind.com/wp-content/uploads/2016/09/java-7-concurrent-future-uml-class-diagram-example.png">
<meta property="og:image" content="http://neoremind.com/wp-content/uploads/2016/09/20111209111944_933.jpg">
<meta property="og:updated_time" content="2018-03-22T14:00:52.075Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="github上的JAVA并发编程实战笔记 参考">
<meta name="twitter:description" content="github上的JAVA并发编程实战笔记code listing 英文版电子书 第五章 基础构建模块Building blocks5.1 同步容器类5.1.1 同步容器类的问题包括Vector和Hashtable，二者都是早期JDK的一部分，此外还包括封装类，比如Collections.synchronizedXXX等工厂方法创建的，他们的实现的方式都是把状态封装起来，并对每一个公有方法都进行同">
<meta name="twitter:image" content="http://neoremind.com/wp-content/uploads/2016/09/java-7-concurrent-executors-uml-class-diagram-example.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'TZAS2SFOJR',
      apiKey: 'e2a9cd036eede8026382b302001ec261',
      indexName: 'cloudpai_blogs_search',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cloudpai.site/2018/03/19/2018-03-20-3/"/>





  <title>github上的JAVA并发编程实战笔记 参考 | CloudPai</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-114643720-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CloudPai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间轴
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>




 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cloudpai.site/2018/03/19/2018-03-20-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CloudPai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudPai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">github上的JAVA并发编程实战笔记 参考</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T21:49:35+08:00">
                2018-03-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-03-22T22:00:52+08:00">
                2018-03-22
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/19/2018-03-20-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/19/2018-03-20-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  27,710
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  123
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="/assets/js/APlayer.min.js"> </script><h1 id="github上的JAVA并发编程实战笔记"><a href="#github上的JAVA并发编程实战笔记" class="headerlink" title="github上的JAVA并发编程实战笔记"></a>github上的JAVA并发编程实战笔记</h1><p><a href="http://jcip.net/listings.html" target="_blank" rel="noopener">code listing</a></p>
<p><a href="http://www.periodicooficial.oaxaca.gob.mx/files/2011/05/EXT02-2011-05-19.pdf" target="_blank" rel="noopener">英文版电子书</a></p>
<h2 id="第五章-基础构建模块Building-blocks"><a href="#第五章-基础构建模块Building-blocks" class="headerlink" title="第五章 基础构建模块Building blocks"></a>第五章 基础构建模块Building blocks</h2><h3 id="5-1-同步容器类"><a href="#5-1-同步容器类" class="headerlink" title="5.1 同步容器类"></a>5.1 同步容器类</h3><h4 id="5-1-1-同步容器类的问题"><a href="#5-1-1-同步容器类的问题" class="headerlink" title="5.1.1 同步容器类的问题"></a>5.1.1 同步容器类的问题</h4><p>包括Vector和Hashtable，二者都是早期JDK的一部分，此外还包括封装类，比如Collections.synchronizedXXX等工厂方法创建的，他们的实现的方式都是把状态封装起来，并对每一个公有方法都进行同步，每次只有一个线程可以访问容器的状态，比如只有一个线程可以add，别人无法add，必须等待这个线程退出完成。</p>
<p>Hashtable的问题是如线程 1 使用 put 进行添加元素,线程 2 不但不能使用 put 方法添加元素,并且也不能使用 get 方法来获取元素,所以竞争越激烈效率越低。</p>
<p>但是同步容器类的问题是，虽然单个方法都是安全的，但是复合操作确不是，例如</p>
<ul>
<li>迭代</li>
<li>若没有则添加</li>
</ul>
<p>等等。例如下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeVectorHelpers &#123;</span><br><span class="line">    public static Object getLast(Vector list) &#123;</span><br><span class="line">        int lastIndex = list.size() - 1;</span><br><span class="line">        return list.get(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void deleteLast(Vector list) &#123;</span><br><span class="line">        int lastIndex = list.size() - 1;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试想A线程执行getLast，B线程执行deleteLast，A看到size=10，那么get(9)，而B在A get之前remove了9，那么直接会抛出ArrayIndexOutOfBoundsException。所以客户端也是需要加锁的，而且必须在list上加锁，在方法上加不是同一把锁，如第三章所讲的，没用，所以改造的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SafeVectorHelpers &#123;</span><br><span class="line">    public static Object getLast(Vector list) &#123;</span><br><span class="line">        synchronized (list) &#123;</span><br><span class="line">            int lastIndex = list.size() - 1;</span><br><span class="line">            return list.get(lastIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void deleteLast(Vector list) &#123;</span><br><span class="line">        synchronized (list) &#123;</span><br><span class="line">            int lastIndex = list.size() - 1;</span><br><span class="line">            list.remove(lastIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样迭代的时候也可能有危险，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; vector.size(); i++) </span><br><span class="line">    dosmth(vector.get(i));</span><br></pre></td></tr></table></figure>
<p>改造后可以加锁，虽然解决了不可靠问题，但是要牺牲一些伸缩性，降低并发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(vector) &#123;</span><br><span class="line">  for (int i = 0; i &lt; vector.size(); i++) </span><br><span class="line">    dosmth(vector.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-迭代器与ConcurrentModificationException"><a href="#5-1-2-迭代器与ConcurrentModificationException" class="headerlink" title="5.1.2 迭代器与ConcurrentModificationException"></a>5.1.2 迭代器与ConcurrentModificationException</h4><p>在迭代的时候，如果有别的线程修改了容器，那么JDK会采用fail-fast策略，抛出ConcurrentModificationException。例如下面的代码在多线程环境下其实是不安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Widget&gt; widgetList</span><br><span class="line"> = Collections.synchronizedList(new ArrayList&lt;Widget&gt;());</span><br><span class="line">...</span><br><span class="line">// May throw ConcurrentModificationException</span><br><span class="line">for (Widget w : widgetList)</span><br><span class="line"> doSomething(w);</span><br></pre></td></tr></table></figure>
<p>for-each只是个语法糖罢了，实际还是用Iterator来实现，可以看看JDK的源代码在AbstractList#Itr类，很简单，有个判断checkForComodification();会抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E next() &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = cursor;</span><br><span class="line">                E next = get(i);</span><br><span class="line">                lastRet = i;</span><br><span class="line">                cursor = i + 1;</span><br><span class="line">                return next;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-异常迭代器"><a href="#5-1-3-异常迭代器" class="headerlink" title="5.1.3 异常迭代器"></a>5.1.3 异常迭代器</h4><p>有的时候比如在toString方法里面打印了list，而在多线程环境中有并发的读写的情况下，也会抛出这个异常。</p>
<h3 id="5-2-并发容器"><a href="#5-2-并发容器" class="headerlink" title="5.2 并发容器"></a>5.2 并发容器</h3><p>上面说的同步容器的代价就是严重降低并发性，存在竞争时吞吐量下降严重。</p>
<p>使用这一节说的并发容器可以极大的提高伸缩性并降低风险。</p>
<p>ConcurrentLinkedQueue、ConcurrentHashMap、ConcurrentSkipListMap…</p>
<p>ConcurrentHashMap使用一种粒度更细的加锁机制来实现更大程度的共享，叫做分段锁（Lock Striping），任务线程可以并发的读写互不阻塞，同时允许一定数量的写入线程并发。性能提升非常多，只是比单线程的HashMap损失一点点性能。</p>
<p>下面的摘自网络电子书java_concurrent.pdf。</p>
<p>HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable 的线程 都必须竞争同一把锁,那假如容器里有多把锁,每一把锁用于锁容器其中一部分数据,那么当多线 程访问容器里不同数据段的数据时,线程间就不会存在锁竞争,从而可以有效的􏰀高并发访问效率, 这就是 ConcurrentHashMap 所使用的锁分段技术,首先将数据分成一段一段的存储,然后给每一段 数据配一把锁,当一个线程占用锁访问其中一个段数据的时候,其他段的数据也能被其他线程访问。</p>
<p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock,在 ConcurrentHashMap 里扮演锁的角色,HashEntry 则用于存储键值对数据。 一个 ConcurrentHashMap 里包含一个 Segment 数组,Segment 的结构和 HashMap 类似,是一种数 组和链表结构, 一个 Segment 里包含一个 HashEntry 数组,每个 HashEntry 是一个链表结构的元 素, 每个 Segment 守护者一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时, 必须首先获得它对应的 Segment 锁。</p>
<p>get操作的高效之处在于不需要加锁,原因是它的get方法里将要使用的共享变量都定义成 volatile,如用于统计当前Segement大小的count字段和用于存储值的HashEntry的 value。定义成volatile的变量,能够在线程之间保持可见性,能够被多线程同时读,并且保证不会读到过期的值,但是只能被单线程写(有一种情况 可以被多线程写,就是写入的值不依赖于原值),在get 操作里只需要读不需要写共享变量count和value,所以可以不用加锁。之所以不会读到过期的值,是根据JMM内存模型的 happens-before原则,对volatile字段的写入操作先于读操作,即使两个线程同时修改和获取 volatile变量,get操作也能拿到最新的值,这是用volatile替换锁的经典应用场景。</p>
<p>下面的源代码摘自JDK7。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</span><br><span class="line">       transient volatile HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">       /**</span><br><span class="line">        * The total number of mutative operations in this segment.</span><br><span class="line">        * Even though this may overflows 32 bits, it provides</span><br><span class="line">        * sufficient accuracy for stability checks in CHM isEmpty()</span><br><span class="line">        * and size() methods.  Accessed only either within locks or</span><br><span class="line">        * among other volatile reads that maintain visibility.</span><br><span class="line">        */</span><br><span class="line">       transient int modCount;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">static final class HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">       final int hash;</span><br><span class="line">       final K key;</span><br><span class="line">       volatile V value;</span><br><span class="line">       volatile HashEntry&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>
<p>另外ConcurrentHashMap不会抛出ConcurrentModificationException。</p>
<p>ConcurrentHashMap还提供了一系列额外的原子操作putIfAbsent, removeIfEqual, and replaceIfEqual等等。</p>
<p>putIfAbsen解决了如下的原子性问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String,String&gt; map = new ConcurrentHashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line">if(!map.containsKey(key))&#123;</span><br><span class="line">    map.put(key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Java 8开始，HashMap，ConcurrentHashMap和LinkedHashMap在处理频繁冲突时将使用平衡树来代替链表，当同一hash桶中的元素数量超过特定的值便会由链表切换到平衡树，这会将get()方法的性能从O(n)提高到O(logn)。</p>
<p>CopyOnWriteArrayList每次修改时候都会复制一遍底层的数组，当迭代的操作远远大于修改的时候，才可以使用“写入时复制”容器。</p>
<h3 id="5-3-阻塞队列和生产者-消费者模式"><a href="#5-3-阻塞队列和生产者-消费者模式" class="headerlink" title="5.3 阻塞队列和生产者-消费者模式"></a>5.3 阻塞队列和生产者-消费者模式</h3><p>摘自<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html</a></p>
<table>
<thead>
<tr>
<th></th>
<th><em>Throws exception</em></th>
<th><em>Special value</em></th>
<th><em>Blocks</em></th>
<th><em>Times out</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Insert</strong></td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#add(E" target="_blank" rel="noopener"><code>add(e)</code></a>)不能容纳抛出异常</td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#offer(E" target="_blank" rel="noopener"><code>offer(e)</code></a>) 不能容纳返回false</td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#put(E" target="_blank" rel="noopener"><code>put(e)</code></a>)</td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#offer(E,%20long,%20java.util.concurrent.TimeUnit" target="_blank" rel="noopener"><code>offer(e, time, unit)</code></a>)</td>
</tr>
<tr>
<td><strong>Remove</strong></td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#remove(java.lang.Object" target="_blank" rel="noopener"><code>remove()</code></a>)</td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#poll(long,%20java.util.concurrent.TimeUnit" target="_blank" rel="noopener"><code>poll()</code></a>)</td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#take(" target="_blank" rel="noopener"><code>take()</code></a>)</td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#poll(long,%20java.util.concurrent.TimeUnit" target="_blank" rel="noopener"><code>poll(time, unit)</code></a>)</td>
</tr>
<tr>
<td><strong>Examine</strong></td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#element(" target="_blank" rel="noopener"><code>element()</code></a>)</td>
<td><a href="http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#peek(" target="_blank" rel="noopener"><code>peek()</code></a>)</td>
<td><em>not applicable</em></td>
<td><em>not applicable</em></td>
</tr>
</tbody>
</table>
<p>举例，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Producer implements Runnable &#123;</span><br><span class="line">   private final BlockingQueue queue;</span><br><span class="line">   Producer(BlockingQueue q) &#123; queue = q; &#125;</span><br><span class="line">   public void run() &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       while (true) &#123; queue.put(produce()); &#125;</span><br><span class="line">     &#125; catch (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   Object produce() &#123; ... &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class Consumer implements Runnable &#123;</span><br><span class="line">   private final BlockingQueue queue;</span><br><span class="line">   Consumer(BlockingQueue q) &#123; queue = q; &#125;</span><br><span class="line">   public void run() &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       while (true) &#123; consume(queue.take()); &#125;</span><br><span class="line">     &#125; catch (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void consume(Object x) &#123; ... &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> class Setup &#123;</span><br><span class="line">   void main() &#123;</span><br><span class="line">     BlockingQueue q = new SomeQueueImplementation();</span><br><span class="line">     Producer p = new Producer(q);</span><br><span class="line">     Consumer c1 = new Consumer(q);</span><br><span class="line">     Consumer c2 = new Consumer(q);</span><br><span class="line">     new Thread(p).start();</span><br><span class="line">     new Thread(c1).start();</span><br><span class="line">     new Thread(c2).start();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>J.U.C下面提供了多种支持并发的队列，包括LinkedBlockingQueue、ArrayBlockingQueue都是FIFO队列，PriorityBlockingQueue是优先队列，特殊的SynchronouseQueue。</p>
<p>同时JAVA6之后还提供了双端队列，Deque（发音“deck”）和BlockingDequeue。有些时候它可以支持密取，叫做Work Stealing，也就是从队头取元素出来。</p>
<h3 id="5-4阻塞和中断方法"><a href="#5-4阻塞和中断方法" class="headerlink" title="5.4阻塞和中断方法"></a>5.4阻塞和中断方法</h3><p>线程可能会阻塞或者暂停执行，原因有很多种：</p>
<ul>
<li>等待I/O操作结束</li>
<li>等待获取一个锁</li>
<li>等待从sleep中唤醒</li>
<li>等待另外一个线程的计算结果</li>
</ul>
<p>当线程阻塞时，它通常被挂起，并处于某种阻塞状态（包括BLOCKED，WAITING，TIMED_WAITING，详细见准备工作一节的0x00部分）。阻塞操作与执行时间很长的普通操作差别在于，被阻塞线程必须等待某个不受它控制的事件发生才可能继续执行，例如等待I/O操作完成，等待某个锁可用，或者等待外部计算结果。当某个外部事件发生时，线程被置为RUNNABLE状态，才可有肯能被线程调度器选中继续执行。</p>
<p>BlockingQueue的put和take方法会抛出InterruptedException，还有Thread.sleep等，表示这个方法是一个阻塞方法，如果这个方法被Thread.interrupt()方法调用，被中断了，那么正在执行这些阻塞当中的线程将抛出InterruptedException，否则仅仅是置了一个interruped的status状态。</p>
<p>遇到interrupted异常应该如何处理？</p>
<p>1）传递异常。</p>
<p>2）恢复中断，如下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TaskRunnable implements Runnable &#123;</span><br><span class="line">    BlockingQueue&lt;Task&gt; queue;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            processTask(queue.take());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // restore interrupted status</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void processTask(Task task) &#123;</span><br><span class="line">        // Handle the task</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    interface Task &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最不建议做的事swallow异常，啥也不做。</p>
<h3 id="5-5-同步工具类"><a href="#5-5-同步工具类" class="headerlink" title="5.5 同步工具类"></a>5.5 同步工具类</h3><h4 id="5-5-1-闭锁"><a href="#5-5-1-闭锁" class="headerlink" title="5.5.1 闭锁"></a>5.5.1 闭锁</h4><p>延迟进程的进度直到到达终止状态，相当于一扇大门，闭锁到达结束状态之前，这扇门一直关闭的，没有任何线程可以通过，到达结束状态，这扇门就会允许所有线程打开。举例：</p>
<ul>
<li>确保某个计算在其需要的所有资源都已经被初始化后才继续执行，二元闭锁。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testCountDownLatch() throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch latch = new CountDownLatch(1);</span><br><span class="line">        System.out.println(&quot;主线程开始...&quot;);</span><br><span class="line">        new Thread(new Runner(latch)).start();</span><br><span class="line">        System.out.println(&quot;等待Runner子线程完成中...&quot;);</span><br><span class="line">        latch.await();</span><br><span class="line">        latch.await(5, TimeUnit.MINUTES); // 已经countdown的再await就没用了</span><br><span class="line">        System.out.println(&quot;主线程结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Runner implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">        public Runner(CountDownLatch latch) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Runner子线程开始跑...&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">            System.out.println(&quot;Runner子线程跑完！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直到某个操作的所有参与者都就绪在继续执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">final ReentrantLock rl = new ReentrantLock();</span><br><span class="line">CountDownLatch cdl = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">        class Worker implements Runnable &#123;</span><br><span class="line">            private String name;</span><br><span class="line"></span><br><span class="line">            Worker(String name) &#123;</span><br><span class="line">                this.name = name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    cdl.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                rl.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.printf(&quot;Thread %s is performing work.%n&quot;, name);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    rl.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 做一个CDL，让A1-A5充分竞争，谁都有可能先获得锁而执行。</span><br><span class="line">        AsyncThread.run(new Worker(&quot;A1&quot;));</span><br><span class="line">        AsyncThread.run(new Worker(&quot;A2&quot;));</span><br><span class="line">        AsyncThread.run(new Worker(&quot;A3&quot;));</span><br><span class="line">        AsyncThread.run(new Worker(&quot;A4&quot;));</span><br><span class="line">        AsyncThread.run(new Worker(&quot;A5&quot;));</span><br><span class="line"></span><br><span class="line">        cdl.countDown();</span><br></pre></td></tr></table></figure>
<p>官方书籍的例子是一个启停的案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TestHarness &#123;</span><br><span class="line">    public long timeTasks(int nThreads, final Runnable task)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        final CountDownLatch startGate = new CountDownLatch(1);</span><br><span class="line">        final CountDownLatch endGate = new CountDownLatch(nThreads);</span><br><span class="line"> </span><br><span class="line">        for (int i = 0; i &lt; nThreads; i++) &#123;</span><br><span class="line">            Thread t = new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        startGate.await();</span><br><span class="line">                        try &#123;</span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            endGate.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        long start = System.nanoTime();</span><br><span class="line">        startGate.countDown();</span><br><span class="line">        endGate.await();</span><br><span class="line">        long end = System.nanoTime();</span><br><span class="line">        return end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-5-2-FutureTask"><a href="#5-5-2-FutureTask" class="headerlink" title="5.5.2 FutureTask"></a>5.5.2 FutureTask</h4><p>FutureTask通过Callable实现，同时也实现了Runnable接口，相当于一个可生成结果的Runnable，如果任务完成get立即返回结果，否则阻塞直到任务进行完成状态。</p>
<p>FutureTask的以上功能却是依靠通过一个叫AbstractQueuedSynchronizer的类来实现，至少在JDK 1.5、JDK1.6版本是这样的（从1.7开始FutureTask已经被其作者Doug Lea修改为不再依赖AbstractQueuedSynchronizer实现了，这是JDK1.7的变化之一）。</p>
<p>一定要看看FutureTask的源代码，内部使用WaitNode记录所有调用get()被阻塞的线程，run方法实际的实现简单如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">run() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">     result = callable.call()</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">     result = t;</span><br><span class="line">  &#125;</span><br><span class="line">  if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;  //原子操作设置状态。</span><br><span class="line">      outcome = result;</span><br><span class="line">      UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">      for (WaitNode q; (q = waiters) != null;) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">               Thread t = q.thread;</span><br><span class="line">               LockSupport.unpark(t);</span><br><span class="line">               WaitNode next = q.next;</span><br><span class="line">               if (next == null)</span><br><span class="line">                  break;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get()阻塞方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (s &lt;= COMPLETING)</span><br><span class="line">    s = waiters queue append this waitNode and LockSupport.parkNanos(this, nanos);</span><br><span class="line">return report(s);</span><br><span class="line"></span><br><span class="line"> private V report(int s) throws ExecutionException &#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        if (s == NORMAL)</span><br><span class="line">            return (V)x;  //正常返回</span><br><span class="line">        if (s &gt;= CANCELLED)</span><br><span class="line">            throw new CancellationException();</span><br><span class="line">        throw new ExecutionException((Throwable)x);  错误返回经过封装的异常</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>圆规正传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Preloader &#123;</span><br><span class="line">    ProductInfo loadProductInfo() throws DataLoadException &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private final FutureTask&lt;ProductInfo&gt; future =</span><br><span class="line">        new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() &#123;</span><br><span class="line">            public ProductInfo call() throws DataLoadException &#123;</span><br><span class="line">                return loadProductInfo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    private final Thread thread = new Thread(future);</span><br><span class="line"> </span><br><span class="line">    public void start() &#123; thread.start(); &#125;</span><br><span class="line"> </span><br><span class="line">    public ProductInfo get()</span><br><span class="line">            throws DataLoadException, InterruptedException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return future.get();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            Throwable cause = e.getCause();</span><br><span class="line">            if (cause instanceof DataLoadException)</span><br><span class="line">                throw (DataLoadException) cause;</span><br><span class="line">            else</span><br><span class="line">                throw LaunderThrowable.launderThrowable(cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    interface ProductInfo &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-5-3-信号量"><a href="#5-5-3-信号量" class="headerlink" title="5.5.3 信号量"></a>5.5.3 信号量</h4><p>用来控制访问某个资源的操作数量，或者同时执行某个操作的数量，还可以作为容器的边界检验。</p>
<p>Semaphore中管理着一组许可permit，初始数量通过构造函数构造，执行操作需要先获取许可，使用后释放回去，acquire可以当没有可用许可的时候可以阻塞，release用于返回一个许可给信号量。</p>
<p>下面的例子是限制同一时间某个资源的操作数量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int N = 10; // 工人数</span><br><span class="line">        Semaphore semaphore = new Semaphore(5); // 机器数目</span><br><span class="line">        for (int i = 0; i &lt; N; i++)</span><br><span class="line">            new Worker(i, semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Worker extends Thread &#123;</span><br><span class="line">        private int num;</span><br><span class="line">        private Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        public Worker(int num, Semaphore semaphore) &#123;</span><br><span class="line">            this.num = num;</span><br><span class="line">            this.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(&quot;工人&quot; + this.num + &quot;占用一个机器在生产...&quot;);</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                System.out.println(&quot;工人&quot; + this.num + &quot;释放出机器&quot;);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子是官方的，使用Semaphore作为容器的设置边界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedHashSet &lt;T&gt; &#123;</span><br><span class="line">    private final Set&lt;T&gt; set;</span><br><span class="line">    private final Semaphore sem;</span><br><span class="line"> </span><br><span class="line">    public BoundedHashSet(int bound) &#123;</span><br><span class="line">        this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;());</span><br><span class="line">        sem = new Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean add(T o) throws InterruptedException &#123;</span><br><span class="line">        sem.acquire();</span><br><span class="line">        boolean wasAdded = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            wasAdded = set.add(o);</span><br><span class="line">            return wasAdded;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!wasAdded)</span><br><span class="line">                sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        boolean wasRemoved = set.remove(o);</span><br><span class="line">        if (wasRemoved)</span><br><span class="line">            sem.release();</span><br><span class="line">        return wasRemoved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始值为1的可以看做是一个Mutex互斥体，并具备不可重入的加锁语义（这句话的理解可以理解为向synchronized可以重入，但是这个同一个线程就不行了吗？），谁拥有这个唯一的许可，谁就拥有的互斥体。</p>
<h4 id="5-5-4-栅栏Barrier"><a href="#5-5-4-栅栏Barrier" class="headerlink" title="5.5.4 栅栏Barrier"></a>5.5.4 栅栏Barrier</h4><p>闭锁是一次性的对象，一旦进入终止状态，就不能被重置。Barrier类似闭锁，它能阻塞一组线程直到某个事件发生。</p>
<p>栅栏与闭锁的区别：所有线程都必须同时到达栅栏才能继续执行，<strong>闭锁用于等待事件，而栅栏用于等待其他线程</strong>。</p>
<p>栅栏在反复迭代的算法中很有用，因为可以被重置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 可以想象三个选手脚都绑到了一起，只有三个人都说ready准备好后才可以一起撤掉脚带，开始各自的奔跑</span><br><span class="line">     * </span><br><span class="line">     * @param args</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws IOException,</span><br><span class="line">            InterruptedException &#123;</span><br><span class="line">        // 如果将参数改为4，但是下面只加入了3个选手，这永远等待下去</span><br><span class="line">        // Waits until all parties have invoked await on this barrier.</span><br><span class="line">        CyclicBarrier barrier = new CyclicBarrier(3, new TotalTask());</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(3);</span><br><span class="line">        executor.submit(new Thread(new Runner(barrier, &quot;1号选手&quot;)));</span><br><span class="line">        executor.submit(new Thread(new Runner(barrier, &quot;2号选手&quot;)));</span><br><span class="line">        executor.submit(new Thread(new Runner(barrier, &quot;3号选手&quot;)));</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Runner implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Runner(CyclicBarrier barrier, String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.barrier = barrier;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000 * (new Random()).nextInt(8));</span><br><span class="line">            System.out.println(name + &quot; 准备好了...&quot;);</span><br><span class="line">            // barrier的await方法，在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + &quot; 起跑！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 主任务：汇总任务</span><br><span class="line"> */</span><br><span class="line">class TotalTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 等到所人都准备好后，再开始</span><br><span class="line">        System.out.println(&quot;=======================================&quot;);</span><br><span class="line">        System.out.println(&quot;开始一起跑啦！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种形式的栅栏式Exchanger，它是Two-party栅栏，各方在栅栏处交换数据，当两方执行不对称的操作时，Exchanger很有用，例如当一个线程缓冲区写入数据，另外一个线程从缓冲区读数据。这些线程可以在Exchanger来回合，并将满的缓冲区和空的缓冲区交换。官方Javadoc的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class FillAndEmpty &#123;</span><br><span class="line">   Exchanger&lt;DataBuffer&gt; exchanger = new Exchanger&lt;DataBuffer&gt;();</span><br><span class="line">   DataBuffer initialEmptyBuffer = ... a made-up type</span><br><span class="line">   DataBuffer initialFullBuffer = ...</span><br><span class="line"></span><br><span class="line">   class FillingLoop implements Runnable &#123;</span><br><span class="line">     public void run() &#123;</span><br><span class="line">       DataBuffer currentBuffer = initialEmptyBuffer;</span><br><span class="line">       try &#123;</span><br><span class="line">         while (currentBuffer != null) &#123;</span><br><span class="line">           addToBuffer(currentBuffer);</span><br><span class="line">           if (currentBuffer.isFull())</span><br><span class="line">             currentBuffer = exchanger.exchange(currentBuffer);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; catch (InterruptedException ex) &#123; ... handle ... &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   class EmptyingLoop implements Runnable &#123;</span><br><span class="line">     public void run() &#123;</span><br><span class="line">       DataBuffer currentBuffer = initialFullBuffer;</span><br><span class="line">       try &#123;</span><br><span class="line">         while (currentBuffer != null) &#123;</span><br><span class="line">           takeFromBuffer(currentBuffer);</span><br><span class="line">           if (currentBuffer.isEmpty())</span><br><span class="line">             currentBuffer = exchanger.exchange(currentBuffer);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; catch (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   void start() &#123;</span><br><span class="line">     new Thread(new FillingLoop()).start();</span><br><span class="line">     new Thread(new EmptyingLoop()).start();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>另外还有一个草根的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadA implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  private final Exchanger&lt;Integer&gt; exchanger;</span><br><span class="line"></span><br><span class="line">  private final AtomicReference&lt;Integer&gt; last = new AtomicReference&lt;Integer&gt;(</span><br><span class="line">      5);</span><br><span class="line"></span><br><span class="line">  public ThreadA(Exchanger&lt;Integer&gt; exchanger) &#123;</span><br><span class="line">    this.exchanger = exchanger;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        last.set(exchanger.exchange(last.get()));</span><br><span class="line">        System.out.println(&quot; After calling exchange. Thread A has value: &quot; + last.get());</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadB implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  private Exchanger&lt;Integer&gt; exchanger;</span><br><span class="line"></span><br><span class="line">  private final AtomicReference&lt;Integer&gt; last = new AtomicReference&lt;Integer&gt;(</span><br><span class="line">      10);</span><br><span class="line"></span><br><span class="line">  public ThreadB(Exchanger&lt;Integer&gt; exchanger) &#123;</span><br><span class="line">    this.exchanger = exchanger;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        last.set(exchanger.exchange(last.get()));</span><br><span class="line">        System.out.println(&quot; After calling exchange. Thread B has value: &quot; + last.get());</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExchangerTest &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Exchanger&lt;Integer&gt; exchanger = new Exchanger&lt;Integer&gt;();</span><br><span class="line">    new Thread(new ThreadA(exchanger)).start();</span><br><span class="line">    new Thread(new ThreadB(exchanger)).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会打印如下，不断的交换5、10两个数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">After calling exchange. Thread B has value: 5 </span><br><span class="line">After calling exchange. Thread A has value: 10 </span><br><span class="line">After calling exchange. Thread B has value: 10 </span><br><span class="line">After calling exchange. Thread A has value: 5 </span><br><span class="line">After calling exchange. Thread A has value: 10 </span><br><span class="line">After calling exchange. Thread B has value: 5 </span><br><span class="line">After calling exchange. Thread B has value: 10 </span><br><span class="line">After calling exchange. Thread A has value: 5</span><br></pre></td></tr></table></figure>
<h3 id="5-6-构建高效的可伸缩的结果缓存"><a href="#5-6-构建高效的可伸缩的结果缓存" class="headerlink" title="5.6 构建高效的可伸缩的结果缓存"></a>5.6 构建高效的可伸缩的结果缓存</h3><p>线程安全的版本，但是并发太差了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Memoizer1 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private final Map&lt;A, V&gt; cache = new HashMap&lt;A, V&gt;();</span><br><span class="line">    private final Computable&lt;A, V&gt; c;</span><br><span class="line"> </span><br><span class="line">    public Memoizer1(Computable&lt;A, V&gt; c) &#123;</span><br><span class="line">        this.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized V compute(A arg) throws InterruptedException &#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">interface Computable &lt;A, V&gt; &#123;</span><br><span class="line">    V compute(A arg) throws InterruptedException;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class ExpensiveFunction</span><br><span class="line">        implements Computable&lt;String, BigInteger&gt; &#123;</span><br><span class="line">    public BigInteger compute(String arg) &#123;</span><br><span class="line">        // after deep thought...</span><br><span class="line">        return new BigInteger(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用封闭并发对象的方式，来解决，但是会存在重复计算的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Memoizer2 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;</span><br><span class="line">    private final Map&lt;A, V&gt; cache = new ConcurrentHashMap&lt;A, V&gt;();</span><br><span class="line">    private final Computable&lt;A, V&gt; c;</span><br><span class="line"> </span><br><span class="line">    public Memoizer2(Computable&lt;A, V&gt; c) &#123;</span><br><span class="line">        this.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V compute(A arg) throws InterruptedException &#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用FutureTask，会极大的降低发生重复计算的概率，但还是有，因为if代码块是非原子的的“先检查再执行”操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Memoizer2 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;</span><br><span class="line">    private final Map&lt;A, V&gt; cache = new ConcurrentHashMap&lt;A, V&gt;();</span><br><span class="line">    private final Computable&lt;A, V&gt; c;</span><br><span class="line"> </span><br><span class="line">    public Memoizer2(Computable&lt;A, V&gt; c) &#123;</span><br><span class="line">        this.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V compute(A arg) throws InterruptedException &#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后正确的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Memoizer &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;</span><br><span class="line">    private final ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache</span><br><span class="line">            = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</span><br><span class="line">    private final Computable&lt;A, V&gt; c;</span><br><span class="line"> </span><br><span class="line">    public Memoizer(Computable&lt;A, V&gt; c) &#123;</span><br><span class="line">        this.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V compute(final A arg) throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">            if (f == null) &#123;</span><br><span class="line">                Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123;</span><br><span class="line">                    public V call() throws InterruptedException &#123;</span><br><span class="line">                        return c.compute(arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval);</span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line">                if (f == null) &#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    ft.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                return f.get();</span><br><span class="line">            &#125; catch (CancellationException e) &#123;</span><br><span class="line">                cache.remove(arg, f);</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                throw LaunderThrowable.launderThrowable(e.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前五章的小节"><a href="#前五章的小节" class="headerlink" title="前五章的小节"></a>前五章的小节</h2><ul>
<li>可变状态是至关重要的，所有的并发问题都归结为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全性。</li>
<li>尽量将域声明为final类型，除非他们是可变的。</li>
<li>不可变对象一定是线程安全的。不可变对象极大的降低了并发编程的复杂度，简单安全，可以任意共享而无需使用加锁或者保护性复制等机制，例如guava。</li>
<li>封装有利于管理复杂度。</li>
<li>用锁来保护每个可变变量。</li>
<li>当保护同一个不变性条件中的所有变量时，要使用同一个锁。</li>
<li>在执行复合操作期间，要持有锁。</li>
<li>如果从多个线程中访问同一个可变变量时没有同步机制，那么程序就会出现问题。</li>
</ul>
<h1 id="第二部分-结构化并发应用程序"><a href="#第二部分-结构化并发应用程序" class="headerlink" title="第二部分 结构化并发应用程序"></a>第二部分 结构化并发应用程序</h1><h2 id="第6章-任务执行"><a href="#第6章-任务执行" class="headerlink" title="第6章 任务执行"></a>第6章 任务执行</h2><h3 id="6-1-在线程中执行任务"><a href="#6-1-在线程中执行任务" class="headerlink" title="6.1 在线程中执行任务"></a>6.1 在线程中执行任务</h3><h4 id="6-1-1-串行的执行任务"><a href="#6-1-1-串行的执行任务" class="headerlink" title="6.1.1 串行的执行任务"></a>6.1.1 串行的执行任务</h4><p>这是最经典的一个最简单的Socket server的例子，服务器的资源利用率非常低，因为单线程在等待I/O操作完成时，CPU处于空闲状态。从而阻塞了当前请求的延迟，还彻底阻止了其他等待中的请求被处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingleThreadWebServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket socket = new ServerSocket(80);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket connection = socket.accept();</span><br><span class="line">            handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void handleRequest(Socket connection) &#123;</span><br><span class="line">        // request-handling logic here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-1-2-显式地为任务创建线程"><a href="#6-1-2-显式地为任务创建线程" class="headerlink" title="6.1.2 显式地为任务创建线程"></a>6.1.2 显式地为任务创建线程</h4><p>任务处理从主线程中分离出来，主循环可以快速等待下一个连接，提高响应性。同时任务可以并行处理了，吞吐量也提高了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPerTaskWebServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket socket = new ServerSocket(80);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            final Socket connection = socket.accept();</span><br><span class="line">            Runnable task = new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            new Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void handleRequest(Socket connection) &#123;</span><br><span class="line">        // request-handling logic here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-1-3-无限制创建线程的不足"><a href="#6-1-3-无限制创建线程的不足" class="headerlink" title="6.1.3 无限制创建线程的不足"></a>6.1.3 无限制创建线程的不足</h4><ul>
<li>线程的生命周期开销非常高</li>
<li>资源消耗。大量的空闲线程占用内存，给GC带来压力，同时线程数量过多，竞争CPU资源开销太大。</li>
<li>稳定性。容易引起GC问题，甚至OOM。</li>
</ul>
<h3 id="6-2-Executor框架"><a href="#6-2-Executor框架" class="headerlink" title="6.2 Executor框架"></a>6.2 Executor框架</h3><p>任务就是一组逻辑工作单元（unit of work），而线程就是使任务异步执行的机制。J.U.C提供了Executor接口，它是代替Thread来做异步执行的入口，这个接口简单，却是非常灵活强大的异步任务执行框架提供了基础。提供了一种标准的方法将</p>
<ul>
<li>任务的提交</li>
<li>任务的执行</li>
</ul>
<p>解耦开来，并用Runnable（无返回时）或者Callable（有返回值）表示任务。</p>
<p>Executor基础生产者-消费者模式。</p>
<p>上面改造后的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TaskExecutionWebServer &#123;</span><br><span class="line">    private static final int NTHREADS = 100;</span><br><span class="line">    private static final Executor exec</span><br><span class="line">            = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket socket = new ServerSocket(80);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            final Socket connection = socket.accept();</span><br><span class="line">            Runnable task = new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void handleRequest(Socket connection) &#123;</span><br><span class="line">        // request-handling logic here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-2-执行策略"><a href="#6-2-2-执行策略" class="headerlink" title="6.2.2 执行策略"></a>6.2.2 执行策略</h4><p>这一节主要介绍做一个Executor框架需要靠那些点？</p>
<ul>
<li>在什么线程中执行任务？</li>
<li>任务按照什么顺序执行？FIFO/LIFO/优先级</li>
<li>有多少个任务可以并发执行？</li>
<li>队列中允许多少个任务等待？</li>
<li>如果系统过载了要拒绝一个任务，那么选择拒绝哪一个？如何通知客户端任务被拒绝了？</li>
<li>在执行任务过程中能不能有些别的动作before/after或者回调？</li>
</ul>
<p>各种执行策略都是一种资源管理工具，最佳的策略取决于可用的计算资源以及对服务质量的要求。</p>
<p>因此每当看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(runnable).start();</span><br></pre></td></tr></table></figure>
<p>并且希望有一种灵活的执行策略的时候，请考虑使用Executor来代替Thread。</p>
<h4 id="6-2-3-线程池"><a href="#6-2-3-线程池" class="headerlink" title="6.2.3 线程池"></a>6.2.3 线程池</h4><p>在<strong>线程池中执行任务</strong>比<strong>为每个任务分配一个线程</strong>优势明显：</p>
<ul>
<li>重用线程，减少开销。</li>
<li>延迟低，线程是等待任务到达。</li>
<li>最大化挖掘系统资源以及保证稳定性。CPU忙碌但是又不会出现线程竞争资源而耗尽内存或者失败的情况。</li>
</ul>
<p>Executors可以看做一个工厂，的提供如下几种Executor的创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newCachedThreadPool</span><br><span class="line">newFixedThreadPool</span><br><span class="line">newSingleThreadExecutor</span><br><span class="line">newScheduledThreadPool</span><br></pre></td></tr></table></figure>
<h4 id="6-2-4-Executor生命周期"><a href="#6-2-4-Executor生命周期" class="headerlink" title="6.2.4 Executor生命周期"></a>6.2.4 Executor生命周期</h4><p><a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#method_summary" target="_blank" rel="noopener">JAVA 5 API</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line"> void shutdown();</span><br><span class="line"> List&lt;Runnable&gt; shutdownNow();</span><br><span class="line"> boolean isShutdown();</span><br><span class="line"> boolean isTerminated();</span><br><span class="line"> boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line"> throws InterruptedException;</span><br></pre></td></tr></table></figure>
<p>一个优雅停止的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class LifecycleWebServer &#123;</span><br><span class="line">    private final ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"> </span><br><span class="line">    public void start() throws IOException &#123;</span><br><span class="line">        ServerSocket socket = new ServerSocket(80);</span><br><span class="line">        while (!exec.isShutdown()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Socket conn = socket.accept();</span><br><span class="line">                exec.execute(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        handleRequest(conn);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">                if (!exec.isShutdown())</span><br><span class="line">                    log(&quot;task submission rejected&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void log(String msg, Exception e) &#123;</span><br><span class="line">        Logger.getAnonymousLogger().log(Level.WARNING, msg, e);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void handleRequest(Socket connection) &#123;</span><br><span class="line">        Request req = readRequest(connection);</span><br><span class="line">        if (isShutdownRequest(req))</span><br><span class="line">            stop();</span><br><span class="line">        else</span><br><span class="line">            dispatchRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    interface Request &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private Request readRequest(Socket s) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void dispatchRequest(Request r) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private boolean isShutdownRequest(Request r) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-5-延迟任务与周期任务"><a href="#6-2-5-延迟任务与周期任务" class="headerlink" title="6.2.5 延迟任务与周期任务"></a>6.2.5 延迟任务与周期任务</h4><p>使用Timer的弊端在于如果某个任务执行时间过长，那么将破坏其他TimerTask的定时精确性。第二，TimerTask抛出异常后就会终止定时线程。</p>
<p>更加合理的做法是使用ScheduledThreadPoolExecutor，它是DelayQueue的应用场景。//TODO</p>
<h3 id="6-3-找出可利用的并行性"><a href="#6-3-找出可利用的并行性" class="headerlink" title="6.3 找出可利用的并行性"></a>6.3 找出可利用的并行性</h3><p>这里的例子是串行的渲染网页的例子，包括HTML的骨架，TEXT以及IMAGE的渲染。</p>
<h4 id="6-3-2-携带结果的任务Callable和Future"><a href="#6-3-2-携带结果的任务Callable和Future" class="headerlink" title="6.3.2 携带结果的任务Callable和Future"></a>6.3.2 携带结果的任务Callable和Future</h4><p>Executor框架支持Runnable，同时也支持Callable，它将返回一个值或者抛出一个异常。</p>
<p>在Executor框架中，已提交但是尚未开始的任务可以取消，但是对于那些已经开始执行的任务，只有他们能响应中断时，才能取消。</p>
<p>Future非常实用，他的API如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boolean	cancel(boolean mayInterruptIfRunning) Attempts to cancel execution of this task.</span><br><span class="line"></span><br><span class="line"> V	get() Waits if necessary for the computation to complete, and then retrieves its result</span><br><span class="line"> </span><br><span class="line"> V	get(long timeout, TimeUnit unit) Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.</span><br><span class="line"> </span><br><span class="line"> boolean	isCancelled()  Returns true if this task was cancelled before it completed normally.</span><br><span class="line"> </span><br><span class="line"> boolean	isDone()  Returns true if this task completed.</span><br></pre></td></tr></table></figure>
<p><strong>内部get的阻塞是靠LockSupport.park来做的，在任务完成后Executor回调finishCompletion方法会依次唤醒被阻塞的线程。</strong></p>
<p>ExecutorService的submit方法接受Runnable和Callable，返回一个Future。ThreadPoolExecutor框架留了一个口子，子类可以重写newTaskFor来决定创建什么Future的实现，默认是FutureTask类。</p>
<h4 id="6-3-3-示例：使用Future实现页面的渲染器"><a href="#6-3-3-示例：使用Future实现页面的渲染器" class="headerlink" title="6.3.3 示例：使用Future实现页面的渲染器"></a>6.3.3 示例：使用Future实现页面的渲染器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FutureRenderer &#123;</span><br><span class="line">    private final ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"> </span><br><span class="line">    void renderPage(CharSequence source) &#123;</span><br><span class="line">        final List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task =</span><br><span class="line">                new Callable&lt;List&lt;ImageData&gt;&gt;() &#123;</span><br><span class="line">                    public List&lt;ImageData&gt; call() &#123;</span><br><span class="line">                        List&lt;ImageData&gt; result = new ArrayList&lt;ImageData&gt;();</span><br><span class="line">                        for (ImageInfo imageInfo : imageInfos)</span><br><span class="line">                            result.add(imageInfo.downloadImage());</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"> </span><br><span class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);</span><br><span class="line">        renderText(source);</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;ImageData&gt; imageData = future.get();</span><br><span class="line">            for (ImageData data : imageData)</span><br><span class="line">                renderImage(data);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // Re-assert the thread&apos;s interrupted status</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            // We don&apos;t need the result, so cancel the task too</span><br><span class="line">            future.cancel(true);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            throw launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    interface ImageData &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    interface ImageInfo &#123;</span><br><span class="line">        ImageData downloadImage();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    abstract void renderText(CharSequence s);</span><br><span class="line"> </span><br><span class="line">    abstract List&lt;ImageInfo&gt; scanForImageInfo(CharSequence s);</span><br><span class="line"> </span><br><span class="line">    abstract void renderImage(ImageData i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-5-CompletionService-Executor-Meets-BlockingQueue"><a href="#6-3-5-CompletionService-Executor-Meets-BlockingQueue" class="headerlink" title="6.3.5 CompletionService: Executor Meets BlockingQueue"></a>6.3.5 CompletionService: Executor Meets BlockingQueue</h4><p>计算完成后FutureTask会调用done方法，而CompletionService集成了FutureTask，对于计算完毕的结果直接放在自己维护的BlockingQueue里面，这样上层调用者就可以一个个take或者poll出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private class QueueingFuture&lt;V&gt; extends FutureTask&lt;V&gt; &#123;</span><br><span class="line"> QueueingFuture(Callable&lt;V&gt; c) &#123; super(c); &#125;</span><br><span class="line"> QueueingFuture(Runnable t, V r) &#123; super(t, r); &#125;</span><br><span class="line"> protected void done() &#123;</span><br><span class="line"> completionQueue.add(this);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-6-示例：使用CompletionService提高渲染性能"><a href="#6-3-6-示例：使用CompletionService提高渲染性能" class="headerlink" title="6.3.6 示例：使用CompletionService提高渲染性能"></a>6.3.6 示例：使用CompletionService提高渲染性能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void renderPage(CharSequence source) &#123;</span><br><span class="line">        final List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        CompletionService&lt;ImageData&gt; completionService =</span><br><span class="line">                new ExecutorCompletionService&lt;ImageData&gt;(executor);</span><br><span class="line">        for (final ImageInfo imageInfo : info)</span><br><span class="line">            completionService.submit(new Callable&lt;ImageData&gt;() &#123;</span><br><span class="line">                public ImageData call() &#123;</span><br><span class="line">                    return imageInfo.downloadImage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"> </span><br><span class="line">        renderText(source);</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            for (int t = 0, n = info.size(); t &lt; n; t++) &#123;</span><br><span class="line">                Future&lt;ImageData&gt; f = completionService.take();</span><br><span class="line">                ImageData imageData = f.get();</span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            throw launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-7-为任务设置时限"><a href="#6-3-7-为任务设置时限" class="headerlink" title="6.3.7 为任务设置时限"></a>6.3.7 为任务设置时限</h4><p>Future的get支持timeout。</p>
<h4 id="6-3-8-批量提交任务"><a href="#6-3-8-批量提交任务" class="headerlink" title="6.3.8 批量提交任务"></a>6.3.8 批量提交任务</h4><p>使用invokeAll方法提交<code>List&lt;Callable&gt;</code>，返回一个<code>List&lt;Future&gt;</code></p>
<h2 id="第7章-取消与关闭"><a href="#第7章-取消与关闭" class="headerlink" title="第7章 取消与关闭"></a>第7章 取消与关闭</h2><p>JAVA媒体提供任务机制来安全的终止线程。但是它提供了中断（interruption），这是一种写作机制，能够使一个线程终止另外一个线程。</p>
<p>一般来说没人希望立即终止，因为必要时总要先清理再终止。</p>
<p>开发一个应用能够妥善处理失败、关闭、取消等过程非常重要也有挑战。</p>
<h3 id="7-1-任务取消"><a href="#7-1-任务取消" class="headerlink" title="7.1 任务取消"></a>7.1 任务取消</h3><p>一定不要使用Thread.stop和suspend这些机制。</p>
<p>一种协作机制就是“标记位”。例如使用volatile类型的field来保存取消状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class PrimeGenerator implements Runnable &#123;</span><br><span class="line">    private static ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"> </span><br><span class="line">    @GuardedBy(&quot;this&quot;) private final List&lt;BigInteger&gt; primes</span><br><span class="line">            = new ArrayList&lt;BigInteger&gt;();</span><br><span class="line">    private volatile boolean cancelled;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        BigInteger p = BigInteger.ONE;</span><br><span class="line">        while (!cancelled) &#123;</span><br><span class="line">            p = p.nextProbablePrime();</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        cancelled = true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized List&lt;BigInteger&gt; get() &#123;</span><br><span class="line">        return new ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static List&lt;BigInteger&gt; aSecondOfPrimes() throws InterruptedException &#123;</span><br><span class="line">        PrimeGenerator generator = new PrimeGenerator();</span><br><span class="line">        exec.execute(generator);</span><br><span class="line">        try &#123;</span><br><span class="line">            SECONDS.sleep(1);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            generator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        return generator.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-1-中断"><a href="#7-1-1-中断" class="headerlink" title="7.1.1 中断"></a>7.1.1 中断</h4><p>下面的例子会出现死锁，线程根本不会停止下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class BrokenPrimeProducer extends Thread &#123;</span><br><span class="line">    private final BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    private volatile boolean cancelled = false;</span><br><span class="line"> </span><br><span class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            while (!cancelled)</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">        &#125; catch (InterruptedException consumed) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        cancelled = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个线程都有一个boolean类型的中断状态。当调用Thread.interrupt方法时，该值被设置为true，Thread.interruptted可以恢复中断。</p>
<p>阻塞库方法，例如sleep和wait、join都会检查中断，并且发现中断则提前返回，他们会清楚中断状态，并抛出InterruptedException。</p>
<p>但是对于其他方法interrupt仅仅是传递了中断的请求消息，并不会使线程中断，需要由线程在下一个合适的时刻中断自己。</p>
<p>通常，用中断是取消的最合理的实现方式。</p>
<p>上面的例子的改进方法就是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class PrimeProducer extends Thread &#123;</span><br><span class="line">    private final BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line"> </span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            while (!Thread.currentThread().isInterrupted())</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">        &#125; catch (InterruptedException consumed) &#123;</span><br><span class="line">            /* Allow thread to exit */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-2-中断策略"><a href="#7-1-2-中断策略" class="headerlink" title="7.1.2 中断策略"></a>7.1.2 中断策略</h4><p>发生了中断，需要尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以采取进一步的操作。当然任务也可以不需要放弃所有操作，可以推迟处理中断清楚，知道某个时机。</p>
<h4 id="7-1-3-响应中断"><a href="#7-1-3-响应中断" class="headerlink" title="7.1.3 响应中断"></a>7.1.3 响应中断</h4><ul>
<li>传递异常</li>
<li>回复中断状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class NoncancelableTask &#123;</span><br><span class="line">    public Task getNextTask(BlockingQueue&lt;Task&gt; queue) &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    return queue.take();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    interrupted = true;</span><br><span class="line">                    // fall through and retry</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (interrupted)</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    interface Task &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-1-6-处理不可中断的阻塞"><a href="#7-1-6-处理不可中断的阻塞" class="headerlink" title="7.1.6 处理不可中断的阻塞"></a>7.1.6 处理不可中断的阻塞</h4><p>例如Socket I/O或者内置锁都不能响应中断，这时候该如何做才能终止他们呢？可以通过重写Thread.interrupt方法，例如加入close的逻辑。</p>
<h3 id="7-2-停止基于线程的服务"><a href="#7-2-停止基于线程的服务" class="headerlink" title="7.2 停止基于线程的服务"></a>7.2 停止基于线程的服务</h3><h4 id="7-2-1-示例：日志服务"><a href="#7-2-1-示例：日志服务" class="headerlink" title="7.2.1 示例：日志服务"></a>7.2.1 示例：日志服务</h4><h4 id="7-2-2-关闭ExecutorService"><a href="#7-2-2-关闭ExecutorService" class="headerlink" title="7.2.2 关闭ExecutorService"></a>7.2.2 关闭ExecutorService</h4><h4 id="7-2-3-Poison-Pill"><a href="#7-2-3-Poison-Pill" class="headerlink" title="7.2.3 Poison Pill"></a>7.2.3 Poison Pill</h4><p>例如CloseEvent机制或者POISON对象，来做特殊的识别，从而让程序自己处理停止操作，退出线程。</p>
<h3 id="7-3-处理非正常的线程终止"><a href="#7-3-处理非正常的线程终止" class="headerlink" title="7.3 处理非正常的线程终止"></a>7.3 处理非正常的线程终止</h3><h3 id="7-4-JVM关闭"><a href="#7-4-JVM关闭" class="headerlink" title="7.4 JVM关闭"></a>7.4 JVM关闭</h3><h2 id="第8章-线程池的使用"><a href="#第8章-线程池的使用" class="headerlink" title="第8章 线程池的使用"></a>第8章 线程池的使用</h2><p>一个很好的<a href="https://my.oschina.net/xionghui/blog/494698" target="_blank" rel="noopener">ThreadPoolExecutor源码分析文档</a></p>
<p>ThreadPoolExecutor UML图：</p>
<p><img src="http://neoremind.com/wp-content/uploads/2016/09/java-7-concurrent-executors-uml-class-diagram-example.png" alt=""></p>
<p><img src="http://neoremind.com/wp-content/uploads/2016/09/java-7-concurrent-collections-uml-class-diagram-example.png" alt=""></p>
<p><img src="http://neoremind.com/wp-content/uploads/2016/09/java-7-concurrent-future-uml-class-diagram-example.png" alt=""></p>
<h3 id="8-1-在任务和执行策略之间隐形耦合"><a href="#8-1-在任务和执行策略之间隐形耦合" class="headerlink" title="8.1 在任务和执行策略之间隐形耦合"></a>8.1 在任务和执行策略之间隐形耦合</h3><p>避免Thread starvation deadlock</p>
<h3 id="8-2-设置线程池大小"><a href="#8-2-设置线程池大小" class="headerlink" title="8.2 设置线程池大小"></a>8.2 设置线程池大小</h3><h3 id="8-3-配置ThreadPoolExecutor"><a href="#8-3-配置ThreadPoolExecutor" class="headerlink" title="8.3 配置ThreadPoolExecutor"></a>8.3 配置ThreadPoolExecutor</h3><p><img src="http://neoremind.com/wp-content/uploads/2016/09/20111209111944_933.jpg" alt=""></p>
<p>构造函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line"> int maximumPoolSize,</span><br><span class="line"> long keepAliveTime,</span><br><span class="line"> TimeUnit unit,</span><br><span class="line"> BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line"> ThreadFactory threadFactory,</span><br><span class="line"> RejectedExecutionHandler handler) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心和最大池大小：如果运行的线程少于 corePoolSize，则创建新线程来处理请求（即一个Runnable实例），即使其它线程是空闲的。如果运行的线程多于 corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程。</li>
<li>保持活动时间：如果池中当前有多于 corePoolSize 的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止。</li>
<li>排队：如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列BlockingQueue，而不添加新的线程。</li>
<li>被拒绝的任务：当 Executor 已经关闭，或者队列已满且线程数量达到maximumPoolSize时（即线程池饱和了），请求将被拒绝。这些拒绝的策略叫做Saturation Policy，即饱和策略。包括AbortPolicy,<br>CallerRunsPolicy, DiscardPolicy, and DiscardOldestPolicy.</li>
</ul>
<p>另外注意：</p>
<ul>
<li>如果运行的线程少于 corePoolSize，ThreadPoolExecutor 会始终首选创建新的线程来处理请求；注意，这时即使有空闲线程也不会重复使用（这和数据库连接池有很大差别）。</li>
<li>如果运行的线程等于或多于 corePoolSize，则 ThreadPoolExecutor 会将请求加入队列BlockingQueue，而不添加新的线程（这和数据库连接池也不一样）。</li>
<li>如果无法将请求加入队列（比如队列已满），则创建新的线程来处理请求；但是如果创建的线程数超出 maximumPoolSize，在这种情况下，请求将被拒绝。</li>
</ul>
<p>newCachedThreadPool使用了SynchronousQueue，并且是无界的。</p>
<p>线程工厂ThreadFactory</p>
<h3 id="8-4-扩展ThreadPoolExecutor"><a href="#8-4-扩展ThreadPoolExecutor" class="headerlink" title="8.4 扩展ThreadPoolExecutor"></a>8.4 扩展ThreadPoolExecutor</h3><p>重写beforeExecute和afterExecute方法。</p>
<h3 id="8-5-递归算法的并行化"><a href="#8-5-递归算法的并行化" class="headerlink" title="8.5 递归算法的并行化"></a>8.5 递归算法的并行化</h3><p>实际就是类似Number of Islands或者N-Queens等DFS问题的一种并行处理。</p>
<p>串行版本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SequentialPuzzleSolver &lt;P, M&gt; &#123;</span><br><span class="line">    private final Puzzle&lt;P, M&gt; puzzle;</span><br><span class="line">    private final Set&lt;P&gt; seen = new HashSet&lt;P&gt;();</span><br><span class="line"> </span><br><span class="line">    public SequentialPuzzleSolver(Puzzle&lt;P, M&gt; puzzle) &#123;</span><br><span class="line">        this.puzzle = puzzle;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public List&lt;M&gt; solve() &#123;</span><br><span class="line">        P pos = puzzle.initialPosition();</span><br><span class="line">        return search(new PuzzleNode&lt;P, M&gt;(pos, null, null));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private List&lt;M&gt; search(PuzzleNode&lt;P, M&gt; node) &#123;</span><br><span class="line">        if (!seen.contains(node.pos)) &#123;</span><br><span class="line">            seen.add(node.pos);</span><br><span class="line">            if (puzzle.isGoal(node.pos))</span><br><span class="line">                return node.asMoveList();</span><br><span class="line">            for (M move : puzzle.legalMoves(node.pos)) &#123;</span><br><span class="line">                P pos = puzzle.move(node.pos, move);</span><br><span class="line">                PuzzleNode&lt;P, M&gt; child = new PuzzleNode&lt;P, M&gt;(pos, move, node);</span><br><span class="line">                List&lt;M&gt; result = search(child);</span><br><span class="line">                if (result != null)</span><br><span class="line">                    return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并行版本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentPuzzleSolver &lt;P, M&gt; &#123;</span><br><span class="line">    private final Puzzle&lt;P, M&gt; puzzle;</span><br><span class="line">    private final ExecutorService exec;</span><br><span class="line">    private final ConcurrentMap&lt;P, Boolean&gt; seen;</span><br><span class="line">    protected final ValueLatch&lt;PuzzleNode&lt;P, M&gt;&gt; solution = new ValueLatch&lt;PuzzleNode&lt;P, M&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">    public ConcurrentPuzzleSolver(Puzzle&lt;P, M&gt; puzzle) &#123;</span><br><span class="line">        this.puzzle = puzzle;</span><br><span class="line">        this.exec = initThreadPool();</span><br><span class="line">        this.seen = new ConcurrentHashMap&lt;P, Boolean&gt;();</span><br><span class="line">        if (exec instanceof ThreadPoolExecutor) &#123;</span><br><span class="line">            ThreadPoolExecutor tpe = (ThreadPoolExecutor) exec;</span><br><span class="line">            tpe.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private ExecutorService initThreadPool() &#123;</span><br><span class="line">        return Executors.newCachedThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public List&lt;M&gt; solve() throws InterruptedException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            P p = puzzle.initialPosition();</span><br><span class="line">            exec.execute(newTask(p, null, null));</span><br><span class="line">            // block until solution found</span><br><span class="line">            PuzzleNode&lt;P, M&gt; solnPuzzleNode = solution.getValue();</span><br><span class="line">            return (solnPuzzleNode == null) ? null : solnPuzzleNode.asMoveList();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            exec.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected Runnable newTask(P p, M m, PuzzleNode&lt;P, M&gt; n) &#123;</span><br><span class="line">        return new SolverTask(p, m, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected class SolverTask extends PuzzleNode&lt;P, M&gt; implements Runnable &#123;</span><br><span class="line">        SolverTask(P pos, M move, PuzzleNode&lt;P, M&gt; prev) &#123;</span><br><span class="line">            super(pos, move, prev);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (solution.isSet()</span><br><span class="line">                    || seen.putIfAbsent(pos, true) != null)</span><br><span class="line">                return; // already solved or seen this position</span><br><span class="line">            if (puzzle.isGoal(pos))</span><br><span class="line">                solution.setValue(this);</span><br><span class="line">            else</span><br><span class="line">                for (M m : puzzle.legalMoves(pos))</span><br><span class="line">                    exec.execute(newTask(puzzle.move(pos, m), m, this));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第9章-图形用户界面应用程序"><a href="#第9章-图形用户界面应用程序" class="headerlink" title="第9章 图形用户界面应用程序"></a>第9章 图形用户界面应用程序</h2><p>略</p>
<h1 id="第三部分-Liveness-Performance-and-Testing"><a href="#第三部分-Liveness-Performance-and-Testing" class="headerlink" title="第三部分 Liveness, Performance, and Testing"></a>第三部分 Liveness, Performance, and Testing</h1><h2 id="第10章-避免活跃性危险"><a href="#第10章-避免活跃性危险" class="headerlink" title="第10章 避免活跃性危险"></a>第10章 避免活跃性危险</h2><h3 id="10-1-死锁"><a href="#10-1-死锁" class="headerlink" title="10.1 死锁"></a>10.1 死锁</h3><p>哲学家问题</p>
<p>有环</p>
<p>A等B，B等A</p>
<p>数据库往往可以检测和解决死锁//TODO</p>
<p>JVM不行，一旦死锁只有停止重启。</p>
<p>下面分别介绍了几种典型的死锁情况：</p>
<h4 id="10-1-1-Lock-ordering-Deadlocks"><a href="#10-1-1-Lock-ordering-Deadlocks" class="headerlink" title="10.1.1 Lock ordering Deadlocks"></a>10.1.1 Lock ordering Deadlocks</h4><p>下面是一个经典的锁顺序死锁：两个线程用不同的顺序来获得相同的锁，<strong>如果按照锁的请求顺序来请求锁，就不会发生这种循环依赖的情况。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LeftRightDeadlock &#123;</span><br><span class="line">    private final Object left = new Object();</span><br><span class="line">    private final Object right = new Object();</span><br><span class="line"> </span><br><span class="line">    public void leftRight() &#123;</span><br><span class="line">        synchronized (left) &#123;</span><br><span class="line">            synchronized (right) &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void rightLeft() &#123;</span><br><span class="line">        synchronized (right) &#123;</span><br><span class="line">            synchronized (left) &#123;</span><br><span class="line">                doSomethingElse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void doSomethingElse() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-1-Dynamic-Lock-Order-Deadlocks"><a href="#10-1-1-Dynamic-Lock-Order-Deadlocks" class="headerlink" title="10.1.1 Dynamic Lock Order Deadlocks"></a>10.1.1 Dynamic Lock Order Deadlocks</h4><p>下面的转账例子，如果一个线程X向Y转，而另外一个线程Y向X也转，那么就会发生死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicOrderDeadlock &#123;</span><br><span class="line">    // Warning: deadlock-prone!</span><br><span class="line">    public static void transferMoney(Account fromAccount,</span><br><span class="line">                                     Account toAccount,</span><br><span class="line">                                     DollarAmount amount)</span><br><span class="line">            throws InsufficientFundsException &#123;</span><br><span class="line">        synchronized (fromAccount) &#123;</span><br><span class="line">            synchronized (toAccount) &#123;</span><br><span class="line">                if (fromAccount.getBalance().compareTo(amount) &lt; 0)</span><br><span class="line">                    throw new InsufficientFundsException();</span><br><span class="line">                else &#123;</span><br><span class="line">                    fromAccount.debit(amount);</span><br><span class="line">                    toAccount.credit(amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class DollarAmount implements Comparable&lt;DollarAmount&gt; &#123;</span><br><span class="line">        // Needs implementation</span><br><span class="line"> </span><br><span class="line">        public DollarAmount(int amount) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public DollarAmount add(DollarAmount d) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public DollarAmount subtract(DollarAmount d) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public int compareTo(DollarAmount dollarAmount) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class Account &#123;</span><br><span class="line">        private DollarAmount balance;</span><br><span class="line">        private final int acctNo;</span><br><span class="line">        private static final AtomicInteger sequence = new AtomicInteger();</span><br><span class="line"> </span><br><span class="line">        public Account() &#123;</span><br><span class="line">            acctNo = sequence.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        void debit(DollarAmount d) &#123;</span><br><span class="line">            balance = balance.subtract(d);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        void credit(DollarAmount d) &#123;</span><br><span class="line">            balance = balance.add(d);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        DollarAmount getBalance() &#123;</span><br><span class="line">            return balance;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        int getAcctNo() &#123;</span><br><span class="line">            return acctNo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class InsufficientFundsException extends Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法还是顺序话锁，考虑针对两种情况取hashcode然后判断if-else里面决定锁顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Helper &#123;</span><br><span class="line">            public void transfer() throws InsufficientFundsException &#123;</span><br><span class="line">                if (fromAcct.getBalance().compareTo(amount) &lt; 0)</span><br><span class="line">                    throw new InsufficientFundsException();</span><br><span class="line">                else &#123;</span><br><span class="line">                    fromAcct.debit(amount);</span><br><span class="line">                    toAcct.credit(amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int fromHash = System.identityHashCode(fromAcct);</span><br><span class="line">        int toHash = System.identityHashCode(toAcct);</span><br><span class="line"> </span><br><span class="line">        if (fromHash &lt; toHash) &#123;</span><br><span class="line">            synchronized (fromAcct) &#123;</span><br><span class="line">                synchronized (toAcct) &#123;</span><br><span class="line">                    new Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (fromHash &gt; toHash) &#123;</span><br><span class="line">            synchronized (toAcct) &#123;</span><br><span class="line">                synchronized (fromAcct) &#123;</span><br><span class="line">                    new Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized (tieLock) &#123;</span><br><span class="line">                synchronized (fromAcct) &#123;</span><br><span class="line">                    synchronized (toAcct) &#123;</span><br><span class="line">                        new Helper().transfer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-3-在协作对象之间发生死锁Deadlocks-Between-Cooperating-Objects"><a href="#10-1-3-在协作对象之间发生死锁Deadlocks-Between-Cooperating-Objects" class="headerlink" title="10.1.3 在协作对象之间发生死锁Deadlocks Between Cooperating Objects"></a>10.1.3 在协作对象之间发生死锁Deadlocks Between Cooperating Objects</h4><p>下面的例子setLocation和getImage都会获取两把锁，会存在两个线程按照不同的顺序获取锁的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class CooperatingDeadlock &#123;</span><br><span class="line">    // Warning: deadlock-prone!</span><br><span class="line">    class Taxi &#123;</span><br><span class="line">        @GuardedBy(&quot;this&quot;) private Point location, destination;</span><br><span class="line">        private final Dispatcher dispatcher;</span><br><span class="line"> </span><br><span class="line">        public Taxi(Dispatcher dispatcher) &#123;</span><br><span class="line">            this.dispatcher = dispatcher;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized Point getLocation() &#123;</span><br><span class="line">            return location;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized void setLocation(Point location) &#123;</span><br><span class="line">            this.location = location;</span><br><span class="line">            if (location.equals(destination))</span><br><span class="line">                dispatcher.notifyAvailable(this);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized Point getDestination() &#123;</span><br><span class="line">            return destination;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized void setDestination(Point destination) &#123;</span><br><span class="line">            this.destination = destination;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Dispatcher &#123;</span><br><span class="line">        @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; taxis;</span><br><span class="line">        @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line"> </span><br><span class="line">        public Dispatcher() &#123;</span><br><span class="line">            taxis = new HashSet&lt;Taxi&gt;();</span><br><span class="line">            availableTaxis = new HashSet&lt;Taxi&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized void notifyAvailable(Taxi taxi) &#123;</span><br><span class="line">            availableTaxis.add(taxi);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized Image getImage() &#123;</span><br><span class="line">            Image image = new Image();</span><br><span class="line">            for (Taxi t : taxis)</span><br><span class="line">                image.drawMarker(t.getLocation());</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Image &#123;</span><br><span class="line">        public void drawMarker(Point p) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-4-开放调用"><a href="#10-1-4-开放调用" class="headerlink" title="10.1.4 开放调用"></a>10.1.4 开放调用</h4><p>减小锁的力度，锁不嵌套。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class CooperatingNoDeadlock &#123;</span><br><span class="line">    @ThreadSafe</span><br><span class="line">    class Taxi &#123;</span><br><span class="line">        @GuardedBy(&quot;this&quot;) private Point location, destination;</span><br><span class="line">        private final Dispatcher dispatcher;</span><br><span class="line"> </span><br><span class="line">        public Taxi(Dispatcher dispatcher) &#123;</span><br><span class="line">            this.dispatcher = dispatcher;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized Point getLocation() &#123;</span><br><span class="line">            return location;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized void setLocation(Point location) &#123;</span><br><span class="line">            boolean reachedDestination;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                this.location = location;</span><br><span class="line">                reachedDestination = location.equals(destination);</span><br><span class="line">            &#125;</span><br><span class="line">            if (reachedDestination)</span><br><span class="line">                dispatcher.notifyAvailable(this);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized Point getDestination() &#123;</span><br><span class="line">            return destination;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized void setDestination(Point destination) &#123;</span><br><span class="line">            this.destination = destination;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @ThreadSafe</span><br><span class="line">    class Dispatcher &#123;</span><br><span class="line">        @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; taxis;</span><br><span class="line">        @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line"> </span><br><span class="line">        public Dispatcher() &#123;</span><br><span class="line">            taxis = new HashSet&lt;Taxi&gt;();</span><br><span class="line">            availableTaxis = new HashSet&lt;Taxi&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public synchronized void notifyAvailable(Taxi taxi) &#123;</span><br><span class="line">            availableTaxis.add(taxi);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public Image getImage() &#123;</span><br><span class="line">            Set&lt;Taxi&gt; copy;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                copy = new HashSet&lt;Taxi&gt;(taxis);</span><br><span class="line">            &#125;</span><br><span class="line">            Image image = new Image();</span><br><span class="line">            for (Taxi t : copy)</span><br><span class="line">                image.drawMarker(t.getLocation());</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Image &#123;</span><br><span class="line">        public void drawMarker(Point p) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-0-15-资源死锁"><a href="#1-0-15-资源死锁" class="headerlink" title="1.0.15 资源死锁"></a>1.0.15 资源死锁</h4><ul>
<li>数据库连接池，A持有数据库D1连接，等待与D2连接，B持有D2的连接，等待与D1连接。</li>
<li>线程饥饿死锁，如8.1.1小节的例子。</li>
</ul>
<h3 id="10-2-死锁的避免与诊断"><a href="#10-2-死锁的避免与诊断" class="headerlink" title="10.2 死锁的避免与诊断"></a>10.2 死锁的避免与诊断</h3><h4 id="10-2-1-支持定时的锁"><a href="#10-2-1-支持定时的锁" class="headerlink" title="10.2.1 支持定时的锁"></a>10.2.1 支持定时的锁</h4><p>tryLock</p>
<h4 id="10-2-2-kill-3-发信号给JVM-dump线程"><a href="#10-2-2-kill-3-发信号给JVM-dump线程" class="headerlink" title="10.2.2 kill -3 发信号给JVM dump线程"></a>10.2.2 kill -3 发信号给JVM dump线程</h4><h3 id="10-3-其他活跃性危险"><a href="#10-3-其他活跃性危险" class="headerlink" title="10.3 其他活跃性危险"></a>10.3 其他活跃性危险</h3><h4 id="10-3-1-饥饿"><a href="#10-3-1-饥饿" class="headerlink" title="10.3.1 饥饿"></a>10.3.1 饥饿</h4><h4 id="10-3-3-活锁Livelock"><a href="#10-3-3-活锁Livelock" class="headerlink" title="10.3.3 活锁Livelock"></a>10.3.3 活锁Livelock</h4><p>他不会阻塞线程，但是也不能继续执行，因为线程在不断的重复执行相同的操作，而且总会失败。</p>
<p>例如处理事务消，回滚后再次重新把任务放在队头。</p>
<p>又例如发送数据包，都选择1s后重试，那么总会冲突，所以可以考虑一个随机数时间间隔。</p>
<h2 id="第11章-性能与可伸缩性Performance-and-Scalability"><a href="#第11章-性能与可伸缩性Performance-and-Scalability" class="headerlink" title="第11章 性能与可伸缩性Performance and Scalability"></a>第11章 性能与可伸缩性Performance and Scalability</h2><p>线程可以充分发挥系统的处理能力，提高资源利用率。同时现有的线程可以提升系统响应性。</p>
<p>但是在安全性与极限性能上，我们首先需要保证的是安全性。</p>
<h3 id="11-1-对性能的思考"><a href="#11-1-对性能的思考" class="headerlink" title="11.1 对性能的思考"></a>11.1 对性能的思考</h3><p>提升性能=用更少的资源做更多的事情（太对了，这才是问题的本质）。</p>
<p>资源包括：CPU时钟周期，内存，网络带宽，I/O带宽，数据请求，磁盘空间等。</p>
<p>资源密集型说的就是对上述维度敏感的应用。</p>
<p>与单线程相比，多线程总会一起一些额外的性能开销：</p>
<ul>
<li>线程协调with coordinating between threads (locking, signaling, and memory synchronization)</li>
<li>上下文切换increased context switching</li>
<li>线程创建和销毁thread creation and teardown</li>
<li>线程调度scheduling overhead</li>
</ul>
<p>可伸缩性是指：增加资源，程序的吞吐可以成比例的增加。</p>
<p>性能的提高往往是一个权衡的过程，需要考虑诸多因素。</p>
<h3 id="11-2-Amdahl定律-Amdahl’s-Law"><a href="#11-2-Amdahl定律-Amdahl’s-Law" class="headerlink" title="11.2 Amdahl定律 Amdahl’s Law"></a>11.2 Amdahl定律 Amdahl’s Law</h3><p>收割可以靠并行提高性能，而作物生长则不行。这是一个很简单的自然界的问题，在计算机界也存在，需要对问题进行合理的分解，发现潜在的并行能力。</p>
<p>Amdahl定律：<a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">并行计算</a>中的<strong>加速比</strong>是用并行前的执行速度和并行后的执行速度之比来表示的，它表示了在并行化之后的效率提升情况。</p>
<p>speedup &lt;= 1 /  F + (1 - F) /N </p>
<p>F表示被串行化的部分，N表示处理器数量。</p>
<p>如果N无穷大，那么最大的加速比例是1/F。理论上如果50%是串行的，那么最大的加速比只能是2。如果10%串行。那么最大加速比接近10，如果N=10也就是说有10个处理器资源，那么最高的加速比是5.4，在100个处理器的情况下是9.2。</p>
<p>但是任何程序都存在串行部分，例如从队列中take数据，访问数据库的操作等，这是绝对的。</p>
<p>书中举了一个例子是Synchronized linkedlist和ConcurrentLinkedQueue的吞吐率对比，在处理器数量到达上限后，他们的吞吐都基本是一条持平的线，但是Synchronized linkedlist吞吐率更低，在处理器较少的情况下就到达了极限，这主要受context switch的限制。</p>
<h3 id="11-3-线程引入的开销"><a href="#11-3-线程引入的开销" class="headerlink" title="11.3 线程引入的开销"></a>11.3 线程引入的开销</h3><p>单线程不存在线程调度，也不存在同步开销，不需要使用锁来保证安全一致性。而多线程这些都需要考虑。</p>
<h4 id="11-3-1-上下文切换"><a href="#11-3-1-上下文切换" class="headerlink" title="11.3.1 上下文切换"></a>11.3.1 上下文切换</h4><p>操作系统的设计者巧妙地利用了时间片轮转的方式, CPU给每个任务都服务一定的时间, 然后把当前任务的状态保存下来, 在加载下一任务的状态后, 继续服务下一任务. 如果可运行的线程数大于CPU数量，那么OS会最终将某个正在运行的线程调度出来，从而让其他线程能够使用CPU，这会导致一次上下文切换，主要包括当前线程“保存现场”，并且新调度出来的线程需要“恢复现场“。这里的context switch直接消耗包括: CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉; 间接消耗指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小). </p>
<p>JVM和OS消耗的CPU时钟周期越少，那么APP可用的CPU时钟周期就越多。</p>
<p>往往OS有一个最小的执行时间，防止过于频繁的上下文切换。</p>
<p>JVM会因为阻塞比如锁、阻塞I/O而挂起线程，如果频繁的阻塞，就会无法使用完整的调度时间片。//?</p>
<p>如果可运行的线程数大于CPU的内核数，那么OS会根据一定的调度算法，强行切换正在运行的线程，从而使其它线程能够使用CPU周期。</p>
<p>切换线程会导致上下文切换。线程的调度会导致CPU需要在操作系统和进程间花费更多的时间片段，这样真正执行应用程序的时间就减少了。另外上下文切换也会导致缓存的频繁进出，对于一个刚被切换的线程来说，可能由于高速缓冲中没有数据而变得更慢，从而导致更多的IO开销。</p>
<p><code>vmstat</code>    命令可以看cs这一个字段看上下文切换的数据。</p>
<h4 id="11-3-2-内存同步"><a href="#11-3-2-内存同步" class="headerlink" title="11.3.2 内存同步"></a>11.3.2 内存同步</h4><p>同步的性能开销包括多个方面。在synchronized和volatile提供的可见性保证中会使用一些特殊指令，即内存栅栏（memory barrier），内存栅栏可以刷新缓存，满足可见性，但是它也会抑制一些编译器优化，例如不能指令重排序。</p>
<p>现代的JVM对于无竞争的synchronized的消耗非常小，基本微乎其微。</p>
<p>同时现代的JVM编译优化做的非常成熟，一些不必要的同步开销往往可以优化掉。例如，下面的代码会去掉锁获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (new Object()) &#123;</span><br><span class="line"> // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一些比如escape analysis会找出不会发布到堆上的本地对象，锁的获取和释放会被优化为最小的次数甚至去掉。例如下面的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getStoogeNames() &#123;</span><br><span class="line"> List&lt;String&gt; stooges = new Vector&lt;String&gt;();</span><br><span class="line"> stooges.add(&quot;Moe&quot;);</span><br><span class="line"> stooges.add(&quot;Larry&quot;);</span><br><span class="line"> stooges.add(&quot;Curly&quot;);</span><br><span class="line"> return stooges.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然即使不escape，也会有lock coarsening过程，将临近的同步代码块使用同一个锁合并起来。这都减少了同步的开销。</p>
<p>所以不必过度担心非竞争同步带来的开销，这个基本的机制已经非常的快了，而且JVM还有能进行额外的优化以进一步降低或者消除开销的本领。</p>
<p>不同线程间要进行数据同步，synchronized以及volatile提供的可见性都会导致缓存失效。线程栈之间的数据要和主存进行同步，这些同步有一些小小的开销。如果线程间同时要进行数据同步，那么这些同步的线程可能都会受阻。</p>
<h4 id="11-3-3-阻塞"><a href="#11-3-3-阻塞" class="headerlink" title="11.3.3 阻塞"></a>11.3.3 阻塞</h4><p>竞争的同步需要OS介入，从而增加了开销。当在锁上发生竞争时，失败者线程会被阻塞，JVM在实现发现阻塞的行为时，可以采用</p>
<ul>
<li>自旋等待 spin-waiting</li>
<li>或者OS挂起被阻塞的线程</li>
</ul>
<p>这两种的效率高低取决于上下文切换的开销以及成功获取锁之前的等待时间，如果等待时间较短，则spin-waiting，如果较长则挂起。</p>
<p>一个线程被阻塞会产生上下文切换的影响，但是它到底何时执行这是由OS决定的，靠时间分片机制，这个调度的策略是OS解决的，而JVM的scheduler解决的是阻塞释放锁之后哪个线程需要被select出来执行，也就是转到runnable状态。</p>
<p>There is no single Java Virtual Machine; JVM is a specification, and there are multiple implementations of it, including the OpenJDK version and the Sun version of it, among others. I don’t know for certain, but I would guess that any reasonable JVM would simply use the underlying threading mechanism provided by the OS, which would imply POSIX Threads (pthreads) on UNIX (Mac OS X, Linux, etc.) and would imply WIN32 threads on Windows. Typically, those systems use a round-robin strategy by default. Many types of algorithms exist like <strong>preemptive</strong> and <strong>time slicing</strong>with <strong>round robin</strong> etc. </p>
<p>The JVM is based on <strong>preemptive and priority based</strong> scheduling algorithm to select thread to run.</p>
<p>每个Java线程一对一映射到Solaris平台上的一个本地线程上，并将线程调度交由本地线程的调度程序。由于Java线程是与本地线程是一对一地绑在一起的，所以改变Java线程的优先权也不会有可靠地运行结果。</p>
<p>对于类Unix系统而言，一般都是进程作为任务的调度单位，也即是操作系统调度器，只会针对进程来分配CPU等资源。由于进程彼此独立，相互不可进行直接访问，这增加了应用的通信成本。所以后面有了微进程，微进程与进程不同的是，允许一定程度上，彼此可以直接进行访问，详细可参考<a href="http://en.wikipedia.org/wiki/LinuxThreads" target="_blank" rel="noopener">LinuxThreads</a>。JVM在一些类Unix平台下，就是将线程映射到操作系统的微进程，来实现线程调度。这样多线程能够直接被系统调度器进行调度，与此对应的就是其线程的创建和销毁的成本就比较高，而且JVM的线程优先级很难进行匹配，无法提供确切的保证，仅仅是个hint。</p>
<p>当发生锁竞争时，失败的线程会导致阻塞。通常阻塞的线程可能在JVM内部进行自旋等待，或者被操作系统挂起。自旋等待可能会导致更多的CPU切片浪费，而操作系统挂起则会导致更多的上下文切换。</p>
<h3 id="11-4-减少锁的竞争"><a href="#11-4-减少锁的竞争" class="headerlink" title="11.4 减少锁的竞争"></a>11.4 减少锁的竞争</h3><p>减少锁的竞争能够提高性能和可伸缩性。</p>
<p>在并发程序中，对可伸缩性的最主要的威胁就是独占方式的资源锁。</p>
<p>有三种方式可以减低锁的竞争程度：</p>
<ul>
<li>减少锁的持有时间</li>
<li>降低锁的请求频率</li>
<li>使用带有协调机制的独占锁，这些机器允许更好的并发性。//?</li>
</ul>
<h4 id="11-4-1-缩小锁的范围（快进快出）"><a href="#11-4-1-缩小锁的范围（快进快出）" class="headerlink" title="11.4.1 缩小锁的范围（快进快出）"></a>11.4.1 缩小锁的范围（快进快出）</h4><p>原理就是Amdah定律，串行的代码总量减少了。</p>
<h4 id="11-4-2-减小锁的粒度"><a href="#11-4-2-减小锁的粒度" class="headerlink" title="11.4.2 减小锁的粒度"></a>11.4.2 减小锁的粒度</h4><p>这种方式就是降低线程请求锁的频率，通过锁分解来实现。</p>
<p>下面的应用明显锁的粒度太粗了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ServerStatusBeforeSplit &#123;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) public final Set&lt;String&gt; users;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) public final Set&lt;String&gt; queries;</span><br><span class="line"> </span><br><span class="line">    public ServerStatusBeforeSplit() &#123;</span><br><span class="line">        users = new HashSet&lt;String&gt;();</span><br><span class="line">        queries = new HashSet&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized void addUser(String u) &#123;</span><br><span class="line">        users.add(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized void addQuery(String q) &#123;</span><br><span class="line">        queries.add(q);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized void removeUser(String u) &#123;</span><br><span class="line">        users.remove(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized void removeQuery(String q) &#123;</span><br><span class="line">        queries.remove(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁分解就是独立的变量独立分配锁，不适用全局锁。优化后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ServerStatusAfterSplit &#123;</span><br><span class="line">    @GuardedBy(&quot;users&quot;) public final Set&lt;String&gt; users;</span><br><span class="line">    @GuardedBy(&quot;queries&quot;) public final Set&lt;String&gt; queries;</span><br><span class="line"> </span><br><span class="line">    public ServerStatusAfterSplit() &#123;</span><br><span class="line">        users = new HashSet&lt;String&gt;();</span><br><span class="line">        queries = new HashSet&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void addUser(String u) &#123;</span><br><span class="line">        synchronized (users) &#123;</span><br><span class="line">            users.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void addQuery(String q) &#123;</span><br><span class="line">        synchronized (queries) &#123;</span><br><span class="line">            queries.add(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void removeUser(String u) &#123;</span><br><span class="line">        synchronized (users) &#123;</span><br><span class="line">            users.remove(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void removeQuery(String q) &#123;</span><br><span class="line">        synchronized (users) &#123;</span><br><span class="line">            queries.remove(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-4-3-锁分段"><a href="#11-4-3-锁分段" class="headerlink" title="11.4.3 锁分段"></a>11.4.3 锁分段</h4><p>最典型的例子就是ConcurrentHashMap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class StripedMap &#123;</span><br><span class="line">    // Synchronization policy: buckets[n] guarded by locks[n%N_LOCKS]</span><br><span class="line">    private static final int N_LOCKS = 16;</span><br><span class="line">    private final Node[] buckets;</span><br><span class="line">    private final Object[] locks;</span><br><span class="line"> </span><br><span class="line">    private static class Node &#123;</span><br><span class="line">        Node next;</span><br><span class="line">        Object key;</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public StripedMap(int numBuckets) &#123;</span><br><span class="line">        buckets = new Node[numBuckets];</span><br><span class="line">        locks = new Object[N_LOCKS];</span><br><span class="line">        for (int i = 0; i &lt; N_LOCKS; i++)</span><br><span class="line">            locks[i] = new Object();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private final int hash(Object key) &#123;</span><br><span class="line">        return Math.abs(key.hashCode() % buckets.length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Object get(Object key) &#123;</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        synchronized (locks[hash % N_LOCKS]) &#123;</span><br><span class="line">            for (Node m = buckets[hash]; m != null; m = m.next)</span><br><span class="line">                if (m.key.equals(key))</span><br><span class="line">                    return m.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        for (int i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            synchronized (locks[i % N_LOCKS]) &#123;</span><br><span class="line">                buckets[i] = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-4-4-避免热点域hot-field"><a href="#11-4-4-避免热点域hot-field" class="headerlink" title="11.4.4 避免热点域hot field"></a>11.4.4 避免热点域hot field</h4><p>比如HashMap的size方法，ConcurrentHashMap采用了牺牲size的准确性的策略。</p>
<h4 id="11-4-5-一些替代独占锁的方法"><a href="#11-4-5-一些替代独占锁的方法" class="headerlink" title="11.4.5 一些替代独占锁的方法"></a>11.4.5 一些替代独占锁的方法</h4><p>ReadWriteLock，AtomicInteger，UNSAFE.compareAndSwap(..)</p>
<h4 id="11-4-6-监测CPU的利用率"><a href="#11-4-6-监测CPU的利用率" class="headerlink" title="11.4.6 监测CPU的利用率"></a>11.4.6 监测CPU的利用率</h4><p>vmstat，kill -3 pid</p>
<p>”waiting to lock monitor…“有这句就证明竞争太激烈了。</p>
<h3 id="11-5-示例：比较Map的性能"><a href="#11-5-示例：比较Map的性能" class="headerlink" title="11.5 示例：比较Map的性能"></a>11.5 示例：比较Map的性能</h3><p>比较了ConcurrentHashMap和synchronized hashmap的性能对比。</p>
<p>串行访问Map一个锁 pk 多个线程能并发的访问Map通过分段锁。</p>
<p>竞争非常激烈的时候，synchronized hashmap伸缩性非常差，吞吐量不会随着线程数增加而增加，反而降低，因为每个操作消耗的时间大部分都用于上下文切换和调度延迟上了。</p>
<h3 id="11-6-减少上下文切换的开销"><a href="#11-6-减少上下文切换的开销" class="headerlink" title="11.6 减少上下文切换的开销"></a>11.6 减少上下文切换的开销</h3><p>举个例子，就是APP记录日志，例如写日志到本地或者远程RPC，直接记录会存在I/O阻塞，靠一个轻量级的queue来解耦，使得APP不感知影响，减少阻塞。</p>
<p><a href="http://www.artima.com/insidejvm/ed2/threadsynch.html" target="_blank" rel="noopener">http://www.artima.com/insidejvm/ed2/threadsynch.html</a>  //TODO</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解了性能的提升的几个方面，也了解性能的开销后，应用程序就要根据实际的场景进行取舍和评估。没有一劳永逸的优化方案，不断的进行小范围改进和调整是提高性能的有效手段。当前一些大的架构调整也会导致较大的性能的提升。</p>
<p>性能提升考虑的方面：</p>
<ul>
<li>系统平台的资源利用率</li>
</ul>
<p>一个程序对系统平台的资源利用率是指某一个设备繁忙且服务于此程序的时间占所有时间的比率。从物理学的角度讲类似于有用功的比率。简单的说就是：资源利用率=有效繁忙时间/总耗费时间。</p>
<p>也就说尽可能的让设备做有用的功，同时榨取其最大值。无用的循环可能会导致CPU 100%的使用率，但不一定是有效的工作。有效性通常难以衡量，通常只能以主观来评估，或者通过被优化的程序的行为来判断是否提高了有效性。</p>
<ul>
<li>延迟</li>
</ul>
<p>延迟描述的是完成任务所耗费的时间。延迟有时候也成为响应时间。如果有多个并行的操作，那么延迟取决于耗费时间最大的任务。</p>
<ul>
<li>多处理</li>
</ul>
<p>多处理是指在单一系统上同时执行多个进程或者多个程序的能力。多处理能力的好处是可以提高吞吐量。多处理可以有效利用多核CPU的资源。</p>
<ul>
<li>多线程</li>
</ul>
<p>多线程描述的是同一个地址空间内同时执行多个线程的过程。这些线程都有不同的执行路径和不同的栈结构。我们说的并发性更多的是指针对线程。</p>
<ul>
<li>并发性</li>
</ul>
<p>同时执行多个程序或者任务称之为并发。单程序内的多任务处理或者多程序间的多任务处理都认为是并发。</p>
<ul>
<li>吞吐量</li>
</ul>
<p>吞吐量衡量系统在单位之间内可以完成的工作总量。对于硬件系统而言，吞吐量是物理介质的上限。在没有达到物理介质之前，提高系统的吞吐量也可以大幅度改进性能。同时吞吐量也是衡量性能的一个指标。</p>
<ul>
<li>瓶颈</li>
</ul>
<p>程序运行过程中性能最差的地方。通常而言，串行的IO、磁盘IO、内存单元分配、网络IO等都可能造成瓶颈。某些使用太频繁的算法也有可能成为瓶颈。</p>
<ul>
<li>可扩展性</li>
</ul>
<p>这里的可扩展性主要是指程序或系统通过增加可使用的资源而增加性能的能力。</p>
<h2 id="第12章-并发程序的测试"><a href="#第12章-并发程序的测试" class="headerlink" title="第12章 并发程序的测试"></a>第12章 并发程序的测试</h2><p>略</p>
<h2 id="第13章-显式锁-Explicit-Locks"><a href="#第13章-显式锁-Explicit-Locks" class="headerlink" title="第13章 显式锁 Explicit Locks"></a>第13章 显式锁 Explicit Locks</h2><p>Java5.0之前只能用synchronized和volatile，5.0后Doug Lea加入了ReentrantLock，并不是替代内置锁，而是当内置锁机制不适用时，作为一种可选择的高级功能。</p>
<p>不适用可以包括无法中断一个正在等待获取锁的线程，无限的锁等待，内置锁必须放在代码块里面（编程有些局限性），所以提供了J.U.C的lock。</p>
<h3 id="13-1-Lock和ReentrantLock"><a href="#13-1-Lock和ReentrantLock" class="headerlink" title="13.1 Lock和ReentrantLock"></a>13.1 Lock和ReentrantLock</h3><p>Lock接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line"> void lock();</span><br><span class="line"> void lockInterruptibly() throws InterruptedException;</span><br><span class="line"> boolean tryLock();</span><br><span class="line"> boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line"> throws InterruptedException;</span><br><span class="line"> void unlock();</span><br><span class="line"> Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用范例模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">...</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"> // update object state</span><br><span class="line"> // catch exceptions and restore invariants if necessary</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"> lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以叫做RentrantLock，可理解为两部：</p>
<p>1）Rentrant，可重入，lock多少次都没关系，只需要unlock即可，或者lock里面嵌套了别的lock都可以。</p>
<p>2）Lock，提供了和synchronized一样的互斥性和内存可见性，与synchronized的monitor内存语义一样。</p>
<p>与synchronized的区别在于</p>
<ul>
<li>可定时锁等待</li>
<li>可轮询锁等待</li>
<li>可中断锁等待</li>
<li>公平性</li>
<li>实现非块结构的加锁</li>
<li>绑定多个Condition。通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await(),signal();</li>
</ul>
<p>下面依次讲解：</p>
<p>轮询锁和定时锁，内置锁的死锁问题只能通过重启程序解决，那么可定时和可轮询的锁提供了另一种选择。通过tryLock解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class DeadlockAvoidance &#123;</span><br><span class="line">    private static Random rnd = new Random();</span><br><span class="line"> </span><br><span class="line">    public boolean transferMoney(Account fromAcct,</span><br><span class="line">                                 Account toAcct,</span><br><span class="line">                                 DollarAmount amount,</span><br><span class="line">                                 long timeout,</span><br><span class="line">                                 TimeUnit unit)</span><br><span class="line">            throws InsufficientFundsException, InterruptedException &#123;</span><br><span class="line">        long fixedDelay = getFixedDelayComponentNanos(timeout, unit);</span><br><span class="line">        long randMod = getRandomDelayModulusNanos(timeout, unit);</span><br><span class="line">        long stopTime = System.nanoTime() + unit.toNanos(timeout); //定时，轮询</span><br><span class="line"> </span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (fromAcct.lock.tryLock()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (toAcct.lock.tryLock()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if (fromAcct.getBalance().compareTo(amount) &lt; 0)</span><br><span class="line">                                throw new InsufficientFundsException();</span><br><span class="line">                            else &#123;</span><br><span class="line">                                fromAcct.debit(amount);</span><br><span class="line">                                toAcct.credit(amount);</span><br><span class="line">                                return true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            toAcct.lock.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    fromAcct.lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (System.nanoTime() &lt; stopTime)</span><br><span class="line">                return false;</span><br><span class="line">            NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static final int DELAY_FIXED = 1;</span><br><span class="line">    private static final int DELAY_RANDOM = 2;</span><br><span class="line"> </span><br><span class="line">    static long getFixedDelayComponentNanos(long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return DELAY_FIXED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static long getRandomDelayModulusNanos(long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return DELAY_RANDOM;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class DollarAmount implements Comparable&lt;DollarAmount&gt; &#123;</span><br><span class="line">        public int compareTo(DollarAmount other) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        DollarAmount(int dollars) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class Account &#123;</span><br><span class="line">        public Lock lock;</span><br><span class="line"> </span><br><span class="line">        void debit(DollarAmount d) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        void credit(DollarAmount d) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        DollarAmount getBalance() &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    class InsufficientFundsException extends Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带有时间限制的锁如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TimedLocking &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    public boolean trySendOnSharedLine(String message,</span><br><span class="line">                                       long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        long nanosToLock = unit.toNanos(timeout)</span><br><span class="line">                - estimatedNanosToSend(message);</span><br><span class="line">        if (!lock.tryLock(nanosToLock, NANOSECONDS))</span><br><span class="line">            return false;</span><br><span class="line">        try &#123;</span><br><span class="line">            return sendOnSharedLine(message);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private boolean sendOnSharedLine(String message) &#123;</span><br><span class="line">        /* send something */</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    long estimatedNanosToSend(String message) &#123;</span><br><span class="line">        return message.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可中断的锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InterruptibleLocking &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"> </span><br><span class="line">    public boolean sendOnSharedLine(String message)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            return cancellableSendOnSharedLine(message);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private boolean cancellableSendOnSharedLine(String message) throws InterruptedException &#123;</span><br><span class="line">        /* send something */</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非结构块的加锁就不用说了。</p>
<p>另外，关于Condition的例子，最典型的就是阻塞的有界队列的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedBuffer &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(BoundedBuffer.class);</span><br><span class="line"></span><br><span class="line">    final Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    final Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    final Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    final Object[] items = new Object[2]; // 阻塞队列</span><br><span class="line"></span><br><span class="line">    int putptr, takeptr, count;</span><br><span class="line">    </span><br><span class="line">    private void log(String info) &#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName() + &quot; - &quot; + info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">        log(x + &quot;,执行put&quot;);</span><br><span class="line">        lock.lock();</span><br><span class="line">        log(x + &quot;,put lock.lock()&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length) &#123; // 如果队列满了，notFull就一直等待</span><br><span class="line">                log(x + &quot;,put notFull.await() 队列满了&quot;);</span><br><span class="line">                notFull.await(); // 调用await的意思取反，及not notFull -&gt; Full</span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x; // 终于可以插入队列</span><br><span class="line">            if (++putptr == items.length) &#123;</span><br><span class="line">                putptr = 0; // 如果下标到达数组边界，循环下标置为0</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            log(x + &quot;,put成功 notEmpty.signal() 周知队列不为空了&quot;);</span><br><span class="line">            notEmpty.signal(); // 唤醒notEmpty</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            log(x + &quot;,put lock.unlock()&quot;);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object take() throws InterruptedException &#123;</span><br><span class="line">        log(&quot;执行take&quot;);</span><br><span class="line">        lock.lock();</span><br><span class="line">        Object x = null;</span><br><span class="line">        log(&quot;take lock.lock()&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0) &#123;</span><br><span class="line">                log(&quot;take notEmpty.await() 队列为空等等&quot;);</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = items[takeptr];</span><br><span class="line">            if (++takeptr == items.length) &#123;</span><br><span class="line">                takeptr = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            log(x + &quot;,take成功 notFull.signal() 周知队列有剩余空间了&quot;);</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            log(x + &quot;,take lock.unlock()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final BoundedBuffer bb = new BoundedBuffer();</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class="line"></span><br><span class="line">        for (char i = &apos;A&apos;; i &lt; &apos;F&apos;; i++) &#123;</span><br><span class="line">            final char t = i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bb.put(t);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Character&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">        for (char i = &apos;A&apos;; i &lt; &apos;F&apos;; i++) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    char c = (char) bb.take();</span><br><span class="line">                    res.add(c);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            executor.awaitTermination(2, TimeUnit.SECONDS);</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">            ie.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(res.toString());</span><br><span class="line">        executor.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-2-性能考虑因素"><a href="#13-2-性能考虑因素" class="headerlink" title="13.2 性能考虑因素"></a>13.2 性能考虑因素</h3><p>Java5.0的时候J.U.C的ReentrantLock锁竞争性能非常好，到了Java6.0使用了改进后的算法来管理内置锁，所以现在差不太多了，只好一点点。</p>
<p>竞争性能的影响可伸缩性的关键要素：如果有越多的资源被耗费在锁的管理和线程调度上，那么应用程序得到的资源就越少，锁的实现方式越好，将需要越少的系统调用和上下文切换。</p>
<h3 id="13-3-公平性"><a href="#13-3-公平性" class="headerlink" title="13.3 公平性"></a>13.3 公平性</h3><p>默认ReentrantLock创建的事非公平的锁，这个非公平是指被阻塞挂起的线程（使用LockSupport.park）都在AQS（下一节会讲）的CLH队列中排队等待自己被唤醒，他们是按照发出的请求顺序来排队的，但是一旦有一个唤醒的就会和新来的线程来竞争锁，新来的可能会“插队”，如果新来的成功获取锁，那么它将跳过所有等待线程而开始执行，这也就是以为着本该被唤醒的线程失败了，对不起您回到队列的尾部继续等。这就是非公平性。</p>
<p>一般，非公平锁的性能要好于公平锁。原因在于一个线程被唤醒是需要时间的，挂起线程和唤醒回复线程存在开销，这个空隙如果有其他线程处于ready状态，不需要上下文切换，那么直接运行就行，A持有锁，B请求，但是B在恢复的过程中,C可以插队“非公平”的获取锁，然后执行再释放，这时候B刚刚好做完上下文切换可以执行，这个对于B和C来说是一个“双赢”的局面，是提高吞吐量的原因。</p>
<p>那么JVM也没有在其内置锁上采用公平性的机制。</p>
<h3 id="13-4-在synchronized和ReentrantLock之间进行选择"><a href="#13-4-在synchronized和ReentrantLock之间进行选择" class="headerlink" title="13.4 在synchronized和ReentrantLock之间进行选择"></a>13.4 在synchronized和ReentrantLock之间进行选择</h3><p>除非使用到13.1提到的高级特性，或者内置锁无法满足需求时，否则还是老实用内置锁，毕竟是JVM自身提供的，而不是靠类库，因此可能会执行一些优化。</p>
<p>另外内置锁在利用kill -3 dump thread的时候可以发现栈帧上的一些monitor lock的信息，识别死锁，而J.U.C的锁这方面就不太行，当然JAVA6之后提供了管理和调试接口解决了。</p>
<h3 id="13-5-读-写锁"><a href="#13-5-读-写锁" class="headerlink" title="13.5 读-写锁"></a>13.5 读-写锁</h3><p>ReentrantLock每次只有一个线程能持有锁，但是这种严格的互斥也会抑制并发。会抑制：</p>
<ul>
<li>写/写</li>
<li>写/读</li>
<li>读/读</li>
</ul>
<p>冲突，但是很多情况下读操作是非常多的，如果放宽加锁的需求，允许多个读操作可以同时访问数据，那么就可以提升性能。<strong>但是要保证读取的数据是最新的，不会有其他线程修改数据。</strong></p>
<p>使用ReadWriteLock的场景是：一个资源可以被多个读操作访问，或者被一个写操作访问，但是二者不能同时进行。API如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lock	readLock() Returns the lock used for reading.</span><br><span class="line"> Lock	writeLock()  Returns the lock used for writing.</span><br></pre></td></tr></table></figure>
<p>如果读正在持有锁，这时候另外一个线程写，那么会优先获取写。//？</p>
<p>下面是一个应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public class ReadWriteMap &lt;K,V&gt; &#123;</span><br><span class="line">    private final Map&lt;K, V&gt; map;</span><br><span class="line">    private final ReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line">    private final Lock r = lock.readLock();</span><br><span class="line">    private final Lock w = lock.writeLock();</span><br><span class="line"> </span><br><span class="line">    public ReadWriteMap(Map&lt;K, V&gt; map) &#123;</span><br><span class="line">        this.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.remove(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.putAll(m);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int size() &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.size();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.isEmpty();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean containsKey(Object key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.containsKey(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean containsValue(Object value) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.containsValue(value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第14章-构建自定义的同步工具-Building-Custom-Synchronizers"><a href="#第14章-构建自定义的同步工具-Building-Custom-Synchronizers" class="headerlink" title="第14章 构建自定义的同步工具 Building Custom Synchronizers"></a>第14章 构建自定义的同步工具 Building Custom Synchronizers</h2><p>类库中包含了许多存在状态依赖的类，例如FutureTask、Semaphore和BlockingQueue，他们的一些操作都有前提条件，例如非空，或者任务已完成等。</p>
<p>创建状态依赖类的最简单的房就是在JDK提供了的状态依赖类基础上构造。例如第八章的ValueLactch，如果这些不满足，可以使用Java语言或者类库提供的底层机制来构造，包括</p>
<ul>
<li>内置的条件队列</li>
<li>condition</li>
<li>AQS</li>
</ul>
<p>这一章就介绍这些。</p>
<h3 id="14-1-状态依赖性的管理-State-Dependence"><a href="#14-1-状态依赖性的管理-State-Dependence" class="headerlink" title="14.1 状态依赖性的管理 State Dependence"></a>14.1 状态依赖性的管理 State Dependence</h3><p>在14.2节会介绍使用条件队列来解决阻塞线程运行的问题。下面先介绍通过轮询和休眠的方式（勉强）的解决。</p>
<p>下面是一个标准的模板，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void blockingAction() throws InterruptedException &#123;</span><br><span class="line">   acquire lock on object state</span><br><span class="line">   while (precondition does not hold) &#123;</span><br><span class="line">      release lock</span><br><span class="line">      wait until precondition might hold</span><br><span class="line">      optionally fail if interrupted or timeout expires</span><br><span class="line">      reacquire lock</span><br><span class="line">   &#125;</span><br><span class="line">   perform action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面介绍阻塞有界队列的集中实现方式。依赖的前提条件是：</p>
<ul>
<li>不能从空缓存中获取元素</li>
<li>不能将元素放入已满的缓存中</li>
</ul>
<p>不满足条件时候，依赖状态的操作可以</p>
<ul>
<li>抛出异常</li>
<li>返回一个错误状态（码）</li>
<li>阻塞直到进入正确的状态</li>
</ul>
<p>下面是基类，线程安全，但是非阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public abstract class BaseBoundedBuffer &lt;V&gt; &#123;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private final V[] buf;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private int tail;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private int head;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private int count;</span><br><span class="line"> </span><br><span class="line">    protected BaseBoundedBuffer(int capacity) &#123;</span><br><span class="line">        this.buf = (V[]) new Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected synchronized final void doPut(V v) &#123;</span><br><span class="line">        buf[tail] = v;</span><br><span class="line">        if (++tail == buf.length)</span><br><span class="line">            tail = 0;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected synchronized final V doTake() &#123;</span><br><span class="line">        V v = buf[head];</span><br><span class="line">        buf[head] = null;</span><br><span class="line">        if (++head == buf.length)</span><br><span class="line">            head = 0;</span><br><span class="line">        --count;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized final boolean isFull() &#123;</span><br><span class="line">        return count == buf.length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized final boolean isEmpty() &#123;</span><br><span class="line">        return count == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“先检查再运行”的逻辑解决方案如下，调用者必须自己处理前提条件失败的情况。当然也可以返回错误消息。</p>
<p>当然调用者可以不Sleep，而是直接重试，这种方法叫做<strong>忙等待或者自旋等待（busy waiting or spin waiting. ）</strong>，如果换成很长时间都不变，那么这将会消耗大量的CPU时间！！！所以调用者自己休眠，sleep让出CPU。但是这个时间就很尴尬了，sleep长了万一一会前提条件就满足了岂不是白等了从而响应性低，sleep短了浪费CPU时钟周期。另外可以试试yield，但是这也不靠谱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">        public class GrumpyBoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123;</span><br><span class="line">    public GrumpyBoundedBuffer() &#123;</span><br><span class="line">        this(100);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public GrumpyBoundedBuffer(int size) &#123;</span><br><span class="line">        super(size);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized void put(V v) throws BufferFullException &#123;</span><br><span class="line">        if (isFull())</span><br><span class="line">            throw new BufferFullException();</span><br><span class="line">        doPut(v);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized V take() throws BufferEmptyException &#123;</span><br><span class="line">        if (isEmpty())</span><br><span class="line">            throw new BufferEmptyException();</span><br><span class="line">        return doTake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class ExampleUsage &#123;</span><br><span class="line">    private GrumpyBoundedBuffer&lt;String&gt; buffer;</span><br><span class="line">    int SLEEP_GRANULARITY = 50;</span><br><span class="line"> </span><br><span class="line">    void useBuffer() throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String item = buffer.take();</span><br><span class="line">                // use item</span><br><span class="line">                break;</span><br><span class="line">            &#125; catch (BufferEmptyException e) &#123;</span><br><span class="line">                Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步改进下，首先让客户端舒服些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SleepyBoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123;</span><br><span class="line">    int SLEEP_GRANULARITY = 60;</span><br><span class="line"> </span><br><span class="line">    public SleepyBoundedBuffer() &#123;</span><br><span class="line">        this(100);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public SleepyBoundedBuffer(int size) &#123;</span><br><span class="line">        super(size);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void put(V v) throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (!isFull()) &#123;</span><br><span class="line">                    doPut(v);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public V take() throws InterruptedException &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (!isEmpty())</span><br><span class="line">                    return doTake();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式测试失败，那么释放锁，让别人做，自己休眠下，然后再检测，不断的重复这个过程，当然可以解决，但是还是需要做权衡，CPU使用率与响应性之间的抉择。</p>
<p>那么我们想如果这种轮询和休眠的dummy方式不用，而是存在某种挂起线程的方案，并且这种方法能够确保党某个条件成真时候立刻唤醒线程，那么将极大的简化实现工作，这就是条件队列的实现。</p>
<p>Condition Queues的名字来源：it gives a group of threads called the <strong>wait set</strong> a way to wait for a specific<br>condition to become true. Unlike typical queues in which the elements are data items, the elements of a condition queue are the threads waiting for the condition.</p>
<p>每个Java对象都可以是一个锁，每个对象同样可以作为一个条件队列，并且Object的wait、notify和notifyAll就是内部条件队列的API。对象的内置锁（intrinsic lock ）和内置条件队列是关联的，<strong>要调用X中的条件队列的任何一个方法，都必须持有对象X上的锁。</strong></p>
<p>Object.wait自动释放锁，并且请求操作系统挂起当前线程，从而其他线程可以获得这个锁并修改对象状态。当被挂起的线程唤醒时。它将在返回之前重新获取锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class BoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123;</span><br><span class="line">    // CONDITION PREDICATE: not-full (!isFull())</span><br><span class="line">    // CONDITION PREDICATE: not-empty (!isEmpty())</span><br><span class="line">    public BoundedBuffer() &#123;</span><br><span class="line">        this(100);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public BoundedBuffer(int size) &#123;</span><br><span class="line">        super(size);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // BLOCKS-UNTIL: not-full</span><br><span class="line">    public synchronized void put(V v) throws InterruptedException &#123;</span><br><span class="line">        while (isFull())</span><br><span class="line">            wait();</span><br><span class="line">        doPut(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // BLOCKS-UNTIL: not-empty</span><br><span class="line">    public synchronized V take() throws InterruptedException &#123;</span><br><span class="line">        while (isEmpty())</span><br><span class="line">            wait();</span><br><span class="line">        V v = doTake();</span><br><span class="line">        notifyAll();</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // BLOCKS-UNTIL: not-full</span><br><span class="line">    // Alternate form of put() using conditional notification</span><br><span class="line">    public synchronized void alternatePut(V v) throws InterruptedException &#123;</span><br><span class="line">        while (isFull())</span><br><span class="line">            wait();</span><br><span class="line">        boolean wasEmpty = isEmpty();</span><br><span class="line">        doPut(v);</span><br><span class="line">        if (wasEmpty)</span><br><span class="line">            notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果某个功能无法通过“轮询和休眠”来实现，那么条件队列也无法实现。</p>
<h3 id="14-2-Using-Condition-Queues"><a href="#14-2-Using-Condition-Queues" class="headerlink" title="14.2 Using Condition Queues"></a>14.2 Using Condition Queues</h3><h4 id="14-2-1-条件谓词The-Condition-Predicate"><a href="#14-2-1-条件谓词The-Condition-Predicate" class="headerlink" title="14.2.1 条件谓词The Condition Predicate"></a>14.2.1 条件谓词The Condition Predicate</h4><p>The Condition Predicate 是使某个操作成为状态依赖操作的前提条件。take方法的条件谓词是”缓存不为空“，take方法在执行之前必须首先测试条件谓词。同样，put方法的条件谓词是”缓存不满“。</p>
<p>在条件等待中存在一种重要的三元关系，包括</p>
<ul>
<li>加锁</li>
<li>wait方法</li>
<li>条件谓词</li>
</ul>
<p>条件谓词中包含多个状态变量，而状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁。锁对象和条件队列对象必须是同一个对象。wait释放锁，线程挂起阻塞，等待知道超时，然后被另外一个线程中断或者被一个通知唤醒。唤醒后，wait在返回前还需要重新获取锁，当线程从wait方法中唤醒，它在重新请求锁时不具有任何特殊的优先级，和其他人一起竞争。</p>
<h4 id="14-2-2-过早唤醒"><a href="#14-2-2-过早唤醒" class="headerlink" title="14.2.2 过早唤醒"></a>14.2.2 过早唤醒</h4><p>其他线程中间插足了，获取了锁，并且修改了遍历，这时候线程获取锁需要重新检查条件谓词。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait block ----------race to get lock ------------------------------------------get lock ----- </span><br><span class="line">                    ^</span><br><span class="line">wait block --------&gt; race to get lock ------get lock------&gt; perform action  ---&gt; release lock</span><br><span class="line">                    ^</span><br><span class="line">                    notifyAll</span><br></pre></td></tr></table></figure>
<p>当然有的时候，比如一个你根本不知道为什么别人调用了notify或者notifyAll，也许条件谓词压根就没满足，但是线程还是获取了锁，然后test条件谓词，释放所，其他线程都来了这么一趟，发生这就是“谎报军情”啊。</p>
<p>基于以上这两种情况，都必须重新测试条件谓词。</p>
<p>When using condition waits (Object.wait or Condition.await):</p>
<ul>
<li>Always have a condition predicate——some test of object state that must hold before proceeding;</li>
<li>Always test the condition predicate before calling wait, and again after returning from wait;</li>
<li>Always call wait in a loop;</li>
<li>Ensure that the state variables making up the condition predicate are guarded by the lock associated with the condition queue;</li>
<li>Hold the lock associated with the the condition queue when calling wait, notify, or notifyAll</li>
<li>Do not release the lock after checking the condition predicate but before acting on it.</li>
</ul>
<p>模板就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void stateDependentMethod() throws InterruptedException &#123;</span><br><span class="line"> // condition predicate must be guarded by lock</span><br><span class="line"> synchronized(lock) &#123;  </span><br><span class="line">     while (!conditionPredicate())  //一定在循环里面做条件谓词</span><br><span class="line">         lock.wait();  //确保和synchronized的是一个对象</span><br><span class="line">     // object is now in desired state  //不要释放锁</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-2-3-丢失的信号"><a href="#14-2-3-丢失的信号" class="headerlink" title="14.2.3 丢失的信号"></a>14.2.3 丢失的信号</h4><p>保证notify一定在wait之后</p>
<h4 id="14-2-4-通知"><a href="#14-2-4-通知" class="headerlink" title="14.2.4 通知"></a>14.2.4 通知</h4><p>下面介绍通知。</p>
<p>调用notify和notifyAll也得持有与条件队列对象相关联的锁。调用notify，JVM Thread Scheduler在这个条件队列上等待的多个线程中选择一个唤醒，而notifyAll则会唤醒所有线程。因此一旦notify了那么就需要尽快的释放锁，否则别人都竞争等着拿锁，都会进行blocked的状态，而不是线程挂起waiting状态，竞争都了不是好事，但是这是你考了性能因素和安全性因素的一个矛盾，具体问题要具体分析。</p>
<p>下面的方法可以进来减少竞争，但是确然程序正确的实现有些难写，所以这个折中还得自己考虑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void alternatePut(V v) throws InterruptedException &#123;</span><br><span class="line">        while (isFull())</span><br><span class="line">            wait();</span><br><span class="line">        boolean wasEmpty = isEmpty();</span><br><span class="line">        doPut(v);</span><br><span class="line">        if (wasEmpty)</span><br><span class="line">            notifyAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用notify容易丢失信号，所以大多数情况下用notifyAll，比如take notify，却通知了另外一个take，没有通知put，那么这就是信号丢失，是一种“被劫持的”信号。</p>
<p>因此只有满足下面两个条件，才能用notify，而不是notifyAll：</p>
<ul>
<li>所有等待线程的类型都相同</li>
<li>单进单出</li>
</ul>
<h4 id="14-2-5-示例：阀门类A-Gate-Class"><a href="#14-2-5-示例：阀门类A-Gate-Class" class="headerlink" title="14.2.5 示例：阀门类A Gate Class"></a>14.2.5 示例：阀门类A Gate Class</h4><p>和第5章的那个TestHarness中使用CountDownLatch类似，完全可以使用wait/notifyAll做阀门。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class ThreadGate &#123;</span><br><span class="line">    // CONDITION-PREDICATE: opened-since(n) (isOpen || generation&gt;n)</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private boolean isOpen;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private int generation;</span><br><span class="line"> </span><br><span class="line">    public synchronized void close() &#123;</span><br><span class="line">        isOpen = false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized void open() &#123;</span><br><span class="line">        ++generation;</span><br><span class="line">        isOpen = true;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // BLOCKS-UNTIL: opened-since(generation on entry)</span><br><span class="line">    public synchronized void await() throws InterruptedException &#123;</span><br><span class="line">        int arrivalGeneration = generation;</span><br><span class="line">        while (!isOpen &amp;&amp; arrivalGeneration == generation)</span><br><span class="line">            wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-3-Explicit-Condition-Objects"><a href="#14-3-Explicit-Condition-Objects" class="headerlink" title="14.3 Explicit Condition Objects"></a>14.3 Explicit Condition Objects</h3><p>Lock是一个内置锁的替代，而Condition也是一种广义的<strong>内置条件队列</strong>。</p>
<p>Condition的API如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Condition &#123;</span><br><span class="line"> void await() throws InterruptedException;</span><br><span class="line"> boolean await(long time, TimeUnit unit)throws InterruptedException;</span><br><span class="line"> long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line"> void awaitUninterruptibly();</span><br><span class="line"> boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line"> void signal();</span><br><span class="line"> void signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内置条件队列存在一些缺陷，每个内置锁都只能有一个相关联的条件队列，记住是<strong>一个</strong>。所以在BoundedBuffer这种累中，<strong>多个线程可能在同一个条件队列上等待不同的条件谓词</strong>，所以notifyAll经常通知不是同一个类型的需求。如果想编写一个带有多个条件谓词的并发对象，或者想获得除了条件队列可见性之外的更多的控制权，可以使用Lock和Condition，而不是内置锁和条件队列，这更加灵活。</p>
<p>一个Condition和一个lock关联，想象一个条件队列和内置锁关联一样。在Lock上调用newCondition就可以新建无数个条件谓词，这些condition是可中断的、可有时间限制的，公平的或者非公平的队列操作。</p>
<p>The equivalents of wait, notify, and notifyAll for Condition objects are await, signal, and<br>signalAll。</p>
<p>下面的例子就是改造后的BoundedBuffer，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class ConditionBoundedBuffer &lt;T&gt; &#123;</span><br><span class="line">    protected final Lock lock = new ReentrantLock();</span><br><span class="line">    // CONDITION PREDICATE: notFull (count &lt; items.length)</span><br><span class="line">    private final Condition notFull = lock.newCondition();</span><br><span class="line">    // CONDITION PREDICATE: notEmpty (count &gt; 0)</span><br><span class="line">    private final Condition notEmpty = lock.newCondition();</span><br><span class="line">    private static final int BUFFER_SIZE = 100;</span><br><span class="line">    @GuardedBy(&quot;lock&quot;) private final T[] items = (T[]) new Object[BUFFER_SIZE];</span><br><span class="line">    @GuardedBy(&quot;lock&quot;) private int tail, head, count;</span><br><span class="line"> </span><br><span class="line">    // BLOCKS-UNTIL: notFull</span><br><span class="line">    public void put(T x) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[tail] = x;</span><br><span class="line">            if (++tail == items.length)</span><br><span class="line">                tail = 0;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // BLOCKS-UNTIL: notEmpty</span><br><span class="line">    public T take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            T x = items[head];</span><br><span class="line">            items[head] = null;</span><br><span class="line">            if (++head == items.length)</span><br><span class="line">                head = 0;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里使用了signal而不是signalll，能极大的减少每次缓存操作中发生的上下文切换和锁请求次数。</p>
<p>使用condition和内置锁和条件队列一样，必须保卫在lock里面。</p>
<h3 id="14-4-Synchronizer剖析"><a href="#14-4-Synchronizer剖析" class="headerlink" title="14.4 Synchronizer剖析"></a>14.4 Synchronizer剖析</h3><p>看似ReentrantLock和Semaphore功能很类似，每次只允许一定的数量线程通过，到达阀门时</p>
<ul>
<li>可以通过 lock或者acquire</li>
<li>等待，阻塞住了</li>
<li>取消tryLock，tryAcquire</li>
<li>可中断的，限时的</li>
<li>公平等待和非公平等待</li>
</ul>
<p>下面的程序是使用Lock做一个Mutex也就是持有一个许可的Semaphore。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SemaphoreOnLock &#123;</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line">    // CONDITION PREDICATE: permitsAvailable (permits &gt; 0)</span><br><span class="line">    private final Condition permitsAvailable = lock.newCondition();</span><br><span class="line">    @GuardedBy(&quot;lock&quot;) private int permits;</span><br><span class="line"> </span><br><span class="line">    SemaphoreOnLock(int initialPermits) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            permits = initialPermits;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // BLOCKS-UNTIL: permitsAvailable</span><br><span class="line">    public void acquire() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (permits &lt;= 0)</span><br><span class="line">                permitsAvailable.await();</span><br><span class="line">            --permits;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void release() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            ++permits;</span><br><span class="line">            permitsAvailable.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上很多J.U.C下面的类都是基于AbstractQueuedSynchronizer (AQS)构建的，例如CountDownLatch, ReentrantReadWriteLock, SynchronousQueue,and FutureTask（java7之后不是了）。AQS解决了实现同步器时设计的大量细节问题，例如等待线程采用FIFO队列操作顺序。AQS不仅能极大极少实现同步器的工作量，并且也不必处理竞争问题，基于AQS构建只可能在一个时刻发生阻塞，从而降低上下文切换的开销，提高吞吐量。在设计AQS时，充分考虑了可伸缩性，可谓大师Doug Lea的经典作品啊！</p>
<h3 id="14-5-AbstractQueuedSynchronizer-AQS"><a href="#14-5-AbstractQueuedSynchronizer-AQS" class="headerlink" title="14.5 AbstractQueuedSynchronizer (AQS)"></a>14.5 AbstractQueuedSynchronizer (AQS)</h3><p>基于AQS构建的同步器勒种，最进步的操作包括各种形式的获取操作和释放操作。获取操作是一种依赖状态的操作，并且通常会阻塞。</p>
<p>如果一个类想成为状态依赖的类，它必须拥有一些状态，AQS负责管理这些状态，通过getState,setState, compareAndSetState等protected类型方法进行操作。这是设计模式中的模板模式。</p>
<p>使用AQS的模板如下：</p>
<p>获取锁：首先判断当前状态是否允许获取锁，如果是就获取锁，否则就阻塞操作或者获取失败，也就是说如果是独占锁就可能阻塞，如果是共享锁就可能失败。另外如果是阻塞线程，那么线程就需要进入阻塞队列。当状态位允许获取锁时就修改状态，并且如果进了队列就从队列中移除。</p>
<p>释放锁:这个过程就是修改状态位，如果有线程因为状态位阻塞的话就唤醒队列中的一个或者更多线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boolean acquire() throws InterruptedException &#123;</span><br><span class="line"> while (state does not permit acquire) &#123;</span><br><span class="line"> if (blocking acquisition requested) &#123;</span><br><span class="line"> enqueue current thread if not already queued</span><br><span class="line"> block current thread</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> return failure</span><br><span class="line"> &#125;</span><br><span class="line"> possibly update synchronization state</span><br><span class="line"> dequeue thread if it was queued</span><br><span class="line"> return success</span><br><span class="line">&#125;</span><br><span class="line">void release() &#123;</span><br><span class="line"> update synchronization state</span><br><span class="line"> if (new state may permit a blocked thread to acquire)</span><br><span class="line"> unblock one or more queued threads</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要支持上面两个操作就必须有下面的条件：</p>
<ul>
<li>原子性操作同步器的状态位</li>
<li>阻塞和唤醒线程</li>
<li>一个有序的队列</li>
</ul>
<p><strong>1 状态位的原子操作</strong></p>
<p>这里使用一个32位的整数来描述状态位，前面章节的原子操作的理论知识整好派上用场，在这里依然使用CAS操作来解决这个问题。事实上这里还有一个64位版本的同步器（AbstractQueuedLongSynchronizer），这里暂且不谈。</p>
<p><strong>2 阻塞和唤醒线程</strong></p>
<p>标准的JAVA API里面是无法挂起（阻塞）一个线程，然后在将来某个时刻再唤醒它的。JDK 1.0的API里面有Thread.suspend和Thread.resume，并且一直延续了下来。但是这些都是过时的API，而且也是不推荐的做法。</p>
<p>HotSpot在Linux中中通过调用pthread_mutex_lock函数把线程交给系统内核进行阻塞。</p>
<p>在JDK 5.0以后利用JNI在LockSupport类中实现了此特性。</p>
<blockquote>
<p>LockSupport.park()<br>LockSupport.park(Object)<br>LockSupport.parkNanos(Object, long)<br>LockSupport.parkNanos(long)<br>LockSupport.parkUntil(Object, long)<br>LockSupport.parkUntil(long)<br>LockSupport.unpark(Thread)</p>
</blockquote>
<p>上面的API中park()是在当前线程中调用，导致线程阻塞，带参数的Object是挂起的对象，这样监视的时候就能够知道此线程是因为什么资源而阻塞的。由于park()立即返回，所以通常情况下需要在循环中去检测竞争资源来决定是否进行下一次阻塞。park()返回的原因有三：</p>
<ul>
<li>其他某个线程调用将当前线程作为目标调用 <a href="http://www.blogjava.net/xylz/java/util/concurrent/locks/LockSupport.html#unpark(java.lang.Thread" target="_blank" rel="noopener"><code>unpark</code></a>)；</li>
<li>其他某个线程<a href="http://www.blogjava.net/xylz/java/lang/Thread.html#interrupt(" target="_blank" rel="noopener">中断</a>)当前线程；</li>
<li>该调用不合逻辑地（即毫无理由地）返回。</li>
</ul>
<p>其实第三条就决定了需要循环检测了，类似于通常写的while(checkCondition()){Thread.sleep(time);}类似的功能。</p>
<p><strong>3 有序队列</strong></p>
<p>在AQS中采用CHL列表来解决有序的队列的问题。</p>
<p>AQS采用的CHL模型采用下面的算法完成FIFO的入队列和出队列过程。该队列的操作均通过Lock-Free（CAS）操作.</p>
<p>自己实现的CLH SpinLock如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class ClhSpinLock &#123;</span><br><span class="line">    private final ThreadLocal&lt;Node&gt; prev;</span><br><span class="line">    private final ThreadLocal&lt;Node&gt; node;</span><br><span class="line">    private final AtomicReference&lt;Node&gt; tail = new AtomicReference&lt;Node&gt;(new Node());</span><br><span class="line"></span><br><span class="line">    public ClhSpinLock() &#123;</span><br><span class="line">        this.node = new ThreadLocal&lt;Node&gt;() &#123;</span><br><span class="line">            protected Node initialValue() &#123;</span><br><span class="line">                return new Node();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        this.prev = new ThreadLocal&lt;Node&gt;() &#123;</span><br><span class="line">            protected Node initialValue() &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        final Node node = this.node.get();</span><br><span class="line">        node.locked = true;</span><br><span class="line">        // 一个CAS操作即可将当前线程对应的节点加入到队列中，</span><br><span class="line">        // 并且同时获得了前继节点的引用，然后就是等待前继释放锁</span><br><span class="line">        Node pred = this.tail.getAndSet(node);</span><br><span class="line">        this.prev.set(pred);</span><br><span class="line">        while (pred.locked) &#123;// 进入自旋</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        final Node node = this.node.get();</span><br><span class="line">        node.locked = false;</span><br><span class="line">        this.node.set(this.prev.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Node &#123;</span><br><span class="line">        private volatile boolean locked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于入队列(<em>enqueue)：</em>采用CAS操作，每次比较尾结点是否一致，然后插入的到尾结点中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">        pred = tail;</span><br><span class="line">&#125;while ( !compareAndSet(pred,tail,node) );</span><br></pre></td></tr></table></figure>
<p>对于出队列(<em>dequeue</em>):由于每一个节点也缓存了一个状态，决定是否出队列，因此当不满足条件时就需要自旋等待，一旦满足条件就将头结点设置为下一个节点。</p>
<p>AQS里面有三个核心字段：</p>
<blockquote>
<p>private volatile int state;</p>
<p>private transient volatile Node head;</p>
<p>private transient volatile Node tail;</p>
</blockquote>
<p>其中state描述的有多少个线程取得了锁，对于互斥锁来说state&lt;=1。head/tail加上CAS操作就构成了一个CHL的FIFO队列。下面是Node节点的属性。</p>
<p>独占操作的API都是不带有shared，而共享的包括semaphore和countdownlatch都是使用带有shared字面的API。</p>
<p>一些有用的参考资料：</p>
<p><strong>java.util.concurrent.locks.AbstractQueuedSynchronizer - </strong>AQS</p>
<p><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a>论文</p>
<p><a href="http://www.blogjava.net/xylz/archive/2010/07/08/325587.html" target="_blank" rel="noopener">http://www.blogjava.net/xylz/archive/2010/07/08/325587.html</a> 一个比较全面的另外一个人的解读</p>
<p><a href="http://suo.iteye.com/blog/1329460" target="_blank" rel="noopener">http://suo.iteye.com/blog/1329460</a></p>
<p><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer</a></p>
<p><a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-overview.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-overview.html</a></p>
<p><a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-clh-and-spin-lock.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-clh-and-spin-lock.html</a></p>
<p><a href="http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-locksupport-and-thread-interrupt.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-locksupport-and-thread-interrupt.html</a></p>
<p>独占的就用TRyAcquire, TRyRelease, and isHeldExclusively,共享的就用 tryAcquireShared and TRyReleaseShared. 带有try前缀的方法都是模板方法，AQS用于判断是否可以继续，例如如果tryAcquireShared返回一个负值，那么表示获取锁失败，失败的就需要进入CLH队列，并且挂起线程。</p>
<p>举一个例子，一个简单的闭锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class OneShotLatch &#123;</span><br><span class="line">    private final Sync sync = new Sync();</span><br><span class="line"> </span><br><span class="line">    public void signal() &#123;</span><br><span class="line">        sync.releaseShared(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void await() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(0);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        protected int tryAcquireShared(int ignored) &#123;</span><br><span class="line">            // Succeed if latch is open (state == 1), else fail</span><br><span class="line">            return (getState() == 1) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        protected boolean tryReleaseShared(int ignored) &#123;</span><br><span class="line">            setState(1); // Latch is now open</span><br><span class="line">            return true; // Other threads may now be able to acquire</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是自己实现的一个Mutex。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Lock free的互斥锁，简单实现，不可重入锁</span><br><span class="line"> */</span><br><span class="line">public class Mutex implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private static final int FREE = 0;</span><br><span class="line">    private static final int BUSY = 1;</span><br><span class="line"></span><br><span class="line">    private static class LockSync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID = 4689388770786922019L;</span><br><span class="line"></span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() == BUSY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return compareAndSetState(FREE, BUSY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected boolean tryRelease(int releases) &#123;</span><br><span class="line">            if (getState() == FREE) &#123;</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setState(FREE);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Condition newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final LockSync sync = new LockSync();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isLocked() &#123;</span><br><span class="line">        return sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasQueuedThreads() &#123;</span><br><span class="line">        return sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-6-J-U-C同步器勒种的AQS"><a href="#14-6-J-U-C同步器勒种的AQS" class="headerlink" title="14.6 J.U.C同步器勒种的AQS"></a>14.6 J.U.C同步器勒种的AQS</h3><ul>
<li>ReentrantLock</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int ignored) &#123;</span><br><span class="line"> final Thread current = Thread.currentThread();</span><br><span class="line"> int c = getState();</span><br><span class="line"> if (c == 0) &#123;</span><br><span class="line"> if (compareAndSetState(0, 1)) &#123;</span><br><span class="line"> owner = current;</span><br><span class="line"> return true;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; else if (current == owner) &#123;</span><br><span class="line"> setState(c+1);</span><br><span class="line"> return true;</span><br><span class="line"> &#125;</span><br><span class="line"> return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Semaphore和CountDownLatch</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line"> while (true) &#123;</span><br><span class="line"> int available = getState();</span><br><span class="line"> int remaining = available - acquires;</span><br><span class="line"> if (remaining &lt; 0</span><br><span class="line"> || compareAndSetState(available, remaining))</span><br><span class="line"> return remaining;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line"> while (true) &#123;</span><br><span class="line"> int p = getState();</span><br><span class="line"> if (compareAndSetState(p, p + releases))</span><br><span class="line"> return true;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第15章-原子遍历与非阻塞同步机制Atomic-Variables-and-Non-blocking-Synchronization"><a href="#第15章-原子遍历与非阻塞同步机制Atomic-Variables-and-Non-blocking-Synchronization" class="headerlink" title="第15章 原子遍历与非阻塞同步机制Atomic Variables and Non-blocking Synchronization"></a>第15章 原子遍历与非阻塞同步机制Atomic Variables and Non-blocking Synchronization</h2><p>近年来，在并发算法领域的大多数研究都侧重于非阻塞算法，这种算法用底层的原子机器指令来代替锁来确保数据在并发访问中的一致性，非阻塞算法被广泛应用于OS和JVM中实现线程/进程调度机制和GC以及锁，并发数据结构中。</p>
<p>与锁的方案相比，非阻塞算法都要复杂的多，他们在可伸缩性和活跃性上（避免死锁）都有巨大的优势。</p>
<p>非阻塞算法，顾名思义，多个线程竞争相同的数据时不会发生阻塞，因此他能在粒度更细的层次上进行协调，而且极大的减少调度开销。</p>
<h3 id="15-1-锁的劣势"><a href="#15-1-锁的劣势" class="headerlink" title="15.1 锁的劣势"></a>15.1 锁的劣势</h3><p>独占，可见性是锁要保证的。</p>
<p>许多JVM都对非竞争的锁获取和释放做了很多优化，性能很不错了。但是如果一些线程被挂起然后稍后恢复运行，当线程恢复后还得等待其他线程执行完他们的时间片，才能被调度，所以挂起和恢复线程存在很大的开销，其实很多锁的力度很小的，很简单，如果锁上存在着激烈的竞争，那么多调度开销/工作开销比值就会非常高。</p>
<p>与锁相比volatile是一种更轻量的同步机制，因为使用volatile不会发生上下文切换或者线程调度操作，但是volatile的指明问题就是虽然保证了可见性，但是原子性无法保证，比如i++的字节码就是N行。</p>
<p>锁的其他缺点还包括，如果一个线程正在等待锁，它不能做任何事情，如果一个线程在持有锁的情况下呗延迟执行了，例如发生了缺页错误，调度延迟，那么就没法执行。如果被阻塞的线程优先级较高，那么就会出现priority invesion的问题，被永久的阻塞下去。</p>
<h3 id="15-2-硬件对并发的支持"><a href="#15-2-硬件对并发的支持" class="headerlink" title="15.2 硬件对并发的支持"></a>15.2 硬件对并发的支持</h3><p>独占锁是悲观所，对于细粒度的操作，更高效的应用是乐观锁，这种方法需要借助<strong>冲突监测机制来判断更新过程中是否存在来自其他线程的干扰，如果存在则失败重试</strong>。</p>
<p>几乎所有的现代CPU都有某种形式的原子读-改-写指令，例如compare-and-swap等，JVM就是使用这些指令来实现无锁并发。</p>
<h4 id="15-2-1-比较并交换"><a href="#15-2-1-比较并交换" class="headerlink" title="15.2.1 比较并交换"></a>15.2.1 比较并交换</h4><p>CAS（Compare and set）乐观的技术。Java实现的一个compare and set如下，这是一个模拟底层的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SimulatedCAS &#123;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private int value;</span><br><span class="line"> </span><br><span class="line">    public synchronized int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized int compareAndSwap(int expectedValue,</span><br><span class="line">                                           int newValue) &#123;</span><br><span class="line">        int oldValue = value;</span><br><span class="line">        if (oldValue == expectedValue)</span><br><span class="line">            value = newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public synchronized boolean compareAndSet(int expectedValue,</span><br><span class="line">                                              int newValue) &#123;</span><br><span class="line">        return (expectedValue</span><br><span class="line">                == compareAndSwap(expectedValue, newValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-2-2-非阻塞的计数器"><a href="#15-2-2-非阻塞的计数器" class="headerlink" title="15.2.2 非阻塞的计数器"></a>15.2.2 非阻塞的计数器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CasCounter &#123;</span><br><span class="line">    private SimulatedCAS value;</span><br><span class="line"> </span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int increment() &#123;</span><br><span class="line">        int v;</span><br><span class="line">        do &#123;</span><br><span class="line">            v = value.get();</span><br><span class="line">        &#125; while (v != value.compareAndSwap(v, v + 1));</span><br><span class="line">        return v + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java中使用AtomicInteger。</p>
<p>首先在竞争激烈一般时候，CAS性能远超过第三章基于锁的计数器。看起来他的指令更多，但是无需上下文切换和线程挂起，JVM内部的代码路径实际很长，所以反而好些。但是激烈程度比较高的时候，它的开销还是比较大，但是你会发生这种激烈程度非常高的情况只是理论，实际生产环境很难遇到。况且JIT很聪明，这种操作往往能非常大的优化。</p>
<p>为了确保正常更新，可能得将CAS操作放到for循环里，从语法结构上来看，使用<strong>CAS</strong>比使用锁更加复杂，得考虑失败的情况（锁会挂起线程，直到恢复）；但是基于<strong>CAS</strong>的原子操作，在性能上基本超过了基于锁的计数器，即使只有很小的竞争或者不存在竞争！</p>
<p>在轻度到中度的争用情况下，非阻塞算法的性能会超越阻塞算法，因为 CAS 的多数时间都在第一次尝试时就成功，而发生争用时的开销也不涉及<strong>线程挂起</strong>和<strong>上下文切换</strong>，只多了几个循环迭代。没有争用的 CAS 要比没有争用的锁便宜得多（这句话肯定是真的，因为没有争用的锁涉及 CAS 加上额外的处理，加锁至少需要一个CAS，在有竞争的情况下，需要操作队列，线程挂起，上下文切换），而争用的 CAS 比争用的锁获取涉及更短的延迟。</p>
<p>CAS的缺点是它使用调用者来处理竞争问题，通过重试、回退、放弃，而锁能自动处理竞争问题，例如阻塞。</p>
<p>原子变量可以看做更好的volatile类型变量。</p>
<p>AtomicInteger在JDK8里面做了改动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK7里面的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">       for(;;) &#123;</span><br><span class="line">           intcurrent= get();</span><br><span class="line">           intnext=current+delta;</span><br><span class="line">           if(compareAndSet(current,next))</span><br><span class="line">               returncurrent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Unsafe是经过特殊处理的，不能理解成常规的java代码，区别在于：</p>
<ul>
<li>1.8在调用getAndAddInt的时候，如果系统底层支持fetch-and-add，那么它执行的就是native方法，使用的是fetch-and-add；</li>
</ul>
<ul>
<li>如果不支持，就按照上面的所看到的getAndAddInt方法体那样，以java代码的方式去执行，使用的是compare-and-swap；</li>
</ul>
<p>这也正好跟openjdk8中Unsafe::getAndAddInt上方的注释相吻合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// The following contain CAS-based Java implementations used on</span><br><span class="line">// platforms not supporting native instructions</span><br></pre></td></tr></table></figure>
<h3 id="15-3-原子变量类"><a href="#15-3-原子变量类" class="headerlink" title="15.3 原子变量类"></a>15.3 原子变量类</h3><p>J.U.C的AtomicXXX</p>
<p>例如一个AtomictReference的使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class CasNumberRange &#123;</span><br><span class="line">    @Immutable</span><br><span class="line">            private static class IntPair &#123;</span><br><span class="line">        // INVARIANT: lower &lt;= upper</span><br><span class="line">        final int lower;</span><br><span class="line">        final int upper;</span><br><span class="line"> </span><br><span class="line">        public IntPair(int lower, int upper) &#123;</span><br><span class="line">            this.lower = lower;</span><br><span class="line">            this.upper = upper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private final AtomicReference&lt;IntPair&gt; values =</span><br><span class="line">            new AtomicReference&lt;IntPair&gt;(new IntPair(0, 0));</span><br><span class="line"> </span><br><span class="line">    public int getLower() &#123;</span><br><span class="line">        return values.get().lower;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getUpper() &#123;</span><br><span class="line">        return values.get().upper;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setLower(int i) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            IntPair oldv = values.get();</span><br><span class="line">            if (i &gt; oldv.upper)</span><br><span class="line">                throw new IllegalArgumentException(&quot;Can&apos;t set lower to &quot; + i + &quot; &gt; upper&quot;);</span><br><span class="line">            IntPair newv = new IntPair(i, oldv.upper);</span><br><span class="line">            if (values.compareAndSet(oldv, newv))</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setUpper(int i) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            IntPair oldv = values.get();</span><br><span class="line">            if (i &lt; oldv.lower)</span><br><span class="line">                throw new IllegalArgumentException(&quot;Can&apos;t set upper to &quot; + i + &quot; &lt; lower&quot;);</span><br><span class="line">            IntPair newv = new IntPair(oldv.lower, i);</span><br><span class="line">            if (values.compareAndSet(oldv, newv))</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-3-2-性能比较：锁与原子变量"><a href="#15-3-2-性能比较：锁与原子变量" class="headerlink" title="15.3.2 性能比较：锁与原子变量"></a>15.3.2 性能比较：锁与原子变量</h4><p>略</p>
<h3 id="15-4-非阻塞算法"><a href="#15-4-非阻塞算法" class="headerlink" title="15.4 非阻塞算法"></a>15.4 非阻塞算法</h3><p>Lock-free算法，可以实现栈、队列、优先队列或者散列表。</p>
<h4 id="15-4-非阻塞的栈"><a href="#15-4-非阻塞的栈" class="headerlink" title="15.4 非阻塞的栈"></a>15.4 非阻塞的栈</h4><p>Trebier算法，1986年提出的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> public class ConcurrentStack &lt;E&gt; &#123;</span><br><span class="line">    AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;Node&lt;E&gt;&gt;();</span><br><span class="line"> </span><br><span class="line">    public void push(E item) &#123;</span><br><span class="line">        Node&lt;E&gt; newHead = new Node&lt;E&gt;(item);</span><br><span class="line">        Node&lt;E&gt; oldHead;</span><br><span class="line">        do &#123;</span><br><span class="line">            oldHead = top.get();</span><br><span class="line">            newHead.next = oldHead;</span><br><span class="line">        &#125; while (!top.compareAndSet(oldHead, newHead));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public E pop() &#123;</span><br><span class="line">        Node&lt;E&gt; oldHead;</span><br><span class="line">        Node&lt;E&gt; newHead;</span><br><span class="line">        do &#123;</span><br><span class="line">            oldHead = top.get();</span><br><span class="line">            if (oldHead == null)</span><br><span class="line">                return null;</span><br><span class="line">            newHead = oldHead.next;</span><br><span class="line">        &#125; while (!top.compareAndSet(oldHead, newHead));</span><br><span class="line">        return oldHead.item;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static class Node &lt;E&gt; &#123;</span><br><span class="line">        public final E item;</span><br><span class="line">        public Node&lt;E&gt; next;</span><br><span class="line"> </span><br><span class="line">        public Node(E item) &#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-4-2-非阻塞的链表"><a href="#15-4-2-非阻塞的链表" class="headerlink" title="15.4.2 非阻塞的链表"></a>15.4.2 非阻塞的链表</h4><p>有点复杂哦，实际J.U.C的ConcurrentLinkedQueue也是参考了这个由Michael and Scott，1996年实现的算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedQueue &lt;E&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    private static class Node &lt;E&gt; &#123;</span><br><span class="line">        final E item;</span><br><span class="line">        final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; next;</span><br><span class="line"> </span><br><span class="line">        public Node(E item, LinkedQueue.Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">            this.next = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private final LinkedQueue.Node&lt;E&gt; dummy = new LinkedQueue.Node&lt;E&gt;(null, null);</span><br><span class="line">    private final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; head</span><br><span class="line">            = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);</span><br><span class="line">    private final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; tail</span><br><span class="line">            = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);</span><br><span class="line"> </span><br><span class="line">    public boolean put(E item) &#123;</span><br><span class="line">        LinkedQueue.Node&lt;E&gt; newNode = new LinkedQueue.Node&lt;E&gt;(item, null);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            LinkedQueue.Node&lt;E&gt; curTail = tail.get();</span><br><span class="line">            LinkedQueue.Node&lt;E&gt; tailNext = curTail.next.get();</span><br><span class="line">            if (curTail == tail.get()) &#123;</span><br><span class="line">                if (tailNext != null) &#123;</span><br><span class="line">                    // Queue in intermediate state, advance tail</span><br><span class="line">                    tail.compareAndSet(curTail, tailNext);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // In quiescent state, try inserting new node</span><br><span class="line">                    if (curTail.next.compareAndSet(null, newNode)) &#123;</span><br><span class="line">                        // Insertion succeeded, try advancing tail</span><br><span class="line">                        tail.compareAndSet(curTail, newNode);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-4-3-原子域更新"><a href="#15-4-3-原子域更新" class="headerlink" title="15.4.3 原子域更新"></a>15.4.3 原子域更新</h4><p>AtomicReferenceFieldUpdater,一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(注意这个字段不能是private的) </p>
<p>通过调用AtomicReferenceFieldUpdater的静态方法newUpdater就能创建它的实例，该方法要接收三个参数： </p>
<ul>
<li>包含该字段的对象的类 </li>
<li>将被更新的对象的类 </li>
<li>将被更新的字段的名称 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AtomicReferenceFieldUpdater updater=AtomicReferenceFieldUpdater.newUpdater(Dog.class,String.class,&quot;name&quot;);  </span><br><span class="line">        Dog dog1=new Dog();  </span><br><span class="line">        updater.compareAndSet(dog1,dog1.name,&quot;test&quot;) ;  </span><br><span class="line">        System.out.println(dog1.name);  </span><br><span class="line">  </span><br><span class="line">class Dog  &#123;  </span><br><span class="line">     volatile  String name=&quot;dog1&quot;;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-4-4-ABA问题"><a href="#15-4-4-ABA问题" class="headerlink" title="15.4.4 ABA问题"></a>15.4.4 ABA问题</h4><p>AtomicStampedReference //TODO</p>
<h2 id="第16章-Java内存模型JMM"><a href="#第16章-Java内存模型JMM" class="headerlink" title="第16章 Java内存模型JMM"></a>第16章 Java内存模型JMM</h2><p>前面几章介绍的安全发布、同步策略的规范还有一致性，这些安全性都来自于JMM。</p>
<h3 id="16-1-什么是内存模型，为什么需要它？"><a href="#16-1-什么是内存模型，为什么需要它？" class="headerlink" title="16.1 什么是内存模型，为什么需要它？"></a>16.1 什么是内存模型，为什么需要它？</h3><p>假设</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=3</span><br></pre></td></tr></table></figure>
<p>内存模型要解决的问题是：“在什么条件下，读取a的线程可以看到这个值为3？”</p>
<p>如果缺少同步会有很多因素导致无法立即、甚至永远看不到一个线程的操作结果，包括</p>
<ul>
<li>编译器中指令顺序</li>
<li>变量保存在寄存器而不是内存中</li>
<li>处理器可以乱序或者并行执行指令</li>
<li>缓存可能会改变将写入变量提交到主内存的次序</li>
<li>处理器中也有本地缓存，对其他处理器不可见</li>
</ul>
<p>单线程中，会为了提高速度使用这些技术，但是Java语言规范要求JVM在线程中维护一种类似串行的语义：只要程序的最终结果与在严格环境中的执行结果相同，那么上述操作都是允许的。</p>
<p>随着处理器越来越强大，编译器也在不断的改进，通过指令重排序实现优化执行，使用成熟的全局寄存器分配算法，但是单处理器存在瓶颈，转而变为多核，提高并行性。</p>
<p>在多线程环境中，维护程序的串行性将导致很大的性能开销，并发程序中的线程，大多数时间各自为政，线程之间协调操作只会降低应用程序的运行速度，不会带来任何好处，只有当多个线程要共享数据时，才必须协调他们之间的操作，并且JVM依赖程序通过同步操作找出这些协调操作将何时发生。</p>
<p>JMM规定了JVM必须遵循一组最小的保证，<strong>保证规定了对变量的写入操作在何时将对其他线程可见。</strong>JMM需要在各个处理器体系架构中实现一份。</p>
<h4 id="16-1-1-平台的内存模型"><a href="#16-1-1-平台的内存模型" class="headerlink" title="16.1.1 平台的内存模型"></a>16.1.1 平台的内存模型</h4><p>在共享内存的多处理器体系架构中，每个处理器拥有自己的缓存，并且定期的与主内存进行协调。在不同的处理器架构中提供了不同级别的缓存一致性（cache coherence）。其中一部分只提供最小的保证，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。操作系统、编译器以及runtime需要弥补这种硬件能力与线程安全需求之间的差异。</p>
<p>要确保每个处理器在任意时刻都知道其他处理器在进行的工作，这将开销巨大。多数情况下，这完全没必要，可随意放宽存储一致性，换取性能的提升。存在一些特殊的指令（成为内存栅栏），当需要共享数据时，这些指令就能实现额外的存储协调保证。为了使Java开发人员无须关心不同架构上内存模型之间的差异，产生了JMM，JVM通过在适当的位置上插入内存栅栏来屏蔽JMM与底层平台内存模型之间的差异。</p>
<p>按照程序的顺序执行，这种乐观的串行一致性在任何一款现代多处理器架构中都不会提供这种串行一致性。当跨线程共享数据时，会出现一些奇怪的情况，除非通过使用内存栅栏来防止这种情况的发生。</p>
<h4 id="16-1-2-重排序"><a href="#16-1-2-重排序" class="headerlink" title="16.1.2 重排序"></a>16.1.2 重排序</h4><p>下面的代码，4中输出都是有可能的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class ReorderingDemo &#123;</span><br><span class="line"></span><br><span class="line">    static int x = 0, y = 0, a = 0, b = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Bag bag = new HashBag();</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            x = y = a = b = 0;</span><br><span class="line">            Thread one = new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    a = 1;</span><br><span class="line">                    x = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread two = new Thread() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    b = 1;</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            one.start();</span><br><span class="line">            two.start();</span><br><span class="line">            one.join();</span><br><span class="line">            two.join();</span><br><span class="line">            bag.add(x + &quot;_&quot; + y);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bag.getCount(&quot;0_1&quot;));</span><br><span class="line">        System.out.println(bag.getCount(&quot;1_0&quot;));</span><br><span class="line">        System.out.println(bag.getCount(&quot;1_1&quot;));</span><br><span class="line">        System.out.println(bag.getCount(&quot;0_0&quot;));</span><br><span class="line">        // 结果是如下的或者其他情况，证明可能发生指令重排序</span><br><span class="line">        //        9999</span><br><span class="line">        //        1</span><br><span class="line">        //        0</span><br><span class="line">        //        0</span><br><span class="line"></span><br><span class="line">        //        9998</span><br><span class="line">        //        2</span><br><span class="line">        //        0</span><br><span class="line">        //        0</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-1-3-Java内存模型简介"><a href="#16-1-3-Java内存模型简介" class="headerlink" title="16.1.3 Java内存模型简介"></a>16.1.3 Java内存模型简介</h4><p>JMM通过各种操作来定义，包括对变量的读写操作，监视器monitor的加锁和释放操作，以及线程的启动和合并操作，JMM为程序中所有的操作定义了一个偏序关系，成为Happens-before，要想保证执行操作B的线程看到A的结果，那么A和B之间必须满足Happens-before关系。如果没有这个关系，JVM可以任意的重排序。</p>
<p><strong>JVM来定义了JMM（Java内存模型）来屏蔽底层平台不同带来的各种同步问题，使得程序员面向JAVA平台预期的结果都是一致的，对于“共享的内存对象的访问保证因果性正是JMM存在的理由”（这句话说的太好了！！！）。</strong></p>
<p>因为没法枚举各种情况，所以提供工具辅助程序员自定义，另外一些就是JMM提供的通用原则，叫做happens-before原则，就是如果动作B要看到动作A的执行结果（无论A/B是否在同一个线程里面执行），那么A/B就需要满足happens-before关系。下面是所有的规则，满足这些规则是一种特殊的处理措施，否则就按照上面背景提到的对于可见性、顺序性是没有保障的，会出现“意外”的情况。</p>
<p>如果多线程写入遍历，没有happens-before来排序，那么会产生race condition。在正确使用同步的的程序中，不存在数据竞争，会表现出串行一致性。</p>
<ul>
<li>（1）同一个线程中的每个Action都happens-before于出现在其后的任何一个Action。//控制流，而非语句</li>
<li>（2）对一个监视器的解锁happens-before于每一个后续对同一个监视器的加锁。//lock、unlock</li>
<li>（3）对volatile字段的写入操作happens-before于每一个后续的同一个字段的读操作。</li>
<li>（4）Thread.start()的调用会happens-before于启动线程里面的动作。</li>
<li>（5）Thread中的所有动作都happens-before于其他线程检查到此线程结束或者Thread.join（）中返回或者Thread.isAlive()==false。</li>
<li>（6）一个线程A调用另一个另一个线程B的interrupt（）都happens-before于线程A发现B被A中断（B抛出异常或者A检测到B的isInterrupted（）或者interrupted()）。</li>
<li>（7）一个对象构造函数的结束happens-before与该对象的finalizer的开始</li>
<li>（8）如果A动作happens-before于B动作，而B动作happens-before与C动作，那么A动作happens-before于C动作。</li>
</ul>
<h4 id="16-1-4-借助同步"><a href="#16-1-4-借助同步" class="headerlink" title="16.1.4 借助同步"></a>16.1.4 借助同步</h4><p>piggyback（借助）现有的同步机制可见性。例如在AQS中借助一个volatile的state变量保证happens-before进行排序。</p>
<p>举例：Inner class of FutureTask illustrating synchronization piggybacking. (See JDK source)</p>
<p>还可以记住CountDownLatch，Semaphore，Future，CyclicBarrier等完成自己的希望。</p>
<h3 id="16-2-发布"><a href="#16-2-发布" class="headerlink" title="16.2 发布"></a>16.2 发布</h3><p>第三章介绍了如何安全的或者不正确的发布一个对象，其中介绍的各种技术都依赖JMM的保证，而造成发布不正确的原因就是</p>
<ul>
<li>发布一个共享对象</li>
<li>另外一个线程访问该对象</li>
</ul>
<p>之间缺少一种happens-before关系。</p>
<h4 id="16-2-1-不安全的发布"><a href="#16-2-1-不安全的发布" class="headerlink" title="16.2.1 不安全的发布"></a>16.2.1 不安全的发布</h4><p>缺少happens-before就会发生重排序，会造成发布一个引用的时候，和内部各个field初始化重排序，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">init field a</span><br><span class="line">init field b</span><br><span class="line">发布ref</span><br><span class="line">init field c</span><br></pre></td></tr></table></figure>
<p>这时候从使用这角度就会看到一个被部分构造的对象。</p>
<p>错误的延迟初始化将导致不正确的发布，如下代码。这段代码不光有race condition、创建低效等问题还存储在另外一个线程会看到部分构造的Resource实例引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class UnsafeLazyInitialization &#123;</span><br><span class="line">    private static Resource resource;</span><br><span class="line"> </span><br><span class="line">    public static Resource getInstance() &#123;</span><br><span class="line">        if (resource == null)</span><br><span class="line">            resource = new Resource(); // unsafe publication</span><br><span class="line">        return resource;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class Resource &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，除非使用final，或者发布操作线程在使用线程开始之前执行，这些都满足了happens-before原则。</p>
<h4 id="16-2-2-安全的发布"><a href="#16-2-2-安全的发布" class="headerlink" title="16.2.2 安全的发布"></a>16.2.2 安全的发布</h4><p>使用第三章的各种技术可以安全发布对象，去报发布对象的操作在使用对象的线程开始使用对象的引用之前执行。如果A将X放入BlockingQueue，B从队列中获取X，那么B看到的X与A放入的X相同，实际上由于使用了锁保护，实际B能看到A移交X之前所有的操作。</p>
<h4 id="16-2-3-安全的初始化模式"><a href="#16-2-3-安全的初始化模式" class="headerlink" title="16.2.3 安全的初始化模式"></a>16.2.3 安全的初始化模式</h4><p>有时候需要延迟初始化，最简单的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SafeLazyInitialization &#123;</span><br><span class="line">    private static Resource resource;</span><br><span class="line"> </span><br><span class="line">    public synchronized static Resource getInstance() &#123;</span><br><span class="line">        if (resource == null)</span><br><span class="line">            resource = new Resource();</span><br><span class="line">        return resource;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class Resource &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果getInstance调用不频繁，这绝对是最佳的。</p>
<p>在初始化中使用static会提供额外的线程安全保证。静态初始化是由JVM在类的初始化阶段执行，并且在类被加载后，在线程使用前的。静态初始化期间，内存写入操作将自动对所有线程可见。因此静态初始化对象不需要显示的同步。下面的代码叫做eager initialization。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class EagerInitialization &#123;</span><br><span class="line">    private static Resource resource = new Resource();</span><br><span class="line"> </span><br><span class="line">    public static Resource getResource() &#123;</span><br><span class="line">        return resource;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class Resource &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是lazy initialization。JVM推迟ResourceHolder的初始化操作，直到开始使用这个类时才初始化，并且通过一个static来做，不需要额外的同步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class ResourceFactory &#123;</span><br><span class="line">    private static class ResourceHolder &#123;</span><br><span class="line">        public static Resource resource = new Resource();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Resource getResource() &#123;</span><br><span class="line">        return ResourceFactory.ResourceHolder.resource;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class Resource &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-2-4-双重检查加锁CDL"><a href="#16-2-4-双重检查加锁CDL" class="headerlink" title="16.2.4 双重检查加锁CDL"></a>16.2.4 双重检查加锁CDL</h4><p>DCL实际是一种糟糕的方式，是一种anti-pattern，它只在JAVA1.4时代好用，因为早期同步的性能开销较大，但是现在这都不是事了，已经不建议使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class DoubleCheckedLocking &#123;</span><br><span class="line">    private static Resource resource;</span><br><span class="line"> </span><br><span class="line">    public static Resource getInstance() &#123;</span><br><span class="line">        if (resource == null) &#123;</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123;</span><br><span class="line">                if (resource == null)</span><br><span class="line">                    resource = new Resource();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return resource;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class Resource &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化instance变量的伪代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();   //1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br><span class="line">instance = memory;     //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure>
<p>之所以会发生上面我说的这种状况，是因为在一些编译器上存在指令排序，初始化过程可能被重排成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();   //1：分配对象的内存空间</span><br><span class="line">instance = memory;     //3：设置instance指向刚分配的内存地址</span><br><span class="line">                       //注意，此时对象还没有被初始化！</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br></pre></td></tr></table></figure>
<p>而volatile存在的意义就在于禁止这种重排！解决办法是声明为volatile类型。这样就可以用DCL了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@NotThreadSafe</span><br><span class="line">public class DoubleCheckedLocking &#123;</span><br><span class="line">    private static volatile Resource resource;</span><br><span class="line"> </span><br><span class="line">    public static Resource getInstance() &#123;</span><br><span class="line">        if (resource == null) &#123;</span><br><span class="line">            synchronized (DoubleCheckedLocking.class) &#123;</span><br><span class="line">                if (resource == null)</span><br><span class="line">                    resource = new Resource();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return resource;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    static class Resource &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-初始化过程中的安全性"><a href="#16-3-初始化过程中的安全性" class="headerlink" title="16.3 初始化过程中的安全性"></a>16.3 初始化过程中的安全性</h3><p>final不会被重排序。</p>
<p>下面的states因为是final的所以可以被安全的发布。即使没有volatile，没有锁。但是，如果除了构造函数外其他方法也能修改states。如果类中还有其他非final域，那么其他线程仍然可能看到这些域上不正确的值。也导致了构造过程中的escape。</p>
<p>写final的重排规则：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。也就是说：写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。</li>
</ul>
<p>读final的重排规则：</p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。也就是说：读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</li>
</ul>
<p>如果final域是引用类型，那么增加如下约束：</p>
<ul>
<li>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。（个人觉得基本意思也就是确保在构造函数外把这个被构造对象的引用赋值给一个引用变量之前，final域已经完全初始化并且赋值给了当前构造对象的成员域，至于初始化和赋值这两个操作则不确保先后顺序。）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@ThreadSafe</span><br><span class="line">public class SafeStates &#123;</span><br><span class="line">    private final Map&lt;String, String&gt; states;</span><br><span class="line"> </span><br><span class="line">    public SafeStates() &#123;</span><br><span class="line">        states = new HashMap&lt;String, String&gt;();</span><br><span class="line">        states.put(&quot;alaska&quot;, &quot;AK&quot;);</span><br><span class="line">        states.put(&quot;alabama&quot;, &quot;AL&quot;);</span><br><span class="line">        /*...*/</span><br><span class="line">        states.put(&quot;wyoming&quot;, &quot;WY&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getAbbreviation(String s) &#123;</span><br><span class="line">        return states.get(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考:<br><a href="https://github.com/neoremind/coddding/blob/master/codding/src/main/java/net/neoremind/mycode/concurrent/JAVA_CONCURRENCY_IN_PRACTICE_NOTES.md" target="_blank" rel="noopener">https://github.com/neoremind/coddding/blob/master/codding/src/main/java/net/neoremind/mycode/concurrent/JAVA_CONCURRENCY_IN_PRACTICE_NOTES.md</a><br><a href="http://zhouchaofei2010.iteye.com/category/346380" target="_blank" rel="noopener">http://zhouchaofei2010.iteye.com/category/346380</a><br><a href="https://www.jianshu.com/p/a584d83d8d81" target="_blank" rel="noopener">https://www.jianshu.com/p/a584d83d8d81</a></p>
</blockquote>

      
    </div>
    
    
    


     
    
      <div>
        
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>

      </div>
    


    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    CloudPai
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://cloudpai.site/2018/03/19/2018-03-20-3/" title="github上的JAVA并发编程实战笔记 参考">http://cloudpai.site/2018/03/19/2018-03-20-3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    




    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
          
            <a href="/tags/并发/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/19/2018-03-19-8/" rel="next" title="java并发编程实战 准备">
                <i class="fa fa-chevron-left"></i> java并发编程实战 准备
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/19/2018-03-19-9/" rel="prev" title="java并发编程实战 笔记一">
                java并发编程实战 笔记一 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>




  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg"
                alt="CloudPai" />
            
              <p class="site-author-name" itemprop="name">CloudPai</p>
              <p class="site-description motion-element" itemprop="description">加油(๑•̀ㅂ•́)و✧加油</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=240 src="//music.163.com/outchain/player?type=0&id=2113726971&auto=0&height=430"></iframe>
</div>
<!-- 459004290 -->




            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudPai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liupai024@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/57965969/doulists/all" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-book"></i>豆瓣</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/cloudPai/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-edit"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dlut.edu.cn/" title="DUT" target="_blank">DUT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bupt.edu.cn/" title="BUPT" target="_blank">BUPT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://campus.alibaba.com/index.htm" title="Alibaba Group" target="_blank">Alibaba Group</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#github上的JAVA并发编程实战笔记"><span class="nav-text">github上的JAVA并发编程实战笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-基础构建模块Building-blocks"><span class="nav-text">第五章 基础构建模块Building blocks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-同步容器类"><span class="nav-text">5.1 同步容器类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-同步容器类的问题"><span class="nav-text">5.1.1 同步容器类的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-迭代器与ConcurrentModificationException"><span class="nav-text">5.1.2 迭代器与ConcurrentModificationException</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-异常迭代器"><span class="nav-text">5.1.3 异常迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-并发容器"><span class="nav-text">5.2 并发容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-阻塞队列和生产者-消费者模式"><span class="nav-text">5.3 阻塞队列和生产者-消费者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4阻塞和中断方法"><span class="nav-text">5.4阻塞和中断方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-同步工具类"><span class="nav-text">5.5 同步工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-闭锁"><span class="nav-text">5.5.1 闭锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-FutureTask"><span class="nav-text">5.5.2 FutureTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-3-信号量"><span class="nav-text">5.5.3 信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-4-栅栏Barrier"><span class="nav-text">5.5.4 栅栏Barrier</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-构建高效的可伸缩的结果缓存"><span class="nav-text">5.6 构建高效的可伸缩的结果缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前五章的小节"><span class="nav-text">前五章的小节</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二部分-结构化并发应用程序"><span class="nav-text">第二部分 结构化并发应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第6章-任务执行"><span class="nav-text">第6章 任务执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-在线程中执行任务"><span class="nav-text">6.1 在线程中执行任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-串行的执行任务"><span class="nav-text">6.1.1 串行的执行任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-显式地为任务创建线程"><span class="nav-text">6.1.2 显式地为任务创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-无限制创建线程的不足"><span class="nav-text">6.1.3 无限制创建线程的不足</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Executor框架"><span class="nav-text">6.2 Executor框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-执行策略"><span class="nav-text">6.2.2 执行策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-线程池"><span class="nav-text">6.2.3 线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-Executor生命周期"><span class="nav-text">6.2.4 Executor生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-延迟任务与周期任务"><span class="nav-text">6.2.5 延迟任务与周期任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-找出可利用的并行性"><span class="nav-text">6.3 找出可利用的并行性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-携带结果的任务Callable和Future"><span class="nav-text">6.3.2 携带结果的任务Callable和Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-示例：使用Future实现页面的渲染器"><span class="nav-text">6.3.3 示例：使用Future实现页面的渲染器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-5-CompletionService-Executor-Meets-BlockingQueue"><span class="nav-text">6.3.5 CompletionService: Executor Meets BlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-6-示例：使用CompletionService提高渲染性能"><span class="nav-text">6.3.6 示例：使用CompletionService提高渲染性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-7-为任务设置时限"><span class="nav-text">6.3.7 为任务设置时限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-8-批量提交任务"><span class="nav-text">6.3.8 批量提交任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第7章-取消与关闭"><span class="nav-text">第7章 取消与关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-任务取消"><span class="nav-text">7.1 任务取消</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-中断"><span class="nav-text">7.1.1 中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-中断策略"><span class="nav-text">7.1.2 中断策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3-响应中断"><span class="nav-text">7.1.3 响应中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-6-处理不可中断的阻塞"><span class="nav-text">7.1.6 处理不可中断的阻塞</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-停止基于线程的服务"><span class="nav-text">7.2 停止基于线程的服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-示例：日志服务"><span class="nav-text">7.2.1 示例：日志服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-关闭ExecutorService"><span class="nav-text">7.2.2 关闭ExecutorService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-Poison-Pill"><span class="nav-text">7.2.3 Poison Pill</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-处理非正常的线程终止"><span class="nav-text">7.3 处理非正常的线程终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-JVM关闭"><span class="nav-text">7.4 JVM关闭</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章-线程池的使用"><span class="nav-text">第8章 线程池的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-在任务和执行策略之间隐形耦合"><span class="nav-text">8.1 在任务和执行策略之间隐形耦合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-设置线程池大小"><span class="nav-text">8.2 设置线程池大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-配置ThreadPoolExecutor"><span class="nav-text">8.3 配置ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-扩展ThreadPoolExecutor"><span class="nav-text">8.4 扩展ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-递归算法的并行化"><span class="nav-text">8.5 递归算法的并行化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第9章-图形用户界面应用程序"><span class="nav-text">第9章 图形用户界面应用程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三部分-Liveness-Performance-and-Testing"><span class="nav-text">第三部分 Liveness, Performance, and Testing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第10章-避免活跃性危险"><span class="nav-text">第10章 避免活跃性危险</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-死锁"><span class="nav-text">10.1 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-1-Lock-ordering-Deadlocks"><span class="nav-text">10.1.1 Lock ordering Deadlocks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-1-Dynamic-Lock-Order-Deadlocks"><span class="nav-text">10.1.1 Dynamic Lock Order Deadlocks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-3-在协作对象之间发生死锁Deadlocks-Between-Cooperating-Objects"><span class="nav-text">10.1.3 在协作对象之间发生死锁Deadlocks Between Cooperating Objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-4-开放调用"><span class="nav-text">10.1.4 开放调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-0-15-资源死锁"><span class="nav-text">1.0.15 资源死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-死锁的避免与诊断"><span class="nav-text">10.2 死锁的避免与诊断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-1-支持定时的锁"><span class="nav-text">10.2.1 支持定时的锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-2-kill-3-发信号给JVM-dump线程"><span class="nav-text">10.2.2 kill -3 发信号给JVM dump线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-其他活跃性危险"><span class="nav-text">10.3 其他活跃性危险</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-1-饥饿"><span class="nav-text">10.3.1 饥饿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-3-活锁Livelock"><span class="nav-text">10.3.3 活锁Livelock</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第11章-性能与可伸缩性Performance-and-Scalability"><span class="nav-text">第11章 性能与可伸缩性Performance and Scalability</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-对性能的思考"><span class="nav-text">11.1 对性能的思考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-Amdahl定律-Amdahl’s-Law"><span class="nav-text">11.2 Amdahl定律 Amdahl’s Law</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-线程引入的开销"><span class="nav-text">11.3 线程引入的开销</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-1-上下文切换"><span class="nav-text">11.3.1 上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-2-内存同步"><span class="nav-text">11.3.2 内存同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-3-阻塞"><span class="nav-text">11.3.3 阻塞</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-减少锁的竞争"><span class="nav-text">11.4 减少锁的竞争</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-1-缩小锁的范围（快进快出）"><span class="nav-text">11.4.1 缩小锁的范围（快进快出）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-2-减小锁的粒度"><span class="nav-text">11.4.2 减小锁的粒度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-3-锁分段"><span class="nav-text">11.4.3 锁分段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-4-避免热点域hot-field"><span class="nav-text">11.4.4 避免热点域hot field</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-5-一些替代独占锁的方法"><span class="nav-text">11.4.5 一些替代独占锁的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-6-监测CPU的利用率"><span class="nav-text">11.4.6 监测CPU的利用率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-5-示例：比较Map的性能"><span class="nav-text">11.5 示例：比较Map的性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-6-减少上下文切换的开销"><span class="nav-text">11.6 减少上下文切换的开销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第12章-并发程序的测试"><span class="nav-text">第12章 并发程序的测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第13章-显式锁-Explicit-Locks"><span class="nav-text">第13章 显式锁 Explicit Locks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-Lock和ReentrantLock"><span class="nav-text">13.1 Lock和ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-性能考虑因素"><span class="nav-text">13.2 性能考虑因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-公平性"><span class="nav-text">13.3 公平性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-4-在synchronized和ReentrantLock之间进行选择"><span class="nav-text">13.4 在synchronized和ReentrantLock之间进行选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-5-读-写锁"><span class="nav-text">13.5 读-写锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第14章-构建自定义的同步工具-Building-Custom-Synchronizers"><span class="nav-text">第14章 构建自定义的同步工具 Building Custom Synchronizers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-状态依赖性的管理-State-Dependence"><span class="nav-text">14.1 状态依赖性的管理 State Dependence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-Using-Condition-Queues"><span class="nav-text">14.2 Using Condition Queues</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-1-条件谓词The-Condition-Predicate"><span class="nav-text">14.2.1 条件谓词The Condition Predicate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-2-过早唤醒"><span class="nav-text">14.2.2 过早唤醒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-3-丢失的信号"><span class="nav-text">14.2.3 丢失的信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-4-通知"><span class="nav-text">14.2.4 通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-2-5-示例：阀门类A-Gate-Class"><span class="nav-text">14.2.5 示例：阀门类A Gate Class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-Explicit-Condition-Objects"><span class="nav-text">14.3 Explicit Condition Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-Synchronizer剖析"><span class="nav-text">14.4 Synchronizer剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-AbstractQueuedSynchronizer-AQS"><span class="nav-text">14.5 AbstractQueuedSynchronizer (AQS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-J-U-C同步器勒种的AQS"><span class="nav-text">14.6 J.U.C同步器勒种的AQS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第15章-原子遍历与非阻塞同步机制Atomic-Variables-and-Non-blocking-Synchronization"><span class="nav-text">第15章 原子遍历与非阻塞同步机制Atomic Variables and Non-blocking Synchronization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-锁的劣势"><span class="nav-text">15.1 锁的劣势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-硬件对并发的支持"><span class="nav-text">15.2 硬件对并发的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-2-1-比较并交换"><span class="nav-text">15.2.1 比较并交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-2-2-非阻塞的计数器"><span class="nav-text">15.2.2 非阻塞的计数器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3-原子变量类"><span class="nav-text">15.3 原子变量类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-3-2-性能比较：锁与原子变量"><span class="nav-text">15.3.2 性能比较：锁与原子变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-非阻塞算法"><span class="nav-text">15.4 非阻塞算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-非阻塞的栈"><span class="nav-text">15.4 非阻塞的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-2-非阻塞的链表"><span class="nav-text">15.4.2 非阻塞的链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-3-原子域更新"><span class="nav-text">15.4.3 原子域更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-4-4-ABA问题"><span class="nav-text">15.4.4 ABA问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第16章-Java内存模型JMM"><span class="nav-text">第16章 Java内存模型JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1-什么是内存模型，为什么需要它？"><span class="nav-text">16.1 什么是内存模型，为什么需要它？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#16-1-1-平台的内存模型"><span class="nav-text">16.1.1 平台的内存模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-1-2-重排序"><span class="nav-text">16.1.2 重排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-1-3-Java内存模型简介"><span class="nav-text">16.1.3 Java内存模型简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-1-4-借助同步"><span class="nav-text">16.1.4 借助同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-发布"><span class="nav-text">16.2 发布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#16-2-1-不安全的发布"><span class="nav-text">16.2.1 不安全的发布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-2-2-安全的发布"><span class="nav-text">16.2.2 安全的发布</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-2-3-安全的初始化模式"><span class="nav-text">16.2.3 安全的初始化模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-2-4-双重检查加锁CDL"><span class="nav-text">16.2.4 双重检查加锁CDL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3-初始化过程中的安全性"><span class="nav-text">16.3 初始化过程中的安全性</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CloudPai</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">317.1k</span>
  
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">  </span>
</span>
</div>







  <div class="theme-info">&#12288;主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://cloudpai.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://cloudpai.site/2018/03/19/2018-03-20-3/';
          this.page.identifier = '2018/03/19/2018-03-20-3/';
          this.page.title = 'github上的JAVA并发编程实战笔记 参考';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://cloudpai.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!-- <!-- <script src="https://cdn.bootcss.com/aplayer/1.6.0/APlayer.min.js"></script>

<script src="https://api.i-meto.com/music/player.js"></script> --> -->
  
  <!--移动端判断，是否引入背景-->
  <script>
  var browser={  
      versions:function(){   
             var u = navigator.userAgent, app = navigator.appVersion;   
             return {//移动终端浏览器版本信息
                  trident: u.indexOf('Trident') > -1, //IE内核
                  presto: u.indexOf('Presto') > -1, //opera内核
                  webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                  gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                  mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                  ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                  android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                  iPhone: u.indexOf('iPhone') > -1 , //是否为iPhone或者QQHD浏览器
                  iPad: u.indexOf('iPad') > -1, //是否iPad
                  webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
              };  
           }(),  
           language:(navigator.browserLanguage || navigator.language).toLowerCase()  
  }   
    if(browser.versions.mobile || browser.versions.ios || browser.versions.android ||   
      browser.versions.iPhone || browser.versions.iPad){        
               
    }else{
    document.write("<script type=\'text/javascript\'  src=\'/js/src/particle.js\'><\/script>");
    }
  </script>

  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>
</html>
