<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="nginx," />





  <link rel="alternate" href="/atom.xml" title="CloudPai" type="application/atom+xml" />






<meta name="description" content="1 反向代理1.1 概念反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 举个例子，比如我想访问 http://www.test.com/readme，但www.test.com上并不存在 readme">
<meta name="keywords" content="nginx">
<meta property="og:type" content="article">
<meta property="og:title" content="nginx理论">
<meta property="og:url" content="http://cloudpai.site/2018/03/29/2018-03-29-3/index.html">
<meta property="og:site_name" content="CloudPai">
<meta property="og:description" content="1 反向代理1.1 概念反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 举个例子，比如我想访问 http://www.test.com/readme，但www.test.com上并不存在 readme">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-2cede76e2384c39f.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-90603b54f3e3e521.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-c9dfe26ee351020e.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-7fab22104f710d74.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-b1413f8b819b7d44.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-d87387daf7a20f64.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-214f029b0fb1d28c.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-37be7bcb761b327a.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6807865-aefcf693d5c431f0.png">
<meta property="og:updated_time" content="2018-03-31T07:34:58.666Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nginx理论">
<meta name="twitter:description" content="1 反向代理1.1 概念反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 举个例子，比如我想访问 http://www.test.com/readme，但www.test.com上并不存在 readme">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/6807865-2cede76e2384c39f.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'TZAS2SFOJR',
      apiKey: 'e2a9cd036eede8026382b302001ec261',
      indexName: 'cloudpai_blogs_search',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cloudpai.site/2018/03/29/2018-03-29-3/"/>





  <title>nginx理论 | CloudPai</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-114643720-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CloudPai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间轴
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>




 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cloudpai.site/2018/03/29/2018-03-29-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CloudPai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudPai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">nginx理论</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T22:54:26+08:00">
                2018-03-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-03-31T15:34:58+08:00">
                2018-03-31
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/29/2018-03-29-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/29/2018-03-29-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,237
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="/assets/js/APlayer.min.js"> </script><h1 id="1-反向代理"><a href="#1-反向代理" class="headerlink" title="1 反向代理"></a>1 反向代理</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>举个例子，比如我想访问 <code>http://www.test.com/readme</code>，但<code>www.test.com</code>上并不存在 readme 页面，于是他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。这里所提到的 <code>www.test.com</code> 这个域名对应的服务器就设置了反向代理功能。</p>
<p><strong>结论就是，反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置</strong>。客户端向反向代理的命名空间 (name-space) 中的内容发送普通请求，接着反向代理服务器将判断向何处 (原始服务器) 转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p>
<p><strong>正向代理，既然有反向代理，就肯定有正向代理。什么叫正向代理呢？</strong></p>
<p>正向代理（Forward Proxy）通常都被简称为代理，就是在用户无法正常访问外部资源，比方说受到 GFW 的影响无法访问 twitter 的时候，我们可以通过代理的方式，让用户绕过防火墙，从而连接到目标网络或者服务。</p>
<p><strong>正向代理的工作原理就像一个跳板</strong>，比如：我访问不了 google.com，但是我能访问一个代理服务器 A，A 能访问 google.com，于是我先连上代理服务器 A，告诉他我需要 google.com 的内容，A 就去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p>
<p><strong>结论就是，正向代理是一个位于客户端和原始服务器 (origin server) 之间的服务器</strong>。为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p><strong>反向代理 VS 正向代理：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6807865-2cede76e2384c39f.png" alt=""> <img src="https://upload-images.jianshu.io/upload_images/6807865-90603b54f3e3e521.png" alt=""></p>
<h2 id="1-2-工作流程"><a href="#1-2-工作流程" class="headerlink" title="1.2 工作流程"></a>1.2 工作流程</h2><ol>
<li><p>用户通过域名发出访问 Web 服务器的请求，该域名被 DNS 服务器解析为反向代理服务器的 IP 地址；</p>
</li>
<li><p>反向代理服务器接受用户的请求；</p>
</li>
<li><p>反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</p>
</li>
<li><p>如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中。</p>
</li>
</ol>
<h2 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h2><ol>
<li><strong>保护了真实的 web 服务器，保证了 web 服务器的资源安全</strong></li>
</ol>
<p>通常的代理服务器，只用于代理内部网络对 Internet 外部网络的连接请求，客户机必须指定代理服务器，并将本来要直接发送到 Web 服务器上的 http 请求发送到代理服务器中。不支持外部网络对内部网络的连接请求，因为内部网络对外部网络是不可见的。<strong>当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务</strong>。此时代理服务器对外就表现为一个 Web 服务器，外部网络就可以简单把它当作一个标准的 Web 服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者 CGI 程序，都保存在内部的 Web 服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了 Web 服务器的安全性。</p>
<ol>
<li><strong>节约了有限的 IP 地址资源</strong></li>
</ol>
<p>企业内所有的网站共享一个在 internet 中注册的 IP 地址，这些服务器分配私有地址，采用<strong>虚拟主机</strong>的方式对外提供服务。</p>
<ol>
<li><strong>减少 WEB 服务器压力，提高响应速度</strong></li>
</ol>
<p>反向代理就是通常所说的 web 服务器加速，它是一种通过在繁忙的 web 服务器和外部网络之间增加一个高速的 web 缓冲服务器来降低实际的 web 服务器的负载的一种技术。反向代理是针对 web 服务器提高加速功能，作为代理缓存，它并不是针对浏览器用户，而针对一台或多台特定的 web 服务器，它可以代理外部网络对内部网络的访问请求。</p>
<p>反向代理服务器会强制将外部网络对要代理的服务器的访问经过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并<strong>把内容保存到本地</strong>，以便日后再收到同样的信息请求时，它会把本地缓存里的内容直接发给用户，以减少后端 web 服务器的压力，提高响应速度。因此 Nginx 还具有<strong>缓存</strong>功能。</p>
<ol>
<li><strong>其他优点</strong></li>
</ol>
<p>（1）请求的统一控制，包括设置权限、过滤规则等；</p>
<p>（2）区分动态和静态可缓存内容；</p>
<p>（3）实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问；</p>
<p>（4）解决 <strong>Ajax 跨域</strong>问题；</p>
<p>（5）作为真实服务器的缓冲，解决瞬间负载量大的问题；</p>
<h1 id="2-Nginx-模块"><a href="#2-Nginx-模块" class="headerlink" title="2 Nginx 模块"></a>2 Nginx 模块</h1><p>Nginx 有五大优点：<strong>模块化、事件驱动、异步、非阻塞、多进程单线程</strong>。由内核和模块组成的，其中内核完成的工作比较简单，仅仅<strong>通过查找配置文件将客户端请求映射到一个 location block，然后又将这个 location block 中所配置的每个指令将会启动不同的模块去完成相应的工作。</strong></p>
<h2 id="2-1-模块划分"><a href="#2-1-模块划分" class="headerlink" title="2.1 模块划分"></a>2.1 模块划分</h2><p><strong>Nginx 的模块从结构上分为核心模块、基础模块和第三方模块：</strong></p>
<blockquote>
<p><strong>核心模块：</strong>HTTP 模块、EVENT 模块和 MAIL 模块</p>
<p><strong>基础模块：</strong>HTTP Access 模块、HTTP FastCGI 模块、HTTP Proxy 模块和 HTTP Rewrite 模块，</p>
<p><strong>第三方模块：</strong>HTTP Upstream Request Hash 模块、Notice 模块和 HTTP Access Key 模块。</p>
</blockquote>
<p><strong>Nginx 的模块从功能上分为如下四类：</strong></p>
<blockquote>
<p><strong>Core(核心模块)：</strong>构建 nginx 基础服务、管理其他模块。</p>
<p><strong>Handlers（处理器模块）：</strong>此类模块直接处理请求，并进行输出内容和修改 headers 信息等操作。</p>
<p><strong>Filters （过滤器模块）：</strong>此类模块主要对其他处理器模块输出的内容进行修改操作，最后由 Nginx 输出。</p>
<p><strong>Proxies （代理类模块）：</strong>此类模块是 Nginx 的 HTTP Upstream 之类的模块，这些模块主要与后端一些服务比如 FastCGI 等进行交互，实现服务代理和负载均衡等功能。</p>
</blockquote>
<p><strong>Nginx 的核心模块主要负责建立 nginx 服务模型、管理网络层和应用层协议、以及启动针对特定应用的一系列候选模块。其他模块负责分配给 web 服务器的实际工作：</strong></p>
<blockquote>
<p>(1) 当 Nginx 发送文件或者转发请求到其他服务器，由 Handlers(处理模块) 或 Proxies（代理类模块）提供服务；</p>
<p>(2) 当需要 Nginx 把输出压缩或者在服务端加一些东西，由 Filters(过滤模块) 提供服务。</p>
</blockquote>
<h2 id="2-2-模块处理"><a href="#2-2-模块处理" class="headerlink" title="2.2 模块处理"></a>2.2 模块处理</h2><ol>
<li>当服务器启动，<strong><em><code>每个handlers(处理模块)都有机会映射到配置文件中定义的特定位置（location）</code></em></strong>；如果有多个 handlers(处理模块) 映射到特定位置时，只有一个会 “赢”（说明配置文件有冲突项，应该避免发生）。</li>
</ol>
<p>处理模块以三种形式返回：</p>
<ul>
<li>OK</li>
<li>ERROR</li>
<li>或者放弃处理这个请求而让默认处理模块来处理（主要是用来处理一些静态文件，事实上如果是位置正确而真实的静态文件，默认的处理模块会抢先处理）。</li>
</ul>
<ol>
<li><strong><em><code>如果handlers(处理模块)把请求反向代理到后端的服务器，就变成另外一类的模块：load-balancers（负载均衡模块）</code></em></strong>。负载均衡模块的配置中有一组后端服务器，当一个 HTTP 请求过来时，它决定哪台服务器应当获得这个请求。</li>
</ol>
<p><strong>Nginx 的负载均衡模块采用两种方法：</strong></p>
<blockquote>
<p><strong>轮转法</strong>，它处理请求就像纸牌游戏一样从头到尾分发；</p>
<p><strong>IP 哈希法</strong>，在众多请求的情况下，它确保来自同一个 IP 的请求会分发到相同的后端服务器。</p>
</blockquote>
<ol>
<li><strong><em><code>如果handlers(处理模块)没有产生错误，filters（过滤模块）将被调用</code></em></strong>。多个 filters（过滤模块）能映射到每个位置，所以（比如）每个请求都可以被压缩成块。它们的执行顺序在编译时决定。</li>
</ol>
<p><strong><em><code>filters（过滤模块）是经典的“接力链表（CHAIN OF RESPONSIBILITY）”模型</code></em></strong>：一个 filters（过滤模块）被调用，完成其工作，然后调用下一个 filters（过滤模块），直到最后一个 filters（过滤模块）。</p>
<p><strong>过滤模块链的特别之处在于：</strong></p>
<blockquote>
<p><strong>每个 filters（过滤模块）不会等上一个 filters（过滤模块）全部完成；</strong></p>
<p><strong>它能把前一个过滤模块的输出作为其处理内容；有点像 Unix 中的流水线；</strong></p>
</blockquote>
<p><strong><em><code>过滤模块能以buffer（缓冲区）为单位进行操作，这些buffer一般都是一页（4K）大小，当然你也可以在nginx.conf文件中进行配置</code></em></strong>。这意味着，比如，模块可以压缩来自后端服务器的响应，然后像流一样的到达客户端，直到整个响应发送完成。</p>
<p><strong>总之，过滤模块链以流水线的方式高效率地向客户端发送响应信息。</strong></p>
<ol>
<li><strong>所以总结下上面的内容，一个典型的 HTTP 处理周期是这样的：</strong></li>
</ol>
<blockquote>
<p>客户端发送 HTTP 请求 –&gt;</p>
<p>Nginx 基于配置文件中的位置选择一个合适的处理模块 -&gt;</p>
<p>(如果有) 负载均衡模块选择一台后端服务器 –&gt;</p>
<p>处理模块进行处理并把输出缓冲放到第一个过滤模块上 –&gt;</p>
<p>第一个过滤模块处理后输出给第二个过滤模块 –&gt;</p>
<p>然后第二个过滤模块又到第三个 –&gt;</p>
<p>依此类推 –&gt; 最后把响应发给客户端。</p>
</blockquote>
<p><strong>下图展示了 Nginx 模块处理流程：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6807865-c9dfe26ee351020e.png" alt=""></p>
<p>Nginx 本身做的工作实际很少，当它接到一个 HTTP 请求时，它仅仅是通过查找配置文件将此次请求映射到一个 location block，而此 location 中所配置的各个指令则会启动不同的模块去完成工作，因此<strong>模块可以看做 Nginx 真正的劳动工作者</strong>。<strong><em><code>通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理</code></em></strong>。</p>
<h1 id="3-Nginx-请求处理"><a href="#3-Nginx-请求处理" class="headerlink" title="3 Nginx 请求处理"></a>3 Nginx 请求处理</h1><p>Nginx 在启动时会<strong><em>以 daemon 形式在后台运行</em></strong>，采用<strong><em>多进程 + 异步非阻塞 IO 事件模型</em></strong>来处理各种连接请求。多进程模型包括一个 master 进程，多个 worker 进程，<strong><em>一般 worker 进程个数是根据服务器 CPU 核数来决定的</em></strong>。<strong><em>master 进程负责管理 Nginx 本身和其他 worker 进程</em></strong>。如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6807865-7fab22104f710d74.png" alt=""> <img src="https://upload-images.jianshu.io/upload_images/6807865-b1413f8b819b7d44.png" alt=""></p>
<blockquote>
<p>从上图中可以很明显地看到，4 个 worker 进程的父进程都是 master 进程，表明 worker 进程都是从父进程 fork 出来的，并且父进程的 ppid 为 1，表示其为 daemon 进程。</p>
<p>需要说明的是，在 nginx 多进程中，每个 worker 都是平等的，因此每个进程处理外部请求的机会权重都是一致的。</p>
</blockquote>
<blockquote>
<p><strong>Master 进程的作用是？</strong></p>
<p>读取并验证配置文件 nginx.conf；管理 worker 进程；</p>
<p><strong>Worker 进程的作用是？</strong></p>
<p>每一个 Worker 进程都维护一个线程（避免线程切换），处理连接和请求；注意 Worker 进程的个数由配置文件决定，一般和 CPU 个数相关（有利于进程切换），配置几个就有几个 Worker 进程。</p>
</blockquote>
<blockquote>
<p><strong>Nginx 如何做到热部署？</strong></p>
<p>所谓热部署，就是配置文件 nginx.conf 修改后，不需要 stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载 / nginx -t 检查配置 / nginx -s stop）</p>
<p>通过上文我们已经知道 worker 进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p>
<p>方案一：</p>
<p>修改配置文件 nginx.conf 后，主进程 master 负责推送给 woker 进程更新配置信息，woker 进程收到信息后，更新进程内部的线程信息。</p>
<p>方案二：</p>
<p>修改配置文件 nginx.conf 后，重新生成新的 worker 进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的 worker 进程，至于老的 worker 进程，等把那些以前的请求处理完毕后，kill 掉即可。</p>
<p><strong>Nginx 采用的就是方案二来达到热部署的！</strong></p>
</blockquote>
<blockquote>
<p><strong>Nginx 如何做到高并发下的高效处理？</strong></p>
<p>上文已经提及 Nginx 的 worker 进程个数与 CPU 绑定、worker 进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p>
<p>作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步 / 同步、阻塞 / 非阻塞…</p>
<p>要同时处理那么多的请求，要知道，有的请求需要发生 IO，可能需要很长时间，如果等着它，就会拖慢 worker 的处理速度。</p>
<p>Nginx 采用了 Linux 的 epoll 模型，epoll 模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果 OK，那么放入 epoll 队列中，这个过程是异步的。worker 只需要从 epoll 队列循环处理即可。</p>
</blockquote>
<blockquote>
<p><strong>Nginx 挂了怎么办？</strong></p>
<p>Nginx 既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p>
<p>答案是：Keepalived+Nginx 实现高可用。</p>
<p>Keepalived 是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和 Nginx 配合来实现 Web 服务的高可用。（其实，Keepalived 不仅仅可以和 Nginx 配合，还可以和很多其他服务配合）</p>
<p>Keepalived+Nginx 实现高可用的思路：</p>
<p>第一：请求不要直接打到 Nginx 上，应该先通过 Keepalived（这就是所谓虚拟 IP，VIP）</p>
<p>第二：Keepalived 应该能监控 Nginx 的生命状态（提供一个用户自定义的脚本，定期检查 Nginx 进程状态，进行权重变化,，从而实现 Nginx 故障切换）</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/6807865-d87387daf7a20f64.png" alt=""></p>
<p><strong>Nginx 架构及工作流程图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6807865-214f029b0fb1d28c.png" alt=""></p>
<p>Nginx 真正处理请求业务的是 Worker 之下的线程。<strong>_<code>worker进程中有一个ngx_worker_process_cycle()函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理</code>_</strong>，直到整个 Nginx 服务被停止。</p>
<p><strong>worker 进程中，ngx_worker_process_cycle() 函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下：</strong></p>
<blockquote>
<ol>
<li>操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。</li>
</ol>
<ol>
<li>接收和处理这些事件，如是接收到数据，则产生更高层的 request 对象。</li>
</ol>
<ol>
<li>处理 request 的 header 和 body。</li>
</ol>
<ol>
<li>产生响应，并发送回客户端。</li>
</ol>
<ol>
<li>完成 request 的处理。</li>
</ol>
<ol>
<li>重新初始化定时器及其他事件。</li>
</ol>
</blockquote>
<h2 id="3-1-多进程处理模型"><a href="#3-1-多进程处理模型" class="headerlink" title="3.1 多进程处理模型"></a>3.1 多进程处理模型</h2><p><strong>下面来介绍一个请求进来，多进程模型的处理方式：</strong></p>
<blockquote>
<p>首先，master 进程一开始就会根据我们的配置，<strong><em><code>来建立需要listen的网络socket fd</code></em></strong>，然后 fork 出多个 worker 进程。</p>
<p>其次，根据进程的特性，新建立的 worker 进程，也会和 master 进程一样，具有相同的设置。因此，<strong><em><code>其也会去监听相同ip端口的套接字socket fd</code></em></strong>。</p>
<p>然后，这个时候有多个 worker 进程都在监听同样设置的 socket fd，<strong><em><code>意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的“惊群现象”</code></em></strong>。为了保证只会有一个进程成功注册到 listenfd 的读事件，<strong>_<code>nginx中实现了一个“accept_mutex”类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件</code>_</strong>。其他进程全部 accept 失败。</p>
<p>最后，监听成功的 worker 进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个 request 请求，只需要 worker 进程就可以完成。</p>
</blockquote>
<p>进程模型的处理方式带来的一些好处就是：<strong><em><code>进程之间是独立的</code></em></strong>，也就是一个 worker 进程出现异常退出，其他 worker 进程是不会受到影响的；此外，独立进程也会避免一些不需要的锁操作，这样会提高处理效率，并且开发调试也更容易。</p>
<p>如前文所述，<strong><em><code>多进程模型+异步非阻塞模型</code></em></strong>才是胜出的方案。<strong><em><code>单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题</code></em></strong>；并且还因此<strong><em><code>避免的多线程的上下文切换导致的性能损失。</code></em></strong></p>
<p><strong>worker 进程会竞争监听客户端的连接请求：</strong>这种方式可能会带来一个问题，<strong><em><code>就是可能所有的请求都被一个worker进程给竞争获取了，导致其他进程都比较空闲，而某一个进程会处于忙碌的状态，这种状态可能还会导致无法及时响应连接而丢弃discard掉本有能力处理的请求</code></em></strong>。这种不公平的现象，是需要避免的，尤其是在高可靠 web 服务器环境下。</p>
<p>针对这种现象，Nginx 采用了一个是否打开 accept_mutex 选项的值，<strong>_<code>ngx_accept_disabled标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件</code>_</strong>。</p>
<blockquote>
<p><strong>ngx_accept_disabled 值</strong>：nginx 单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个 ngx_accept_disabled。</p>
<p><strong>当 ngx_accept_disabled 大于 0 时，不会去尝试获取 accept_mutex 锁</strong>，并且将 ngx_accept_disabled 减 1，于是，每次执行到此处时，都会去减 1，直到小于 0。不去获取 accept_mutex 锁，就是等于让出获取连接的机会，很显然可以看出，_<code>当空闲连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大</code>_。不去 accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx 就控制了多进程间连接的平衡了。</p>
</blockquote>
<h2 id="3-2-一个简单的-HTTP-请求"><a href="#3-2-一个简单的-HTTP-请求" class="headerlink" title="3.2 一个简单的 HTTP 请求"></a>3.2 一个简单的 HTTP 请求</h2><p><strong>从 Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段：</strong></p>
<blockquote>
<p>初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。</p>
<p>处理请求头。</p>
<p>处理请求体。</p>
<p>如果有的话，调用与此请求（URL 或者 Location）关联的 handler。</p>
<p>依次调用各 phase handler 进行处理。</p>
</blockquote>
<p>在建立连接过程中，<strong>_<code>对于nginx监听到的每个客户端连接，都会将它的读事件的handler设置为ngx_http_init_request函数，这个函数就是请求处理的入口</code>_</strong>。在处理请求时，主要就是要解析 http 请求，比如：uri，请求行等，然后再根据请求生成响应。下面看一下 nginx 处理的具体过程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6807865-37be7bcb761b327a.png" alt=""></p>
<p>在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。<strong><em><code>所以 phase handlers 也就好理解了，就是包含若干个处理阶段的一些 handler</code></em></strong>。</p>
<p><strong><em><code>在每一个阶段，包含有若干个 handler</code></em></strong>，再处理到某个阶段的时候，依次调用该阶段的 handler 对 HTTP Request 进行处理。</p>
<p>通常情况下，一个 phase handler 对这个 request 进行处理，并产生一些输出。<strong><em><code>通常 phase handler 是与定义在配置文件中的某个 location 相关联的</code></em></strong>。</p>
<p><strong>一个 phase handler 通常执行以下几项任务：</strong></p>
<blockquote>
<p>获取 location 配置。</p>
<p>产生适当的响应。</p>
<p>发送 response header。</p>
<p>发送 response body。</p>
</blockquote>
<p><strong><em><code>当 Nginx 读取到一个 HTTP Request 的 header 的时候，Nginx 首先查找与这个请求关联的虚拟主机的配置</code></em></strong>。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase handlers）：</p>
<blockquote>
<p>NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段</p>
<p>NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段</p>
<p>NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段</p>
<p>NGX_HTTP_REWRITE_PHASE: Location 请求地址重写阶段</p>
<p>NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段</p>
<p>NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段</p>
<p>NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段</p>
<p>NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段</p>
<p>NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段</p>
<p>NGX_HTTP_CONTENT_PHASE: 内容产生阶段</p>
<p>NGX_HTTP_LOG_PHASE: 日志模块处理阶段</p>
</blockquote>
<p>在内容产生阶段，为了给一个 request 产生正确的响应，<strong><em><code>Nginx 必须把这个 request 交给一个合适的 content handler 去处理</code></em></strong>。如果这个 request 对应的 location 在配置文件中被明确指定了一个 content handler，那么 Nginx 就可以通过对 location 的匹配，直接找到这个对应的 handler，并把这个 request 交给这个 content handler 去处理。这样的配置指令包括像，perl，flv，proxy_pass，mp4 等。</p>
<p><strong>如果一个 request 对应的 location 并没有直接有配置的 content handler，那么 Nginx 依次尝试：</strong></p>
<blockquote>
<p>如果一个 location 里面有配置 random_index on，那么随机选择一个文件，发送给客户端。</p>
<p>如果一个 location 里面有配置 index 指令，那么发送 index 指令指明的文件，给客户端。</p>
<p>如果一个 location 里面有配置 autoindex on，那么就发送请求地址对应的服务端路径下的文件列表给客户端。</p>
<p>如果这个 request 对应的 location 上有设置 gzip_static on，那么就查找是否有对应的. gz 文件存在，有的话，就发送这个给客户端（客户端支持 gzip 的情况下）。</p>
<p>请求的 URI 如果对应一个静态文件，static module 就发送静态文件的内容到客户端。</p>
</blockquote>
<p><strong><em><code>内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理</code></em></strong>。filter 模块也是与 location 相关的。所有的 filter 模块都被组织成一条链。输出会依次穿越所有的 filter，直到有一个 filter 模块的返回值表明已经处理完成。</p>
<p><strong>这里列举几个常见的 filter 模块，例如：</strong></p>
<blockquote>
<p>server-side includes。</p>
<p>XSLT filtering。</p>
<p>图像缩放之类的。</p>
<p>gzip 压缩。</p>
</blockquote>
<p><strong>在所有的 filter 中，有几个 filter 模块需要关注一下。按照调用的顺序依次说明如下：</strong></p>
<blockquote>
<p>copy: 将一些需要复制的 buf(文件或者内存) 重新复制一份然后交给剩余的 body filter 处理。</p>
<p>postpone: 这个 filter 是负责 subrequest 的，也就是子请求的。</p>
<p>write: 写输出到客户端，实际上是写到连接对应的 socket 上。</p>
</blockquote>
<h2 id="3-3-请求完整处理过程"><a href="#3-3-请求完整处理过程" class="headerlink" title="3.3 请求完整处理过程"></a>3.3 请求完整处理过程</h2><p><strong>根据以上请求步骤所述，请求完整的处理过程如下图所示：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6807865-aefcf693d5c431f0.png" alt=""></p>
<h2 id="3-4-keepalive-长连接"><a href="#3-4-keepalive-长连接" class="headerlink" title="3.4 keepalive 长连接"></a>3.4 keepalive 长连接</h2><p>当然，在 nginx 中，对于 http1.0 与 http1.1 也是支持长连接的。</p>
<p>什么是长连接呢？我们知道，http 请求是基于 TCP 协议之上的，那么，当客户端在发起请求前，需要先与服务端建立 TCP 连接，而每一次的 TCP 连接是需要三次握手来确定的，如果客户端与服务端之间网络差一点，这三次交互消费的时间会比较多，而且三次交互也会带来网络流量。当然，当连接断开后，也会有四次的交互，当然对用户体验来说就不重要了。而 http 请求是请求应答式的，如果我们能知道每个请求头与响应体的长度，那么我们是可以在一个连接上面执行多个请求的，这就是所谓的长连接，但前提条件是我们先得确定请求头与响应体的长度。</p>
<p>对于请求来说，如果当前请求需要有 body，如 POST 请求，那么 nginx 就需要客户端在请求头中指定 content-length 来表明 body 的大小，否则返回 400 错误。也就是说，请求体的长度是确定的，那么响应体的长度呢？先来看看 http 协议中关于响应 body 长度的确定：</p>
<blockquote>
<p>对于 <strong>http1.0 协议</strong>来说，如果响应头中有 content-length 头，则以 content-length 的长度就可以知道 body 的长度了，客户端在接收 body 时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有 content-length 头，则客户端会一直接收数据，直到服务端主动断开连接，才表示 body 接收完了。</p>
<p>而对于 <strong>http1.1 协议</strong>来说，如果响应头中的 Transfer-encoding 为 chunked 传输，则表示 body 是流式输出，body 会被分成多个块，每块的开始会标识出当前块的长度，此时，body 不需要通过长度来指定。如果是非 chunked 传输，而且有 content-length，则按照 content-length 来接收数据。否则，如果是非 chunked，并且没有 content-length，则客户端接收数据，直到服务端主动断开连接。</p>
</blockquote>
<p>从上面，我们可以看到，除了 http1.0 不带 content-length 以及 http1.1 非 chunked 不带 content-length 外，body 的长度是可知的。此时，当服务端在输出完 body 之后，会可以考虑使用长连接。能否使用长连接，也是有条件限制的。如果客户端的请求头中的 connection 为 close，则表示客户端需要关掉长连接，如果为 keep-alive，则客户端需要打开长连接，如果客户端的请求中没有 connection 这个头，那么根据协议，如果是 http1.0，则默认为 close，如果是 http1.1，则默认为 keep-alive。如果结果为 keepalive，那么，nginx 在输出完响应体后，会设置当前连接的 keepalive 属性，然后等待客户端下一次请求。</p>
<p>当然，nginx 不可能一直等待下去，如果客户端一直不发数据过来，岂不是一直占用这个连接？所以当 nginx 设置了 keepalive 等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项 keepalive_timeout 来配置的，如果配置为 0，则表示关掉 keepalive，此时，http 版本无论是 1.1 还是 1.0，客户端的 connection 不管是 close 还是 keepalive，都会强制为 close。</p>
<p>如果服务端最后的决定是 keepalive 打开，那么在响应的 http 头里面，也会包含有 connection 头域，其值是”Keep-Alive”，否则就是”Close”。如果 connection 值为 close，那么在 nginx 响应完数据后，会主动关掉连接。所以，对于请求量比较大的 nginx 来说，关掉 keepalive 最后会产生比较多的 time-wait 状态的 socket。一般来说，当客户端的一次访问，<strong>需要多次访问同一个 server 时，打开 keepalive 的优势非常大</strong>，<strong>比如图片服务器，通常一个网页会包含很多个图片。打开 keepalive 也会大量减少 time-wait 的数量</strong>。</p>
<p>参考</p>
<p><a href="https://www.jianshu.com/p/bed000e1830b" target="_blank" rel="noopener">WEB 请求处理二：Nginx 请求反向代理</a></p>
<p><a href="https://link.jianshu.com?t=http%3A%2F%2Ftengine.taobao.org%2Fbook%2F" target="_blank" rel="noopener">Nginx 开发从入门到精通</a></p>
<p><a href="https://www.jianshu.com/p/5eab0f83e3b4" target="_blank" rel="noopener">深入浅出 Nginx</a></p>
<hr>
<blockquote>
<p>原理参考：<br>理解Nginx工作原理 - 简书<br><a href="https://www.jianshu.com/p/6215e5d24553" target="_blank" rel="noopener">https://www.jianshu.com/p/6215e5d24553</a><br>Nginx工作原理和优化、漏洞。 - CSDN博客<br><a href="https://blog.csdn.net/hguisu/article/details/8930668" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/8930668</a></p>
</blockquote>

      
    </div>
    
    
    


     
    
      <div>
        
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>

      </div>
    


    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    CloudPai
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://cloudpai.site/2018/03/29/2018-03-29-3/" title="nginx理论">http://cloudpai.site/2018/03/29/2018-03-29-3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    




    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/nginx/" rel="tag"><i class="fa fa-tag"></i> nginx</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/29/2018-03-29-2/" rel="next" title="正则表达式">
                <i class="fa fa-chevron-left"></i> 正则表达式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/30/2018-03-30/" rel="prev" title="nginx 面试 总结">
                nginx 面试 总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>




  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg"
                alt="CloudPai" />
            
              <p class="site-author-name" itemprop="name">CloudPai</p>
              <p class="site-description motion-element" itemprop="description">加油(๑•̀ㅂ•́)و✧加油</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">103</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=240 src="//music.163.com/outchain/player?type=0&id=2113726971&auto=0&height=430"></iframe>
</div>
<!-- 459004290 -->




            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudPai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liupai024@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/57965969/doulists/all" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-book"></i>豆瓣</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/cloudPai/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-edit"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dlut.edu.cn/" title="DUT" target="_blank">DUT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bupt.edu.cn/" title="BUPT" target="_blank">BUPT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://campus.alibaba.com/index.htm" title="Alibaba Group" target="_blank">Alibaba Group</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-反向代理"><span class="nav-text">1 反向代理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-概念"><span class="nav-text">1.1 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-工作流程"><span class="nav-text">1.2 工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-优点"><span class="nav-text">1.3 优点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Nginx-模块"><span class="nav-text">2 Nginx 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-模块划分"><span class="nav-text">2.1 模块划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-模块处理"><span class="nav-text">2.2 模块处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Nginx-请求处理"><span class="nav-text">3 Nginx 请求处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-多进程处理模型"><span class="nav-text">3.1 多进程处理模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-一个简单的-HTTP-请求"><span class="nav-text">3.2 一个简单的 HTTP 请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-请求完整处理过程"><span class="nav-text">3.3 请求完整处理过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-keepalive-长连接"><span class="nav-text">3.4 keepalive 长连接</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CloudPai</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">517.4k</span>
  
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">  </span>
</span>
</div>







  <div class="theme-info">&#12288;主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://cloudpai.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://cloudpai.site/2018/03/29/2018-03-29-3/';
          this.page.identifier = '2018/03/29/2018-03-29-3/';
          this.page.title = 'nginx理论';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://cloudpai.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!-- <!-- <script src="https://cdn.bootcss.com/aplayer/1.6.0/APlayer.min.js"></script>

<script src="https://api.i-meto.com/music/player.js"></script> --> -->
  
  <!--移动端判断，是否引入背景-->
  <script>
  var browser={  
      versions:function(){   
             var u = navigator.userAgent, app = navigator.appVersion;   
             return {//移动终端浏览器版本信息
                  trident: u.indexOf('Trident') > -1, //IE内核
                  presto: u.indexOf('Presto') > -1, //opera内核
                  webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                  gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                  mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                  ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                  android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                  iPhone: u.indexOf('iPhone') > -1 , //是否为iPhone或者QQHD浏览器
                  iPad: u.indexOf('iPad') > -1, //是否iPad
                  webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
              };  
           }(),  
           language:(navigator.browserLanguage || navigator.language).toLowerCase()  
  }   
    if(browser.versions.mobile || browser.versions.ios || browser.versions.android ||   
      browser.versions.iPhone || browser.versions.iPad){        
               
    }else{
    document.write("<script type=\'text/javascript\'  src=\'/js/src/particle.js\'><\/script>");
    }
  </script>

  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>
</html>
