<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Spring," />





  <link rel="alternate" href="/atom.xml" title="CloudPai" type="application/atom+xml" />






<meta name="description" content="Spring 知识点总结69题1. 什么是 Spring？ Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。 2.Spring 有哪些">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 知识点总结69题+25题">
<meta property="og:url" content="http://cloudpai.site/2018/03/17/2018-03-17-1/index.html">
<meta property="og:site_name" content="CloudPai">
<meta property="og:description" content="Spring 知识点总结69题1. 什么是 Spring？ Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。 2.Spring 有哪些">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.itmyhome.com/images/spring/1.png">
<meta property="og:updated_time" content="2018-03-31T09:49:00.169Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring 知识点总结69题+25题">
<meta name="twitter:description" content="Spring 知识点总结69题1. 什么是 Spring？ Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。 2.Spring 有哪些">
<meta name="twitter:image" content="http://blog.itmyhome.com/images/spring/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'TZAS2SFOJR',
      apiKey: 'e2a9cd036eede8026382b302001ec261',
      indexName: 'cloudpai_blogs_search',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cloudpai.site/2018/03/17/2018-03-17-1/"/>





  <title>Spring 知识点总结69题+25题 | CloudPai</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-114643720-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CloudPai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间轴
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>




 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cloudpai.site/2018/03/17/2018-03-17-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CloudPai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudPai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring 知识点总结69题+25题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T18:39:18+08:00">
                2018-03-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-03-31T17:49:00+08:00">
                2018-03-31
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/17/2018-03-17-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/17/2018-03-17-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12,836
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  50
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="/assets/js/APlayer.min.js"> </script><h1 id="Spring-知识点总结69题"><a href="#Spring-知识点总结69题" class="headerlink" title="Spring 知识点总结69题"></a>Spring 知识点总结69题</h1><p><strong>1. 什么是 Spring？</strong></p>
<p>Spring 是一个开源的 Java EE 开发框架。Spring 框架的核心功能可以应用在任何 Java 应用程序中，但对 Java EE 平台上的 Web 应用程序有更好的扩展性。Spring 框架的目标是使得 Java EE 应用程序的开发更加简捷，通过使用 POJO 为基础的编程模型促进良好的编程风格。</p>
<p><strong>2.Spring 有哪些优点？</strong></p>
<ul>
<li><p><strong>轻量级：</strong>Spring 在大小和透明性方面绝对属于轻量级的，基础版本的 Spring 框架大约只有 2MB。</p>
</li>
<li><p><strong>控制反转 (IOC)：</strong>Spring 使用<a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2011/08/what-is-dependency-inversion-is-it-ioc.html" target="_blank" rel="noopener">控制反转技术</a>实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。</p>
</li>
<li><p><strong>面向切面编程 (AOP)：</strong> <a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2011/01/aspect-oriented-programming-spring-aop.html" target="_blank" rel="noopener">Spring 支持面向切面编程</a>，同时把应用的业务逻辑与系统的服务分离开来。</p>
</li>
<li><p><strong>容器：</strong>Spring 包含并管理应用程序对象的配置及生命周期。</p>
</li>
<li><p><strong>MVC 框架：</strong>Spring 的 web 框架是一个设计优良的 <a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2011/02/spring-mvc-development-tutorial.html" target="_blank" rel="noopener">web MVC 框架</a>，很好的取代了一些 web 框架。</p>
</li>
<li><p><strong>事务管理：</strong>Spring 对下至本地业务上至全局业务 (JAT) 提供了统一的事务管理接口。</p>
</li>
<li><p><strong>异常处理：</strong>Spring 提供一个方便的 API 将特定技术的异常 (由 JDBC, Hibernate, 或 JDO 抛出) 转化为一致的、Unchecked 异常。</p>
</li>
</ul>
<p><strong>3.Spring 框架有哪些模块？</strong></p>
<p>Spring 框架的基本模块如下所示：</p>
<ul>
<li>Core module</li>
<li>Bean module</li>
<li>Context module</li>
<li>Expression Language module</li>
<li>JDBC module</li>
<li>ORM module</li>
<li>OXM module</li>
<li>Java Messaging Service(JMS) module</li>
<li>Transaction module</li>
<li>Web module</li>
<li>Web-Servlet module</li>
<li>Web-Struts module</li>
<li>Web-Portlet module</li>
</ul>
<p><strong>4. 解释核心容器 (应用上下文) 模块</strong></p>
<p>这是 Spring 的基本模块，它提供了 Spring 框架的基本功能。BeanFactory 是所有 Spring 应用的核心。Spring 框架是建立在这个模块之上的，这也使得 Spring 成为一个容器。</p>
<p><strong>5.BeanFactory – BeanFactory 实例</strong></p>
<p>BeanFactory 是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。</p>
<p>最常用的 BeanFactory 实现是 XmlBeanFactory 类。</p>
<p><strong>6.XmlBeanFactory</strong></p>
<p>最常用的就是 org.springframework.beans.factory.xml.XmlBeanFactory，它根据 XML 文件中定义的内容加载 beans。该容器从 XML 文件中读取配置元数据，并用它来创建一个完备的系统或应用。</p>
<p><strong>7. 解释 AOP 模块</strong></p>
<p>AOP 模块用来开发 Spring 应用程序中具有切面性质的部分。该模块的大部分服务由 AOP Aliance 提供，这就保证了 Spring 框架和其他 AOP 框架之间的互操作性。另外，该模块将元数据编程引入到了 Spring。</p>
<p><strong>8. 解释抽象 JDBC 和 DAO 模块</strong></p>
<p>通过使用<a href="https://link.jianshu.com?t=http://examples.javacodegeeks.com/enterprise-java/spring/jdbc/spring-jdbctemplate-example/" target="_blank" rel="noopener">抽象 JDBC 和 DAO 模块</a>保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用 Spring 的 AOP 模块为 Spring 应用程序中的对象提供事务管理服务。</p>
<p><strong>9. 解释对象 / 关系映射集成模块</strong></p>
<p>Spring 通过提供 ORM 模块在 JDBC 的基础上支持对象关系映射工具。这样的支持使得 Spring 可以集成主流的 ORM 框架，包括 Hibernate, JDO, 及 iBATIS SQL Maps。Spring 的事务管理可以同时支持以上某种框架和 JDBC。</p>
<p><strong>10. 解释 web 模块</strong></p>
<p><a href="https://link.jianshu.com?t=http://examples.javacodegeeks.com/enterprise-java/spring/mvc/spring-mvc-hello-world-example/" target="_blank" rel="noopener">Spring 的 web 模块</a>建立在应用上下文 (application context) 模块之上，提供了一个适合基于 web 应用程序的上下文环境。该模块还支持了几个面向 web 的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。</p>
<p><strong>11. 解释 Spring MVC 模块</strong></p>
<p>Spring 提供 MVC 框架构建 web 应用程序。Spring 可以很轻松的同其他 MVC 框架结合，但 <a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2012/09/spring-adding-spring-mvc-part-1.html" target="_blank" rel="noopener">Spring 的 MVC</a> 是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。</p>
<p><strong>12.Spring 的配置文件</strong></p>
<p>Spring 的配置文件是一个 XML 文件，文件包含了类信息并描述了这些类是如何配置和互相调用的。</p>
<p><strong>13.Spring IoC 容器是什么？</strong></p>
<p>Spring IOC 负责创建对象、管理对象 (通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。</p>
<p><strong>14.IOC 有什么优点？</strong></p>
<p>IOC 或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或 JNDI 查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC 容器支持勤性单例及延迟加载服务。</p>
<p><strong>15. 应用上下文是如何实现的？</strong></p>
<p><strong>FileSystemXmlApplicationContext</strong> 容器加载 XML 文件中 beans 的定义。XML Bean 配置文件的完整路径必须传递给构造器。</p>
<p><strong>FileSystemXmlApplicationContext</strong> 容器也加载 XML 文件中 beans 的定义。注意，你需要正确的设置 CLASSPATH，因为该容器会在 CLASSPATH 中查看 bean 的 XML 配置文件。</p>
<p><strong>WebXmlApplicationContext：</strong>该容器加载 xml 文件，这些文件定义了 web 应用中所有的 beans。</p>
<p><strong>16.Bean Factory 和 ApplicationContext 有什么区别？</strong></p>
<p>ApplicationContext 提供了一种解决文档信息的方法，一种加载文件资源的方式 (如图片)，他们可以向监听他们的 beans 发送消息。另外，容器或者容器中 beans 的操作，这些必须以 bean 工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。应用上下文实现了 MessageSource，该接口用于获取本地消息，实际的实现是可选的。</p>
<p><strong>17.Spring 应用程序看起来像什么？</strong></p>
<ul>
<li>一个定义功能的接口</li>
<li>实现包括属性，setter 和 getter 方法，功能等</li>
<li>Spring AOP</li>
<li>Spring 的 XML 配置文件</li>
<li>使用该功能的客户端编程</li>
</ul>
<p><strong>依赖注入</strong></p>
<p><strong>18.Spring 中的依赖注入是什么？</strong></p>
<p><a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2014/02/dependency-injection-options-for-java.html" target="_blank" rel="noopener">依赖注入</a>作为控制反转 (IOC) 的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后 IOC 容器负责衔接。</p>
<p><strong>19. 有哪些不同类型的 IOC(依赖注入)？</strong></p>
<ul>
<li><p><strong>构造器依赖注入：</strong>构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。</p>
</li>
<li><p><strong>Setter 方法依赖注入：</strong>首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用 bean 中的 setter 方法完成 Setter 方法依赖注入。</p>
</li>
</ul>
<p><strong>20. 你推荐哪种依赖注入？构造器依赖注入还是 Setter 方法依赖注入？</strong></p>
<p>你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用 setter 方法实现可选的依赖关系。</p>
<p><strong>Spring Beans</strong></p>
<p><strong>21. 什么是 Spring Beans？</strong></p>
<p><a href="https://link.jianshu.com?t=http://examples.javacodegeeks.com/enterprise-java/spring/beans-spring/spring-3-bean-reference-example/" target="_blank" rel="noopener">Spring Beans</a> 是构成 Spring 应用核心的 Java 对象。这些对象由 Spring IOC 容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用 XML 文件中定义的 <bean> 创建。</bean></p>
<p>在 Spring 中创建的 beans 都是单例的 beans。在 bean 标签中有一个属性为”singleton”, 如果设为 true，该 bean 是单例的，如果设为 false，该 bean 是原型 bean。Singleton 属性默认设置为 true。因此，spring 框架中所有的 bean 都默认为单例 bean。</p>
<p><strong>22.Spring Bean 中定义了什么内容？</strong></p>
<p>Spring Bean 中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p>
<p><strong>23. 如何向 Spring 容器提供配置元数据？</strong></p>
<p>有三种方式向 Spring 容器提供元数据:</p>
<ul>
<li><p>XML 配置文件</p>
</li>
<li><p>基于注解配置</p>
</li>
<li><p><a href="https://link.jianshu.com?t=http://examples.javacodegeeks.com/enterprise-java/spring/beans-spring/spring-3-java-config-example/" target="_blank" rel="noopener">基于 Java 的配置</a></p>
</li>
</ul>
<p><strong>24. 你如何定义 bean 的作用域？</strong></p>
<p>在 Spring 中创建一个 bean 的时候，我们可以声明它的作用域。只需要在 bean 定义的时候通过’scope’属性定义即可。例如，当 Spring 需要产生每次一个新的 bean 实例时，应该声明 bean 的 scope 属性为 prototype。如果每次你希望 Spring 返回一个实例，应该声明 bean 的 scope 属性为 singleton。</p>
<p><strong>25. 说一下 Spring 中支持的 bean 作用域</strong></p>
<p>Spring 框架支持如下五种不同的作用域：</p>
<ul>
<li><p><strong>singleton</strong>：在 Spring IOC 容器中仅存在一个 Bean 实例，Bean 以单实例的方式存在。</p>
</li>
<li><p><strong>prototype</strong>：一个 bean 可以定义多个实例。</p>
</li>
<li><p><strong>request</strong>：每次 HTTP 请求都会创建一个新的 Bean。该作用域仅适用于 WebApplicationContext 环境。</p>
</li>
<li><p><strong>session</strong>：一个 HTTP Session 定义一个 Bean。该作用域仅适用于 WebApplicationContext 环境.</p>
</li>
<li><p><strong>globalSession</strong>：同一个全局 HTTP Session 定义一个 Bean。该作用域同样仅适用于 WebApplicationContext 环境.</p>
</li>
</ul>
<p>bean 默认的 scope 属性是’<strong>singleton</strong>‘。</p>
<p><strong>26.Spring 框架中单例 beans 是线程安全的吗？</strong></p>
<p>不是，Spring 框架中的单例 beans 不是线程安全的。</p>
<p><strong>27. 解释 Spring 框架中 bean 的生命周期</strong></p>
<ul>
<li><p>Spring 容器读取 XML 文件中 bean 的定义并实例化 bean。</p>
</li>
<li><p>Spring 根据 bean 的定义设置属性值。</p>
</li>
<li><p>如果该 Bean 实现了 BeanNameAware 接口，Spring 将 bean 的 id 传递给 setBeanName() 方法。</p>
</li>
<li><p>如果该 Bean 实现了 BeanFactoryAware 接口，Spring 将 beanfactory 传递给 setBeanFactory() 方法。</p>
</li>
<li><p>如果任何 bean BeanPostProcessors 和该 bean 相关，Spring 调用 postProcessBeforeInitialization() 方法。</p>
</li>
<li><p>如果该 Bean 实现了 InitializingBean 接口，调用 Bean 中的 afterPropertiesSet 方法。如果 bean 有初始化函数声明，调用相应的初始化方法。</p>
</li>
<li><p>如果任何 bean BeanPostProcessors 和该 bean 相关，调用 postProcessAfterInitialization() 方法。</p>
</li>
<li><p>如果该 bean 实现了 DisposableBean，调用 destroy() 方法。</p>
</li>
</ul>
<p><strong>28. 哪些是最重要的 bean 生命周期方法？能重写它们吗？</strong></p>
<p>有两个重要的 bean 生命周期方法。第一个是 setup 方法，该方法在容器加载 bean 的时候被调用。第二个是 teardown 方法，该方法在 bean 从容器中移除的时候调用。</p>
<p>bean 标签有两个重要的属性 (init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring 也有相应的注解：@PostConstruct 和 @PreDestroy。</p>
<p><strong>29. 什么是 Spring 的内部 bean？</strong></p>
<p>当一个 bean 被用作另一个 bean 的属性时，这个 bean 可以被声明为内部 bean。在基于 XML 的配置元数据中，可以通过把 <bean> 元素定义在 <property> 或 &lt; constrtucor-arg &gt; 元素内部实现定义内部 bean。内部 bean 总是匿名的并且它们的 scope 总是 prototype。</property></bean></p>
<p><strong>30. 如何在 Spring 中注入 Java 集合类？</strong></p>
<p>Spring 提供如下几种类型的<a href="https://link.jianshu.com?t=http://examples.javacodegeeks.com/enterprise-java/spring/beans-spring/spring-collections-list-set-map-and-properties-example/" target="_blank" rel="noopener">集合配置元素</a>：</p>
<ul>
<li><p>list 元素用来注入一系列的值，允许有相同的值。</p>
</li>
<li><p>set 元素用来注入一些列的值，不允许有相同的值。</p>
</li>
<li><p>map 用来注入一组” 键 - 值” 对，键、值可以是任何类型的。</p>
</li>
<li><p>props 也可以用来注入一组” 键 - 值” 对，这里的键、值都字符串类型。</p>
</li>
</ul>
<p><strong>31. 什么是 bean wiring？</strong></p>
<p>Wiring，或者说 bean Wiring 是指 beans 在 Spring 容器中结合在一起的情况。当装配 bean 的时候，Spring 容器需要知道需要哪些 beans 以及如何使用依赖注入将它们结合起来。</p>
<p><strong>32. 什么是 bean 自动装配？</strong></p>
<p>Spring 容器可以<a href="https://link.jianshu.com?t=http://examples.javacodegeeks.com/enterprise-java/spring/beans-spring/spring-autowire-example/" target="_blank" rel="noopener">自动配置</a>相互协作 beans 之间的关联关系。这意味着 Spring 可以自动配置一个 bean 和其他协作 bean 之间的关系，通过检查 BeanFactory 的内容里没有使用 <constructor-arg> 和 &lt; property &gt; 元素。</constructor-arg></p>
<p><strong>33. 解释自动装配的各种模式？</strong></p>
<p>自动装配提供五种不同的模式供 Spring 容器用来自动装配 beans 之间的依赖注入:</p>
<ul>
<li><p><strong>no：</strong>默认的方式是不进行自动装配，通过手工设置 ref 属性来进行装配 bean。</p>
</li>
<li><p><strong>byName：</strong>通过参数名自动装配，Spring 容器查找 beans 的属性，这些 beans 在 XML 配置文件中被设置为 byName。之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。</p>
</li>
<li><p><strong>byType：</strong>通过参数的数据类型自动自动装配，Spring 容器查找 beans 的属性，这些 beans 在 XML 配置文件中被设置为 byType。之后容器试图匹配和装配和该 bean 的属性类型一样的 bean。如果有多个 bean 符合条件，则抛出错误。</p>
</li>
<li><p><strong>constructor：</strong>这个同 byType 类似，不过是应用于构造函数的参数。如果在 BeanFactory 中不是恰好有一个 bean 与构造函数参数相同类型，则抛出一个严重的错误。</p>
</li>
<li><p><strong>autodetect：</strong>如果有默认的构造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。</p>
</li>
</ul>
<p><strong>34. 自动装配有哪些局限性？</strong></p>
<p>自动装配有如下局限性：</p>
<ul>
<li><p><strong>重写：</strong>你仍然需要使用 <constructor-arg> 和 &lt; property &gt; 设置指明依赖，这意味着总要重写自动装配。</constructor-arg></p>
</li>
<li><p><strong>原生数据类型:</strong> 你不能自动装配简单的属性，如原生类型、字符串和类。</p>
</li>
<li><p><strong>模糊特性：</strong>自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。</p>
</li>
</ul>
<p><strong>35. 你可以在 Spring 中注入 null 或空字符串吗？</strong></p>
<p>完全可以。</p>
<p><strong>Spring 注解</strong></p>
<p><strong>36. 什么是 Spring 基于 Java 的配置？给出一些注解的例子</strong></p>
<p><a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2013/04/spring-java-configuration.html" target="_blank" rel="noopener">基于 Java 的配置</a>允许你使用 Java 的注解进行 Spring 的大部分配置而非通过传统的 XML 文件配置。</p>
<p>以注解 @Configuration 为例，它用来标记类，说明作为 beans 的定义，可以被 Spring IOC 容器使用。另一个例子是 @Bean 注解，它表示该方法定义的 Bean 要被注册进 Spring 应用上下文中。</p>
<p><strong>37. 什么是基于注解的容器配置?</strong></p>
<p>另外一种替代 XML 配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用 XML 描述 bean 之间的连线关系。</p>
<p><strong>38. 如何开启注解装配？</strong></p>
<p>注解装配默认情况下在 Spring 容器中是不开启的。如果想要开启基于注解的装配只需在 Spring 配置文件中配置 <a href="context:annotation-config" target="_blank" rel="noopener">context:annotation-config</a> 元素即可。&lt;/context:annotation-config&gt;</p>
<p><strong>39.@Required 注解</strong></p>
<p>@Required 表明 bean 的属性必须在配置时设置，可以在 bean 的定义中明确指定也可通过自动装配设置。如果 bean 的属性未设置，则抛出 BeanInitializationException 异常。</p>
<p><strong>40.@Autowired 注解</strong></p>
<p>@Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。它可以像 @Required 一样自动装配 setter 方法、构造器、属性或者具有任意名称和 / 或多个参数的 PN 方法。</p>
<p><strong>41. @Qualifier 注解</strong></p>
<p>当有多个相同类型的 bean 而只有其中的一个需要自动装配时，将 @Qualifier 注解和 @Autowire 注解结合使用消除这种混淆，指明需要装配的 bean。</p>
<p><strong>Spring 数据访问</strong></p>
<p><strong>42. 在 Spring 框架中如何更有效的使用 JDBC？</strong></p>
<p>使用 Spring JDBC 框架，资源管理以及错误处理的代价都会减轻。开发人员只需通过 statements 和 queries 语句从数据库中存取数据。Spring 框架中通过使用模板类能更有效的使用 JDBC，也就是所谓的 JdbcTemplate(<a href="https://link.jianshu.com?t=http://examples.javacodegeeks.com/enterprise-java/spring/jdbc/spring-jdbctemplate-example/" target="_blank" rel="noopener">例子</a>)。</p>
<p><strong>43.JdbcTemplate</strong></p>
<p>JdbcTemplate 类提供了许多方法，为我们与数据库的交互提供了便利。例如，它可以将数据库的数据转化为原生类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据库错误处理功能。</p>
<p><strong>44.Spring 对 DAO 的支持</strong></p>
<p><a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2012/09/spring-dao-and-service-layer.html" target="_blank" rel="noopener">Spring 对数据访问对象 (DAO)</a> 的支持旨在使它可以与数据访问技术 (如 JDBC, Hibernate 及 JDO) 方便的结合起来工作。这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。</p>
<p><strong>45. 使用 Spring 可以通过什么方式访问 Hibernate？</strong></p>
<p>使用 Spring 有两种方式访问 Hibernate：</p>
<ul>
<li><p>使用 Hibernate Template 的反转控制以及回调方法</p>
</li>
<li><p>继承 HibernateDAOSupport，并申请一个 AOP 拦截器节点</p>
</li>
</ul>
<p><strong>46.Spring 支持的 ORM</strong></p>
<p>Spring 支持一下 ORM：</p>
<ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA (Java -Persistence API)</li>
<li>TopLink</li>
<li>JDO (Java Data Objects)</li>
<li>OJB</li>
</ul>
<p><strong>47. 如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</strong></p>
<p>使用 Spring 的 SessionFactory 调用 LocalSessionFactory。结合过程分为以下三步：</p>
<ul>
<li><p>配置 Hibernate SessionFactory</p>
</li>
<li><p>继承 HibernateDaoSupport 实现一个 DAO</p>
</li>
<li><p>使用 AOP 装载事务支持</p>
</li>
</ul>
<p><strong>48.Spring 支持的事务管理类型</strong></p>
<p>Spring 支持如下两种方式的事务管理：</p>
<ul>
<li><p><strong>编程式事务管理：</strong>这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</p>
</li>
<li><p><strong>声明式事务管理：</strong>这种方式意味着你可以将<a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2011/09/spring-declarative-transactions-example.html" target="_blank" rel="noopener">事务管理和业务代码分离</a>。你只需要通过注解或者 XML 配置管理事务。</p>
</li>
</ul>
<p><strong>49.Spring 框架的事务管理有哪些优点？</strong></p>
<ul>
<li><p>它为不同的事务 API(如 JTA, JDBC, Hibernate, JPA, 和 JDO) 提供了统一的编程模型。</p>
</li>
<li><p>它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API(如 JTA).</p>
</li>
<li><p>它支持声明式事务管理。</p>
</li>
<li><p>它可以和 Spring 的多种数据访问技术很好的融合。</p>
</li>
</ul>
<p><strong>50. 你更推荐那种类型的事务管理？</strong></p>
<p>许多 Spring 框架的用户选择<strong>声明式事务管理</strong>，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理 (这种方式允许你通过代码控制业务)。</p>
<p><strong>Spring 面向切面编程 (AOP)</strong></p>
<p><strong>51. 解释 AOP</strong></p>
<p><a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2014/02/applying-aspect-oriented-programming.html" target="_blank" rel="noopener">面向切面编程</a>, 或 AOP 允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。</p>
<p><strong>52. 切面 (Aspect)</strong></p>
<p>AOP 的核心就是切面，它将多个类的通用行为封装为可重用的模块。该模块含有一组 API 提供 cross-cutting 功能。例如, 日志模块称为日志的 AOP 切面。根据需求的不同，一个应用程序可以有若干切面。在 Spring AOP 中，切面通过带有 @Aspect 注解的类实现。</p>
<p><strong>53. 在 Spring AOP 中 concern 和 cross-cutting concern 的区别是什么？</strong></p>
<p>Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern 可以定义为我们想要实现的功能。</p>
<p>Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于 Cross-cutting concern。</p>
<p><strong>54. 连接点 (Join point)</strong></p>
<p>连接点代表应用程序中插入 AOP 切面的地点。它实际上是 Spring AOP 框架在应用程序中执行动作的地点。</p>
<p><strong>55. 通知 (Advice)</strong></p>
<p>通知表示在方法执行前后需要执行的动作。实际上它是 Spring AOP 框架在程序执行过程中触发的一些代码。</p>
<p>Spring 切面可以执行一下五种类型的通知:</p>
<ul>
<li><p>before(前置通知)：在一个方法之前执行的通知。</p>
</li>
<li><p>after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p>
</li>
<li><p>after-returning(后置通知)：在某连接点正常完成后执行的通知。</p>
</li>
<li><p>after-throwing(异常通知)：在方法抛出异常退出时执行的通知。</p>
</li>
<li><p>around(环绕通知)：在方法调用前后触发的通知。</p>
</li>
</ul>
<p><strong>56. 切入点 (Pointcut)</strong></p>
<p>切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p>
<p><strong>57. 什么是引入？</strong></p>
<p>引入允许我们在已有的类上添加新的方法或属性。</p>
<p><strong>58. 什么是目标对象？</strong></p>
<p>被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被通知（advised）对象。</p>
<p><strong>59. 什么是代理？</strong></p>
<p>代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</p>
<p><strong>60. 有几种不同类型的自动代理？</strong></p>
<ul>
<li><p>BeanNameAutoProxyCreator：bean 名称自动代理创建器</p>
</li>
<li><p>DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器</p>
</li>
<li><p>Metadata autoproxying：元数据自动代理</p>
</li>
</ul>
<p><strong>61. 什么是织入？什么是织入应用的不同点？</strong></p>
<p>织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。</p>
<p><strong>62. 解释基于 XML Schema 方式的切面实现</strong></p>
<p>在这种情况下，切面由使用 XML 文件配置的类实现。</p>
<p><strong>63. 解释基于注解方式 (基于 @AspectJ) 的切面实现</strong></p>
<p>在这种情况下 (基于 @AspectJ 的实现)，指的是切面的对应的类使用 Java 5 注解的声明方式。</p>
<p><strong>Spring 的 MVC 框架</strong></p>
<p><strong>64. 什么是 Spring 的 MVC 框架？</strong></p>
<p>Spring 提供了一个<a href="https://link.jianshu.com?t=http://examples.javacodegeeks.com/enterprise-java/spring/mvc/spring-mvc-hello-world-example/" target="_blank" rel="noopener">功能齐全的 MVC 框架用于构建 Web 应用程序</a>。Spring 框架可以很容易的和其他的 MVC 框架融合 (如 Struts)，该框架使用<strong>控制反转(IOC)</strong> 将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。</p>
<p><strong>65.DispatcherServlet</strong></p>
<p>Spring 的 MVC 框架围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。</p>
<p><strong>66.WebApplicationContext</strong></p>
<p>WebApplicationContext 继承了 ApplicationContext，并添加了一些 web 应用程序需要的功能。和普通的 ApplicationContext 不同，WebApplicationContext 可以用来处理主题样式，它也知道如何找到相应的 servlet。</p>
<p><strong>67. 什么是 Spring MVC 框架的控制器？</strong></p>
<p>控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。</p>
<p><strong>68.@Controller annotation</strong></p>
<p>@Controller 注解表示该类扮演控制器的角色。Spring 不需要继承任何控制器基类或应用 Servlet API。</p>
<p><strong>69.@RequestMapping annotation</strong></p>
<p>@RequestMapping 注解用于将 URL 映射到任何一个类或者一个特定的处理方法上。</p>
<hr>
<blockquote>
<p>原文链接： <a href="https://link.jianshu.com?t=http://www.javacodegeeks.com/2014/05/spring-interview-questions-and-answers.html" target="_blank" rel="noopener">javacodegeeks</a> 翻译： <a href="https://link.jianshu.com?t=http://www.importnew.com" target="_blank" rel="noopener">ImportNew.com</a> - <a href="https://link.jianshu.com?t=http://www.importnew.com/author/mandy" target="_blank" rel="noopener">人晓</a><br>译文链接： <a href="https://link.jianshu.com?t=http://www.importnew.com/11657.html" target="_blank" rel="noopener">http://www.importnew.com/11657.html</a></p>
</blockquote>
<hr>
<h1 id="spring面试总结25题"><a href="#spring面试总结25题" class="headerlink" title="spring面试总结25题"></a>spring面试总结25题</h1><p>1、什么是 <a href="http://lib.csdn.net/base/javaee" title="Java EE知识库" target="_blank" rel="noopener">spring</a> 框架？Spring 框架有哪些主要模块？</p>
<p>Spring 框架是一个为 <a href="http://lib.csdn.net/base/javase" title="Java SE知识库" target="_blank" rel="noopener">Java</a> 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。Spring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。</p>
<p>Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成,、Web、</p>
<p>AOP（面向切面编程）、工具、消息和<a href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库" target="_blank" rel="noopener">测试</a>模块。</p>
<p><img src="http://blog.itmyhome.com/images/spring/1.png" alt=""></p>
<p><a></a></p>
<h4 id="2、使用-Spring-框架能带来哪些好处？"><a href="#2、使用-Spring-框架能带来哪些好处？" class="headerlink" title="2、使用 Spring 框架能带来哪些好处？"></a><a></a>2、使用 Spring 框架能带来哪些好处？</h4><p>下面列举了一些使用 Spring 框架带来的主要好处：</p>
<ul>
<li><p>Dependency Injection(DI) 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。</p>
</li>
<li><p>与 EJB 容器相比较，IoC 容器更加趋向于轻量级。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下进行应用程序的开发和发布就变得十分有利。</p>
</li>
<li><p>Spring 并没有闭门造车, Spring 利用了已有的技术如 ORM 框架 logging 框架、J2EE、Quartz 和 JDK Timer, 以及其他视图技术.</p>
</li>
<li><p>Spring 框架是按照模块的形式来组织的. 由包和类的编号就可以看出其所属的模块, 开发者仅仅需要选用他们需要的模块即可。</p>
</li>
<li><p>要测试一项用 Spring 开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。</p>
</li>
<li><p>Spring 的 Web 框架亦是一个精心设计的 Web MVC 框架，为开发者们在 web 框架的选择上提供了一个除了主流框架 比如 Struts、过度设计的、不流行 web 框架的以外的有力选项。</p>
</li>
<li><p>Spring 提供了一个便捷的事务管理接口，适用于小型的本地事物处理 (比如在单 DB 的环境下) 和复杂的共同事物处理 (比如利用 JTA 的复杂 DB 环境)。</p>
</li>
</ul>
<p><a></a></p>
<h4 id="3、什么是控制反转-IOC-什么是依赖注入"><a href="#3、什么是控制反转-IOC-什么是依赖注入" class="headerlink" title="3、什么是控制反转 (IOC)? 什么是依赖注入?"></a><a></a>3、什么是控制反转 (IOC)? 什么是依赖注入?</h4><p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常</p>
<p>是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的</p>
<p>情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联</p>
<p>关系的定义抽象化。而<strong>绑定</strong>的过程是通过 “依赖注入” 实现的。</p>
<p><strong>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式</strong>，并在我们的实际工作中起到了有效的作用。</p>
<p><strong>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。</strong></p>
<p>这就需要一种机制用来激活相应的组件以提供特定的功能，所以<strong>依赖注入是控制反转的基础</strong>。否则如果在组件不受框架控制的</p>
<p>情况下，框架又怎么知道要创建哪个组件？</p>
<p>在 Java 中依然注入有以下三种实现方式：</p>
<ul>
<li><p>构造器注入</p>
</li>
<li><p>Setter 方法注入</p>
</li>
<li><p>接口注入</p>
</li>
</ul>
<p><a></a></p>
<h4 id="4、请解释下-Spring-框架中的-IoC"><a href="#4、请解释下-Spring-框架中的-IoC" class="headerlink" title="4、请解释下 Spring 框架中的 IoC?"></a><a></a>4、请解释下 Spring 框架中的 IoC?</h4><p>Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了 Spring 框架 IoC 容器的基础。</p>
<p>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex 接口对</p>
<p>BeanFactory(是一个子接口) 进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，</p>
<p>也提供了处理 message resource 的机制 (用于国际化)、事件传播以及应用层的特别配置，</p>
<p>比如针对 Web 应用的 WebApplicationContext。</p>
<p>org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。</p>
<p>BeanFactory 接口是 Spring IoC 容器的核心接口。</p>
<p><a></a></p>
<h4 id="5、BeanFactory-和-ApplicationContext-有什么区别"><a href="#5、BeanFactory-和-ApplicationContext-有什么区别" class="headerlink" title="5、BeanFactory 和 ApplicationContext 有什么区别?"></a><a></a>5、BeanFactory 和 ApplicationContext 有什么区别?</h4><p>BeanFactory 可以理解为含有 bean 集合的工厂类. BeanFactory 包含了种 bean 的定义, 以便在接收到客户端请求时将对应的</p>
<p>bean 实例化.</p>
<p>BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。</p>
<p>BeanFactory 还包含了 bean 生命周期的控制, 调用客户端的初始化方法 (initialization methods) 和销毁方法(destruction methods)。</p>
<p>从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。</p>
<p>但 application context 在此基础上还提供了其他的功能。</p>
<p>1、提供了支持国际化的文本消息</p>
<p>2、统一的资源文件读取方式</p>
<p>3、已在监听器中注册的 bean 的事件</p>
<p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<p>1、ClassPathXmlApplicationContext: 从 classpath 的 XML 配置文件中读取上下文, 并生成上下文定义. 应用程序上下文从程序环境变量中取得.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br></pre></td></tr></table></figure>
<p>2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;);</span><br></pre></td></tr></table></figure>
<p>3、XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。</p>
<p><a></a></p>
<h4 id="6、Spring-有几种配置方式"><a href="#6、Spring-有几种配置方式" class="headerlink" title="6、Spring 有几种配置方式?"></a><a></a>6、Spring 有几种配置方式?</h4><p>将 Spring 配置到应用开发中有以下三种方式：</p>
<p>1、基于 XML 的配置</p>
<p>2、基于注解的配置</p>
<p>3、基于 Java 的配置</p>
<p><a></a></p>
<h4 id="7、如何用基于-XML-配置的方式配置-Spring"><a href="#7、如何用基于-XML-配置的方式配置-Spring" class="headerlink" title="7、如何用基于 XML 配置的方式配置 Spring?"></a><a></a>7、如何用基于 XML 配置的方式配置 Spring?</h4><p>在 Spring 框架中，依赖和服务需要在专门的配置文件来实现，我常用的 XML 格式的配置文件。</p>
<p>这些配置文件的格式通常用开头，然后一系列的 bean 定义和专门的应用配置选项组成。</p>
<p>SpringXML 配置的主要目的时候是使所有的 Spring 组件都可以用 xml 文件的形式来进行配置。</p>
<p>这意味着不会出现其他的 Spring 配置类型 (比如声明的方式或基于 <a href="http://lib.csdn.net/base/java" title="Java 知识库" target="_blank" rel="noopener">Java </a>Class 的配置方式)</p>
<p>Spring 的 XML 配置方式是使用被 Spring 命名空间的所支持的一系列的 XML 标签来实现的。</p>
<p>Spring 有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc 和 aso。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;!-- JSON Support --&gt;</span><br><span class="line">    &lt;bean /&gt;</span><br><span class="line">    &lt;bean /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>下面这个 web.xml 仅仅配置了 DispatcherServlet, 这件最简单的配置便能满足应用程序配置运行时组件的需求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;</span><br><span class="line">            &lt;servlet-class&gt;</span><br><span class="line">                org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">            &lt;/servlet-class&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="8、如何用基于-Java-配置的方式配置-Spring"><a href="#8、如何用基于-Java-配置的方式配置-Spring" class="headerlink" title="8、如何用基于 Java 配置的方式配置 Spring?"></a><a></a>8、如何用基于 Java 配置的方式配置 Spring?</h4><p>Spring 对 Java 配置的支持是由 @Configuration 注解和 @Bean 注解来实现的。由 @Bean 注解的方法将会实例化、</p>
<p>配置和初始化一个新对象，这个对象将由 Spring 的 IoC 容器来管理。@Bean 声明所起到的作用与 元素类似。</p>
<p>被 @Configuration 所注解的类则表示这个类的主要目的是作为 bean 定义的资源。被 @Configuration 声明的类可以</p>
<p>通过在同一个类的内部调用 @bean 方法来设置嵌入 bean 的依赖关系。</p>
<p>最简单的 @Configuration 声明类请参考下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig&#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MyService myService() &#123;</span><br><span class="line">        return new MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的 @Beans 配置文件相同的 XML 配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;myService&quot; class=&quot;com.howtodoinjava.services.MyServiceImpl&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>上述配置方式的实例化方式如下：利用 AnnotationConfigApplicationContext 类进行实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用组件组建扫描，仅需用 @Configuration 进行注解即可:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;com.howtodoinjava&quot;)</span><br><span class="line">public class AppConfig  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，com.acme 包首先会被扫到，然后再容器内查找被 @Component 声明的类，</p>
<p>找到后将这些类按照 Sring bean 定义进行注册。</p>
<p>如果你要在你的 web 应用开发中选用上述的配置的方式的话, 需要用 AnnotationConfigWebApplicationContext 类来读取配置文件，</p>
<p>可以用来配置 Spring 的 Servlet 监听器 ContrextLoaderListener 或者 Spring MVC 的 DispatcherServlet。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">    &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext</span><br><span class="line">        instead of the default XmlWebApplicationContext --&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextClass&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;</span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        &lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Configuration locations must consist of one or more comma- or space-delimited</span><br><span class="line">        fully-qualified @Configuration classes. Fully-qualified packages may also be</span><br><span class="line">        specified for component-scanning --&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;com.howtodoinjava.AppConfig&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext</span><br><span class="line">            instead of the default XmlWebApplicationContext --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextClass&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;</span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            &lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;!-- Again, config locations must consist of one or more comma- or space-delimited</span><br><span class="line">            and fully-qualified @Configuration classes --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;com.howtodoinjava.web.MvcConfig&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="9、怎样用注解的方式配置-Spring？"><a href="#9、怎样用注解的方式配置-Spring？" class="headerlink" title="9、怎样用注解的方式配置 Spring？"></a><a></a>9、怎样用注解的方式配置 Spring？</h4><p>Spring 在 2.5 版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML 方式的 bean 描述，</p>
<p>可以将 bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。</p>
<p>注解注入将会被容器在 XML 注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。</p>
<p>注解装配在 Spring 中是默认关闭的。所以需要在 Spring 文件中配置一下才能使用基于注解的装配模式。</p>
<p>如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">   &lt;context:annotation-config/&gt;</span><br><span class="line">   &lt;!-- bean definitions go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在 <a href="http://blog.csdn.net/liuhang03/article/details/50147117" target="_blank" rel="noopener">context:annotation-config/</a> 标签配置完成以后, 就可以用注解的方式在 Spring 中向属性、方法和构造方法中自动装配变量。</p>
<p>下面是几种比较重要的注解类型： </p>
<p>1、@Required：该注解应用于设值方法。</p>
<p>2、@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。</p>
<p>3、@Qualifier：该注解和 @Autowired 注解搭配使用，用于消除特定 bean 自动装配的歧义。</p>
<p>4、JSR-250 Annotations：Spring 支持基于 JSR-250 注解的以下注解,@Resource、@PostConstruct 和 @PreDestroy。</p>
<p><a></a></p>
<h4 id="10、请解释-Spring-Bean-的生命周期"><a href="#10、请解释-Spring-Bean-的生命周期" class="headerlink" title="10、请解释 Spring Bean 的生命周期?"></a><a></a>10、请解释 Spring Bean 的生命周期?</h4><p>Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。</p>
<p>同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。</p>
<p>Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调 (call back) 方法组成。</p>
<p>1、初始化之后调用的回调方法。</p>
<p>2、销毁之前调用的回调方法。</p>
<p>Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：</p>
<ul>
<li><p>InitializingBean 和 DisposableBean 回调接口</p>
</li>
<li><p>针对特殊行为的其他 Aware 接口</p>
</li>
<li><p>Bean 配置文件中的 Custom init() 方法和 destroy() 方法</p>
</li>
<li><p>@PostConstruct 和 @PreDestroy 注解方式</p>
</li>
</ul>
<p>使用 customInit() 和 customDestroy() 方法管理 bean 生命周期的代码样例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;demoBean&quot; class=&quot;com.howtodoinjava.task.DemoBean&quot;</span><br><span class="line">            init-method=&quot;customInit&quot; destroy-method=&quot;customDestroy&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="11、Spring-Bean-的作用域之间有什么区别？"><a href="#11、Spring-Bean-的作用域之间有什么区别？" class="headerlink" title="11、Spring Bean 的作用域之间有什么区别？"></a><a></a>11、Spring Bean 的作用域之间有什么区别？</h4><p>Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的, 但是为了避免混淆, 还是让我们来解释一下：</p>
<p>1、singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例，</p>
<p>单例的模式由 bean factory 自身来维护。</p>
<p>2、prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。</p>
<p>3、request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例, 在请求完成以后, bean 会失效并被垃圾回收器回收.</p>
<p>4、Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。</p>
<p>5、global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。</p>
<p>如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。</p>
<p>全局作用域与 Servlet 中的 session 作用域效果相同。</p>
<p><a></a></p>
<h4 id="12、什么是-Spring-inner-beans"><a href="#12、什么是-Spring-inner-beans" class="headerlink" title="12、什么是 Spring inner beans?"></a><a></a>12、什么是 Spring inner beans?</h4><p>在 Spring 框架中，无论何时 bean 被使用时，当仅被调用了一个属性。一个明智的做法是将这个 bean 声明为内部 bean。</p>
<p>内部 bean 可以用 setter 注入 “属性” 和构造方法注入 “构造参数” 的方式来实现。</p>
<p>比如，在我们的应用程序中，一个 Customer 类引用了一个 Person 类，我们的要做的是创建一个 Person 的实例，</p>
<p>然后在 Customer 内部使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Customer</span><br><span class="line">&#123;</span><br><span class="line">    private Person person;</span><br><span class="line"></span><br><span class="line">    //Setters and Getters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String address;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    //Setters and Getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部 bean 的声明方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;CustomerBean&quot; class=&quot;com.howtodoinjava.common.Customer&quot;&gt;</span><br><span class="line">    &lt;property &gt;</span><br><span class="line">        &lt;!-- This is inner bean --&gt;</span><br><span class="line">        &lt;bean class=&quot;com.howtodoinjava.common.Person&quot;&gt;</span><br><span class="line">            &lt;property  /&gt;</span><br><span class="line">            &lt;property  /&gt;</span><br><span class="line">            &lt;property  /&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="13、Spring-框架中的单例-Beans-是线程安全的么"><a href="#13、Spring-框架中的单例-Beans-是线程安全的么" class="headerlink" title="13、Spring 框架中的单例 Beans 是线程安全的么?"></a><a></a>13、Spring 框架中的单例 Beans 是线程安全的么?</h4><p>Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问题需要开发者自行去搞定。</p>
<p>但实际上，大部分的 Spring bean 并没有可变的状态 (比如 Serview 类和 DAO 类), 所以在某种程度上说 Spring 的单例 bean</p>
<p>是线程安全的。如果你的 bean 有多种状态的话 (比如 View Model 对象)，就需要自行保证线程安全。</p>
<p>最浅显的解决办法就是将多态 bean 的作用域由 “singleton” 变更为 “prototype”。</p>
<p><a></a></p>
<h4 id="14、请举例说明如何在-Spring-中注入一个-Java-Collection"><a href="#14、请举例说明如何在-Spring-中注入一个-Java-Collection" class="headerlink" title="14、请举例说明如何在 Spring 中注入一个 Java Collection?"></a><a></a>14、请举例说明如何在 Spring 中注入一个 Java Collection?</h4><p>Spring 提供了以下四种集合类的配置元素：</p>
<ul>
<li><p><code>&lt;list&gt;:</code>该标签用来装配可重复的 list 值。</p>
</li>
<li><p><code>&lt;set&gt;:</code>该标签用来装配没有重复的 set 值。</p>
</li>
<li><p><code>&lt;map&gt;:</code>该标签可用来注入键和值可以为任何类型的键值对。</p>
</li>
<li><p><code>&lt;props&gt;:</code>该标签支持注入键和值都是字符串类型的键值对。</p>
</li>
</ul>
<p>下面看一下具体的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- Definition for javaCollection --&gt;</span><br><span class="line">   &lt;bean id=&quot;javaCollection&quot; class=&quot;com.howtodoinjava.JavaCollection&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- java.util.List --&gt;</span><br><span class="line">      &lt;property &gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">           &lt;value&gt;INDIA&lt;/value&gt;</span><br><span class="line">           &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">           &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">           &lt;value&gt;UK&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- java.util.Set --&gt;</span><br><span class="line">     &lt;property &gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">           &lt;value&gt;INDIA&lt;/value&gt;</span><br><span class="line">           &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">           &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">           &lt;value&gt;UK&lt;/value&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- java.util.Map --&gt;</span><br><span class="line">     &lt;property &gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">           &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt;</span><br><span class="line">           &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt;</span><br><span class="line">           &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt;</span><br><span class="line">           &lt;entry key=&quot;4&quot; value=&quot;UK&quot;/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- java.util.Properties --&gt;</span><br><span class="line">    &lt;property &gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="15、如何向-Spring-Bean-中注入一个-Java-util-Properties"><a href="#15、如何向-Spring-Bean-中注入一个-Java-util-Properties" class="headerlink" title="15、如何向 Spring Bean 中注入一个 Java.util.Properties?"></a><a></a>15、如何向 Spring Bean 中注入一个 Java.util.Properties?</h4><p>第一种方法是使用如下面代码所示的<code>&lt;props&gt;</code> 标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;adminUser&quot; class=&quot;com.howtodoinjava.common.Customer&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- java.util.Properties --&gt;</span><br><span class="line">    &lt;property &gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;admin&quot;&gt;admin@nospam.com&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;support&quot;&gt;support@nospam.com&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>也可用 “util:” 命名空间来从 properties 文件中创建出一个 propertiesbean，然后利用 setter 方法注入 bean 的引用。</p>
<p><a></a></p>
<h4 id="16、请解释-Spring-Bean-的自动装配"><a href="#16、请解释-Spring-Bean-的自动装配" class="headerlink" title="16、请解释 Spring Bean 的自动装配?"></a><a></a>16、请解释 Spring Bean 的自动装配?</h4><p>在 Spring 框架中，在配置文件中设定 bean 的依赖关系是一个很好的机制，Spring 容器还可以自动装配合作关系 bean 之间的</p>
<p>关联关系。这意味着 Spring 可以通过向 Bean Factory 中注入的方式自动搞定 bean 之间的依赖关系。</p>
<p>自动装配可以设置在每个 bean 上，也可以设定在特定的 bean 上。</p>
<p>下面的 XML 配置文件表明了如何根据名称将一个 bean 设置为自动装配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;employeeDAO&quot; class=&quot;com.howtodoinjava.EmployeeDAOImpl&quot; autowire=&quot;byName&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>除了 bean 配置文件中提供的自动装配模式，还可以使用 @Autowired 注解来自动装配指定的 bean。</p>
<p>在使用 @Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config /&gt;</span><br></pre></td></tr></table></figure>
<p>也可以通过在配置文件中配置 AutowiredAnnotationBeanPostProcessor 达到相同的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class =&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>配置好以后就可以使用 @Autowired 来标注了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public EmployeeDAOImpl ( EmployeeManager manager ) &#123;</span><br><span class="line">    this.manager = manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="17、请解释自动装配模式的区别"><a href="#17、请解释自动装配模式的区别" class="headerlink" title="17、请解释自动装配模式的区别?"></a><a></a>17、请解释自动装配模式的区别?</h4><p>在 Spring 框架中共有 5 种自动装配，让我们逐一分析。</p>
<p>1、no：这是 Spring 框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 bean 定义中用标签明确的设置依赖关系。</p>
<p>2、byName：该选项可以根据 bean 名称设置依赖关系。当向一个 bean 中自动装配一个属性时，</p>
<p>容器将根据 bean 的名称自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</p>
<p>3、byType：该选项可以根据 bean 类型设置依赖关系。当向一个 bean 中自动装配一个属性时，</p>
<p>容器将根据 bean 的类型自动在在配置文件中查询一个匹配的 bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</p>
<p>4、constructor：造器的自动装配和 byType 模式类似，但是仅仅适用于与有构造器相同参数的 bean，</p>
<p>如果在容器中没有找到与构造器参数类型一致的 bean，那么将会抛出异常。</p>
<p>5、autodetect：该模式自动探测使用构造器自动装配或者 byType 自动装配。首先，首先会尝试找合适的带参数的构造器，</p>
<p>如果找到的话就是用构造器自动装配，如果在 bean 内部没有找到相应的构造器或者是无参构造器，容器就会自动选择</p>
<p>byType 的自动装配方式。</p>
<p><a></a></p>
<h4 id="18、如何开启基于注解的自动装配？"><a href="#18、如何开启基于注解的自动装配？" class="headerlink" title="18、如何开启基于注解的自动装配？"></a><a></a>18、如何开启基于注解的自动装配？</h4><p>要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：</p>
<p>1、引入配置文件中的下引入 <a href="http://blog.csdn.net/liuhang03/article/details/50147117" target="_blank" rel="noopener">context:annotation-config</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:annotation-config /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>2、在 bean 配置文件中直接引入 AutowiredAnnotationBeanPostProcessor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="19、请举例解释-Required-注解"><a href="#19、请举例解释-Required-注解" class="headerlink" title="19、请举例解释 @Required 注解?"></a><a></a>19、请举例解释 @Required 注解?</h4><p>在产品级别的应用中，IoC 容器可能声明了数十万了 bean，bean 与 bean 之间有着复杂的依赖关系。设值注解方法的短板之一</p>
<p>就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置 “dependency-check” 来解决这个问题。</p>
<p>在应用程序的生命周期中，你可能不大愿意花时间在验证所有 bean 的属性是否按照上下文文件正确配置。或者你宁可验证某个</p>
<p>bean 的特定属性是否被正确的设置。即使是用 “dependency-check” 属性也不能很好的解决这个问题, 在这种情况下, 你需要使用</p>
<p>@Required 注解。</p>
<p>需要用如下的方式使用来标明 bean 的设值方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class EmployeeFactoryBean extends AbstractFactoryBean&lt;Object&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private String designation;</span><br><span class="line"></span><br><span class="line">    public String getDesignation() &#123;</span><br><span class="line">        return designation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Required</span><br><span class="line">    public void setDesignation(String designation) &#123;</span><br><span class="line">        this.designation = designation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //more code here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequiredAnnotationBeanPostProcessor 是 Spring 中的后置处理用来验证被 @Required 注解的 bean 属性是否被正确的设置了。</p>
<p>在使用 RequiredAnnotationBeanPostProcesso 来验证 bean 属性之前，首先要在 IoC 容器中对其进行注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个 BeanInitializationException 异常。</p>
<p><a></a></p>
<h4 id="20、请举例解释-Autowired-注解"><a href="#20、请举例解释-Autowired-注解" class="headerlink" title="20、请举例解释 @Autowired 注解?"></a><a></a>20、请举例解释 @Autowired 注解?</h4><p>@Autowired 注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired 注解可以像 @Required 注解、</p>
<p>构造器一样被用于在 bean 的设值方法上自动装配 bean 的属性，一个参数或者带有任意名称或带有多个参数的方法。</p>
<p>比如，可以在设值方法上使用 @Autowired 注解来替代配置文件中的 元素。</p>
<p>当 Spring 容器在 setter 方法上找到 @Autowired 注解时，会尝试用 byType 自动装配。</p>
<p>当然我们也可以在构造方法上使用 @Autowired 注解。带有 @Autowired 注解的构造方法意味着</p>
<p>在创建一个 bean 时将会被自动装配，即便在配置文件中使用 元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TextEditor &#123;</span><br><span class="line">   private SpellChecker spellChecker;</span><br><span class="line"></span><br><span class="line">   @Autowired</span><br><span class="line">   public TextEditor(SpellChecker spellChecker)&#123;</span><br><span class="line">      System.out.println(&quot;Inside TextEditor constructor.&quot; );</span><br><span class="line">      this.spellChecker = spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void spellCheck()&#123;</span><br><span class="line">      spellChecker.checkSpelling();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是没有构造参数的配置方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">   &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- Definition for textEditor bean without constructor-arg  --&gt;</span><br><span class="line">   &lt;bean id=&quot;textEditor&quot; class=&quot;com.howtodoinjava.TextEditor&quot;&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- Definition for spellChecker bean --&gt;</span><br><span class="line">   &lt;bean id=&quot;spellChecker&quot; class=&quot;com.howtodoinjava.SpellChecker&quot;&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="21、请举例说明-Qualifier-注解"><a href="#21、请举例说明-Qualifier-注解" class="headerlink" title="21、请举例说明 @Qualifier 注解?"></a><a></a>21、请举例说明 @Qualifier 注解?</h4><p>@Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。Qualifier 注解可以用来取消 Spring 不能取消的 bean 应用。</p>
<p>下面的示例将会在 Customer 的 person 属性中自动装配 person 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Customer</span><br><span class="line">&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Person person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们要在配置文件中来配置 Person 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;customer&quot; class=&quot;com.howtodoinjava.common.Customer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;personA&quot; class=&quot;com.howtodoinjava.common.Person&quot; &gt;</span><br><span class="line">    &lt;property  /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;personB&quot; class=&quot;com.howtodoinjava.common.Person&quot; &gt;</span><br><span class="line">    &lt;property  /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>Spring 会知道要自动装配哪个 person bean 么? 不会的，但是运行上面的示例时，会抛出下面的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException:</span><br><span class="line">    No unique bean of type [com.howtodoinjava.common.Person] is defined:</span><br><span class="line">        expected single matching bean but found 2: [personA, personB]</span><br></pre></td></tr></table></figure>
<p>要解决上面的问题，需要使用 @Quanlifier 注解来告诉 Spring 容器要装配哪个 bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Customer</span><br><span class="line">&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;personA&quot;)</span><br><span class="line">    private Person person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="22、构造方法注入和设值注入有什么区别"><a href="#22、构造方法注入和设值注入有什么区别" class="headerlink" title="22、构造方法注入和设值注入有什么区别?"></a><a></a>22、构造方法注入和设值注入有什么区别?</h4><p>请注意以下明显的区别：</p>
<p>1、在设值注入方法支持大部分的依赖注入，如果我们仅需要注入 int、string 和 long 型的变量，我们不要用设值的方法注入。</p>
<p>对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，</p>
<p>因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。</p>
<p>2、设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，</p>
<p>那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。</p>
<p>3、在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。</p>
<p>而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。</p>
<p>4、在设值注入时如果对象 A 和对象 B 互相依赖，在创建对象 A 时 Spring 会抛出 sObjectCurrentlyInCreationException 异常，</p>
<p>因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题，</p>
<p>因对象的设值方法是在对象被创建之前被调用的。</p>
<p><a></a></p>
<h4 id="23、Spring-框架中有哪些不同类型的事件"><a href="#23、Spring-框架中有哪些不同类型的事件" class="headerlink" title="23、Spring 框架中有哪些不同类型的事件?"></a><a></a>23、Spring 框架中有哪些不同类型的事件?</h4><p>Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。</p>
<p>我们可以创建 bean 用来监听在 ApplicationContext 中发布的事件。ApplicationEvent 类和在 ApplicationContext 接口中处理的事件,</p>
<p>如果一个 bean 实现了 ApplicationListener 接口，当一个 ApplicationEvent 被发布以后，bean 会自动被通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt;</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationEvent applicationEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        //process event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 提供了以下 5 中标准的事件：</p>
<p>1、上下文更新事件 (ContextRefreshedEvent)：该事件会在 ApplicationContext 被初始化或者更新时发布。</p>
<p>也可以在调用 ConfigurableApplicationContext 接口中的 refresh() 方法时被触发。</p>
<p>2、上下文开始事件 (ContextStartedEvent)：当容器调用 ConfigurableApplicationContext 的 Start()</p>
<p>方法开始 / 重新开始容器时触发该事件。</p>
<p>3、上下文停止事件 (ContextStoppedEvent)：当容器调用 ConfigurableApplicationContext 的 Stop()</p>
<p>方法停止容器时触发该事件。</p>
<p>4、上下文关闭事件 (ContextClosedEvent)：当 ApplicationContext 被关闭时触发该事件。</p>
<p>容器被关闭时，其管理的所有单例 Bean 都被销毁。</p>
<p>5、请求处理事件 (RequestHandledEvent)：在 Web 应用中，当一个 http 请求（request）结束触发该事件。</p>
<p>除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CustomApplicationEvent extends ApplicationEvent</span><br><span class="line">&#123;</span><br><span class="line">    public CustomApplicationEvent ( Object source, final String msg )</span><br><span class="line">    &#123;</span><br><span class="line">        super(source);</span><br><span class="line">        System.out.println(&quot;Created a Custom event&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了监听这个事件，还需要创建一个监听器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CustomEventListener implements ApplicationListener &lt; CustomApplicationEvent &gt;</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123;</span><br><span class="line">        //handle event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后通过 applicationContext 接口的 publishEvent() 方法来发布自定义事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext, &quot;Test message&quot;);</span><br><span class="line">applicationContext.publishEvent(customEvent);</span><br></pre></td></tr></table></figure>
<p><a></a></p>
<h4 id="24、FileSystemResource-和-ClassPathResource-有何区别"><a href="#24、FileSystemResource-和-ClassPathResource-有何区别" class="headerlink" title="24、FileSystemResource 和 ClassPathResource 有何区别?"></a><a></a>24、FileSystemResource 和 ClassPathResource 有何区别?</h4><p>在 FileSystemResource 中需要给出 spring-config.xml 文件在你项目中的相对路径或者绝对路径。</p>
<p>在 ClassPathResource 中 spring 会在 ClassPath 中自动搜寻配置文件，所以要把 ClassPathResource 文件放在 ClassPath 下。</p>
<p>如果将 spring-config.xml 保存在了 src 文件夹下的话，只需给出配置文件的名称即可，因为 src 文件夹是默认。</p>
<p>简而言之，ClassPathResource 在环境变量中读取配置文件，FileSystemResource 在配置文件中读取配置文件。</p>
<p><a></a></p>
<h4 id="25、Spring-框架中都用到了哪些设计模式？"><a href="#25、Spring-框架中都用到了哪些设计模式？" class="headerlink" title="25、Spring 框架中都用到了哪些设计模式？"></a><a></a>25、Spring 框架中都用到了哪些设计模式？</h4><p>Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p>
<p>1、代理模式—在 AOP 和 remoting 中被用的比较多。</p>
<p>2、单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。</p>
<p>3、模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p>
<p>4、前端控制器—Spring 提供了 DispatcherServlet 来对请求进行分发。</p>
<p>5、视图帮助 (View Helper)—Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</p>
<p>6、依赖注入—贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</p>
<p>7、工厂模式—BeanFactory 用来创建对象的实例。</p>
<hr>
<blockquote>
<p>原文:<br><a href="http://blog.csdn.net/a724888/article/details/68925151" target="_blank" rel="noopener">http://blog.csdn.net/a724888/article/details/68925151</a></p>
</blockquote>

      
    </div>
    
    
    


     
    
      <div>
        
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>

      </div>
    


    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    CloudPai
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://cloudpai.site/2018/03/17/2018-03-17-1/" title="Spring 知识点总结69题+25题">http://cloudpai.site/2018/03/17/2018-03-17-1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    




    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring/" rel="tag"><i class="fa fa-tag"></i> Spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/17/2018-03-17/" rel="next" title="Spring实战笔记五">
                <i class="fa fa-chevron-left"></i> Spring实战笔记五
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/17/2018-03-17-2/" rel="prev" title="经典Java面试题95道">
                经典Java面试题95道 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>




  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg"
                alt="CloudPai" />
            
              <p class="site-author-name" itemprop="name">CloudPai</p>
              <p class="site-description motion-element" itemprop="description">加油(๑•̀ㅂ•́)و✧加油</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">182</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=240 src="//music.163.com/outchain/player?type=0&id=2113726971&auto=0&height=430"></iframe>
</div>
<!-- 459004290 -->




            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">89</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudPai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liupai024@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/57965969/doulists/all" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-book"></i>豆瓣</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/cloudPai/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-edit"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dlut.edu.cn/" title="DUT" target="_blank">DUT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bupt.edu.cn/" title="BUPT" target="_blank">BUPT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://campus.alibaba.com/index.htm" title="Alibaba Group" target="_blank">Alibaba Group</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-知识点总结69题"><span class="nav-text">Spring 知识点总结69题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring面试总结25题"><span class="nav-text">spring面试总结25题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2、使用-Spring-框架能带来哪些好处？"><span class="nav-text">2、使用 Spring 框架能带来哪些好处？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、什么是控制反转-IOC-什么是依赖注入"><span class="nav-text">3、什么是控制反转 (IOC)? 什么是依赖注入?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、请解释下-Spring-框架中的-IoC"><span class="nav-text">4、请解释下 Spring 框架中的 IoC?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、BeanFactory-和-ApplicationContext-有什么区别"><span class="nav-text">5、BeanFactory 和 ApplicationContext 有什么区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、Spring-有几种配置方式"><span class="nav-text">6、Spring 有几种配置方式?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、如何用基于-XML-配置的方式配置-Spring"><span class="nav-text">7、如何用基于 XML 配置的方式配置 Spring?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8、如何用基于-Java-配置的方式配置-Spring"><span class="nav-text">8、如何用基于 Java 配置的方式配置 Spring?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9、怎样用注解的方式配置-Spring？"><span class="nav-text">9、怎样用注解的方式配置 Spring？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10、请解释-Spring-Bean-的生命周期"><span class="nav-text">10、请解释 Spring Bean 的生命周期?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11、Spring-Bean-的作用域之间有什么区别？"><span class="nav-text">11、Spring Bean 的作用域之间有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12、什么是-Spring-inner-beans"><span class="nav-text">12、什么是 Spring inner beans?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13、Spring-框架中的单例-Beans-是线程安全的么"><span class="nav-text">13、Spring 框架中的单例 Beans 是线程安全的么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14、请举例说明如何在-Spring-中注入一个-Java-Collection"><span class="nav-text">14、请举例说明如何在 Spring 中注入一个 Java Collection?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15、如何向-Spring-Bean-中注入一个-Java-util-Properties"><span class="nav-text">15、如何向 Spring Bean 中注入一个 Java.util.Properties?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16、请解释-Spring-Bean-的自动装配"><span class="nav-text">16、请解释 Spring Bean 的自动装配?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17、请解释自动装配模式的区别"><span class="nav-text">17、请解释自动装配模式的区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18、如何开启基于注解的自动装配？"><span class="nav-text">18、如何开启基于注解的自动装配？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19、请举例解释-Required-注解"><span class="nav-text">19、请举例解释 @Required 注解?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20、请举例解释-Autowired-注解"><span class="nav-text">20、请举例解释 @Autowired 注解?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21、请举例说明-Qualifier-注解"><span class="nav-text">21、请举例说明 @Qualifier 注解?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22、构造方法注入和设值注入有什么区别"><span class="nav-text">22、构造方法注入和设值注入有什么区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23、Spring-框架中有哪些不同类型的事件"><span class="nav-text">23、Spring 框架中有哪些不同类型的事件?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24、FileSystemResource-和-ClassPathResource-有何区别"><span class="nav-text">24、FileSystemResource 和 ClassPathResource 有何区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25、Spring-框架中都用到了哪些设计模式？"><span class="nav-text">25、Spring 框架中都用到了哪些设计模式？</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CloudPai</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">786.0k</span>
  
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">  </span>
</span>
</div>







  <div class="theme-info">&#12288;主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://cloudpai.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://cloudpai.site/2018/03/17/2018-03-17-1/';
          this.page.identifier = '2018/03/17/2018-03-17-1/';
          this.page.title = 'Spring 知识点总结69题+25题';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://cloudpai.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!-- <!-- <script src="https://cdn.bootcss.com/aplayer/1.6.0/APlayer.min.js"></script>

<script src="https://api.i-meto.com/music/player.js"></script> --> -->
  
  <!--移动端判断，是否引入背景-->
  <script>
  var browser={  
      versions:function(){   
             var u = navigator.userAgent, app = navigator.appVersion;   
             return {//移动终端浏览器版本信息
                  trident: u.indexOf('Trident') > -1, //IE内核
                  presto: u.indexOf('Presto') > -1, //opera内核
                  webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                  gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                  mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                  ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                  android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                  iPhone: u.indexOf('iPhone') > -1 , //是否为iPhone或者QQHD浏览器
                  iPad: u.indexOf('iPad') > -1, //是否iPad
                  webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
              };  
           }(),  
           language:(navigator.browserLanguage || navigator.language).toLowerCase()  
  }   
    if(browser.versions.mobile || browser.versions.ios || browser.versions.android ||   
      browser.versions.iPhone || browser.versions.iPad){        
               
    }else{
    document.write("<script type=\'text/javascript\'  src=\'/js/src/particle.js\'><\/script>");
    }
  </script>

  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>
</html>
