<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,并发," />





  <link rel="alternate" href="/atom.xml" title="CloudPai" type="application/atom+xml" />






<meta name="description" content="01 框架概要之前，在 “Java 集合系列目录 (Category)“中，讲解了 Java 集合包中的各个类。接下来，将展开对 JUC 包中的集合进行学习。在学习之前，先温习一下”Java 集合包 “。本章内容包括：Java 集合包JUC 中的集合类 Java 集合包在 “Java 集合系列 01 之 总体框架” 中，介绍 java 集合的架构。主体内容包括 Collection 集合和 Ma">
<meta name="keywords" content="Java,并发">
<meta property="og:type" content="article">
<meta property="og:title" content="java多线程系列四：JUC集合">
<meta property="og:url" content="http://cloudpai.site/2018/03/24/2018-03-24-2/index.html">
<meta property="og:site_name" content="CloudPai">
<meta property="og:description" content="01 框架概要之前，在 “Java 集合系列目录 (Category)“中，讲解了 Java 集合包中的各个类。接下来，将展开对 JUC 包中的集合进行学习。在学习之前，先温习一下”Java 集合包 “。本章内容包括：Java 集合包JUC 中的集合类 Java 集合包在 “Java 集合系列 01 之 总体框架” 中，介绍 java 集合的架构。主体内容包括 Collection 集合和 Ma">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219010957077.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219011603468.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219011850353.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219017612777.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219025788408.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219030610058.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219438220629.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219438488674.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219438780072.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219446573198.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219449691395.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219464896847.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219472408332.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219479687651.jpg">
<meta property="og:updated_time" content="2018-03-31T09:49:00.133Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java多线程系列四：JUC集合">
<meta name="twitter:description" content="01 框架概要之前，在 “Java 集合系列目录 (Category)“中，讲解了 Java 集合包中的各个类。接下来，将展开对 JUC 包中的集合进行学习。在学习之前，先温习一下”Java 集合包 “。本章内容包括：Java 集合包JUC 中的集合类 Java 集合包在 “Java 集合系列 01 之 总体框架” 中，介绍 java 集合的架构。主体内容包括 Collection 集合和 Ma">
<meta name="twitter:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219010957077.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'TZAS2SFOJR',
      apiKey: 'e2a9cd036eede8026382b302001ec261',
      indexName: 'cloudpai_blogs_search',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cloudpai.site/2018/03/24/2018-03-24-2/"/>





  <title>java多线程系列四：JUC集合 | CloudPai</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-114643720-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CloudPai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间轴
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>




 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cloudpai.site/2018/03/24/2018-03-24-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CloudPai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudPai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java多线程系列四：JUC集合</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T21:55:31+08:00">
                2018-03-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-03-31T17:49:00+08:00">
                2018-03-31
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/24/2018-03-24-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/24/2018-03-24-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  34,050
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  147
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="/assets/js/APlayer.min.js"> </script><h1 id="01-框架"><a href="#01-框架" class="headerlink" title="01 框架"></a>01 框架</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>之前，在 “<a href="http://www.cnblogs.com/skywang12345/p/3323085.html" target="_blank" rel="noopener">Java 集合系列目录 (Category)</a>“中，讲解了 Java 集合包中的各个类。接下来，将展开对 JUC 包中的集合进行学习。在学习之前，先温习一下”Java 集合包 “。本章内容包括：<br><a href="#a1">Java 集合包</a><br><a href="#a2">JUC 中的集合类</a></p>
<h2 id="Java-集合包"><a href="#Java-集合包" class="headerlink" title="Java 集合包"></a><strong><a></a>Java 集合包</strong></h2><p>在 “<a href="http://www.cnblogs.com/skywang12345/p/3308498.html" target="_blank" rel="noopener">Java 集合系列 01 之 总体框架</a>” 中，介绍 java 集合的架构。主体内容包括 Collection 集合和 Map 类；而 Collection 集合又可以划分为 List(队列) 和 Set(集合)。</p>
<p><strong>1. List 的实现类主要有: LinkedList, ArrayList, Vector, Stack。</strong></p>
<p>(01) <a href="http://www.cnblogs.com/skywang12345/p/3308807.html" target="_blank" rel="noopener">LinkedList</a> 是双向链表实现的双端队列；它不是线程安全的，只适用于单线程。<br>(02) <a href="http://www.cnblogs.com/skywang12345/p/3308556.html" target="_blank" rel="noopener">ArrayList</a> 是数组实现的队列，它是一个动态数组；它也不是线程安全的，只适用于单线程。<br>(03) <a href="http://www.cnblogs.com/skywang12345/p/3308833.html" target="_blank" rel="noopener">Vector</a> 是数组实现的矢量队列，它也一个动态数组；不过和 ArrayList 不同的是，<strong>Vector 是线程安全的，它支持并发。</strong><br>(04) <a href="http://www.cnblogs.com/skywang12345/p/3308852.html" target="_blank" rel="noopener">Stack</a> 是 Vector 实现的栈；和 <strong>Vector 一样，它也是线程安全的。</strong></p>
<p><strong>2. Set 的实现类主要有: HastSet 和 TreeSet。</strong></p>
<p>(01) <a href="http://www.cnblogs.com/skywang12345/p/3311252.html" target="_blank" rel="noopener">HashSet</a> 是一个没有重复元素的集合，它通过 HashMap 实现的；HashSet 不是线程安全的，只适用于单线程。<br>(02) <a href="http://www.cnblogs.com/skywang12345/p/3311268.html" target="_blank" rel="noopener">TreeSet</a> 也是一个没有重复元素的集合，不过和 HashSet 不同的是，TreeSet 中的元素是有序的；它是通过 TreeMap 实现的；TreeSet 也不是线程安全的，只适用于单线程。</p>
<p><strong>3.Map 的实现类主要有: HashMap，WeakHashMap, Hashtable 和 TreeMap。</strong></p>
<p>(01) <a href="http://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="noopener">HashMap</a> 是存储 “键 - 值对” 的哈希表；它不是线程安全的，只适用于单线程。<br>(02) <a href="http://www.cnblogs.com/skywang12345/p/3311092.html" target="_blank" rel="noopener">WeakHashMap</a> 是也是哈希表；和 HashMap 不同的是，HashMap 的 “键” 是强引用类型，而 WeakHashMap 的 “键” 是弱引用类型，也就是说当 WeakHashMap 中的某个键不再正常使用时，会被从 WeakHashMap 中被自动移除。WeakHashMap 也不是线程安全的，只适用于单线程。<br>(03) <a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="noopener">Hashtable</a> 也是哈希表；和 HashMap 不同的是，<strong>Hashtable 是线程安全的，支持并发。</strong><br>(04) <a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="noopener">TreeMap</a> 也是哈希表，不过 TreeMap 中的 “键 - 值对” 是有序的，它是通过 R-B Tree(红黑树)实现的；TreeMap 不是线程安全的，只适用于单线程。<br>更多关于这些集合类的介绍，可以参考 “Java 集合系列目录 (Category)”。</p>
<p>为了方便，我们将前面介绍集合类统称为”<strong>java 集合包</strong> “。java 集合包大多是 “非线程安全的”，<strong>虽然可以通过 Collections 工具类中的方法获取 java 集合包对应的同步类，但是这些同步类的并发效率并不是很高</strong>。为了更好的支持高并发任务，并发大师 Doug Lea 在 JUC(java.util.concurrent) 包中添加了 java 集合包中单线程类的对应的支持高并发的类。<em>例如，ArrayList 对应的高并发类是 CopyOnWriteArrayList，HashMap 对应的高并发类是 ConcurrentHashMap，等等。</em></p>
<p>JUC 包在添加”java 集合包 “对应的高并发类时，为了保持 API 接口的一致性，使用了”Java 集合包 “中的框架。<em>例如，CopyOnWriteArrayList 实现了 “Java 集合包” 中的 List 接口，HashMap 继承了 “java 集合包” 中的 AbstractMap 类，等等。</em>得益于 “JUC 包使用了 Java 集合包中的类”，如果我们了解了 Java 集合包中的类的思想之后，理解 JUC 包中的类也相对容易；<strong>理解时，最大的难点是，对 JUC 包是如何添加对“高并发” 的支持的</strong>！</p>
<h2 id="JUC-中的集合类"><a href="#JUC-中的集合类" class="headerlink" title="JUC 中的集合类"></a><strong><a></a>JUC 中的集合类</strong></h2><p>下面，我们先了解 JUC 包中集合类的框架；为了方便讲诉，我将 JUC 包中的集合类划分为 3 部分来进行说明。在简单的了解 JUC 包中集合类的框架之后，后面的章节再逐步对各个类进行介绍。</p>
<p><strong>1. List 和 Set</strong></p>
<p>JUC 集合包中的 List 和 Set 实现类包括: CopyOnWriteArrayList, CopyOnWriteArraySet 和 ConcurrentSkipListSet。ConcurrentSkipListSet 稍后在说明 Map 时再说明，CopyOnWriteArrayList 和 CopyOnWriteArraySet 的框架如下图所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219010957077.jpg" alt=""></p>
<p>(01) CopyOnWriteArrayList 相当于线程安全的 ArrayList，它实现了 List 接口。CopyOnWriteArrayList 是支持高并发的。<br>(02) CopyOnWriteArraySet 相当于线程安全的 HashSet，它继承于 AbstractSet 类。CopyOnWriteArraySet 内部包含一个 CopyOnWriteArrayList 对象，它是通过 CopyOnWriteArrayList 实现的。</p>
<p><strong>2. Map</strong></p>
<p>JUC 集合包中 Map 的实现类包括: ConcurrentHashMap 和 ConcurrentSkipListMap。它们的框架如下图所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219011603468.jpg" alt=""><br>(01) ConcurrentHashMap 是线程安全的哈希表 (相当于线程安全的 HashMap)；它继承于 AbstractMap 类，并且实现 ConcurrentMap 接口。ConcurrentHashMap 是通过“锁分段” 来实现的，它支持并发。<br>(02) ConcurrentSkipListMap 是线程安全的有序的哈希表 (相当于线程安全的 TreeMap); 它继承于 AbstractMap 类，并且实现 ConcurrentNavigableMap 接口。ConcurrentSkipListMap 是通过“跳表” 来实现的，它支持并发。<br>(03) ConcurrentSkipListSet 是线程安全的有序的集合 (相当于线程安全的 TreeSet)；它继承于 AbstractSet，并实现了 NavigableSet 接口。ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，它也支持并发。</p>
<p><strong>3. Queue</strong></p>
<p>JUC 集合包中 Queue 的实现类包括: ArrayBlockingQueue, LinkedBlockingQueue, LinkedBlockingDeque, ConcurrentLinkedQueue 和 ConcurrentLinkedDeque。它们的框架如下图所示：<br><img src="http://p4lmrb1gp.bkt.clouddn.com/15219011850353.jpg" alt=""></p>
<p>(01) ArrayBlockingQueue 是数组实现的线程安全的有界的阻塞队列。<br>(02) LinkedBlockingQueue 是单向链表实现的 (指定大小) 阻塞队列，该队列按 FIFO（先进先出）排序元素。<br>(03) LinkedBlockingDeque 是双向链表实现的 (指定大小) 双向并发阻塞队列，该阻塞队列同时支持 FIFO 和 FILO 两种操作方式。<br>(04) ConcurrentLinkedQueue 是单向链表实现的无界队列，该队列按 FIFO（先进先出）排序元素。<br>(05) ConcurrentLinkedDeque 是双向链表实现的无界队列，该队列同时支持 FIFO 和 FILO 两种操作方式。</p>
<p>接下来，将逐个对 JUC 包中的集合类进行学习。</p>
<hr>
<h1 id="02-CopyOnWriteArrayList"><a href="#02-CopyOnWriteArrayList" class="headerlink" title="02 CopyOnWriteArrayList"></a>02 CopyOnWriteArrayList</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章是 “<strong><a href="http://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="noopener">JUC 系列</a></strong> “ 的 CopyOnWriteArrayList 篇。接下来，会先对 CopyOnWriteArrayList 进行基本介绍，然后再说明它的原理，接着通过代码去分析，最后通过示例更进一步的了解 CopyOnWriteArrayList。内容包括：<br><a href="#p1">CopyOnWriteArrayList 介绍</a> <a href="#p3">CopyOnWriteArrayList 原理和数据结构</a><br><a href="#p2">CopyOnWriteArrayList 函数列表</a><br><a href="#p4">CopyOnWriteArrayList 源码分析 (JDK1.7.0_40 版本)</a><br><a href="#p5">CopyOnWriteArrayList 示例</a></p>
<h2 id="CopyOnWriteArrayList-介绍"><a href="#CopyOnWriteArrayList-介绍" class="headerlink" title="CopyOnWriteArrayList 介绍"></a><strong><a></a>CopyOnWriteArrayList 介绍</strong></h2><p>它相当于线程安全的 <a href="http://www.cnblogs.com/skywang12345/p/3308556.html" target="_blank" rel="noopener">ArrayList</a>。和 ArrayList 一样，它是个可变数组；但是和 ArrayList 不同的时，它具有以下特性：<br>1. 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。<br>2. 它是线程安全的。<br>3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。<br>4. 迭代器支持 hasNext(), next() 等不可变操作，但不支持可变 remove() 等操作。<br>5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p>
<p>建议：在学习 CopyOnWriteArraySet 之前，先通过 “<a href="http://www.cnblogs.com/skywang12345/p/3308556.html" target="_blank" rel="noopener">Java 集合系列 03 之 ArrayList 详细介绍 (源码解析) 和使用示例</a> “ 对 ArrayList 进行了解！</p>
<h2 id="CopyOnWriteArrayList-原理和数据结构"><a href="#CopyOnWriteArrayList-原理和数据结构" class="headerlink" title="CopyOnWriteArrayList 原理和数据结构"></a><strong><a></a>CopyOnWriteArrayList 原理和数据结构</strong></h2><p>CopyOnWriteArrayList 的数据结构，如下图所示：<br><img src="http://p4lmrb1gp.bkt.clouddn.com/15219017612777.jpg" alt=""></p>
<p><strong>说明</strong>：<br>1. CopyOnWriteArrayList 实现了 List 接口，因此它是一个队列。<br>2. CopyOnWriteArrayList 包含了成员 lock。每一个 CopyOnWriteArrayList 都和一个互斥锁 lock 绑定，通过 lock，实现了对 CopyOnWriteArrayList 的互斥访问。<br>3. CopyOnWriteArrayList 包含了成员 array 数组，这说明 CopyOnWriteArrayList 本质上通过数组实现的。</p>
<p>下面从 “动态数组” 和“线程安全”两个方面进一步对 CopyOnWriteArrayList 的原理进行说明。</p>
<ol>
<li><strong>CopyOnWriteArrayList 的 “动态数组” 机制</strong> – 它内部有个 “volatile 数组”(array) 来保持数据。在 “添加 / 修改 / 删除” 数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给 “volatile 数组”。这就是它叫做 CopyOnWriteArrayList 的原因！CopyOnWriteArrayList 就是通过这种方式实现的动态数组；不过正由于它在“添加 / 修改 / 删除” 数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList 效率很<br>低；但是单单只是进行遍历查找的话，效率比较高。</li>
<li><strong>CopyOnWriteArrayList 的 “线程安全” 机制</strong> – 是通过 volatile 和互斥锁来实现的。(01) CopyOnWriteArrayList 是通过 <strong>“volatile 数组” 来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 volatile 变量最后的写入</strong>；就这样，通过 volatile 提供了 “<strong>读取到的数据总是最新的</strong>” 这个机制的<br>保证。(02) CopyOnWriteArrayList 通过互斥锁来保护数据。在 “添加 / 修改 / 删除” 数据时，会<strong>先 “获取互斥锁”，再修改完毕之后，先将数据更新到“volatile 数组” 中，然后再“释放互斥锁”</strong>；这样，就达到了保护数据的目的。 </li>
</ol>
<h2 id="CopyOnWriteArrayList-函数列表"><a href="#CopyOnWriteArrayList-函数列表" class="headerlink" title="CopyOnWriteArrayList 函数列表"></a><strong><a></a>CopyOnWriteArrayList 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空列表。</span></span><br><span class="line">CopyOnWriteArrayList()</span><br><span class="line"><span class="comment">// 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。</span></span><br><span class="line">CopyOnWriteArrayList(Collection&lt;? extends E&gt; c)</span><br><span class="line"><span class="comment">// CopyOnWriteArrayList(E[] toCopyIn)</span></span><br><span class="line">创建一个保存给定数组的副本的列表。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定元素添加到此列表的尾部。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 在此列表的指定位置上插入指定元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从指定位置开始，将指定 collection 的所有元素插入此列表。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addAllAbsent</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 添加元素（如果不存在）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此列表移除所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此列表的浅表副本。</span></span></span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此列表包含指定的元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此列表包含指定 collection 的所有元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较指定对象与此列表的相等性。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回列表中指定位置的元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此列表的哈希码值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此列表不包含任何元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回以恰当顺序在此列表元素上进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(E e, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此列表元素的列表迭代器（按适当顺序）。</span></span></span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。</span></span></span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除此列表指定位置上的元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此列表移除第一次出现的指定元素（如果存在）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此列表移除所有包含在指定 collection 中的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 只保留此列表中包含在指定 collection 中的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 用指定的元素替代此列表指定位置上的元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此列表中的元素数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。</span></span></span><br><span class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此列表的字符串表示形式。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="CopyOnWriteArrayList-源码分析-JDK1-7-0-40-版本"><a href="#CopyOnWriteArrayList-源码分析-JDK1-7-0-40-版本" class="headerlink" title="CopyOnWriteArrayList 源码分析 (JDK1.7.0_40 版本)"></a><strong><a></a>CopyOnWriteArrayList 源码分析 (JDK1.7.0_40 版本)</strong></h2><p>JDK1.7.0_40 版本中 CopyOnWriteArrayList.java 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/CopyOnWriteArrayList.java" target="_blank" rel="noopener">CopyOnWriteArrayList.java 的完整源码</a></p>
<p>下面我们从 “<strong>创建</strong>，<strong>添加</strong>，<strong>删除</strong>，<strong>获取</strong>，<strong>遍历</strong>” 这 5 个方面去分析 CopyOnWriteArrayList 的原理。</p>
<p><strong>1. 创建</strong></p>
<p>CopyOnWriteArrayList 共 3 个构造函数。它们的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">        elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：这 3 个构造函数都调用了 setArray()，setArray() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：setArray() 的作用是给 array 赋值；其中，array 是 volatile transient Object[] 类型，即 array 是 “volatile 数组”。<br>关于 volatile 关键字，我们知道 “volatile 能让变量变得可见”，即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。正在由于这种特性，每次更新了“volatile 数组” 之后，其它线程都能看到对它所做的更新。<br>关于 transient 关键字，它是在序列化中才起作用，transient 变量不会被自动序列化。transient 不是本文关注的重点，了解即可。<br>关于 transient 的更多内容，请参考：<a href="http://www.cnblogs.com/skywang12345/p/io_06.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/io_06.html</a></p>
<p><strong>2. 添加</strong></p>
<p>以 add(E e)为例，来对 “CopyOnWriteArrayList 的添加操作” 进行说明。下面是 add(E e)的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取“锁”</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原始”volatile数组“中的数据和数据长度。</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 新建一个数组newElements，并将原始数据拷贝到newElements中；</span></span><br><span class="line">        <span class="comment">// newElements数组的长度=“原始数组的长度”+1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将“新增加的元素”保存到newElements中。</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将newElements赋值给”volatile数组“。</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“锁”</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：add(E e) 的作用就是将数据 e 添加到”volatile 数组 “中。它的实现方式是，新建一个数组，接着将原始的”volatile 数组 “的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile 数组 “。<br>在 add(E e) 中有两点需要关注。<br>        第一，在” 添加操作 “开始前，获取独占锁 (lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁 (lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！lock 的定义如下：</p>
<p>transient final ReentrantLock lock = new ReentrantLock();</p>
<p>关于 ReentrantLock 的更多内容，可以参考：<a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a><br>        第二，操作完毕时，会通过 setArray()来更新”volatile 数组 “。而且，前面我们提过” 即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入“；这样，每次添加元素之后，其它线程都能看到新添加的元素。</p>
<p><strong>3. 获取</strong></p>
<p>以 get(int index)为例，来对 “CopyOnWriteArrayList 的删除操作” 进行说明。下面是 get(int index)的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：get(int index) 的实现很简单，就是返回”volatile 数组 “中的第 index 个元素。</p>
<p><strong>4. 删除</strong></p>
<p>以 remove(int index)为例，来对 “CopyOnWriteArrayList 的删除操作” 进行说明。下面是 remove(int index)的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取“锁”</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原始”volatile数组“中的数据和数据长度。</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 获取elements数组中的第index个数据。</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。</span></span><br><span class="line">        <span class="comment">// 否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组“。</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“锁”</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：remove(int index)的作用就是将”volatile 数组 “中第 index 个元素删除。它的实现方式是，如果被删除的是最后一个元素，则直接通过 Arrays.copyOf() 进行处理，而不需要新建数组。否则，新建数组，然后将”volatile 数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile 数组“。<br>         和 add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是 “；并且” 在操作完成时，会通过将数据更新到 volatile 数组中“。</p>
<p><strong>5. 遍历</strong></p>
<p>以 iterator()为例，来对 “CopyOnWriteArrayList 的遍历操作” 进行说明。下面是 iterator()的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：iterator() 会返回 COWIterator 对象。</p>
<p>COWIterator 实现额 ListIterator 接口，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一个元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：COWIterator 不支持修改元素的操作。例如，对于 remove(),set(),add() 等操作，COWIterator 都会抛出异常！<br>另外，需要提到的一点是，CopyOnWriteArrayList 返回迭代器不会抛出 ConcurrentModificationException 异常，即它不是 fail-fast 机制的！<br>关于 fail-fast 机制，可以参考 “<a href="http://www.cnblogs.com/skywang12345/p/3308762.html" target="_blank" rel="noopener">Java 集合系列 04 之 fail-fast 总结 (通过 ArrayList 来说明 fail-fast 的原理、解决办法)</a>”。</p>
<h3 id="CopyOnWriteArrayList-示例"><a href="#CopyOnWriteArrayList-示例" class="headerlink" title="CopyOnWriteArrayList 示例"></a><a></a>CopyOnWriteArrayList 示例</h3><p>下面，我们通过一个例子去对比 ArrayList 和 CopyOnWriteArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   CopyOnWriteArrayList是“线程安全”的动态数组，而ArrayList是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历list”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当list是CopyOnWriteArrayList对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当list是ArrayList对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> list是ArrayList对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 同时启动两个线程对list进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"ta"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"tb"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        Iterator iter = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "-" + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName()+<span class="string">"-"</span>+i;</span><br><span class="line">                list.add(val);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历List。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ta-1, tb-1, ta-1, </span><br><span class="line">tb-1, </span><br><span class="line">ta-1, ta-1, tb-1, tb-1, tb-2, </span><br><span class="line">tb-2, ta-1, ta-2, </span><br><span class="line">tb-1, ta-1, tb-2, tb-1, ta-2, tb-2, tb-3, </span><br><span class="line">ta-2, ta-1, tb-3, tb-1, ta-3, </span><br><span class="line">tb-2, ta-1, ta-2, tb-1, tb-3, tb-2, ta-3, ta-2, tb-4, </span><br><span class="line">tb-3, ta-1, ta-3, tb-1, tb-4, tb-2, ta-4, </span><br><span class="line">ta-2, ta-1, tb-3, tb-1, ta-3, tb-2, tb-4, ta-2, ta-4, tb-3, tb-5, </span><br><span class="line">ta-3, ta-1, tb-4, tb-1, ta-4, tb-2, tb-5, ta-2, ta-5, </span><br><span class="line">tb-3, ta-1, ta-3, tb-1, tb-4, tb-2, ta-4, ta-2, tb-5, tb-3, ta-5, ta-3, tb-6, </span><br><span class="line">tb-4, ta-4, tb-5, ta-5, tb-6, ta-6,</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：如果将源码中的 list 改成 ArrayList 对象时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<h1 id="03-CopyOnWriteArraySet"><a href="#03-CopyOnWriteArraySet" class="headerlink" title="03 CopyOnWriteArraySet"></a>03 CopyOnWriteArraySet</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章是 <strong><a href="http://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="noopener">JUC 系列</a></strong>中的 CopyOnWriteArraySet 篇。接下来，会先对 CopyOnWriteArraySet 进行基本介绍，然后再说明它的原理，接着通过代码去分析，最后通过示例更进一步的了解 CopyOnWriteArraySet。内容包括：<br><a href="#p1">CopyOnWriteArraySet 介绍</a> <a href="#p3">CopyOnWriteArraySet 原理和数据结构</a><br><a href="#p2">CopyOnWriteArraySet 函数列表</a><br><a href="#p4">CopyOnWriteArraySet 源码 (JDK1.7.0_40 版本)</a><br><a href="#p5">CopyOnWriteArraySet 示例</a></p>
<h2 id="CopyOnWriteArraySet-介绍"><a href="#CopyOnWriteArraySet-介绍" class="headerlink" title="CopyOnWriteArraySet 介绍"></a><strong><a></a>CopyOnWriteArraySet 介绍</strong></h2><p>它是线程安全的无序的集合，可以将它理解成线程安全的 <a href="http://www.cnblogs.com/skywang12345/p/3311252.html" target="_blank" rel="noopener">HashSet</a>。有意思的是，CopyOnWriteArraySet 和 HashSet 虽然都继承于共同的父类 AbstractSet；但是，HashSet 是通过 <a href="http://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="noopener">“散列表</a> (HashMap)” 实现的，而 CopyOnWriteArraySet 则是通过 “<a href="http://www.cnblogs.com/skywang12345/p/3498483.html" target="_blank" rel="noopener">动态数组 (CopyOnWriteArrayList)</a>” 实现的，并不是散列表。<br>和 CopyOnWriteArrayList 类似，CopyOnWriteArraySet 具有以下特性：<br>1. 它最适合于具有以下特征的应用程序：Set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。<br>2. 它是线程安全的。<br>3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。<br>4. 迭代器支持 hasNext(), next() 等不可变操作，但不支持可变 remove() 等 操作。<br>5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p>
<p>建议：在学习 CopyOnWriteArraySet 之前，先通过 “<a href="http://www.cnblogs.com/skywang12345/p/3311252.html" target="_blank" rel="noopener">Java 集合系列 16 之 HashSet 详细介绍 (源码解析) 和使用示例</a> “ 对 HashSet 进行了解。</p>
<h2 id="CopyOnWriteArraySet-原理和数据结构"><a href="#CopyOnWriteArraySet-原理和数据结构" class="headerlink" title="CopyOnWriteArraySet 原理和数据结构"></a><strong><a></a>CopyOnWriteArraySet 原理和数据结构</strong></h2><p>CopyOnWriteArraySet 的数据结构，如下图所示：<br><img src="http://p4lmrb1gp.bkt.clouddn.com/15219025788408.jpg" alt=""></p>
<p><strong>说明</strong>：<br>  1. CopyOnWriteArraySet 继承于 <a href="http://www.cnblogs.com/skywang12345/p/3311136.html" target="_blank" rel="noopener">AbstractSet</a>，这就意味着它是一个集合。<br>  2. CopyOnWriteArraySet 包含 <a href="http://www.cnblogs.com/skywang12345/p/3498483.html#p4" target="_blank" rel="noopener">CopyOnWriteArrayList</a> 对象，它是通过 CopyOnWriteArrayList 实现的。而 CopyOnWriteArrayList 本质是个动态数组队列，<br>所以 CopyOnWriteArraySet 相当于通过通过动态数组实现的 “集合”！ CopyOnWriteArrayList 中允许有重复的元素；但是，CopyOnWriteArraySet 是一个集合，所以它不能有重复集合。因此，CopyOnWriteArrayList 额外提供了 addIfAbsent() 和 addAllAbsent()这两个添加元素的 API，通过这些 API 来添加元素时，只有当元素不存在时才执行添加操作！<br>   至于 CopyOnWriteArraySet 的 “线程安全” 机制，和 <a href="http://www.cnblogs.com/skywang12345/p/3498483.html" target="_blank" rel="noopener">CopyOnWriteArrayList</a> 一样，是通过 volatile 和互斥锁来实现的。这个在前一章节介绍 <a href="http://www.cnblogs.com/skywang12345/p/3498483.html" target="_blank" rel="noopener">CopyOnWriteArrayList</a> 时数据结构时，已经进行了说明，这里就不再重复叙述了。</p>
<h2 id="CopyOnWriteArraySet-函数列表"><a href="#CopyOnWriteArraySet-函数列表" class="headerlink" title="CopyOnWriteArraySet 函数列表"></a><strong><a></a>CopyOnWriteArraySet 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空 set。</span></span><br><span class="line">CopyOnWriteArraySet()</span><br><span class="line"><span class="comment">// 创建一个包含指定 collection 所有元素的 set。</span></span><br><span class="line">CopyOnWriteArraySet(Collection&lt;? extends E&gt; c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果指定元素并不存在于此 set 中，则添加它。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 中没有指定 collection 中的所有元素，则将它们都添加到此 set 中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除此 set 中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 包含指定元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 包含指定 collection 的所有元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较指定对象与此 set 的相等性。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 不包含任何元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回按照元素添加顺序在此 set 中包含的元素上进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果指定元素存在于此 set 中，则将其移除。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除此 set 中包含在指定 collection 中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 仅保留此 set 中那些包含在指定 collection 中的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中的元素数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个包含此 set 所有元素的数组。</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个包含此 set 所有元素的数组；返回数组的运行时类型是指定数组的类型。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="CopyOnWriteArraySet-源码-JDK1-7-0-40-版本"><a href="#CopyOnWriteArraySet-源码-JDK1-7-0-40-版本" class="headerlink" title="CopyOnWriteArraySet 源码 (JDK1.7.0_40 版本)"></a><strong><a></a>CopyOnWriteArraySet 源码 (JDK1.7.0_40 版本)</strong></h2><p>CopyOnWriteArraySet.java 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/CopyOnWriteArraySet.java" target="_blank" rel="noopener">CopyOnWriteArraySet.java 的完整源码</a></p>
<p>CopyOnWriteArraySet 是通过 CopyOnWriteArrayList 实现的，它的 API 基本上都是通过调用 CopyOnWriteArrayList 的 API 来实现的。相信对 CopyOnWriteArrayList 了解的话，对 CopyOnWriteArraySet 的了解是水到渠成的事；所以，这里就不再对 CopyOnWriteArraySet 的代码进行详细的解析了。若对 CopyOnWriteArrayList 不了解，请参考 “<a href="http://www.cnblogs.com/skywang12345/p/3498483.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 集合”02 之 CopyOnWriteArrayList</a>”。</p>
<h2 id="CopyOnWriteArraySet-示例"><a href="#CopyOnWriteArraySet-示例" class="headerlink" title="CopyOnWriteArraySet 示例"></a><strong><a></a>CopyOnWriteArraySet 示例</strong></h2><p>下面，我们通过一个例子去对比 HashSet 和 CopyOnWriteArraySet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   CopyOnWriteArraySet是“线程安全”的集合，而HashSet是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历集合set”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当set是CopyOnWriteArraySet对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当set是HashSet对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArraySetTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> set是HashSet对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static Set&lt;String&gt; set = new HashSet&lt;String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时启动两个线程对set进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"ta"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"tb"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        Iterator iter = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "-" + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName() + <span class="string">"-"</span> + (i%<span class="number">6</span>);</span><br><span class="line">                set.add(val);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历set。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ta-1, tb-1, ta-1, </span><br><span class="line">tb-1, ta-1, </span><br><span class="line">tb-1, ta-1, ta-2, </span><br><span class="line">tb-1, ta-1, ta-2, tb-1, tb-2, </span><br><span class="line">ta-2, ta-1, tb-2, tb-1, ta-3, </span><br><span class="line">ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, </span><br><span class="line">tb-2, ta-1, ta-3, tb-1, tb-3, ta-2, ta-4, </span><br><span class="line">tb-2, ta-1, ta-3, tb-1, tb-3, ta-2, ta-4, tb-2, tb-4, </span><br><span class="line">ta-3, ta-1, tb-3, tb-1, ta-4, ta-2, tb-4, tb-2, ta-5, </span><br><span class="line">ta-3, ta-1, tb-3, tb-1, ta-4, ta-2, tb-4, tb-2, ta-5, ta-3, tb-5, </span><br><span class="line">tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, </span><br><span class="line">tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, tb-0, </span><br><span class="line">ta-4, ta-1, tb-4, tb-1, ta-5, ta-2, tb-5, tb-2, ta-0, ta-3, tb-0, </span><br><span class="line">tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-5, ta-0, tb-0, </span><br><span class="line">ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-4, ta-3, tb-4, tb-3, ta-5, ta-4, tb-5, tb-4, ta-0, ta-5, tb-0, </span><br><span class="line">tb-5, ta-1, ta-0, tb-1, tb-0, </span><br><span class="line">ta-2, ta-1, tb-2, tb-1, ta-3, ta-2, tb-3, tb-2, ta-4, ta-3, tb-4, tb-3, ta-5, tb-5, ta-0, tb-0, </span><br><span class="line">ta-4, ta-1, tb-4, tb-1, ta-5, ta-2, tb-5, tb-2, ta-0, ta-3, tb-0, </span><br><span class="line">tb-3, ta-1, ta-4, tb-1, tb-4, ta-2, ta-5, tb-2, tb-5, ta-3, ta-0, tb-3, tb-0, </span><br><span class="line">ta-4, tb-4, ta-5, tb-5, ta-0, tb-0,</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：<br>由于 set 是集合对象，因此它不会包含重复的元素。<br>如果将源码中的 set 改成 HashSet 对象时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<h1 id="04-ConcurrentHashMap"><a href="#04-ConcurrentHashMap" class="headerlink" title="04 ConcurrentHashMap"></a>04 ConcurrentHashMap</h1><h2 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章是 <strong><a href="http://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="noopener">JUC 系列</a></strong>的 ConcurrentHashMap 篇。内容包括：<br><a href="#p1">ConcurrentHashMap 介绍</a> <a href="#p3">ConcurrentHashMap 原理和数据结构</a><br><a href="#p2">ConcurrentHashMap 函数列表</a><br><a href="#p4">ConcurrentHashMap 源码分析 (JDK1.7.0_40 版本)</a><br><a href="#p5">ConcurrentHashMap 示例</a></p>
<h2 id="ConcurrentHashMap-介绍"><a href="#ConcurrentHashMap-介绍" class="headerlink" title="ConcurrentHashMap 介绍"></a><strong><a></a>ConcurrentHashMap 介绍</strong></h2><p>ConcurrentHashMap 是线程安全的哈希表。<a href="http://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="noopener">HashMap</a>, <a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="noopener">Hashtable</a>, ConcurrentHashMap 之间的关联如下：</p>
<p><strong><a href="http://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="noopener">HashMap</a></strong> 是非线程安全的哈希表，常用于单线程程序中。</p>
<p><strong><a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="noopener">Hashtable</a></strong> 是线程安全的哈希表，它是通过 synchronized 来保证线程安全的；即，多线程通过同一个 “对象的同步锁” 来实现并发控制。<strong>Hashtable 在线程竞争激烈时，效率比较低(此时建议使用 ConcurrentHashMap)</strong>！因为当一个线程访问 Hashtable 的同步方法时，其它线程就访问 Hashtable 的同步方法时，可能会进入阻塞状态。</p>
<p>　　<strong>ConcurrentHashMap</strong> 是线程安全的哈希表，它是通过 “锁分段” 来保证线程安全的。ConcurrentHashMap 将哈希表分成许多片段(Segment)，每一个片段除了保存哈希表之外，本质上也是一个“可重入的互斥锁”(ReentrantLock)。多线程对同一个片段的访问，是互斥的；但是，<strong>对于不同片段的访问，却是可以同步进行的。</strong></p>
<p>关于 HashMap,Hashtable 以及 ReentrantLock 的更多内容，可以参考：</p>
<ol>
<li><a href="http://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="noopener">Java 集合系列 10 之 HashMap 详细介绍 (源码解析) 和使用示例</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="noopener">Java 集合系列 11 之 Hashtable 详细介绍 (源码解析) 和使用示例</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a></li>
</ol>
<h2 id="ConcurrentHashMap-原理和数据结构"><a href="#ConcurrentHashMap-原理和数据结构" class="headerlink" title="ConcurrentHashMap 原理和数据结构"></a><strong><a></a>ConcurrentHashMap 原理和数据结构</strong></h2><p>要想搞清 ConcurrentHashMap，必须先弄清楚它的数据结构：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219030610058.jpg" alt=""></p>
<p>  (01) ConcurrentHashMap 继承于 AbstractMap 抽象类。<br>  (02) Segment 是 ConcurrentHashMap 中的内部类，它就是 ConcurrentHashMap 中的 “锁分段” 对应的存储结构。ConcurrentHashMap 与 Segment 是组合关系，1 个 ConcurrentHashMap 对象包含若干个 Segment 对象。在代码中，这表现为 ConcurrentHashMap 类中存在 “Segment 数组” 成员。<br>  (03) Segment 类继承于 ReentrantLock 类，所以 Segment 本质上是一个可重入的互斥锁。<br>  (04) HashEntry 也是 ConcurrentHashMap 的内部类，是单向链表节点，存储着 key-value 键值对。Segment 与 HashEntry 是组合关系，Segment 类中存在 “HashEntry 数组” 成员，“HashEntry 数组”中的每个 HashEntry 就是一个单向链表。</p>
<p>  对于多线程访问对一个 “哈希表对象” 竞争资源，<strong>Hashtable 是通过一把锁来控制并发；而 ConcurrentHashMap 则是将哈希表分成许多片段，对于每一个片段分别通过一个互斥锁来控制并发</strong>。ConcurrentHashMap 对并发的控制更加细腻，它也更加适应于高并发场景！</p>
<h2 id="ConcurrentHashMap-函数列表"><a href="#ConcurrentHashMap-函数列表" class="headerlink" title="ConcurrentHashMap 函数列表"></a><strong><a></a>ConcurrentHashMap 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span></span><br><span class="line">ConcurrentHashMap()</span><br><span class="line"><span class="comment">// 创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射。</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="comment">// 创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (16) 的新的空映射。</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"><span class="comment">// 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span><br><span class="line"><span class="comment">// 构造一个与给定映射具有相同映射关系的新映射。</span></span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K,? extends V&gt; m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从该映射中移除所有映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 一种遗留方法，测试此表中是否有一些与指定值存在映射关系的键。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 测试指定对象是否为此表中的键。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此映射将一个或多个键映射到指定值，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此表中值的枚举。</span></span></span><br><span class="line"><span class="function">Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射所包含的映射关系的 Set 视图。</span></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回指定键所映射到的值，如果此映射不包含该键的映射关系，则返回 null。</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此映射不包含键-值映射关系，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此表中键的枚举。</span></span></span><br><span class="line"><span class="function">Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中包含的键的 Set 视图。</span></span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定键映射到此表中的指定值。</span></span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定映射中所有映射关系复制到此映射中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果指定键已经不再与某个值相关联，则将它与给定值关联。</span></span></span><br><span class="line"><span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此映射中移除键（及其相应的值）。</span></span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 只有目前将键的条目映射到给定值时，才移除该键的条目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 只有目前将键的条目映射到某一值时，才替换该键的条目。</span></span></span><br><span class="line"><span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 只有目前将键的条目映射到给定值时，才替换该键的条目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中的键-值映射关系数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中包含的值的 Collection 视图。</span></span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap-源码分析-JDK1-7-0-40-版本"><a href="#ConcurrentHashMap-源码分析-JDK1-7-0-40-版本" class="headerlink" title="ConcurrentHashMap 源码分析 (JDK1.7.0_40 版本)"></a><strong><a></a>ConcurrentHashMap 源码分析 (JDK1.7.0_40 版本)</strong></h2><p>ConcurrentHashMap.java 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/ConcurrentHashMap.java" target="_blank" rel="noopener">ConcurrentHashMap.java 的完整源码</a></p>
<p>下面从 ConcurrentHashMap 的创建，获取，添加，删除这 4 个方面对 ConcurrentHashMap 进行分析。</p>
<p><strong>1 创建</strong></p>
<p>下面以 ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) 来进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数有效性判断</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// concurrencyLevel是“用来计算segments的容量”</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ssize=“大于或等于concurrencyLevel的最小的2的N次方值”</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化segmentShift和segmentMask</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 哈希表的初始容量</span></span><br><span class="line">    <span class="comment">// 哈希表的实际容量=“segments的容量” x “segments中数组的长度”</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// “哈希表的初始容量” / “segments的容量”</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// cap就是“segments中的HashEntry数组的长度”</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// segments</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>(01) 前面我们说过，ConcurrentHashMap 采用了 “锁分段” 技术；在代码中，它通过 “segments 数组” 对象来保存各个分段。segments 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>
<p>concurrencyLevel 的作用就是用来计算 segments 数组的容量大小。先计算出 “大于或等于 concurrencyLevel 的最小的 2 的 N 次方值”，然后将其保存为 “segments 的容量大小 (ssize)”。<br>(02) initialCapacity 是哈希表的初始容量。需要注意的是，哈希表的实际容量 =“segments 的容量” x “segments 中数组的长度”。<br>(03) loadFactor 是加载因子。它是哈希表在其容量自动增加之前可以达到多满的一种尺度。</p>
<p>ConcurrentHashMap 的构造函数中涉及到的非常重要的一个结构体，它就是 Segment。下面看看 Segment 的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// threshold阈，是哈希表在其容量自动增加之前可以达到多满的一种尺度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// loadFactor是加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.table = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：Segment 包含 HashEntry 数组，HashEntry 保存了哈希表中的键值对。<br>此外，还需要说明的 Segment 继承于 ReentrantLock。这意味着，Segment 本质上就是可重入的互斥锁。</p>
<p>HashEntry 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">// 哈希值</span></span><br><span class="line">    <span class="keyword">final</span> K key;       <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">volatile</span> V value;  <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next; <span class="comment">// 下一个HashEntry节点</span></span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：和 HashMap 的节点一样，HashEntry 也是链表。这就说明，ConcurrentHashMap 是链式哈希表，它是通过 “拉链法” 来解决哈希冲突的。</p>
<p><strong>2 获取</strong></p>
<p>下面以 get(Object key) 为例，对 ConcurrentHashMap 的获取方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 获取key对应的Segment片段。</span></span><br><span class="line">    <span class="comment">// 如果Segment片段不为null，则在“Segment片段的HashEntry数组中”中找到key所对应的HashEntry列表；</span></span><br><span class="line">    <span class="comment">// 接着遍历该HashEntry链表，找到于key-value键值对对应的HashEntry节点。</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：get(Object key) 的作用是返回 key 在 ConcurrentHashMap 哈希表中对应的值。<br>它首先根据 key 计算出来的哈希值，获取 key 所对应的 Segment 片段。<br>如果 Segment 片段不为 null，则在 “Segment 片段的 HashEntry 数组中” 中找到 key 所对应的 HashEntry 列表。Segment 包含 “HashEntry 数组” 对象，而每一个 HashEntry 本质上是一个单向链表。<br>接着遍历该 HashEntry 链表，找到于 key-value 键值对对应的 HashEntry 节点。</p>
<p>下面是 hash() 的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3 增加</strong></p>
<p>下面以 put(K key, V value) 来对 ConcurrentHashMap 中增加键值对来进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 获取key对应的哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 如果找不到该Segment，则新建一个。</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">// in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>(01) put() 根据 key 获取对应的哈希值，再根据哈希值找到对应的 Segment 片段。如果 Segment 片段不存在，则新增一个 Segment。<br>(02) 将 key-value 键值对添加到 Segment 片段中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryLock()获取锁，成功返回true，失败返回false。</span></span><br><span class="line">    <span class="comment">// 获取锁失败的话，则通过scanAndLockForPut()获取锁，并返回”要插入的key-value“对应的”HashEntry链表“。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// tab代表”当前Segment中的HashEntry数组“</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//  根据”hash值“获取”HashEntry数组中对应的HashEntry链表“</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">// 如果”HashEntry链表中的当前HashEntry节点“不为null，</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// 当”要插入的key-value键值对“已经存在于”HashEntry链表中“时，先保存原有的值。</span></span><br><span class="line">                <span class="comment">// 若”onlyIfAbsent“为true，即”要插入的key不存在时才插入”，则直接退出；</span></span><br><span class="line">                <span class="comment">// 否则，用新的value值覆盖原有的原有的值。</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果node非空，则将first设置为“node的下一个节点”。</span></span><br><span class="line">                <span class="comment">// 否则，新建HashEntry链表</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果添加key-value键值对之后，Segment中的元素超过阈值(并且，HashEntry数组的长度没超过限制)，则rehash；</span></span><br><span class="line">                <span class="comment">// 否则，直接添加key-value键值对。</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>put() 的作用是将 key-value 键值对插入到 “当前 Segment 对应的 HashEntry 中”，在插入前它会获取 Segment 对应的互斥锁，插入后会释放锁。具体的插入过程如下：<br>(01) 首先根据 “hash 值” 获取 “当前 Segment 的 HashEntry 数组对象” 中的“HashEntry 节点”，每个 HashEntry 节点都是一个单向链表。<br>(02) 接着，遍历 HashEntry 链表。<br>       若在遍历 HashEntry 链表时，找到与 “要 key-value 键值对” 对应的节点，即 “要插入的 key-value 键值对” 的 key 已经存在于 HashEntry 链表中。则根据 onlyIfAbsent 进行判断，若 onlyIfAbsent 为 true，即“当要插入的 key 不存在时才插入”，则不进行插入，直接返回；否则，用新的 value 值覆盖原始的 value 值，然后再返回。<br>       若在遍历 HashEntry 链表时，没有找到与 “要 key-value 键值对” 对应的节点。当 node!=null 时，即在 scanAndLockForPut()获取锁时，已经新建了 key-value 对应的 HashEntry 节点，则”将 HashEntry 添加到 Segment 中 “；否则，新建 key-value 对应的 HashEntry 节点，然后再“将 HashEntry 添加到 Segment 中”。 在” 将 HashEntry 添加到 Segment 中 “前，会判断是否需要 rehash。如果在添加 key-value 键值之后，容量会超过阈值，并且 HashEntry 数组的长度没有超过限制，则进行 rehash；否则，直接通过 setEntryAt() 将 key-value 键值对添加到 Segment 中。</p>
<p>在介绍 rehash() 和 setEntryAt() 之前，我们先看看自旋函数 scanAndLockForPut()。下面是它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个HashEntry节点</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    <span class="comment">// 当前的HashEntry节点</span></span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 重复计数(自旋计数器)</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找”key-value键值对“在”HashEntry链表上对应的节点“；</span></span><br><span class="line">    <span class="comment">// 若找到的话，则不断的自旋；在自旋期间，若通过tryLock()获取锁成功则返回；否则自旋MAX_SCAN_RETRIES次数之后，强制获取”锁“并退出。</span></span><br><span class="line">    <span class="comment">// 若没有找到的话，则新建一个HashEntry链表。然后不断的自旋。</span></span><br><span class="line">    <span class="comment">// 此外，若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋工作！</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="comment">// 1\. retries&lt;0的处理情况</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.1 如果当前的HashEntry节点为空(意味着，在该HashEntry链表上上没有找到”要插入的键值对“对应的节点)，而且node=null；则新建HashEntry链表。</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.2 如果当前的HashEntry节点是”要插入的键值对在该HashEntry上对应的节点“，则设置retries=0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 1.3 设置为下一个HashEntry。</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2\. 如果自旋次数超过限制，则获取“锁”并退出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3\. 当“尝试了偶数次”时，就获取“当前Segment的第一个HashEntry”，即f。</span></span><br><span class="line">        <span class="comment">// 然后，通过f!=first来判断“当前Segment的第一个HashEntry是否发生了改变”。</span></span><br><span class="line">        <span class="comment">// 若是的话，则重置e，first和retries的值，并重新遍历。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>scanAndLockForPut() 的目标是获取锁。流程如下：<br>    它首先会调用 entryForHash()，根据 hash 值获取” 当前 Segment 中对应的 HashEntry 节点 (first)，即找到对应的 HashEntry 链表 “。<br>    紧接着进入 while 循环。在 while 循环中，它会遍历”HashEntry 链表 (e)“，查找” 要插入的 key-value 键值对 “在” 该 HashEntry 链表上对应的节点“。<br>         若找到的话，则不断的自旋，即不断的执行 while 循环。在自旋期间，若通过 tryLock() 获取锁成功则返回；否则，在自旋 MAX_SCAN_RETRIES 次数之后，强制获取锁并退出。<br>         若没有找到的话，则新建一个 HashEntry 链表，然后不断的自旋。在自旋期间，若通过 tryLock() 获取锁成功则返回；否则，在自旋 MAX_SCAN_RETRIES 次数之后，强制获取锁并退出。<br>     此外，若在自旋期间，HashEntry 链表的表头发生变化；则重新进行查找和自旋工作！</p>
<p>理解 scanAndLockForPut()时，务必要联系”哈希表 “的数据结构。一个 Segment 本身就是一个哈希表，Segment 中包含了”HashEntry 数组“对象，而每一个 HashEntry 对象本身是一个” 单向链表“。</p>
<p>下面看看 rehash() 的实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="comment">// ”Segment中原始的HashEntry数组的长度“</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// ”Segment中新HashEntry数组的长度“</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 新的HashEntry数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历”原始的HashEntry数组“，</span></span><br><span class="line">    <span class="comment">// 将”原始的HashEntry数组“中的每个”HashEntry链表“的值，都复制到”新的HashEntry数组的HashEntry元素“中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取”原始的HashEntry数组“中的”第i个HashEntry链表“</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 将”原始的HashEntry数组“中的”HashEntry链表(e)“的值，都复制到”新的HashEntry数组的HashEntry“中。</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新的node节点添加到“Segment的新HashEntry数组(newTable)“中。</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：rehash()的作用是将”Segment 的容量 “变为” 原始的 Segment 容量的 2 倍“。<br>在将原始的数据拷贝到 “新的 Segment” 中后，会将新增加的 key-value 键值对添加到 “新的 Segment” 中。</p>
<p>setEntryAt() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setEntryAt</span><span class="params">(HashEntry&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   HashEntry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; TSHIFT) + TBASE, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UNSAFE 是 Segment 类中定义的 “静态 sun.misc.Unsafe” 对象。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br></pre></td></tr></table></figure>
<p>Unsafe.java 在 openjdk6 中的路径是：openjdk6/jdk/src/share/classes/sun/misc/Unsafe.java。其中，putOrderedObject() 的源码下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：putOrderedObject() 是一个本地方法。<br>它会设置 obj 对象中 offset 偏移地址对应的 object 型 field 的值为指定值。它是一个有序或者有延迟的 putObjectVolatile() 方法，并且不保证值的改变被其他线程立即看到。只有在 field 被 volatile 修饰并且期望被意外修改的时候，使用 putOrderedObject() 才有用。</p>
<p>总之，setEntryAt() 的目的是设置 tab 中第 i 位置元素的值为 e，且该设置会有延迟。</p>
<p><strong>4 删除</strong></p>
<p>下面以 remove(Object key) 来对 ConcurrentHashMap 中的删除操作来进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据hash值，找到key对应的Segment片段。</span></span><br><span class="line">    Segment&lt;K,V&gt; s = segmentForHash(hash);</span><br><span class="line">    <span class="keyword">return</span> s == <span class="keyword">null</span> ? <span class="keyword">null</span> : s.remove(key, hash, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：remove()首先根据 “key 的计算出来的哈希值” 找到对应的 Segment 片段，然后再从该 Segment 片段中删除对应的“key-value 键值对”。</p>
<p>remove() 的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试获取Segment对应的锁。</span></span><br><span class="line">    <span class="comment">// 尝试失败的话，则通过scanAndLock()来获取锁。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryLock())</span><br><span class="line">        scanAndLock(key, hash);</span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据“hash值”找到“Segment的HashEntry数组”中对应的“HashEntry节点(e)”，该HashEntry节点是一HashEntry个链表。</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = entryAt(tab, index);</span><br><span class="line">        HashEntry&lt;K,V&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历“HashEntry链表”，删除key-value键值对</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == v || value.equals(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                        setEntryAt(tab, index, next);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pred.setNext(next);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    --count;</span><br><span class="line">                    oldValue = v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pred = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：remove() 的目的就是删除 key-value 键值对。在删除之前，它会获取到 Segment 的互斥锁，在删除之后，再释放锁。<br>它的删除过程也比较简单，它会先根据 hash 值，找到 “Segment 的 HashEntry 数组” 中对应的 “HashEntry” 节点。根据 Segment 的数据结构，我们知道 Segment 中包含一个 HashEntry 数组对象，而每一个 HashEntry 本质上是一个单向链表。 在找到 “HashEntry” 节点之后，就遍历该 “HashEntry” 节点对应的链表，找到 key-value 键值对对应的节点，然后删除。</p>
<p>下面对 scanAndLock() 进行说明。它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanAndLock</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个HashEntry节点</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找”key-value键值对“在”HashEntry链表上对应的节点“；</span></span><br><span class="line">    <span class="comment">// 无论找没找到，最后都会不断的自旋；在自旋期间，若通过tryLock()获取锁成功则返回；否则自旋MAX_SCAN_RETRIES次数之后，强制获取”锁“并退出。</span></span><br><span class="line">    <span class="comment">// 若在自旋期间，HashEntry链表的表头发生变化；则重新进行查找和自旋！</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f;</span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果“遍历完该HashEntry链表，仍然没找到”要删除的键值对“对应的节点”</span></span><br><span class="line">            <span class="comment">// 或者“在该HashEntry链表上找到”要删除的键值对“对应的节点”，则设置retries=0</span></span><br><span class="line">            <span class="comment">// 否则，设置e为下一个HashEntry节点。</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span> || key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋超过限制次数之后，获取锁并退出。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当“尝试了偶数次”时，就获取“当前Segment的第一个HashEntry”，即f。</span></span><br><span class="line">        <span class="comment">// 然后，通过f!=first来判断“当前Segment的第一个HashEntry是否发生了改变”。</span></span><br><span class="line">        <span class="comment">// 若是的话，则重置e，first和retries的值，并重新遍历。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f;</span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：scanAndLock() 的目标是获取锁。它的实现与 scanAndLockForPut() 类似，这里就不再过多说明。</p>
<p><strong>总结</strong>：ConcurrentHashMap 是线程安全的哈希表，它是通过 “<strong>锁分段</strong>” 来实现的。ConcurrentHashMap 中包括了 “Segment(锁分段) 数组”，每个 Segment 就是一个哈希表，而且也是可重入的互斥锁。第一，Segment 是哈希表表现在，Segment 包含了 “HashEntry 数组”，而“HashEntry 数组” 中的每一个 HashEntry 元素是一个单向链表。即 Segment 是通过链式哈希表。第二，Segment 是可重入的互斥锁表现在，Segment 继承于 ReentrantLock，而 ReentrantLock 就是可重入的互斥锁。<br>对于 ConcurrentHashMap 的添加，删除操作，<strong>在操作开始前，线程都会获取 Segment 的互斥锁；操作完毕之后，才会释放</strong>。而对于读取操作，它是通过 volatile 去实现的，HashEntry 数组是 volatile 类型的，而 volatile 能保证 “即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”，即我们总能读到其它线程写入 HashEntry 之后的值。 以上这些方式，就是 ConcurrentHashMap 线程安全的实现原理。</p>
<h2 id="ConcurrentHashMap-示例"><a href="#ConcurrentHashMap-示例" class="headerlink" title="ConcurrentHashMap 示例"></a><strong><a></a>ConcurrentHashMap 示例</strong></h2><p>下面，我们通过一个例子去对比 HashMap 和 ConcurrentHashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   ConcurrentHashMap是“线程安全”的哈希表，而HashMap是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历map”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当map是ConcurrentHashMap对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当map是HashMap对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> map是HashMap对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 同时启动两个线程对map进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"ta"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"tb"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String key, value;</span><br><span class="line">        Iterator iter = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line">            key = (String)entry.getKey();</span><br><span class="line">            value = (String)entry.getValue();</span><br><span class="line">            System.out.print(key+<span class="string">" - "</span>+value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "-" + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName()+i;</span><br><span class="line">                map.put(String.valueOf(i), val);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历map。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 - tb1, </span><br><span class="line">1 - tb1, </span><br><span class="line">1 - tb1, 1 - tb1, 2 - tb2, </span><br><span class="line">2 - tb2, 1 - tb1, </span><br><span class="line">3 - ta3, 1 - tb1, 2 - tb2, </span><br><span class="line">3 - tb3, 1 - tb1, 2 - tb2, </span><br><span class="line">3 - tb3, 1 - tb1, 4 - tb4, 3 - tb3, 2 - tb2, </span><br><span class="line">4 - tb4, 1 - tb1, 2 - tb2, </span><br><span class="line">5 - ta5, 1 - tb1, 3 - tb3, 5 - tb5, 4 - tb4, 3 - tb3, 2 - tb2, </span><br><span class="line">4 - tb4, 1 - tb1, 2 - tb2, </span><br><span class="line">5 - tb5, 1 - tb1, 6 - tb6, 5 - tb5, 3 - tb3, 6 - tb6, 4 - tb4, 3 - tb3, 2 - tb2, </span><br><span class="line">4 - tb4, 2 - tb2,</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：如果将源码中的 map 改成 HashMap 对象时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<h1 id="05-ConcurrentSkipListMap"><a href="#05-ConcurrentSkipListMap" class="headerlink" title="05 ConcurrentSkipListMap"></a>05 ConcurrentSkipListMap</h1><h2 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章对 Java.util.concurrent 包中的 ConcurrentSkipListMap 类进行详细的介绍。内容包括：<br><a href="#p1">ConcurrentSkipListMap 介绍</a><br> <a href="#p3">ConcurrentSkipListMap 原理和数据结构</a><br><a href="#p2">ConcurrentSkipListMap 函数列表</a><br><a href="#p4">ConcurrentSkipListMap 源码分析 (JDK1.7.0_40 版本)</a><br><a href="#p5">ConcurrentSkipListMap 示例</a></p>
<h2 id="ConcurrentSkipListMap-介绍"><a href="#ConcurrentSkipListMap-介绍" class="headerlink" title="ConcurrentSkipListMap 介绍"></a><strong><a></a>ConcurrentSkipListMap 介绍</strong></h2><p>ConcurrentSkipListMap 是线程安全的有序的哈希表，适用于高并发的场景。<br>ConcurrentSkipListMap 和 <a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="noopener">TreeMap</a>，它们虽然都是有序的哈希表。但是，第一，它们的线程安全机制不同，TreeMap 是非线程安全的，而 ConcurrentSkipListMap 是线程安全的。第二，ConcurrentSkipListMap 是通过<strong>跳表</strong>实现的，而 TreeMap 是通过红黑树实现的。<br>关于跳表 (Skip List)，它是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种<strong>随机化的算法</strong>的，这样也就是说<strong>跳表的插入和删除的工作是比较简单的</strong>。</p>
<h2 id="ConcurrentSkipListMap-原理和数据结构"><a href="#ConcurrentSkipListMap-原理和数据结构" class="headerlink" title="ConcurrentSkipListMap 原理和数据结构"></a><strong>ConcurrentSkipListMap 原理和数据结构</strong></h2><p>ConcurrentSkipListMap 的数据结构，如下图所示：<br><img src="http://p4lmrb1gp.bkt.clouddn.com/15219438220629.jpg" alt=""></p>
<p><strong>说明</strong>：</p>
<p>先以数据 “7,14,21,32,37,71,85” 序列为例，来对跳表进行简单说明。</p>
<p>跳表分为许多层 (level)，每一层都可以看作是数据的索引，这些索引的意义就是加快跳表查找数据速度。每一层的数据都是有序的，上一层数据是下一层数据的子集，并且第一层(level 1) 包含了全部的数据；层次越高，跳跃性越大，包含的数据越少。<br>跳表包含一个表头，它查找数据时，是从上往下，从左往右进行查找。现在 “需要找出值为 32 的节点” 为例，来对比说明跳表和普遍的链表。</p>
<p><strong>情况 1：链表中查找 “32” 节点</strong><br>路径如下图 1-02 所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219438488674.jpg" alt=""></p>
<p>需要 4 步 (红色部分表示路径)。</p>
<p><strong>情况 2：跳表中查找 “32” 节点</strong><br>路径如下图 1-03 所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219438780072.jpg" alt=""></p>
<p>忽略索引垂直线路上路径的情况下，只需要 2 步 (红色部分表示路径)。</p>
<p>下面说说 Java 中 ConcurrentSkipListMap 的数据结构。<br>(01) ConcurrentSkipListMap 继承于 AbstractMap 类，也就意味着它是一个哈希表。<br>(02) Index 是 ConcurrentSkipListMap 的内部类，它与 “跳表中的索引相对应”。HeadIndex 继承于 Index，ConcurrentSkipListMap 中含有一个 HeadIndex 的对象 head，head 是 “跳表的表头”。<br>(03) Index 是跳表中的索引，它包含 “右索引的指针(right)”，“下索引的指针(down)” 和“哈希表节点 node”。node 是 Node 的对象，Node 也是 ConcurrentSkipListMap 中的内部类。</p>
<h2 id="ConcurrentSkipListMap-函数列表"><a href="#ConcurrentSkipListMap-函数列表" class="headerlink" title="ConcurrentSkipListMap 函数列表"></a><strong><a></a>ConcurrentSkipListMap 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个新的空映射，该映射按照键的自然顺序进行排序。</span></span><br><span class="line">ConcurrentSkipListMap()</span><br><span class="line"><span class="comment">// 构造一个新的空映射，该映射按照指定的比较器进行排序。</span></span><br><span class="line">ConcurrentSkipListMap(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span><br><span class="line"><span class="comment">// 构造一个新映射，该映射所包含的映射关系与给定映射包含的映射关系相同，并按照键的自然顺序进行排序。</span></span><br><span class="line">ConcurrentSkipListMap(Map&lt;? extends K,? extends V&gt; m)</span><br><span class="line"><span class="comment">// 构造一个新映射，该映射所包含的映射关系与指定的有序映射包含的映射关系相同，使用的顺序也相同。</span></span><br><span class="line">ConcurrentSkipListMap(SortedMap&lt;K,? extends V&gt; m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与大于等于给定键的最小键关联的键-值映射关系；如果不存在这样的条目，则返回 null。</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回大于等于给定键的最小键；如果不存在这样的键，则返回 null。</span></span></span><br><span class="line"><span class="function">K <span class="title">ceilingKey</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此映射中移除所有映射关系。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 ConcurrentSkipListMap 实例的浅表副本。</span></span></span><br><span class="line"><span class="function">ConcurrentSkipListMap&lt;K,V&gt; <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。</span></span></span><br><span class="line"><span class="function">Comparator&lt;? <span class="keyword">super</span> K&gt; <span class="title">comparator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此映射包含指定键的映射关系，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此映射为指定值映射一个或多个键，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中所包含键的逆序 NavigableSet 视图。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;K&gt; <span class="title">descendingKeySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中所包含映射关系的逆序视图。</span></span></span><br><span class="line"><span class="function">ConcurrentNavigableMap&lt;K,V&gt; <span class="title">descendingMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中所包含的映射关系的 Set 视图。</span></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较指定对象与此映射的相等性。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。</span></span></span><br><span class="line"><span class="function">Map.Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中当前第一个（最低）键。</span></span></span><br><span class="line"><span class="function">K <span class="title">firstKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回与小于等于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。</span></span></span><br><span class="line"><span class="function">Map.Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回小于等于给定键的最大键；如果不存在这样的键，则返回 null。</span></span></span><br><span class="line"><span class="function">K <span class="title">floorKey</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回指定键所映射到的值；如果此映射不包含该键的映射关系，则返回 null。</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射的部分视图，其键值严格小于 toKey。</span></span></span><br><span class="line"><span class="function">ConcurrentNavigableMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。</span></span></span><br><span class="line"><span class="function">ConcurrentNavigableMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey, <span class="keyword">boolean</span> inclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回与严格大于给定键的最小键关联的键-值映射关系；如果不存在这样的键，则返回 null。</span></span></span><br><span class="line"><span class="function">Map.Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回严格大于给定键的最小键；如果不存在这样的键，则返回 null。</span></span></span><br><span class="line"><span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此映射未包含键-值映射关系，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中所包含键的 NavigableSet 视图。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。</span></span></span><br><span class="line"><span class="function">Map.Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回映射中当前最后一个（最高）键。</span></span></span><br><span class="line"><span class="function">K <span class="title">lastKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回与严格小于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。</span></span></span><br><span class="line"><span class="function">Map.Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回严格小于给定键的最大键；如果不存在这样的键，则返回 null。</span></span></span><br><span class="line"><span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中所包含键的 NavigableSet 视图。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;K&gt; <span class="title">navigableKeySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除并返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。</span></span></span><br><span class="line"><span class="function">Map.Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除并返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。</span></span></span><br><span class="line"><span class="function">Map.Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定值与此映射中的指定键关联。</span></span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果指定键已经不再与某个值相关联，则将它与给定值关联。</span></span></span><br><span class="line"><span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此映射中移除指定键的映射关系（如果存在）。</span></span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 只有目前将键的条目映射到给定值时，才移除该键的条目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 只有目前将键的条目映射到某一值时，才替换该键的条目。</span></span></span><br><span class="line"><span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 只有目前将键的条目映射到给定值时，才替换该键的条目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中的键-值映射关系数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。</span></span></span><br><span class="line"><span class="function">ConcurrentNavigableMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> fromInclusive, K toKey, <span class="keyword">boolean</span> toInclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。</span></span></span><br><span class="line"><span class="function">ConcurrentNavigableMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射的部分视图，其键大于等于 fromKey。</span></span></span><br><span class="line"><span class="function">ConcurrentNavigableMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。</span></span></span><br><span class="line"><span class="function">ConcurrentNavigableMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> inclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此映射中所包含值的 Collection 视图。</span></span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentSkipListMap-源码分析-JDK1-7-0-40-版本"><a href="#ConcurrentSkipListMap-源码分析-JDK1-7-0-40-版本" class="headerlink" title="ConcurrentSkipListMap 源码分析 (JDK1.7.0_40 版本)"></a><strong><a></a>ConcurrentSkipListMap 源码分析 (JDK1.7.0_40 版本)</strong></h2><p>ConcurrentSkipListMap.java 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/ConcurrentSkipListMap.java" target="_blank" rel="noopener">ConcurrentSkipListMap.java源码</a></p>
<p>下面从 ConcurrentSkipListMap 的添加，删除，获取这 3 个方面对它进行分析。</p>
<p><strong>1. 添加</strong></p>
<p>下面以 put(K key, V value) 为例，对 ConcurrentSkipListMap 的添加方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，put() 是通过 doPut() 将 key-value 键值对添加到 ConcurrentSkipListMap 中的。</p>
<p>doPut() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K kkey, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(kkey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找到key的前继节点</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        <span class="comment">// 设置n为“key的前继节点的后继节点”，即n应该是“插入节点”的“后继节点”</span></span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="comment">// 如果两次获得的b.next不是相同的Node，就跳转到”外层for循环“，重新获得b和n后再遍历。</span></span><br><span class="line">                <span class="keyword">if</span> (n != b.next)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// v是“n的值”</span></span><br><span class="line">                Object v = n.value;</span><br><span class="line">                <span class="comment">// 当n的值为null(意味着其它线程删除了n)；此时删除b的下一个节点，然后跳转到”外层for循环“，重新获得b和n后再遍历。</span></span><br><span class="line">                <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;               <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果其它线程删除了b；则跳转到”外层for循环“，重新获得b和n后再遍历。</span></span><br><span class="line">                <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 比较key和n.key</span></span><br><span class="line">                <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value))</span><br><span class="line">                        <span class="keyword">return</span> (V)v;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新建节点(对应是“要插入的键值对”)</span></span><br><span class="line">            Node&lt;K,V&gt; z = <span class="keyword">new</span> Node&lt;K,V&gt;(kkey, value, n);</span><br><span class="line">            <span class="comment">// 设置“b的后继节点”为z</span></span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// 多线程情况下，break才可能发生(其它线程对b进行了操作)</span></span><br><span class="line">            <span class="comment">// 随机获取一个level</span></span><br><span class="line">            <span class="comment">// 然后在“第1层”到“第level层”的链表中都插入新建节点</span></span><br><span class="line">            <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">            <span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">                insertIndex(z, level);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：doPut() 的作用就是将键值对添加到 “跳表” 中。<br>要想搞清 doPut()，首先要弄清楚它的主干部分 —— 我们先单纯的只考虑 “单线程的情况下，将 key-value 添加到跳表中”，即忽略 “多线程相关的内容”。它的流程如下：<br>第 1 步：找到 “插入位置”。<br>即，找到 “key 的前继节点(b)” 和“key 的后继节点(n)”；key 是要插入节点的键。<br>第 2 步：新建并插入节点。<br>即，新建节点 z(key 对应的节点)，并将新节点 z 插入到 “跳表” 中(设置“b 的后继节点为 z”，“z 的后继节点为 n”)。<br>第 3 步：更新跳表。<br>即，随机获取一个 level，然后在 “跳表” 的第 1 层～第 level 层之间，每一层都插入节点 z；在第 level 层之上就不再插入节点了。若 level 数值大于“跳表的层次”，则新建一层。<br>主干部分 “对应的精简后的 doPut() 的代码”如下(仅供参考)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K kkey, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(kkey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找到key的前继节点</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        <span class="comment">// 设置n为key的后继节点</span></span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新建节点(对应是“要被插入的键值对”)</span></span><br><span class="line">            Node&lt;K,V&gt; z = <span class="keyword">new</span> Node&lt;K,V&gt;(kkey, value, n);</span><br><span class="line">            <span class="comment">// 设置“b的后继节点”为z</span></span><br><span class="line">            b.casNext(n, z);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 随机获取一个level</span></span><br><span class="line">            <span class="comment">// 然后在“第1层”到“第level层”的链表中都插入新建节点</span></span><br><span class="line">            <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">            <span class="keyword">if</span> (level &gt; <span class="number">0</span>)</span><br><span class="line">                insertIndex(z, level);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理清主干之后，剩余的工作就相对简单了。主要是上面几步的对应算法的具体实现，以及多线程相关情况的处理！</p>
<p><strong>2. 删除</strong></p>
<p>下面以 remove(Object key) 为例，对 ConcurrentSkipListMap 的删除方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，remove() 是通过 doRemove() 将 ConcurrentSkipListMap 中的 key 对应的键值对删除的。</p>
<p>doRemove() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object okey, Object value)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(okey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找到“key的前继节点”</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        <span class="comment">// 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点)</span></span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// f是“当前节点n的后继节点”</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">// 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span></span><br><span class="line">            Object v = n.value;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;                    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果“前继节点b”被删除(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span></span><br><span class="line">            <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以下是c=0的情况</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 设置“当前节点n”的值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 设置“b的后继节点”为f</span></span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// Retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 清除“跳表”中每一层的key节点</span></span><br><span class="line">                findPredecessor(key);           <span class="comment">// Clean index</span></span><br><span class="line">                <span class="comment">// 如果“表头的右索引为空”，则将“跳表的层次”-1。</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：doRemove() 的作用是删除跳表中的节点。<br>和 doPut() 一样，我们重点看 doRemove() 的主干部分，了解主干部分之后，其余部分就非常容易理解了。下面是 “单线程的情况下，删除跳表中键值对的步骤”：<br>第 1 步：找到 “被删除节点的位置”。<br>即，找到 “key 的前继节点 (b)”，“key 所对应的节点 (n)”，“n 的后继节点 f”；key 是要删除节点的键。<br>第 2 步：删除节点。<br>即，将 “key 所对应的节点 n” 从跳表中移除 – 将 “b 的后继节点” 设为“f”！<br>第 3 步：更新跳表。<br>即，遍历跳表，删除每一层的 “key 节点”(如果存在的话)。如果删除“key 节点” 之后，跳表的层次需要 - 1；则执行相应的操作！<br>主干部分 “对应的精简后的 doRemove() 的代码”如下(仅供参考)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object okey, Object value)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(okey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找到“key的前继节点”</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        <span class="comment">// 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点)</span></span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// f是“当前节点n的后继节点”</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置“当前节点n”的值为null</span></span><br><span class="line">            n.casValue(v, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置“b的后继节点”为f</span></span><br><span class="line">            b.casNext(n, f);</span><br><span class="line">            <span class="comment">// 清除“跳表”中每一层的key节点</span></span><br><span class="line">            findPredecessor(key);</span><br><span class="line">            <span class="comment">// 如果“表头的右索引为空”，则将“跳表的层次”-1。</span></span><br><span class="line">            <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                tryReduceLevel();</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 获取</strong></p>
<p>下面以 get(Object key) 为例，对 ConcurrentSkipListMap 的获取方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doGet 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object okey)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; key = comparable(okey);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找到“key对应的节点”</span></span><br><span class="line">        Node&lt;K,V&gt; n = findNode(key);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Object v = n.value;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (V)v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：doGet() 是通过 findNode() 找到并返回节点的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findNode</span><span class="params">(Comparable&lt;? <span class="keyword">super</span> K&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找到key的前继节点</span></span><br><span class="line">        Node&lt;K,V&gt; b = findPredecessor(key);</span><br><span class="line">        <span class="comment">// 设置n为“b的后继节点”(即若key存在于“跳表中”，n就是key对应的节点)</span></span><br><span class="line">        Node&lt;K,V&gt; n = b.next;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果“n为null”，则跳转中不存在key对应的节点，直接返回null。</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">// 如果两次读取到的“b的后继节点”不同(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            Object v = n.value;</span><br><span class="line">            <span class="comment">// 如果“当前节点n的值”变为null(其它线程操作了该跳表)，则返回到“外层for循环”重新遍历。</span></span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;                <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == n || b.value == <span class="keyword">null</span>)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 若n是当前节点，则返回n。</span></span><br><span class="line">            <span class="keyword">int</span> c = key.compareTo(n.key);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="comment">// 若“节点n的key”小于“key”，则说明跳表中不存在key对应的节点，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 若“节点n的key”大于“key”，则更新b和n，继续查找。</span></span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：findNode(key) 的作用是在返回跳表中 key 对应的节点；存在则返回节点，不存在则返回 null。<br>先弄清函数的主干部分，即抛开 “多线程相关内容”，单纯的考虑单线程情况下，从跳表获取节点的算法。<br>第 1 步：找到 “被删除节点的位置”。<br>根据 findPredecessor() 定位 key 所在的层次以及找到 key 的前继节点 (b)，然后找到 b 的后继节点 n。<br>第 2 步：根据 “key 的前继节点(b)” 和“key 的前继节点的后继节点 (n)” 来定位“key 对应的节点”。<br>具体是通过比较 “n 的键值” 和“key”的大小。如果相等，则 n 就是所要查找的键。</p>
<h3 id="ConcurrentSkipListMap-示例"><a href="#ConcurrentSkipListMap-示例" class="headerlink" title="ConcurrentSkipListMap 示例"></a><strong><a></a>ConcurrentSkipListMap 示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   ConcurrentSkipListMap是“线程安全”的哈希表，而TreeMap是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历map”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当map是ConcurrentSkipListMap对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当map是TreeMap对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMapDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> map是TreeMap对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;String, String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时启动两个线程对map进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"a"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"b"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String key, value;</span><br><span class="line">        Iterator iter = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line">            key = (String)entry.getKey();</span><br><span class="line">            value = (String)entry.getValue();</span><br><span class="line">            System.out.print(<span class="string">"("</span>+key+<span class="string">", "</span>+value+<span class="string">"), "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName()+i;</span><br><span class="line">                map.put(val, <span class="string">"0"</span>);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历map。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(a1, 0), (a1, 0), (b1, 0), (b1, 0),</span><br><span class="line"></span><br><span class="line">(a1, 0), (b1, 0), (b2, 0), </span><br><span class="line">(a1, 0), (a1, 0), (a2, 0), (a2, 0), (b1, 0), (b1, 0), (b2, 0), (b2, 0), (b3, 0), </span><br><span class="line">(b3, 0), (a1, 0), </span><br><span class="line">(a2, 0), (a3, 0), (a1, 0), (b1, 0), (a2, 0), (b2, 0), (a3, 0), (b3, 0), (b1, 0), (b4, 0), </span><br><span class="line">(b2, 0), (a1, 0), (b3, 0), (a2, 0), (b4, 0), </span><br><span class="line">(a3, 0), (a1, 0), (a4, 0), (a2, 0), (b1, 0), (a3, 0), (b2, 0), (a4, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (b5, 0), </span><br><span class="line">(b3, 0), (a1, 0), (b4, 0), (a2, 0), (b5, 0), </span><br><span class="line">(a3, 0), (a1, 0), (a4, 0), (a2, 0), (a5, 0), (a3, 0), (b1, 0), (a4, 0), (b2, 0), (a5, 0), (b3, 0), (b1, 0), (b4, 0), (b2, 0), (b5, 0), (b3, 0), (b6, 0), </span><br><span class="line">(b4, 0), (a1, 0), (b5, 0), (a2, 0), (b6, 0), </span><br><span class="line">(a3, 0), (a4, 0), (a5, 0), (a6, 0), (b1, 0), (b2, 0), (b3, 0), (b4, 0), (b5, 0), (b6, 0),</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：<br>示例程序中，启动两个线程 (线程 a 和线程 b) 分别对 ConcurrentSkipListMap 进行操作。以线程 a 而言，它会先获取 “线程名”+“序号”，然后将该字符串作为 key，将“0” 作为 value，插入到 ConcurrentSkipListMap 中；接着，遍历并输出 ConcurrentSkipListMap 中的全部元素。 线程 b 的操作和线程 a 一样，只不过线程 b 的名字和线程 a 的名字不同。<br>当 map 是 ConcurrentSkipListMap 对象时，程序能正常运行。如果将 map 改为 TreeMap 时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<h1 id="06-ConcurrentSkipListSet"><a href="#06-ConcurrentSkipListSet" class="headerlink" title="06 ConcurrentSkipListSet"></a>06 ConcurrentSkipListSet</h1><h2 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章对 Java.util.concurrent 包中的 ConcurrentSkipListSet 类进行详细的介绍。内容包括：<br><a href="#p1">ConcurrentSkipListSet 介绍</a><br><a href="#a22">ConcurrentSkipListSet 原理和数据结构</a><br><a href="#p2">ConcurrentSkipListSet 函数列表</a><br><a href="#a4">ConcurrentSkipListSet 源码 (JDK1.7.0_40 版本)</a><br><a href="#a5">ConcurrentSkipListSet 示例</a></p>
<h2 id="ConcurrentSkipListSet-介绍"><a href="#ConcurrentSkipListSet-介绍" class="headerlink" title="ConcurrentSkipListSet 介绍"></a><strong><a></a>ConcurrentSkipListSet 介绍</strong></h2><p>ConcurrentSkipListSet 是线程安全的有序的集合，适用于高并发的场景。<br>ConcurrentSkipListSet 和 <a href="http://www.cnblogs.com/skywang12345/p/3311268.html" target="_blank" rel="noopener">TreeSet</a>，它们虽然都是有序的集合。但是，第一，它们的线程安全机制不同，TreeSet 是非线程安全的，而 ConcurrentSkipListSet 是线程安全的。第二，ConcurrentSkipListSet 是通过 <a href="http://www.cnblogs.com/skywang12345/p/3498556.html" target="_blank" rel="noopener">ConcurrentSkipListMap</a> 实现的，而 TreeSet 是通过 TreeMap 实现的。</p>
<h2 id="ConcurrentSkipListSet-原理和数据结构"><a href="#ConcurrentSkipListSet-原理和数据结构" class="headerlink" title="ConcurrentSkipListSet 原理和数据结构"></a><strong><a></a>ConcurrentSkipListSet 原理和数据结构</strong></h2><p>ConcurrentSkipListSet 的数据结构，如下图所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219446573198.jpg" alt=""></p>
<p><strong>说明</strong>：<br>(01) ConcurrentSkipListSet 继承于 AbstractSet。因此，它本质上是一个集合。<br>(02) ConcurrentSkipListSet 实现了 NavigableSet 接口。因此，ConcurrentSkipListSet 是一个有序的集合。<br>(03) ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的。它包含一个 ConcurrentNavigableMap 对象 m，而 m 对象实际上是 ConcurrentNavigableMap 的实现类 ConcurrentSkipListMap 的实例。ConcurrentSkipListMap 中的元素是 key-value 键值对；而 ConcurrentSkipListSet 是集合，它只用到了 ConcurrentSkipListMap 中的 key！</p>
<h2 id="ConcurrentSkipListSet-函数列表"><a href="#ConcurrentSkipListSet-函数列表" class="headerlink" title="ConcurrentSkipListSet 函数列表"></a><strong><a></a>ConcurrentSkipListSet 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个新的空 set，该 set 按照元素的自然顺序对其进行排序。</span></span><br><span class="line">ConcurrentSkipListSet()</span><br><span class="line"><span class="comment">// 构造一个包含指定 collection 中元素的新 set，这个新 set 按照元素的自然顺序对其进行排序。</span></span><br><span class="line">ConcurrentSkipListSet(Collection&lt;? extends E&gt; c)</span><br><span class="line"><span class="comment">// 构造一个新的空 set，该 set 按照指定的比较器对其元素进行排序。</span></span><br><span class="line">ConcurrentSkipListSet(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line"><span class="comment">// 构造一个新 set，该 set 所包含的元素与指定的有序 set 包含的元素相同，使用的顺序也相同。</span></span><br><span class="line">ConcurrentSkipListSet(SortedSet&lt;E&gt; s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果此 set 中不包含指定元素，则添加指定元素。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">ceiling</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此 set 中移除所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 ConcurrentSkipListSet 实例的浅表副本。</span></span></span><br><span class="line"><span class="function">ConcurrentSkipListSet&lt;E&gt; <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。</span></span></span><br><span class="line"><span class="function">Comparator&lt;? <span class="keyword">super</span> E&gt; <span class="title">comparator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 包含指定的元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此 set 的元素上以降序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中所包含元素的逆序视图。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较指定对象与此 set 的相等性。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中当前第一个（最低）元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">floor</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素严格小于 toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素小于（或等于，如果 inclusive 为 true）toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 不包含任何元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此 set 的元素上以升序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中当前最后一个（最高）元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此 set 中存在指定的元素，则将其移除。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此 set 中移除包含在指定 collection 中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 中的元素数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive, E toElement, <span class="keyword">boolean</span> toInclusive)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素大于等于 fromElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。</span></span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentSkipListSet-源码-JDK1-7-0-40-版本"><a href="#ConcurrentSkipListSet-源码-JDK1-7-0-40-版本" class="headerlink" title="ConcurrentSkipListSet 源码 (JDK1.7.0_40 版本)"></a><strong><a></a>ConcurrentSkipListSet 源码 (JDK1.7.0_40 版本)</strong></h2><p>ConcurrentSkipListSet.java 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/ConcurrentSkipListSet.java" target="_blank" rel="noopener">ConcurrentSkipListSet.java 的完整源码</a></p>
<p>ConcurrentSkipListSet 是通过 ConcurrentSkipListMap 实现的，它的接口基本上都是通过调用 ConcurrentSkipListMap 接口来实现的。这里就不再对它的源码进行分析了。</p>
<h2 id="ConcurrentSkipListSet-示例"><a href="#ConcurrentSkipListSet-示例" class="headerlink" title="ConcurrentSkipListSet 示例"></a><strong><a></a>ConcurrentSkipListSet 示例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   ConcurrentSkipListSet是“线程安全”的集合，而TreeSet是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历集合set”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当set是ConcurrentSkipListSet对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当set是TreeSet对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListSetDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> set是TreeSet对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static Set&lt;String&gt; set = new TreeSet&lt;String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; set = <span class="keyword">new</span> ConcurrentSkipListSet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 同时启动两个线程对set进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"a"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"b"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        Iterator iter = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName() + (i%<span class="number">6</span>);</span><br><span class="line">                set.add(val);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历set。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a1, b1, </span><br><span class="line">a1, a1, a2, b1, </span><br><span class="line">b1, a1, a2, a3, b1,</span><br><span class="line"></span><br><span class="line">a1, a2, a3, a1, a4, b1, b2, </span><br><span class="line">a2, a1, a2, a3, a4, a5, b1, b2, </span><br><span class="line">a3, a0, a4, a5, a1, b1, a2, b2, </span><br><span class="line">a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, </span><br><span class="line">a5, a0, b1, a1, b2, a2, b3, </span><br><span class="line">a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, b4, </span><br><span class="line">b1, a0, b2, a1, b3, a2, b4, </span><br><span class="line">a3, a0, a4, a1, a5, a2, b1, a3, b2, a4, b3, a5, b4, b1, b5, </span><br><span class="line">b2, a0, a1, a2, a3, a4, a5, b3, b1, b4, b2, b5, </span><br><span class="line">b3, a0, b4, a1, b5, </span><br><span class="line">a2, a0, a3, a1, a4, a2, a5, a3, b0, a4, b1, a5, b2, b0, b3, b1, b4, b2, b5, b3, </span><br><span class="line">b4, a0, b5, </span><br><span class="line">a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, </span><br><span class="line">a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, </span><br><span class="line">a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, </span><br><span class="line">a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5,</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：<br>示例程序中，启动两个线程 (线程 a 和线程 b) 分别对 ConcurrentSkipListSet 进行操作。以线程 a 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 ConcurrentSkipListSet 集合中；接着，遍历并输出集合中的全部元素。 线程 b 的操作和线程 a 一样，只不过线程 b 的名字和线程 a 的名字不同。<br>当 set 是 ConcurrentSkipListSet 对象时，程序能正常运行。如果将 set 改为 TreeSet 时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<h1 id="07-ArrayBlockingQueue"><a href="#07-ArrayBlockingQueue" class="headerlink" title="07 ArrayBlockingQueue"></a>07 ArrayBlockingQueue</h1><h2 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章对 Java.util.concurrent 包中的 ArrayBlockingQueue 类进行详细的介绍。内容包括：<br><a href="#a1">ArrayBlockingQueue 介绍</a><br> <a href="#a22">ArrayBlockingQueue 原理和数据结构</a><br><a href="#a2">ArrayBlockingQueue 函数列表</a><br><a href="#a4">ArrayBlockingQueue 源码分析 (JDK1.7.0_40 版本)</a><br><a href="#a5">ArrayBlockingQueue 示例</a></p>
<h2 id="ArrayBlockingQueue-介绍"><a href="#ArrayBlockingQueue-介绍" class="headerlink" title="ArrayBlockingQueue 介绍"></a><strong><a></a>ArrayBlockingQueue 介绍</strong></h2><p><strong>ArrayBlockingQueue 是数组实现的线程安全的有界的阻塞队列。</strong><br>线程安全是指，ArrayBlockingQueue 内部通过 “互斥锁” 保护竞争资源，实现了多线程对竞争资源的互斥访问。而有界，则是指 ArrayBlockingQueue 对应的数组是有界限的。 阻塞队列，是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待；而且，ArrayBlockingQueue 是按 FIFO（先进先出）原则对元素进行排序，元素都是<strong>从尾部插入到队列，从头部开始返回。</strong></p>
<p>注意：ArrayBlockingQueue 不同于 ConcurrentLinkedQueue，ArrayBlockingQueue 是<strong>数组</strong>实现的，并且是<strong>有界限</strong>的；而 ConcurrentLinkedQueue 是链表实现的，是无界限的。</p>
<h2 id="ArrayBlockingQueue-原理和数据结构"><a href="#ArrayBlockingQueue-原理和数据结构" class="headerlink" title="ArrayBlockingQueue 原理和数据结构"></a><strong><a></a>ArrayBlockingQueue 原理和数据结构</strong></h2><p>ArrayBlockingQueue 的数据结构，如下图所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219449691395.jpg" alt=""></p>
<p><strong>说明</strong>：<br>    1. ArrayBlockingQueue 继承于 AbstractQueue，并且它实现了 BlockingQueue 接口。<br>    2. ArrayBlockingQueue 内部是通过 Object[] 数组保存数据的，也就是说 ArrayBlockingQueue 本质上是通过数组实现的。ArrayBlockingQueue 的大小，即数组的容量是创建 ArrayBlockingQueue 时指定的。<br>    3. ArrayBlockingQueue 与 ReentrantLock 是组合关系，ArrayBlockingQueue 中包含一个 ReentrantLock 对象 (lock)。ReentrantLock 是可重入的互斥锁，ArrayBlockingQueue 就是根据该互斥锁实现 “多线程对竞争资源的互斥访问”。而且，ReentrantLock 分为公平锁和非公平锁，关于具体使用公平锁还是非公平锁，在创建 ArrayBlockingQueue 时可以指定；而且，ArrayBlockingQueue 默认会使用非公平锁。<br>    4. ArrayBlockingQueue 与 Condition 是组合关系，ArrayBlockingQueue 中包含两个 Condition 对象 (notEmpty 和 notFull)。而且，Condition 又依赖于 ArrayBlockingQueue 而存在，通过 Condition 可以实现对 ArrayBlockingQueue 的更精确的访问 – (01) 若某线程 (线程 A) 要取数据时，数组正好为空，则该线程会执行 notEmpty.await()进行等待；当其它某个线程 (线程 B) 向数组中插入了数据之后，会调用 notEmpty.signal()唤醒 “notEmpty 上的等待线程”。此时，线程 A 会被唤醒从而得以继续运行。(02) 若某线程 (线程 H) 要插入数据时，数组已满，则该线程会它执行 notFull.await()进行等待；当其它某个线程 (线程 I) 取出数据之后，会调用 notFull.signal()唤醒“notFull 上的等待线程”。此时，线程 H 就会被唤醒从而得以继续运行。<br>    关于 ReentrantLock，公平锁，非公平锁，以及 Condition 等更多的内容，可以参考：</p>
<p> (01) <a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a><br>    (02) <a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a><br>    (03) <a href="http://www.cnblogs.com/skywang12345/p/3496609.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”04 之 公平锁 (二)</a><br>    (04) <a href="http://www.cnblogs.com/skywang12345/p/3496651.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”05 之 非公平锁</a><br>    (05) <a href="http://www.cnblogs.com/skywang12345/p/3496716.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”06 之 Condition 条件</a></p>
<h2 id="ArrayBlockingQueue-函数列表"><a href="#ArrayBlockingQueue-函数列表" class="headerlink" title="ArrayBlockingQueue 函数列表"></a><strong><a></a>ArrayBlockingQueue 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。</span></span><br><span class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity)</span><br><span class="line"><span class="comment">// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。</span></span><br><span class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span><br><span class="line"><span class="comment">// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。</span></span><br><span class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair, Collection&lt;? extends E&gt; c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 自动移除此队列中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此队列包含指定的元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此队列中的元素上按适当顺序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取但不移除此队列的头；如果此队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此队列的头，如果此队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。</span></span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的其他元素数量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此队列中移除指定元素的单个实例（如果存在）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此队列中元素的数量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。</span></span></span><br><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个按适当顺序包含此队列中所有元素的数组。</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 collection 的字符串表示形式。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ArrayBlockingQueue-源码分析-JDK1-7-0-40-版本"><a href="#ArrayBlockingQueue-源码分析-JDK1-7-0-40-版本" class="headerlink" title="ArrayBlockingQueue 源码分析 (JDK1.7.0_40 版本)"></a><strong><a></a>ArrayBlockingQueue 源码分析 (JDK1.7.0_40 版本)</strong></h2><p>ArrayBlockingQueue.java 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/ArrayBlockingQueue.java" target="_blank" rel="noopener">ArrayBlockingQueue.java 的完整源码</a></p>
<p>下面从 ArrayBlockingQueue 的创建，添加，取出，遍历这几个方面对 ArrayBlockingQueue 进行分析。</p>
<p><strong>1. 创建</strong></p>
<p>下面以 ArrayBlockingQueue(int capacity, boolean fair) 来进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>(01) items 是保存 “阻塞队列” 数据的数组。它的定义如下：</p>
<p>final Object[] items;</p>
<p>(02) fair 是 “可重入的独占锁(ReentrantLock)” 的类型。fair 为 true，表示是公平锁；fair 为 false，表示是非公平锁。<br>notEmpty 和 notFull 是锁的两个 Condition 条件。它们的定义如下：</p>
<p>final ReentrantLock lock;<br>private final Condition notEmpty;<br>private final Condition notFull;</p>
<p>简单对 Condition 和 Lock 的用法进行说明，更多内容请参考 “<a href="http://www.cnblogs.com/skywang12345/p/3496716.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”06 之 Condition 条件</a>”。<br>Lock 的作用是提供独占锁机制，来保护竞争资源；而 Condition 是为了更加精细的对锁进行控制，它依赖于 Lock，通过某个条件对多线程进行控制。<br>notEmpty 表示 “锁的非空条件”。当某线程想从队列中取数据时，而此时又没有数据，则该线程通过 notEmpty.await() 进行等待；当其它线程向队列中插入了元素之后，就调用 notEmpty.signal()唤醒 “之前通过 notEmpty.await() 进入等待状态的线程”。<br>同理，notFull 表示 “锁的满条件”。当某线程想向队列中插入元素，而此时队列已满时，该线程等待；当其它线程从队列中取出元素之后，就唤醒该等待的线程。</p>
<p><strong>2. 添加</strong></p>
<p>下面以 offer(E e) 为例，对 ArrayBlockingQueue 的添加方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建插入的元素是否为null，是的话抛出NullPointerException异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 获取“该阻塞队列的独占锁”</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，则返回false。</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列未满，则插入e，并返回true。</span></span><br><span class="line">            insert(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：offer(E e) 的作用是将 e 插入阻塞队列的尾部。如果队列已满，则返回 false，表示插入失败；否则，插入元素，并返回 true。<br>(01) <strong>count 表示” 队列中的元素个数 “。</strong>除此之外，队列中还有另外两个遍历 takeIndex 和 putIndex。takeIndex 表示下一个被取出元素的索引，putIndex 表示下一个被添加元素的索引。它们的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列中的元素个数</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一个被取出元素的索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">// 下一个被添加元素的索引</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>(02) <strong>insert() 的源码如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将x添加到”队列“中</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">// 设置”下一个被取出元素的索引“</span></span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    <span class="comment">// 将”队列中的元素个数”+1</span></span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">// 唤醒notEmpty上的等待线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert() 在插入元素之后，会唤醒 notEmpty 上面的等待线程。</p>
<p>inc() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (++i == items.length) ? <span class="number">0</span> : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 i+1 的值等于 “队列的长度”，即添加元素之后，队列满；则设置“下一个被添加元素的索引” 为 0。</p>
<p><strong>3. 取出</strong></p>
<p>下面以 take() 为例，对 ArrayBlockingQueue 的取出方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取“队列的独占锁”</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取“锁”，若当前线程是中断状态，则抛出InterruptedException异常</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 若“队列为空”，则一直等待。</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 取出元素</span></span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“锁”</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：take() 的作用是取出并返回队列的头。若队列为空，则一直等待。</p>
<p>extract() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// 强制将元素转换为“泛型E”</span></span><br><span class="line">    E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]);</span><br><span class="line">    <span class="comment">// 将第takeIndex元素设为null，即删除。同时，帮助GC回收。</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 设置“下一个被取出元素的索引”</span></span><br><span class="line">    takeIndex = inc(takeIndex);</span><br><span class="line">    <span class="comment">// 将“队列中元素数量”-1</span></span><br><span class="line">    --count;</span><br><span class="line">    <span class="comment">// 唤醒notFull上的等待线程。</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：extract() 在删除元素之后，会唤醒 notFull 上的等待线程。</p>
<p><strong>4. 遍历</strong></p>
<p>下面对 ArrayBlockingQueue 的遍历方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Itr 是实现了 Iterator 接口的类，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 队列中剩余元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> remaining; <span class="comment">// Number of elements yet to be returned</span></span><br><span class="line">    <span class="comment">// 下一次调用next()返回的元素的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex; <span class="comment">// Index of element to be returned by next</span></span><br><span class="line">    <span class="comment">// 下一次调用next()返回的元素</span></span><br><span class="line">    <span class="keyword">private</span> E nextItem;    <span class="comment">// Element to be returned by next call to next</span></span><br><span class="line">    <span class="comment">// 上一次调用next()返回的元素</span></span><br><span class="line">    <span class="keyword">private</span> E lastItem;    <span class="comment">// Element returned by last call to next</span></span><br><span class="line">    <span class="comment">// 上一次调用next()返回的元素的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastRet;   <span class="comment">// Index of last element returned, or -1 if none</span></span><br><span class="line"></span><br><span class="line">    Itr() &#123;</span><br><span class="line">        <span class="comment">// 获取“阻塞队列”的锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((remaining = count) &gt; <span class="number">0</span>)</span><br><span class="line">                nextItem = itemAt(nextIndex = takeIndex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放“锁”</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remaining &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取“阻塞队列”的锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 若“剩余元素&lt;=0”，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            lastRet = nextIndex;</span><br><span class="line">            <span class="comment">// 获取第nextIndex位置的元素</span></span><br><span class="line">            E x = itemAt(nextIndex);  <span class="comment">// check for fresher value</span></span><br><span class="line">            <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x = nextItem;         <span class="comment">// we are forced to report old value</span></span><br><span class="line">                lastItem = <span class="keyword">null</span>;      <span class="comment">// but ensure remove fails</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lastItem = x;</span><br><span class="line">            <span class="keyword">while</span> (--remaining &gt; <span class="number">0</span> &amp;&amp; <span class="comment">// skip over nulls</span></span><br><span class="line">                   (nextItem = itemAt(nextIndex = inc(nextIndex))) == <span class="keyword">null</span>)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = ArrayBlockingQueue.<span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = lastRet;</span><br><span class="line">            <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            E x = lastItem;</span><br><span class="line">            lastItem = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// only remove if item still at index</span></span><br><span class="line">            <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp; x == items[i]) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> removingHead = (i == takeIndex);</span><br><span class="line">                removeAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!removingHead)</span><br><span class="line">                    nextIndex = dec(nextIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ArrayBlockingQueue-示例"><a href="#ArrayBlockingQueue-示例" class="headerlink" title="ArrayBlockingQueue 示例"></a><strong><a></a>ArrayBlockingQueue 示例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   ArrayBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历queue”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当queue是ArrayBlockingQueue对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueDemo1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> queue是LinkedList对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">20</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时启动两个线程对queue进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"ta"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"tb"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value;</span><br><span class="line">        Iterator iter = queue.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "-" + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName()+i;</span><br><span class="line">                queue.add(val);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历queue。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ta1, ta1, </span><br><span class="line">tb1, ta1, </span><br><span class="line">tb1, ta1, ta2, </span><br><span class="line">tb1, ta1, ta2, tb1, tb2, </span><br><span class="line">ta2, ta1, tb2, tb1, ta3, </span><br><span class="line">ta2, ta1, tb2, tb1, ta3, ta2, tb3, </span><br><span class="line">tb2, ta1, ta3, tb1, tb3, ta2, ta4, </span><br><span class="line">tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, tb4, </span><br><span class="line">ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, </span><br><span class="line">ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, tb5, </span><br><span class="line">tb3, ta1, ta4, tb1, tb4, ta2, ta5, tb2, tb5, ta3, ta6, </span><br><span class="line">tb3, ta4, tb4, ta5, tb5, ta6, tb6,</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：如果将源码中的 queue 改成 LinkedList 对象时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<h1 id="08-LinkedBlockingQueue"><a href="#08-LinkedBlockingQueue" class="headerlink" title="08 LinkedBlockingQueue"></a>08 LinkedBlockingQueue</h1><h2 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章介绍 JUC 包中的 LinkedBlockingQueue。内容包括：<br><a href="#a1">LinkedBlockingQueue 介绍</a><br><a href="#a2">LinkedBlockingQueue 原理和数据结构</a><br><a href="#a3">LinkedBlockingQueue 函数列表</a><br><a href="#a4">LinkedBlockingQueue 源码分析 (JDK1.7.0_40 版本)</a><br><a href="#a5">LinkedBlockingQueue 示例</a></p>
<h2 id="LinkedBlockingQueue-介绍"><a href="#LinkedBlockingQueue-介绍" class="headerlink" title="LinkedBlockingQueue 介绍"></a><strong><a></a>LinkedBlockingQueue 介绍</strong></h2><p>LinkedBlockingQueue 是一个单向链表实现的阻塞队列。该队列按 FIFO（先进先出）排序元素，新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。</p>
<p>此外，LinkedBlockingQueue 还是可选容量的 (防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于 Integer.MAX_VALUE。</p>
<h2 id="LinkedBlockingQueue-原理和数据结构"><a href="#LinkedBlockingQueue-原理和数据结构" class="headerlink" title="LinkedBlockingQueue 原理和数据结构"></a><strong><a></a>LinkedBlockingQueue 原理和数据结构</strong></h2><p>LinkedBlockingQueue 的数据结构，如下图所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219464896847.jpg" alt=""></p>
<p><strong>说明</strong>：<br>1. LinkedBlockingQueue 继承于 AbstractQueue，它本质上是一个 FIFO(先进先出) 的队列。<br>2. LinkedBlockingQueue 实现了 BlockingQueue 接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。<br>3. LinkedBlockingQueue 是通过单链表实现的。<br>(01) head 是链表的表头。取出数据时，都是从表头 head 处插入。<br>(02) last 是链表的表尾。新增数据时，都是从表尾 last 处插入。<br>(03) count 是链表的实际大小，即当前链表中包含的节点个数。<br>(04) capacity 是列表的容量，它是在创建链表时指定的。<br>(05) putLock 是插入锁，takeLock 是取出锁；notEmpty 是 “非空条件”，notFull 是 “未满条件”。通过它们对链表进行并发控制。<br>       LinkedBlockingQueue 在实现 “多线程对竞争资源的互斥访问” 时，对于 “插入” 和“取出 (删除)” 操作分别使用了不同的锁。对于插入操作，通过 “插入锁 putLock” 进行同步；对于取出操作，通过 “取出锁 takeLock” 进行同步。<br>       此外，插入锁 putLock 和 “非满条件 notFull” 相关联，取出锁 takeLock 和 “非空条件 notEmpty” 相关联。通过 notFull 和 notEmpty 更细腻的控制锁。</p>
<p> – 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。<br> – 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。</p>
<p>关于 ReentrantLock 和 Condition 等更多的内容，可以参考：<br>    (01) <a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a><br>    (02) <a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a><br>    (03) <a href="http://www.cnblogs.com/skywang12345/p/3496609.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”04 之 公平锁 (二)</a><br>    (04) <a href="http://www.cnblogs.com/skywang12345/p/3496651.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”05 之 非公平锁</a><br>    (05) <a href="http://www.cnblogs.com/skywang12345/p/3496716.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”06 之 Condition 条件</a></p>
<h2 id="LinkedBlockingQueue-函数列表"><a href="#LinkedBlockingQueue-函数列表" class="headerlink" title="LinkedBlockingQueue 函数列表"></a><strong><a></a>LinkedBlockingQueue 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue。</span></span><br><span class="line">LinkedBlockingQueue()</span><br><span class="line"><span class="comment">// 创建一个容量是 Integer.MAX_VALUE 的 LinkedBlockingQueue，最初包含给定 collection 的元素，元素按该 collection 迭代器的遍历顺序添加。</span></span><br><span class="line">LinkedBlockingQueue(Collection&lt;? extends E&gt; c)</span><br><span class="line"><span class="comment">// 创建一个具有给定（固定）容量的 LinkedBlockingQueue。</span></span><br><span class="line">LinkedBlockingQueue(<span class="keyword">int</span> capacity)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队列彻底移除所有元素。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在队列中的元素上按适当顺序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定元素插入到此队列的尾部（如果立即可行且不会超出此队列的容量），在成功时返回 true，如果此队列已满，则返回 false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定元素插入到此队列的尾部，如有必要，则等待指定的时间以使空间变得可用。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取但不移除此队列的头；如果此队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此队列的头，如果此队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。</span></span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定元素插入到此队列的尾部，如有必要，则等待空间变得可用。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回理想情况下（没有内存和资源约束）此队列可接受并且不会被阻塞的附加元素数量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此队列移除指定元素的单个实例（如果存在）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回队列中的元素个数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。</span></span></span><br><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回按适当顺序包含此队列中所有元素的数组。</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 collection 的字符串表示形式。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="LinkedBlockingQueue-源码分析-JDK1-7-0-40-版本"><a href="#LinkedBlockingQueue-源码分析-JDK1-7-0-40-版本" class="headerlink" title="LinkedBlockingQueue 源码分析 (JDK1.7.0_40 版本)"></a><strong><a></a>LinkedBlockingQueue 源码分析 (JDK1.7.0_40 版本)</strong></h2><p>LinkedBlockingQueue.java 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/LinkedBlockingQueue.java" target="_blank" rel="noopener">LinkedBlockingQueue.java 的完整源码</a><br>下面从 LinkedBlockingQueue 的创建，添加，删除，遍历这几个方面对它进行分析。</p>
<p><strong>1. 创建</strong></p>
<p>下面以 LinkedBlockingQueue(int capacity) 来进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>(01) capacity 是 “链式阻塞队列” 的容量。<br>(02) head 和 last 是 “链式阻塞队列” 的首节点和尾节点。它们在 LinkedBlockingQueue 中的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">// 当前数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head; <span class="comment">// 链表的表头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">// 链表的表尾</span></span><br><span class="line"><span class="comment">// 用于控制“删除元素”的互斥锁takeLock 和 锁对应的“非空条件”notEmpty</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="comment">// 用于控制“添加元素”的互斥锁putLock 和 锁对应的“非满条件”notFull</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<p>链表的节点定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;         <span class="comment">// 数据</span></span><br><span class="line">    Node&lt;E&gt; next;   <span class="comment">// 下一个节点的指针</span></span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 添加</strong></p>
<p>下面以 offer(E e) 为例，对 LinkedBlockingQueue 的添加方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 如果“队列已满”，则返回false，表示插入失败。</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新建“节点e”</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="comment">// 获取“插入锁putLock”</span></span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 再次对“队列是不是满”的进行判断。</span></span><br><span class="line">        <span class="comment">// 若“队列未满”，则插入节点。</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            <span class="comment">// 插入节点</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            <span class="comment">// 将“当前节点数量”+1，并返回“原始的数量”</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">// 如果在插入元素之后，队列仍然未满，则唤醒notFull上的等待线程。</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“插入锁putLock”</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果在插入节点前，队列为空；则插入节点后，唤醒notEmpty上的等待线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：offer() 的作用很简单，就是将元素 E 添加到队列的末尾。</p>
<p>enqueue() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enqueue() 的作用是将 node 添加到队列末尾，并设置 node 为新的尾节点！</p>
<p>signalNotEmpty() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>signalNotEmpty() 的作用是唤醒 notEmpty 上的等待线程。</p>
<p><strong>3. 取出</strong></p>
<p>下面以 take() 为例，对 LinkedBlockingQueue 的取出方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    <span class="comment">// 获取“取出锁”，若当前线程是中断状态，则抛出InterruptedException异常</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 若“队列为空”，则一直等待。</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出元素</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// 取出元素之后，将“节点数量”-1；并返回“原始的节点数量”。</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“取出锁”</span></span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果在“取出元素之前”，队列是满的；则在取出元素之后，唤醒notFull上的等待线程。</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：take() 的作用是取出并返回队列的头。若队列为空，则一直等待。</p>
<p>dequeue() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dequeue() 的作用就是删除队列的头节点，并将表头指向 “原头节点的下一个节点”。</p>
<p>signalNotFull() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>signalNotFull() 的作用就是唤醒 notFull 上的等待线程。</p>
<p><strong>4. 遍历</strong></p>
<p>下面对 LinkedBlockingQueue 的遍历方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iterator() 实际上是返回一个 Iter 对象。</p>
<p>Itr 类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; current;</span><br><span class="line">    <span class="comment">// 上一次返回的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastRet;</span><br><span class="line">    <span class="comment">// 当前节点对应的值</span></span><br><span class="line">    <span class="keyword">private</span> E currentElement;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;</span><br><span class="line">        <span class="comment">// 同时获取“插入锁putLock” 和 “取出锁takeLock”</span></span><br><span class="line">        fullyLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置“当前元素”为“队列表头的下一节点”，即为队列的第一个有效节点</span></span><br><span class="line">            current = head.next;</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="keyword">null</span>)</span><br><span class="line">                currentElement = current.item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放“插入锁putLock” 和 “取出锁takeLock”</span></span><br><span class="line">            fullyUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“下一个节点是否为null”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">nextNode</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node&lt;E&gt; s = p.next;</span><br><span class="line">            <span class="keyword">if</span> (s == p)</span><br><span class="line">                <span class="keyword">return</span> head.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.item != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            p = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fullyLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            E x = currentElement;</span><br><span class="line">            lastRet = current;</span><br><span class="line">            current = nextNode(current);</span><br><span class="line">            currentElement = (current == <span class="keyword">null</span>) ? <span class="keyword">null</span> : current.item;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fullyUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        fullyLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Node&lt;E&gt; node = lastRet;</span><br><span class="line">            lastRet = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">                 p != <span class="keyword">null</span>;</span><br><span class="line">                 trail = p, p = p.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == node) &#123;</span><br><span class="line">                    unlink(p, trail);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fullyUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedBlockingQueue-示例"><a href="#LinkedBlockingQueue-示例" class="headerlink" title="LinkedBlockingQueue 示例"></a><a></a>LinkedBlockingQueue 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   LinkedBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历queue”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当queue是LinkedBlockingQueue对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> queue是LinkedList对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 同时启动两个线程对queue进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"ta"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"tb"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value;</span><br><span class="line">        Iterator iter = queue.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "-" + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName()+i;</span><br><span class="line">                queue.add(val);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历queue。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tb1, ta1, </span><br><span class="line">tb1, ta1, ta2, </span><br><span class="line">tb1, ta1, ta2, ta3, </span><br><span class="line">tb1, ta1, ta2, ta3, ta4, </span><br><span class="line">tb1, ta1, tb1, ta2, ta1, ta3, ta2, ta4, ta3, ta5, </span><br><span class="line">ta4, tb1, ta5, ta1, ta6, </span><br><span class="line">ta2, tb1, ta3, ta1, ta4, ta2, ta5, ta3, ta6, ta4, tb2, </span><br><span class="line">ta5, ta6, tb2, </span><br><span class="line">tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, </span><br><span class="line">tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, </span><br><span class="line">tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb5, </span><br><span class="line">tb1, ta1, ta2, ta3, ta4, ta5, ta6, tb2, tb3, tb4, tb5, tb6,</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：<br>示例程序中，启动两个线程 (线程 ta 和线程 tb) 分别对 LinkedBlockingQueue 进行操作。以线程 ta 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 LinkedBlockingQueue 中；接着，遍历并输出 LinkedBlockingQueue 中的全部元素。 线程 tb 的操作和线程 ta 一样，只不过线程 tb 的名字和线程 ta 的名字不同。<br>当 queue 是 LinkedBlockingQueue 对象时，程序能正常运行。如果将 queue 改为 LinkedList 时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<h1 id="09-LinkedBlockingDeque"><a href="#09-LinkedBlockingDeque" class="headerlink" title="09 LinkedBlockingDeque"></a>09 LinkedBlockingDeque</h1><h2 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章介绍 JUC 包中的 LinkedBlockingDeque。内容包括：<br><a href="#a1">LinkedBlockingDeque 介绍</a><br><a href="#a2">LinkedBlockingDeque 原理和数据结构</a><br><a href="#a3">LinkedBlockingDeque 函数列表</a><br><a href="#a4">LinkedBlockingDeque 源码分析 (JDK1.7.0_40 版本)</a><br><a href="#a5">LinkedBlockingDeque 示例</a></p>
<h2 id="LinkedBlockingDeque-介绍"><a href="#LinkedBlockingDeque-介绍" class="headerlink" title="LinkedBlockingDeque 介绍"></a><strong><a></a>LinkedBlockingDeque 介绍</strong></h2><p>LinkedBlockingDeque 是<strong>双向链表实现的双向并发阻塞队列</strong>。该阻塞队列同时支持 FIFO 和 FILO 两种操作方式，即可以从队列的头和尾同时操作 (插入 / 删除)；并且，该阻塞队列是支持线程安全。</p>
<p>此外，LinkedBlockingDeque 还是可选容量的 (防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于 Integer.MAX_VALUE。</p>
<h2 id="LinkedBlockingDeque-原理和数据结构"><a href="#LinkedBlockingDeque-原理和数据结构" class="headerlink" title="LinkedBlockingDeque 原理和数据结构"></a><strong><a></a>LinkedBlockingDeque 原理和数据结构</strong></h2><p>LinkedBlockingDeque 的数据结构，如下图所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219472408332.jpg" alt=""></p>
<p><strong>说明</strong>：<br>1. LinkedBlockingDeque 继承于 AbstractQueue，它本质上是一个支持 FIFO 和 FILO 的双向的队列。<br>2. LinkedBlockingDeque 实现了 BlockingDeque 接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。<br>3. LinkedBlockingDeque 是通过双向链表实现的。<br>3.1 first 是双向链表的表头。<br>3.2 last 是双向链表的表尾。<br>3.3 count 是 LinkedBlockingDeque 的实际大小，即双向链表中当前节点个数。<br>3.4 capacity 是 LinkedBlockingDeque 的容量，它是在创建 LinkedBlockingDeque 时指定的。<br>3.5 lock 是控制对 LinkedBlockingDeque 的互斥锁，当多个线程竞争同时访问 LinkedBlockingDeque 时，某线程获取到了互斥锁 lock，其它线程则需要阻塞等待，直到该线程释放 lock，其它线程才有机会获取 lock 从而获取 cpu 执行权。<br>3.6 notEmpty 和 notFull 分别是 “非空条件” 和“未满条件”。通过它们能够更加细腻进行并发控制。</p>
<p>– 若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。<br>– 若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。</p>
<p>关于 ReentrantLock 和 Condition 等更多的内容，可以参考：<br>    (01) <a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a><br>    (02) <a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a><br>    (03) <a href="http://www.cnblogs.com/skywang12345/p/3496609.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”04 之 公平锁 (二)</a><br>    (04) <a href="http://www.cnblogs.com/skywang12345/p/3496651.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”05 之 非公平锁</a><br>    (05) <a href="http://www.cnblogs.com/skywang12345/p/3496716.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”06 之 Condition 条件</a></p>
<h2 id="LinkedBlockingDeque-函数列表"><a href="#LinkedBlockingDeque-函数列表" class="headerlink" title="LinkedBlockingDeque 函数列表"></a><strong><a></a>LinkedBlockingDeque 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingDeque。</span></span><br><span class="line">LinkedBlockingDeque()</span><br><span class="line"><span class="comment">// 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingDeque，最初包含给定 collection 的元素，以该 collection 迭代器的遍历顺序添加。</span></span><br><span class="line">LinkedBlockingDeque(Collection&lt;? extends E&gt; c)</span><br><span class="line"><span class="comment">// 创建一个具有给定（固定）容量的 LinkedBlockingDeque。</span></span><br><span class="line">LinkedBlockingDeque(<span class="keyword">int</span> capacity)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在不违反容量限制的情况下，将指定的元素插入此双端队列的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头；如果当前没有空间可用，则抛出 IllegalStateException。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾；如果当前没有空间可用，则抛出 IllegalStateException。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以原子方式 (atomically) 从此双端队列移除所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此双端队列包含指定的元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此双端队列的元素上以逆向连续顺序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取但不移除此双端队列表示的队列的头部。</span></span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取，但不移除此双端队列的第一个元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取，但不移除此双端队列的最后一个元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此双端队列元素上以恰当顺序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），并在成功时返回 true；如果当前没有空间可用，则返回 false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将在指定的等待时间内一直等待可用空间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的开头，并在成功时返回 true；如果当前没有空间可用，则返回 false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入此双端队列的开头，必要时将在指定的等待时间内等待可用空间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果立即可行且不违反容量限制，则将指定的元素插入此双端队列的末尾，并在成功时返回 true；如果当前没有空间可用，则返回 false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入此双端队列的末尾，必要时将在指定的等待时间内等待可用空间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取但不移除此双端队列表示的队列的头部（即此双端队列的第一个元素）；如果此双端队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素）；如果此双端队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），如有必要将在指定的等待时间内等待可用元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列的第一个元素，必要时将在指定的等待时间等待可用元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列的最后一个元素，必要时将在指定的等待时间内等待可用元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此双端队列所表示的堆栈中弹出一个元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将元素推入此双端队列表示的栈。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入此双端队列表示的队列中（即此双端队列的尾部），必要时将一直等待可用空间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入此双端队列的开头，必要时将一直等待可用空间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putFirst</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putLast</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回理想情况下（没有内存和资源约束）此双端队列可不受阻塞地接受的额外元素数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列表示的队列的头部。</span></span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此双端队列移除第一次出现的指定元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列第一个元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此双端队列移除第一次出现的指定元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列的最后一个元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此双端队列移除最后一次出现的指定元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此双端队列中的元素数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列表示的队列的头部（即此双端队列的第一个元素），必要时将一直等待可用元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列的第一个元素，必要时将一直等待可用元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">takeFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此双端队列的最后一个元素，必要时将一直等待可用元素。</span></span></span><br><span class="line"><span class="function">E <span class="title">takeLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回以恰当顺序（从第一个元素到最后一个元素）包含此双端队列所有元素的数组。</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回以恰当顺序包含此双端队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此 collection 的字符串表示形式。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="LinkedBlockingDeque-源码分析-JDK1-7-0-40-版本"><a href="#LinkedBlockingDeque-源码分析-JDK1-7-0-40-版本" class="headerlink" title="LinkedBlockingDeque 源码分析 (JDK1.7.0_40 版本)"></a><strong><a></a>LinkedBlockingDeque 源码分析 (JDK1.7.0_40 版本)</strong></h2><p>LinkedBlockingDeque.java 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/LinkedBlockingDeque.java" target="_blank" rel="noopener">LinkedBlockingDeque.java 的完整源码</a></p>
<p>下面从 ArrayBlockingQueue 的创建，添加，取出，遍历这几个方面对 LinkedBlockingDeque 进行分析</p>
<p><strong>1. 创建</strong></p>
<p>下面以 LinkedBlockingDeque(int capacity) 来进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingDeque</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：capacity 是 “链式阻塞队列” 的容量。</p>
<p>LinkedBlockingDeque 中相关的数据结果定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “双向队列”的表头</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">// “双向队列”的表尾</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"><span class="comment">// 节点数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">// 互斥锁 , 互斥锁对应的“非空条件notEmpty”, 互斥锁对应的“未满条件notFull”</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：lock 是互斥锁，用于控制多线程对 LinkedBlockingDeque 中元素的互斥访问；而 notEmpty 和 notFull 是与 lock 绑定的条件，它们用于实现对多线程更精确的控制。</p>
<p>双向链表的节点 Node 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;       <span class="comment">// 数据</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 前一节点</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 后一节点</span></span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 添加</strong></p>
<p>下面以 offer(E e) 为例，对 LinkedBlockingDeque 的添加方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offerLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>offer() 实际上是调用 offerLast() 将元素添加到队列的末尾。</p>
<p>offerLast() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 新建节点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将“新节点”添加到双向链表的末尾</span></span><br><span class="line">        <span class="keyword">return</span> linkLast(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：offerLast() 的作用，是新建节点并将该节点插入到双向链表的末尾。它在插入节点前，会获取锁；操作完毕，再释放锁。</p>
<p>linkLast() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkLast</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果“双向链表的节点数量” &gt; “容量”，则返回false，表示插入失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将“node添加到链表末尾”，并设置node为新的尾节点</span></span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    node.prev = l;</span><br><span class="line">    last = node;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        first = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = node;</span><br><span class="line">    <span class="comment">// 将“节点数量”+1</span></span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">// 插入节点之后，唤醒notEmpty上的等待线程。</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：linkLast() 的作用，是将节点插入到双向队列的末尾；插入节点之后，唤醒 notEmpty 上的等待线程。</p>
<p><strong>3. 删除</strong></p>
<p>下面以 take() 为例，对 LinkedBlockingDeque 的取出方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> takeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take() 实际上是调用 takeFirst() 队列的第一个元素。</p>
<p>takeFirst() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="comment">// 若“队列为空”，则一直等待。否则，通过unlinkFirst()删除第一个节点。</span></span><br><span class="line">        <span class="keyword">while</span> ( (x = unlinkFirst()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：takeFirst() 的作用，是删除双向链表的第一个节点，并返回节点对应的值。它在插入节点前，会获取锁；操作完毕，再释放锁。</p>
<p>unlinkFirst() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 删除并更新“第一个节点”</span></span><br><span class="line">    Node&lt;E&gt; n = f.next;</span><br><span class="line">    E item = f.item;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = f; <span class="comment">// help GC</span></span><br><span class="line">    first = n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将“节点数量”-1</span></span><br><span class="line">    --count;</span><br><span class="line">    <span class="comment">// 删除节点之后，唤醒notFull上的等待线程。</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：unlinkFirst() 的作用，是将双向队列的第一个节点删除；删除节点之后，唤醒 notFull 上的等待线程。</p>
<p><strong>4. 遍历</strong></p>
<p>下面对 LinkedBlockingDeque 的遍历方法进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iterator() 实际上是返回一个 Iter 对象。</p>
<p>Itr 类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">extends</span> <span class="title">AbstractItr</span> </span>&#123;</span><br><span class="line">    <span class="comment">// “双向队列”的表头</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">firstNode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">    <span class="comment">// 获取“节点n的下一个节点”</span></span><br><span class="line">    <span class="function">Node&lt;E&gt; <span class="title">nextNode</span><span class="params">(Node&lt;E&gt; n)</span> </span>&#123; <span class="keyword">return</span> n.next; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Itr 继承于 AbstractItr，而 AbstractItr 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractItr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// next是下一次调用next()会返回的节点。</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// nextItem是next()返回节点对应的数据。</span></span><br><span class="line">    E nextItem;</span><br><span class="line">    <span class="comment">// 上一次next()返回的节点。</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastRet;</span><br><span class="line">    <span class="comment">// 返回第一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Node&lt;E&gt; <span class="title">firstNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Node&lt;E&gt; <span class="title">nextNode</span><span class="params">(Node&lt;E&gt; n)</span></span>;</span><br><span class="line"></span><br><span class="line">    AbstractItr() &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = LinkedBlockingDeque.<span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 获取“LinkedBlockingDeque的互斥锁”</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取“双向队列”的表头</span></span><br><span class="line">            next = firstNode();</span><br><span class="line">            <span class="comment">// 获取表头对应的数据</span></span><br><span class="line">            nextItem = (next == <span class="keyword">null</span>) ? <span class="keyword">null</span> : next.item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放“LinkedBlockingDeque的互斥锁”</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取n的后继节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Chains of deleted nodes ending in null or self-links</span></span><br><span class="line">        <span class="comment">// are possible if multiple interior nodes are removed.</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node&lt;E&gt; s = nextNode(n);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.item != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == n)</span><br><span class="line">                <span class="keyword">return</span> firstNode();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新next和nextItem。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = LinkedBlockingDeque.<span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// assert next != null;</span></span><br><span class="line">            next = succ(next);</span><br><span class="line">            nextItem = (next == <span class="keyword">null</span>) ? <span class="keyword">null</span> : next.item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“下一个节点是否为null”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        lastRet = next;</span><br><span class="line">        E x = nextItem;</span><br><span class="line">        advance();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; n = lastRet;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        lastRet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = LinkedBlockingDeque.<span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n.item != <span class="keyword">null</span>)</span><br><span class="line">                unlink(n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedBlockingDeque-示例"><a href="#LinkedBlockingDeque-示例" class="headerlink" title="LinkedBlockingDeque 示例"></a><strong><a></a>LinkedBlockingDeque 示例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   LinkedBlockingDeque是“线程安全”的队列，而LinkedList是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历queue”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当queue是LinkedBlockingDeque对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingDequeDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> queue是LinkedList对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 同时启动两个线程对queue进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"ta"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"tb"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value;</span><br><span class="line">        Iterator iter = queue.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "-" + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName()+i;</span><br><span class="line">                queue.add(val);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历queue。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ta1, ta1, tb1, tb1,</span><br><span class="line"></span><br><span class="line">ta1, ta1, tb1, tb1, tb2, tb2, ta2, </span><br><span class="line">ta2, </span><br><span class="line">ta1, ta1, tb1, tb1, tb2, tb2, ta2, ta2, tb3, tb3, ta3, </span><br><span class="line">ta3, ta1, </span><br><span class="line">tb1, ta1, tb2, tb1, ta2, tb2, tb3, ta2, ta3, tb3, tb4, ta3, ta4, </span><br><span class="line">tb4, ta1, ta4, tb1, tb5, </span><br><span class="line">tb2, ta1, ta2, tb1, tb3, tb2, ta3, ta2, tb4, tb3, ta4, ta3, tb5, tb4, ta5, </span><br><span class="line">ta4, ta1, tb5, tb1, ta5, tb2, tb6, </span><br><span class="line">ta2, ta1, tb3, tb1, ta3, tb2, tb4, ta2, ta4, tb3, tb5, ta3, ta5, tb4, tb6, ta4, ta6, </span><br><span class="line">tb5, ta5, tb6, ta6,</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：示例程序中，启动两个线程 (线程 ta 和线程 tb) 分别对 LinkedBlockingDeque 进行操作。以线程 ta 而言，它会先获取“线程名”+“序号”，然后将该字符串添加到 LinkedBlockingDeque 中；接着，遍历并输出 LinkedBlockingDeque 中的全部元素。 线程 tb 的操作和线程 ta 一样，只不过线程 tb 的名字和线程 ta 的名字不同。<br>当 queue 是 LinkedBlockingDeque 对象时，程序能正常运行。如果将 queue 改为 LinkedList 时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<h1 id="10-ConcurrentLinkedQueue"><a href="#10-ConcurrentLinkedQueue" class="headerlink" title="10 ConcurrentLinkedQueue"></a>10 ConcurrentLinkedQueue</h1><h2 id="概要-9"><a href="#概要-9" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章对 Java.util.concurrent 包中的 ConcurrentHashMap 类进行详细的介绍。内容包括：<br><a href="#a1">ConcurrentLinkedQueue 介绍</a><br><a href="#a2">ConcurrentLinkedQueue 原理和数据结构</a><br><a href="#a3">ConcurrentLinkedQueue 函数列表</a><br><a href="#a4">ConcurrentLinkedQueue 源码分析 (JDK1.7.0_40 版本)</a><br><a href="#a5">ConcurrentLinkedQueue 示例</a></p>
<h2 id="ConcurrentLinkedQueue-介绍"><a href="#ConcurrentLinkedQueue-介绍" class="headerlink" title="ConcurrentLinkedQueue 介绍"></a><strong><a></a>ConcurrentLinkedQueue 介绍</strong></h2><p>ConcurrentLinkedQueue 是线程安全的队列，它适用于 “高并发” 的场景。<br>它是一个基于<strong>链接节点的无界线程安全队列</strong>，按照 FIFO（先进先出）原则对元素进行排序。队列元素中不可以放置 null 元素（内部实现的特殊节点除外）。</p>
<h2 id="ConcurrentLinkedQueue-原理和数据结构"><a href="#ConcurrentLinkedQueue-原理和数据结构" class="headerlink" title="ConcurrentLinkedQueue 原理和数据结构"></a><strong><a></a>ConcurrentLinkedQueue 原理和数据结构</strong></h2><p>ConcurrentLinkedQueue 的数据结构，如下图所示：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219479687651.jpg" alt=""></p>
<p><strong>说明</strong>：<br>1. ConcurrentLinkedQueue 继承于 AbstractQueue。<br>2. ConcurrentLinkedQueue 内部是通过链表来实现的。它同时包含链表的头节点 head 和尾节点 tail。ConcurrentLinkedQueue 按照 FIFO（先进先出）原则对元素进行排序。元素都是从尾部插入到链表，从头部开始返回。<br>3. ConcurrentLinkedQueue 的链表 Node 中的 next 的类型是 volatile，而且链表数据 item 的类型也是 volatile。关于 volatile，我们知道它的语义包含：“即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”。ConcurrentLinkedQueue 就是通过 volatile 来实现多线程对竞争资源的互斥访问的。</p>
<h2 id="ConcurrentLinkedQueue-函数列表"><a href="#ConcurrentLinkedQueue-函数列表" class="headerlink" title="ConcurrentLinkedQueue 函数列表"></a><strong><a></a>ConcurrentLinkedQueue 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个最初为空的 ConcurrentLinkedQueue。</span></span><br><span class="line">ConcurrentLinkedQueue()</span><br><span class="line"><span class="comment">// 创建一个最初包含给定 collection 元素的 ConcurrentLinkedQueue，按照此 collection 迭代器的遍历顺序来添加元素。</span></span><br><span class="line">ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定元素插入此队列的尾部。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此队列包含指定元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此队列不包含任何元素，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回在此队列元素上以恰当顺序进行迭代的迭代器。</span></span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定元素插入此队列的尾部。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取但不移除此队列的头；如果此队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并移除此队列的头，如果此队列为空，则返回 null。</span></span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从队列中移除指定元素的单个实例（如果存在）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此队列中的元素数量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回以恰当顺序包含此队列所有元素的数组。</span></span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回以恰当顺序包含此队列所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentLinkedQueue-源码分析-JDK1-7-0-40-版本"><a href="#ConcurrentLinkedQueue-源码分析-JDK1-7-0-40-版本" class="headerlink" title="ConcurrentLinkedQueue 源码分析 (JDK1.7.0_40 版本)"></a><strong><a></a>ConcurrentLinkedQueue 源码分析 (JDK1.7.0_40 版本)</strong></h2><p>ConcurrentLinkedQueue 的完整源码如下：</p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/ConcurrentLinkedQueue.java" target="_blank" rel="noopener">ConcurrentLinkedQueue.java的完整源码</a></p>
<p>下面从 ConcurrentLinkedQueue 的创建，添加，删除这几个方面对它进行分析。</p>
<p><strong>1 创建</strong></p>
<p>下面以 ConcurrentLinkedQueue() 来进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：在构造函数中，新建了一个 “内容为 null 的节点”，并设置表头 head 和表尾 tail 的值为新节点。</p>
<p>head 和 tail 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br></pre></td></tr></table></figure>
<p>head 和 tail 都是 volatile 类型，他们具有 volatile 赋予的含义：“即对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入”。</p>
<p>Node 的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class k = Node.class;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>Node 是个单向链表节点，next 用于指向下一个 Node，item 用于存储数据。Node 中操作节点数据的 API，都是通过 Unsafe 机制的 CAS 函数实现的；例如 casNext() 是通过 CAS 函数 “比较并设置节点的下一个节点”。</p>
<p><strong>2. 添加</strong></p>
<p>下面以 add(E e) 为例对 ConcurrentLinkedQueue 中的添加进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：add() 实际上是调用的 offer() 来完成添加操作的。</p>
<p>offer() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查e是不是null，是的话抛出NullPointerException异常。</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 创建新的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将“新的节点”添加到链表的末尾。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="comment">// 情况1：q为空</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// CAS操作：如果“p的下一个节点为null”(即p为尾节点)，则设置p的下一个节点为newNode。</span></span><br><span class="line">            <span class="comment">// 如果该CAS操作成功的话，则比较“p和t”(若p不等于t，则设置newNode为新的尾节点)，然后返回true。</span></span><br><span class="line">            <span class="comment">// 如果该CAS操作失败，这意味着“其它线程对尾节点进行了修改”，则重新循环。</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2：p和q相等</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="comment">// 情况3：其它</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：offer(E e) 的作用就是将元素 e 添加到链表的末尾。offer() 比较的地方是理解 for 循环，下面区分 3 种情况对 for 进行分析。</p>
<p>情况 1 – q 为空。这意味着 q 是尾节点的下一个节点。此时，通过 p.casNext(null, newNode) 将 “p 的下一个节点设为 newNode”，若设置成功的话，则比较 “p 和 t”(若 p 不等于 t，则设置 newNode 为新的尾节点)，然后返回 true。否则的话 (意味着 “其它线程对尾节点进行了修改”)，什么也不做，继续进行 for 循环。<br>p.casNext(null, newNode)，是调用 CAS 对 p 进行操作。若 “p 的下一个节点等于 null”，则设置 “p 的下一个节点等于 newNode”；设置成功的话，返回 true，失败的话返回 false。</p>
<p>情况 2 – p 和 q 相等。这种情况什么时候会发生呢？通过 “情况 3”，我们知道，经过“情况 3” 的处理后，p 的值可能等于 q。<br>此时，若尾节点没有发生变化的话，那么，应该是头节点发生了变化，则设置 p 为头节点，然后重新遍历链表；否则 (尾节点变化的话)，则设置 p 为尾节点。</p>
<p>情况 3 – 其它。<br>我们将 p = (p != t &amp;&amp; t != (t = tail)) ? t : q; 转换成如下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p==t) &#123;</span><br><span class="line">    p = q;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;E&gt; tmp=t;</span><br><span class="line">    t = tail;</span><br><span class="line">    <span class="keyword">if</span> (tmp==t) &#123;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 p 和 t 相等，则设置 p 为 q。否则的话，判断 “尾节点是否发生变化”，没有变化的话，则设置 p 为 q；否则，设置 p 为尾节点。</p>
<p>checkNotNull() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkNotNull</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 删除</strong></p>
<p>下面以 poll() 为例对 ConcurrentLinkedQueue 中的删除进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置“标记”</span></span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况1</span></span><br><span class="line">            <span class="comment">// 表头的数据不为null，并且“设置表头的数据为null”这个操作成功的话;</span></span><br><span class="line">            <span class="comment">// 则比较“p和h”(若p!=h，即表头发生了变化，则更新表头，即设置表头为p)，然后返回原表头的item值。</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2</span></span><br><span class="line">            <span class="comment">// 表头的下一个节点为null，即链表只有一个“内容为null的表头节点”。则更新表头为p，并返回null。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3</span></span><br><span class="line">            <span class="comment">// 这可能到由于“情况4”的发生导致p=q，在该情况下跳转到restartFromHead标记重新操作。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="comment">// 情况4</span></span><br><span class="line">            <span class="comment">// 设置p为q</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：poll() 的作用就是删除链表的表头节点，并返回被删节点对应的值。poll() 的实现原理和 offer() 比较类似，下面根将 or 循环划分为 4 种情况进行分析。</p>
<p>情况 1：“表头节点的数据”不为 null，并且 “设置表头节点的数据为 null” 这个操作成功。<br>p.casItem(item, null) – 调用 CAS 函数，比较 “节点 p 的数据值” 与 item 是否相等，是的话，设置节点 p 的数据值为 null。<br>在情况 1 发生时，先比较 “p 和 h”，若 p!=h，即表头发生了变化，则调用 updateHead() 更新表头；然后返回删除节点的 item 值。<br>updateHead() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：updateHead() 的最终目的是更新表头为 p，并设置 h 的下一个节点为 h 本身。<br>casHead(h,p) 是通过 CAS 函数设置表头，若表头等于 h 的话，则设置表头为 p。<br>lazySetNext() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>putOrderedObject()函数，我们在前面一章 “TODO” 中介绍过。h.lazySetNext(h)的作用是通过 CAS 函数设置 h 的下一个节点为 h 自身，该设置可能会延迟执行。</p>
<p>情况 2：如果表头的下一个节点为 null，即链表只有一个 “内容为 null 的表头节点”。<br>则调用 updateHead(h, p)，将表头更新 p；然后返回 null。</p>
<p>情况 3：p=q<br>在 “情况 4” 的发生后，会导致 p=q；此时，“情况 3”就会发生。当 “情况 3” 发生后，它会跳转到 restartFromHead 标记重新操作。</p>
<p>情况 4：其它情况。<br>设置 p=q。</p>
<h3 id="ConcurrentLinkedQueue-示例"><a href="#ConcurrentLinkedQueue-示例" class="headerlink" title="ConcurrentLinkedQueue 示例"></a><strong><a></a>ConcurrentLinkedQueue 示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   ConcurrentLinkedQueue是“线程安全”的队列，而LinkedList是非线程安全的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   下面是“多个线程同时操作并且遍历queue”的示例</span></span><br><span class="line"><span class="comment"> *   (01) 当queue是ConcurrentLinkedQueue对象时，程序能正常运行。</span></span><br><span class="line"><span class="comment"> *   (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author skywang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueueDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> queue是LinkedList对象时，程序会出错。</span></span><br><span class="line">    <span class="comment">//private static Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 同时启动两个线程对queue进行操作！</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"ta"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">"tb"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value;</span><br><span class="line">        Iterator iter = queue.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">            value = (String)iter.next();</span><br><span class="line">            System.out.print(value+<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i++ &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="comment">// “线程名” + "-" + "序号"</span></span><br><span class="line">                String val = Thread.currentThread().getName()+i;</span><br><span class="line">                queue.add(val);</span><br><span class="line">                <span class="comment">// 通过“Iterator”遍历queue。</span></span><br><span class="line">                printAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ta1, ta1, tb1, tb1,</span><br><span class="line"></span><br><span class="line">ta1, ta1, tb1, tb1, ta2, ta2, tb2, </span><br><span class="line">tb2, </span><br><span class="line">ta1, ta1, tb1, tb1, ta2, ta2, tb2, tb2, ta3, tb3, </span><br><span class="line">ta3, ta1, tb3, tb1, ta4, </span><br><span class="line">ta2, ta1, tb2, tb1, ta3, ta2, tb3, tb2, ta4, ta3, tb4, </span><br><span class="line">tb3, ta1, ta4, tb1, tb4, ta2, ta5, </span><br><span class="line">tb2, ta1, ta3, tb1, tb3, ta2, ta4, tb2, tb4, ta3, ta5, tb3, tb5, </span><br><span class="line">ta4, ta1, tb4, tb1, ta5, ta2, tb5, tb2, ta6, </span><br><span class="line">ta3, ta1, tb3, tb1, ta4, ta2, tb4, tb2, ta5, ta3, tb5, tb3, ta6, ta4, tb6, </span><br><span class="line">tb4, ta5, tb5, ta6, tb6,</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：如果将源码中的 queue 改成 LinkedList 对象时，程序会产生 ConcurrentModificationException 异常。</p>
<hr>
<blockquote>
<p>原文地址：<br><a href="http://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/java_threads_category.html</a></p>
</blockquote>

      
    </div>
    
    
    


     
    
      <div>
        
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>

      </div>
    


    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    CloudPai
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://cloudpai.site/2018/03/24/2018-03-24-2/" title="java多线程系列四：JUC集合">http://cloudpai.site/2018/03/24/2018-03-24-2/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    




    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
            <a href="/tags/并发/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/24/2018-03-24-1/" rel="next" title="java多线程系列三：JUC锁">
                <i class="fa fa-chevron-left"></i> java多线程系列三：JUC锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/25/2018-03-25/" rel="prev" title="java多线程系列五：JUC线程池">
                java多线程系列五：JUC线程池 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>




  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg"
                alt="CloudPai" />
            
              <p class="site-author-name" itemprop="name">CloudPai</p>
              <p class="site-description motion-element" itemprop="description">加油(๑•̀ㅂ•́)و✧加油</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">103</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=240 src="//music.163.com/outchain/player?type=0&id=2113726971&auto=0&height=430"></iframe>
</div>
<!-- 459004290 -->




            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudPai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liupai024@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/57965969/doulists/all" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-book"></i>豆瓣</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/cloudPai/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-edit"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dlut.edu.cn/" title="DUT" target="_blank">DUT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bupt.edu.cn/" title="BUPT" target="_blank">BUPT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://campus.alibaba.com/index.htm" title="Alibaba Group" target="_blank">Alibaba Group</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#01-框架"><span class="nav-text">01 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-集合包"><span class="nav-text">Java 集合包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC-中的集合类"><span class="nav-text">JUC 中的集合类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#02-CopyOnWriteArrayList"><span class="nav-text">02 CopyOnWriteArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-1"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList-介绍"><span class="nav-text">CopyOnWriteArrayList 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList-原理和数据结构"><span class="nav-text">CopyOnWriteArrayList 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList-函数列表"><span class="nav-text">CopyOnWriteArrayList 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList-源码分析-JDK1-7-0-40-版本"><span class="nav-text">CopyOnWriteArrayList 源码分析 (JDK1.7.0_40 版本)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList-示例"><span class="nav-text">CopyOnWriteArrayList 示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#03-CopyOnWriteArraySet"><span class="nav-text">03 CopyOnWriteArraySet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-2"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArraySet-介绍"><span class="nav-text">CopyOnWriteArraySet 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArraySet-原理和数据结构"><span class="nav-text">CopyOnWriteArraySet 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArraySet-函数列表"><span class="nav-text">CopyOnWriteArraySet 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArraySet-源码-JDK1-7-0-40-版本"><span class="nav-text">CopyOnWriteArraySet 源码 (JDK1.7.0_40 版本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArraySet-示例"><span class="nav-text">CopyOnWriteArraySet 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-ConcurrentHashMap"><span class="nav-text">04 ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-3"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-介绍"><span class="nav-text">ConcurrentHashMap 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-原理和数据结构"><span class="nav-text">ConcurrentHashMap 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-函数列表"><span class="nav-text">ConcurrentHashMap 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-源码分析-JDK1-7-0-40-版本"><span class="nav-text">ConcurrentHashMap 源码分析 (JDK1.7.0_40 版本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-示例"><span class="nav-text">ConcurrentHashMap 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#05-ConcurrentSkipListMap"><span class="nav-text">05 ConcurrentSkipListMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-4"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListMap-介绍"><span class="nav-text">ConcurrentSkipListMap 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListMap-原理和数据结构"><span class="nav-text">ConcurrentSkipListMap 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListMap-函数列表"><span class="nav-text">ConcurrentSkipListMap 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListMap-源码分析-JDK1-7-0-40-版本"><span class="nav-text">ConcurrentSkipListMap 源码分析 (JDK1.7.0_40 版本)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentSkipListMap-示例"><span class="nav-text">ConcurrentSkipListMap 示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#06-ConcurrentSkipListSet"><span class="nav-text">06 ConcurrentSkipListSet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-5"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListSet-介绍"><span class="nav-text">ConcurrentSkipListSet 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListSet-原理和数据结构"><span class="nav-text">ConcurrentSkipListSet 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListSet-函数列表"><span class="nav-text">ConcurrentSkipListSet 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListSet-源码-JDK1-7-0-40-版本"><span class="nav-text">ConcurrentSkipListSet 源码 (JDK1.7.0_40 版本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentSkipListSet-示例"><span class="nav-text">ConcurrentSkipListSet 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#07-ArrayBlockingQueue"><span class="nav-text">07 ArrayBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-6"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBlockingQueue-介绍"><span class="nav-text">ArrayBlockingQueue 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBlockingQueue-原理和数据结构"><span class="nav-text">ArrayBlockingQueue 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBlockingQueue-函数列表"><span class="nav-text">ArrayBlockingQueue 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBlockingQueue-源码分析-JDK1-7-0-40-版本"><span class="nav-text">ArrayBlockingQueue 源码分析 (JDK1.7.0_40 版本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBlockingQueue-示例"><span class="nav-text">ArrayBlockingQueue 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#08-LinkedBlockingQueue"><span class="nav-text">08 LinkedBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-7"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue-介绍"><span class="nav-text">LinkedBlockingQueue 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue-原理和数据结构"><span class="nav-text">LinkedBlockingQueue 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue-函数列表"><span class="nav-text">LinkedBlockingQueue 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue-源码分析-JDK1-7-0-40-版本"><span class="nav-text">LinkedBlockingQueue 源码分析 (JDK1.7.0_40 版本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue-示例"><span class="nav-text">LinkedBlockingQueue 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#09-LinkedBlockingDeque"><span class="nav-text">09 LinkedBlockingDeque</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-8"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingDeque-介绍"><span class="nav-text">LinkedBlockingDeque 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingDeque-原理和数据结构"><span class="nav-text">LinkedBlockingDeque 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingDeque-函数列表"><span class="nav-text">LinkedBlockingDeque 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingDeque-源码分析-JDK1-7-0-40-版本"><span class="nav-text">LinkedBlockingDeque 源码分析 (JDK1.7.0_40 版本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingDeque-示例"><span class="nav-text">LinkedBlockingDeque 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-ConcurrentLinkedQueue"><span class="nav-text">10 ConcurrentLinkedQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-9"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentLinkedQueue-介绍"><span class="nav-text">ConcurrentLinkedQueue 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentLinkedQueue-原理和数据结构"><span class="nav-text">ConcurrentLinkedQueue 原理和数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentLinkedQueue-函数列表"><span class="nav-text">ConcurrentLinkedQueue 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentLinkedQueue-源码分析-JDK1-7-0-40-版本"><span class="nav-text">ConcurrentLinkedQueue 源码分析 (JDK1.7.0_40 版本)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentLinkedQueue-示例"><span class="nav-text">ConcurrentLinkedQueue 示例</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CloudPai</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">517.4k</span>
  
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">  </span>
</span>
</div>







  <div class="theme-info">&#12288;主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://cloudpai.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://cloudpai.site/2018/03/24/2018-03-24-2/';
          this.page.identifier = '2018/03/24/2018-03-24-2/';
          this.page.title = 'java多线程系列四：JUC集合';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://cloudpai.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!-- <!-- <script src="https://cdn.bootcss.com/aplayer/1.6.0/APlayer.min.js"></script>

<script src="https://api.i-meto.com/music/player.js"></script> --> -->
  
  <!--移动端判断，是否引入背景-->
  <script>
  var browser={  
      versions:function(){   
             var u = navigator.userAgent, app = navigator.appVersion;   
             return {//移动终端浏览器版本信息
                  trident: u.indexOf('Trident') > -1, //IE内核
                  presto: u.indexOf('Presto') > -1, //opera内核
                  webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                  gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                  mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                  ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                  android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                  iPhone: u.indexOf('iPhone') > -1 , //是否为iPhone或者QQHD浏览器
                  iPad: u.indexOf('iPad') > -1, //是否iPad
                  webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
              };  
           }(),  
           language:(navigator.browserLanguage || navigator.language).toLowerCase()  
  }   
    if(browser.versions.mobile || browser.versions.ios || browser.versions.android ||   
      browser.versions.iPhone || browser.versions.iPad){        
               
    }else{
    document.write("<script type=\'text/javascript\'  src=\'/js/src/particle.js\'><\/script>");
    }
  </script>

  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>
</html>
