<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,并发," />





  <link rel="alternate" href="/atom.xml" title="CloudPai" type="application/atom+xml" />






<meta name="description" content="01 框架根据锁添加到 Java 中的时间，Java 中的锁，可以分为 “ 同步锁 “和”JUC 包中的锁 “。 同步锁　　即通过 synchronized 关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0 版本中就已经支持同步锁了。 　　同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样">
<meta name="keywords" content="Java,并发">
<meta property="og:type" content="article">
<meta property="og:title" content="java多线程系列三：JUC锁">
<meta property="og:url" content="http://cloudpai.site/2018/03/24/2018-03-24-1/index.html">
<meta property="og:site_name" content="CloudPai">
<meta property="og:description" content="01 框架根据锁添加到 Java 中的时间，Java 中的锁，可以分为 “ 同步锁 “和”JUC 包中的锁 “。 同步锁　　即通过 synchronized 关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0 版本中就已经支持同步锁了。 　　同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219003314646.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219004035875.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219004291148.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219004579028.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219005355223.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219005557103.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219005916685.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219006492938.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219007544698.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219007832876.jpg">
<meta property="og:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219008098919.jpg">
<meta property="og:updated_time" content="2018-03-31T09:49:00.310Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java多线程系列三：JUC锁">
<meta name="twitter:description" content="01 框架根据锁添加到 Java 中的时间，Java 中的锁，可以分为 “ 同步锁 “和”JUC 包中的锁 “。 同步锁　　即通过 synchronized 关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0 版本中就已经支持同步锁了。 　　同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样">
<meta name="twitter:image" content="http://p4lmrb1gp.bkt.clouddn.com/15219003314646.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'TZAS2SFOJR',
      apiKey: 'e2a9cd036eede8026382b302001ec261',
      indexName: 'cloudpai_blogs_search',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://cloudpai.site/2018/03/24/2018-03-24-1/"/>





  <title>java多线程系列三：JUC锁 | CloudPai</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-114643720-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CloudPai</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间轴
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>




 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cloudpai.site/2018/03/24/2018-03-24-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CloudPai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CloudPai">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java多线程系列三：JUC锁</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T16:46:11+08:00">
                2018-03-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-03-31T17:49:00+08:00">
                2018-03-31
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/24/2018-03-24-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/24/2018-03-24-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  28,107
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  119
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <script src="/assets/js/APlayer.min.js"> </script><h1 id="01-框架"><a href="#01-框架" class="headerlink" title="01 框架"></a>01 框架</h1><p>根据锁添加到 Java 中的时间，Java 中的锁，可以分为 “ <a href="http://www.cnblogs.com/skywang12345/p/3479202.html" target="_blank" rel="noopener"><strong>同步锁</strong></a> “和”<strong>JUC 包中的锁</strong> “。</p>
<h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a><strong>同步锁</strong></h2><p>　　即通过 <strong>synchronized</strong> 关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0 版本中就已经支持同步锁了。</p>
<p>　　同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行 CPU 调度，从而在 CPU 上执行；而没有获取到同步锁的线程，必须进行等待，直到<strong>获取到同步锁之后才能继续运行</strong>。这就是，多线程通过同步锁进行同步的原理！</p>
<p>　　关于 “同步锁” 的更多内容，请参考 “<a href="http://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="noopener">Java 锁的基础部分</a> “ 的内容。</p>
<h2 id="JUC-包中的锁"><a href="#JUC-包中的锁" class="headerlink" title="JUC 包中的锁"></a><strong>JUC 包中的锁</strong></h2><p>　　相比同步锁，JUC 包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。</p>
<p>　　JUC 包中的锁，包括：Lock 接口，ReadWriteLock 接口，LockSupport 阻塞原语，Condition 条件，AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer 三个抽象类，ReentrantLock 独占锁，ReentrantReadWriteLock 读写锁。由于 CountDownLatch，CyclicBarrier 和 Semaphore 也是通过 AQS 来实现的；因此，我也将它们归纳到锁的框架中进行介绍。</p>
<p>　　先看看锁的框架图，如下所示。</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219003314646.jpg" alt=""></p>
<p><strong>01. Lock 接口</strong></p>
<p>　　JUC 包中的 Lock 接口支持那些语义不同 (重入、公平等) 的锁规则。所谓语义不同，是指锁可是有 “公平机制的锁”、”非公平机制的锁”、”可重入的锁” 等等。”公平机制” 是指 “不同线程获取锁的机制是公平的”，而 “非公平机制” 则是指 “不同线程获取锁的机制是非公平的”，”可重入的锁” 是指同一个锁能够被一个线程多次获取。</p>
<p><strong>02. ReadWriteLock</strong></p>
<p>　　ReadWriteLock 接口以和 Lock 类似的方式定义了一些读取者可以共享而写入者独占的锁。JUC 包只有一个类实现了该接口，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。</p>
<p><strong>03. AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer</strong><br>　　<strong>AbstractQueuedSynchronizer</strong> 就是被称之为 <strong>AQS</strong> 的类，它是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器；ReentrantLock，ReentrantReadWriteLock，CountDownLatch，CyclicBarrier 和 Semaphore 等这些类都是基于 AQS 类实现的。AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。</p>
<p><strong>04. LockSupport</strong><br>　　LockSupport 提供 “创建锁” 和“其他同步类的<strong>基本线程阻塞原语</strong>”。<br>　　LockSupport 的功能和 “Thread 中的 Thread.suspend()和 Thread.resume()有点类似”，LockSupport 中的 park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是 park()和 unpark()不会遇到 “Thread.suspend 和 Thread.resume 所可能引发的死锁” 问题。</p>
<p><strong>05. Condition</strong><br>　　Condition 需要和 Lock 联合使用，它的作用是代替 Object 监视器方法，可以通过 await(),signal() 来休眠 / 唤醒线程。<strong>strong text</strong><br>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</p>
<p><strong>06. ReentrantLock</strong></p>
<blockquote>
<p>Reentrant:可重入</p>
</blockquote>
<p>　　ReentrantLock 是<strong>独占锁</strong>。所谓独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。ReentrantLock 锁包括 “公平的 ReentrantLock” 和 “非公平的 ReentrantLock”。”公平的 ReentrantLock” 是指 “不同线程获取锁的机制是公平的”，而 “非公平的　　ReentrantLock” 则是指 “不同线程获取锁的机制是非公平的”，<strong>ReentrantLock 是 “可重入的锁”。</strong><br>　　ReentrantLock 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219004035875.jpg" alt=""></p>
<p>　　(01) ReentrantLock 实现了 Lock 接口。<br>　　(02) ReentrantLock 中有一个成员变量 sync，sync 是 Sync 类型；Sync 是一个抽象类，而且它继承于 AQS。<br>　　(03) ReentrantLock 中有 “公平锁类”FairSync 和 “非公平锁类”NonfairSync，它们都是 Sync 的子类。ReentrantReadWriteLock 中 sync 对象，是 FairSync 与 NonfairSync 中的一种，这也意味着 ReentrantLock 是 “公平锁” 或 “非公平锁” 中的一种，ReentrantLock 默认是非公平锁。</p>
<p><strong>07. ReentrantReadWriteLock</strong><br>　　ReentrantReadWriteLock 是读写锁接口 ReadWriteLock 的实现类，它包括子类 ReadLock 和 WriteLock。ReentrantLock 是共享锁，而 WriteLock 是独占锁。<br>　　ReentrantReadWriteLock 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219004291148.jpg" alt=""></p>
<p>　　(01) ReentrantReadWriteLock 实现了 ReadWriteLock 接口。<br>　　(02) ReentrantReadWriteLock 中包含 sync 对象，读锁 readerLock 和写锁 writerLock。读锁 ReadLock 和写锁 WriteLock 都实现了 Lock 接口。<br>　　(03) 和 “ReentrantLock” 一样，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平锁”FairSync 和 “非公平锁”NonfairSync。</p>
<p><strong>08. CountDownLatch</strong><br>　　CountDownLatch 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。<br>　　CountDownLatch 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219004579028.jpg" alt=""><br>　　CountDownLatch 包含了 sync 对象，sync 是 Sync 类型。CountDownLatch 的 Sync 是实例类，它继承于 AQS。</p>
<p><strong>09. CyclicBarrier</strong><br>　　CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。<br>　　CyclicBarrier 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219005355223.jpg" alt=""></p>
<p>　　CyclicBarrier 是包含了 “ReentrantLock 对象 lock” 和 “Condition 对象 trip”，它是通过独占锁实现的。<br>　　<strong>CyclicBarrier 和 CountDownLatch 的区别</strong>是：<br>　　(01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。<br>　　(02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。</p>
<p><strong>10. Semaphore</strong><br>　　Semaphore 是一个计数信号量，它的本质是一个 “共享锁”。<br>　　信号量维护了一个信号量许可集。线程可以通过调用 acquire() 来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过 release() 来释放它所持有的信号量许可。<br>　　Semaphore 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219005557103.jpg" alt=""></p>
<p>　　和 “ReentrantLock” 一样，Semaphore 包含了 sync 对象，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平信号量”FairSync 和 “非公平信号量”NonfairSync。</p>
<h1 id="02-互斥锁ReentrantLock"><a href="#02-互斥锁ReentrantLock" class="headerlink" title="02 互斥锁ReentrantLock"></a>02 互斥锁ReentrantLock</h1><p>本章对 ReentrantLock 包进行基本介绍，这一章主要对 ReentrantLock 进行概括性的介绍，内容包括：<br><a href="#p1">ReentrantLock 介绍</a><br><a href="#p2">ReentrantLock 函数列表</a><br><a href="#p3">ReentrantLock 示例</a><br>在后面的两章，会分别介绍 ReentrantLock 的两个子类 (公平锁和非公平锁) 的实现原理。</p>
<h2 id="ReentrantLock-介绍"><a href="#ReentrantLock-介绍" class="headerlink" title="ReentrantLock 介绍"></a><strong><a></a>ReentrantLock 介绍</strong></h2><p>ReentrantLock 是一个<strong>可重入的互斥锁</strong>，又被称为 “独占锁”。</p>
<p>顾名思义，ReentrantLock 锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock 锁，可以被单个线程多次获取。<br>ReentrantLock分为 “<strong>公平锁</strong>” 和 “<strong>非公平锁</strong>”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock 在同一个时间点只能被一个线程获取 (当某线程获取到“锁” 时，其它线程就必须等待)；ReentraantLock 是通过一个 FIFO 的等待队列来管理获取该锁所有线程的。在 “公平锁” 的机制下，线程依次排队获取锁；而 “非公平锁” 在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。</p>
<h2 id="ReentrantLock-函数列表"><a href="#ReentrantLock-函数列表" class="headerlink" title="ReentrantLock 函数列表"></a><strong><a></a>ReentrantLock 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 ReentrantLock ，默认是“非公平锁”。</span></span><br><span class="line">ReentrantLock()</span><br><span class="line"><span class="comment">// 创建策略是fair的 ReentrantLock。fair为true表示是公平锁，fair为false表示是非公平锁。</span></span><br><span class="line">ReentrantLock(<span class="keyword">boolean</span> fair)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询当前线程保持此锁的次数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Thread <span class="title">getOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个 collection，它包含可能正等待获取此锁的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回正等待获取此锁的线程估计数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回等待与此锁相关的给定条件的线程估计数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询给定线程是否正在等待获取此锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread thread)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询是否有些线程正在等待获取此锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询是否有些线程正在等待与此锁有关的给定条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果是“公平锁”返回true，否则返回false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询当前线程是否保持此锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询此锁是否由任意线程保持。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果当前线程未被中断，则获取锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回用来与此Lock实例一起使用的 Condition 实例。</span></span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 试图释放此锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ReentrantLock-示例"><a href="#ReentrantLock-示例" class="headerlink" title="ReentrantLock 示例"></a><strong><a></a>ReentrantLock 示例</strong></h2><p>通过对比 “示例 1” 和“示例 2”, 我们能够清晰的认识 lock 和 unlock 的作用</p>
<p><strong>示例 1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockTest1.java</span></span><br><span class="line"><span class="comment">// 仓库</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Depot</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;        <span class="comment">// 仓库的实际数量</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;        <span class="comment">// 独占锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Depot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            size += val;</span><br><span class="line">            System.out.printf(<span class="string">"%s produce(%d) --&gt; size=%d\n"</span>, </span><br><span class="line">                    Thread.currentThread().getName(), val, size);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            size -= val;</span><br><span class="line">            System.out.printf(<span class="string">"%s consume(%d) &lt;-- size=%d\n"</span>, </span><br><span class="line">                    Thread.currentThread().getName(), val, size);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Depot depot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程向仓库中生产产品。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                depot.produce(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Depot depot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程从仓库中消费产品。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                depot.consume(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest1</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Depot mDepot = <span class="keyword">new</span> Depot();</span><br><span class="line">        Producer mPro = <span class="keyword">new</span> Producer(mDepot);</span><br><span class="line">        Customer mCus = <span class="keyword">new</span> Customer(mDepot);</span><br><span class="line"></span><br><span class="line">        mPro.produce(<span class="number">60</span>);</span><br><span class="line">        mPro.produce(<span class="number">120</span>);</span><br><span class="line">        mCus.consume(<span class="number">90</span>);</span><br><span class="line">        mCus.consume(<span class="number">150</span>);</span><br><span class="line">        mPro.produce(<span class="number">110</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> produce(<span class="number">60</span>) --&gt; size=<span class="number">60</span></span><br><span class="line">Thread-<span class="number">1</span> produce(<span class="number">120</span>) --&gt; size=<span class="number">180</span></span><br><span class="line">Thread-<span class="number">3</span> consume(<span class="number">150</span>) &lt;-- size=<span class="number">30</span></span><br><span class="line">Thread-<span class="number">2</span> consume(<span class="number">90</span>) &lt;-- size=-<span class="number">60</span></span><br><span class="line">Thread-<span class="number">4</span> produce(<span class="number">110</span>) --&gt; size=<span class="number">50</span></span><br></pre></td></tr></table></figure>
<p><strong>结果分析</strong>：<br>(01) Depot 是个仓库。通过 produce()能往仓库中生产货物，通过 consume()能消费仓库中的货物。通过独占锁 lock 实现对仓库的互斥访问：在操作 (生产 / 消费) 仓库中货品前，会先通过 lock()锁住仓库，操作完之后再通过 unlock()解锁。<br>(02) Producer 是生产者类。调用 Producer 中的 produce() 函数可以新建一个线程往仓库中生产产品。<br>(03) Customer 是消费者类。调用 Customer 中的 consume() 函数可以新建一个线程消费仓库中的产品。<br>(04) 在主线程 main 中，我们会新建 1 个生产者 mPro，同时新建 1 个消费者 mCus。它们分别向仓库中生产 / 消费产品。<br>根据 main 中的生产 / 消费数量，仓库最终剩余的产品应该是 50。运行结果是符合我们预期的！</p>
<p>这个模型存在两个问题：<br>(01) 现实中，仓库的容量不可能为负数。但是，此模型中的仓库容量可以为负数，这与现实相矛盾！<br>(02) 现实中，仓库的容量是有限制的。但是，此模型中的容量确实没有限制的！<br>这两个问题，我们稍微会讲到如何解决。现在，先看个简单的示例 2；通过对比 “示例 1” 和“示例 2”, 我们能更清晰的认识 lock(),unlock()的用途。</p>
<p><strong>示例 2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockTest2.java</span></span><br><span class="line"><span class="comment">// 仓库</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Depot</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;        <span class="comment">// 仓库的实际数量</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;        <span class="comment">// 独占锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Depot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line">            size += val;</span><br><span class="line">            System.out.printf(<span class="string">"%s produce(%d) --&gt; size=%d\n"</span>, </span><br><span class="line">                    Thread.currentThread().getName(), val, size);</span><br><span class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        lock.lock();</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line">            size -= val;</span><br><span class="line">            System.out.printf(<span class="string">"%s consume(%d) &lt;-- size=%d\n"</span>, </span><br><span class="line">                    Thread.currentThread().getName(), val, size);</span><br><span class="line"><span class="comment">//        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//            lock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Depot depot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程向仓库中生产产品。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                depot.produce(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Depot depot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程从仓库中消费产品。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                depot.consume(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Depot mDepot = <span class="keyword">new</span> Depot();</span><br><span class="line">        Producer mPro = <span class="keyword">new</span> Producer(mDepot);</span><br><span class="line">        Customer mCus = <span class="keyword">new</span> Customer(mDepot);</span><br><span class="line"></span><br><span class="line">        mPro.produce(<span class="number">60</span>);</span><br><span class="line">        mPro.produce(<span class="number">120</span>);</span><br><span class="line">        mCus.consume(<span class="number">90</span>);</span><br><span class="line">        mCus.consume(<span class="number">150</span>);</span><br><span class="line">        mPro.produce(<span class="number">110</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 produce(60) --&gt; size=-60</span><br><span class="line">Thread-4 produce(110) --&gt; size=50</span><br><span class="line">Thread-2 consume(90) &lt;-- size=-60</span><br><span class="line">Thread-1 produce(120) --&gt; size=-60</span><br><span class="line">Thread-3 consume(150) &lt;-- size=-60</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：<br>“示例 2”在 “示例 1” 的基础上去掉了 lock 锁。在 “示例 2” 中，仓库中最终剩余的产品是 - 60，而不是我们期望的 50。原因是我们没有实现对仓库的互斥访问。</p>
<p><strong>示例 3</strong></p>
<p>在 “示例 3” 中，我们通过 Condition 去解决 “示例 1” 中的两个问题：“仓库的容量不可能为负数”以及“仓库的容量是有限制的”。<br><strong>解决该问题是通过 Condition</strong>。<strong>Condition 是需要和 Lock 联合使用的</strong>：通过 Condition 中的 await()方法，能让线程阻塞 [类似于 wait()]；通过 Condition 的 signal() 方法，能唤醒线程[类似于 notify()]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockTest3.java</span></span><br><span class="line"><span class="comment">// 仓库</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Depot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;    <span class="comment">// 仓库的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;        <span class="comment">// 仓库的实际数量</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock;        <span class="comment">// 独占锁</span></span><br><span class="line">    <span class="keyword">private</span> Condition fullCondtion;            <span class="comment">// 生产条件</span></span><br><span class="line">    <span class="keyword">private</span> Condition emptyCondtion;        <span class="comment">// 消费条件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Depot</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.fullCondtion = lock.newCondition();</span><br><span class="line">        <span class="keyword">this</span>.emptyCondtion = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// left 表示“想要生产的数量”(有可能生产量太多，需多此生产)</span></span><br><span class="line">            <span class="keyword">int</span> left = val;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 库存已满时，等待“消费者”消费产品。</span></span><br><span class="line">                <span class="keyword">while</span> (size &gt;= capacity)</span><br><span class="line">                    fullCondtion.await();</span><br><span class="line">                <span class="comment">// 获取“实际生产的数量”(即库存中新增的数量)</span></span><br><span class="line">                <span class="comment">// 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库)</span></span><br><span class="line">                <span class="comment">// 否则“实际增量”=“想要生产的数量”</span></span><br><span class="line">                <span class="keyword">int</span> inc = (size+left)&gt;capacity ? (capacity-size) : left;</span><br><span class="line">                size += inc;</span><br><span class="line">                left -= inc;</span><br><span class="line">                System.out.printf(<span class="string">"%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\n"</span>, </span><br><span class="line">                        Thread.currentThread().getName(), val, left, inc, size);</span><br><span class="line">                <span class="comment">// 通知“消费者”可以消费了。</span></span><br><span class="line">                emptyCondtion.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费)</span></span><br><span class="line">            <span class="keyword">int</span> left = val;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 库存为0时，等待“生产者”生产产品。</span></span><br><span class="line">                <span class="keyword">while</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">                    emptyCondtion.await();</span><br><span class="line">                <span class="comment">// 获取“实际消费的数量”(即库存中实际减少的数量)</span></span><br><span class="line">                <span class="comment">// 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”；</span></span><br><span class="line">                <span class="comment">// 否则，“实际消费量”=“客户要消费的数量”。</span></span><br><span class="line">                <span class="keyword">int</span> dec = (size&lt;left) ? size : left;</span><br><span class="line">                size -= dec;</span><br><span class="line">                left -= dec;</span><br><span class="line">                System.out.printf(<span class="string">"%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\n"</span>, </span><br><span class="line">                        Thread.currentThread().getName(), val, left, dec, size);</span><br><span class="line">                fullCondtion.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"capacity:"</span>+capacity+<span class="string">", actual size:"</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Depot depot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程向仓库中生产产品。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                depot.produce(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Depot depot;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Depot depot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.depot = depot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费产品：新建一个线程从仓库中消费产品。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                depot.consume(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest3</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Depot mDepot = <span class="keyword">new</span> Depot(<span class="number">100</span>);</span><br><span class="line">        Producer mPro = <span class="keyword">new</span> Producer(mDepot);</span><br><span class="line">        Customer mCus = <span class="keyword">new</span> Customer(mDepot);</span><br><span class="line"></span><br><span class="line">        mPro.produce(<span class="number">60</span>);</span><br><span class="line">        mPro.produce(<span class="number">120</span>);</span><br><span class="line">        mCus.consume(<span class="number">90</span>);</span><br><span class="line">        mCus.consume(<span class="number">150</span>);</span><br><span class="line">        mPro.produce(<span class="number">110</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 produce( 60) --&gt; left=  0, inc= 60, size= 60</span><br><span class="line">Thread-1 produce(120) --&gt; left= 80, inc= 40, size=100</span><br><span class="line">Thread-2 consume( 90) &lt;-- left=  0, dec= 90, size= 10</span><br><span class="line">Thread-3 consume(150) &lt;-- left=140, dec= 10, size=  0</span><br><span class="line">Thread-4 produce(110) --&gt; left= 10, inc=100, size=100</span><br><span class="line">Thread-3 consume(150) &lt;-- left= 40, dec=100, size=  0</span><br><span class="line">Thread-4 produce(110) --&gt; left=  0, inc= 10, size= 10</span><br><span class="line">Thread-3 consume(150) &lt;-- left= 30, dec= 10, size=  0</span><br><span class="line">Thread-1 produce(120) --&gt; left=  0, inc= 80, size= 80</span><br><span class="line">Thread-3 consume(150) &lt;-- left=  0, dec= 30, size= 50</span><br></pre></td></tr></table></figure>
<p>代码中的已经包含了很详细的注释，这里就不再说明了。<br>更多 “生产者 / 消费者模型” 的更多内容，可以参考“<strong><a href="http://www.cnblogs.com/skywang12345/p/3480016.html" target="_blank" rel="noopener">Java 多线程系列 –“基础篇”11 之 生产消费者问题</a></strong>”。<br>而关于 Condition 的内容，在后面我们会详细介绍。</p>
<hr>
<h1 id="03-公平锁-一"><a href="#03-公平锁-一" class="headerlink" title="03 公平锁(一)"></a>03 公平锁(一)</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章对 “公平锁” 的获取锁机制进行介绍(本文的公平锁指的是互斥锁的公平锁)，内容包括：<br><a href="#p1">基本概念</a> <a href="#s1">ReentrantLock 数据结构</a><br><a href="#p001">参考代码</a><br><a href="#p2">获取公平锁 (基于 JDK1.7.0_40)</a><br><a href="#p21">  一. tryAcquire()</a><br><a href="#p22">  二. addWaiter()</a><br><a href="#p23">  三. acquireQueued()</a><br><a href="#p24">  四. selfInterrupt()</a><br>“公平锁” 的释放锁的机制在后面一章再做介绍，锁的使用示例请参考 “<a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a>”。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong><a></a>基本概念</strong></h2><p>本章，我们会讲解 “线程获取公平锁” 的原理；在讲解之前，需要了解几个基本概念。后面的内容，都是基于这些概念的；这些概念可能比较枯燥，但从这些概念中，能窥见 “java 锁” 的一些架构，这对我们了解锁是有帮助的。<br>1. <strong>AQS</strong> – 指 AbstractQueuedSynchronizer 类。<br>    AQS 是 java 中管理 “锁” 的抽象类，锁的许多公共方法都是在这个类中实现。AQS 是独占锁 (例如，ReentrantLock) 和共享锁 (例如，Semaphore) 的公共父类。</p>
<p>2. <strong>AQS</strong> 锁的类别 – 分为 “<strong>独占锁</strong>” 和 “<strong>共享锁</strong>” 两种。<br>    (01) <strong>独占锁</strong> – 锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为 “<strong>公平锁</strong>” 和 “<strong>非公平锁</strong>”。公平锁，是按照通过 CLH 等待线程按照先来先得的规则，公平的获取锁；而非公平锁，则当线程要获取锁时，它会无视 CLH 等待队列而直接获取锁。独占锁的典型实例子是 ReentrantLock，此外，ReentrantReadWriteLock.WriteLock 也是独占锁。<br>    (02) <strong>共享锁</strong> – 能被多个线程同时拥有，能被共享的锁。JUC 包中的 ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch 和 Semaphore 都是共享锁。这些锁的用途和原理，在以后的章节再详细介绍。</p>
<ol>
<li><strong>CLH 队列</strong> – Craig, Landin, and Hagersten lock queue<br> CLH 队列是 AQS 中 “等待锁” 的线程队列。在多线程中，为了保护竞争资源不被多个线程同时操作而起来错误，我们常常需要通过锁来保护这些资源。在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；而其它线程则需要等待。CLH 就是管理这些 “等待锁” 的线程的队列。<br> CLH 是一个非阻塞的 FIFO 队列。也就是说往里面插入或移除一个节点的时候，在并发条件下不会阻塞，而是通过<strong>自旋锁</strong>和 <strong>CAS</strong> 保证节点插入和移除的原子性。</li>
</ol>
<p>4. <strong>CAS 函数</strong> – Compare And Swap<br>    CAS 函数，是比较并交换函数，它是原子操作函数；即，通过 CAS 操作的数据都是以<strong>原子方式</strong>进行的。例如，compareAndSetHead(), compareAndSetTail(), compareAndSetNext() 等函数。它们共同的特点是，这些函数所执行的动作是以原子的方式进行的。</p>
<p>本章是围绕 “公平锁” 如何获取锁而层次展开。“公平锁”涉及到的知识点比较多，但总的来说，不是特别难；如果读者能读懂 AQS 和 ReentrantLock.java 这两个类的大致意思，理解锁的原理和机制也就不成问题了。本章只是作者本人对锁的一点点理解，希望这部分知识能帮助您了解 “公平锁” 的获取过程，认识 “锁” 的框架。</p>
<h2 id="ReentrantLock-数据结构"><a href="#ReentrantLock-数据结构" class="headerlink" title="ReentrantLock 数据结构"></a><strong><a></a>ReentrantLock 数据结构</strong></h2><p>ReentrantLock 的 UML 类图<br><img src="http://p4lmrb1gp.bkt.clouddn.com/15219005916685.jpg" alt=""></p>
<p>从图中可以看出：<br>(01) ReentrantLock 实现了 Lock 接口。<br>(02) ReentrantLock 与 sync 是组合关系。ReentrantLock 中，包含了 Sync 对象；而且，Sync 是 AQS 的子类；更重要的是，Sync 有两个子类 FairSync(公平锁) 和 NonFairSync(非公平锁)。ReentrantLock 是一个独占锁，至于它到底是公平锁还是非公平锁，就取决于 sync 对象是 “FairSync 的实例” 还是 “NonFairSync 的实例”。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a><strong><a></a>参考代码</strong></h2><p>下面给出 Java1.7.0_40 版本中，ReentrantLock 和 AQS 的源码，仅供参考！</p>
<p><strong>ReentranLock.java</strong></p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/ReentranLock.java" target="_blank" rel="noopener">ReentranLock.java源码</a></p>
<p><strong>AQS(AbstractQueuedSynchronizer.java)</strong></p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/AbstractQueuedSynchronizer.java" target="_blank" rel="noopener">AbstractQueuedSynchronizer.java源码</a></p>
<h2 id="获取公平锁-基于-JDK1-7-0-40"><a href="#获取公平锁-基于-JDK1-7-0-40" class="headerlink" title="获取公平锁 (基于 JDK1.7.0_40)"></a><strong><a></a>获取公平锁 (基于 JDK1.7.0_40)</strong></h2><p>通过前面 “<a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a>”的 “示例 1”，我们知道，获取锁是通过 lock() 函数。下面，我们以 lock()对获取公平锁的过程进行展开。</p>
<p><strong>1. lock()</strong></p>
<p>lock() 在 ReentrantLock.java 的 FairSync 类中实现，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：“当前线程” 实际上是通过 acquire(1) 获取锁的。<br>        这里说明一下 “<strong>1</strong>”的含义，它是设置 “锁的状态” 的参数。对于 “独占锁” 而言，锁处于可获取状态时，它的状态值是 0；锁被线程初次获取到了，它的状态值就变成了 1。<br>        由于 ReentrantLock(公平锁 / 非公平锁)是可重入锁，所以 “独占锁” 可以被单个线程多此获取，每获取 1 次就将锁的状态 + 1。也就是说，初次获取锁时，通过 acquire(1)将锁的状态值设为 1；再次获取锁时，将锁的状态值设为 2；依次类推… 这就是为什么获取锁时，传入的参数是 1 的原因了。<br>        可重入就是指锁可以被单个线程多次获取。</p>
<p><strong>2. acquire()</strong></p>
<p>acquire() 在 AQS 中实现的，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(01) “当前线程” 首先通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列排序等待 (前面还有可能有需要线程在等待该锁)。<br>(02) “当前线程”尝试失败的情况下，先通过 addWaiter(Node.EXCLUSIVE)来将 “当前线程” 加入到 “CLH 队列(非阻塞的 FIFO 队列)” 末尾。CLH 队列就是线程等待队列。<br>(03) 再执行完 addWaiter(Node.EXCLUSIVE) 之后，会调用 acquireQueued() 来获取锁。由于此时 ReentrantLock 是公平锁，它会<strong>根据公平性原则</strong>来获取锁。<br>(04) “当前线程” 在执行 acquireQueued() 时，会进入到 CLH 队列中休眠等待，直到获取锁了才返回！如果 “当前线程” 在休眠等待过程中被中断过，acquireQueued 会返回 true，此时 “当前线程” 会调用 selfInterrupt()来自己给自己产生一个中断。至于为什么要自己给自己产生一个中断，后面再介绍。</p>
<p>上面是对 acquire() 的概括性说明。下面，我们将该函数分为 4 部分来逐步解析。<br><strong><a href="#p21">一. tryAcquire()</a></strong><br><strong><a href="#p22">二. addWaiter()</a></strong><br><strong><a href="#p23">三. acquireQueued()</a></strong><br><strong><a href="#p24">四. selfInterrupt()</a></strong></p>
<h3 id="一-tryAcquire"><a href="#一-tryAcquire" class="headerlink" title="一. tryAcquire()"></a><strong><a></a>一. tryAcquire()</strong></h3><p><strong>1. tryAcquire()</strong></p>
<p>公平锁的 tryAcquire() 在 ReentrantLock.java 的 <strong>FairSync</strong> 类中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取“当前线程”</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取“独占锁”的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// c=0意味着“锁没有被任何线程锁拥有”，</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若“锁没有被任何线程锁拥有”，</span></span><br><span class="line">        <span class="comment">// 则判断“当前线程”是不是CLH队列中的第一个线程线程，</span></span><br><span class="line">        <span class="comment">// 若是的话，则获取该锁，设置锁的状态，并切设置锁的拥有者为“当前线程”。</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果“独占锁”的拥有者已经为“当前线程”，</span></span><br><span class="line">        <span class="comment">// 则将更新锁的状态。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：根据代码，我们可以分析出，tryAcquire() 的作用就是<strong>尝试去获取锁</strong>。注意，这里只是尝试！<br>         尝试成功的话，返回 true；尝试失败的话，返回 false，后续再通过其它办法来获取该锁。后面我们会说明，在尝试失败的情况下，是如何一步步获取锁的。</p>
<p><strong>2. hasQueuedPredecessors()</strong></p>
<p>hasQueuedPredecessors() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>： 通过代码，能分析出，hasQueuedPredecessors() 是通过判断 “当前线程” 是不是在 CLH 队列的队首，来返回 AQS 中是不是有比 “当前线程” 等待更久的线程。下面对 head、tail 和 Node 进行说明。</p>
<p><strong>3. Node 的源码</strong></p>
<p>Node 就是 CLH 队列的节点。Node 在 AQS 中实现，它的数据结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;    <span class="comment">// CLH队列的队首</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;    <span class="comment">// CLH队列的队尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CLH队列的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程已被取消，对应的waitStatus的值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// “当前线程的后继线程需要被unpark(唤醒)”，对应的waitStatus的值。</span></span><br><span class="line">    <span class="comment">// 一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 线程(处在Condition休眠状态)在等待Condition唤醒，对应的waitStatus的值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// (共享锁)其它线程获取到“共享锁”，对应的waitStatus的值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus为“CANCELLED, SIGNAL, CONDITION, PROPAGATE”时分别表示不同状态，</span></span><br><span class="line">    <span class="comment">// 若waitStatus=0，则意味着当前线程不属于上面的任何一种状态。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前一节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后一节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点所对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextWaiter是“区别当前CLH队列是 ‘独占锁’队列 还是 ‘共享锁’队列 的标记”</span></span><br><span class="line">    <span class="comment">// 若nextWaiter=SHARED，则CLH队列是“独占锁”队列；</span></span><br><span class="line">    <span class="comment">// 若nextWaiter=EXCLUSIVE，(即nextWaiter=null)，则CLH队列是“共享锁”队列。</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “共享锁”则返回true，“独占锁”则返回false。</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回前一节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数。thread是节点所对应的线程，mode是用来表示thread的锁是“独占锁”还是“共享锁”。</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数。thread是节点所对应的线程，waitStatus是线程的等待状态。</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>Node 是 CLH 队列的节点，代表 “等待锁的线程队列”。<br>(01) 每个 Node 都会一个线程对应。<br>(02) 每个 Node 会通过 prev 和 next 分别指向上一个节点和下一个节点，这分别代表上一个等待线程和下一个等待线程。<br>(03) Node 通过 waitStatus 保存线程的等待状态。<br>(04) Node 通过 nextWaiter 来区分线程是 “独占锁” 线程还是 “共享锁” 线程。如果是 “独占锁” 线程，则 nextWaiter 的值为 EXCLUSIVE；如果是 “共享锁” 线程，则 nextWaiter 的值是 SHARED。</p>
<p><strong>4. compareAndSetState()</strong></p>
<p>compareAndSetState() 在 AQS 中实现。它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>： compareAndSwapInt() 是 sun.misc.Unsafe 类中的一个本地方法。对此，我们需要了解的是 compareAndSetState(expect, update) 是以原子的方式操作当前线程；若当前线程的状态为 expect，则设置它的状态为 update。</p>
<p><strong>5. setExclusiveOwnerThread()</strong></p>
<p>setExclusiveOwnerThread() 在 AbstractOwnableSynchronizer.java 中实现，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exclusiveOwnerThread是当前拥有“独占锁”的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    exclusiveOwnerThread = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：setExclusiveOwnerThread()的作用就是，设置线程 t 为当前拥有 “独占锁” 的线程。</p>
<p><strong>6. getState(), setState()</strong></p>
<p>getState() 和 setState() 都在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 设置锁的状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取锁的状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：state 表示锁的状态，对于 “独占锁” 而已，state=0 表示锁是可获取状态(即，锁没有被任何线程锁持有)。由于 java 中的独占锁是可重入的，state 的值可以 &gt; 1。</p>
<p><strong>小结</strong>：tryAcquire()的作用就是让 “当前线程” 尝试获取锁。获取成功返回 true，失败则返回 false。</p>
<h3 id="二-addWaiter-Node-EXCLUSIVE"><a href="#二-addWaiter-Node-EXCLUSIVE" class="headerlink" title="二. addWaiter(Node.EXCLUSIVE)"></a><strong><a></a>二. addWaiter(Node.EXCLUSIVE)</strong></h3><p>addWaiter(Node.EXCLUSIVE)的作用是，创建 “当前线程” 的 Node 节点，且 Node 中记录 “当前线程” 对应的锁是 “独占锁” 类型，并且将该节点添加到 CLH 队列的末尾。</p>
<p><strong>1.addWaiter()</strong></p>
<p>addWaiter() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个Node节点，节点对应的线程是“当前线程”，“当前线程”的锁的模型是mode。</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 若CLH队列不为空，则将“当前线程”添加到CLH队列末尾</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若CLH队列为空，则调用enq()新建CLH队列，然后再将“当前线程”添加到CLH队列中。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：对于 “公平锁” 而言，addWaiter(Node.EXCLUSIVE)会首先创建一个 Node 节点，节点的类型是 “独占锁”(Node.EXCLUSIVE) 类型。然后，再将该节点添加到 CLH 队列的末尾。</p>
<p><strong>2. compareAndSetTail()</strong></p>
<p>compareAndSetTail() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：compareAndSetTail 也属于 CAS 函数，也是通过 “本地方法” 实现的。compareAndSetTail(expect, update)会以原子的方式进行操作，它的作用是判断 CLH 队列的队尾是不是为 expect，是的话，就将队尾设为 update。</p>
<p><strong>3. enq()</strong></p>
<p>enq() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>： enq() 的作用很简单。如果 CLH 队列为空，则新建一个 CLH 表头；然后将 node 添加到 CLH 末尾。否则，直接将 node 添加到 CLH 末尾。</p>
<p>小结：addWaiter()的作用，就是将当前线程添加到 CLH 队列中。这就意味着将当前线程添加到等待获取 “锁” 的等待线程队列中了。</p>
<h3 id="三-acquireQueued"><a href="#三-acquireQueued" class="headerlink" title="三. acquireQueued()"></a><strong><a></a>三. acquireQueued()</strong></h3><p>前面，我们已经将当前线程添加到 CLH 队列中了。而 acquireQueued() 的作用就是逐步的去执行 CLH 队列的线程，如果当前线程获取到了锁，则返回；否则，当前线程进行休眠，直到唤醒并重新获取锁了才返回。下面，我们看看 acquireQueued() 的具体流程。</p>
<p><strong>1. acquireQueued()</strong></p>
<p>acquireQueued() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// interrupted表示在CLH队列的调度中，</span></span><br><span class="line">        <span class="comment">// “当前线程”在休眠时，有没有被中断过。</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取上一个节点。</span></span><br><span class="line">            <span class="comment">// node是“当前线程”对应的节点，这里就意味着“获取上一个等待锁的线程”。</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：acquireQueued() 的目的是从队列中获取锁。</p>
<p><strong>2. shouldParkAfterFailedAcquire()</strong></p>
<p>shouldParkAfterFailedAcquire() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回“当前线程是否应该阻塞”</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前继节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前继节点是SIGNAL状态，则意味这当前线程需要被unpark唤醒。此时，返回true。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点”  为  “‘原前继节点’的前继节点”。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>(01) 关于 waitStatus 请参考下表 (中扩号内为 waitStatus 的值)，更多关于 waitStatus 的内容，可以参考前面的 Node 类的介绍。</p>
<p>CANCELLED[1]  – 当前线程已被取消<br>SIGNAL[-1]    – “当前线程的后继线程需要被unpark(唤醒)”。一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。<br>CONDITION[-2] – 当前线程(处在Condition休眠状态)在等待Condition唤醒<br>PROPAGATE[-3] – (共享锁)其它线程获取到“共享锁”<br>[0]           – 当前线程不属于上面的任何一种状态。</p>
<p>(02) shouldParkAfterFailedAcquire()通过以下规则，判断 “当前线程” 是否需要被阻塞。</p>
<p>规则1：如果前继节点状态为SIGNAL，表明当前节点需要被unpark(唤醒)，此时则返回true。<br>规则2：如果前继节点状态为CANCELLED(ws&gt;0)，说明前继节点已经被取消，则通过先前回溯找到一个有效(非CANCELLED状态)的节点，并返回false。<br>规则3：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，并返回false。</p>
<p>如果 “规则 1” 发生，即 “前继节点是 SIGNAL” 状态，则意味着 “当前线程” 需要被阻塞。接下来会调用 parkAndCheckInterrupt()阻塞当前线程，直到当前先被唤醒才从 parkAndCheckInterrupt()中返回。</p>
<p><strong>3. parkAndCheckInterrupt())</strong></p>
<p>parkAndCheckInterrupt() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过LockSupport的park()阻塞“当前线程”。</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 返回线程的中断状态。</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：parkAndCheckInterrupt()的作用是阻塞当前线程，并且返回 “线程被唤醒之后” 的中断状态。<br>它会先通过 LockSupport.park()阻塞 “当前线程”，然后通过 Thread.interrupted() 返回线程的中断状态。</p>
<p>这里介绍一下线程被阻塞之后如何唤醒。一般有 2 种情况：<br><strong>第 1 种情况</strong>：unpark() 唤醒。“前继节点对应的线程” 使用完锁之后，通过 unpark() 方式唤醒当前线程。<br><strong>第 2 种情况</strong>：中断唤醒。其它线程通过 interrupt() 中断当前线程。</p>
<p><strong>补充</strong>：LockSupport() 中的 park(),unpark() 的作用 和 Object 中的 wait(),notify() 作用类似，是阻塞 / 唤醒。<br>它们的用法不同，park(),unpark() 是轻量级的，而 wait(),notify() 是必须先通过 Synchronized 获取同步锁。<br><strong>关于 LockSupport，我们会在之后的章节再专门进行介绍！</strong></p>
<p><strong>4. 再次 tryAcquire()</strong></p>
<p>了解了 shouldParkAfterFailedAcquire() 和 parkAndCheckInterrupt() 函数之后。我们接着分析 acquireQueued() 的 for 循环部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    failed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>(01) 通过 node.predecessor() 获取前继节点。predecessor() 就是返回 node 的前继节点，若对此有疑惑可以查看下面关于 Node 类的介绍。<br>(02) p == head &amp;&amp; tryAcquire(arg)<br>       首先，判断 “前继节点” 是不是 CHL 表头。如果是的话，则通过 tryAcquire()尝试获取锁。<br>       其实，这样做的目的是为了 “让当前线程获取锁”，但是为什么需要先判断 p==head 呢？理解这个对理解“公平锁” 的机制很重要，因为这么做的原因就是为了保证公平性！<br>       (a) 前面，我们在 shouldParkAfterFailedAcquire()我们判断 “当前线程” 是否需要阻塞；<br>       (b) 接着，“当前线程”阻塞的话，会调用 parkAndCheckInterrupt()来阻塞线程。当线程被解除阻塞的时候，我们会返回线程的中断状态。而线程被解决阻塞，可能是由于 “线程被中断”，也可能是由于“其它线程调用了该线程的 unpark() 函数”。<br>       (c) 再回到 p==head 这里。如果当前线程是因为其它线程调用了 unpark()函数而被唤醒，那么唤醒它的线程，应该是它的前继节点所对应的线程 (关于这一点，后面在“释放锁” 的过程中会看到)。 OK，是前继节点调用 unpark()唤醒了当前线程！<br>            此时，再来理解 p==head 就很简单了：当前继节点是 CLH 队列的头节点，并且它释放锁之后；就轮到当前节点获取锁了。然后，当前节点通过 tryAcquire() 获取锁；获取成功的话，通过 setHead(node) 设置当前节点为头节点，并返回。<br>       总之，如果 “前继节点调用 unpark() 唤醒了当前线程”并且 “前继节点是 CLH 表头”，此时就是满足 p==head，也就是符合公平性原则的。否则，如果当前线程是因为“线程被中断” 而唤醒，那么显然就不是公平了。这就是为什么说 p==head 就是保证公平性！</p>
<p><strong>小结</strong>：acquireQueued()的作用就是 “当前线程” 会根据公平性原则进行阻塞等待，直到获取锁为止；并且返回当前线程在等待过程中有没有并中断过。</p>
<h3 id="四-selfInterrupt"><a href="#四-selfInterrupt" class="headerlink" title="四. selfInterrupt()"></a><a></a>四. selfInterrupt()</h3><p>selfInterrupt() 是 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：selfInterrupt()的代码很简单，就是 “当前线程” 自己产生一个中断。但是，为什么需要这么做呢？<br>这必须结合 acquireQueued() 进行分析。如果在 acquireQueued() 中，当前线程被中断过，则执行 selfInterrupt()；否则不会执行。</p>
<p>在 acquireQueued() 中，即使是线程在阻塞状态被中断唤醒而获取到 cpu 执行权利；但是，如果该线程的前面还有其它等待锁的线程，根据公平性原则，该线程依然无法获取到锁。它会再次阻塞！ 该线程再次阻塞，直到该线程被它的前面等待锁的线程锁唤醒；线程才会获取锁，然后 “真正执行起来”！<br>也就是说，在该线程 “成功获取锁并真正执行起来” 之前，它的中断会被忽略并且中断标记会被清除！ 因为在 parkAndCheckInterrupt()中，我们线程的中断状态时调用了 Thread.interrupted()。该函数不同于 Thread 的 isInterrupted()函数，isInterrupted()仅仅返回中断状态，而 interrupted()在返回当前中断状态之后，还会清除中断状态。 正因为之前的中断状态被清除了，所以这里需要调用 selfInterrupt()重新产生一个中断！</p>
<p><strong>小结</strong>：selfInterrupt() 的作用就是当前线程自己产生一个中断。</p>
<p><strong>总结</strong></p>
<p>再回过头看看 acquire() 函数，它最终的目的是获取锁！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(01) 先是通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，再通过 acquireQueued() 获取锁。<br>(02) 尝试失败的情况下，会先通过 addWaiter()来将 “当前线程” 加入到 “CLH 队列” 末尾；然后调用 acquireQueued()，在 CLH 队列中排序等待获取锁，在此过程中，线程处于休眠状态。直到获取锁了才返回。 如果在休眠等待过程中被中断过，则调用 selfInterrupt()来自己产生一个中断。</p>
<hr>
<h1 id="04-公平锁-二"><a href="#04-公平锁-二" class="headerlink" title="04 公平锁(二)"></a>04 公平锁(二)</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>前面一章，我们学习了 “公平锁” 获取锁的详细流程；这里，我们再来看看 “公平锁” 释放锁的过程。内容包括：<br><a href="#a3">释放公平锁 (基于 JDK1.7.0_40)</a><br>“公平锁” 的获取过程请参考 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a>”，<br>锁的使用示例请参考 “<a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a>”。<br><strong>注意</strong>：<br>(01) 这里是以 “公平锁” 来进行说明。<br>(02) 关于本章的术语，如 “AQS”，“CAS 函数”，“CLH 队列”，“公平锁”，“非公平锁”，“独占锁”，“共享锁” 等内容，请参考 <strong><a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a></strong> 的<strong>基本概念</strong>。</p>
<h2 id="释放公平锁-基于-JDK1-7-0-40"><a href="#释放公平锁-基于-JDK1-7-0-40" class="headerlink" title="释放公平锁 (基于 JDK1.7.0_40)"></a><strong><a></a>释放公平锁 (基于 JDK1.7.0_40)</strong></h2><p><strong>1. unlock()</strong></p>
<p>unlock() 在 ReentrantLock.java 中实现的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>unlock() 是解锁函数，它是通过 AQS 的 release() 函数来实现的。<br>在这里，“1”的含义和 “获取锁的函数 acquire(1) 的含义”一样，它是设置 “释放锁的状态” 的参数。由于 “公平锁” 是可重入的，所以对于同一个线程，每释放锁一次，锁的状态 - 1。</p>
<p>关于 AQS, ReentrantLock 和 sync 的关系如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中，我们发现：sync 是 ReentrantLock.java 中的成员对象，而 Sync 是 AQS 的子类。</p>
<p><strong>2. release()</strong></p>
<p>release() 在 AQS 中实现的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>release() 会先调用 tryRelease() 来尝试释放当前线程锁持有的锁。成功的话，则唤醒后继等待线程，并返回 true。否则，直接返回 false。</p>
<p><strong>3. tryRelease()</strong></p>
<p>tryRelease() 在 ReentrantLock.java 的 Sync 类中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c是本次释放锁之后的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果“当前线程”不是“锁的持有者”，则抛出异常！</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果“锁”已经被当前线程彻底释放，则设置“锁”的持有者为null，即锁是可获取状态。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前线程的锁的状态。</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>tryRelease() 的作用是尝试释放锁。<br>(01) 如果 “当前线程” 不是“锁的持有者”，则抛出异常。<br>(02) 如果 “当前线程” 在本次释放锁操作之后，对锁的拥有状态是 0(即，当前线程彻底释放该 “锁”)，则设置“锁” 的持有者为 null，即锁是可获取状态。同时，更新当前线程的锁的状态为 0。<br>getState(), setState() 在前一章已经介绍过，这里不再说明。<br>getExclusiveOwnerThread(), setExclusiveOwnerThread() 在 AQS 的父类 AbstractOwnableSynchronizer.java 中定义，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “锁”的持有线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置“锁的持有线程”为t</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取“锁的持有线程”</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. unparkSuccessor()</strong></p>
<p>在 release()中 “当前线程” 释放锁成功的话，会唤醒当前线程的后继线程。<br>根据 CLH 队列的 FIFO 规则，“当前线程”(即已经获取锁的线程) 肯定是 head；如果 CLH 队列非空的话，则唤醒锁的下一个等待线程。<br>下面看看 unparkSuccessor() 的源码，它在 AQS 中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果状态&lt;0，则设置状态=0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前节点的“有效的后继节点”，无效的话，则通过for循环进行获取。</span></span><br><span class="line">    <span class="comment">// 这里的有效，是指“后继节点对应的线程状态&lt;=0”</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒“后继节点对应的线程”</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>unparkSuccessor() 的作用是 “唤醒当前线程的后继线程”。后继线程被唤醒之后，就可以获取该锁并恢复运行了。<br>关于 node.waitStatus 的说明，请参考 “上一章关于 Node 类的介绍”。</p>
<p><strong>总结</strong></p>
<p>“释放锁”的过程相对 “获取锁” 的过程比较简单。释放锁时，主要进行的操作，是更新当前线程对应的锁的状态。如果当前线程对锁已经彻底释放，则设置 “锁” 的持有线程为 null，设置当前线程的状态为空，然后唤醒后继线程。</p>
<hr>
<h1 id="05-非公平锁"><a href="#05-非公平锁" class="headerlink" title="05 非公平锁"></a>05 非公平锁</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>前面两章分析了 “公平锁的获取和释放机制”，这一章开始对 “非公平锁” 的获取锁 / 释放锁的过程进行分析。内容包括：<br><a href="#a2">获取非公平锁 (基于 JDK1.7.0_40)</a><br><a href="#a3">释放非公平锁 (基于 JDK1.7.0_40)</a><br>关于锁的数据结构请参考 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a> “，锁的使用示例请参考 “<a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a>”。</p>
<h2 id="获取非公平锁-基于-JDK1-7-0-40"><a href="#获取非公平锁-基于-JDK1-7-0-40" class="headerlink" title="获取非公平锁 (基于 JDK1.7.0_40)"></a><strong><a></a>获取非公平锁 (基于 JDK1.7.0_40)</strong></h2><p>非公平锁和公平锁在获取锁的方法上，流程是一样的；它们的区别主要表现在 “尝试获取锁的机制不同”。简单点说，“公平锁” 在每次尝试获取锁时，都是采用公平策略 (根据等待队列依次排序等待)；而“非公平锁” 在每次尝试获取锁时，都是采用的非公平策略(无视等待队列，直接尝试获取锁，如果锁是空闲的，即可获取状态，则获取锁)。<br>在前面的 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a>” 中，已经详细介绍了获取公平锁的流程和机制；下面，通过代码分析以下获取非公平锁的流程。</p>
<p><strong>1. lock()</strong></p>
<p>lock() 在 ReentrantLock.java 的 NonfairSync 类中实现，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>lock()会先通过 compareAndSet(0, 1)来判断 “锁” 是不是空闲状态。是的话，“当前线程”直接获取 “锁”；否则的话，调用 acquire(1) 获取锁。<br>(01) compareAndSetState() 是 CAS 函数，它的作用是比较并设置当前锁的状态。若锁的状态值为 0，则设置锁的状态值为 1。<br>(02) setExclusiveOwnerThread(Thread.currentThread())的作用是，设置 “当前线程” 为“锁”的持有者。</p>
<p><strong>“公平锁”和 “非公平锁” 关于 lock()的对比</strong></p>
<p>公平锁   – 公平锁的lock()函数，会直接调用acquire(1)。<br>非公平锁 – 非公平锁会先判断当前锁的状态是不是空闲，是的话，就不排队，而是直接获取锁。</p>
<p><strong>2. acquire()</strong></p>
<p>acquire() 在 AQS 中实现的，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(01) “当前线程” 首先通过 tryAcquire() 尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列依次排序，然后获取锁。<br>(02) “当前线程”尝试失败的情况下，会先通过 addWaiter(Node.EXCLUSIVE)来将 “当前线程” 加入到 “CLH 队列(非阻塞的 FIFO 队列)” 末尾。<br>(03) 然后，调用 acquireQueued()获取锁。在 acquireQueued()中，当前线程会等待它在 “CLH 队列” 中前面的所有线程执行并释放锁之后，才能获取锁并返回。如果 “当前线程” 在休眠等待过程中被中断过，则调用 selfInterrupt()来自己产生一个中断。</p>
<p><strong>“公平锁”和 “非公平锁” 关于 acquire()的对比</strong></p>
<p><strong>公平锁和非公平锁，只有 tryAcquire() 函数的实现不同</strong>；即它们尝试获取锁的机制不同。这就是我们所说的 “它们获取锁策略的不同所在之处”！<br>在 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a>” 中，已经详细介绍了 acquire() 涉及到的各个函数。这里仅对它们有差异的函数 tryAcquire() 进行说明。</p>
<p>非公平锁的 tryAcquire() 在 ReentrantLock.java 的 NonfairSync 类中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nonfairTryAcquire() 在 ReentrantLock.java 的 Sync 类中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取“当前线程”</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取“锁”的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// c=0意味着“锁没有被任何线程锁拥有”</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若“锁没有被任何线程锁拥有”，则通过CAS函数设置“锁”的状态为acquires。</span></span><br><span class="line">        <span class="comment">// 同时，设置“当前线程”为锁的持有者。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果“锁”的持有者已经是“当前线程”，</span></span><br><span class="line">        <span class="comment">// 则将更新锁的状态。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>根据代码，我们可以分析出，tryAcquire() 的作用就是尝试去获取锁。<br>(01) 如果 “锁” 没有被任何线程拥有，则通过 CAS 函数设置 “锁” 的状态为 acquires，同时，设置 “当前线程” 为锁的持有者，然后返回 true。<br>(02) 如果 “锁” 的持有者已经是当前线程，则将更新锁的状态即可。<br>(03) 如果不术语上面的两种情况，则认为尝试失败。</p>
<p><strong>“公平锁”和 “非公平锁” 关于 tryAcquire()的对比</strong></p>
<p>公平锁和非公平锁，它们尝试获取锁的方式不同。<br>公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。<br>而<strong>非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。</strong></p>
<h2 id="释放非公平锁-基于-JDK1-7-0-40"><a href="#释放非公平锁-基于-JDK1-7-0-40" class="headerlink" title="释放非公平锁 (基于 JDK1.7.0_40)"></a><strong><a></a>释放非公平锁 (基于 JDK1.7.0_40)</strong></h2><p>非公平锁和公平锁在释放锁的方法和策略上是一样的。<br>而在前面的 “<a href="http://www.cnblogs.com/skywang12345/p/3496609.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”04 之 公平锁 (二)</a> ”中，已经对 “释放公平锁” 进行了介绍；这里就不再重复的进行说明。</p>
<p><strong>总结</strong><br>公平锁和非公平锁的区别，是在获取锁的机制上的区别。表现在，在尝试获取锁时 —— 公平锁，只有在当前线程是 CLH 等待队列的表头时，才获取锁；而非公平锁，只要当前锁处于空闲状态，则直接获取锁，而不管 CLH 等待队列中的顺序。<br>只有当非公平锁尝试获取锁失败的时候，它才会像公平锁一样，进入 CLH 等待队列排序等待。</p>
<hr>
<h1 id="06-Condition条件"><a href="#06-Condition条件" class="headerlink" title="06 Condition条件"></a>06 Condition条件</h1><h2 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>前面对 JUC 包中的锁的原理进行了介绍，本章会 JUC 中对与锁经常配合使用的 Condition 进行介绍，内容包括:<br><a href="#p1">Condition 介绍</a><br><a href="#p2">Condition 函数列表</a><br><a href="#p3">Condition 示例</a></p>
<h2 id="Condition-介绍"><a href="#Condition-介绍" class="headerlink" title="Condition 介绍"></a><strong><a></a>Condition 介绍</strong></h2><p>Condition 的作用是对锁进行更精确的控制。Condition 中的 await() 方法相当于 Object 的 <a href="http://www.cnblogs.com/skywang12345/p/3479224.html" target="_blank" rel="noopener">wait()</a> 方法，Condition 中的 signal() 方法相当于 Object 的 notify() 方法，Condition 中的 signalAll() 相当于 Object 的 notifyAll() 方法。不同的是，Object 中的 <a href="http://www.cnblogs.com/skywang12345/p/3479224.html" target="_blank" rel="noopener">wait(),notify(),notifyAll()</a> 方法是和 <a href="http://www.cnblogs.com/skywang12345/p/3479202.html" target="_blank" rel="noopener">“同步锁”(synchronized 关键字)</a> 捆绑使用的；而 Condition 是需要与 <a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">“互斥锁”/“共享锁”</a> 捆绑使用的。</p>
<h2 id="Condition-函数列表"><a href="#Condition-函数列表" class="headerlink" title="Condition 函数列表"></a><strong><a></a>Condition 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 造成当前线程在接到信号或被中断之前一直处于等待状态。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 唤醒一个等待线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 唤醒所有等待线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Condition-示例"><a href="#Condition-示例" class="headerlink" title="Condition 示例"></a><strong><a></a>Condition 示例</strong></h2><p>示例 1 是通过 Object 的 wait(), notify() 来演示线程的休眠 / 唤醒功能。<br>示例 2 是通过 Condition 的 await(), signal() 来演示线程的休眠 / 唤醒功能。<br>示例 3 是通过 Condition 的高级功能。</p>
<p><strong>示例 1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadA ta = <span class="keyword">new</span> ThreadA(<span class="string">"ta"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(ta) &#123; <span class="comment">// 通过synchronized(ta)获取“对象ta的同步锁”</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" start ta"</span>);</span><br><span class="line">                ta.start();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" block"</span>);</span><br><span class="line">                ta.wait();    <span class="comment">// 等待</span></span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" continue"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 通过synchronized(this)获取“当前对象的同步锁”</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" wakup others"</span>);</span><br><span class="line">                notify();    <span class="comment">// 唤醒“当前对象上的等待线程”</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadA ta = <span class="keyword">new</span> ThreadA(<span class="string">"ta"</span>);</span><br><span class="line"></span><br><span class="line">        lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" start ta"</span>);</span><br><span class="line">            ta.start();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" block"</span>);</span><br><span class="line">            condition.await();    <span class="comment">// 等待</span></span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" continue"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();    <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" wakup others"</span>);</span><br><span class="line">                condition.signal();    <span class="comment">// 唤醒“condition所在锁上的其它线程”</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main start ta</span><br><span class="line">main block</span><br><span class="line">ta wakup others</span><br><span class="line">main continue</span><br></pre></td></tr></table></figure>
<p>通过 “示例 1” 和“示例 2”，我们知道 Condition 和 Object 的方法有一下对应关系：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>Object</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>休眠</td>
<td>wait</td>
<td>await</td>
</tr>
<tr>
<td>唤醒某个线程</td>
<td>notify</td>
<td>signal</td>
</tr>
<tr>
<td>唤醒所有线程</td>
<td>notifyAll</td>
<td>signalAll</td>
</tr>
</tbody>
</table>
<p>Condition 除了支持上面的功能之外，它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个 Condition，在不同的情况下使用不同的 Condition。<br>例如，假如多线程读 / 写同一个缓冲区：当向缓冲区中写入数据之后，唤醒 “读线程”；当从缓冲区读出数据之后，唤醒 “写线程”；并且当缓冲区满的时候，”写线程” 需要等待；当缓冲区为空时，”读线程” 需要等待。         如果采用 Object 类中的 wait(), notify(), notifyAll() 实现该缓冲区，当向缓冲区写入数据之后需要唤醒 “读线程” 时，不可能通过 notify() 或 notifyAll() 明确的指定唤醒 “读线程”，而只能通过 notifyAll 唤醒所有线程 (但是 notifyAll 无法区分唤醒的线程是读线程，还是写线程)。  但是，通过 Condition，就能明确的指定唤醒读线程。<br>看看下面的示例 3，可能对这个概念有更深刻的理解。</p>
<p><strong>示例 3</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果“缓冲已满”，则等待；直到“缓冲”不是满的，才将x添加到缓冲中。</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="comment">// 将x添加到缓冲中</span></span><br><span class="line">            items[putptr] = x; </span><br><span class="line">            <span class="comment">// 将“put统计数putptr+1”；如果“缓冲已满”，则设putptr为0。</span></span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将“缓冲”数量+1</span></span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">// 唤醒take线程，因为take线程通过notEmpty.await()等待</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印写入的数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" put  "</span>+ (Integer)x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果“缓冲为空”，则等待；直到“缓冲”不为空，才将x从缓冲中取出。</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) </span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="comment">// 将x从缓冲中取出</span></span><br><span class="line">            Object x = items[takeptr]; </span><br><span class="line">            <span class="comment">// 将“take统计数takeptr+1”；如果“缓冲为空”，则设takeptr为0。</span></span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将“缓冲”数量-1</span></span><br><span class="line">            --count;</span><br><span class="line">            <span class="comment">// 唤醒put线程，因为put线程通过notFull.await()等待</span></span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印取出的数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" take "</span>+ (Integer)x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();    <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BoundedBuffer bb = <span class="keyword">new</span> BoundedBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)；</span></span><br><span class="line">        <span class="comment">// 启动10个“读线程”，从BoundedBuffer中不断的读数据。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> PutThread(<span class="string">"p"</span>+i, i).start();</span><br><span class="line">            <span class="keyword">new</span> TakeThread(<span class="string">"t"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(String name, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);    <span class="comment">// 线程休眠1ms</span></span><br><span class="line">                bb.put(num);        <span class="comment">// 向BoundedBuffer中写入数据</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TakeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TakeThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);                    <span class="comment">// 线程休眠1ms</span></span><br><span class="line">                Integer num = (Integer)bb.take();    <span class="comment">// 从BoundedBuffer中取出数据</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(某一次) 运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">p1 put  1</span><br><span class="line">p4 put  4</span><br><span class="line">p5 put  5</span><br><span class="line">p0 put  0</span><br><span class="line">p2 put  2</span><br><span class="line">t0 take 1</span><br><span class="line">p3 put  3</span><br><span class="line">t1 take 4</span><br><span class="line">p6 put  6</span><br><span class="line">t2 take 5</span><br><span class="line">p7 put  7</span><br><span class="line">t3 take 0</span><br><span class="line">p8 put  8</span><br><span class="line">t4 take 2</span><br><span class="line">p9 put  9</span><br><span class="line">t5 take 3</span><br><span class="line">t6 take 6</span><br><span class="line">t7 take 7</span><br><span class="line">t8 take 8</span><br><span class="line">t9 take 9</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：<br>(01) BoundedBuffer 是容量为 5 的缓冲，缓冲中存储的是 Object 对象，支持多线程的读 / 写缓冲。多个线程操作 “一个 BoundedBuffer 对象” 时，它们通过互斥锁 lock 对缓冲区 items 进行互斥访问；而且同一个 BoundedBuffer 对象下的全部线程共用 “notFull” 和“notEmpty”这两个 Condition。<br>       notFull 用于控制写缓冲，notEmpty 用于控制读缓冲。当缓冲已满的时候，调用 put 的线程会执行 notFull.await() 进行等待；当缓冲区不是满的状态时，就将对象添加到缓冲区并将缓冲区的容量 count+1，最后，调用 notEmpty.signal() 缓冲 notEmpty 上的等待线程 (调用 notEmpty.await 的线程)。 简言之，notFull 控制 “缓冲区的写入”，当往缓冲区写入数据之后会唤醒 notEmpty 上的等待线程。<br>       同理，notEmpty 控制 “缓冲区的读取”，当读取了缓冲区数据之后会唤醒 notFull 上的等待线程。<br>(02) 在 ConditionTest2 的 main 函数中，启动 10 个 “写线程”，向 BoundedBuffer 中不断的写数据 (写入 0-9)；同时，也启动 10 个 “读线程”，从 BoundedBuffer 中不断的读数据。<br>(03) 简单分析一下运行结果。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1, p1线程向缓冲中写入1。    此时，缓冲区数据:   | 1 |   |   |   |   |</span><br><span class="line">2, p4线程向缓冲中写入4。    此时，缓冲区数据:   | 1 | 4 |   |   |   |</span><br><span class="line">3, p5线程向缓冲中写入5。    此时，缓冲区数据:   | 1 | 4 | 5 |   |   |</span><br><span class="line">4, p0线程向缓冲中写入0。    此时，缓冲区数据:   | 1 | 4 | 5 | 0 |   |</span><br><span class="line">5, p2线程向缓冲中写入2。    此时，缓冲区数据:   | 1 | 4 | 5 | 0 | 2 |</span><br><span class="line">此时，缓冲区容量为5；缓冲区已满！如果此时，还有“写线程”想往缓冲中写入数据，会调用put中的notFull.await()等待，直接缓冲区非满状态，才能继续运行。</span><br><span class="line">6, t0线程从缓冲中取出数据1。此时，缓冲区数据:   |   | 4 | 5 | 0 | 2 |</span><br><span class="line">7, p3线程向缓冲中写入3。    此时，缓冲区数据:   | 3 | 4 | 5 | 0 | 2 |</span><br><span class="line">8, t1线程从缓冲中取出数据4。此时，缓冲区数据:   | 3 |   | 5 | 0 | 2 |</span><br><span class="line">9, p6线程向缓冲中写入6。    此时，缓冲区数据:   | 3 | 6 | 5 | 0 | 2 |</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="07-LockSupport"><a href="#07-LockSupport" class="headerlink" title="07 LockSupport"></a>07 LockSupport</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>本章介绍 JUC(java.util.concurrent) 包中的 LockSupport。内容包括：<br><a href="#a1">LockSupport 介绍</a><br><a href="#a2">LockSupport 函数列表</a><br><a href="#a3">LockSupport 参考代码 (基于 JDK1.7.0_40)</a><br><a href="#a4">LockSupport 示例</a></p>
<h2 id="LockSupport-介绍"><a href="#LockSupport-介绍" class="headerlink" title="LockSupport 介绍"></a><strong><a></a>LockSupport 介绍</strong></h2><p>LockSupport 是用来创建锁和其他同步类的基本线程阻塞原语。<br>LockSupport 中的 park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，而且 park()和 unpark()不会遇到 “Thread.suspend 和 Thread.resume 所可能引发的死锁” 问题。<br>因为 park() 和 unpark() 有许可的存在；调用 park() 的线程和另一个试图将其 unpark() 的线程之间的竞争将保持活性。</p>
<h2 id="LockSupport-函数列表"><a href="#LockSupport-函数列表" class="headerlink" title="LockSupport 函数列表"></a><strong><a></a>LockSupport 函数列表</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 为了线程调度，禁用当前线程，除非许可可用。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 为了线程调度，在许可可用之前禁用当前线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果给定线程的许可尚不可用，则使其可用。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="LockSupport-参考代码-基于-JDK1-7-0-40"><a href="#LockSupport-参考代码-基于-JDK1-7-0-40" class="headerlink" title="LockSupport 参考代码 (基于 JDK1.7.0_40)"></a><strong><a></a>LockSupport 参考代码 (基于 JDK1.7.0_40)</strong></h2><p><a href="http://p4lmrb1gp.bkt.clouddn.com/LockSupport.java" target="_blank" rel="noopener">LockSupport.java源码</a></p>
<p><strong>说明</strong>：LockSupport 是通过调用 Unsafe 函数中的接口实现阻塞和解除阻塞的。</p>
<h2 id="LockSupport-示例"><a href="#LockSupport-示例" class="headerlink" title="LockSupport 示例"></a><strong><a></a>LockSupport 示例</strong></h2><p>对比下面的 “示例 1” 和“示例 2”可以更清晰的了解 LockSupport 的用法。</p>
<p><strong>示例 1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadA ta = <span class="keyword">new</span> ThreadA(<span class="string">"ta"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(ta) &#123; <span class="comment">// 通过synchronized(ta)获取“对象ta的同步锁”</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" start ta"</span>);</span><br><span class="line">                ta.start();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" block"</span>);</span><br><span class="line">                <span class="comment">// 主线程等待</span></span><br><span class="line">                ta.wait();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" continue"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 通过synchronized(this)获取“当前对象的同步锁”</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" wakup others"</span>);</span><br><span class="line">                notify();    <span class="comment">// 唤醒“当前对象上的等待线程”</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread mainThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadA ta = <span class="keyword">new</span> ThreadA(<span class="string">"ta"</span>);</span><br><span class="line">        <span class="comment">// 获取主线程</span></span><br><span class="line">        mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" start ta"</span>);</span><br><span class="line">        ta.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" block"</span>);</span><br><span class="line">        <span class="comment">// 主线程阻塞</span></span><br><span class="line">        LockSupport.park(mainThread);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" continue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" wakup others"</span>);</span><br><span class="line">            <span class="comment">// 唤醒“主线程”</span></span><br><span class="line">            LockSupport.unpark(mainThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main start ta</span><br><span class="line">main block</span><br><span class="line">ta wakup others</span><br><span class="line">main continue</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：park 和 wait 的区别。wait 让线程阻塞前，必须通过 synchronized 获取同步锁。</p>
<hr>
<h1 id="08-共享锁和ReentrantReadWriteLock"><a href="#08-共享锁和ReentrantReadWriteLock" class="headerlink" title="08 共享锁和ReentrantReadWriteLock"></a>08 共享锁和ReentrantReadWriteLock</h1><h2 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>Java 的 JUC(java.util.concurrent) 包中的锁包括 “独占锁” 和 “共享锁”。在 “<a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”02 之 互斥锁 ReentrantLock</a> ”中，对 Java 的独占锁进行了说明。本章对 Java 的 “共享锁” 进行介绍，JUC 中的共享锁有 CountDownLatch, CyclicBarrier, Semaphore, ReentrantReadWriteLock 等；本章会以 ReentrantReadWriteLock 为蓝本对共享锁进行说明。内容包括：<br><a href="#a1">ReadWriteLock 和 ReentrantReadWriteLock 介绍</a><br><a href="#a2">ReadWriteLock 和 ReentrantReadWriteLock 函数列表</a> <a href="#s1">ReentrantReadWriteLock 数据结构</a><br><a href="#a3">参考代码 (基于 JDK1.7.0_40)</a><br><a href="#a5">  获取共享锁</a><br><a href="#a6">  释放共享锁</a><br><a href="#a7">  公平共享锁和非公平共享锁</a><br><a href="#a8">ReentrantReadWriteLock 示例</a></p>
<h2 id="ReadWriteLock-和-ReentrantReadWriteLock-介绍"><a href="#ReadWriteLock-和-ReentrantReadWriteLock-介绍" class="headerlink" title="ReadWriteLock 和 ReentrantReadWriteLock 介绍"></a><strong><a></a>ReadWriteLock 和 ReentrantReadWriteLock 介绍</strong></h2><p>ReadWriteLock，顾名思义，是读写锁。它维护了一对相关的锁 — — “读取锁” 和 “写入锁”，一个用于读取操作，另一个用于写入操作。<br>“读取锁” 用于只读操作，它是 “共享锁”，能同时被多个线程获取。<br>“写入锁” 用于写入操作，它是 “独占锁”，写入锁只能被一个线程锁获取。<br>注意：不能同时存在读取锁和写入锁！<br>ReadWriteLock 是一个接口。ReentrantReadWriteLock 是它的实现类，ReentrantReadWriteLock 包括子类 ReadLock 和 WriteLock。</p>
<h2 id="ReadWriteLock-和-ReentrantReadWriteLock-函数列表"><a href="#ReadWriteLock-和-ReentrantReadWriteLock-函数列表" class="headerlink" title="ReadWriteLock 和 ReentrantReadWriteLock 函数列表"></a><strong><a></a>ReadWriteLock 和 ReentrantReadWriteLock 函数列表</strong></h2><p><strong>ReadWriteLock 函数列表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回用于读取操作的锁。</span></span><br><span class="line"><span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回用于写入操作的锁。</span></span></span><br><span class="line"><span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong><a></a>ReentrantReadWriteLock 函数列表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 ReentrantReadWriteLock，默认是采用“非公平策略”。</span></span><br><span class="line">ReentrantReadWriteLock()</span><br><span class="line"><span class="comment">// 创建一个新的 ReentrantReadWriteLock，fair是“公平策略”。fair为true，意味着公平策略；否则，意味着非公平策略。</span></span><br><span class="line">ReentrantReadWriteLock(<span class="keyword">boolean</span> fair)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前拥有写入锁的线程，如果没有这样的线程，则返回 null。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Thread <span class="title">getOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个 collection，它包含可能正在等待获取读取锁的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedReaderThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个 collection，它包含可能正在等待获取读取或写入锁的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个 collection，它包含可能正在等待获取写入锁的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedWriterThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回等待获取读取或写入锁的线程估计数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询当前线程在此锁上保持的重入读取锁数量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询为此锁保持的读取锁数量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getReadLockCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个 collection，它包含可能正在等待与写入锁相关的给定条件的那些线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回正等待与写入锁相关的给定条件的线程估计数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询当前线程在此锁上保持的重入写入锁数量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWriteHoldCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询是否给定线程正在等待获取读取或写入锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread thread)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询是否所有的线程正在等待获取读取或写入锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询是否有些线程正在等待与写入锁有关的给定条件。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此锁将公平性设置为 ture，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询是否某个线程保持了写入锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isWriteLocked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询当前线程是否保持了写入锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isWriteLockedByCurrentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回用于读取操作的锁。</span></span></span><br><span class="line"><span class="function">ReentrantReadWriteLock.ReadLock <span class="title">readLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回用于写入操作的锁。</span></span></span><br><span class="line"><span class="function">ReentrantReadWriteLock.WriteLock <span class="title">writeLock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ReentrantReadWriteLock-数据结构"><a href="#ReentrantReadWriteLock-数据结构" class="headerlink" title="ReentrantReadWriteLock 数据结构"></a><strong><a></a>ReentrantReadWriteLock 数据结构</strong></h2><p>ReentrantReadWriteLock 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219006492938.jpg" alt=""></p>
<p>从中可以看出：</p>
<p>(01) ReentrantReadWriteLock 实现了 ReadWriteLock 接口。ReadWriteLock 是一个读写锁的接口，提供了 “获取读锁的 readLock() 函数” 和 “获取写锁的 writeLock() 函数”。<br>(02) ReentrantReadWriteLock 中包含：sync 对象，读锁 readerLock 和写锁 writerLock。读锁 ReadLock 和写锁 WriteLock 都实现了 Lock 接口。读锁 ReadLock 和写锁 WriteLock 中也都分别包含了 “Sync 对象”，它们的 Sync 对象和 ReentrantReadWriteLock 的 Sync 对象 是一样的，就是通过 sync，读锁和写锁实现了对同一个对象的访问。<br>(03) 和 “ReentrantLock” 一样，sync 是 Sync 类型；而且，Sync 也是一个继承于 AQS 的抽象类。Sync 也包括 “公平锁”FairSync 和 “非公平锁”NonfairSync。sync 对象是 “FairSync” 和 “NonfairSync” 中的一个，默认是 “NonfairSync”。</p>
<h2 id="参考代码-基于-JDK1-7-0-40"><a href="#参考代码-基于-JDK1-7-0-40" class="headerlink" title="参考代码 (基于 JDK1.7.0_40)"></a><strong><a></a>参考代码 (基于 JDK1.7.0_40)</strong></h2><p><strong>ReentrantReadWriteLock 的完整源码</strong></p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/ReentrantReadWriteLock.java" target="_blank" rel="noopener">ReentrantReadWriteLock.java源码</a></p>
<p>其中，共享锁源码相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line">    <span class="comment">// ReentrantReadWriteLock的AQS对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取“共享锁”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程是中断状态，则抛出一场，否则尝试获取共享锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取“共享锁”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryReadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定时间内，尝试获取“共享锁”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放“共享锁”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = sync.getReadLockCount();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() +</span><br><span class="line">            <span class="string">"[Read locks = "</span> + r + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>ReadLock 中的 sync 是一个 Sync 对象，Sync 继承于 AQS 类，即 Sync 就是一个锁。ReentrantReadWriteLock 中也有一个 Sync 对象，而且 ReadLock 中的 sync 和 ReentrantReadWriteLock 中的 sync 是对应关系。即 ReentrantReadWriteLock 和 ReadLock 共享同一个 AQS 对象，共享同一把锁。<br>ReentrantReadWriteLock 中 Sync 的定义如下：</p>
<p>final Sync sync;</p>
<p>下面，分别从 “获取共享锁” 和“释放共享锁”两个方面对共享锁进行说明。</p>
<h2 id="获取共享锁"><a href="#获取共享锁" class="headerlink" title="获取共享锁"></a><strong><a></a>获取共享锁</strong></h2><p>获取共享锁的思想 (即 lock 函数的步骤)，是先通过 tryAcquireShared() 尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过 doAcquireShared()不断的循环并尝试获取锁，若有需要，则阻塞等待。doAcquireShared()在循环中每次尝试获取锁时，都是通过 <strong>tryAcquireShared()</strong>来进行尝试的。下面看看 “获取共享锁” 的详细流程。</p>
<p><strong>1. lock()</strong></p>
<p>lock() 在 ReadLock 中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. acquireShared()</strong></p>
<p>Sync 继承于 AQS，acquireShared() 定义在 AQS 中。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：acquireShared() 首先会通过 tryAcquireShared() 来尝试获取锁。<br>尝试成功的话，则不再做任何动作 (因为已经成功获取到锁了)。<br>尝试失败的话，则通过 doAcquireShared() 来获取锁。doAcquireShared() 会获取到锁了才返回。</p>
<p><strong>3. tryAcquireShared()</strong></p>
<p>tryAcquireShared() 定义在 ReentrantReadWriteLock.java 的 Sync 中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取“锁”的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取“读取锁”的共享计数</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 如果“不需要阻塞等待”，并且“读取锁”的共享计数小于MAX_COUNT；</span></span><br><span class="line">    <span class="comment">// 则通过CAS函数更新“锁的状态”，将“读取锁”的共享计数+1。</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 第1次获取“读取锁”。</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; </span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; </span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// HoldCounter是用来统计该线程获取“读取锁”的次数。</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 将该线程获取“读取锁”的次数+1。</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：tryAcquireShared() 的作用是尝试获取 “共享锁”。<br>如果在尝试获取锁时，“不需要阻塞等待” 并且 “读取锁的共享计数小于 MAX_COUNT”，则直接通过 CAS 函数更新 “读取锁的共享计数”，以及将 “当前线程获取读取锁的次数 + 1”。<br>否则，通过 fullTryAcquireShared() 获取读取锁。</p>
<p><strong>4. fullTryAcquireShared()</strong></p>
<p>fullTryAcquireShared() 在 ReentrantReadWriteLock 中定义，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取“锁”的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果“需要阻塞等待”。</span></span><br><span class="line">        <span class="comment">// (01) 当“需要阻塞等待”的线程是第1个获取锁的线程的话，则继续往下执行。</span></span><br><span class="line">        <span class="comment">// (02) 当“需要阻塞等待”的线程获取锁的次数=0时，则返回-1。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId()) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果当前线程获取锁的计数=0,则返回-1。</span></span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果“不需要阻塞等待”，则获取“读取锁”的共享统计数；</span></span><br><span class="line">        <span class="comment">// 如果共享统计数超过MAX_COUNT，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 将线程获取“读取锁”的次数+1。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 如果是第1次获取“读取锁”，则更新firstReader和firstReaderHoldCount。</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程，</span></span><br><span class="line">            <span class="comment">// 则将firstReaderHoldCount+1。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                <span class="comment">// 更新线程的获取“读取锁”的共享计数</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：fullTryAcquireShared()会根据 “是否需要阻塞等待”，“读取锁的共享计数是否超过限制” 等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过 CAS 尝试获取锁，并返回 1。</p>
<p><strong>5. doAcquireShared()</strong></p>
<p>doAcquireShared() 定义在 AQS 函数中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// addWaiter(Node.SHARED)的作用是，创建“当前线程”对应的节点，并将该线程添加到CLH队列中。</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取“node”的前一节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果“当前线程”是CLH队列的表头，则尝试获取共享锁。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果“当前线程”不是CLH队列的表头，则通过shouldParkAfterFailedAcquire()判断是否需要等待，</span></span><br><span class="line">            <span class="comment">// 需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。若阻塞等待过程中，线程被中断过，则设置interrupted为true。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：doAcquireShared() 的作用是获取共享锁。<br>它会首先创建线程对应的 CLH 队列的节点，然后将该节点添加到 CLH 队列中。CLH 队列是管理获取锁的等待线程的队列。<br>如果 “当前线程” 是 CLH 队列的表头，则尝试获取共享锁；否则，则需要通过 shouldParkAfterFailedAcquire()判断是否阻塞等待，需要的话，则通过 parkAndCheckInterrupt()进行阻塞等待。<br>doAcquireShared() 会通过 for 循环，不断的进行上面的操作；目的就是获取共享锁。需要注意的是：doAcquireShared() 在每一次尝试获取锁时，是通过 tryAcquireShared() 来执行的！</p>
<p>shouldParkAfterFailedAcquire(), parkAndCheckInterrupt() 等函数已经在 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a> ” 中详细介绍过，这里就不再重复说明了。</p>
<h2 id="释放共享锁"><a href="#释放共享锁" class="headerlink" title="释放共享锁"></a><strong><a></a>释放共享锁</strong></h2><p>释放共享锁的思想，是先通过 tryReleaseShared() 尝试释放共享锁。尝试成功的话，则通过 doReleaseShared() 唤醒 “其他等待获取共享锁的线程”，并返回 true；否则的话，返回 flase。</p>
<p><strong>1. unlock()</strong></p>
<p>public  void unlock() {<br>    sync.releaseShared(1);<br>}</p>
<p><strong>说明</strong>：该函数实际上调用 releaseShared(1) 释放共享锁。</p>
<p><strong>2. releaseShared()</strong></p>
<p>releaseShared() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：releaseShared() 的目的是让当前线程释放它所持有的共享锁。<br>它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。</p>
<p><strong>3. tryReleaseShared()</strong></p>
<p>tryReleaseShared() 定义在 ReentrantReadWriteLock 中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程，即释放共享锁的线程。</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果想要释放锁的线程(current)是第1个获取锁(firstReader)的线程，</span></span><br><span class="line">    <span class="comment">// 并且“第1个获取锁的线程获取锁的次数”=1，则设置firstReader为null；</span></span><br><span class="line">    <span class="comment">// 否则，将“第1个获取锁的线程的获取次数”-1。</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    <span class="comment">// 获取rh对象，并更新“当前线程获取锁的信息”。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取锁的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 将锁的获取次数-1。</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">// 通过CAS更新锁的状态。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：tryReleaseShared() 的作用是尝试释放共享锁。</p>
<p><strong>4. doReleaseShared()</strong></p>
<p>doReleaseShared() 定义在 AQS 中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取CLH队列的头节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果头节点不为null，并且头节点不等于tail节点。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// 获取头节点对应的线程的状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 唤醒“头节点的下一个节点所对应的线程”。</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点发生变化，则继续循环。否则，退出循环。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：doReleaseShared()会释放 “共享锁”。它会从前往后的遍历 CLH 队列，依次“唤醒” 然后 “执行” 队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的锁。</p>
<h2 id="公平共享锁和非公平共享锁"><a href="#公平共享锁和非公平共享锁" class="headerlink" title="公平共享锁和非公平共享锁"></a><strong><a></a>公平共享锁和非公平共享锁</strong></h2><p>和互斥锁 ReentrantLock 一样，ReadLock 也分为公平锁和非公平锁。</p>
<p>公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数 readerShouldBlock() 是不同的。<br>公平锁的 readerShouldBlock() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在公平共享锁中，如果在当前线程的前面有其他线程在等待获取共享锁，则返回 true；否则，返回 false。<br>非公平锁的 readerShouldBlock() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在非公平共享锁中，它会无视当前线程的前面是否有其他线程在等待获取共享锁。只要该非公平共享锁对应的线程不为 null，则返回 true。</p>
<h2 id="ReentrantReadWriteLock-示例"><a href="#ReentrantReadWriteLock-示例" class="headerlink" title="ReentrantReadWriteLock 示例"></a><strong><a></a>ReentrantReadWriteLock 示例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest1</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 创建账户</span></span><br><span class="line">        MyCount myCount = <span class="keyword">new</span> MyCount(<span class="string">"4238920615242830"</span>, <span class="number">10000</span>); </span><br><span class="line">        <span class="comment">// 创建用户，并指定账户</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"Tommy"</span>, myCount); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别启动3个“读取账户金钱”的线程 和 3个“设置账户金钱”的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">            user.getCash();</span><br><span class="line">            user.setCash((i+<span class="number">1</span>)*<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">//用户名 </span></span><br><span class="line">    <span class="keyword">private</span> MyCount myCount;        <span class="comment">//所要操作的账户 </span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock myLock;   <span class="comment">//执行操作所需的锁对象 </span></span><br><span class="line"></span><br><span class="line">    User(String name, MyCount myCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">        <span class="keyword">this</span>.myCount = myCount; </span><br><span class="line">        <span class="keyword">this</span>.myLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                myLock.readLock().lock(); </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">" getCash start"</span>); </span><br><span class="line">                    myCount.getCash();</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">" getCash end"</span>); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    myLock.readLock().unlock(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCash</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> cash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                myLock.writeLock().lock(); </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">" setCash start"</span>); </span><br><span class="line">                    myCount.setCash(cash);</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">" setCash end"</span>); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    myLock.writeLock().unlock(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;         <span class="comment">//账号 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>    cash;       <span class="comment">//账户余额 </span></span><br><span class="line"></span><br><span class="line">    MyCount(String id, <span class="keyword">int</span> cash) &#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id; </span><br><span class="line">        <span class="keyword">this</span>.cash = cash; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.id = id; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCash</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">" getCash cash="</span>+ cash); </span><br><span class="line">        <span class="keyword">return</span> cash; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCash</span><span class="params">(<span class="keyword">int</span> cash)</span> </span>&#123; </span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">" setCash cash="</span>+ cash); </span><br><span class="line">        <span class="keyword">this</span>.cash = cash; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 getCash start</span><br><span class="line">Thread-2 getCash start</span><br><span class="line">Thread-0 getCash cash=10000</span><br><span class="line">Thread-2 getCash cash=10000</span><br><span class="line">Thread-0 getCash end</span><br><span class="line">Thread-2 getCash end</span><br><span class="line">Thread-1 setCash start</span><br><span class="line">Thread-1 setCash cash=1000</span><br><span class="line">Thread-1 setCash end</span><br><span class="line">Thread-3 setCash start</span><br><span class="line">Thread-3 setCash cash=2000</span><br><span class="line">Thread-3 setCash end</span><br><span class="line">Thread-4 getCash start</span><br><span class="line">Thread-4 getCash cash=2000</span><br><span class="line">Thread-4 getCash end</span><br><span class="line">Thread-5 setCash start</span><br><span class="line">Thread-5 setCash cash=3000</span><br><span class="line">Thread-5 setCash end</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：<br>(01) 观察 Thread0 和 Thread-2 的运行结果，我们发现，Thread-0 启动并获取到 “读取锁”，在它还没运行完毕的时候，Thread-2 也启动了并且也成功获取到 “读取锁”。<br>因此，“读取锁” 支持被多个线程同时获取。<br>(02) 观察 Thread-1,Thread-3,Thread-5 这三个 “写入锁” 的线程。只要 “写入锁” 被某线程获取，则该线程运行完毕了，才释放该锁。<br>因此，“写入锁” 不支持被多个线程同时获取。</p>
<hr>
<h1 id="09-CountDownLatch原理和示例"><a href="#09-CountDownLatch原理和示例" class="headerlink" title="09 CountDownLatch原理和示例"></a>09 CountDownLatch原理和示例</h1><h2 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>前面对 “ <a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">独占锁</a> “和” <a href="http://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">共享锁</a> “有了个大致的了解；本章，我们对 CountDownLatch 进行学习。和 ReadWriteLock.ReadLock 一样，CountDownLatch 的本质也是一个” 共享锁 “。本章的内容包括：<br><a href="#a1">CountDownLatch 简介</a> <a href="#s1">CountDownLatch 数据结构</a><br><a href="#a2">CountDownLatch 源码分析 (基于 JDK1.7.0_40)</a><br><a href="#a3">CountDownLatch 示例</a></p>
<h2 id="CountDownLatch-简介"><a href="#CountDownLatch-简介" class="headerlink" title="CountDownLatch 简介"></a><strong><a></a>CountDownLatch 简介</strong></h2><p>CountDownLatch 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
<p><strong>CountDownLatch 和 CyclicBarrier 的区别</strong><br>(01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。<br>(02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。<br>关于 CyclicBarrier 的原理，后面一章再来学习。</p>
<p><strong>CountDownLatch 函数列表</strong></p>
<p>CountDownLatch(int count)<br>构造一个用给定计数初始化的 CountDownLatch。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前计数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回标识此锁存器及其状态的字符串。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="CountDownLatch-数据结构"><a href="#CountDownLatch-数据结构" class="headerlink" title="CountDownLatch 数据结构"></a><strong><a></a>CountDownLatch 数据结构</strong></h2><p>CountDownLatch 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219007544698.jpg" alt=""></p>
<p>CountDownLatch 的数据结构很简单，它是通过 “ <a href="http://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">共享锁</a> “ 实现的。它包含了 sync 对象，sync 是 Sync 类型。Sync 是实例类，它继承于 AQS。</p>
<h2 id="CountDownLatch-源码分析-基于-JDK1-7-0-40"><a href="#CountDownLatch-源码分析-基于-JDK1-7-0-40" class="headerlink" title="CountDownLatch 源码分析 (基于 JDK1.7.0_40)"></a><strong><a></a>CountDownLatch 源码分析 (基于 JDK1.7.0_40)</strong></h2><p><strong>CountDownLatch 完整源码 (基于 JDK1.7.0_40)</strong></p>
<p> <a href="http://p4lmrb1gp.bkt.clouddn.com/CountDownLatch.java" target="_blank" rel="noopener">CountDownLatch.java完整源码</a></p>
<p>CountDownLatch 是通过 “共享锁” 实现的。下面，我们分析 CountDownLatch 中 3 个核心函数: CountDownLatch(int count), await(), countDown()。</p>
<p><strong>1. CountDownLatch(int count)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：该函数是创建一个 Sync 对象，而 Sync 是继承于 AQS 类。Sync 构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setState() 在 AQS 中实现，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">long</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>说明</strong>：在 AQS 中，state 是一个 private volatile long 类型的对象。对于 CountDownLatch 而言，state 表示的”锁计数器 “。CountDownLatch 中的 getCount() 最终是调用 AQS 中的 getState()，返回的 state 对象，即”锁计数器“。</p>
<p><strong>2. await()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：该函数实际上是调用的 AQS 的 acquireSharedInterruptibly(1);</p>
<p>AQS 中的 acquireSharedInterruptibly() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：acquireSharedInterruptibly() 的作用是获取共享锁。<br>如果当前线程是中断状态，则抛出异常 InterruptedException。否则，调用 tryAcquireShared(arg)尝试获取共享锁；尝试成功则返回，否则就调用 doAcquireSharedInterruptibly()。doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁 (或被中断) 才返回。</p>
<p>tryAcquireShared() 在 CountDownLatch.java 中被重写，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：tryAcquireShared() 的作用是尝试获取共享锁。<br>如果 “锁计数器 = 0”，即锁是可获取状态，则返回 1；否则，锁是不可获取状态，则返回 - 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建"当前线程"的Node节点，且Node中记录的锁是"共享锁"类型；并将该节点添加到CLH队列末尾。</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取上一个节点。</span></span><br><span class="line">            <span class="comment">// 如果上一节点是CLH队列的表头，则"尝试获取共享锁"。</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">long</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// (上一节点不是CLH队列的表头) 当前线程一直等待，直到获取到共享锁。</span></span><br><span class="line">            <span class="comment">// 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<br>(01) addWaiter(Node.SHARED)的作用是，创建”当前线程 “的 Node 节点，且 Node 中记录的锁的类型是” 共享锁“(Node.SHARED)；并将该节点添加到 CLH 队列末尾。关于 Node 和 CLH 在 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a>“ 已经详细介绍过，这里就不再重复说明了。<br>(02) node.predecessor() 的作用是，获取上一个节点。如果上一节点是 CLH 队列的表头，则” 尝试获取共享锁 “。<br>(03) shouldParkAfterFailedAcquire() 的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回 true；否则，返回 false。<br>(04) 当 shouldParkAfterFailedAcquire() 返回 ture 时，则调用 parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。<br>doAcquireSharedInterruptibly() 中的 shouldParkAfterFailedAcquire(), parkAndCheckInterrupt 等函数在 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a>“ 中介绍过，这里也就不再详细说明了。</p>
<p><strong>3. countDown()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：该函数实际上调用 releaseShared(1) 释放共享锁。</p>
<p>releaseShared() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：releaseShared() 的目的是让当前线程释放它所持有的共享锁。<br>它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。</p>
<p>tryReleaseShared() 在 CountDownLatch.java 中被重写，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取“锁计数器”的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// “锁计数器”-1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 通过CAS函数进行赋值。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：tryReleaseShared()的作用是释放共享锁，将 “锁计数器” 的值 - 1。</p>
<p><strong>总结：</strong>CountDownLatch 是通过 “共享锁” 实现的。在创建 CountDownLatch 中时，会传递一个 int 类型参数 count，该参数是 “锁计数器” 的初始状态，表示该 “共享锁” 最多能被 count 个线程同时获取。当某线程调用该 CountDownLatch 对象的 await()方法时，该线程会等待 “共享锁” 可用时，才能获取 “共享锁” 进而继续运行。而 “共享锁” 可用的条件，就是 “锁计数器” 的值为 0！而 “锁计数器” 的初始值为 count，每当一个线程调用该 CountDownLatch 对象的 countDown()方法时，才将 “锁计数器”减1；通过这种方式，必须有 count 个线程调用 countDown() 之后，“锁计数器”才为 0，而前面提到的等待线程才能继续运行！</p>
<p>以上，就是 CountDownLatch 的实现原理。</p>
<h2 id="CountDownLatch-的使用示例"><a href="#CountDownLatch-的使用示例" class="headerlink" title="CountDownLatch 的使用示例"></a><strong><a></a>CountDownLatch 的使用示例</strong></h2><p>下面通过 CountDownLatch 实现：”主线程” 等待 “5 个子线程” 全部都完成 “指定的工作 (休眠 1000ms)” 之后，再继续运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> LATCH_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doneSignal = <span class="keyword">new</span> CountDownLatch(LATCH_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新建5个任务</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;LATCH_SIZE; i++)</span><br><span class="line">                <span class="keyword">new</span> InnerThread().start();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"main await begin."</span>);</span><br><span class="line">            <span class="comment">// "主线程"等待线程池中5个任务的完成</span></span><br><span class="line">            doneSignal.await();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"main await finished."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" sleep 1000ms."</span>);</span><br><span class="line">                <span class="comment">// 将CountDownLatch的数值减1</span></span><br><span class="line">                doneSignal.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main await begin.</span><br><span class="line">Thread-0 sleep 1000ms.</span><br><span class="line">Thread-2 sleep 1000ms.</span><br><span class="line">Thread-1 sleep 1000ms.</span><br><span class="line">Thread-4 sleep 1000ms.</span><br><span class="line">Thread-3 sleep 1000ms.</span><br><span class="line">main await finished.</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：主线程通过 doneSignal.await() 等待其它线程将 doneSignal 递减至 0。其它的 5 个 InnerThread 线程，每一个都通过 doneSignal.countDown() 将 doneSignal 的值减 1；当 doneSignal 为 0 时，main 被唤醒后继续执行。</p>
<hr>
<h1 id="10-CyclicBarrier原理和示例"><a href="#10-CyclicBarrier原理和示例" class="headerlink" title="10 CyclicBarrier原理和示例"></a>10 CyclicBarrier原理和示例</h1><h2 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章介绍 JUC 包中的 CyclicBarrier 锁。内容包括：<br><a href="#a1">CyclicBarrier 简介</a><br><a href="#s1">CyclicBarrier 数据结构</a><br><a href="#a2">CyclicBarrier 源码分析 (基于 JDK1.7.0_40)</a><br><a href="#a3">CyclicBarrier 示例</a></p>
<h2 id="CyclicBarrier-简介"><a href="#CyclicBarrier-简介" class="headerlink" title="CyclicBarrier 简介"></a><strong><a></a>CyclicBarrier 简介</strong></h2><p>CyclicBarrier 是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p>
<p>注意比较 <a href="http://www.cnblogs.com/skywang12345/p/3533887.html" target="_blank" rel="noopener">CountDownLatch</a> 和 <a href="http://www.cnblogs.com/skywang12345/p/3533995.html" target="_blank" rel="noopener">CyclicBarrier</a>：<br>(01) CountDownLatch 的作用是允许 1 或 N 个线程等待其他线程完成执行；而 CyclicBarrier 则是允许 N 个线程相互等待。<br>(02) CountDownLatch 的计数器无法被重置；CyclicBarrier 的计数器可以被重置后使用，因此它被称为是循环的 barrier。</p>
<p><strong>CyclicBarrier 函数列表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier(<span class="keyword">int</span> parties)</span><br><span class="line"><span class="comment">//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</span></span><br><span class="line">CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction)</span><br><span class="line"><span class="comment">//创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">//在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回当前在屏障处等待的参与者数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回要求启动此 barrier 的参与者数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//查询此屏障是否处于损坏状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//将屏障重置为其初始状态。</span></span></span><br></pre></td></tr></table></figure>
<h2 id="CyclicBarrier-数据结构"><a href="#CyclicBarrier-数据结构" class="headerlink" title="CyclicBarrier 数据结构"></a><strong><a></a>CyclicBarrier 数据结构</strong></h2><p>CyclicBarrier 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219007832876.jpg" alt=""></p>
<p>CyclicBarrier 是包含了 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">ReentrantLock</a> 对象 lock”和”<a href="http://www.cnblogs.com/skywang12345/p/3496716.html" target="_blank" rel="noopener">Condition</a> 对象 trip”，它是通过独占锁实现的。下面通过源码去分析到底是如何实现的。</p>
<h2 id="CyclicBarrier-源码分析-基于-JDK1-7-0-40"><a href="#CyclicBarrier-源码分析-基于-JDK1-7-0-40" class="headerlink" title="CyclicBarrier 源码分析 (基于 JDK1.7.0_40)"></a><strong><a></a>CyclicBarrier 源码分析 (基于 JDK1.7.0_40)</strong></h2><p><strong>CyclicBarrier 完整源码 (基于 JDK1.7.0_40)</strong></p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/CyclicBarrier.java" target="_blank" rel="noopener">CyclicBarrier.java源码</a></p>
<p>CyclicBarrier 是通过 <a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">ReentrantLock</a>(独占锁) 和 <a href="http://www.cnblogs.com/skywang12345/p/3496716.html" target="_blank" rel="noopener">Condition</a> 来实现的。下面，我们分析 CyclicBarrier 中 3 个核心函数: 构造函数, await() 作出分析。</p>
<p><strong>1. 构造函数</strong></p>
<p>CyclicBarrier 的构造函数共 2 个：CyclicBarrier 和 CyclicBarrier(int parties, Runnable barrierAction)。第 1 个构造函数是调用第 2 个构造函数来实现的，下面第 2 个构造函数的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// parties表示“必须同时到达barrier的线程个数”。</span></span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="comment">// count表示“处在等待状态的线程个数”。</span></span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="comment">// barrierCommand表示“parties个线程到达barrier时，会执行的动作”。</span></span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 等待函数</strong></p>
<p>CyclicBarrier.java 中 await() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：await() 是通过 dowait() 实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取“独占锁(lock)”</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保存“当前的generation”</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若“当前generation已损坏”，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程被中断，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将“count计数器”-1</span></span><br><span class="line">       <span class="keyword">int</span> index = --count;</span><br><span class="line">       <span class="comment">// 如果index=0，则意味着“有parties个线程到达barrier”。</span></span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">           <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果barrierCommand不为null，则执行该动作。</span></span><br><span class="line">               <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">               <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                   command.run();</span><br><span class="line">               ranAction = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">// 唤醒所有等待线程，并更新generation。</span></span><br><span class="line">               nextGeneration();</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                   breakBarrier();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，</span></span><br><span class="line">        <span class="comment">// 当前线程才继续执行。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是“超时等待”，则调用awati()进行等待；否则，调用awaitNanos()进行等待。</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果等待过程中，线程被中断，则执行下面的函数。</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果“当前generation已经损坏”，则抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果“generation已经换代”，则返回index。</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是“超时等待”，并且时间已到，则通过breakBarrier()终止CyclicBarrier，唤醒CyclicBarrier中所有等待线程。</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放“独占锁(lock)”</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：dowait()的作用就是让当前线程阻塞，直到 “有 parties 个线程到达 barrier” 或 “当前线程被中断” 或 “超时” 这 3 者之一发生，当前线程才继续执行。<br>(01) generation 是 CyclicBarrier 的一个成员遍历，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CyclicBarrier 中，同一批的线程属于同一代，即同一个 Generation；CyclicBarrier 中通过 generation 对象，记录属于哪一代。<br>当有 parties 个线程到达 barrier，generation 就会被更新换代。</p>
<p>(02) 如果当前线程被中断，即 Thread.interrupted() 为 true；则通过 breakBarrier() 终止 CyclicBarrier。breakBarrier() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>breakBarrier()会设置当前中断标记 broken 为 true，意味着 “将该 Generation 中断”；同时，设置 count=parties，即重新初始化 count；最后，通过 signalAll() 唤醒 CyclicBarrier 上所有的等待线程。</p>
<p>(03) 将 “count 计数器”-1，即 –count；然后判断是不是 “有 parties 个线程到达 barrier”，即 index 是不是为 0。<br>当 index=0 时，如果 barrierCommand 不为 null，则执行该 barrierCommand，barrierCommand 就是我们创建 CyclicBarrier 时，传入的 Runnable 对象。然后，调用 nextGeneration() 进行换代工作，nextGeneration() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，它会调用 signalAll() 唤醒 CyclicBarrier 上所有的等待线程；接着，重新初始化 count；最后，更新 generation 的值。</p>
<p>(04) 在 for(;;)循环中。timed 是用来表示当前是不是 “超时等待” 线程。如果不是，则通过 trip.await()进行等待；否则，调用 awaitNanos()进行超时等待。</p>
<h2 id="CyclicBarrier-的使用示例"><a href="#CyclicBarrier-的使用示例" class="headerlink" title="CyclicBarrier 的使用示例"></a><strong><a></a>CyclicBarrier 的使用示例</strong></h2><p><strong>示例 1</strong><br>新建 5 个线程，这 5 个线程达到一定的条件时，它们才继续往后运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        cb = <span class="keyword">new</span> CyclicBarrier(SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)</span><br><span class="line">            <span class="keyword">new</span> InnerThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" wait for CyclicBarrier."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将cb的参与者数量加1</span></span><br><span class="line">                cb.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// cb的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" continued."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 wait for CyclicBarrier.</span><br><span class="line">Thread-2 wait for CyclicBarrier.</span><br><span class="line">Thread-3 wait for CyclicBarrier.</span><br><span class="line">Thread-4 wait for CyclicBarrier.</span><br><span class="line">Thread-0 wait for CyclicBarrier.</span><br><span class="line">Thread-0 continued.</span><br><span class="line">Thread-4 continued.</span><br><span class="line">Thread-2 continued.</span><br><span class="line">Thread-3 continued.</span><br><span class="line">Thread-1 continued.</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：主线程中新建了 5 个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到 cb 中所有线程都达到 barrier 时，这些线程才继续运行！</p>
<p><strong>示例 2</strong></p>
<p>新建 5 个线程，当这 5 个线程达到一定的条件时，执行某项任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        cb = <span class="keyword">new</span> CyclicBarrier(SIZE, <span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"CyclicBarrier's parties is: "</span>+ cb.getParties());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)</span><br><span class="line">            <span class="keyword">new</span> InnerThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" wait for CyclicBarrier."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将cb的参与者数量加1</span></span><br><span class="line">                cb.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// cb的参与者数量等于5时，才继续往后执行</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" continued."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 wait for CyclicBarrier.</span><br><span class="line">Thread-2 wait for CyclicBarrier.</span><br><span class="line">Thread-3 wait for CyclicBarrier.</span><br><span class="line">Thread-4 wait for CyclicBarrier.</span><br><span class="line">Thread-0 wait for CyclicBarrier.</span><br><span class="line">CyclicBarrier's parties is: 5</span><br><span class="line">Thread-0 continued.</span><br><span class="line">Thread-4 continued.</span><br><span class="line">Thread-2 continued.</span><br><span class="line">Thread-3 continued.</span><br><span class="line">Thread-1 continued.</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：主线程中新建了 5 个线程，所有的这些线程都调用 cb.await() 等待。所有这些线程一直等待，直到 cb 中所有线程都达到 barrier 时，执行新建 cb 时注册的 Runnable 任务。</p>
<hr>
<h1 id="11-Semaphore信号量的原理和示例"><a href="#11-Semaphore信号量的原理和示例" class="headerlink" title="11 Semaphore信号量的原理和示例"></a>11 Semaphore信号量的原理和示例</h1><h2 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a><strong>概要</strong></h2><p>本章，我们对 JUC 包中的信号量 Semaphore 进行学习。内容包括：<br><a href="#a1">Semaphore 简介</a><br><a href="#s1">Semaphore 数据结构</a><br><a href="#a2">Semaphore 源码分析 (基于 JDK1.7.0_40)</a><br><a href="#a3">Semaphore 示例</a></p>
<h2 id="Semaphore-简介"><a href="#Semaphore-简介" class="headerlink" title="Semaphore 简介"></a><strong><a></a>Semaphore 简介</strong></h2><p>Semaphore 是一个计数信号量，它的本质是一个 “ <a href="http://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">共享锁</a> “。</p>
<p>信号量维护了一个信号量许可集。线程可以通过调用 acquire() 来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过 release() 来释放它所持有的信号量许可。</p>
<p><strong>Semaphore 的函数列表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建具有给定的许可数和非公平的公平设置的 Semaphore。</span></span><br><span class="line">Semaphore(<span class="keyword">int</span> permits)</span><br><span class="line"><span class="comment">// 创建具有给定的许可数和给定的公平设置的 Semaphore。</span></span><br><span class="line">Semaphore(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞，或者线程已被中断。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此信号量中获取许可，在有可用的许可前将其阻塞。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回此信号量中当前可用的许可数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取并返回立即可用的所有许可。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个 collection，包含可能等待获取的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回正在等待获取的线程的估计数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查询是否有线程正在等待获取。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果此信号量的公平设置为 true，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 根据指定的缩减量减小可用许可的数目。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reduction)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 释放一个许可，将其返回给信号量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 释放给定数目的许可，将其返回到信号量。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回标识此信号量的字符串，以及信号量的状态。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 仅在调用时此信号量中有给定数目的许可时，才从此信号量中获取这些许可。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果在给定的等待时间内此信号量有可用的所有许可，并且当前线程未被中断，则从此信号量获取给定数目的许可。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果在给定的等待时间内，此信号量有可用的许可并且当前线程未被中断，则从此信号量获取一个许可。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Semaphore-数据结构"><a href="#Semaphore-数据结构" class="headerlink" title="Semaphore 数据结构"></a><strong><a></a>Semaphore 数据结构</strong></h3><p>Semaphore 的 UML 类图如下：</p>
<p><img src="http://p4lmrb1gp.bkt.clouddn.com/15219008098919.jpg" alt=""></p>
<p>从图中可以看出： <a href="#a1"></a> (01) 和 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">ReentrantLock</a>“ 一样，Semaphore 也包含了 sync 对象，sync 是 Sync 类型；而且，Sync 是一个继承于 AQS 的抽象类。 <a href="#a1"></a> (02) Sync 包括两个子类：”公平信号量”FairSync 和 “非公平信号量”NonfairSync。sync 是 “FairSync 的实例”，或者 “NonfairSync 的实例”；默认情况下，sync 是 NonfairSync(即，默认是非公平信号量)。</p>
<h2 id="Semaphore-源码分析-基于-JDK1-7-0-40"><a href="#Semaphore-源码分析-基于-JDK1-7-0-40" class="headerlink" title="Semaphore 源码分析 (基于 JDK1.7.0_40)"></a><strong><a></a>Semaphore 源码分析 (基于 JDK1.7.0_40)</strong></h2><p><strong>Semaphore 完整源码 (基于 JDK1.7.0_40)</strong></p>
<p><a href="http://p4lmrb1gp.bkt.clouddn.com/Semaphore.java" target="_blank" rel="noopener">Semaphore.java源码</a></p>
<p>Semaphore 是通过<a href="http://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">共享锁</a>实现的。根据共享锁的获取原则，Semaphore 分为 “公平信号量” 和 “非公平信号量”。</p>
<p><strong>“公平信号量” 和 “非公平信号量” 的区别</strong></p>
<p>“公平信号量” 和 “非公平信号量” 的释放信号量的机制是一样的！不同的是它们获取信号量的机制：线程在尝试获取信号量许可时，对于公平信号量而言，如果当前线程不在 CLH 队列的头部，则排队等候；而对于非公平信号量而言，无论当前线程是不是在 CLH 队列的头部，它都会直接获取信号量。该差异具体的体现在，它们的 tryAcquireShared() 函数的实现不同。</p>
<p><strong>“公平信号量” 类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>“非公平信号量” 类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们逐步的对它们的源码进行分析。</p>
<p><strong>1. 信号量构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中，我们可以信号量分为 “公平信号量(FairSync)” 和“非公平信号量 (NonfairSync)”。Semaphore(int permits) 函数会默认创建“非公平信号量”。</p>
<p><strong>2. 公平信号量获取和释放</strong></p>
<p><strong>2.1 公平信号量的获取</strong><br>Semaphore 中的公平信号量是 FairSync。它的获取 API 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量中的 acquire() 获取函数，实际上是调用的 AQS 中的 acquireSharedInterruptibly()。</p>
<p>acquireSharedInterruptibly() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程是中断状态，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 否则，尝试获取“共享锁”；获取成功则直接返回，获取失败，则通过doAcquireSharedInterruptibly()获取。</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Semaphore 中”公平锁 “对应的 tryAcquireShared() 实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 判断“当前线程”是不是CLH队列中的第一个线程线程，</span></span><br><span class="line">        <span class="comment">// 若是的话，则返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置“可以获得的信号量的许可数”</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 设置“获得acquires个信号量许可之后，剩余的信号量许可数”</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">// 如果“剩余的信号量许可数&gt;=0”，则设置“可以获得的信号量许可数”为remaining。</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：tryAcquireShared() 的作用是尝试获取 acquires 个信号量许可数。<br>对于 Semaphore 而言，state 表示的是 “当前可获得的信号量许可数”。</p>
<p>下面看看 AQS 中 doAcquireSharedInterruptibly() 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建”当前线程“的Node节点，且Node中记录的锁是”共享锁“类型；并将该节点添加到CLH队列末尾。</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取上一个节点。</span></span><br><span class="line">            <span class="comment">// 如果上一节点是CLH队列的表头，则”尝试获取共享锁“。</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">long</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前线程一直等待，直到获取到共享锁。</span></span><br><span class="line">            <span class="comment">// 如果线程在等待过程中被中断过，则再次中断该线程(还原之前的中断状态)。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁 (或被中断) 才返回。<br>(01) addWaiter(Node.SHARED)的作用是，创建”当前线程 “的 Node 节点，且 Node 中记录的锁的类型是” 共享锁“(Node.SHARED)；并将该节点添加到 CLH 队列末尾。关于 Node 和 CLH 在 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a>“ 已经详细介绍过，这里就不再重复说明了。<br>(02) node.predecessor() 的作用是，获取上一个节点。如果上一节点是 CLH 队列的表头，则” 尝试获取共享锁 “。<br>(03) shouldParkAfterFailedAcquire() 的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回 true；否则，返回 false。<br>(04) 当 shouldParkAfterFailedAcquire() 返回 ture 时，则调用 parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。<br>doAcquireSharedInterruptibly() 中的 shouldParkAfterFailedAcquire(), parkAndCheckInterrupt 等函数在 “<a href="http://www.cnblogs.com/skywang12345/p/3496147.html" target="_blank" rel="noopener">Java 多线程系列 –“JUC 锁”03 之 公平锁 (一)</a>“ 中介绍过，这里也就不再详细说明了。</p>
<p><strong>2.2 公平信号量的释放</strong></p>
<p>Semaphore 中公平信号量 (FairSync) 的释放 API 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量的 releases() 释放函数，实际上是调用的 AQS 中的 releaseShared()。</p>
<p>releaseShared() 在 AQS 中实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：releaseShared() 的目的是让当前线程释放它所持有的共享锁。<br>它首先会通过 tryReleaseShared() 去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过 doReleaseShared() 去释放共享锁。</p>
<p>Semaphore 重写了 tryReleaseShared()，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取“可以获得的信号量的许可数”</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 获取“释放releases个信号量许可之后，剩余的信号量许可数”</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置“可以获得的信号量的许可数”为next。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 tryReleaseShared() 尝试释放共享锁失败，则会调用 doReleaseShared() 去释放共享锁。doReleaseShared() 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取CLH队列的头节点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果头节点不为null，并且头节点不等于tail节点。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// 获取头节点对应的线程的状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 唤醒“头节点的下一个节点所对应的线程”。</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头节点发生变化，则继续循环。否则，退出循环。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：doReleaseShared()会释放 “共享锁”。它会从前往后的遍历 CLH 队列，依次“唤醒” 然后 “执行” 队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的信号量。</p>
<p><strong>3 非公平信号量获取和释放</strong></p>
<p>Semaphore 中的非公平信号量是 NonFairSync。在 Semaphore 中，“非公平信号量许可的释放 (release)” 与“公平信号量许可的释放 (release)” 是一样的。<br>不同的是它们获取 “信号量许可” 的机制不同，下面是非公平信号量获取信号量许可的代码。</p>
<p>非公平信号量的 tryAcquireShared() 实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nonfairTryAcquireShared() 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 设置“可以获得的信号量的许可数”</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 设置“获得acquires个信号量许可之后，剩余的信号量许可数”</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">// 如果“剩余的信号量许可数&gt;=0”，则设置“可以获得的信号量许可数”为remaining。</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：非公平信号量的 tryAcquireShared()调用 AQS 中的 nonfairTryAcquireShared()。而在 nonfairTryAcquireShared()的 for 循环中，它都会直接判断 “当前剩余的信号量许可数” 是否足够；足够的话，则直接“设置可以获得的信号量许可数”，进而再获取信号量。<br>而公平信号量的 tryAcquireShared() 中，在获取信号量之前会通过 if (hasQueuedPredecessors()) 来判断 “当前线程是不是在 CLH 队列的头部”，是的话，则返回 - 1。 </p>
<h2 id="Semaphore-示例"><a href="#Semaphore-示例" class="headerlink" title="Semaphore 示例"></a><strong><a></a>Semaphore 示例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest1</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEM_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Semaphore sem = <span class="keyword">new</span> Semaphore(SEM_MAX);</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//在线程池中执行任务</span></span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> MyThread(sem, <span class="number">5</span>));</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> MyThread(sem, <span class="number">4</span>));</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> MyThread(sem, <span class="number">7</span>));</span><br><span class="line">        <span class="comment">//关闭池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Semaphore sem;    <span class="comment">// 信号量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;        <span class="comment">// 申请信号量的大小 </span></span><br><span class="line"></span><br><span class="line">    MyThread(Semaphore sem, <span class="keyword">int</span> count) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sem = sem;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从信号量中获取count个许可</span></span><br><span class="line">            sem.acquire(count);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" acquire count="</span>+count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放给定数目的许可，将其返回到信号量。</span></span><br><span class="line">            sem.release(count);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" release "</span> + count + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(某一次) 运行结果：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 acquire count=5</span><br><span class="line">pool-1-thread-2 acquire count=4</span><br><span class="line">pool-1-thread-1 release 5</span><br><span class="line">pool-1-thread-2 release 4</span><br><span class="line">pool-1-thread-3 acquire count=7</span><br><span class="line">pool-1-thread-3 release 7</span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：信号量 sem 的许可总数是 10 个；共 3 个线程，分别需要获取的信号量许可数是 5,4,7。前面两个线程获取到信号量的许可后，sem 中剩余的可用的许可数是 1；因此，最后一个线程必须等前两个线程释放了它们所持有的信号量许可之后，才能获取到 7 个信号量许可。</p>
<hr>
<blockquote>
<p>原文地址：<br><a href="http://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/java_threads_category.html</a></p>
</blockquote>

      
    </div>
    
    
    


     
    
      <div>
        
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>

      </div>
    


    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    CloudPai
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://cloudpai.site/2018/03/24/2018-03-24-1/" title="java多线程系列三：JUC锁">http://cloudpai.site/2018/03/24/2018-03-24-1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    




    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
            <a href="/tags/并发/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/24/2018-03-24/" rel="next" title="java多线程系列二：JUC原子类">
                <i class="fa fa-chevron-left"></i> java多线程系列二：JUC原子类
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/24/2018-03-24-2/" rel="prev" title="java多线程系列四：JUC集合">
                java多线程系列四：JUC集合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>




  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p4lmrb1gp.bkt.clouddn.com/君名-squashed.jpg"
                alt="CloudPai" />
            
              <p class="site-author-name" itemprop="name">CloudPai</p>
              <p class="site-description motion-element" itemprop="description">加油(๑•̀ㅂ•́)و✧加油</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">129</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=240 src="//music.163.com/outchain/player?type=0&id=2113726971&auto=0&height=430"></iframe>
</div>
<!-- 459004290 -->




            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CloudPai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liupai024@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/57965969/doulists/all" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-book"></i>豆瓣</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/cloudPai/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-edit"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dlut.edu.cn/" title="DUT" target="_blank">DUT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bupt.edu.cn/" title="BUPT" target="_blank">BUPT</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://campus.alibaba.com/index.htm" title="Alibaba Group" target="_blank">Alibaba Group</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#01-框架"><span class="nav-text">01 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#同步锁"><span class="nav-text">同步锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC-包中的锁"><span class="nav-text">JUC 包中的锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#02-互斥锁ReentrantLock"><span class="nav-text">02 互斥锁ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-介绍"><span class="nav-text">ReentrantLock 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-函数列表"><span class="nav-text">ReentrantLock 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-示例"><span class="nav-text">ReentrantLock 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#03-公平锁-一"><span class="nav-text">03 公平锁(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-数据结构"><span class="nav-text">ReentrantLock 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考代码"><span class="nav-text">参考代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取公平锁-基于-JDK1-7-0-40"><span class="nav-text">获取公平锁 (基于 JDK1.7.0_40)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-tryAcquire"><span class="nav-text">一. tryAcquire()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-addWaiter-Node-EXCLUSIVE"><span class="nav-text">二. addWaiter(Node.EXCLUSIVE)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-acquireQueued"><span class="nav-text">三. acquireQueued()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-selfInterrupt"><span class="nav-text">四. selfInterrupt()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-公平锁-二"><span class="nav-text">04 公平锁(二)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-1"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放公平锁-基于-JDK1-7-0-40"><span class="nav-text">释放公平锁 (基于 JDK1.7.0_40)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#05-非公平锁"><span class="nav-text">05 非公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-2"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取非公平锁-基于-JDK1-7-0-40"><span class="nav-text">获取非公平锁 (基于 JDK1.7.0_40)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放非公平锁-基于-JDK1-7-0-40"><span class="nav-text">释放非公平锁 (基于 JDK1.7.0_40)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#06-Condition条件"><span class="nav-text">06 Condition条件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-3"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition-介绍"><span class="nav-text">Condition 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition-函数列表"><span class="nav-text">Condition 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition-示例"><span class="nav-text">Condition 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#07-LockSupport"><span class="nav-text">07 LockSupport</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LockSupport-介绍"><span class="nav-text">LockSupport 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LockSupport-函数列表"><span class="nav-text">LockSupport 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LockSupport-参考代码-基于-JDK1-7-0-40"><span class="nav-text">LockSupport 参考代码 (基于 JDK1.7.0_40)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LockSupport-示例"><span class="nav-text">LockSupport 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#08-共享锁和ReentrantReadWriteLock"><span class="nav-text">08 共享锁和ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-4"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock-和-ReentrantReadWriteLock-介绍"><span class="nav-text">ReadWriteLock 和 ReentrantReadWriteLock 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock-和-ReentrantReadWriteLock-函数列表"><span class="nav-text">ReadWriteLock 和 ReentrantReadWriteLock 函数列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantReadWriteLock-数据结构"><span class="nav-text">ReentrantReadWriteLock 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考代码-基于-JDK1-7-0-40"><span class="nav-text">参考代码 (基于 JDK1.7.0_40)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取共享锁"><span class="nav-text">获取共享锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放共享锁"><span class="nav-text">释放共享锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公平共享锁和非公平共享锁"><span class="nav-text">公平共享锁和非公平共享锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantReadWriteLock-示例"><span class="nav-text">ReentrantReadWriteLock 示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#09-CountDownLatch原理和示例"><span class="nav-text">09 CountDownLatch原理和示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-5"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-简介"><span class="nav-text">CountDownLatch 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-数据结构"><span class="nav-text">CountDownLatch 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-源码分析-基于-JDK1-7-0-40"><span class="nav-text">CountDownLatch 源码分析 (基于 JDK1.7.0_40)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-的使用示例"><span class="nav-text">CountDownLatch 的使用示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-CyclicBarrier原理和示例"><span class="nav-text">10 CyclicBarrier原理和示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-6"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier-简介"><span class="nav-text">CyclicBarrier 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier-数据结构"><span class="nav-text">CyclicBarrier 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier-源码分析-基于-JDK1-7-0-40"><span class="nav-text">CyclicBarrier 源码分析 (基于 JDK1.7.0_40)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier-的使用示例"><span class="nav-text">CyclicBarrier 的使用示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Semaphore信号量的原理和示例"><span class="nav-text">11 Semaphore信号量的原理和示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概要-7"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-简介"><span class="nav-text">Semaphore 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore-数据结构"><span class="nav-text">Semaphore 数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-源码分析-基于-JDK1-7-0-40"><span class="nav-text">Semaphore 源码分析 (基于 JDK1.7.0_40)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-示例"><span class="nav-text">Semaphore 示例</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CloudPai</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">626.3k</span>
  
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">  </span>
</span>
</div>







  <div class="theme-info">&#12288;主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://cloudpai.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://cloudpai.site/2018/03/24/2018-03-24-1/';
          this.page.identifier = '2018/03/24/2018-03-24-1/';
          this.page.title = 'java多线程系列三：JUC锁';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://cloudpai.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  <!-- <!-- <script src="https://cdn.bootcss.com/aplayer/1.6.0/APlayer.min.js"></script>

<script src="https://api.i-meto.com/music/player.js"></script> --> -->
  
  <!--移动端判断，是否引入背景-->
  <script>
  var browser={  
      versions:function(){   
             var u = navigator.userAgent, app = navigator.appVersion;   
             return {//移动终端浏览器版本信息
                  trident: u.indexOf('Trident') > -1, //IE内核
                  presto: u.indexOf('Presto') > -1, //opera内核
                  webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                  gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                  mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                  ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                  android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                  iPhone: u.indexOf('iPhone') > -1 , //是否为iPhone或者QQHD浏览器
                  iPad: u.indexOf('iPad') > -1, //是否iPad
                  webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
              };  
           }(),  
           language:(navigator.browserLanguage || navigator.language).toLowerCase()  
  }   
    if(browser.versions.mobile || browser.versions.ios || browser.versions.android ||   
      browser.versions.iPhone || browser.versions.iPad){        
               
    }else{
    document.write("<script type=\'text/javascript\'  src=\'/js/src/particle.js\'><\/script>");
    }
  </script>

  
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":-80,"vOffset":-50},"mobile":{"show":false,"scale":0.2},"react":{"opacityDefault":1,"opacityOnHover":0.2}});</script></body>
</html>
